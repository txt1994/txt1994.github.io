<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>适用于Keil的插件合集</title>
    <link href="/2023/07/11/Keil%E6%8F%92%E4%BB%B6%E5%90%88%E9%9B%86/"/>
    <url>/2023/07/11/Keil%E6%8F%92%E4%BB%B6%E5%90%88%E9%9B%86/</url>
    
    <content type="html"><![CDATA[<div class="toc"><!-- toc --><ul><li><a href="#1-astyle">1.AStyle</a><ul><li><a href="#1-1-astyle-ke-yi-dui-dai-ma-jin-xing-ge-shi-hua-fen-bie-shi-dui-dan-ge-wen-jian-ge-shi-hua-ming-ling">1.1 AStyle可以对代码进行格式化分别是对单个文件格式化，命令：</a></li></ul></li><li><a href="#2-filecomments">2.FileComments</a><ul><li><a href="#2-1-filecomments-ke-yi-dui-h-he-c-jin-xing-kuai-su-tian-jia-zhu-shi-dan-xu-yao-mo-ban-wen-jian-ci-wen-jian-zai-zui-xia-mian-ti-gong-xia-zai-ming-ling">2.1 FileComments可以对*.h和*.c进行快速添加注释，但需要模版文件，此文件在最下面提供下载，命令：</a></li></ul></li><li><a href="#3-datetime">3.DateTime</a><ul><li><a href="#3-1-datetime-ke-yi-shi-bie-dang-qian-ri-qi-he-shi-jian-yong-de-bu-duo-ming-ling">3.1 DateTime可以识别当前日期和时间，用的不多，命令：</a></li></ul></li><li><a href="#4-functioncomment">4.FunctionComment</a><ul><li><a href="#4-1-functioncomment-ke-yi-ti-gong-han-shu-kuai-su-tian-jia-zhu-shi-ming-ling">4.1 FunctionComment可以提供函数快速添加注释，命令：</a></li></ul></li></ul><!-- tocstop --></div><p>本人收集的Keil插件，当然也可用于其他软件</p><h2><span id="1-astyle">1.AStyle</span><a href="#1-astyle" class="header-anchor">#</a></h2><h3><span id="1-1-astyle-ke-yi-dui-dai-ma-jin-xing-ge-shi-hua-fen-bie-shi-dui-dan-ge-wen-jian-ge-shi-hua-ming-ling">1.1 AStyle可以对代码进行格式化分别是对单个文件格式化，命令：</span><a href="#1-1-astyle-ke-yi-dui-dai-ma-jin-xing-ge-shi-hua-fen-bie-shi-dui-dan-ge-wen-jian-ge-shi-hua-ming-ling" class="header-anchor">#</a></h3><div class="code-wrapper"><pre><code class="hljs shell">-n !E --style=google -s4</code></pre></div><p>对多个文件格式化，但需要在同一个文件夹，命令：</p><div class="code-wrapper"><pre><code class="hljs shell">-n "$E*.c" "$E*.h" --style=google -p -s4 -S -f -xW -w -xw -R</code></pre></div><h2><span id="2-filecomments">2.FileComments</span><a href="#2-filecomments" class="header-anchor">#</a></h2><h3><span id="2-1-filecomments-ke-yi-dui-h-he-c-jin-xing-kuai-su-tian-jia-zhu-shi-dan-xu-yao-mo-ban-wen-jian-ci-wen-jian-zai-zui-xia-mian-ti-gong-xia-zai-ming-ling">2.1 FileComments可以对*.h和*.c进行快速添加注释，但需要模版文件，此文件在最下面提供下载，命令：</span><a href="#2-1-filecomments-ke-yi-dui-h-he-c-jin-xing-kuai-su-tian-jia-zhu-shi-dan-xu-yao-mo-ban-wen-jian-ci-wen-jian-zai-zui-xia-mian-ti-gong-xia-zai-ming-ling" class="header-anchor">#</a></h3><div class="code-wrapper"><pre><code class="hljs shell">!E</code></pre></div><h2><span id="3-datetime">3.DateTime</span><a href="#3-datetime" class="header-anchor">#</a></h2><h3><span id="3-1-datetime-ke-yi-shi-bie-dang-qian-ri-qi-he-shi-jian-yong-de-bu-duo-ming-ling">3.1 DateTime可以识别当前日期和时间，用的不多，命令：</span><a href="#3-1-datetime-ke-yi-shi-bie-dang-qian-ri-qi-he-shi-jian-yong-de-bu-duo-ming-ling" class="header-anchor">#</a></h3><p>当前日期：</p><div class="code-wrapper"><pre><code class="hljs shell">!E ~E ^E</code></pre></div><p>当前时间：</p><div class="code-wrapper"><pre><code class="hljs shell">!E ~E ^E T</code></pre></div><h2><span id="4-functioncomment">4.FunctionComment</span><a href="#4-functioncomment" class="header-anchor">#</a></h2><h3><span id="4-1-functioncomment-ke-yi-ti-gong-han-shu-kuai-su-tian-jia-zhu-shi-ming-ling">4.1 FunctionComment可以提供函数快速添加注释，命令：</span><a href="#4-1-functioncomment-ke-yi-ti-gong-han-shu-kuai-su-tian-jia-zhu-shi-ming-ling" class="header-anchor">#</a></h3><div class="code-wrapper"><pre><code class="hljs shell">!E ~E</code></pre></div><p>把这些插件添加到keil中，打开keil，依次点击Tools-&gt;Customize Tools Menu,此时页面是这样的：<br><img src="/img/155637.png"></p><p>把上述的插件添加进去，Command是插件路径，Arguments是使用插件时的参数，可以根据需要自行定制</p><p>添加插件的快捷键：点击keil页面的小扳手，找到Shortcut Keys,把下拉框拉到刚才添加的插件处，右边是添加快键键的地方，添加后可以使用了</p>]]></content>
    
    
    
    <tags>
      
      <tag>Keil</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>第五部分-专业工具</title>
    <link href="/2022/03/19/%E7%AC%AC%E4%BA%94%E9%83%A8%E5%88%86%20%E4%B8%93%E4%B8%9A%E5%B7%A5%E5%85%B7%20/"/>
    <url>/2022/03/19/%E7%AC%AC%E4%BA%94%E9%83%A8%E5%88%86%20%E4%B8%93%E4%B8%9A%E5%B7%A5%E5%85%B7%20/</url>
    
    <content type="html"><![CDATA[<h2><span id="di-wu-bu-fen-zhuan-ye-gong-ju">第五部分 专业工具</span><a href="#di-wu-bu-fen-zhuan-ye-gong-ju" class="header-anchor">#</a></h2><p>这部分介绍了普通应用程序程序员通常不必知道的新语言和库特性。 它可能涵盖基础库、特定模式或特殊环境中的程序员的工具。</p><h3><span id="27-duo-tai-de-nei-cun-zi-yuan-pmr">27  多态的内存资源 (PMR)</span><a href="#27-duo-tai-de-nei-cun-zi-yuan-pmr" class="header-anchor">#</a></h3><p>自C++98以来，标准库就支持配置类分配其内部（堆）内存的方式的能力。由于这个原因，标准库中几乎所有分配内存的类型都有一个分配器参数。因此，你可以配置容器、字符串和其他类型分配其内部内存的方式，如果它们需要比堆栈上分配的空间更多的话。<br>分配这种内存的默认方式是从堆中分配。但是有不同的理由来修改这个默认行为：</p><ul><li>你可以使用你自己的方式分配内存，以减少系统调用的数量。</li><li>你可以确保分配的内存位于彼此的旁边，以从CPU缓存中获益。</li><li>你可以把容器和它们的元素放在可供多进程使用的共享内存中。</li><li>你甚至可以重定向这些堆内存调用，以使用早期在堆栈上分配的内存。因此，可以有性能和功能方面的原因。</li></ul><p>然而，在C++17之前，使用分配器（右）在很多方面都是既棘手又笨拙的（由于一些缺陷，太过复杂，以及与后向兼容的修改）。<br>现在，C++17为预定义和用户定义的内存分配方式提供了一个相当容易使用的方法，它可以用于标准类型和用户定义的类型。<br>基于这个原因，本章将讨论：</p><ul><li>使用标准库提供的标准内存资源</li><li>定义自定义内存资源</li><li>为自定义类型提供内存资源支持</li></ul><p>如果没有Pablo Halpern、Arthur O’Dwyer、David Sankel和Jonathan Wakely的大力帮助，本章就不可能完成。一些视频解释了这里提供的功能：</p><ul><li>分配器：Pablo Halpern 的好零件</li><li>C++17 的 std::pmr 有代价 David Sankel</li><li>分配器是 Arthur O’Dwyer 的堆句柄</li></ul><h4><span id="27-1-shi-yong-biao-zhun-nei-cun-zi-yuan">27.1 使用标准内存资源</span><a href="#27-1-shi-yong-biao-zhun-nei-cun-zi-yuan" class="header-anchor">#</a></h4><p>本节介绍了标准内存资源以及如何使用它们。</p><h5><span id="27-1-1-ji-li-xing-de-li-zi">27.1.1 激励性的例子</span><a href="#27-1-1-ji-li-xing-de-li-zi" class="header-anchor">#</a></h5><p>让我们首先比较一下没有和有标准内存资源的内存消耗。</p><h6><span id="wei-rong-qi-he-zi-fu-chuan-fen-pei-nei-cun">为容器和字符串分配内存</span><a href="#wei-rong-qi-he-zi-fu-chuan-fen-pei-nei-cun" class="header-anchor">#</a></h6><p>假设在你的程序中，你有一个由一些字符串组成的向量，你用相当长的方式初始化这些字符串字符串：</p><p><code>pmr/pmr0.cpp </code></p><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">"../lang/tracknew.hpp"</span></span><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>{    TrackNew::<span class="hljs-built_in">reset</span>();    std::vector&lt;std::string&gt; coll;    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>; i &lt; <span class="hljs-number">1000</span>; ++i) {        coll.<span class="hljs-built_in">emplace_back</span>(<span class="hljs-string">"just a non-SSO string"</span>);    }    TrackNew::<span class="hljs-built_in">status</span>();}</code></pre></div><p>注意，我们使用一个类来跟踪内存分配的数量，该类跟踪所有用以下循环执行的::new调用：</p><div class="code-wrapper"><pre><code class="hljs c++">std::vector&lt;std::string&gt; coll;<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>; i &lt; <span class="hljs-number">1000</span>; ++i) {    coll.<span class="hljs-built_in">emplace_back</span>(<span class="hljs-string">"just a non-SSO string"</span>);}</code></pre></div><p>有很多的分配，因为  vector 内部使用内存来存储元素。此外，字符串元素本身可能会在堆上分配内存以保存其当前值（由于经常实现小字符串优化，这通常只在字符串超过15个字符时发生）。<br>该程序的输出可能类似于以下内容。</p><div class="code-wrapper"><pre><code class="hljs bash">1018 allocations <span class="hljs-keyword">for</span> 134,730 bytes</code></pre></div><p>这将意味着为每个元素分配一次，加上  vector 内部的18次分配，因为它18次分配（更多）内存来容纳其元素。<br>这样的行为可能变得很关键，因为内存（重新）分配需要时间，在某些情况下（如嵌入式系统），分配堆内存可能是个问题。<br>我们可以要求  vector 在前面预留足够的内存，但一般来说，你无法避免重新分配，除非你知道前面要处理的数据量。如果你不知道到底要处理多少数据，你总是要在避免重新分配和不浪费太多内存之间找到一个折中点。而你至少需要1001个分配（一个分配用于保存向量中的元素，一个用于不使用小字符串优化的每个字符串）。</p><h6><span id="bu-wei-rong-qi-fen-pei-nei-cun">不为容器分配内存</span><a href="#bu-wei-rong-qi-fen-pei-nei-cun" class="header-anchor">#</a></h6><p>通过使用多态分配器，我们可以轻松地改善这种情况。首先，我们可以使用std::pmr::vector，让向量在堆栈中分配其内存。<br><code>pmr/pmr1.cpp</code>。</p><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;array&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstdlib&gt;</span> <span class="hljs-comment">// for std::byte</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;memory_resource&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">"../lang/tracknew.hpp"</span></span><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>{    TrackNew::<span class="hljs-built_in">reset</span>();    <span class="hljs-comment">// 在堆栈上分配一些内存:</span>    std::array&lt;std::byte, 200000&gt; buf;    <span class="hljs-comment">// 并将其用作vector的初始内存池：</span>    std::pmr::monotonic_buffer_resource pool{buf.<span class="hljs-built_in">data</span>(), buf.<span class="hljs-built_in">size</span>()};    std::pmr::vector&lt;std::string&gt; coll{&amp;pool};    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>; i &lt; <span class="hljs-number">1000</span>; ++i) {        coll.<span class="hljs-built_in">emplace_back</span>(<span class="hljs-string">"just a non-SSO string"</span>);    }    TrackNew::<span class="hljs-built_in">status</span>();}</code></pre></div><p>首先，我们使用新类型 std::byte 在堆栈上分配我们自己的内存：</p><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-comment">// 在堆栈上分配一些内存:</span>std::array&lt;std::byte, 200000&gt; buf;</code></pre></div><p>除了 std::byte 你也可以只使用 char。<br>然后，我们用这个内存初始化一个 monotonic_buffer_resource，传递它的地址和它的大小：</p><div class="code-wrapper"><pre><code class="hljs c++">std::pmr::monotonic_buffer_resource pool{buf.<span class="hljs-built_in">data</span>(), buf.<span class="hljs-built_in">size</span>()};</code></pre></div><p>最后，我们使用一个std::pmr::vector，它占用了所有分配的内存资源:</p><div class="code-wrapper"><pre><code class="hljs c++">std::pmr::vector&lt;std::string&gt; coll{&amp;pool};</code></pre></div><p>这个声明只是以下的一个快捷方式:</p><div class="code-wrapper"><pre><code class="hljs c++">std::vector&lt;std::string,std::pmr::polymorphic_allocator&lt;std::string&gt;&gt; coll{&amp;pool};</code></pre></div><p>也就是说，我们声明向量使用多态分配器，它可以在运行时在不同的内存资源之间切换。monotonic_buffer_resource类派生于memory_resource类，因此可以作为多态分配器的内存资源。因此，通过传递我们的内存资源的地址，我们确保向量使用我们的内存资源作为多态分配器。<br>如果我们测量这个程序的分配的内存，输出结果可能是。<br>32000字节的1000次分配<br>矢量的18次分配不再是在堆上进行的。相反，我们初始化的缓冲区buf被使用。<br>如果预先分配的200000字节的内存不够用，向量仍然会在堆上分配更多的内存。发生这种情况，是因为monotonic_memory_resource使用了默认的分配器，它用new来分配内存，作为退路。</p><h6><span id="wan-quan-bu-fen-pei-nei-cun">完全不分配内存</span><a href="#wan-quan-bu-fen-pei-nei-cun" class="header-anchor">#</a></h6><p>我们甚至可以通过定义std::pmr::vector的元素类型来避免使用堆内存 的元素类型为std::pmr::string:</p><p><code>pmr/pmr2.cpp</code></p><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;array&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstdlib&gt;</span> <span class="hljs-comment">// for std::byte</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;memory_resource&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">"../lang/tracknew.hpp"</span></span><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>{    TrackNew::<span class="hljs-built_in">reset</span>();    <span class="hljs-comment">// 在堆栈中分配一些内存：</span>    std::array&lt;std::byte, 200'000&gt; buf;    <span class="hljs-comment">// 并将其作为vector及其字符串的初始内存池。:</span>    std::pmr::monotonic_buffer_resource pool{buf.<span class="hljs-built_in">data</span>(), buf.<span class="hljs-built_in">size</span>()};    std::pmr::vector&lt;std::pmr::string&gt; coll{&amp;pool};    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>; i &lt; <span class="hljs-number">1000</span>; ++i) {        coll.<span class="hljs-built_in">emplace_back</span>(<span class="hljs-string">"just a non-SSO string"</span>);    }    TrackNew::<span class="hljs-built_in">status</span>();}</code></pre></div><p>由于以下的矢量定义：</p><div class="code-wrapper"><pre><code class="hljs c++">std::pmr::vector&lt;std::pmr::string&gt; coll{&amp;pool};</code></pre></div><p>程序的输出成为:</p><div class="code-wrapper"><pre><code class="hljs bash">0 allocations <span class="hljs-keyword">for</span> 0 bytes</code></pre></div><p>原因是，默认情况下，pmr向量试图将其分配器传播给其元素。当元素不使用多态分配器时，这是不成功的，如std::string类型的情况。然而，通过使用std::pmr::string类型，它是一个使用多态分配器的字符串，传播工作正常。<br>同样，只有当缓冲区中没有更多的内存时，新的内存才会由堆上的池分配。例如，这种情况可能发生在以下修改中:</p><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>; i &lt; <span class="hljs-number">50000</span>; ++i) {    coll.<span class="hljs-built_in">emplace_back</span>(<span class="hljs-string">"just a non-SSO string"</span>);}</code></pre></div><p>当输出可能突然变得:</p><div class="code-wrapper"><pre><code class="hljs bash">8 allocations <span class="hljs-keyword">for</span> 14777448 bytes</code></pre></div><h6><span id="chong-fu-shi-yong-nei-cun-chi">重复使用内存池</span><a href="#chong-fu-shi-yong-nei-cun-chi" class="header-anchor">#</a></h6><p>我们甚至可以重复使用我们的堆栈内存池。比如说:</p><p><code>pmr/pmr3.cpp </code></p><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;array&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstdlib&gt;</span> <span class="hljs-comment">// for std::byte</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;memory_resource&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">"../lang/tracknew.hpp"</span></span><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>{    <span class="hljs-comment">// 在堆栈上分配一些内存:</span>    std::array&lt;std::byte, 200000&gt; buf;    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> num : {<span class="hljs-number">1000</span>, <span class="hljs-number">2000</span>, <span class="hljs-number">500</span>, <span class="hljs-number">2000</span>, <span class="hljs-number">3000</span>, <span class="hljs-number">50000</span>, <span class="hljs-number">1000</span>}) {        std::cout &lt;&lt; <span class="hljs-string">"-- check with "</span> &lt;&lt; num &lt;&lt; <span class="hljs-string">" elements:\n"</span>;        TrackNew::<span class="hljs-built_in">reset</span>();        std::pmr::monotonic_buffer_resource pool{buf.<span class="hljs-built_in">data</span>(), buf.<span class="hljs-built_in">size</span>()};        std::pmr::vector&lt;std::pmr::string&gt; coll{&amp;pool};        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>; i &lt; num; ++i) {            coll.<span class="hljs-built_in">emplace_back</span>(<span class="hljs-string">"just a non-SSO string"</span>);        }        TrackNew::<span class="hljs-built_in">status</span>();    }}</code></pre></div><p>这里，在分配了堆栈上的200,000字节后，我们再次使用这块内存，为vector及其元素初始化一个新的资源池:</p><p>输出可能变为：</p><div class="code-wrapper"><pre><code class="hljs bash">-- check with 1000 elements:0 allocations <span class="hljs-keyword">for</span> 0 bytes-- check with 2000 elements:1 allocations <span class="hljs-keyword">for</span> 300000 bytes-- check with 500 elements:0 allocations <span class="hljs-keyword">for</span> 0 bytes-- check with 2000 elements:1 allocations <span class="hljs-keyword">for</span> 300000 bytes-- check with 3000 elements:2 allocations <span class="hljs-keyword">for</span> 750000 bytes-- check with 50000 elements:8 allocations <span class="hljs-keyword">for</span> 14777448 bytes-- check with 1000 elements:0 allocations <span class="hljs-keyword">for</span> 0 bytes</code></pre></div><p>每次200000字节足够的时候，我们不需要额外的分配（在这里，它是最多1000个元素的情况）。这200000字节被使用，当内存池被销毁时，可用于下一次迭代。<br>每次内存被超过时，内存池会在堆上分配额外的内存，当内存池被销毁时，这些内存会被删除。<br>这样你就可以很容易地对内存池进行编程，你只需分配一次内存（无论是在堆栈还是在堆上），并在每个新任务（服务请求、事件、要处理的数据文件等）中重复使用它。等等）。<br>我们将在后面讨论更复杂的内存池的例子。</p><h5><span id="27-1-2-biao-zhun-nei-cun-zi-yuan">27.1.2 标准内存资源</span><a href="#27-1-2-biao-zhun-nei-cun-zi-yuan" class="header-anchor">#</a></h5><p>为了支持多态分配器，C++标准库提供了表标准内存资源中列出的内存。</p><table><thead><tr><th>内存资源</th><th>行为</th></tr></thead><tbody><tr><td>new_delete_resource()</td><td>产生一个指向内存资源的指针，调用new和删除</td></tr><tr><td>synchronized_pool_resource</td><td>类来创建内存资源，碎片少，线程安全。</td></tr><tr><td>unsynchronized_pool_resource</td><td>创建零散的内存资源的类，不是线程安全的</td></tr><tr><td>monotonic_buffer_resource</td><td>创建内存资源的类，该类永远不会取消分配，可以选择使用一个传递的缓冲区，不是线程安全的</td></tr><tr><td>null_memory_resource()</td><td>产生一个指向内存资源的指针，每次分配都会失败</td></tr></tbody></table><p>new_delete_resource()和null_memory_resource()是返回全局内存资源指针的函数，它被定义为一个单子。其他三个内存资源是类，你必须创建对象并将这些对象的指针传递给多态分配器。一些使用例子:</p><div class="code-wrapper"><pre><code class="hljs c++">std::pmr::string s1{<span class="hljs-string">"my string"</span>, std::pmr::<span class="hljs-built_in">new_delete_resource</span>()};std::pmr::synchronized_pool_resource pool1;std::pmr::string s2{<span class="hljs-string">"my string"</span>, &amp;pool1};std::pmr::monotonic_buffer_resource pool2{...};std::pmr::string s3{<span class="hljs-string">"my string"</span>, &amp;pool2};</code></pre></div><p>一般来说，内存资源是作为指针传递的。由于这个原因，重要的是你要确保这些指针所指的资源对象在最后一次调用去分配之前一直存在（如果你移动对象并且内存资源可以互换，这可能比你预期的要晚）。</p><h6><span id="mo-ren-de-nei-cun-zi-yuan">默认的内存资源</span><a href="#mo-ren-de-nei-cun-zi-yuan" class="header-anchor">#</a></h6><p>多态分配器有一个默认的内存资源，如果没有传递其他的内存资源，就会使用它。表中默认内存资源的操作列出了为其定义的操作。</p><table><thead><tr><th>内存资源</th><th>行为</th></tr></thead><tbody><tr><td>get_default_resource()</td><td>产生一个指向当前默认内存资源的指针</td></tr><tr><td>set_default_resource(memresPtr)</td><td>设置默认的内存资源（传递一个指针），并且产生一个指向前一个的指针</td></tr></tbody></table><p>你可以用std::pmr::get_default_resource()来获取当前的默认资源，你可以通过它来初始化一个多态分配器。你可以用std::pmr::set_default_resource()全局性地设置一个不同的默认内存资源。这个资源在任何范围内都作为默认资源使用，直到下一次调用std::pmr::set_default_resource()。比如说</p><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-type">static</span> std::pmr::synchronized_pool_resource myPool;<span class="hljs-comment">// 设置myPool为新的默认内存资源。</span>std::pmr::memory_resource* old = std::pmr::set_default_resource（&amp;myPool）。    ...;<span class="hljs-comment">// 恢复旧的默认内存资源为默认值。</span>std::pmr::<span class="hljs-built_in">set_default_resource</span>(old)。</code></pre></div><p>如果你在程序中创建了一个自定义的内存资源，并将其作为默认资源使用，那么在main()中作为静态对象先创建它，这是一个好办法。</p><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>{    <span class="hljs-type">static</span> std::pmr::synchronized_pool_resource myPool;    ...}</code></pre></div><p>或者，提供一个全局函数，将你的资源作为静态对象返回。</p><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-function">memory_resource* <span class="hljs-title">myResource</span><span class="hljs-params">()</span></span></code></pre></div><div class="code-wrapper"><pre><code class="hljs c++">{    <span class="hljs-type">static</span> std::pmr::synchronized_pool_resource myPool;    <span class="hljs-keyword">return</span> &amp;myPool;}</code></pre></div><p>返回类型 memory_resource 是所有内存资源的基类。<br>请注意，以前的默认资源在被替换时可能仍然被使用。除非你知道（并确保）情况并非如此，例如，这意味着没有使用该资源创建静态对象，否则你应该让你的资源尽可能长地存活（同样，最好是在main()的开头创建，以便它最后被销毁）。</p><h5><span id="27-1-3-biao-zhun-nei-cun-zi-yuan-de-xiang-xi-jie-shao">27.1.3 标准内存资源的详细介绍</span><a href="#27-1-3-biao-zhun-nei-cun-zi-yuan-de-xiang-xi-jie-shao" class="header-anchor">#</a></h5><p>让我们详细讨论一下不同的标准内存资源。</p><h6><span id="new-delete-resource">new_delete_resource()</span><a href="#new-delete-resource" class="header-anchor">#</a></h6><p>new_delete_resource()是默认的内存资源。它是由get_default_resource()返回的。<br>返回，除非你通过调用set_default_resource()定义了一个不同的默认内存资源。<br>它处理分配，就像使用默认分配器时的处理方式。</p><ul><li>每次分配都调用new</li><li>每一次去分配都调用delete</li></ul><p>然而，请注意，具有这种内存资源的多态分配器不能与默认分配器互换，因为它们只是具有不同的类型。由于这个原因</p><div class="code-wrapper"><pre><code class="hljs c++">std::string s{<span class="hljs-string">"my string with some value"</span>}。std::pmr::string ps{std::<span class="hljs-built_in">move</span>(s), std::pmr::<span class="hljs-built_in">new_delete_resource</span>()}; <span class="hljs-comment">// copies</span></code></pre></div><p>将不会移动（将分配给s的内存传递给ps）。相反，s的内存将被复制到ps的新内存中，用new分配。</p><h6><span id="un-synchronized-pool-resource">(un)synchronized_pool_resource</span><a href="#un-synchronized-pool-resource" class="header-anchor">#</a></h6><p>synchronized_pool_resource和unsynchronized_pool_resource是内存资源的类，它们试图将所有内存定位在彼此附近。因此，它们迫使内存的碎片化很少。<br>不同的是，synchronized_pool_resource是线程安全的（这需要花费更多的性能），而unsynchronized_pool_resource则不是。因此，如果你知道这个池子的内存只由一个线程处理（或者（去）分配是同步的），你应该选择unsynchronized_pool_resource。<br>这两个类仍然使用底层内存资源来实际执行分配和去分配。它们只是作为一个封装器，确保这些分配能更好地被集群起来。因此:</p><div class="code-wrapper"><pre><code class="hljs c++">std::pmr::synchronized_pool_resource myPool。</code></pre></div><p>与</p><div class="code-wrapper"><pre><code class="hljs c++">std::pmr::synchronized_pool_resource myPool{std::pmr::<span class="hljs-built_in">get_default_resource</span>()}。</code></pre></div><p>此外，当池子被销毁时，它们会删除所有的内存。<br>这些池子的一个主要应用是确保基于节点的容器中的元素位于彼此的旁边。这也可能大大增加了容器的性能，因为这样CPU缓存就会把元素装在一起的缓存行中。其效果是，当你访问一个元素后，访问其他元素就变得非常快，因为它们已经在缓存中了。<br>然而，你应该衡量一下，因为这取决于内存资源的实现。例如，如果内存资源使用mutex来同步内存访问，性能可能会明显变差。<br>让我们用一个简单的例子来看看这个效果。下面的程序创建了一个地图，它将积分值映射到字符串。</p><p><code>pmr/pmrsync0.cpp </code></p><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;map&gt;</span></span><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>{    std::map&lt;<span class="hljs-type">long</span>, std::string&gt; coll;    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>; i&lt;<span class="hljs-number">10</span>; ++i) {        std::string s{<span class="hljs-string">"Customer"</span> + std::<span class="hljs-built_in">to_string</span>(i)};        coll.<span class="hljs-built_in">emplace</span>(i, s);    }    <span class="hljs-comment">// print element distances:</span>    <span class="hljs-keyword">for</span> (<span class="hljs-type">const</span> <span class="hljs-keyword">auto</span>&amp; elem : coll) {        <span class="hljs-type">static</span> <span class="hljs-type">long</span> <span class="hljs-type">long</span> lastVal = <span class="hljs-number">0</span>;        <span class="hljs-type">long</span> <span class="hljs-type">long</span> val = <span class="hljs-built_in">reinterpret_cast</span>&lt;<span class="hljs-type">long</span> <span class="hljs-type">long</span>&gt;(&amp;elem);        std::cout &lt;&lt; <span class="hljs-string">"diff: "</span> &lt;&lt; (val-lastVal) &lt;&lt; <span class="hljs-string">'\n'</span>;        lastVal = val;    }}</code></pre></div><p>这个数据结构是一个平衡的二叉树，每个节点都执行自己的分配来存储一个元素。因此，对每个元素进行分配，这些分配默认当前在堆上分配内存（使用标准默认分配器）。<br>为了看清效果，程序打印了元素地址之间的距离，同时迭代了 它们之间的距离。例如，一个输出可能看起来如下:</p><div class="code-wrapper"><pre><code class="hljs bash">diff: 1777277585312diff: -320diff: 60816diff: 1120diff: -400diff: 80diff: -2080diff: -1120diff: 2720diff: -3040</code></pre></div><p>这些元素不是彼此相邻的。我们有60,000字节的距离，10个元素的大小约为24字节。如果在元素的分配之间分配了其他的内存，这种碎片化就会变得更严重。<br>现在让我们用多态分配器运行这个程序，使用synchronized_pool_resource:</p><p><code>pmr/pmrsync1.cpp </code></p><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;map&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;memory_resource&gt;</span></span><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>{    std::pmr::synchronized_pool_resource pool;    std::pmr::map&lt;<span class="hljs-type">long</span>, std::pmr::string&gt; coll{&amp;pool};    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>; i&lt;<span class="hljs-number">10</span>; ++i) {        std::string s{<span class="hljs-string">"Customer"</span> + std::<span class="hljs-built_in">to_string</span>(i)};        coll.<span class="hljs-built_in">emplace</span>(i, s);    }    <span class="hljs-comment">// 打印元素距离:</span>    <span class="hljs-keyword">for</span> (<span class="hljs-type">const</span> <span class="hljs-keyword">auto</span>&amp; elem : coll) {        <span class="hljs-type">static</span> <span class="hljs-type">long</span> <span class="hljs-type">long</span> lastVal = <span class="hljs-number">0</span>;        <span class="hljs-type">long</span> <span class="hljs-type">long</span> val = <span class="hljs-built_in">reinterpret_cast</span>&lt;<span class="hljs-type">long</span> <span class="hljs-type">long</span>&gt;(&amp;elem);        std::cout &lt;&lt; <span class="hljs-string">"diff: "</span> &lt;&lt; (val-lastVal) &lt;&lt; <span class="hljs-string">'\n'</span>;        lastVal = val;    }}</code></pre></div><p>正如你所看到的，我们简单地创建了资源并将其作为参数传递给容器的构造函数:</p><div class="code-wrapper"><pre><code class="hljs c++">std::pmr::synchronized_pool_resource pool;std::pmr::map&lt;<span class="hljs-type">long</span>, std::pmr::string&gt; coll{&amp;pool};</code></pre></div><p>例如，现在的输出看起来如下:</p><div class="code-wrapper"><pre><code class="hljs bash">diff: 2548552461600diff: 128diff: 128diff: 105216diff: 128diff: 128diff: 128diff: 128diff: 128diff: 128</code></pre></div><p>正如你所看到的，这些元素现在都位于彼此附近。但是，它们仍然没有位于一个内存块中。当内存池发现第一块内存不足以容纳所有的元素时，它为更多的元素分配更多的内存。因此，我们分配的内存越多，内存块就越大，这样就有更多的元素被放在彼此附近。这个算法的细节是由实现定义的。</p><p>当然，这个输出是特殊的，因为我们按照元素在容器内的排序来创建它们。因此，在实践中，如果你用随机值创建对象，这些元素将不会一个接一个地顺序定位（在不同的内存块中）。然而，它们仍然位于彼此之间，这对于处理这个容器中的元素时的良好性能是很重要的。</p><p>还请注意，我们不看元素值的内存是如何安排的。在这里，通常小字符串的优化导致对元素没有分配内存。但是一旦我们放大了字符串值，池子也会尝试将这些字符串放在一起。请注意，池为不同的分配大小管理不同的内存块。也就是说，在一般情况下，元素之间是相互定位的，相同字符串大小的元素的字符串值是相互靠近的。</p><h6><span id="monotonic-buffer-resource">monotonic_buffer_resource</span><a href="#monotonic-buffer-resource" class="header-anchor">#</a></h6><p>monotonic_buffer_resource类也提供了将所有内存放在大块内存中的能力。然而，它还有另外两种能力。</p><ul><li>你可以传递一个缓冲区来作为内存使用。这一点，特别是可以在堆栈上分配内存。</li><li>内存资源永远不会被取消分配，直到整个资源被取消分配。也就是说，它也试图避免碎片化。而且，它的速度超快，因为去分配是一个无操作的过程，你跳过了追踪去分配的内存以便进一步使用。每当有分配内存的请求时，它只是返回下一块空闲的内存，直到所有的内存都用完。</li></ul><p>请注意，对象仍然是被销毁的。只有它们的内存没有被释放。如果你删除了对象，这通常会删除它们的内存，但删除并没有影响。<br>如果你没有删除对象，或者你有足够的内存可以浪费（不重复使用之前被其他对象使用的内存），你应该更喜欢这种资源。<br>我们已经在第一个激励性的例子中看到了monotonic_buffer_resource的应用，我们把在堆栈中分配的内存传递给了池。</p><div class="code-wrapper"><pre><code class="hljs c++">std::array&lt;std::byte, 200000&gt; buf。std::pmr::monotonic_buffer_resource pool{buf.<span class="hljs-built_in">data</span>(), buf.<span class="hljs-built_in">size</span>()}。</code></pre></div><p>你也可以使用这个池子让任何内存资源跳过去分配（可以选择传递一个初始大小）。默认情况下，这将适用于默认的内存资源，默认是new_delete_resource()。就是说，用</p><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-comment">//使用默认的内存资源，但只要池子还在，就跳过去分配。</span>{    std::pmr::monotonic_buffer_resource pool。        std::pmr::vector&lt;std::pmr::string&gt; coll{&amp;pool};    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>; i &lt; <span class="hljs-number">100</span>; ++i) {        coll.<span class="hljs-built_in">emplace_back</span>(<span class="hljs-string">"just a non-SSO string"</span>)。    }    coll.<span class="hljs-built_in">clear</span>(); <span class="hljs-comment">// 销毁但不去分配</span>} <span class="hljs-comment">// 取消分配所有分配的内存</span></code></pre></div><p>带有循环的内部块将不时为向量及其元素分配内存。由于我们使用的是一个池子，分配的内存被组合成块状。例如，这可能导致14次分配。通过首先调用coll.reserve(100)，这通常会变成只有两个分配。<br>正如所写的那样，只要池子存在，就不做任何取消分配。因此，如果向量的创建和使用是在一个循环中完成的，池子分配的内存会不断增加。<br>monotonic_buffer_resource也允许我们传递一个初始大小，然后它使用其第一次分配的最小大小（当第一次内存请求发生时进行）。此外，你可以定义它使用哪个内存资源来执行分配。这使得我们可以通过连锁内存资源来提供更复杂的内存资源。<br>考虑一下下面的例子:</p><div class="code-wrapper"><pre><code class="hljs c++">{    <span class="hljs-comment">// 分配大块内存（从10k开始），而不去分配:</span>    std::pmr::monotonic_buffer_resource keepAllocatedPool{<span class="hljs-number">10000</span>};    std::pmr::synchronized_pool_resource pool{&amp;keepAllocatedPool};    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>; j &lt; <span class="hljs-number">100</span>; ++j) {        std::pmr::vector&lt;std::pmr::string&gt; coll{&amp;pool};        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>; i &lt; <span class="hljs-number">100</span>; ++i) {            coll.<span class="hljs-built_in">emplace_back</span>(<span class="hljs-string">"just a non-SSO string"</span>);        }    } <span class="hljs-comment">// 去分配的数据被送回池中，但没有解除分配。</span>    <span class="hljs-comment">// 到目前为止，没有任何东西被释放</span>} <span class="hljs-comment">// 释放所有分配的内存</span></code></pre></div><p>通过这段代码，我们首先为我们所有的内存创建一个池，只要它活着就永远不会去分配，初始化时开始分配10000字节（使用默认的内存资源分配）。</p><div class="code-wrapper"><pre><code class="hljs c++">std::pmr::monotonic_buffer_resource keepAllocatedPool{<span class="hljs-number">10000</span>}。</code></pre></div><p>然后我们创建另一个池，使用这个非去分配的池来分配内存块。</p><div class="code-wrapper"><pre><code class="hljs c++">std::pmr::synchronized_pool_resource pool{&amp;keepAllocatedPool}。</code></pre></div><p>综合的效果是，我们的所有内存都有一个池子，它从10000字节开始分配，如果有必要，可以分配更多的内存，而且几乎没有碎片，可以被所有使用这个池子的pmr对象使用。<br>当keepAllocatedPool超出范围时，所分配的内存（可能是最初的10000字节加上一些更大的内存块的额外分配）都将被释放。</p><p>这里到底发生了什么，将在后面我们扩展这个例子以追踪这个嵌套池的所有分配时进行演示。</p><h6><span id="null-memory-resource">null_memory_resource()</span><a href="#null-memory-resource" class="header-anchor">#</a></h6><p>null_memory_resource()处理分配的方式是每次分配都会抛出一个bad_alloc异常。<br>最重要的应用是确保使用堆栈上分配的内存的内存池不会突然在堆上分配内存，如果它需要更多的话。<br>考虑一下下面的例子:</p><p><code>pmr/pmrnull.cpp </code></p><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unordered_map&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;array&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstddef&gt;</span> <span class="hljs-comment">// for std::byte</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;memory_resource&gt;</span></span><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>{    <span class="hljs-comment">// 使用堆栈上的内存而不在堆上进行回退:</span>    std::array&lt;std::byte, 200000&gt; buf;    std::pmr::monotonic_buffer_resource pool{buf.<span class="hljs-built_in">data</span>(), buf.<span class="hljs-built_in">size</span>(),                                             std::pmr::<span class="hljs-built_in">null_memory_resource</span>()};    <span class="hljs-comment">// 并分配太多内存:</span>    std::pmr::unordered_map&lt;<span class="hljs-type">long</span>, std::pmr::string&gt; coll {&amp;pool};    <span class="hljs-keyword">try</span> {        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>; i&lt;buf.<span class="hljs-built_in">size</span>(); ++i) {            std::string s{<span class="hljs-string">"Customer"</span> + std::<span class="hljs-built_in">to_string</span>(i)};            coll.<span class="hljs-built_in">emplace</span>(i, s);        }    }    <span class="hljs-built_in">catch</span> (<span class="hljs-type">const</span> std::bad_alloc&amp; e) {        std::cerr &lt;&lt; <span class="hljs-string">"BAD ALLOC EXCEPTION: "</span> &lt;&lt; e.<span class="hljs-built_in">what</span>() &lt;&lt; <span class="hljs-string">'\n'</span>;    }    std::cout &lt;&lt; <span class="hljs-string">"size: "</span> &lt;&lt; coll.<span class="hljs-built_in">size</span>() &lt;&lt; <span class="hljs-string">'\n'</span>;}</code></pre></div><p>我们在堆栈中分配内存，并将其传递给单调的缓冲区作为内存资源:</p><div class="code-wrapper"><pre><code class="hljs c++">std::array&lt;std::byte, 200000&gt; buf;std::pmr::monotonic_buffer_resource pool{buf.<span class="hljs-built_in">data</span>(), buf.<span class="hljs-built_in">size</span>(),                                         std::pmr::<span class="hljs-built_in">null_memory_resource</span>()};</code></pre></div><p>通过传递null_memory_resource()作为后备内存资源，我们确保任何分配更多内存的尝试都会抛出一个异常，而不是在堆上分配内存。<br>其结果是，程序迟早会结束，例如，输出结果如下:</p><div class="code-wrapper"><pre><code class="hljs bash">BAD ALLOC EXCEPTION: bad allocationsize: 2048</code></pre></div><p>当堆内存分配不是一种选择时，这有助于获得合理的反馈，而不是碰上你必须避免的行为。</p><h4><span id="27-2-ding-yi-zi-ding-yi-nei-cun-zi-yuan">27.2 定义自定义内存资源</span><a href="#27-2-ding-yi-zi-ding-yi-nei-cun-zi-yuan" class="header-anchor">#</a></h4><p>你可以提供你自定义的内存资源。为此，你只需要</p><ul><li>派生自std::pmr::memory_resource</li><li>实现私有成员<ul><li>do_allocate() 来分配内存</li><li>do_deallocate()来删除内存</li><li>do_is_equal()定义你的类型是否以及何时可以与另一个内存资源对象交换分配的内存</li></ul></li></ul><p>下面是一个完整的例子，它仅仅允许我们跟踪任何 其他的内存资源:</p><p><code>pmr/tracker.hpp</code></p><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;memory_resource&gt;</span></span><span class="hljs-keyword">class</span> <span class="hljs-title class_">Tracker</span> : <span class="hljs-keyword">public</span> std::pmr::memory_resource{    <span class="hljs-keyword">private</span>:    std::pmr::memory_resource* upstream; <span class="hljs-comment">// 包装的内存资源</span>    std::string prefix{};    <span class="hljs-keyword">public</span>:    <span class="hljs-comment">// 我们包装传递的或默认的资源:</span>    <span class="hljs-function"><span class="hljs-keyword">explicit</span> <span class="hljs-title">Tracker</span><span class="hljs-params">(std::pmr::memory_resource* us</span></span><span class="hljs-params"><span class="hljs-function">                     = std::pmr::get_default_resource())</span></span><span class="hljs-function">        : upstream{</span>us} {        }    <span class="hljs-function"><span class="hljs-keyword">explicit</span> <span class="hljs-title">Tracker</span><span class="hljs-params">(std::string p,</span></span><span class="hljs-params"><span class="hljs-function">                     std::pmr::memory_resource* us</span></span><span class="hljs-params"><span class="hljs-function">                     = std::pmr::get_default_resource())</span></span><span class="hljs-function">        : prefix{</span>std::<span class="hljs-built_in">move</span>(p)}, upstream{us} {        }    <span class="hljs-keyword">private</span>:    <span class="hljs-function"><span class="hljs-type">void</span>* <span class="hljs-title">do_allocate</span><span class="hljs-params">(<span class="hljs-type">size_t</span> bytes, <span class="hljs-type">size_t</span> alignment)</span> <span class="hljs-keyword">override</span> </span>{        std::cout &lt;&lt; prefix &lt;&lt; <span class="hljs-string">"allocate "</span> &lt;&lt; bytes &lt;&lt; <span class="hljs-string">" Bytes\n"</span>;        <span class="hljs-type">void</span>* ret = upstream-&gt;<span class="hljs-built_in">allocate</span>(bytes, alignment);        <span class="hljs-keyword">return</span> ret;    }    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">do_deallocate</span><span class="hljs-params">(<span class="hljs-type">void</span>* ptr, <span class="hljs-type">size_t</span> bytes, <span class="hljs-type">size_t</span> alignment)</span> <span class="hljs-keyword">override</span> </span>{        std::cout &lt;&lt; prefix &lt;&lt; <span class="hljs-string">"deallocate "</span> &lt;&lt; bytes &lt;&lt; <span class="hljs-string">" Bytes\n"</span>;        upstream-&gt;<span class="hljs-built_in">deallocate</span>(ptr, bytes, alignment);    }    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">do_is_equal</span><span class="hljs-params">(<span class="hljs-type">const</span> std::pmr::memory_resource&amp; other)</span> <span class="hljs-type">const</span> <span class="hljs-keyword">noexcept</span></span><span class="hljs-function">        <span class="hljs-keyword">override</span> </span>{        <span class="hljs-comment">// same object?:</span>        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span> == &amp;other) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;        <span class="hljs-comment">// 相同的类型和前缀以及相等的上游？</span>        <span class="hljs-keyword">auto</span> op = <span class="hljs-built_in">dynamic_cast</span>&lt;<span class="hljs-type">const</span> Tracker*&gt;(&amp;other);        <span class="hljs-keyword">return</span> op != <span class="hljs-literal">nullptr</span> &amp;&amp; op-&gt;prefix == prefix            &amp;&amp; upstream-&gt;<span class="hljs-built_in">is_equal</span>(other);    }};</code></pre></div><p>像通常的智能内存资源一样，我们支持传递另一个内存资源（通常称为上游）来包裹它或将其作为后备资源。此外，我们还可以传递一个可选的前缀。在每次分配和去分配时，我们都会用可选的前缀来追踪这个调用。<br>我们唯一需要实现的其他函数是do_is_equal()，它定义了两个分配器何时可以互换（也就是说，一个多态内存资源对象是否以及何时可以去分配另一个分配的内存）。在这种情况下，我们简单地说，只要前缀相同，任何这种类型的对象都可以取消从任何其他这种类型的对象分配的内存:</p><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">do_is_equal</span><span class="hljs-params">(<span class="hljs-type">const</span> std::pmr::memory_resource&amp; other)</span> <span class="hljs-type">const</span> <span class="hljs-keyword">noexcept</span></span><span class="hljs-function">    <span class="hljs-keyword">override</span> </span>{    <span class="hljs-comment">// same object?:</span>    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span> == &amp;other) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;    <span class="hljs-comment">// 相同的类型和前缀以及相等的上游？:</span>    <span class="hljs-keyword">auto</span> op = <span class="hljs-built_in">dynamic_cast</span>&lt;<span class="hljs-type">const</span> Tracker*&gt;(&amp;other);    <span class="hljs-keyword">return</span> op != <span class="hljs-literal">nullptr</span> &amp;&amp; op-&gt;prefix == prefix        &amp;&amp; upstream-&gt;<span class="hljs-built_in">is_equal</span>(other);}</code></pre></div><p>第一个比较的存在只是为了跳过其他更昂贵的与下限的比较。如果我们不使用相同的跟踪器，我们要求另一个内存资源也是具有相同前缀的跟踪器（相同意义上的相同）和可交换的底层内存资源。否则，如果我们使用不同底层内存资源的跟踪器，应用程序会认为从完全不同的内存资源中分配的内存是可以取消的。<br>让我们使用这个跟踪器来理解之前演示的嵌套池的行为，以分配大块的内存而不去分配:</p><p><code>pmr/tracker.cpp</code></p><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">"tracker.hpp"</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;memory_resource&gt;</span></span><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>{    {        <span class="hljs-comment">// 追踪分配内存块（从10k开始）而不去分配。:</span>        Tracker track1{<span class="hljs-string">"keeppool:"</span>};        std::pmr::monotonic_buffer_resource keeppool{<span class="hljs-number">10000</span>, &amp;track1};        {            Tracker track2{<span class="hljs-string">" syncpool:"</span>, &amp;keeppool};            std::pmr::synchronized_pool_resource pool{&amp;track2};            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>; j &lt; <span class="hljs-number">100</span>; ++j) {                std::pmr::vector&lt;std::pmr::string&gt; coll{&amp;pool};                coll.<span class="hljs-built_in">reserve</span>(<span class="hljs-number">100</span>);                <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>; i &lt; <span class="hljs-number">100</span>; ++i) {                    coll.<span class="hljs-built_in">emplace_back</span>(<span class="hljs-string">"just a non-SSO string"</span>);                }                <span class="hljs-keyword">if</span> (j==<span class="hljs-number">2</span>) std::cout &lt;&lt; <span class="hljs-string">"--- third iteration done\n"</span>;            } <span class="hljs-comment">// 去分配的数据被送回池子里，但没有去分配。</span>            <span class="hljs-comment">// 到目前为止，没有分配到任何东西</span>            std::cout &lt;&lt; <span class="hljs-string">"--- leave scope of pool\n"</span>;        }        std::cout &lt;&lt; <span class="hljs-string">"--- leave scope of keeppool\n"</span>;    } <span class="hljs-comment">// 删除所有已分配的内存</span>}</code></pre></div><p>输出可能如下所示：</p><div class="code-wrapper"><pre><code class="hljs bash">syncpool:allocate 48 Byteskeeppool:allocate 10000 Bytessyncpool:allocate 16440 Byteskeeppool:allocate 16464 Bytessyncpool:allocate 96 Byteskeeppool:allocate 24696 Bytessyncpool:deallocate 48 Bytessyncpool:allocate 312 Bytessyncpool:allocate 568 Bytessyncpool:allocate 1080 Bytessyncpool:allocate 2104 Bytessyncpool:allocate 4152 Bytessyncpool:deallocate 312 Bytessyncpool:deallocate 568 Bytessyncpool:deallocate 1080 Bytessyncpool:deallocate 2104 Bytessyncpool:allocate 8248 Bytessyncpool:deallocate 4152 Bytes--- third iteration <span class="hljs-keyword">done</span>--- leave scope of poolsyncpool:deallocate 8248 Bytessyncpool:deallocate 16440 Bytessyncpool:deallocate 96 Bytes--- leave scope of keeppoolkeeppool:deallocate 24696 Byteskeeppool:deallocate 16464 Byteskeeppool:deallocate 10000 Bytes</code></pre></div><p>输出显示了以下情况。</p><ul><li>随着一个对象的第一次分配，syncpool分配了48个字节，这导致keeppool分配其初始的10,000字节。这10,000字节是在堆上分配的，使用的是keeppool初始化时get_default_resource()的资源。</li><li>后来的对象会分配和删除内存，这使得syncpool不时地分配更多的内存块，但也会删除内存块。如果syncpool有效地分配了比keeppool所分配的更多的内存，keeppool再次从堆中分配更多的内存。也就是说，只有keeppool的分配成为（相当昂贵的）系统调用。</li><li>通过对第三个迭代结束时的额外追踪，你可以看到所有这些分配都发生在外循环的前三个迭代中。然后，（重新）使用的内存量是稳定的。因此，剩下的97次迭代根本就没有从操作系统中分配任何内存。</li><li>即使syncpool已经分配了所有的内存，keeppool也没有分配任何内存。</li><li>只有当keeppool被销毁时，分配的六块内存才会真正地被调用::delete（或者当keeppool被初始化时用set_default_resource()定义的任何东西）而被取消分配。</li></ul><p>如果我们在这个程序中引入第三个跟踪器，我们也可以跟踪对象从syncpool分配和删除内存的时间:</p><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-comment">// 跟踪每个调用，同步池中的效果，以及单池中的效果:</span>Tracker track1{<span class="hljs-string">"keeppool:"</span>};std::pmr::monotonic_buffer_resource keepAllocatedPool{<span class="hljs-number">10000</span>, &amp;track1};Tracker track2{<span class="hljs-string">" syncpool:"</span>, &amp;keepAllocatedPool};std::pmr::synchronized_pool_resource syncPool{&amp;track2};Tracker track3{<span class="hljs-string">" objects:"</span>, &amp;syncPool};...std::pmr::vector&lt;std::pmr::string&gt; coll{&amp;track3};</code></pre></div><h5><span id="27-2-1-nei-cun-zi-yuan-de-ping-deng-xing">27.2.1 内存资源的平等性</span><a href="#27-2-1-nei-cun-zi-yuan-de-ping-deng-xing" class="header-anchor">#</a></h5><p>让我们谈谈 do_is_equal()，该函数定义两个内存资源何时可互换。 这个功能需要比最初看起来更多的思考。<br>在我们的跟踪器中，我们定义了分配器是可互换的，如果它们都是 Tracker 类型并且使用相同的前缀：</p><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">do_is_equal</span><span class="hljs-params">(<span class="hljs-type">const</span> std::pmr::memory_resource&amp; other)</span> <span class="hljs-type">const</span> <span class="hljs-keyword">noexcept</span></span><span class="hljs-function">    <span class="hljs-keyword">override</span> </span>{    <span class="hljs-comment">// same object?:</span>    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span> == &amp;other) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;    <span class="hljs-comment">// same type and prefix?:</span>    <span class="hljs-keyword">auto</span> op = <span class="hljs-built_in">dynamic_cast</span>&lt;<span class="hljs-type">const</span> Tracker*&gt;(&amp;other);    <span class="hljs-keyword">return</span> op != <span class="hljs-literal">nullptr</span> &amp;&amp; op-&gt;prefix == prefix;}</code></pre></div><p>这具有以下效果：</p><div class="code-wrapper"><pre><code class="hljs c++">Tracker track1{<span class="hljs-string">"track1:"</span>};Tracker track2{<span class="hljs-string">"track2:"</span>};std::pmr::string s1{<span class="hljs-string">"more than 15 chars"</span>, &amp;track1}; <span class="hljs-comment">// 用 track1 分配</span>std::pmr::string s2{std::<span class="hljs-built_in">move</span>(s1), &amp;track1}; <span class="hljs-comment">// 移动（相同的跟踪器）</span>std::pmr::string s3{std::<span class="hljs-built_in">move</span>(s2), &amp;track2}; <span class="hljs-comment">// 拷贝（不同的前缀）</span>std::pmr::string s4{std::<span class="hljs-built_in">move</span>(s3)}; <span class="hljs-comment">// 移动（复制分配器）</span>std::string s5{std::<span class="hljs-built_in">move</span>(s4)}; <span class="hljs-comment">// 移动（其他分配器）</span></code></pre></div><p>也就是说，只有当源码和目的码具有可互换的分配器时，移动才会作为移动执行。对于多态分配类型，当使用移动构造函数时就是这种情况（新对象复制了分配器）。但是如果需要一个不可互换的分配器（如这里的跟踪器有不同的前缀），或者使用不同的分配器类型（如移动到std::string，它使用默认的分配器），内存会被复制。因此，互换性会影响移动的性能。<br>如果我们让所有Tracker类型的内存资源都可以互换，只检查类型:</p><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">do_is_equal</span><span class="hljs-params">(<span class="hljs-type">const</span> std::pmr::memory_resource&amp; other)</span> <span class="hljs-type">const</span> <span class="hljs-keyword">noexcept</span></span><span class="hljs-function">    <span class="hljs-keyword">override</span> </span>{    <span class="hljs-comment">// 如果所有 Tracker 具有相同的类型，则它们都可以互换:</span>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span> == &amp;other || <span class="hljs-built_in">dynamic_cast</span>&lt;<span class="hljs-type">const</span> Tracker*&gt;(&amp;other) != <span class="hljs-literal">nullptr</span>;}</code></pre></div><p>我们会得到以下行为:</p><div class="code-wrapper"><pre><code class="hljs c++">Tracker track1{<span class="hljs-string">"track1:"</span>};Tracker track2{<span class="hljs-string">"track2:"</span>};std::pmr::string s1{<span class="hljs-string">"more than 15 chars"</span>, &amp;track1}; <span class="hljs-comment">// 用 track1 分配</span>std::pmr::string s2{std::<span class="hljs-built_in">move</span>(s1), &amp;track1}; <span class="hljs-comment">// 移动（相同的跟踪器类型）</span>std::pmr::string s3{std::<span class="hljs-built_in">move</span>(s2), &amp;track2}; <span class="hljs-comment">// 移动 (same tracker type)</span>std::pmr::string s4{std::<span class="hljs-built_in">move</span>(s3)}; <span class="hljs-comment">// 移动 (allocator copied)</span>std::string s5{std::<span class="hljs-built_in">move</span>(s4)}; <span class="hljs-comment">// 拷贝 (other allocator)</span></code></pre></div><p>如您所见，效果是track1分配的内存通过s3传递给s4，两者都使用track2，因此我们得到：</p><div class="code-wrapper"><pre><code class="hljs bash">track1:allocate 32 Bytestrack2:deallocate 32 Bytes</code></pre></div><p>如果我们的内存资源不会有不同的状态（即不会有前缀），这将是一个很好的实现，因为这可以提高移动的性能。<br>所以，使内存资源可互换是值得的，因为较少的移动会转换为拷贝。但你不应该让它们的互换性超过其目的需要。</p><h4><span id="27-3-wei-zi-ding-yi-lei-xing-ti-gong-nei-cun-zi-yuan-zhi-chi">27.3 为自定义类型提供内存资源支持</span><a href="#27-3-wei-zi-ding-yi-lei-xing-ti-gong-nei-cun-zi-yuan-zhi-chi" class="header-anchor">#</a></h4><p>在我们介绍了标准内存资源和用户定义的内存资源之后，还有一个问题。我们怎样才能使我们的自定义类型具有多态分配器意识，从而使它们像pmr::string一样作为pmr容器的一个元素，使用其分配器进行分配。</p><h5><span id="27-3-1-pmr-lei-xing-de-ding-yi">27.3.1 PMR类型的定义</span><a href="#27-3-1-pmr-lei-xing-de-ding-yi" class="header-anchor">#</a></h5><p>支持多态分配器的方法出奇的简单，只要对所有需要堆内存的数据使用pmr成员就可以了。你必须这样做。</p><ul><li>将allocator_type定义为多态分配器的公共成员</li><li>为所有构造函数添加重载，使其将分配器作为附加参数（包括复制和移动构造函数）。</li><li>让没有分配器参数的初始化构造函数使用allocator_type（如果实现的话，这不适用于复制和移动构造函数）。</li></ul><p>下面是第一个例子:</p><p><code>pmr/pmrcustomer.hpp </code></p><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;memory_resource&gt;</span></span><span class="hljs-comment">// 一个多态分配器感知类型 客户</span><span class="hljs-comment">// - 分配器存储在字符串成员中</span><span class="hljs-keyword">class</span> <span class="hljs-title class_">PmrCustomer</span>{    <span class="hljs-keyword">private</span>:    std::pmr::string name; <span class="hljs-comment">// 也用于存储分配器</span>    <span class="hljs-keyword">public</span>:    <span class="hljs-keyword">using</span> allocator_type = std::pmr::polymorphic_allocator&lt;<span class="hljs-type">char</span>&gt;;    <span class="hljs-comment">// 初始化构造函数 constructor(s):</span>    <span class="hljs-built_in">PmrCustomer</span>(std::pmr::string n, allocator_type alloc = {})        : name{std::<span class="hljs-built_in">move</span>(n), alloc} {        }    <span class="hljs-comment">// 使用分配器复制/移动:</span>    <span class="hljs-built_in">PmrCustomer</span>(<span class="hljs-type">const</span> PmrCustomer&amp; c, allocator_type alloc)        : name{c.name, alloc} {        }    <span class="hljs-built_in">PmrCustomer</span>(PmrCustomer&amp;&amp; c, allocator_type alloc)        : name{std::<span class="hljs-built_in">move</span>(c.name), alloc} {        }    <span class="hljs-comment">// setters/getters:</span>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">setName</span><span class="hljs-params">(std::pmr::string s)</span> </span>{        name = std::<span class="hljs-built_in">move</span>(s);    }    std::<span class="hljs-function">pmr::string <span class="hljs-title">getName</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>{        <span class="hljs-keyword">return</span> name;    }    <span class="hljs-function">std::string <span class="hljs-title">getNameAsString</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>{        <span class="hljs-keyword">return</span> std::string{name};    }};</code></pre></div><p>首先注意，我们使用一个pmr字符串作为成员。这不仅持有值（这里是名称），还持有当前使用的分配器:</p><div class="code-wrapper"><pre><code class="hljs c++">std::pmr::string name; <span class="hljs-comment">// 也用于存储分配器</span></code></pre></div><p>然后，我们必须指定这个类型支持多态分配器，这可以通过提供一个相应的allocator_type类型的声明来简单完成:</p><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">using</span> allocator_type = std::pmr::polymorphic_allocator&lt;<span class="hljs-type">char</span>&gt;;</code></pre></div><p>传递给polymorphic_allocator的类型并不重要（当它被使用时，分配器会被反弹到必要的类型）。例如，你也可以在那里使用std::byte。4 另外，你也可以使用字符串成员的allocator_type:</p><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">using</span> allocator_type = <span class="hljs-keyword">decltype</span>(name)::allocator_type;</code></pre></div><p>接下来我们定义通常的构造函数，增加一个可选的分配器参数。</p><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-built_in">PmrCustomer</span>(std::pmr::string n, allocator_type alloc = {})    : name{std::<span class="hljs-built_in">move</span>(n), alloc} {    }````你可以考虑将这样的构造函数声明为显式的。至少如果你有一个默认的构造函数，你应该这样做以避免从分配器到客户的隐式转换。```c++<span class="hljs-function"><span class="hljs-keyword">explicit</span> <span class="hljs-title">PmrCustomer</span><span class="hljs-params">(allocator_type alloc = {})</span></span><span class="hljs-function">    : name{</span>alloc} {    }</code></pre></div><p>然后，我们必须提供要求特定分配器的复制和移动操作。这是pmr容器的主要接口，确保其元素使用容器的分配器。</p><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-built_in">PmrCustomer</span>(<span class="hljs-type">const</span> PmrCustomer&amp; c, allocator_type alloc)    : name{c.name, alloc} {    }<span class="hljs-built_in">PmrCustomer</span>(PmrCustomer&amp;&amp; c, allocator_type alloc)    : name{std::<span class="hljs-built_in">move</span>(c.name), alloc} {    }</code></pre></div><p>注意，这两个都不是noexcept，因为如果所需的分配器allocator不能互换，即使是move构造函数也可能要复制一个被传递的客户。<br>最后，我们实现必要的setters和getters，它们通常是。</p><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">setName</span><span class="hljs-params">(std::pmr::string s)</span> </span>{    name = std::<span class="hljs-built_in">move</span>(s);}std::<span class="hljs-function">pmr::string <span class="hljs-title">getName</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>{    <span class="hljs-keyword">return</span> name;}</code></pre></div><p>还有一个getter，getNameAsString()，我们提供这个getter来廉价地将名字返回为 std::string。我们将在后面讨论它。目前，你也可以不使用它。</p><h5><span id="27-3-2-pmr-lei-xing-de-yong-fa">27.3.2 PMR类型的用法</span><a href="#27-3-2-pmr-lei-xing-de-yong-fa" class="header-anchor">#</a></h5><p>有了上面 PmrCustomer 的定义，我们就可以在 pmr 容器中使用这个类型了。 例如：</p><p><code>pmr/pmrcustomer1.cpp</code></p><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">"pmrcustomer.hpp"</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">"tracker.hpp"</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>{    Tracker tracker;    std::<span class="hljs-function">pmr::vector&lt;PmrCustomer&gt; <span class="hljs-title">coll</span><span class="hljs-params">(&amp;tracker)</span></span>;    coll.<span class="hljs-built_in">reserve</span>(<span class="hljs-number">100</span>); <span class="hljs-comment">// 用跟踪器分配</span>    PmrCustomer c1{<span class="hljs-string">"Peter, Paul &amp; Mary"</span>}; <span class="hljs-comment">// 用 get_default_resource() 分配</span>    coll.<span class="hljs-built_in">push_back</span>(c1); <span class="hljs-comment">// 使用vector分配器（跟踪器）进行分配</span>    coll.<span class="hljs-built_in">push_back</span>(std::<span class="hljs-built_in">move</span>(c1)); <span class="hljs-comment">// 副本（分配器不可互换）</span>    <span class="hljs-keyword">for</span> (<span class="hljs-type">const</span> <span class="hljs-keyword">auto</span>&amp; cust : coll) {        std::cout &lt;&lt; cust.<span class="hljs-built_in">getName</span>() &lt;&lt; <span class="hljs-string">'\n'</span>;    }}</code></pre></div><p>为了让人们看到所发生的事情，我们使用追踪器来追踪所有的分配和取消分配:</p><div class="code-wrapper"><pre><code class="hljs c++">Tracker tracker;std::<span class="hljs-function">pmr::vector&lt;PmrCustomer&gt; <span class="hljs-title">coll</span><span class="hljs-params">(&amp;tracker)</span></span>;</code></pre></div><p>当我们为100个元素保留内存时，vector使用我们的跟踪器来分配必要的数据:</p><div class="code-wrapper"><pre><code class="hljs c++">coll.<span class="hljs-built_in">reserve</span>(<span class="hljs-number">100</span>); <span class="hljs-comment">//用跟踪器分配</span></code></pre></div><p>当我们创建消费者时，不使用跟踪器：</p><div class="code-wrapper"><pre><code class="hljs c++">PmrCustomer c1{<span class="hljs-string">"Peter, Paul &amp; Mary"</span>}; <span class="hljs-comment">// 用 get_default_resource() 分配</span></code></pre></div><p>然而，当我们把customer的副本推到vector中时，vector会确保元素也都使用其多态分配器。由于这个原因，PmrCustomer的扩展拷贝构造函数被调用，其第二个参数是vector分配器，这样元素就被初始化了 与跟踪器一起初始化。</p><div class="code-wrapper"><pre><code class="hljs c++">std::<span class="hljs-function">pmr::vector&lt;PmrCustomer&gt; <span class="hljs-title">coll</span><span class="hljs-params">(&amp;tracker)</span></span>;...PmrCustomer c1{<span class="hljs-string">"Peter, Paul &amp; Mary"</span>}; <span class="hljs-comment">// 用 get_default_resource() 分配</span>coll.<span class="hljs-built_in">push_back</span>(c1); <span class="hljs-comment">// 使用vector分配器（跟踪器）进行分配</span></code></pre></div><p>如果我们把customer 移到vector中，也会发生同样的情况，因为vector的分配器（跟踪器）和客户的分配器（使用默认资源）是不能互换的：</p><div class="code-wrapper"><pre><code class="hljs c++">std::<span class="hljs-function">pmr::vector&lt;PmrCustomer&gt; <span class="hljs-title">coll</span><span class="hljs-params">(&amp;tracker)</span></span>;...PmrCustomer c1{<span class="hljs-string">"Peter, Paul &amp; Mary"</span>}; <span class="hljs-comment">// 用 get_default_resource() 分配</span>...coll.<span class="hljs-built_in">push_back</span>(std::<span class="hljs-built_in">move</span>(c1)); <span class="hljs-comment">// 副本（分配器不可互换）</span></code></pre></div><p>如果我们还使用跟踪器初始化客户，则移动将起作用：</p><div class="code-wrapper"><pre><code class="hljs c++">std::<span class="hljs-function">pmr::vector&lt;PmrCustomer&gt; <span class="hljs-title">coll</span><span class="hljs-params">(&amp;tracker)</span></span>;...PmrCustomer c1{<span class="hljs-string">"Peter, Paul &amp; Mary"</span>, &amp;tracker}; <span class="hljs-comment">// 用跟踪器分配</span>...coll.<span class="hljs-built_in">push_back</span>(std::<span class="hljs-built_in">move</span>(c1)); <span class="hljs-comment">// 移动（相同的分配器）</span></code></pre></div><p>如果我们根本不使用任何跟踪器，情况也是如此：</p><div class="code-wrapper"><pre><code class="hljs c++">std::pmr::vector&lt;PmrCustomer&gt; coll; <span class="hljs-comment">// 使用默认资源分配</span>...PmrCustomer c1{<span class="hljs-string">"Peter, Paul &amp; Mary"</span>}; <span class="hljs-comment">// 使用默认资源分配</span>...coll.<span class="hljs-built_in">push_back</span>(std::<span class="hljs-built_in">move</span>(c1)); <span class="hljs-comment">// 移动（相同的分配器）</span></code></pre></div><h5><span id="27-3-3-chu-li-bu-tong-de-lei-xing">27.3.3 处理不同的类型</span><a href="#27-3-3-chu-li-bu-tong-de-lei-xing" class="header-anchor">#</a></h5><p>虽然将 PmrCustomer 与 pmr 类型一起使用变得非常好，但我们有一个问题：通常，程序使用 std::string 类型的字符串。 那么我们如何处理同时使用 std::string 和 std::pmr::string 呢？<br>首先，不同字符串类型之间存在显式但没有隐式转换： </p><div class="code-wrapper"><pre><code class="hljs c++">std::string s;std::pmr::string t1{s}; <span class="hljs-comment">// OK</span>std::pmr::string t2 = s; <span class="hljs-comment">// ERROR</span>s = t1; <span class="hljs-comment">// ERROR</span>s = std::<span class="hljs-built_in">string</span>(t1); <span class="hljs-comment">// OK</span></code></pre></div><p>支持显式转换，因为任何字符串都会隐式转换为 std::string_view，它可以显式转换为任何字符串类型。 进一步降低成本，但后者需要分配内存（假设小字符串优化不适用）。<br>在我们的示例中，这意味着：</p><div class="code-wrapper"><pre><code class="hljs c++">std::string s{<span class="hljs-string">"Paul Kalkbrenner"</span>};PmrCustomer c1 = s; <span class="hljs-comment">// 错误：没有隐式转换</span>PmrCustomer c2{s}; <span class="hljs-comment">// 错误：没有隐式转换</span>PmrCustomer c3{std::pmr::string{s}}; <span class="hljs-comment">// OK（隐式将 s 转换为 string_view）</span></code></pre></div><p>我们可能想提供额外的构造函数，但不提供它们的好处是程序员被迫实现昂贵的转换。 此外，如果您为不同的字符串类型（std::string 和 std::pmr::string）重载，则会产生额外的歧义（例如，采用 string_view 或字符串文字），因此需要更多的重载。<br>无论如何，getter 只能返回一种类型（因为我们不能只重载不同的返回类型）。 因此，我们只能提供一个 getter，它通常应该返回 API 的“本机”类型（这里是 std::pmr::string）。 这意味着，如果我们返回一个 std::pmr::string 并且需要名称为 std::string，我们再次需要显式转换：</p><div class="code-wrapper"><pre><code class="hljs c++">PmrCustomer c4{<span class="hljs-string">"Mr. Paul Kalkbrenner"</span>}; <span class="hljs-comment">// OK：使用默认资源分配</span>std::string s1 = c4.<span class="hljs-built_in">getName</span>(); <span class="hljs-comment">// 错误：没有隐式转换</span>std::string s2 = std::string{c4.<span class="hljs-built_in">getName</span>()}; <span class="hljs-comment">// OOPS：两个分配</span></code></pre></div><p>这不仅不太方便，这也是一个性能问题，因为在最后一条语句中发生了两次分配：</p><ul><li>首先我们为返回值分配内存，然后</li><li>那么从 std::pmr::string 类型到 std::string 的转换需要另一个分配。</li></ul><p>出于这个原因，提供一个额外的 getNameAsString() 直接创建并返回请求的类型可能是个好主意：</p><div class="code-wrapper"><pre><code class="hljs c++">std::string s3 = c4.<span class="hljs-built_in">getNameAsString</span>(); <span class="hljs-comment">// OK：一次分配</span></code></pre></div><h4><span id="27-4-hou-ji">27.4 后记</span><a href="#27-4-hou-ji" class="header-anchor">#</a></h4><p>多态分配器首先由 Pablo Halpern 在 <a href="https://wg21.link/n3525">https://wg21.link/n3525</a> 中提出。 这<br>采用 Pablo Halpern 在 <a href="https://wg21.link/n3916">https://wg21.link/n3916</a> 中提出的方法成为图书馆基础 TS 的一部分。 该方法与 Beman Dawes 和 Alisdair Meredith 在 <a href="https://wg21.link/p0220r1">https://wg21.link/p0220r1</a> 中提出的 C++17 的其他组件一起采用。</p><h3><span id="28-dui-qi-shu-ju-shang-de-new-he-delete">28  对齐数据上的new和delete</span><a href="#28-dui-qi-shu-ju-shang-de-new-he-delete" class="header-anchor">#</a></h3><p>从C++11开始，你可以指定过度对齐的类型，通过使用alignas指定器，拥有比默认对齐方式更大的对齐方式。比如说:</p><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">alignas</span>(<span class="hljs-number">32</span>) MyType32 {    <span class="hljs-type">int</span> i;    <span class="hljs-type">char</span> c;    std::string s[<span class="hljs-number">4</span>];};MyType32 val1; <span class="hljs-comment">// 32 字节对齐</span><span class="hljs-built_in">alignas</span>(<span class="hljs-number">64</span>) MyType32 val2; <span class="hljs-comment">// 64 字节对齐</span></code></pre></div><p>请注意，对齐值必须是 2 的幂，并且指定小于该类型默认对齐的任何值都是错误的。<br>但是，过度对齐数据的动态/堆分配在 C++11 和 C++14 中未正确处理。 默认情况下，对过度对齐的类型使用 operator new 会忽略请求的对齐方式，因此通常 63 字节对齐的类型可能例如仅 8 字节或 16 字节对齐。<br>C++17 弥补了这一差距。 新行为的结果是提供了带有对齐参数的新重载，以便能够为过度对齐的数据提供您自己的 operator new 实现。</p><h4><span id="28-1-shi-yong-xin-de-dui-qi-fang-shi">28.1 使用新的对齐方式</span><a href="#28-1-shi-yong-xin-de-dui-qi-fang-shi" class="header-anchor">#</a></h4><p>通过使用过度对齐的类型，例如： </p><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">alignas</span>(<span class="hljs-number">32</span>) MyType32 {    <span class="hljs-type">int</span> i;    <span class="hljs-type">char</span> c;    std::string s[<span class="hljs-number">4</span>];};</code></pre></div><p>一个新的表达式现在可以保证所请求的堆内存是按要求对齐的（前提是 支持过度对齐）:</p><div class="code-wrapper"><pre><code class="hljs c++">MyType32* p = <span class="hljs-keyword">new</span> MyType32; <span class="hljs-comment">// 因为 C++17 保证是 32 字节对齐的</span>...</code></pre></div><p>在C++17之前，请求不保证是32字节对齐的。<br>像往常一样，没有任何初始化的值，对象是默认初始化的，这意味着可用的构造器被调用，但基本类型的（子）对象有一个未定义的值。由于这个原因，你最好使用带大括号的列表初始化，以确保（子）对象要么有其默认值或0/false/nullptr：</p><div class="code-wrapper"><pre><code class="hljs c++">MyType32* p = <span class="hljs-keyword">new</span> MyType32{}; <span class="hljs-comment">// 对齐和初始化</span></code></pre></div><h5><span id="28-1-1-bu-tong-de-dong-tai-dui-zhan-nei-cun-ling-yu">28.1.1 不同的动态/堆栈内存领域</span><a href="#28-1-1-bu-tong-de-dong-tai-dui-zhan-nei-cun-ling-yu" class="header-anchor">#</a></h5><p>请注意，对对齐内存的请求可能会导致调用从一个不相连的内存分配机制中获取内存。由于这个原因，对对齐内存的请求可能需要一个特定的相应请求来取消对齐数据。有可能内存是用C11函数aligned_alloc()分配的（现在在C++17中也可用）。在这种情况下，用free()去分配还是可以的，这样与用malloc()分配的内存相比就没有什么区别。<br>然而，对于平台来说，new和delete的其他实现是允许的，这就导致了必须用不同的内部函数去分配默认对齐的和超对齐的数据的要求。例如，在Windows上通常使用_aligned_malloc()，这就要求使用_aligned_free()作为对应。<br>与C标准相比，C++标准尊重这种情况，因此在概念上假定有两个互不相干的、不可操作的内存区域，一个用于默认对齐的数据，一个用于超对齐的数据。大多数情况下，编译器知道如何正确地处理这个问题：</p><div class="code-wrapper"><pre><code class="hljs c++">std::string* p1 = <span class="hljs-keyword">new</span> std::string; <span class="hljs-comment">// 使用默认对齐的内存操作</span>MyType32* p2 = <span class="hljs-keyword">new</span> MyType32; <span class="hljs-comment">// 使用过度对齐的内存操作</span>...<span class="hljs-keyword">delete</span> p1; <span class="hljs-comment">// 使用默认对齐的内存操作</span><span class="hljs-keyword">delete</span> p2; <span class="hljs-comment">// 使用过度对齐的内存操作</span></code></pre></div><p>但有时程序员必须做正确的事情，正如我们将在本章的其余部分中看到的那样。</p><h5><span id="28-1-2-yong-new-biao-da-shi-chuan-di-dui-qi-fang-shi">28.1.2 用new表达式传递对齐方式</span><a href="#28-1-2-yong-new-biao-da-shi-chuan-di-dui-qi-fang-shi" class="header-anchor">#</a></h5><p>还有一种方法是为特定的新调用请求特定的过度对齐。比如说：</p><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;new&gt;</span> <span class="hljs-comment">// for align_val_t</span></span>...std::string* p = <span class="hljs-built_in">new</span>(std::<span class="hljs-type">align_val_t</span>{<span class="hljs-number">64</span>}) std::string; <span class="hljs-comment">// 64 字节对齐</span>MyType32* p = <span class="hljs-built_in">new</span>(std::<span class="hljs-type">align_val_t</span>{<span class="hljs-number">64</span>}) MyType32{}; <span class="hljs-comment">// 64 字节对齐</span>...</code></pre></div><p>std::align_val_t 类型在标头 <new> 中定义如下：</new></p><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">namespace</span> std {    <span class="hljs-keyword">enum class</span> <span class="hljs-title class_">align_val_t</span> : <span class="hljs-type">size_t</span> {    };}</code></pre></div><p>它被规定为现在能够将对齐请求传递给运算符new()的相应实现。请记住，在C++中运算符new()可以用不同的方式实现。</p><ul><li>作为一个全局函数（默认提供了不同的重载，可以由程序员替换）。</li><li>作为特定类型的实现，可以由程序员提供，并具有比全局重载更高的 优先级高于全局重载。</li></ul><p>然而，这是第一个例子，必须特别注意正确处理不同的动态内存领域，因为当用新的表达式指定对齐方式时，编译器不能使用类型来知道是否以及哪种对齐方式被请求。程序员必须指定调用哪个删除操作。<br>不幸的是，没有一个删除操作符，你可以传递一个额外的参数，你必须直接调用相应的操作符delete()，这意味着你必须知道多个重载中的哪一个被实现。事实上，在这个例子中，对于一个T类型的对象，可以调用以下函数中的一个 类型的对象，可以调用以下函数之一:</p><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> T::<span class="hljs-keyword">operator</span> <span class="hljs-title">delete</span><span class="hljs-params">(<span class="hljs-type">void</span>* ptr, std::<span class="hljs-type">size_t</span> size, std::<span class="hljs-type">align_val_t</span> align)</span></span>;<span class="hljs-function"><span class="hljs-type">void</span> T::<span class="hljs-keyword">operator</span> <span class="hljs-title">delete</span><span class="hljs-params">(<span class="hljs-type">void</span>* ptr, std::<span class="hljs-type">align_val_t</span> align)</span></span>;<span class="hljs-function"><span class="hljs-type">void</span> T::<span class="hljs-keyword">operator</span> <span class="hljs-title">delete</span><span class="hljs-params">(<span class="hljs-type">void</span>* ptr, std::<span class="hljs-type">size_t</span> size)</span></span>;<span class="hljs-function"><span class="hljs-type">void</span> T::<span class="hljs-keyword">operator</span> <span class="hljs-title">delete</span><span class="hljs-params">(<span class="hljs-type">void</span>* ptr)</span></span>;<span class="hljs-type">void</span> ::<span class="hljs-function"><span class="hljs-keyword">operator</span> <span class="hljs-title">delete</span><span class="hljs-params">(<span class="hljs-type">void</span>* ptr, std::<span class="hljs-type">size_t</span> size, std::<span class="hljs-type">align_val_t</span> align)</span></span>;<span class="hljs-type">void</span> ::<span class="hljs-function"><span class="hljs-keyword">operator</span> <span class="hljs-title">delete</span><span class="hljs-params">(<span class="hljs-type">void</span>* ptr, std::<span class="hljs-type">align_val_t</span> align)</span></span>;<span class="hljs-type">void</span> ::<span class="hljs-function"><span class="hljs-keyword">operator</span> <span class="hljs-title">delete</span><span class="hljs-params">(<span class="hljs-type">void</span>* ptr, std::<span class="hljs-type">size_t</span> size)</span></span>;<span class="hljs-type">void</span> ::<span class="hljs-function"><span class="hljs-keyword">operator</span> <span class="hljs-title">delete</span><span class="hljs-params">(<span class="hljs-type">void</span>* ptr)</span></span>;</code></pre></div><p>是的，就是这么复杂，我将在后面详细解释。目前，请使用三个选项中的一个。</p><ol><li>不要在新的表达式中直接使用过度对齐。</li><li>提供操作者new()和操作者delete()的实现，使用相同的内存区域（这样调用delete总是可以的）。</li><li>提供与运算符new()相匹配的运算符delete()的特定类型实现，并直接调用它们，而不是使用delete表达式。</li></ol><p>注意，你不能使用类型定义或使用声明来代替:</p><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">using</span> MyType64 = <span class="hljs-built_in">alignas</span>(<span class="hljs-number">64</span>) MyType32; <span class="hljs-comment">// ERROR</span><span class="hljs-function"><span class="hljs-keyword">typedef</span> <span class="hljs-title">alignas</span><span class="hljs-params">(<span class="hljs-number">64</span>)</span> MyType32 MyType64</span>; <span class="hljs-comment">// ERROR</span>...MyType64* p = <span class="hljs-keyword">new</span> MyType64; <span class="hljs-comment">// 因此不可能</span></code></pre></div><p>原因是typedef或using声明只是原始类型的一个新名称/别名，这里所要求的是一个不同的类型，遵循不同的对齐规则。<br>如果你想调用一个对齐的new，获得nullptr作为返回值，而不是抛出 std::bad_alloc，你可以这样做：</p><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-comment">// 分配一个 64 字节对齐的字符串（如果没有，则为 nullptr）:</span>std::string* p = <span class="hljs-built_in">new</span>(std::<span class="hljs-type">align_val_t</span>{<span class="hljs-number">64</span>}, std::nothrow) std::string;<span class="hljs-keyword">if</span> (p != <span class="hljs-literal">nullptr</span>) {    ...}</code></pre></div><h4><span id="28-2-wei-dui-qi-de-nei-cun-shi-xian-cao-zuo-fu-new">28.2 为对齐的内存实现操作符new()</span><a href="#28-2-wei-dui-qi-de-nei-cun-shi-xian-cao-zuo-fu-new" class="header-anchor">#</a></h4><p>在C++中，当new和delete被调用时，你可以提供你自己的分配和删除内存的实现。这种机制现在也支持传递一个对齐参数。</p><h5><span id="28-2-1-zai-c-17-zhi-qian-shi-xian-dui-qi-fen-pei">28.2.1 在C++17之前实现对齐分配</span><a href="#28-2-1-zai-c-17-zhi-qian-shi-xian-dui-qi-fen-pei" class="header-anchor">#</a></h5><p>在全局范围内，C++提供了操作符new()和操作符delete()的重载，除非定义了特定类型的实现，否则会使用这些操作符。如果存在这些操作符的特定类型的实现，就会使用它们。请注意，有一个特定类型的操作符new()，就不能使用该类型的任何全局操作符new()实现（同样适用于delete、new[]和 delete[]）。</p><p>也就是说，每次为类型 T 调用 new 时，都会调用特定类型的 T::operator new() 或（如果不存在）全局 ::operator new() 的相应调用：</p><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">auto</span> p = <span class="hljs-keyword">new</span> T; <span class="hljs-comment">// 尝试调用特定类型的运算符 new()（如果有）</span><span class="hljs-comment">// 如果没有尝试调用全局 ::operator new()</span></code></pre></div><p>同样地，每次你为一个类型T调用delete时，都会相应地调用特定类型的T::operator delete()或全局的::operator delete()。如果数组被分配/去分配，相应的特定类型或全局操作符operator new<a href></a>和operator delete<a href></a>被调用。<br>在C++17之前，要求的对齐方式不会自动传递给这些函数，默认机制分配动态内存时不会考虑对齐方式。一个过度对齐的类型总是需要自己实现operator new()和operator delete()才能在动态内存上正确对齐。更糟糕的是，没有可移植的方法来执行对过度对齐的动态内存的请求。<br>因此，举例来说，你必须定义如下的东西:</p><p><code>lang/alignednew11.hpp </code></p><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstddef&gt;</span> <span class="hljs-comment">// for std::size_t</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">if</span> __STDC_VERSION &gt;= 201112L</span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span> <span class="hljs-comment">// for aligned_alloc()</span></span><span class="hljs-meta">#<span class="hljs-keyword">else</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;malloc.h&gt;</span> <span class="hljs-comment">// for _aligned_malloc() or memalign()</span></span><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><span class="hljs-keyword">struct</span> <span class="hljs-title class_">alignas</span>(<span class="hljs-number">32</span>) MyType32 {    <span class="hljs-type">int</span> i;    <span class="hljs-type">char</span> c;    std::string s[<span class="hljs-number">4</span>];    ...;    <span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">void</span>* <span class="hljs-keyword">operator</span> <span class="hljs-title">new</span> <span class="hljs-params">(std::<span class="hljs-type">size_t</span> size)</span> </span>{        <span class="hljs-comment">// 为要求的排列方式分配内存:</span>        <span class="hljs-meta">#<span class="hljs-keyword">if</span> __STDC_VERSION &gt;= 201112L</span>        <span class="hljs-comment">// use API of C11:</span>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">aligned_alloc</span>(<span class="hljs-built_in">alignof</span>(MyType32), size);        <span class="hljs-meta">#<span class="hljs-keyword">else</span></span>        <span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> _MSC_VER</span>        <span class="hljs-comment">// use API of Windows:</span>        <span class="hljs-keyword">return</span> _aligned_malloc(size, <span class="hljs-built_in">alignof</span>(MyType32));        <span class="hljs-meta">#<span class="hljs-keyword">else</span></span>        <span class="hljs-comment">// use API of Linux:</span>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">memalign</span>(<span class="hljs-built_in">alignof</span>(MyType32), size);        <span class="hljs-meta">#<span class="hljs-keyword">endif</span></span>        <span class="hljs-meta">#<span class="hljs-keyword">endif</span></span>    }    <span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-keyword">operator</span> <span class="hljs-title">delete</span> <span class="hljs-params">(<span class="hljs-type">void</span>* p)</span> </span>{        <span class="hljs-comment">// 为所要求的对齐方式取消分配内存:</span>        <span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> _MSC_VER</span>        <span class="hljs-comment">// 使用Windows的特殊API:</span>        _aligned_free(p);        <span class="hljs-meta">#<span class="hljs-keyword">else</span></span>        <span class="hljs-comment">// C11/Linux可以使用通用的free()函数。:</span>        <span class="hljs-built_in">free</span>(p);        <span class="hljs-meta">#<span class="hljs-keyword">endif</span></span>    }    <span class="hljs-comment">// since C++14:</span>    <span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-keyword">operator</span> <span class="hljs-title">delete</span> <span class="hljs-params">(<span class="hljs-type">void</span>* p, std::<span class="hljs-type">size_t</span> size)</span> </span>{        <span class="hljs-function">MyType32::<span class="hljs-keyword">operator</span> <span class="hljs-title">delete</span><span class="hljs-params">(p)</span></span>; <span class="hljs-comment">// 使用非尺寸删除</span>    }    ...;    <span class="hljs-comment">// also for arrays (new[] and delete[])</span>};</code></pre></div><p>注意，从C++14开始，你可以为删除操作符提供一个大小参数。然而，可能会发生尺寸不可用的情况（例如，当处理不完整的类型时），有些情况下，平台可以选择是否向操作符delete()传递一个尺寸参数。出于这个原因，自C++14以来，你应该总是同时替换操作符delete()的无大小和有大小的重载。让一个人调用另一个人通常是可以的。<br>有了这个定义，下面的代码表现得很正确：</p><p><code>lang/alignednew11.cpp </code></p><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">"alignednew11.hpp"</span></span><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>{    <span class="hljs-keyword">auto</span> p = <span class="hljs-keyword">new</span> MyType32;    ...;    <span class="hljs-keyword">delete</span> p;}</code></pre></div><p>如所写，从 C++17 开始，您可以跳过执行操作以分配/取消分配对齐数据的开销。 即使没有为您的类型定义 operator new() 和 operator delete()，该示例也能正常工作：</p><p><code>lang/alignednew17.cpp </code></p><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span><span class="hljs-keyword">struct</span> <span class="hljs-title class_">alignas</span>(<span class="hljs-number">32</span>) MyType32 {    <span class="hljs-type">int</span> i;    <span class="hljs-type">char</span> c;    std::string s[<span class="hljs-number">4</span>];    ...};<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>{    <span class="hljs-keyword">auto</span> p = <span class="hljs-keyword">new</span> MyType32; <span class="hljs-comment">// 从C++17开始分配32字节对齐的内存</span>    ...;    <span class="hljs-keyword">delete</span> p;}</code></pre></div><h5><span id="28-2-2-shi-xian-te-ding-lei-xing-cao-zuo-fu-new">28.2.2 实现特定类型操作符new()</span><a href="#28-2-2-shi-xian-te-ding-lei-xing-cao-zuo-fu-new" class="header-anchor">#</a></h5><p>如果你必须自己实现运算符new()和运算符delete()，现在已经支持超对齐数据。在实践中，特定类型的相应代码 实现的相应代码自C++17以来看起来如下：</p><p><code>lang/alignednew.hpp </code></p><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstddef&gt;</span> <span class="hljs-comment">// for std::size_t</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;new&gt;</span> <span class="hljs-comment">// for std::align_val_t</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstdlib&gt;</span> <span class="hljs-comment">// for malloc(), aligned_alloc(), free()</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span><span class="hljs-keyword">struct</span> <span class="hljs-title class_">alignas</span>(<span class="hljs-number">32</span>) MyType32 {    <span class="hljs-type">int</span> i;    <span class="hljs-type">char</span> c;    std::string s[<span class="hljs-number">4</span>];    ...;    <span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">void</span>* <span class="hljs-keyword">operator</span> <span class="hljs-title">new</span> <span class="hljs-params">(std::<span class="hljs-type">size_t</span> size)</span> </span>{        <span class="hljs-comment">// 要求默认对齐的数据:</span>        <span class="hljs-comment">// 调用默认对其数据：</span>        std::cout &lt;&lt; <span class="hljs-string">"MyType32::new() with size "</span> &lt;&lt; size &lt;&lt; <span class="hljs-string">'\n'</span>;        <span class="hljs-keyword">return</span> ::<span class="hljs-keyword">operator</span> <span class="hljs-built_in">new</span>(size);    }    <span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">void</span>* <span class="hljs-keyword">operator</span> <span class="hljs-title">new</span> <span class="hljs-params">(std::<span class="hljs-type">size_t</span> size, std::<span class="hljs-type">align_val_t</span> align)</span> </span>{        <span class="hljs-comment">// 要求过度对齐的数据:</span>        std::cout &lt;&lt; <span class="hljs-string">"MyType32::new() with size "</span> &lt;&lt; size            &lt;&lt; <span class="hljs-string">" and alignment "</span> &lt;&lt; <span class="hljs-built_in">static_cast</span>&lt;std::<span class="hljs-type">size_t</span>&gt;(align)            &lt;&lt; <span class="hljs-string">'\n'</span>;        <span class="hljs-keyword">return</span> ::<span class="hljs-keyword">operator</span> <span class="hljs-built_in">new</span>(size, align);    }    <span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-keyword">operator</span> <span class="hljs-title">delete</span> <span class="hljs-params">(<span class="hljs-type">void</span>* p)</span> </span>{        <span class="hljs-comment">// 要求默认对齐的数据:</span>        std::cout &lt;&lt; <span class="hljs-string">"MyType32::delete() without alignment\n"</span>;        ::<span class="hljs-function"><span class="hljs-keyword">operator</span> <span class="hljs-title">delete</span><span class="hljs-params">(p)</span></span>;    }    <span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-keyword">operator</span> <span class="hljs-title">delete</span> <span class="hljs-params">(<span class="hljs-type">void</span>* p, std::<span class="hljs-type">size_t</span> size)</span> </span>{        <span class="hljs-function">MyType32::<span class="hljs-keyword">operator</span> <span class="hljs-title">delete</span><span class="hljs-params">(p)</span></span>; <span class="hljs-comment">// 使用非大小删除</span>    }    <span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-keyword">operator</span> <span class="hljs-title">delete</span> <span class="hljs-params">(<span class="hljs-type">void</span>* p, std::<span class="hljs-type">align_val_t</span> align)</span> </span>{        <span class="hljs-comment">// 要求默认对齐的数据:</span>        std::cout &lt;&lt; <span class="hljs-string">"MyType32::delete() with alignment\n"</span>;        ::<span class="hljs-function"><span class="hljs-keyword">operator</span> <span class="hljs-title">delete</span><span class="hljs-params">(p, align)</span></span>;    }    <span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-keyword">operator</span> <span class="hljs-title">delete</span> <span class="hljs-params">(<span class="hljs-type">void</span>* p, std::<span class="hljs-type">size_t</span> size,</span></span><span class="hljs-params"><span class="hljs-function">                                 std::<span class="hljs-type">align_val_t</span> align)</span> </span>{        <span class="hljs-function">MyType32::<span class="hljs-keyword">operator</span> <span class="hljs-title">delete</span><span class="hljs-params">(p, align)</span></span>; <span class="hljs-comment">// 使用非大小删除</span>    }    <span class="hljs-comment">// also for arrays (operator new[] and operator delete[])</span>    ...;};</code></pre></div><p>原则上，我们只需要额外对齐参数的重载，并调用函数来分配和释放对齐的内存。 最便携的方法是调用为过度对齐（取消）分配提供的全局函数：</p><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">void</span>* <span class="hljs-keyword">operator</span> <span class="hljs-title">new</span> <span class="hljs-params">(std::<span class="hljs-type">size_t</span> size, std::<span class="hljs-type">align_val_t</span> align)</span> </span>{    ...;    <span class="hljs-keyword">return</span> ::<span class="hljs-keyword">operator</span> <span class="hljs-built_in">new</span>(size, align);}...;<span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-keyword">operator</span> <span class="hljs-title">delete</span> <span class="hljs-params">(<span class="hljs-type">void</span>* p, std::<span class="hljs-type">align_val_t</span> align)</span> </span>{    ...;    ::<span class="hljs-function"><span class="hljs-keyword">operator</span> <span class="hljs-title">delete</span><span class="hljs-params">(p)</span></span>;}</code></pre></div><p>您也可以直接调用 C11 函数进行对齐分配：</p><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">void</span>* <span class="hljs-keyword">operator</span> <span class="hljs-title">new</span> <span class="hljs-params">(std::<span class="hljs-type">size_t</span> size, std::<span class="hljs-type">align_val_t</span> align)</span> </span>{    ...;    <span class="hljs-keyword">return</span> std::<span class="hljs-built_in">aligned_alloc</span>(<span class="hljs-built_in">static_cast</span>&lt;<span class="hljs-type">size_t</span>&gt;(align), size);}...;<span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-keyword">operator</span> <span class="hljs-title">delete</span> <span class="hljs-params">(<span class="hljs-type">void</span>* p, std::<span class="hljs-type">align_val_t</span> align)</span> </span>{    ...;    std::<span class="hljs-built_in">free</span>(p);}</code></pre></div><p>然而，由于Windows对aligned_alloc()的问题，在实践中，我们需要特殊的处理方式来进行移植，那么:</p><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">void</span>* <span class="hljs-keyword">operator</span> <span class="hljs-title">new</span> <span class="hljs-params">(std::<span class="hljs-type">size_t</span> size, std::<span class="hljs-type">align_val_t</span> align)</span> </span>{    ...;    <span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> _MSC_VER</span>    <span class="hljs-comment">// 特定于 Windows 的 API:</span>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">aligned_malloc</span>(size, <span class="hljs-built_in">static_cast</span>&lt;<span class="hljs-type">size_t</span>&gt;(align));    <span class="hljs-meta">#<span class="hljs-keyword">else</span></span>    <span class="hljs-comment">// 标准 C++17 API:</span>    <span class="hljs-keyword">return</span> std::<span class="hljs-built_in">aligned_alloc</span>(<span class="hljs-built_in">static_cast</span>&lt;<span class="hljs-type">size_t</span>&gt;(align), size);    <span class="hljs-meta">#<span class="hljs-keyword">endif</span></span>}<span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-keyword">operator</span> <span class="hljs-title">delete</span> <span class="hljs-params">(<span class="hljs-type">void</span>* p, std::<span class="hljs-type">align_val_t</span> align)</span> </span>{    ...;    <span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> _MSC_VER</span>    <span class="hljs-comment">// 特定于 Windows 的 API:</span>    _aligned_free(p);    <span class="hljs-meta">#<span class="hljs-keyword">else</span></span>    <span class="hljs-comment">// 标准 C++17 API:</span>    std::<span class="hljs-built_in">free</span>(p);    <span class="hljs-meta">#<span class="hljs-keyword">endif</span></span>}</code></pre></div><p>请注意，所有的分配函数都将对齐参数作为size_t类型，这意味着我们必须使用静态转换来从std::align_val_t类型转换数值。<br>此外，你可能想用[[nodiscard]]声明运算符new()的重载。属性:</p><div class="code-wrapper"><pre><code class="hljs c++">[[nodiscard]] <span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">void</span>* <span class="hljs-keyword">operator</span> <span class="hljs-title">new</span> <span class="hljs-params">(std::<span class="hljs-type">size_t</span> size)</span> </span>{    ...;}[[nodiscard]] <span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">void</span>* <span class="hljs-keyword">operator</span> <span class="hljs-title">new</span> <span class="hljs-params">(std::<span class="hljs-type">size_t</span> size,</span></span><span class="hljs-params"><span class="hljs-function">                                         std::<span class="hljs-type">align_val_t</span> align)</span> </span>{    ...;}</code></pre></div><p>直接调用运算符new()（不使用new表达式）是很罕见的，但（正如你在这里看到的）是可能的。有了[[nodiscard]]，编译器会检测到，如果调用者忘记使用返回值，这将导致内存泄漏。</p><h6><span id="operator-new-shi-me-shi-hou-diao-yong">operator new() 什么时候调用？</span><a href="#operator-new-shi-me-shi-hou-diao-yong" class="header-anchor">#</a></h6><p>正如所介绍的，我们现在可以有两个重载的操作符new()。</p><ul><li>只有size参数的版本，在C++17之前也被支持，一般是为默认对齐的数据请求提供的。<br>然而，如果没有提供用于大对齐数据的版本，它也可以作为回退。</li><li>带有额外对齐参数的版本，自C++17以来得到了特别的支持，一般是为超对齐数据的请求提供的。</li></ul><p>使用哪个重载不一定取决于是否使用了alignas。它取决于特定平台对过对齐数据的定义。<br>编译器会根据一个一般的对齐值从默认对齐切换到超对齐，这个值 你可以在新的预处理程序常量中找到<br>__stdcpp_default_new_alignment__。<br>也就是说，在任何大于这个常数的对齐方式下，调用new会从试图调用</p><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">operator</span> <span class="hljs-title">new</span><span class="hljs-params">(std::<span class="hljs-type">size_t</span>)</span></span></code></pre></div><p>试调用：</p><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">operator</span> <span class="hljs-title">new</span><span class="hljs-params">(std::<span class="hljs-type">size_t</span>, std::<span class="hljs-type">align_val_t</span>)</span></span></code></pre></div><p>因此，以下代码的输出可能因平台而异:</p><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">alignas</span>(<span class="hljs-number">32</span>) MyType32 {    ...;    <span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">void</span>* <span class="hljs-keyword">operator</span> <span class="hljs-title">new</span> <span class="hljs-params">(std::<span class="hljs-type">size_t</span> size)</span> </span>{        std::cout &lt;&lt; <span class="hljs-string">"MyType32::new() with size "</span> &lt;&lt; size &lt;&lt; <span class="hljs-string">'\n'</span>;        <span class="hljs-keyword">return</span> ::<span class="hljs-keyword">operator</span> <span class="hljs-built_in">new</span>(size);    }    <span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">void</span>* <span class="hljs-keyword">operator</span> <span class="hljs-title">new</span> <span class="hljs-params">(std::<span class="hljs-type">size_t</span> size, std::<span class="hljs-type">align_val_t</span> align)</span> </span>{        std::cout &lt;&lt; <span class="hljs-string">"MyType32::new() with size "</span> &lt;&lt; size            &lt;&lt; <span class="hljs-string">" and alignment "</span> &lt;&lt; <span class="hljs-built_in">static_cast</span>&lt;std::<span class="hljs-type">size_t</span>&gt;(align) &lt;&lt; <span class="hljs-string">'\n'</span>;        <span class="hljs-keyword">return</span> ::<span class="hljs-keyword">operator</span> <span class="hljs-built_in">new</span>(size, align);        ::<span class="hljs-function"><span class="hljs-keyword">operator</span> <span class="hljs-title">delete</span><span class="hljs-params">(p)</span></span>;    }    ...;};<span class="hljs-keyword">auto</span> p = <span class="hljs-keyword">new</span> MyType32;</code></pre></div><p>如果默认的对齐方式是32（或者更少，并且代码可以编译），表达式new MyType32将调用运算符new()的第一个重载，只有大小参数，所以输出是这样的 像这样:</p><div class="code-wrapper"><pre><code class="hljs bash">MyType32::new() with size 128</code></pre></div><p>如果默认对齐方式小于32，将调用两个参数的运算符new()的第二个重载，这样输出就变成了这样:</p><div class="code-wrapper"><pre><code class="hljs bash">MyType32::new() with size 128 and alignment 32</code></pre></div><p>如果没有为特定类型的运算符new()提供std::align_val_t重载，没有这个参数的重载将被用作回退。因此，一个只提供C++17之前支持的运算符new()重载的类仍然可以编译并具有相同的行为（注意，对于全局运算符new()来说，情况不是这样的）:</p><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">NonalignedNewOnly</span> {    ...;    <span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">void</span>* <span class="hljs-keyword">operator</span> <span class="hljs-title">new</span> <span class="hljs-params">(std::<span class="hljs-type">size_t</span> size)</span> </span>{        ...;    }    ...; <span class="hljs-comment">// 不operato new(std::size_t, std::align_val_t align)</span>};<span class="hljs-keyword">auto</span> p = <span class="hljs-keyword">new</span> NonalignedNewOnly; <span class="hljs-comment">// OK：使用了操作符new(size_t)。</span></code></pre></div><p>反之则不然。如果一个类型只提供了带有对齐方式参数的重载，那么任何使用默认对齐方式的new分配存储的尝试都会失败：</p><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">AlignedNewOnly</span> {    ...; <span class="hljs-comment">// no operator new(std::size_t)</span>    <span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">void</span>* <span class="hljs-keyword">operator</span> <span class="hljs-title">new</span> <span class="hljs-params">(std::<span class="hljs-type">size_t</span> size, std::<span class="hljs-type">align_val_t</span> align)</span> </span>{        <span class="hljs-keyword">return</span> std::<span class="hljs-built_in">aligned_alloc</span>(<span class="hljs-built_in">static_cast</span>&lt;<span class="hljs-type">size_t</span>&gt;(align), size);    }};<span class="hljs-keyword">auto</span> p = <span class="hljs-keyword">new</span> AlignedNewOnly; <span class="hljs-comment">// 错误：没有用于默认对齐的运算符 new()</span></code></pre></div><p>如果对该类型要求的对齐方式是（小于）默认的对齐方式，这也将是一个错误。</p><h6><span id="zai-xin-de-biao-da-shi-zhong-qing-qiu-dui-qi">在新的表达式中请求对齐</span><a href="#zai-xin-de-biao-da-shi-zhong-qing-qiu-dui-qi" class="header-anchor">#</a></h6><p>如果你在new表达式中传递了一个要求的对齐方式，那么传递的对齐方式参数总是被传递，并且必须被操作符new()所支持。事实上，对齐方式参数的处理与你可以传递给新表达式的任何其他额外参数一样。它们被作为附加参数传递给运算符new()。<br>因此，一个调用，如:</p><div class="code-wrapper"><pre><code class="hljs c++">std::string* p = <span class="hljs-built_in">new</span>(std::<span class="hljs-type">align_val_t</span>{<span class="hljs-number">64</span>}) std::string; <span class="hljs-comment">// 64 字节对齐</span></code></pre></div><p>将始终尝试调用：</p><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">operator</span> <span class="hljs-title">new</span><span class="hljs-params">(std::<span class="hljs-type">size_t</span>, std::<span class="hljs-type">align_val_t</span>)</span></span></code></pre></div><p>一个仅有大小的重载在这里不会作为fallback。<br>如果你对一个过度对齐的类型有一个特定的对齐请求，其行为就更加有趣了。例如，如果你调用:</p><div class="code-wrapper"><pre><code class="hljs c++">MyType32* p = <span class="hljs-built_in">new</span>(std::<span class="hljs-type">align_val_t</span>{<span class="hljs-number">64</span>}) MyType32{};</code></pre></div><p>并且 MyType32 过度对齐，编译器首先尝试调用:</p><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">operator</span> <span class="hljs-title">new</span><span class="hljs-params">(std::<span class="hljs-type">size_t</span>, std::<span class="hljs-type">align_val_t</span>, std::<span class="hljs-type">align_val_t</span>)</span></span></code></pre></div><p>32作为第二个参数（type的一般过度对齐），64作为第三个参数（要求的特定对齐）。只作为退步:</p><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">operator</span> <span class="hljs-title">new</span><span class="hljs-params">(std::<span class="hljs-type">size_t</span>, std::<span class="hljs-type">align_val_t</span>)</span></span></code></pre></div><p>被调用，并将64作为请求的特定对齐方式。原则上，你可以为这三个参数提供一个重载，以实现对超对齐类型请求特定对齐时的特定行为。<br>再次注意，如果你需要为超对齐的数据提供特殊的去分配函数，你必须在新表达式中传递对齐方式时调用正确的去分配函数:</p><div class="code-wrapper"><pre><code class="hljs c++">std::string* p1 = <span class="hljs-built_in">new</span>(std::<span class="hljs-type">align_val_t</span>{<span class="hljs-number">64</span>}) std::string{};MyType32* p2 = <span class="hljs-built_in">new</span>(std::<span class="hljs-type">align_val_t</span>{<span class="hljs-number">64</span>}) MyType32{};...;::<span class="hljs-function"><span class="hljs-keyword">operator</span> <span class="hljs-title">delete</span><span class="hljs-params">(p2, std::<span class="hljs-type">align_val_t</span>{<span class="hljs-number">64</span>})</span></span>; <span class="hljs-comment">// !!!</span><span class="hljs-function">MyType32::<span class="hljs-keyword">operator</span> <span class="hljs-title">delete</span><span class="hljs-params">(p1, std::<span class="hljs-type">align_val_t</span>{<span class="hljs-number">64</span>})</span></span>; <span class="hljs-comment">// !!!</span></code></pre></div><p>这意味着，本例中的新表达式将调用</p><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">operator</span> <span class="hljs-title">new</span><span class="hljs-params">(std::<span class="hljs-type">size_t</span> size, std::<span class="hljs-type">align_val_t</span> align)</span></span>;</code></pre></div><p>而 delete 表达式将为默认对齐的数据调用以下两个操作之一：</p><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">operator</span> <span class="hljs-title">delete</span><span class="hljs-params">(<span class="hljs-type">void</span>* ptr, std::<span class="hljs-type">align_val_t</span> align)</span></span>;<span class="hljs-function"><span class="hljs-keyword">operator</span> <span class="hljs-title">delete</span><span class="hljs-params">(<span class="hljs-type">void</span>* ptr, std::<span class="hljs-type">size_t</span> size, std::<span class="hljs-type">align_val_t</span> align)</span></span>;</code></pre></div><p>以及针对过度对齐数据的以下四种操作之一：</p><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">operator</span> <span class="hljs-title">delete</span><span class="hljs-params">(<span class="hljs-type">void</span>* ptr, std::<span class="hljs-type">align_val_t</span> typealign, std::<span class="hljs-type">align_val_t</span> align)</span></span>;<span class="hljs-function"><span class="hljs-keyword">operator</span> <span class="hljs-title">delete</span><span class="hljs-params">(<span class="hljs-type">void</span>* ptr, std::<span class="hljs-type">size_t</span> size, std::<span class="hljs-type">align_val_t</span> typealign,</span></span><span class="hljs-params"><span class="hljs-function">                std::<span class="hljs-type">align_val_t</span> align)</span></span>;<span class="hljs-function"><span class="hljs-keyword">operator</span> <span class="hljs-title">delete</span><span class="hljs-params">(<span class="hljs-type">void</span>* ptr, std::<span class="hljs-type">align_val_t</span> align)</span></span>;<span class="hljs-function"><span class="hljs-keyword">operator</span> <span class="hljs-title">delete</span><span class="hljs-params">(<span class="hljs-type">void</span>* ptr, std::<span class="hljs-type">size_t</span> size, std::<span class="hljs-type">align_val_t</span> align)</span></span>;</code></pre></div><h4><span id="28-3-shi-xian-quan-ju-cao-zuo-fu-new">28.3 实现全局操作符new()</span><a href="#28-3-shi-xian-quan-ju-cao-zuo-fu-new" class="header-anchor">#</a></h4><p>默认情况下，C++ 平台现在为 operator new() 和 delete() 提供了大量的全局重载（包括相应的数组版本）：</p><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-type">void</span>* ::<span class="hljs-function"><span class="hljs-keyword">operator</span> <span class="hljs-title">new</span><span class="hljs-params">(std::<span class="hljs-type">size_t</span>)</span></span>;<span class="hljs-type">void</span>* ::<span class="hljs-function"><span class="hljs-keyword">operator</span> <span class="hljs-title">new</span><span class="hljs-params">(std::<span class="hljs-type">size_t</span>, std::<span class="hljs-type">align_val_t</span>)</span></span>;<span class="hljs-type">void</span>* ::<span class="hljs-function"><span class="hljs-keyword">operator</span> <span class="hljs-title">new</span><span class="hljs-params">(std::<span class="hljs-type">size_t</span>, <span class="hljs-type">const</span> std::<span class="hljs-type">nothrow_t</span>&amp;)</span> <span class="hljs-keyword">noexcept</span></span>;<span class="hljs-type">void</span>* ::<span class="hljs-function"><span class="hljs-keyword">operator</span> <span class="hljs-title">new</span><span class="hljs-params">(std::<span class="hljs-type">size_t</span>, std::<span class="hljs-type">align_val_t</span>,</span></span><span class="hljs-params"><span class="hljs-function">                     <span class="hljs-type">const</span> std::<span class="hljs-type">nothrow_t</span>&amp;)</span> <span class="hljs-keyword">noexcept</span></span>;<span class="hljs-type">void</span> ::<span class="hljs-function"><span class="hljs-keyword">operator</span> <span class="hljs-title">delete</span><span class="hljs-params">(<span class="hljs-type">void</span>*)</span> <span class="hljs-keyword">noexcept</span></span>;<span class="hljs-type">void</span> ::<span class="hljs-function"><span class="hljs-keyword">operator</span> <span class="hljs-title">delete</span><span class="hljs-params">(<span class="hljs-type">void</span>*, std::<span class="hljs-type">size_t</span>)</span> <span class="hljs-keyword">noexcept</span></span>;<span class="hljs-type">void</span> ::<span class="hljs-function"><span class="hljs-keyword">operator</span> <span class="hljs-title">delete</span><span class="hljs-params">(<span class="hljs-type">void</span>*, std::<span class="hljs-type">align_val_t</span>)</span> <span class="hljs-keyword">noexcept</span></span>;<span class="hljs-type">void</span> ::<span class="hljs-function"><span class="hljs-keyword">operator</span> <span class="hljs-title">delete</span><span class="hljs-params">(<span class="hljs-type">void</span>*, std::<span class="hljs-type">size_t</span>, std::<span class="hljs-type">align_val_t</span>)</span> <span class="hljs-keyword">noexcept</span></span>;<span class="hljs-type">void</span> ::<span class="hljs-function"><span class="hljs-keyword">operator</span> <span class="hljs-title">delete</span><span class="hljs-params">(<span class="hljs-type">void</span>*, <span class="hljs-type">const</span> std::<span class="hljs-type">nothrow_t</span>&amp;)</span> <span class="hljs-keyword">noexcept</span></span>;<span class="hljs-type">void</span> ::<span class="hljs-function"><span class="hljs-keyword">operator</span> <span class="hljs-title">delete</span><span class="hljs-params">(<span class="hljs-type">void</span>*, std::<span class="hljs-type">align_val_t</span>,</span></span><span class="hljs-params"><span class="hljs-function">                       <span class="hljs-type">const</span> std::<span class="hljs-type">nothrow_t</span>&amp;)</span> <span class="hljs-keyword">noexcept</span></span>;<span class="hljs-type">void</span>* ::<span class="hljs-keyword">operator</span> <span class="hljs-keyword">new</span>[](std::<span class="hljs-type">size_t</span>);<span class="hljs-type">void</span>* ::<span class="hljs-keyword">operator</span> <span class="hljs-keyword">new</span>[](std::<span class="hljs-type">size_t</span>, std::<span class="hljs-type">align_val_t</span>);<span class="hljs-type">void</span>* ::<span class="hljs-keyword">operator</span> <span class="hljs-keyword">new</span>[](std::<span class="hljs-type">size_t</span>, <span class="hljs-type">const</span> std::<span class="hljs-type">nothrow_t</span>&amp;) <span class="hljs-keyword">noexcept</span>;<span class="hljs-type">void</span>* ::<span class="hljs-keyword">operator</span> <span class="hljs-keyword">new</span>[](std::<span class="hljs-type">size_t</span>, std::<span class="hljs-type">align_val_t</span>,                       <span class="hljs-type">const</span> std::<span class="hljs-type">nothrow_t</span>&amp;) <span class="hljs-keyword">noexcept</span>;<span class="hljs-type">void</span> ::<span class="hljs-keyword">operator</span> <span class="hljs-keyword">delete</span>[](<span class="hljs-type">void</span>*) <span class="hljs-keyword">noexcept</span>;<span class="hljs-type">void</span> ::<span class="hljs-keyword">operator</span> <span class="hljs-keyword">delete</span>[](<span class="hljs-type">void</span>*, std::<span class="hljs-type">size_t</span>) <span class="hljs-keyword">noexcept</span>;<span class="hljs-type">void</span> ::<span class="hljs-keyword">operator</span> <span class="hljs-keyword">delete</span>[](<span class="hljs-type">void</span>*, std::<span class="hljs-type">align_val_t</span>) <span class="hljs-keyword">noexcept</span>;<span class="hljs-type">void</span> ::<span class="hljs-keyword">operator</span> <span class="hljs-keyword">delete</span>[](<span class="hljs-type">void</span>*, std::<span class="hljs-type">size_t</span>, std::<span class="hljs-type">align_val_t</span>) <span class="hljs-keyword">noexcept</span>;<span class="hljs-type">void</span> ::<span class="hljs-keyword">operator</span> <span class="hljs-keyword">delete</span>[](<span class="hljs-type">void</span>*, <span class="hljs-type">const</span> std::<span class="hljs-type">nothrow_t</span>&amp;) <span class="hljs-keyword">noexcept</span>;<span class="hljs-type">void</span> ::<span class="hljs-keyword">operator</span> <span class="hljs-keyword">delete</span>[](<span class="hljs-type">void</span>*, std::<span class="hljs-type">align_val_t</span>,                         <span class="hljs-type">const</span> std::<span class="hljs-type">nothrow_t</span>&amp;) <span class="hljs-keyword">noexcept</span>;</code></pre></div><p>如果你想实现自己的内存管理（例如，为了能够调试动态内存调用），你不必全部覆盖它们。只要实现以下基本函数就足够了，因为默认情况下，所有其他函数（包括所有数组版本）都会调用这些基本函数中的一个:</p><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-type">void</span>* ::<span class="hljs-function"><span class="hljs-keyword">operator</span> <span class="hljs-title">new</span><span class="hljs-params">(std::<span class="hljs-type">size_t</span>)</span></span>;<span class="hljs-type">void</span>* ::<span class="hljs-function"><span class="hljs-keyword">operator</span> <span class="hljs-title">new</span><span class="hljs-params">(std::<span class="hljs-type">size_t</span>, std::<span class="hljs-type">align_val_t</span>)</span></span>;<span class="hljs-type">void</span> ::<span class="hljs-function"><span class="hljs-keyword">operator</span> <span class="hljs-title">delete</span><span class="hljs-params">(<span class="hljs-type">void</span>*)</span> <span class="hljs-keyword">noexcept</span></span>;<span class="hljs-type">void</span> ::<span class="hljs-function"><span class="hljs-keyword">operator</span> <span class="hljs-title">delete</span><span class="hljs-params">(<span class="hljs-type">void</span>*, std::<span class="hljs-type">size_t</span>)</span> <span class="hljs-keyword">noexcept</span></span>;<span class="hljs-type">void</span> ::<span class="hljs-function"><span class="hljs-keyword">operator</span> <span class="hljs-title">delete</span><span class="hljs-params">(<span class="hljs-type">void</span>*, std::<span class="hljs-type">align_val_t</span>)</span> <span class="hljs-keyword">noexcept</span></span>;<span class="hljs-type">void</span> ::<span class="hljs-function"><span class="hljs-keyword">operator</span> <span class="hljs-title">delete</span><span class="hljs-params">(<span class="hljs-type">void</span>*, std::<span class="hljs-type">size_t</span>, std::<span class="hljs-type">align_val_t</span>)</span> <span class="hljs-keyword">noexcept</span></span>;</code></pre></div><p>原则上，操作者delete()的默认大小版本也只是调用非大小版本。然而，这在将来可能会发生变化，因此要求你同时实现这两个功能（如果你不这样做，有些编译器会发出警告）。</p><h5><span id="28-3-1-xiang-hou-de-bu-xiang-rong-xing">28.3.1 向后的不相容性</span><a href="#28-3-1-xiang-hou-de-bu-xiang-rong-xing" class="header-anchor">#</a></h5><p>请注意，以下程序的行为会随着 C++17 默默地改变：</p><p><code>lang/alignednewincomp.cpp</code></p><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstddef&gt;</span> <span class="hljs-comment">// for std::size_t</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstdlib&gt;</span> <span class="hljs-comment">// for std::malloc()</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstdio&gt;</span> <span class="hljs-comment">// for std::printf()</span></span><span class="hljs-function"><span class="hljs-type">void</span>* <span class="hljs-keyword">operator</span> <span class="hljs-title">new</span> <span class="hljs-params">(std::<span class="hljs-type">size_t</span> size)</span></span><span class="hljs-function"></span>{    std::<span class="hljs-built_in">printf</span>(<span class="hljs-string">"::new called with size: %zu\n"</span>, size);    <span class="hljs-keyword">return</span> ::std::<span class="hljs-built_in">malloc</span>(size);}<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>{    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">alignas</span>(<span class="hljs-number">64</span>) S {        <span class="hljs-type">int</span> i;    };    S* p = <span class="hljs-keyword">new</span> S; <span class="hljs-comment">// 仅在 C++17 之前调用我们的运算符 new</span>}</code></pre></div><p>在 C++14 中，为所有新表达式调用全局 ::operator new(size_t) 重载，以便程序始终具有以下输出：</p><div class="code-wrapper"><pre><code class="hljs bash">::new called with size: 64</code></pre></div><p>从 C++17 开始，这个程序的行为发生了变化，因为现在默认重载了过度对齐的数据</p><div class="code-wrapper"><pre><code class="hljs c++">::<span class="hljs-function"><span class="hljs-keyword">operator</span> <span class="hljs-title">new</span><span class="hljs-params">(<span class="hljs-type">size_t</span>, <span class="hljs-type">align_val_t</span>)</span></span></code></pre></div><p>在这里调用，没有被替换。 结果，程序将不再输出上面的行。</p><p>请注意，此问题仅适用于全局运算符 new()。 如果为 S 定义了特定于类型的运算符 new()，则该运算符仍用作过度对齐数据的后备，以便此类程序的行为与 C++17 之前一样。<br>另请注意，此处有意使用 printf() 以避免 std::cout 的输出在我们分配内存时分配内存，这可能会导致严重错误（充其量是核心转储）。</p><h4><span id="28-4-gen-zong-suo-you-new-de-diao-yong">28.4 跟踪所有::new的调用</span><a href="#28-4-gen-zong-suo-you-new-de-diao-yong" class="header-anchor">#</a></h4><p>下面的程序演示了如何使用 new 运算符 new() 重载结合内联变量和 [[nodiscard]] 来跟踪 ::new 的所有调用，只需包含此头文件：</p><p><code>lang/tracknew.hpp</code></p><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">ifndef</span> TRACKNEW_HPP</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> TRACKNEW_HPP</span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;new&gt;</span> <span class="hljs-comment">// for std::align_val_t</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstdio&gt;</span> <span class="hljs-comment">// for printf()</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstdlib&gt;</span> <span class="hljs-comment">// for malloc() and aligned_alloc()</span></span><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> _MSC_VER</span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;malloc.h&gt;</span> <span class="hljs-comment">// for _aligned_malloc() and _aligned_free()</span></span><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><span class="hljs-keyword">class</span> <span class="hljs-title class_">TrackNew</span> {<span class="hljs-keyword">private</span>:    <span class="hljs-type">static</span> <span class="hljs-keyword">inline</span> <span class="hljs-type">int</span> numMalloc = <span class="hljs-number">0</span>; <span class="hljs-comment">// num malloc 调用</span>    <span class="hljs-type">static</span> <span class="hljs-keyword">inline</span> <span class="hljs-type">size_t</span> sumSize = <span class="hljs-number">0</span>; <span class="hljs-comment">// 到目前为止分配的字节数</span>    <span class="hljs-type">static</span> <span class="hljs-keyword">inline</span> <span class="hljs-type">bool</span> doTrace = <span class="hljs-literal">false</span>; <span class="hljs-comment">// 启用跟踪</span>    <span class="hljs-type">static</span> <span class="hljs-keyword">inline</span> <span class="hljs-type">bool</span> inNew = <span class="hljs-literal">false</span>; <span class="hljs-comment">// 不要在新的重载中跟踪输出</span><span class="hljs-keyword">public</span>:    <span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title">reset</span><span class="hljs-params">()</span> </span>{ <span class="hljs-comment">//重置新/内存计数器</span>        numMalloc = <span class="hljs-number">0</span>;        sumSize = <span class="hljs-number">0</span>;    }    <span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title">trace</span><span class="hljs-params">(<span class="hljs-type">bool</span> b)</span> </span>{ <span class="hljs-comment">// 启用/禁用跟踪</span>        doTrace = b;    }    <span class="hljs-comment">// 实施跟踪分配:</span>    <span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">void</span>* <span class="hljs-title">allocate</span><span class="hljs-params">(std::<span class="hljs-type">size_t</span> size, std::<span class="hljs-type">size_t</span> align,</span></span><span class="hljs-params"><span class="hljs-function">                          <span class="hljs-type">const</span> <span class="hljs-type">char</span>* call)</span> </span>{        <span class="hljs-comment">// 跟踪和跟踪分配:</span>        ++numMalloc;        sumSize += size;        <span class="hljs-type">void</span>* p;        <span class="hljs-keyword">if</span> (align == <span class="hljs-number">0</span>) {            p = std::<span class="hljs-built_in">malloc</span>(size);        }        <span class="hljs-keyword">else</span> {            <span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> _MSC_VER</span>            p = _aligned_malloc(size, align); <span class="hljs-comment">// Windows API</span>            <span class="hljs-meta">#<span class="hljs-keyword">else</span></span>            p = std::<span class="hljs-built_in">aligned_alloc</span>(align, size); <span class="hljs-comment">// C++17 API</span>            <span class="hljs-meta">#<span class="hljs-keyword">endif</span></span>        }        <span class="hljs-keyword">if</span> (doTrace) {            <span class="hljs-comment">// 不要在这里使用 std::cout 因为它可能会分配内存</span>            <span class="hljs-comment">// 当我们分配内存时（充其量是核心转储）</span>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">"#%d %s "</span>, numMalloc, call);            <span class="hljs-built_in">printf</span>(<span class="hljs-string">"(%zu bytes, "</span>, size);            <span class="hljs-keyword">if</span> (align &gt; <span class="hljs-number">0</span>) {                <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%zu-bytes aligned) "</span>, align);            }            <span class="hljs-keyword">else</span> {                <span class="hljs-built_in">printf</span>(<span class="hljs-string">"def-aligned) "</span>);            }            <span class="hljs-built_in">printf</span>(<span class="hljs-string">"=&gt; %p (total: %zu Bytes)\n"</span>, (<span class="hljs-type">void</span>*)p, sumSize);        }        <span class="hljs-keyword">return</span> p;    }    <span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title">status</span><span class="hljs-params">()</span> </span>{ <span class="hljs-comment">// 打印当前状态</span>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%d allocations for %zu bytes\n"</span>, numMalloc, sumSize);    }};[[nodiscard]]<span class="hljs-function"><span class="hljs-type">void</span>* <span class="hljs-keyword">operator</span> <span class="hljs-title">new</span> <span class="hljs-params">(std::<span class="hljs-type">size_t</span> size)</span> </span>{    <span class="hljs-keyword">return</span> TrackNew::<span class="hljs-built_in">allocate</span>(size, <span class="hljs-number">0</span>, <span class="hljs-string">"::new"</span>);}[[nodiscard]]<span class="hljs-function"><span class="hljs-type">void</span>* <span class="hljs-keyword">operator</span> <span class="hljs-title">new</span> <span class="hljs-params">(std::<span class="hljs-type">size_t</span> size, std::<span class="hljs-type">align_val_t</span> align)</span> </span>{    <span class="hljs-keyword">return</span> TrackNew::<span class="hljs-built_in">allocate</span>(size, <span class="hljs-built_in">static_cast</span>&lt;<span class="hljs-type">size_t</span>&gt;(align),                              <span class="hljs-string">"::new aligned"</span>);}[[nodiscard]]<span class="hljs-type">void</span>* <span class="hljs-keyword">operator</span> <span class="hljs-keyword">new</span>[] (std::<span class="hljs-type">size_t</span> size) {    <span class="hljs-keyword">return</span> TrackNew::<span class="hljs-built_in">allocate</span>(size, <span class="hljs-number">0</span>, <span class="hljs-string">"::new[]"</span>);}[[nodiscard]]<span class="hljs-type">void</span>* <span class="hljs-keyword">operator</span> <span class="hljs-keyword">new</span>[] (std::<span class="hljs-type">size_t</span> size, std::<span class="hljs-type">align_val_t</span> align) {    <span class="hljs-keyword">return</span> TrackNew::<span class="hljs-built_in">allocate</span>(size, <span class="hljs-built_in">static_cast</span>&lt;<span class="hljs-type">size_t</span>&gt;(align),                              <span class="hljs-string">"::new[] aligned"</span>);}<span class="hljs-comment">// 确保释放匹配:</span><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-keyword">operator</span> <span class="hljs-title">delete</span> <span class="hljs-params">(<span class="hljs-type">void</span>* p)</span> <span class="hljs-keyword">noexcept</span> </span>{    std::<span class="hljs-built_in">free</span>(p);}<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-keyword">operator</span> <span class="hljs-title">delete</span> <span class="hljs-params">(<span class="hljs-type">void</span>* p, std::<span class="hljs-type">size_t</span>)</span> <span class="hljs-keyword">noexcept</span> </span>{    ::<span class="hljs-function"><span class="hljs-keyword">operator</span> <span class="hljs-title">delete</span><span class="hljs-params">(p)</span></span>;}<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-keyword">operator</span> <span class="hljs-title">delete</span> <span class="hljs-params">(<span class="hljs-type">void</span>* p, std::<span class="hljs-type">align_val_t</span>)</span> <span class="hljs-keyword">noexcept</span> </span>{    <span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> _MSC_VER</span>    _aligned_free(p); <span class="hljs-comment">// Windows API</span>    <span class="hljs-meta">#<span class="hljs-keyword">else</span></span>    std::<span class="hljs-built_in">free</span>(p); <span class="hljs-comment">// C++17 API</span>    <span class="hljs-meta">#<span class="hljs-keyword">endif</span></span>}<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-keyword">operator</span> <span class="hljs-title">delete</span> <span class="hljs-params">(<span class="hljs-type">void</span>* p, std::<span class="hljs-type">size_t</span>,</span></span><span class="hljs-params"><span class="hljs-function">                      std::<span class="hljs-type">align_val_t</span> align)</span> <span class="hljs-keyword">noexcept</span> </span>{    ::<span class="hljs-function"><span class="hljs-keyword">operator</span> <span class="hljs-title">delete</span><span class="hljs-params">(p, align)</span></span>;}<span class="hljs-meta">#<span class="hljs-keyword">endif</span> <span class="hljs-comment">// TRACKNEW_HPP  </span></span></code></pre></div><p>考虑在以下 CPP 文件中使用此头文件：</p><p><code>lang/tracknew.cpp</code></p><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">"tracknew.hpp"</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>{    TrackNew::<span class="hljs-built_in">reset</span>();    TrackNew::<span class="hljs-built_in">trace</span>(<span class="hljs-literal">true</span>);    std::string s = <span class="hljs-string">"string value with 26 chars"</span>;    <span class="hljs-keyword">auto</span> p1 = <span class="hljs-keyword">new</span> std::string{<span class="hljs-string">"an initial value with even 35 chars"</span>};    <span class="hljs-keyword">auto</span> p2 = <span class="hljs-built_in">new</span>(std::<span class="hljs-type">align_val_t</span>{<span class="hljs-number">64</span>}) std::string[<span class="hljs-number">4</span>];    <span class="hljs-keyword">auto</span> p3 = <span class="hljs-keyword">new</span> std::string[<span class="hljs-number">4</span>] { <span class="hljs-string">"7 chars"</span>, <span class="hljs-string">"x"</span>, <span class="hljs-string">"or 11 chars"</span>,                                  <span class="hljs-string">"a string value with 28 chars"</span> };    TrackNew::<span class="hljs-built_in">status</span>();    ...;    <span class="hljs-keyword">delete</span> p1;    <span class="hljs-keyword">delete</span>[] p2;    <span class="hljs-keyword">delete</span>[] p3;}</code></pre></div><p>输出取决于何时初始化跟踪以及为其他初始化执行了多少分配。 但它应该包含类似于以下几行的内容：</p><div class="code-wrapper"><pre><code class="hljs bash"><span class="hljs-comment">#1 ::new (27 bytes, def-aligned) =&gt; 0x8002ccc0 (total: 27 Bytes)</span><span class="hljs-comment">#2 ::new (24 bytes, def-aligned) =&gt; 0x8004cd28 (total: 51 Bytes)</span><span class="hljs-comment">#3 ::new (36 bytes, def-aligned) =&gt; 0x8004cd48 (total: 87 Bytes)</span><span class="hljs-comment">#4 ::new[] aligned (100 bytes, 64-bytes aligned) =&gt; 0x8004cd80 (total: 187 Bytes)</span><span class="hljs-comment">#5 ::new[] (100 bytes, def-aligned) =&gt; 0x8004cde8 (total: 287 Bytes)</span><span class="hljs-comment">#6 ::new (29 bytes, def-aligned) =&gt; 0x8004ce50 (total: 316 Bytes)</span>6 allocations <span class="hljs-keyword">for</span> 316 bytes</code></pre></div><p>第一个输出是，例如，为s的值初始化内存。注意，根据std::string类的分配策略，这个值可能更大。<br>接下来写的两行是由第二个请求引起的:</p><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">auto</span> p1 = <span class="hljs-keyword">new</span> std::string{<span class="hljs-string">"an initial value with even 35 chars"</span>};</code></pre></div><p>它为核心字符串对象分配了24个字节，加上36个字节的字符串初始值（同样，这些值可能会有所不同）。<br>第三次调用要求一个64字节的4个字符串的数组。<br>最后一个调用再次执行两个分配：一个用于数组，一个用于最后一个字符串的初始值。是的，只为最后一个字符串，因为库的实现通常使用小/短字符串优化（SSO），它将通常不超过15个字符的字符串存储在数据成员中，而不是完全分配堆内存。其他实现可能在这里进行5次分配。</p><h4><span id="28-5-hou-ji">28.5 后记</span><a href="#28-5-hou-ji" class="header-anchor">#</a></h4><p>堆/动态内存分配的对齐由 Clark Nelson 在 <a href="https://wg21.link/n3396">https://wg21.link/n3396</a> 中首次提出。 最终接受的措辞由 Clark Nelson 在 <a href="https://wg21.link/p0035r4">https://wg21.link/p0035r4</a> 中制定。</p><h3><span id="29-qi-ta-zhuan-ye-ku-de-gai-dong">29  其他专业库的改动</span><a href="#29-qi-ta-zhuan-ye-ku-de-gai-dong" class="header-anchor">#</a></h3><p>对于专家来说，C++标准库还有一些进一步的改进，例如基础库的程序员，本章将介绍这些改进。</p><h4><span id="29-1-zi-fu-xu-lie-he-shu-zi-zhi-zhi-jian-de-di-ji-zhuan-huan">29.1 字符序列和数字值之间的低级转换</span><a href="#29-1-zi-fu-xu-lie-he-shu-zi-zhi-zhi-jian-de-di-ji-zhuan-huan" class="header-anchor">#</a></h4><p>自 C 以来，将整数值转换为字符序列（反之亦然）一直是一个问题。虽然 C 提供了 sprintf() 和 sscanf()，但 C++ 首先引入了字符串流，但是这需要大量资源。使用 C++11 引入了方便的函数，例如 std::to_string 和 std::stoi() ，它们只接受 std::string 参数。<br>C++17 引入了具有以下能力的新基本字符串转换函数（引用自最初的提议）：</p><ul><li>没有格式字符串的运行时解析</li><li>接口本身不需要动态内存分配</li><li>不考虑语言环境</li><li>不需要通过函数指针进行间接寻址</li><li>防止缓冲区溢出</li><li>解析字符串时，错误可与有效数字区分开来</li><li>解析字符串时，空格或装饰不会被忽略</li></ul><p>除了浮点数之外，此功能还将提供往返保证，即转换为字符序列并转换回原始值的值。</p><p>这些函数在头文件 <charconv> 中提供。</charconv></p><h5><span id="29-1-1-shi-yong-shi-li">29.1.1 使用实例</span><a href="#29-1-1-shi-yong-shi-li" class="header-anchor">#</a></h5><p>提供了两个重载函数：</p><ul><li>std::from_chars() 将给定的字符序列转换为数值。</li><li>std::to_chars() 将数值转换为给定的字符序列。</li></ul><h6><span id="from-chars">from_chars()</span><a href="#from-chars" class="header-anchor">#</a></h6><p>std::from_chars() 将给定的字符序列转换为数值。 例如：</p><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;charconv&gt;</span></span><span class="hljs-type">const</span> <span class="hljs-type">char</span>* str = <span class="hljs-string">"12 monkeys"</span>;<span class="hljs-type">int</span> value;std::from_chars_result res = std::<span class="hljs-built_in">from_chars</span>(str, str+<span class="hljs-number">10</span>,                                             value);</code></pre></div><p>在成功解析后，值包含解析后的值（本例中为12）。结果值是以下结构:</p><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">from_chars_result</span> {    <span class="hljs-type">const</span> <span class="hljs-type">char</span>* ptr;    std::errc ec;};</code></pre></div><p>在调用之后，ptr指的是第一个没有被解析为数字的一部分的字符（或者传递的第二个参数，如果所有的字符都被传递了），ec包含一个std::errc类型的错误条件，如果转换成功，则等于std::errc{}。因此，你可以这样检查结果如下:</p><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">if</span> (res.ec != std::errc{}) {    ... <span class="hljs-comment">// error handling</span>}</code></pre></div><p>注意，对于std::errc来说，没有隐式转换为bool，所以你不能像下面这样检查值:</p><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">if</span> (res.ec) { <span class="hljs-comment">// 错误：没有隐式转换为布尔值</span></code></pre></div><p>或者：</p><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">if</span> (!res.ec) { <span class="hljs-comment">// 错误：没有操作员！ 定义</span></code></pre></div><p>但是，通过使用结构化绑定并且如果使用初始化，您可以编写：</p><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">if</span> (<span class="hljs-keyword">auto</span> [ptr, ec] = std::<span class="hljs-built_in">from_chars</span>(str, str+<span class="hljs-number">10</span>, value); ec != std::errc{}) {    ... <span class="hljs-comment">// error handling</span>}</code></pre></div><p>另一个例子是解析传递的字符串视图:</p><h6><span id="to-chars">to_chars()</span><a href="#to-chars" class="header-anchor">#</a></h6><p>std::to_chars() 将数值转换为给定的字符序列。 例如：</p><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;charconv&gt;</span></span><span class="hljs-type">int</span> value = <span class="hljs-number">42</span>;<span class="hljs-type">char</span> str[<span class="hljs-number">10</span>];std::to_chars_result res = std::<span class="hljs-built_in">to_chars</span>(str, str+<span class="hljs-number">9</span>,                                         value);*res.ptr = <span class="hljs-string">'\0'</span>; <span class="hljs-comment">// 确保后面有一个尾随空字符</span></code></pre></div><p>转换成功后，str包含了代表传递值的字符序列（本例中为42），没有尾部空字符。<br>结果值是以下结构:</p><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">to_chars_result</span> {    <span class="hljs-type">char</span>* ptr;    std::errc ec;};</code></pre></div><p>在调用之后，ptr指的是最后一个写入的字符之后的字符，ec包含一个std::errc类型的错误条件，如果转换成功，则等于std::errc{}。<br>因此，你可以按以下方式检查结果:</p><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">if</span> (res.ec != std::errc{}) {    ... <span class="hljs-comment">// 错误处理</span>}<span class="hljs-keyword">else</span> {    <span class="hljs-built_in">process</span> (str, res.ptr - str); <span class="hljs-comment">//传递字符和长度</span>}</code></pre></div><p>再次注意，对于std::errc来说，没有隐式转换为bool，所以你不能像下面这样检查值:</p><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">if</span> (res.ec) { <span class="hljs-comment">// 错误：没有隐式转换为布尔值</span></code></pre></div><p>或者：</p><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">if</span> (!res.ec) { <span class="hljs-comment">// 错误：没有操作员！ 定义</span></code></pre></div><p>由于未写入尾随空终止符，因此您必须确保仅使用写入的字符或添加尾随空字符，如本示例中使用返回值的 ptr 成员所做的那样：</p><div class="code-wrapper"><pre><code class="hljs c++">*res.ptr = <span class="hljs-string">'\0'</span>; <span class="hljs-comment">// 确保后面有一个尾随空字符</span></code></pre></div><p>同样，通过使用结构化绑定，如果使用初始化，您可以编写：</p><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">if</span> (<span class="hljs-keyword">auto</span> [ptr, ec] = std::<span class="hljs-built_in">to_chars</span>(str, str+<span class="hljs-number">10</span>, value); ec != std::errc{}) {    ... <span class="hljs-comment">// 错误处理</span>}<span class="hljs-keyword">else</span> {    <span class="hljs-built_in">process</span> (str, res.ptr - str); <span class="hljs-comment">// 传递字符和长度</span>}</code></pre></div><p>请注意，使用现有的std::to_string()函数，这种行为更安全，更容易实现。使用std::to_char()只有在进一步处理直接需要所写的 字符序列。</p><h5><span id="29-1-2-zhi-chi-fu-dian-wang-fan-yun-suan">29.1.2 支持浮点往返运算</span><a href="#29-1-2-zhi-chi-fu-dian-wang-fan-yun-suan" class="header-anchor">#</a></h5><p>如果没有给出精度，to_chars()和from_chars()保证对浮点值的往返支持。这意味着一个转换为字符序列的值在读回时正好是其原始值。不过，这种保证只适用于在同一实现中的写入和读取。<br>因此，浮点值必须被写成具有最高精度的最细粒度的字符序列。由于这个原因，数值被写入的字符序列可能有很大的尺寸。<br>请看下面的函数:</p><p><code>lib/charconv.hpp </code></p><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;charconv&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cassert&gt;</span></span><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">d2str2d</span><span class="hljs-params">(<span class="hljs-type">double</span> value1)</span></span><span class="hljs-function"></span>{    std::cout &lt;&lt; <span class="hljs-string">"in: "</span> &lt;&lt; value1 &lt;&lt; <span class="hljs-string">'\n'</span>;    <span class="hljs-comment">// 转换为字符序列:</span>    <span class="hljs-type">char</span> str[<span class="hljs-number">1000</span>];    std::to_chars_result res1 = std::<span class="hljs-built_in">to_chars</span>(str, str+<span class="hljs-number">999</span>,                                              value1);    *res1.ptr = <span class="hljs-string">'\0'</span>; <span class="hljs-comment">// 添加尾随空字符</span>    std::cout &lt;&lt; <span class="hljs-string">"str: "</span> &lt;&lt; str &lt;&lt; <span class="hljs-string">'\n'</span>;    <span class="hljs-built_in">assert</span>(res1.ec == std::errc{});    <span class="hljs-comment">// 从字符序列回读:</span>    <span class="hljs-type">double</span> value2;    std::from_chars_result res2 = std::<span class="hljs-built_in">from_chars</span>(str, str+<span class="hljs-number">999</span>,                                                  value2);    std::cout &lt;&lt; <span class="hljs-string">"out: "</span> &lt;&lt; value2 &lt;&lt; <span class="hljs-string">'\n'</span>;    <span class="hljs-built_in">assert</span>(res2.ec == std::errc{});    <span class="hljs-built_in">assert</span>(value1 == value2); <span class="hljs-comment">// should never fail</span>}</code></pre></div><p>在这里，我们将传递的双精度值转换为字符序列并将其解析回来。 最后的断言再次检查该值是否相同。<br>下面的程序演示了效果：</p><p><code>lib/charconv.cpp </code></p><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">"charconv.hpp"</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iomanip&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;numeric&gt;</span></span><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>{    std::vector&lt;<span class="hljs-type">double</span>&gt; coll{<span class="hljs-number">0.1</span>, <span class="hljs-number">0.3</span>, <span class="hljs-number">0.00001</span>};    <span class="hljs-comment">// 创建两个略有不同的浮点值:</span>    <span class="hljs-keyword">auto</span> sum1 = std::<span class="hljs-built_in">accumulate</span>(coll.<span class="hljs-built_in">begin</span>(), coll.<span class="hljs-built_in">end</span>(),                                <span class="hljs-number">0.0</span>, std::plus&lt;&gt;());    <span class="hljs-keyword">auto</span> sum2 = std::<span class="hljs-built_in">accumulate</span>(coll.<span class="hljs-built_in">rbegin</span>(), coll.<span class="hljs-built_in">rend</span>(),                                <span class="hljs-number">0.0</span>, std::plus&lt;&gt;());    <span class="hljs-comment">// look the same:</span>    std::cout &lt;&lt; <span class="hljs-string">"sum1: "</span> &lt;&lt; sum1 &lt;&lt; <span class="hljs-string">'\n'</span>;    std::cout &lt;&lt; <span class="hljs-string">"sum1: "</span> &lt;&lt; sum2 &lt;&lt; <span class="hljs-string">'\n'</span>;    <span class="hljs-comment">// 但不一样:</span>    std::cout &lt;&lt; std::boolalpha &lt;&lt; std::<span class="hljs-built_in">setprecision</span>(<span class="hljs-number">20</span>);    std::cout &lt;&lt; <span class="hljs-string">"equal: "</span> &lt;&lt; (sum1==sum2) &lt;&lt; <span class="hljs-string">'\n'</span>; <span class="hljs-comment">// false !!</span>    std::cout &lt;&lt; <span class="hljs-string">"sum1: "</span> &lt;&lt; sum1 &lt;&lt; <span class="hljs-string">'\n'</span>;    std::cout &lt;&lt; <span class="hljs-string">"sum1: "</span> &lt;&lt; sum2 &lt;&lt; <span class="hljs-string">'\n'</span>;    std::cout &lt;&lt; <span class="hljs-string">'\n'</span>;    <span class="hljs-comment">// 检查往返:</span>    <span class="hljs-built_in">d2str2d</span>(sum1);    <span class="hljs-built_in">d2str2d</span>(sum2);}</code></pre></div><p>我们以不同的顺序累积两个小的浮点序列。 sum1 是从左到右累积的总和，而 sum2 是从右到左累积的总和（使用反向迭代器）。 结果，这些值看起来相同但不是：</p><div class="code-wrapper"><pre><code class="hljs bash">sum1: 0.40001sum1: 0.40001equal: <span class="hljs-literal">false</span>sum1: 0.40001000000000003221sum1: 0.40000999999999997669</code></pre></div><p>将值传递给 d2str2d() 时，您可以看到这些值存储为具有必要粒度的不同字符序列：</p><div class="code-wrapper"><pre><code class="hljs bash"><span class="hljs-keyword">in</span>: 0.40001000000000003221str: 0.40001000000000003out: 0.40001000000000003221<span class="hljs-keyword">in</span>: 0.40000999999999997669str: 0.40001out: 0.40000999999999997669</code></pre></div><p>再次注意，粒度（以及字符序列的必要大小）取决于平台。<br>往返支持适用于所有浮点数，包括 NAN 和 INFINITY。 例如，将 INFINITY 传递给 d2st2d() 应该具有以下效果：</p><div class="code-wrapper"><pre><code class="hljs bash">value1: infstr: infvalue2: inf</code></pre></div><p>但是，请注意，对于 NAN，d2str2d() 中的断言将失败，因为它从不与任何东西进行比较，包括它自己。</p><h4><span id="29-2-hou-ji">29.2 后记</span><a href="#29-2-hou-ji" class="header-anchor">#</a></h4><p>字符序列和数字值之间的低级转换是由Jens Maurer在<a href="https://wg21.link/p0067r0">https://wg21.link/p0067r0</a> 中首次提出的。最终被接受的措辞是由Jens Maurer在<a href="https://wg21.link/p0067r5%E3%80%82%E7%84%B6%E8%80%8C%EF%BC%8C%E9%87%8D%E8%A6%81%E7%9A%84%E6%BE%84%E6%B8%85%E5%92%8C%E6%96%B0%E7%9A%84%E5%A4%B4%E6%96%87%E4%BB%B6%E8%A2%AB%E6%8C%87%E5%AE%9A%E4%B8%BAJens">https://wg21.link/p0067r5。然而，重要的澄清和新的头文件被指定为Jens</a> Maurer在<a href="https://wg21.link/p0682r1%EF%BC%8C%E4%BD%9C%E4%B8%BA%E9%92%88%E5%AF%B9C++17%E7%9A%84%E7%BC%BA%E9%99%B7%E6%8A%A5%E5%91%8A%E3%80%82">https://wg21.link/p0682r1，作为针对C++17的缺陷报告。</a></p><h2><span id="ci-hui-biao">词汇表</span><a href="#ci-hui-biao" class="header-anchor">#</a></h2>]]></content>
    
    
    
    <tags>
      
      <tag>C++17</tag>
      
      <tag>TOOL</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>第四部分-标准库扩展和修改</title>
    <link href="/2022/03/19/%E7%AC%AC%E5%9B%9B%E9%83%A8%E5%88%86%20%E6%A0%87%E5%87%86%E5%BA%93%E6%89%A9%E5%B1%95%E5%92%8C%E4%BF%AE%E6%94%B9/"/>
    <url>/2022/03/19/%E7%AC%AC%E5%9B%9B%E9%83%A8%E5%88%86%20%E6%A0%87%E5%87%86%E5%BA%93%E6%89%A9%E5%B1%95%E5%92%8C%E4%BF%AE%E6%94%B9/</url>
    
    <content type="html"><![CDATA[<h2><span id="di-si-bu-fen-biao-zhun-ku-kuo-zhan-he-xiu-gai">第四部分 标准库扩展和修改</span><a href="#di-si-bu-fen-biao-zhun-ku-kuo-zhan-he-xiu-gai" class="header-anchor">#</a></h2><p>这一部分介绍了用C++17对现有库组件的扩展和修改。</p><h3><span id="21-lei-xing-te-zheng-kuo-zhan">21类型特征扩展</span><a href="#21-lei-xing-te-zheng-kuo-zhan" class="header-anchor">#</a></h3><p>关于类型特征（标准类型函数），C++17扩展了使用它们的一般能力，并且 引入了一些新的类型特征。</p><h4><span id="21-1-lei-xing-te-zheng-de-suffix-v">21.1 类型特征的<code>Suffix _v</code></span><a href="#21-1-lei-xing-te-zheng-de-suffix-v" class="header-anchor">#</a></h4><p>从C++17开始，你可以对所有产生数值的类型特征使用后缀<code>_v</code>（因为你可以对所有产生类型的类型特征使用后缀<code>_t</code>）。例如，对于任何类型的T，而不是</p><div class="code-wrapper"><pre><code class="hljs c++">std::is_const&lt;T&gt;::value</code></pre></div><p>你现在可以写:</p><div class="code-wrapper"><pre><code class="hljs c++">std::is_const_v&lt;T&gt; <span class="hljs-comment">// since C++17</span></code></pre></div><p>这适用于所有类型特征。其方法是，为每个标准类型特征定义一个相应的 变量模板。比如说:</p><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">namespace</span> std {    <span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;    <span class="hljs-keyword">constexpr</span> <span class="hljs-type">bool</span> is_const_v = is_const&lt;T&gt;::value;}</code></pre></div><p>通常，这有助于制定布尔条件，你可以在运行时使用:</p><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">if</span> (std::is_signed_v&lt;<span class="hljs-type">char</span>&gt;) {    ...}</code></pre></div><p>但由于类型特征是在编译时评估的，所以你可以在编译时使用编译时的结果，即compile-time if:</p><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">if</span> <span class="hljs-title">constexpr</span> <span class="hljs-params">(std::is_signed_v&lt;<span class="hljs-type">char</span>&gt;)</span> </span>{    ...}</code></pre></div><p>或在实例化模板时:</p><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-comment">// C&lt;T&gt;类的主要模板</span><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T, <span class="hljs-type">bool</span> = std::is_pointer_v&lt;T&gt;&gt;<span class="hljs-keyword">class</span> C {    ...};<span class="hljs-comment">// 指针类型的部分特殊化。</span><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">C</span>&lt;T, <span class="hljs-literal">true</span>&gt; {    ...};</code></pre></div><p>在这里，以C类为例，它为指针类型提供了一个特殊的实现。<br>但是如果类型特征产生一个非布尔值，后缀_v也可以使用，比如std::extreme&lt;&gt;。它产生的是一个原始数组的维度大小:</p><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-type">int</span> a[<span class="hljs-number">5</span>][<span class="hljs-number">7</span>];std::cout &lt;&lt; std::extent_v&lt;<span class="hljs-keyword">decltype</span>(a)&gt; &lt;&lt; <span class="hljs-string">'\n'</span>; <span class="hljs-comment">// prints 5</span>std::cout &lt;&lt; std::extent_v&lt;<span class="hljs-keyword">decltype</span>(a),<span class="hljs-number">1</span>&gt; &lt;&lt; <span class="hljs-string">'\n'</span>; <span class="hljs-comment">// prints 7</span></code></pre></div><h4><span id="21-2-xin-lei-xing-te-zheng">21.2 新类型特征</span><a href="#21-2-xin-lei-xing-te-zheng" class="header-anchor">#</a></h4><p>C++17 引入了几个新的类型特征。<br>此外， is_literal_type&lt;&gt; 和 result_of&lt;&gt; 自 C++17 起已弃用。<br>正在建设中的详细说明</p><h6><span id="is-aggregate-lt-gt">is_aggregate&lt;&gt;</span><a href="#is-aggregate-lt-gt" class="header-anchor">#</a></h6><p>std::is_aggregate<t> 评估 T 是否为聚合类型：</t></p><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;<span class="hljs-keyword">struct</span> <span class="hljs-title class_">D</span> : std::string, std::complex&lt;T&gt; {    std::string data;};D&lt;<span class="hljs-type">float</span>&gt; s{{<span class="hljs-string">"hello"</span>}, {<span class="hljs-number">4.5</span>,<span class="hljs-number">6.7</span>}, <span class="hljs-string">"world"</span>}; <span class="hljs-comment">// OK since C++17</span>std::cout &lt;&lt; std::is_aggregate&lt;<span class="hljs-keyword">decltype</span>(s)&gt;::value; <span class="hljs-comment">// outputs: 1 (true)</span></code></pre></div><h4><span id="21-3-std-bool-constant-lt-gt">21.3 std::bool_constant&lt; &gt;。</span><a href="#21-3-std-bool-constant-lt-gt" class="header-anchor">#</a></h4><p>如果特征产生布尔值，它们现在使用别名模板 bool_constant&lt;&gt;：</p><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">namespace</span> std {    <span class="hljs-keyword">template</span>&lt;<span class="hljs-type">bool</span> B&gt;    <span class="hljs-keyword">using</span> bool_constant = integral_constant&lt;<span class="hljs-type">bool</span>, B&gt;; <span class="hljs-comment">// since C++17</span>    <span class="hljs-keyword">using</span> true_type = bool_constant&lt;<span class="hljs-literal">true</span>&gt;;    <span class="hljs-keyword">using</span> false_type = bool_constant&lt;<span class="hljs-literal">false</span>&gt;;}</code></pre></div><table><thead><tr><th>特征</th><th>作用</th></tr></thead><tbody><tr><td>is_aggregate<t></t></td><td>是聚合类型</td></tr><tr><td>has_unique_object_representations<t></t></td><td>任何两个具有相同值的对象在内存中具有相同的表示</td></tr><tr><td>is_invocable&lt;T,Args…&gt;</td><td>可用作 Args 的可调用对象…</td></tr><tr><td>is_nothrow_invocable&lt;T,Args…&gt;</td><td>可用作 Args… 的可调用对象…无需抛出</td></tr><tr><td>is_invocable_r&lt;RT,T,Args…&gt;</td><td>可用作 Args 的可调用… 返回 RT</td></tr><tr><td>is_nothrow_invocable_r&lt;RT,T,Args…&gt;</td><td>可用作 Args 的可调用对象…返回 RT 而不抛出</td></tr><tr><td>invoke_result&lt;T,Args…&gt;</td><td>如果用作 Args 的可调用结果类型…</td></tr><tr><td>is_swappable<t></t></td><td>is_swappable<t> 可以为此类型调用 swap()</t></td></tr><tr><td>is_nothrow_swappable<t></t></td><td>可以为此类型调用 swap() 并且该操作不能抛出</td></tr><tr><td>is_swappable_with&lt;T,T2&gt;</td><td>可以为这两种具有特定值类别的类型调用 swap()</td></tr><tr><td>is_nothrow_swappable_with&lt;T,T2&gt;</td><td>可以为这两种具有特定值类别的类型调用 swap() 并且该操作不能抛出</td></tr><tr><td>conjunction&lt;B…&gt;</td><td>逻辑和布尔特征 B…</td></tr><tr><td>disjunction&lt;B… &gt;</td><td>逻辑或布尔特征 B…</td></tr><tr><td>negation<b></b></td><td>逻辑不用于布尔特征 B</td></tr></tbody></table><p>在C++17之前，std::true_type和std::false_type分别被直接定义为std::integral_constant&lt;bool,true&gt;和std::integral_constant&lt;bool,false&gt;的别名定义。<br>尽管如此，如果一个特定的属性适用，布尔特性通常继承自std::true_type，如果不适用则继承自std::false_type。比如说:</p><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-comment">// 主模板：通常 T 不是 void 类型</span><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;<span class="hljs-keyword">struct</span> <span class="hljs-title class_">IsVoid</span> : std::false_type {};<span class="hljs-comment">// void 类型的特化:</span><span class="hljs-keyword">template</span>&lt;&gt;<span class="hljs-keyword">struct</span> <span class="hljs-title class_">IsVoid</span>&lt;<span class="hljs-type">void</span>&gt; : std::true_type {};</code></pre></div><p>但是现在你可以通过派生自bool_constant&lt;&gt;来定义你自己的类型特质，如果你能够把相应的编译时表达式表述为布尔条件的话。比如说:</p><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;<span class="hljs-keyword">struct</span> <span class="hljs-title class_">IsLargerThanInt</span>    : <span class="hljs-function">std::bool_constant&lt;<span class="hljs-params">(<span class="hljs-keyword">sizeof</span>(T) &gt; <span class="hljs-keyword">sizeof</span>(<span class="hljs-type">int</span>))</span>&gt; </span>{    }</code></pre></div><p>这样你就可以使用这样一个特性，根据一个类型是否大于int来进行编译:</p><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;</span><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">foo</span><span class="hljs-params">(T x)</span></span><span class="hljs-function"></span>{    <span class="hljs-function"><span class="hljs-keyword">if</span> <span class="hljs-title">constexpr</span><span class="hljs-params">(IsLargerThanInt&lt;T&gt;::value)</span> </span>{        ...    }}</code></pre></div><p>通过添加后缀_v的相应变量模板作为内联变量:</p><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;<span class="hljs-keyword">inline</span> <span class="hljs-type">static</span> <span class="hljs-keyword">constexpr</span> <span class="hljs-keyword">auto</span> IsLargerThanInt_v = IsLargerThanInt&lt;T&gt;::value;</code></pre></div><p>你也可以缩短该特性的用法，如下所示:</p><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;</span><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">foo</span><span class="hljs-params">(T x)</span></span><span class="hljs-function"></span>{    <span class="hljs-function"><span class="hljs-keyword">if</span> <span class="hljs-title">constexpr</span><span class="hljs-params">(IsLargerThanInt_v&lt;T&gt;)</span> </span>{        ...    }}</code></pre></div><p>作为另一个例子，我们可以定义一个特质，检查一个类型T的移动构造函数是否保证不抛出，大致如下:</p><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;<span class="hljs-keyword">struct</span> <span class="hljs-title class_">IsNothrowMoveConstructibleT</span>    : std::bool_constant&lt;<span class="hljs-built_in">noexcept</span>(<span class="hljs-built_in">T</span>(std::<span class="hljs-built_in">declval</span>&lt;T&gt;()))&gt; {    };</code></pre></div><h4><span id="21-4-std-void-t-lt-gt">21.4 std::void_t&lt; &gt;</span><a href="#21-4-std-void-t-lt-gt" class="header-anchor">#</a></h4><p>在C++17中，一个小小的，但令人难以置信的有用的定义类型特征的辅助工具被标准化了：std::void_t&lt;&gt;。<br>它被简单地定义如下：</p><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">namespace</span> std {    <span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span>...&gt; <span class="hljs-keyword">using</span> <span class="hljs-type">void_t</span> = <span class="hljs-type">void</span>;}</code></pre></div><p>也就是说，它对任何模板参数的变量列表都会产生无效。这很有帮助，我们只想在参数列表中处理类型。<br>主要的应用是在定义新的类型特征时检查条件的能力。下面的例子演示了这个帮助器的应用：</p><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;utility&gt;</span> <span class="hljs-comment">// 对于declval&lt;&gt;来说</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;type_traits&gt;</span> <span class="hljs-comment">// 为true_type，false_type，和void_t</span></span><span class="hljs-comment">// 主模板:</span><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span>, <span class="hljs-keyword">typename</span> = std::<span class="hljs-type">void_t</span>&lt;&gt;&gt;<span class="hljs-keyword">struct</span> HasVarious : std::false_type {};<span class="hljs-comment">// 部分专业（可能会被SFINAE所取代）:</span><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;<span class="hljs-keyword">struct</span> <span class="hljs-title class_">HasVarious</span>&lt;T, std::<span class="hljs-type">void_t</span>&lt;<span class="hljs-keyword">decltype</span>(std::<span class="hljs-built_in">declval</span>&lt;T&gt;().<span class="hljs-built_in">begin</span>()),<span class="hljs-keyword">typename</span> T::difference_type,<span class="hljs-keyword">typename</span> T::iterator&gt;&gt;    : std::true_type {    };</code></pre></div><p>在这里，我们定义了一个新的类型特质HasVariousT&lt;&gt;，它检查三件事。</p><ul><li><p>该类型是否有一个成员函数begin()？</p></li><li><p>该类型是否有一个类型成员 difference_type？</p></li><li><p>该类型是否有一个类型成员迭代器？<br>只有当所有相应的表达式都对一个类型T有效时，才会使用部分专业化。那么它就比主模板更具体，而且由于我们从std::true_type派生出来，对这个特征的值进行检查会得到true。</p><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">if</span> <span class="hljs-title">constexpr</span> <span class="hljs-params">(HasVarious&lt;T&gt;::value)</span> </span>{    ...}</code></pre></div></li></ul><p>如果任何一个表达式的结果是无效的代码（即T没有begin()，或者没有类型成员difference_type，或者没有类型成员iterator），部分专业化就会被SFINAE’d掉，这意味着由于替换失败不是错误的规则，它被忽略。然后，只有主模板是可用的，它派生自std::false_type，所以对这个特质的值进行检查会产生false。<br>同样地，你可以使用std::void_t轻松地定义其他特质来检查一个或多个条件，其中一个成员或操作的存在/能力很重要。</p><h4><span id="21-5-hou-ji">21.5 后记</span><a href="#21-5-hou-ji" class="header-anchor">#</a></h4><p>标准类型性状的变量模板最早是由Stephan T. Lavavej在2014年提出的 <a href="https://wg21.link/n3854%E3%80%82%E5%AE%83%E4%BB%AC%E6%9C%80%E7%BB%88%E8%A2%AB%E9%87%87%E7%BA%B3%E4%B8%BA%E5%9B%BE%E4%B9%A6%E9%A6%86%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86TS%E7%9A%84%E4%B8%80%E9%83%A8%E5%88%86">https://wg21.link/n3854。它们最终被采纳为图书馆基本原理TS的一部分</a> 的一部分，由Alisdair Meredith在<a href="https://wg21.link/p0006r0%E3%80%82">https://wg21.link/p0006r0。</a></p><p>类型特质std::is_aggregate&lt;&gt;是作为美国国家机构的评论引入的，用于C++17的标准化。C++17的标准化而引入的（见<a href="https://wg21.link/lwg2911%EF%BC%89%E3%80%82">https://wg21.link/lwg2911）。</a></p><p>std::bool_constant&lt;&gt;是由袁志豪在<a href="https://wg21.link/n4334">https://wg21.link/n4334</a> 中首次提出的。它们最终被采纳为袁志豪在<a href="https://wg21.link/n4389">https://wg21.link/n4389</a> 中的提议。</p><p>std::void_t_&lt;&gt;是由Walter E. Brown在<a href="https://wg21.link/n3911">https://wg21.link/n3911</a> 中提出的，被采用。建设中</p><h3><span id="22-bing-xing-stl-suan-fa">22 并行STL算法</span><a href="#22-bing-xing-stl-suan-fa" class="header-anchor">#</a></h3><p>为了从现代多核架构中获益，C++17标准库引入了让STL标准算法使用多线程运行的能力，以并行处理不同的元素。</p><p>许多算法通过一个新的第一参数进行了扩展，以指定是否以及如何在并行线程中运行算法（当然，没有这个参数的老方法仍然被支持）。此外，还引入了一些专门支持并行处理的补充算法。</p><h6><span id="yi-ge-jian-dan-de-ji-shi-qi-zhu-shou">一个简单的计时器助手</span><a href="#yi-ge-jian-dan-de-ji-shi-qi-zhu-shou" class="header-anchor">#</a></h6><p>在本章的例子中，有时我们需要一个定时器来测量算法的速度。为此，我们使用了一个简单的辅助类，它初始化了一个定时器，并提供了printDiff()来打印消耗的毫秒数并重新初始化定时器:</p><p><code>lib/timer.hpp </code></p><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">ifndef</span> TIMER_HPP</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> TIMER_HPP</span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;chrono&gt;</span></span><span class="hljs-comment">/********************************************</span><span class="hljs-comment">* timer to print elapsed time</span><span class="hljs-comment">********************************************/</span><span class="hljs-keyword">class</span> <span class="hljs-title class_">Timer</span>{<span class="hljs-keyword">private</span>:    std::chrono::steady_clock::time_point last;<span class="hljs-keyword">public</span>:    <span class="hljs-built_in">Timer</span>()        : la st{std::chrono::steady_clock::<span class="hljs-built_in">now</span>()} {        }    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">printDiff</span><span class="hljs-params">(<span class="hljs-type">const</span> std::string&amp; msg = <span class="hljs-string">"Timer diff: "</span>)</span> </span>{        <span class="hljs-keyword">auto</span> now{std::chrono::steady_clock::<span class="hljs-built_in">now</span>()};        std::chrono::duration&lt;<span class="hljs-type">double</span>, std::milli&gt; diff{now - last};        std::cout &lt;&lt; msg &lt;&lt; diff.<span class="hljs-built_in">count</span>() &lt;&lt; <span class="hljs-string">"ms\n"</span>;        last = std::chrono::steady_clock::<span class="hljs-built_in">now</span>();    }};<span class="hljs-meta">#<span class="hljs-keyword">endif</span> <span class="hljs-comment">// TIMER_HPP</span></span></code></pre></div><h4><span id="22-1-shi-yong-bing-xing-suan-fa">22.1 使用并行算法</span><a href="#22-1-shi-yong-bing-xing-suan-fa" class="header-anchor">#</a></h4><p>让我们从一些例子程序开始，展示让现有算法并行运行和使用新的并行算法的能力。</p><h5><span id="22-1-1-shi-yong-bing-xing-de-for-each">22.1.1 使用并行的for_each()</span><a href="#22-1-1-shi-yong-bing-xing-de-for-each" class="header-anchor">#</a></h5><p>这是并行运行标准算法 for_each() 的第一个非常简单的示例：</p><p><code>lib/parforeach.cpp </code></p><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;numeric&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;execution&gt;</span> <span class="hljs-comment">// 对于执行策略</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">"timer.hpp"</span></span><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>{    <span class="hljs-type">int</span> numElems = <span class="hljs-number">1000</span>;    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">Data</span> {        <span class="hljs-type">double</span> value; <span class="hljs-comment">// 初始值</span>        <span class="hljs-type">double</span> sqrt; <span class="hljs-comment">// 并行计算平方根</span>    };    <span class="hljs-comment">// 初始化没有平方根的 NumElems 值:</span>    std::vector&lt;Data&gt; coll;    coll.<span class="hljs-built_in">reserve</span>(numElems);    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>; i&lt;numElems; ++i) {        coll.<span class="hljs-built_in">push_back</span>(Data{i * <span class="hljs-number">4.37</span>, <span class="hljs-number">0</span>});    }    <span class="hljs-comment">// 平方根的并行计算:</span>    for_each(std::execution::par,             coll.<span class="hljs-built_in">begin</span>(), coll.<span class="hljs-built_in">end</span>(),             [](<span class="hljs-keyword">auto</span>&amp; val) {                 val.sqrt = std::<span class="hljs-built_in">sqrt</span>(val.value);             });}</code></pre></div><p>正如你所看到的，使用并行算法在原则上是非常容易的。</p><ul><li>包括头文件<execution>。</execution></li><li>按照你通常调用算法的方式来调用算法，并附加一个第一个参数，这个参数通常是简单的std::execution::par。</li></ul><p>在这种情况下，我们使用标准算法for_each()来计算传递的向量coll中所有元素的成员值的平方根。由于额外的第一个参数std::execution::par，我们要求该算法以并行模式运行:</p><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;execution&gt;</span></span>...for_each(std::execution::par,         coll.<span class="hljs-built_in">begin</span>(), coll.<span class="hljs-built_in">end</span>(),         [](<span class="hljs-keyword">auto</span>&amp; val) {             val.sqrt = std::<span class="hljs-built_in">sqrt</span>(val.value);         });</code></pre></div><p>像往常一样，coll在这里可以是任何范围。但是请注意，所有的并行算法都要求迭代器至少是前向迭代器（我们在不同的线程中迭代相同的元素，如果迭代器不迭代相同的值，那就没有意义）。<br>算法并行运行的方式是具体实现的。当然，使用多线程也不一定更快，因为启动和处理多线程也需要时间。</p><h6><span id="xing-neng-you-shi">性能优势</span><a href="#xing-neng-you-shi" class="header-anchor">#</a></h6><p>为了找到如何、是否以及何时值得并行运行这个算法，让我们把这个例子修改如下。<br><code>lib/parforeach.cpp</code> </p><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;numeric&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;execution&gt;</span> <span class="hljs-comment">// for the execution policy</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">"timer.hpp"</span></span><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>{    <span class="hljs-type">int</span> numElems = <span class="hljs-number">1000</span>;    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">Data</span> {        <span class="hljs-type">double</span> value; <span class="hljs-comment">// 初始值</span>        <span class="hljs-type">double</span> sqrt; <span class="hljs-comment">// 并行计算平方根</span>    };    <span class="hljs-comment">// 初始化没有平方根的 NumElems 值:</span>    std::vector&lt;Data&gt; coll;    coll.<span class="hljs-built_in">reserve</span>(numElems);    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>; i&lt;numElems; ++i) {        coll.<span class="hljs-built_in">push_back</span>(Data{i * <span class="hljs-number">4.37</span>, <span class="hljs-number">0</span>});    }    <span class="hljs-comment">// 平方根的并行计算:</span>    for_each(std::execution::par,             coll.<span class="hljs-built_in">begin</span>(), coll.<span class="hljs-built_in">end</span>(),             [](<span class="hljs-keyword">auto</span>&amp; val) {                 val.sqrt = std::<span class="hljs-built_in">sqrt</span>(val.value);             });}</code></pre></div><p>关键的修改是。</p><ul><li>我们可以通过命令行传递我们操作的数值的多少。</li><li>我们使用类Timer来测量调用算法的持续时间。</li><li>我们在一个循环中进行多次测量，以使持续时间更加成熟。<br>结果在很大程度上取决于所使用的硬件、C++编译器和C++库。在我的笔记本电脑上（在英特尔i7上使用Visual C++，带有2个核心和超线程），我们得到的结果如下。</li><li>在100个元素的情况下，顺序算法要快10倍以上。这是因为启动和管理线程需要太多的时间，对于几个元素来说不值得。</li><li>对于10,000个元素，我们接近于收支平衡。</li><li>对于1,000,000个元素，并行执行的速度大约是3倍。</li></ul><p>同样，这也不是一个一般性的证明，在什么地方和什么时候并行算法是值得的。但它表明，即使对于非微不足道的数字运算，也值得使用它们。关键是，它值得用在</p><ul><li>长操作</li><li>许多许多元素<br>例如，使用并行版本的算法count_if()计算一个ints vector中的偶数元素的数量是不值得的。元素的并行版本是不值得的；即使有1,000,000,000个元素也不值得。<div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">auto</span> num = std::<span class="hljs-built_in">count_if</span>(std::execution::par, <span class="hljs-comment">// execute policy</span>                         coll.<span class="hljs-built_in">cbegin</span>(), coll.<span class="hljs-built_in">cend</span>(), <span class="hljs-comment">// 范围</span>                         [](<span class="hljs-type">int</span> elem){ <span class="hljs-comment">//准则</span>                             <span class="hljs-keyword">return</span> elem % <span class="hljs-number">2</span> == <span class="hljs-number">0</span>;                         });</code></pre></div>事实上，对于本例中具有快速谓词的简单算法，并行运行可能永远不会有回报。每个元素都应该发生一些需要大量时间的事情，并且与其他元素的处理无关。<br>但你无法预测任何事情，因为何时以及如何使用并行线程，都取决于C++标准库的实现者。事实上，无法控制使用多少线程，实现者可能会决定只在一定数量的元素上使用多线程。<br>测量! 用你的目标平台上的典型场景。</li></ul><h5><span id="22-1-2-shi-yong-bing-xing-de-sort">22.1.2 使用并行的sort()</span><a href="#22-1-2-shi-yong-bing-xing-de-sort" class="header-anchor">#</a></h5><p>排序是另一个例子，并行算法可以提供帮助。因为排序标准对每个元素的使用不只一次，你可以节省大量时间。<br>例如，考虑一下，我们初始化一个字符串的向量如下:</p><div class="code-wrapper"><pre><code class="hljs c++">std::vector&lt;std::string&gt; coll;<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>; i &lt; numElems / <span class="hljs-number">2</span>; ++i) {    coll.<span class="hljs-built_in">emplace_back</span>(<span class="hljs-string">"id"</span> + std::<span class="hljs-built_in">to_string</span>(i));    coll.<span class="hljs-built_in">emplace_back</span>(<span class="hljs-string">"ID"</span> + std::<span class="hljs-built_in">to_string</span>(i));}</code></pre></div><p>也就是说，我们创建一个以 “id “或 “ID “开头的元素向量，后面是一个整数:</p><div class="code-wrapper"><pre><code class="hljs bash">id0 ID0 id1 ID1 id2 ID2 id3 ... id99 ID99 id100 ID100 ...</code></pre></div><p>我们可以像往常一样按以下顺序对元素进行排序:</p><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-built_in">sort</span>(coll.<span class="hljs-built_in">begin</span>(), coll.<span class="hljs-built_in">end</span>());</code></pre></div><p>现在也可以通过明确传递一个 “顺序 “执行策略来实现:</p><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-built_in">sort</span>(std::execution::seq, coll.<span class="hljs-built_in">begin</span>(), coll.<span class="hljs-built_in">end</span>());</code></pre></div><p>如果在运行时决定是顺序运行还是并行运行，并且你不想有不同的函数调用，那么将顺序执行作为参数传递会很有用。<br>要求用并行排序来代替是很容易的:</p><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-built_in">sort</span>(std::execution::par, coll.<span class="hljs-built_in">begin</span>(), coll.<span class="hljs-built_in">end</span>());</code></pre></div><p>请注意，还有另一个并行执行策略：</p><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-built_in">sort</span>(std::execution::par_seq, coll.<span class="hljs-built_in">begin</span>(), coll.<span class="hljs-built_in">end</span>());</code></pre></div><p>我稍后将解释其中的区别。<br>所以，问题又来了，（什么时候）使用并行排序更好？在我的笔记本电脑上，只有10,000个字符串，你可以看到排序的时间是顺序排序的一半。而且，即使是对1000个字符串进行排序，使用并行执行也略胜一筹。</p><h6><span id="yu-qi-ta-gai-jin-cuo-shi-xiang-jie-he">与其他改进措施相结合</span><a href="#yu-qi-ta-gai-jin-cuo-shi-xiang-jie-he" class="header-anchor">#</a></h6><p>请注意，还有其他的修改可能会给你带来更多或额外的好处。例如，如果我们只按数字排序，使用没有两个前导字符的子串，我们可以在谓词中使用字符串操作，并再次看到并行执行的2倍的改进:</p><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-built_in">sort</span>(std::execution::par,     coll.<span class="hljs-built_in">begin</span>(), coll.<span class="hljs-built_in">end</span>(),     [] (<span class="hljs-type">const</span> <span class="hljs-keyword">auto</span>&amp; a, <span class="hljs-type">const</span> <span class="hljs-keyword">auto</span>&amp; b) {         <span class="hljs-keyword">return</span> a.<span class="hljs-built_in">substr</span>(<span class="hljs-number">2</span>) &lt; b.<span class="hljs-built_in">substr</span>(<span class="hljs-number">2</span>);     });</code></pre></div><p>然而，substr()对于字符串来说是一个相当昂贵的成员函数，因为它创建并返回一个新的临时字符串。通过使用string_view类，我们甚至在连续执行的情况下，也会比以前好3倍。顺序执行的情况下，我们的速度也会提高3倍:</p><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-built_in">sort</span>(coll.<span class="hljs-built_in">begin</span>(), coll.<span class="hljs-built_in">end</span>(),     [] (<span class="hljs-type">const</span> <span class="hljs-keyword">auto</span>&amp; a, <span class="hljs-type">const</span> <span class="hljs-keyword">auto</span>&amp; b) {         <span class="hljs-keyword">return</span> std::string_view{a}.<span class="hljs-built_in">substr</span>(<span class="hljs-number">2</span>) &lt; std::string_view{b}.<span class="hljs-built_in">substr</span>(<span class="hljs-number">2</span>);     });</code></pre></div><p>结合使用并行算法，我们的速度提高了多达 10 倍：</p><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-built_in">sort</span>(std::execution::par,     coll.<span class="hljs-built_in">begin</span>(), coll.<span class="hljs-built_in">end</span>(),     [] (<span class="hljs-type">const</span> <span class="hljs-keyword">auto</span>&amp; a, <span class="hljs-type">const</span> <span class="hljs-keyword">auto</span>&amp; b) {         <span class="hljs-keyword">return</span> std::string_view{a}.<span class="hljs-built_in">substr</span>(<span class="hljs-number">2</span>) &lt; std::string_view{b}.<span class="hljs-built_in">substr</span>(<span class="hljs-number">2</span>);     });</code></pre></div><p>与使用字符串的 substr() 成员的顺序执行相比：</p><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-built_in">sort</span>(coll.<span class="hljs-built_in">begin</span>(), coll.<span class="hljs-built_in">end</span>(),     [] (<span class="hljs-type">const</span> <span class="hljs-keyword">auto</span>&amp; a, <span class="hljs-type">const</span> <span class="hljs-keyword">auto</span>&amp; b) {         <span class="hljs-keyword">return</span> a.<span class="hljs-built_in">substr</span>(<span class="hljs-number">2</span>) &lt; b.<span class="hljs-built_in">substr</span>(<span class="hljs-number">2</span>);</code></pre></div><h4><span id="22-2-zhi-xing-ce-lue">22.2 执行策略</span><a href="#22-2-zhi-xing-ce-lue" class="header-anchor">#</a></h4><p>你可以把不同的执行策略作为第一个参数传递给并行STL算法。它们被定义在头文件<execution>中。表Execution Policies列出了标准化的执行策略。</execution></p><table><thead><tr><th>策略</th><th>意义</th></tr></thead><tbody><tr><td>std::execution::seq</td><td>顺序执行</td></tr><tr><td>std::execution::par</td><td>并行顺序执行</td></tr><tr><td>std::execution::par_unseq</td><td>并行无序列（矢量）执行</td></tr></tbody></table><p>让我们详细讨论一下执行策略。</p><ul><li>使用seq的顺序执行<br>意味着和非并行算法一样，当前的执行线程按顺序逐个元素执行必要的操作。使用这个策略的行为应该和使用非并行方式调用算法一样，根本不需要传递任何执行策略。然而，对于接受这个参数的并行算法，可能会有额外的限制，比如for_each()不返回任何值，或者所有的迭代器必须至少是前向迭代器。<br>提供这个策略是为了能够通过传递一个不同的参数而不是使用一个不同的签名来请求顺序执行。但是请注意，采用这种策略的并行算法的行为可能与相应的非并行算法略有不同。</li><li>使用par的并行顺序执行<br>意味着多个线程可能依次执行元素的必要操作。当一个算法开始执行必要的操作时，它在处理其他元素之前完成这一执行。<br>与par_unseq相比，这可以确保没有问题或死锁发生，因为在处理完一个元素的步骤后，需要在同一个线程对另一个元素执行第一步之前调用另一个步骤。</li><li>使用par_unseq的并行无序执行<br>意味着多个线程可能为多个元素执行必要的操作，但不能保证一个线程执行该元素的所有步骤而不切换到其他 元素。这特别是使矢量执行成为可能，在这种情况下，一个线程可能首先执行多个元素的第一步 在执行下一个步骤之前，一个线程可能首先执行多个元素的执行步骤。</li></ul><p>并行的无序执行需要编译器/硬件的特别支持，以检测哪里和如何操作可以被矢量化。操作如何被矢量化。</p><h4><span id="22-3-yi-chang-chu-li">22.3 异常处理</span><a href="#22-3-yi-chang-chu-li" class="header-anchor">#</a></h4><p>所有的并行算法都会调用std::terminate()，如果元素访问函数通过一个未捕获的异常退出。<br>请注意，如果选择的是顺序执行策略，这也适用。如果不能接受这种情况，使用算法的非并行版本可能是更好的选择。<br>还要注意的是，并行算法仍有可能被抛出。如果它们不能为并行执行获得临时的内存资源，它们会抛出std::bad_alloc。然而，没有其他 可能会被抛出。</p><h4><span id="22-4-bu-shi-yong-bing-xing-suan-fa-de-hao-chu">22.4 不使用并行算法的好处</span><a href="#22-4-bu-shi-yong-bing-xing-suan-fa-de-hao-chu" class="header-anchor">#</a></h4><p>有了调用并行算法的能力，以及它们甚至提供了一个顺序执行策略的事实，可能会出现这样的问题：我们是否还需要非并行算法。<br>然而，除了向后兼容之外，使用非并行算法可能有很大的好处。</p><ul><li>可以使用输入和输出迭代器。</li><li>算法不会在异常情况下terminate()。</li><li>算法可以避免由于非故意使用元素而产生的副作用。</li><li>算法可能提供额外的功能，例如for_each()返回传递的可调用，以便能够处理其结果状态。</li></ul><h4><span id="22-5-bing-xing-suan-fa-de-gai-shu">22.5 并行算法的概述</span><a href="#22-5-bing-xing-suan-fa-de-gai-shu" class="header-anchor">#</a></h4><p>表Unmodified Parallel STL Algorithms列出了标准化的算法，可以不加任何修改地支持并行处理。<br>表Modified Parallel STL Algorithms列出了经过一些修改的支持并行处理的标准化算法。<br>表STL算法无并行化列出了不支持并行处理的算法。<br>请注意，对于 accumulate() 和 inner_product() ，新的并行算法被提供了宽松的要求。放宽了要求。</p><table><thead><tr><th>算法</th><th>备注</th></tr></thead><tbody><tr><td>find_end(), adjacent_find()</td><td>除了搜索者</td></tr><tr><td>search(), search_n()</td><td></td></tr><tr><td>swap_ranges()</td><td></td></tr><tr><td>replace(), replace_if()</td><td></td></tr><tr><td>fill()</td><td></td></tr><tr><td>generate()</td><td></td></tr><tr><td>remove(), remove_if()</td><td></td></tr><tr><td>unique()</td><td></td></tr><tr><td>reverse()</td><td></td></tr><tr><td>rotate()</td><td></td></tr><tr><td>partition(), stable_partition()</td><td></td></tr><tr><td>sort(), stable_sort(), partial_sort()</td><td></td></tr><tr><td>is_sorted(), is_sorted_until()</td><td></td></tr><tr><td>nth_element()</td><td></td></tr><tr><td>inplace_merge()</td><td></td></tr><tr><td>is_heap(), is_heap_until()</td><td></td></tr><tr><td>min_element(), max_element(), min_max_element()</td><td>除了搜索者</td></tr><tr><td>for_each()</td><td>前向迭代器和返回类型 void</td></tr><tr><td>all_of(), any_of(), none_of()</td><td>前向迭代器</td></tr><tr><td>for_each_n()</td><td></td></tr><tr><td>find(), find_if(), find_if_not()</td><td></td></tr><tr><td>find_first_of()</td><td></td></tr><tr><td>count(), count_if()</td><td></td></tr><tr><td>mismatch()</td><td></td></tr><tr><td>equal()</td><td></td></tr><tr><td>is_partitioned()</td><td></td></tr><tr><td>partial_sort_copy()</td><td></td></tr><tr><td>includes()</td><td></td></tr><tr><td>lexicographical_compare()</td><td></td></tr><tr><td>fill_n()</td><td></td></tr><tr><td>generate_n()</td><td></td></tr><tr><td>reverse_copy()</td><td></td></tr><tr><td>rotate_copy()</td><td></td></tr><tr><td>copy(), copy_n(), copy_if()</td><td></td></tr><tr><td>move()</td><td></td></tr><tr><td>transform()</td><td></td></tr><tr><td>replace_copy(), replace_copy_if()</td><td></td></tr><tr><td>remove_copy(), remove_copy_if()</td><td></td></tr><tr><td>unique_copy()</td><td></td></tr><tr><td>partition_copy()</td><td></td></tr><tr><td>merge()</td><td></td></tr><tr><td>set_union(), set_intersection()</td><td></td></tr><tr><td>set_difference(), set_symmetric_difference()</td><td></td></tr><tr><td>exclusive_scan(), inclusive_scan()</td><td>前向迭代器</td></tr><tr><td>accumulate(), inner_product(), partial_sum()</td><td>改用 reduce() 和 transform_reduce()</td></tr><tr><td>search() with searcher</td><td></td></tr><tr><td>copy_backward() move_backward()</td><td></td></tr><tr><td>sample(), shuffle()</td><td></td></tr><tr><td>partition_point()</td><td></td></tr><tr><td>lower_bound(), upper_bound(), equal_range()</td><td></td></tr><tr><td>binary_search()</td><td></td></tr><tr><td>is_permutation(), next_permutation(), prev_permutation()</td><td></td></tr><tr><td>push_heap(), pop_heap(), make_heap(), sort_heap()</td><td>改用 reduce() 和 transform_reduce()</td></tr></tbody></table><h4><span id="22-6-bing-xing-chu-li-de-xin-suan-fa">22.6 并行处理的新算法</span><a href="#22-6-bing-xing-chu-li-de-xin-suan-fa" class="header-anchor">#</a></h4><p>一些补充算法被引入，以处理自C++98以来可用的标准算法的并行处理。</p><h5><span id="22-6-1-reduce">22.6.1 reduce()</span><a href="#22-6-1-reduce" class="header-anchor">#</a></h5><p>例如，reduce()是作为 accumulate()的平行形式引入的，它 “累积 “所有元素（你可以定义，哪个操作执行 “累积”）。例如，考虑以下 accumulate() 的用法。</p><p><code>lib/accumulate.cpp </code></p><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;numeric&gt;</span> <span class="hljs-comment">// for accumulate()</span></span><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">printSum</span><span class="hljs-params">(<span class="hljs-type">long</span> num)</span></span><span class="hljs-function"></span>{    <span class="hljs-comment">// 用 1 2 3 4 的 num 个序列创建 coll:</span>    std::vector&lt;<span class="hljs-type">long</span>&gt; coll;    coll.<span class="hljs-built_in">reserve</span>(num * <span class="hljs-number">4</span>);    <span class="hljs-keyword">for</span> (<span class="hljs-type">long</span> i=<span class="hljs-number">0</span>; i &lt; num; ++i) {        coll.<span class="hljs-built_in">insert</span>(coll.<span class="hljs-built_in">end</span>(), {<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>});    }    <span class="hljs-keyword">auto</span> sum = std::<span class="hljs-built_in">accumulate</span>(coll.<span class="hljs-built_in">begin</span>(), coll.<span class="hljs-built_in">end</span>(),                               <span class="hljs-number">0L</span>);    std::cout &lt;&lt; <span class="hljs-string">"accumulate(): "</span> &lt;&lt; sum &lt;&lt; <span class="hljs-string">'\n'</span>;}<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>{    <span class="hljs-built_in">printSum</span>(<span class="hljs-number">1</span>);    <span class="hljs-built_in">printSum</span>(<span class="hljs-number">1000</span>);    <span class="hljs-built_in">printSum</span>(<span class="hljs-number">1000000</span>);    <span class="hljs-built_in">printSum</span>(<span class="hljs-number">10000000</span>);}</code></pre></div><p>我们计算所有元素的总和，输出：</p><div class="code-wrapper"><pre><code class="hljs bash">accumulate(): 10accumulate(): 10000accumulate(): 10000000</code></pre></div><h6><span id="huan-suan-yun-suan-de-ping-xing-hua">换算运算的平行化</span><a href="#huan-suan-yun-suan-de-ping-xing-hua" class="header-anchor">#</a></h6><p>这个程序可以通过改用reduce()来实现并行化:</p><p><code>lib/reduce.cpp</code></p><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;numeric&gt;</span> <span class="hljs-comment">// for reduce()</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;execution&gt;</span></span><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">printSum</span><span class="hljs-params">(<span class="hljs-type">long</span> num)</span></span><span class="hljs-function"></span>{    <span class="hljs-comment">// 用 1 2 3 4 的 num 个序列创建 coll:</span>    std::vector&lt;<span class="hljs-type">long</span>&gt; coll;    coll.<span class="hljs-built_in">reserve</span>(num * <span class="hljs-number">4</span>);    <span class="hljs-keyword">for</span> (<span class="hljs-type">long</span> i=<span class="hljs-number">0</span>; i &lt; num; ++i) {        coll.<span class="hljs-built_in">insert</span>(coll.<span class="hljs-built_in">end</span>(), {<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>});    }    <span class="hljs-keyword">auto</span> sum = std::<span class="hljs-built_in">reduce</span>(std::execution::par,                           coll.<span class="hljs-built_in">begin</span>(), coll.<span class="hljs-built_in">end</span>(),                           <span class="hljs-number">0L</span>);    std::cout &lt;&lt; <span class="hljs-string">"reduce(): "</span> &lt;&lt; sum &lt;&lt; <span class="hljs-string">'\n'</span>;}<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>{    <span class="hljs-built_in">printSum</span>(<span class="hljs-number">1</span>);    <span class="hljs-built_in">printSum</span>(<span class="hljs-number">1000</span>);    <span class="hljs-built_in">printSum</span>(<span class="hljs-number">1000000</span>);    <span class="hljs-built_in">printSum</span>(<span class="hljs-number">10000000</span>);}</code></pre></div><p>在输出相同的情况下，现在的程序可能运行得更快或更慢（取决于是否支持启动多线程，以及所花费的时间是否比我们并行运行算法所节省的时间多）。<br>这里使用的操作是+，它是换元的，所以加入积分元素的顺序并不重要。</p><h6><span id="fei-gong-e-yun-suan-de-bing-xing-hua">非共轭运算的并行化</span><a href="#fei-gong-e-yun-suan-de-bing-xing-hua" class="header-anchor">#</a></h6><p>然而，对于浮点值来说，顺序很重要，这就证明了以下程序:</p><p><code>lib/reducefloat.cpp </code></p><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;numeric&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;execution&gt;</span></span><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">printSum</span><span class="hljs-params">(<span class="hljs-type">long</span> num)</span></span><span class="hljs-function"></span>{    <span class="hljs-comment">// 用 0.1 0.3 0.0001 的 num 个序列创建 coll:</span>    std::vector&lt;<span class="hljs-type">double</span>&gt; coll;    coll.<span class="hljs-built_in">reserve</span>(num * <span class="hljs-number">4</span>);    <span class="hljs-keyword">for</span> (<span class="hljs-type">long</span> i=<span class="hljs-number">0</span>; i &lt; num; ++i) {        coll.<span class="hljs-built_in">insert</span>(coll.<span class="hljs-built_in">end</span>(), {<span class="hljs-number">0.1</span>, <span class="hljs-number">0.3</span>, <span class="hljs-number">0.00001</span>});    }    <span class="hljs-keyword">auto</span> sum1 = std::<span class="hljs-built_in">accumulate</span>(coll.<span class="hljs-built_in">begin</span>(), coll.<span class="hljs-built_in">end</span>(),                                <span class="hljs-number">0.0</span>);    std::cout &lt;&lt; <span class="hljs-string">"accumulate(): "</span> &lt;&lt; sum1 &lt;&lt; <span class="hljs-string">'\n'</span>;    <span class="hljs-keyword">auto</span> sum2 = std::<span class="hljs-built_in">reduce</span>(std::execution::par,                            coll.<span class="hljs-built_in">begin</span>(), coll.<span class="hljs-built_in">end</span>(),                            <span class="hljs-number">0.0</span>);    std::cout &lt;&lt; <span class="hljs-string">"reduce(): "</span> &lt;&lt; sum2 &lt;&lt; <span class="hljs-string">'\n'</span>;    std::cout &lt;&lt; (sum1==sum2 ? <span class="hljs-string">"equal\n"</span> : <span class="hljs-string">"differ\n"</span>);}<span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iomanip&gt;</span></span><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>{    std::cout &lt;&lt; std::<span class="hljs-built_in">setprecision</span>(<span class="hljs-number">20</span>);    <span class="hljs-built_in">printSum</span>(<span class="hljs-number">1</span>);    <span class="hljs-built_in">printSum</span>(<span class="hljs-number">1000</span>);    <span class="hljs-built_in">printSum</span>(<span class="hljs-number">1000000</span>);    <span class="hljs-built_in">printSum</span>(<span class="hljs-number">10000000</span>);}</code></pre></div><p>这里我们同时使用 accumulate() 和 reduce() 并比较结果。一个可能的输出是:</p><div class="code-wrapper"><pre><code class="hljs bash">accumulate(): 0.40001reduce(): 0.40001equalaccumulate(): 400.01reduce(): 400.01differaccumulate(): 400010reduce(): 400010differaccumulate(): 4.0001e+06reduce(): 4.0001e+06differ</code></pre></div><p>虽然结果看起来是一样的，但有时会有差异。这可能是以不同的顺序添加 的顺序不同而造成的。<br>如果我们改变打印浮点值的精度:</p><div class="code-wrapper"><pre><code class="hljs c++">std::cout &lt;&lt; std::<span class="hljs-built_in">setprecision</span>(<span class="hljs-number">20</span>);</code></pre></div><p>我们可以看到结果值略有不同：</p><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-built_in">accumulate</span>(): <span class="hljs-number">0.40001000000000003221</span><span class="hljs-built_in">reduce</span>(): <span class="hljs-number">0.40001000000000003221</span><span class="hljs-function">equal</span><span class="hljs-function"><span class="hljs-title">accumulate</span><span class="hljs-params">()</span>: <span class="hljs-number">400.01000000000533419</span></span><span class="hljs-function">reduce(): <span class="hljs-number">400.01000000000010459</span></span><span class="hljs-function">differ</span><span class="hljs-function">accumulate(): <span class="hljs-number">400009.99999085225863</span></span><span class="hljs-function">reduce(): <span class="hljs-number">400009.9999999878346</span></span><span class="hljs-function">differ</span><span class="hljs-function">accumulate(): <span class="hljs-number">4000100.0004483023658</span></span><span class="hljs-function">reduce(): <span class="hljs-number">4000100.0000019222498</span></span><span class="hljs-function">differ</span></code></pre></div><p>由于没有定义是否、何时以及如何实现并行算法，因此在某些平台上的结果可能看起来是一样的（达到一定数量的元素）。</p><h6><span id="fei-guan-lian-xing-cao-zuo-de-bing-xing-hua">非关联性操作的并行化</span><a href="#fei-guan-lian-xing-cao-zuo-de-bing-xing-hua" class="header-anchor">#</a></h6><p>现在让我们改变一下操作，通过总是添加每个值的平方来累积值:</p><p><code>lib/accumulate2.cpp</code></p><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;numeric&gt;</span> <span class="hljs-comment">// 对于 accumulate()</span></span><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">printSum</span><span class="hljs-params">(<span class="hljs-type">long</span> num)</span></span><span class="hljs-function"></span>{    <span class="hljs-comment">// 用 1 2 3 4 的 num 个序列创建 coll：</span>    std::vector&lt;<span class="hljs-type">long</span>&gt; coll;    coll.<span class="hljs-built_in">reserve</span>(num * <span class="hljs-number">4</span>);    <span class="hljs-keyword">for</span> (<span class="hljs-type">long</span> i=<span class="hljs-number">0</span>; i &lt; num; ++i) {        coll.<span class="hljs-built_in">insert</span>(coll.<span class="hljs-built_in">end</span>(), {<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>});    }    <span class="hljs-keyword">auto</span> squaredSum = [] (<span class="hljs-keyword">auto</span> sum, <span class="hljs-keyword">auto</span> val) {        <span class="hljs-keyword">return</span> sum + val * val;    };    <span class="hljs-keyword">auto</span> sum = std::<span class="hljs-built_in">accumulate</span>(coll.<span class="hljs-built_in">begin</span>(), coll.<span class="hljs-built_in">end</span>(),                               <span class="hljs-number">0L</span>,                               squaredSum);    std::cout &lt;&lt; <span class="hljs-string">"accumulate(): "</span> &lt;&lt; sum &lt;&lt; <span class="hljs-string">'\n'</span>;}<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>{    <span class="hljs-built_in">printSum</span>(<span class="hljs-number">1</span>);    <span class="hljs-built_in">printSum</span>(<span class="hljs-number">1000</span>);    <span class="hljs-built_in">printSum</span>(<span class="hljs-number">1000000</span>);    <span class="hljs-built_in">printSum</span>(<span class="hljs-number">10000000</span>);}</code></pre></div><p>在这里，我们传递一个lambda，对于每一个值，都要取当前的和，并加上新值的平方:</p><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">auto</span> squaredSum = [] (<span class="hljs-keyword">auto</span> sum, <span class="hljs-keyword">auto</span> val) {    <span class="hljs-keyword">return</span> sum + val * val;};</code></pre></div><p>使用 accumulate() 输出看起来很好:</p><div class="code-wrapper"><pre><code class="hljs bash">accumulate(): 30accumulate(): 30000accumulate(): 30000000accumulate(): 300000000</code></pre></div><p>但是，让我们使用 reduce() 切换到并行处理：</p><p> <code>lib/reduce2.cpp</code> </p><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;numeric&gt;</span> <span class="hljs-comment">// 对于reduce()</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;execution&gt;</span></span><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">printSum</span><span class="hljs-params">(<span class="hljs-type">long</span> num)</span></span><span class="hljs-function"></span>{    <span class="hljs-comment">// 用 1 2 3 4 的 num 个序列创建 coll：</span>    std::vector&lt;<span class="hljs-type">long</span>&gt; coll;    coll.<span class="hljs-built_in">reserve</span>(num * <span class="hljs-number">4</span>);    <span class="hljs-keyword">for</span> (<span class="hljs-type">long</span> i=<span class="hljs-number">0</span>; i &lt; num; ++i) {        coll.<span class="hljs-built_in">insert</span>(coll.<span class="hljs-built_in">end</span>(), {<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>});    }    <span class="hljs-keyword">auto</span> squaredSum = [] (<span class="hljs-keyword">auto</span> sum, <span class="hljs-keyword">auto</span> val) {        <span class="hljs-keyword">return</span> sum + val * val;    };    <span class="hljs-keyword">auto</span> sum = std::<span class="hljs-built_in">reduce</span>(std::execution::par,                           coll.<span class="hljs-built_in">begin</span>(), coll.<span class="hljs-built_in">end</span>(),                           <span class="hljs-number">0L</span>,                           squaredSum);    std::cout &lt;&lt; <span class="hljs-string">"reduce(): "</span> &lt;&lt; sum &lt;&lt; <span class="hljs-string">'\n'</span>;}<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>{    <span class="hljs-built_in">printSum</span>(<span class="hljs-number">1</span>);    <span class="hljs-built_in">printSum</span>(<span class="hljs-number">1000</span>);    <span class="hljs-built_in">printSum</span>(<span class="hljs-number">1000000</span>);    <span class="hljs-built_in">printSum</span>(<span class="hljs-number">10000000</span>);}</code></pre></div><p>输出可能会变成这样：</p><div class="code-wrapper"><pre><code class="hljs bash">reduce(): 30reduce(): 30000reduce(): -425251612reduce(): 705991074</code></pre></div><p>是的，结果有时可能是错误的。问题是，该操作不是关联性的。例如，如果我们对元素1、2和3应用这个操作，我们可能先计算0+1<em>1和2+3</em>3，但当我们把中间的结果结合起来时，我们又把3平方了，基本上是 计算:</p><div class="code-wrapper"><pre><code class="hljs bash">(0+1*1) + (2+3*3) * (2+3*3)</code></pre></div><p>但为什么这里的结果有时是正确的呢？嗯，似乎在这个平台上，reduce()只在一定数量的元素中并行运行。而这是完全可以的。因此，使用有足够多元素的测试案例来检测这样的问题。<br>解决这个问题的方法是使用另一种新的算法，transform_reduce()。它把我们要对每个元素进行的修改（这是我们可以并行化的一件事）和结果的累积分开，只要它是换元的（这是我们可以并行化的另一件事）。</p><p><code>lib/transformreduce.cpp </code></p><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;numeric&gt;</span> <span class="hljs-comment">// for transform_reduce()</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;execution&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;functional&gt;</span></span><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">printSum</span><span class="hljs-params">(<span class="hljs-type">long</span> num)</span></span><span class="hljs-function"></span>{    <span class="hljs-comment">// 用 1 2 3 4 的 num 个序列创建 coll:</span>    std::vector&lt;<span class="hljs-type">long</span>&gt; coll;    coll.<span class="hljs-built_in">reserve</span>(num * <span class="hljs-number">4</span>);    <span class="hljs-keyword">for</span> (<span class="hljs-type">long</span> i=<span class="hljs-number">0</span>; i &lt; num; ++i) {        coll.<span class="hljs-built_in">insert</span>(coll.<span class="hljs-built_in">end</span>(), {<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>});    }    <span class="hljs-keyword">auto</span> sum = std::<span class="hljs-built_in">transform_reduce</span>(std::execution::par,                                     coll.<span class="hljs-built_in">begin</span>(), coll.<span class="hljs-built_in">end</span>(),                                     <span class="hljs-number">0L</span>,                                     std::plus{},                                     [] (<span class="hljs-keyword">auto</span> val) {                                         <span class="hljs-keyword">return</span> val * val;                                     });    std::cout &lt;&lt; <span class="hljs-string">"transform_reduce(): "</span> &lt;&lt; sum &lt;&lt; <span class="hljs-string">'\n'</span>;}<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>{    <span class="hljs-built_in">printSum</span>(<span class="hljs-number">1</span>);    <span class="hljs-built_in">printSum</span>(<span class="hljs-number">1000</span>);    <span class="hljs-built_in">printSum</span>(<span class="hljs-number">1000000</span>);    <span class="hljs-built_in">printSum</span>(<span class="hljs-number">10000000</span>);}</code></pre></div><p>在调用transform_reduce()时，我们传递了</p><ul><li>执行策略，以便（允许）并行地运行这个程序</li><li>要处理的值的范围</li><li>0L作为外部累加的初始值</li><li>操作+作为外部累加的操作</li><li>一个lambda，用于在累加之前处理每个值</li></ul><p>transform_reduce()可能是迄今为止最重要的并行算法，因为我们经常在合并数值之前修改它们（也称为map reduce原则）。</p><h6><span id="yong-yu-wen-jian-xi-tong-cao-zuo-de-transform-reduce-han-shu">用于文件系统操作的transform_reduce()函数</span><a href="#yong-yu-wen-jian-xi-tong-cao-zuo-de-transform-reduce-han-shu" class="header-anchor">#</a></h6><p>下面是另一个并行运行transform_reduce()的例子:</p><p><code>lib/dirsize.cpp</code></p><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;numeric&gt;</span> <span class="hljs-comment">// for transform_reduce()</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;execution&gt;</span> <span class="hljs-comment">// 对于执行策略</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;filesystem&gt;</span> <span class="hljs-comment">// filesystem library</span></span><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span>* argv[])</span></span><span class="hljs-function"></span>{    <span class="hljs-comment">// 根目录作为命令行参数被传递:</span>    <span class="hljs-keyword">if</span> (argc &lt; <span class="hljs-number">2</span>) {        std::cout &lt;&lt; <span class="hljs-string">"Usage: "</span> &lt;&lt; argv[<span class="hljs-number">0</span>] &lt;&lt; <span class="hljs-string">" &lt;path&gt; \n"</span>;        <span class="hljs-keyword">return</span> EXIT_FAILURE;    }    std::filesystem::path root{argv[<span class="hljs-number">1</span>]};    <span class="hljs-comment">// 在通过的文件树中启动所有文件路径的列表:</span>    std::vector&lt;std::filesystem::path&gt; paths;    <span class="hljs-keyword">try</span> {        std::filesystem::recursive_directory_iterator dirpos{root};        std::<span class="hljs-built_in">copy</span>(<span class="hljs-built_in">begin</span>(dirpos), <span class="hljs-built_in">end</span>(dirpos),                  std::<span class="hljs-built_in">back_inserter</span>(paths));    }    <span class="hljs-built_in">catch</span> (<span class="hljs-type">const</span> std::exception&amp; e) {        std::cerr &lt;&lt; <span class="hljs-string">"EXCEPTION: "</span> &lt;&lt; e.<span class="hljs-built_in">what</span>() &lt;&lt; std::endl;        <span class="hljs-keyword">return</span> EXIT_FAILURE;    }    <span class="hljs-comment">// 累积所有常规文件的大小:</span>    <span class="hljs-keyword">auto</span> sz = std::<span class="hljs-built_in">transform_reduce</span>(        std::execution::par, <span class="hljs-comment">// 并行执行</span>        paths.<span class="hljs-built_in">cbegin</span>(), paths.<span class="hljs-built_in">cend</span>(), <span class="hljs-comment">// range</span>        std::<span class="hljs-type">uintmax_t</span>{<span class="hljs-number">0</span>}, <span class="hljs-comment">// 初始值</span>        std::plus&lt;&gt;(), <span class="hljs-comment">// accumulate ...</span>        [](<span class="hljs-type">const</span> std::filesystem::path&amp; p) { <span class="hljs-comment">// 如果是普通文件，文件大小</span>            <span class="hljs-keyword">return</span> <span class="hljs-built_in">is_regular_file</span>(p) ? <span class="hljs-built_in">file_size</span>(p)                : std::<span class="hljs-type">uintmax_t</span>{<span class="hljs-number">0</span>};        });    std::cout &lt;&lt; <span class="hljs-string">"size of all "</span> &lt;&lt; paths.<span class="hljs-built_in">size</span>()        &lt;&lt; <span class="hljs-string">" regular files: "</span> &lt;&lt; sz &lt;&lt; <span class="hljs-string">'\n'</span>;}</code></pre></div><p>首先，我们递归地收集作为命令行参数的目录中的所有文件系统路径:</p><div class="code-wrapper"><pre><code class="hljs c++">std::filesystem::path root{argv[<span class="hljs-number">1</span>]};std::vector&lt;std::filesystem::path&gt; paths;std::filesystem::recursive_directory_iterator dirpos{root};std::<span class="hljs-built_in">copy</span>(<span class="hljs-built_in">begin</span>(dirpos), <span class="hljs-built_in">end</span>(dirpos),std::<span class="hljs-built_in">back_inserter</span>(paths));</code></pre></div><p>请注意，由于我们可能会传递一个无效的路径，可能的（文件系统）异常会被捕获。<br>然后，我们遍历文件系统路径的集合，积累它们的大小，如果它们是 正常的文件:</p><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">auto</span> sz = std::<span class="hljs-built_in">transform_reduce</span>(    std::execution::par, <span class="hljs-comment">// 并行执行</span>    paths.<span class="hljs-built_in">cbegin</span>(), paths.<span class="hljs-built_in">cend</span>(), <span class="hljs-comment">// range</span>    std::<span class="hljs-type">uintmax_t</span>{<span class="hljs-number">0</span>}, <span class="hljs-comment">// initial value</span>    std::plus&lt;&gt;(), <span class="hljs-comment">// accumulate ...</span>    [](<span class="hljs-type">const</span> std::filesystem::path&amp; p) { <span class="hljs-comment">// 文件大小（如果是常规文件）</span>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">is_regular_file</span>(p) ? <span class="hljs-built_in">file_size</span>(p)            : std::<span class="hljs-type">uintmax_t</span>{<span class="hljs-number">0</span>};    });</code></pre></div><p>新的标准算法transform_reduce()的操作方法如下。</p><ul><li>最后一个参数被应用于每个元素。在这里，对每个路径元素调用传递的lambda，如果它是一个普通文件，则查询其大小。</li><li>第二个但也是最后一个参数是合并所有大小的操作。因为我们要累积大小，所以我们使用标准函数对象std::plus&lt;&gt;。</li><li>第三个但也是最后一个参数是合并所有大小的操作的初始值。因此，如果路径列表是空的，我们从0开始。我们使用与file_size()的返回值相同的类型，std::uintmax_t。</li></ul><p>请注意，询问文件的大小是一个相当昂贵的操作，因为它需要一个操作系统调用。由于这个原因，使用一个算法来调用这个转换（从路径到大小），并以任何顺序与多个线程并行，并计算出总和，是非常快的回报。第一次测量显示了一个明显的胜利（程序的速度提高了一倍）。<br>还要注意的是，你不能把目录迭代器所迭代的路径直接传递给并行的 算法，因为目录迭代器是输入迭代器，而并行算法需要正向的 迭代器。<br>最后请注意，transform_reduce()被定义在头文件<numeric>中，而不是<algorithm>。<br>(就像 accumulate() 一样，它也算作数字算法。</algorithm></numeric></p><h4><span id="22-7-bing-xing-suan-fa-de-xiang-xi-jie-shao">22.7 并行算法的详细介绍</span><a href="#22-7-bing-xing-suan-fa-de-xiang-xi-jie-shao" class="header-anchor">#</a></h4><h4><span id="22-8-hou-ji">22.8 后记</span><a href="#22-8-hou-ji" class="header-anchor">#</a></h4><p>2012 年，Jared Hoberock Michael Garland Olivier Giroux Vinod Grover、Ujval Kapasi 和 Jaydeep Marathe 在 <a href="https://wg21.link/n3408">https://wg21.link/n3408</a> 中首次提出了并行化 STL 算法。 它成为了一个正式的 beta 标准，即并行 C++ 扩展技术规范（参见 <a href="https://wg21.link/n3850%EF%BC%89%E3%80%82">https://wg21.link/n3850）。</a> Jared Hoberock、Grant Mercer、Agustin Berge 和 Harmut Kaiser 在 <a href="https://wg21.link/n4276">https://wg21.link/n4276</a> 中添加了其他算法。 通过 <a href="https://wg21.link/p0024r2%EF%BC%8CJared">https://wg21.link/p0024r2，Jared</a> Hoberock 提出的标准库采用了 C++ 并行扩展技术规范。 JF Bastien 和 Bryce Adelstein Lelbach 在 <a href="https://wg21.link/p0394r4">https://wg21.link/p0394r4</a> 中提出的异常处理被接受。</p><h3><span id="23-zi-zi-fu-chuan-he-zi-xu-lie-sou-suo">23  子字符串和子序列搜索</span><a href="#23-zi-zi-fu-chuan-he-zi-xu-lie-sou-suo" class="header-anchor">#</a></h3><p>自C++98以来，C++标准库提供了一种搜索算法来寻找一个范围内元素的子序列。然而，存在着不同的搜索算法。例如，通过预先计算关于要搜索的模式的统计数据，这些算法对于特殊的任务，如在一个大文本中寻找子串，可以有明显的表现。<br>因此，C++17引入了Boyer-Moore和Boyer-Moore-Horspool搜索算法以及使用它们的各种接口。它们特别适用于搜索大文本中的子串，但也可以改进寻找容器或范围中的子序列。</p><h4><span id="23-1-shi-yong-zi-chuan-sou-suo-qi">23.1 使用子串搜索器</span><a href="#23-1-shi-yong-zi-chuan-sou-suo-qi" class="header-anchor">#</a></h4><p>新的搜索器是专门为搜索大型文本中的字符串（例如，单词或短语）而开发的。<br>因此，让我们首先演示一下在这种情况下如何使用它们，以及你如何利用它们来获益。</p><h5><span id="23-1-1-tong-guo-search-shi-yong-sou-suo-qi">23.1.1 通过search()使用搜索器</span><a href="#23-1-1-tong-guo-search-shi-yong-sou-suo-qi" class="header-anchor">#</a></h5><p>我们现在有以下选项来搜索一个字符串文本中的子串子:</p><ol><li>字符串成员 find():<div class="code-wrapper"><pre><code class="hljs c++">std::size_type idx = text.<span class="hljs-built_in">find</span>(sub)。</code></pre></div></li><li>算法搜索()。<div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">auto</span> pos = std::<span class="hljs-built_in">search</span>(text.<span class="hljs-built_in">begin</span>(), text.<span class="hljs-built_in">end</span>(),sub.<span class="hljs-built_in">begin</span>(), sub.<span class="hljs-built_in">end</span>())。</code></pre></div></li><li>并行算法 search():<div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">auto</span> pos = std::<span class="hljs-built_in">search</span>(std::execution::par,text.<span class="hljs-built_in">begin</span>(), text.<span class="hljs-built_in">end</span>(), sub.<span class="hljs-built_in">begin</span>(), sub.<span class="hljs-built_in">end</span>()）。</code></pre></div></li><li>使用 default_searcher:<div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">auto</span> pos = std::<span class="hljs-built_in">search</span>(text.<span class="hljs-built_in">begin</span>(), text.<span class="hljs-built_in">end</span>(),std::default_searcher{sub.<span class="hljs-built_in">begin</span>(), sub.<span class="hljs-built_in">end</span>()})。</code></pre></div></li><li>使用boyer_moore_searcher:<div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">auto</span> pos = std::<span class="hljs-built_in">search</span>(text.<span class="hljs-built_in">begin</span>(), text.<span class="hljs-built_in">end</span>(),std::boyer_moore_searcher{sub.<span class="hljs-built_in">begin</span>(), sub.<span class="hljs-built_in">end</span>()}）。</code></pre></div></li><li>使用boyer_moore_horspool_searcher:<div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">auto</span> pos = std::<span class="hljs-built_in">search</span>(text.<span class="hljs-built_in">begin</span>(), text.<span class="hljs-built_in">end</span>(),std::boyer_moore_horspool_searcher{sub.<span class="hljs-built_in">begin</span>(),sub.<span class="hljs-built_in">end</span>()}）。</code></pre></div>新的搜索器被定义在<functional>中。<br>Boyer-Moore和Boyer-Moore-Horspool搜索器是众所周知的算法，在搜索开始前预先计算表格（哈希值），以提高搜索的速度，如果搜索覆盖了相当大的文本和/或子串。使用它们，算法需要随机访问的迭代器（而不是正向迭代器，这对于天真的搜索（）来说已经足够了）。</functional></li></ol><p>在lib/searcher1.cpp中，你可以找到一个完整的程序，演示如何使用这些不同的方式来搜索子串。<br>请注意，所有search()的应用都会产生一个指向匹配子串的第一个字符的迭代器。如果没有，则返回文本的末端。这样我们就可以搜索到一个子串的所有出现，如下所示。</p><div class="code-wrapper"><pre><code class="hljs c++">std::boyer_moore_searcher bm{sub.<span class="hljs-built_in">begin</span>(), sub.<span class="hljs-built_in">end</span>()};<span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> pos = std::<span class="hljs-built_in">search</span>(text.<span class="hljs-built_in">begin</span>(), text.<span class="hljs-built_in">end</span>(), bm);pos != text.<span class="hljs-built_in">end</span>();pos = std::<span class="hljs-built_in">search</span>(pos+sub.<span class="hljs-built_in">size</span>(), text.<span class="hljs-built_in">end</span>(), bm)) {std::cout &lt;&lt; <span class="hljs-string">"Found '"</span> &lt;&lt; sub &lt;&lt; <span class="hljs-string">"' at index "</span> &lt;&lt; pos - text.<span class="hljs-built_in">begin</span>() &lt;&lt; <span class="hljs-string">'\n'</span>;}</code></pre></div><h6><span id="sou-suo-qi-de-xing-neng">搜索器的性能</span><a href="#sou-suo-qi-de-xing-neng" class="header-anchor">#</a></h6><p>哪一种是搜索子字符串的最佳方法（最快和/或最少的内存）？ 这个问题的一个特殊方面是我们现在也可以在并行模式下使用传统的 search() （使用新的搜索器时这是不可能的）。<br>答案取决于具体情况：</p><ul><li><p>仅使用（非并行）search() 通常是最慢的，因为对于文本中的每个字符，我们开始找出子字符串是否匹配。</p></li><li><p>使用 default_searcher 应该是等价的，但我看到更糟糕的运行时间高达 3 倍。</p></li><li><p>使用find()可能会更快，但这取决于库中实现的质量。在我所做的测量中，我看到与search()相比，运行时间提高了20%到100倍之间。</p></li><li><p>对于文本和相当大小的子串，boyer_moore_searcher应该是最快的。与search()相比，我看到了50倍甚至100倍的改进。在有大量子串的大文本中，这始终是最快的搜索。</p></li><li><p>boyer_moore__horspool_searcher以空间换时间。它通常比boyer_moore_searcher慢，但不应该使用那么多内存。我看到的改进在不同的平台上确实有很大的不同。在一个平台上，它接近boyer_moore（比search()好50倍，比find()好10倍），而在其他平台上，对search()的改进只有2或3倍，而使用find()则快得多。</p></li><li><p>使用并行的search()与普通的search()相比，我得到了3倍的支持，看起来使用Boyer-Moore搜索器通常还是要快很多。</p></li></ul><p>所以我只能给出一个建议。测量! 在你的目标平台上测试典型场景。<br>这是值得的，因为你可能会得到100倍的改进（例如，我在一个有1000万个字符的字符串中搜索一个接近结尾的1000个字符的子串）。<br><code>lib/searcher1.cpp</code>中的代码还打印了不同搜索选项的测量值，这样你就可以比较你的平台上的数字。</p><h5><span id="23-1-2-zhi-jie-shi-yong-sou-suo-qi">23.1.2 直接使用搜索器</span><a href="#23-1-2-zhi-jie-shi-yong-sou-suo-qi" class="header-anchor">#</a></h5><p>或者，你可以使用搜索器的函数调用操作，它返回一对开始和结束的一对子序列。<br>代码看起来如下。</p><div class="code-wrapper"><pre><code class="hljs c++">std::boyer_moore_searcher bm{sub.<span class="hljs-built_in">begin</span>(), sub.<span class="hljs-built_in">end</span>()};...;<span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> begend = <span class="hljs-built_in">bm</span>(text.<span class="hljs-built_in">begin</span>(), text.<span class="hljs-built_in">end</span>());     begend.first != text.<span class="hljs-built_in">end</span>();     begend = <span class="hljs-built_in">bm</span>(begend.second, text.<span class="hljs-built_in">end</span>())) {    std::cout &lt;&lt; <span class="hljs-string">"found '"</span> &lt;&lt; sub &lt;&lt; <span class="hljs-string">"' at index "</span>        &lt;&lt; begend.first - text.<span class="hljs-built_in">begin</span>() &lt;&lt; <span class="hljs-string">'-'</span>        &lt;&lt; begend.second - text.<span class="hljs-built_in">begin</span>() &lt;&lt; <span class="hljs-string">'\n'</span>;}</code></pre></div><p>然而，由于你可以使用std::tie()将新的值重新分配给结构化绑定的 std::pair&lt;&gt;，你可以将代码简化如下:</p><div class="code-wrapper"><pre><code class="hljs c++">std::boyer_moore_searcher bm{sub.<span class="hljs-built_in">begin</span>(), sub.<span class="hljs-built_in">end</span>()};...;<span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> [beg, end] = <span class="hljs-built_in">bm</span>(text.<span class="hljs-built_in">begin</span>(), text.<span class="hljs-built_in">end</span>());     beg != text.<span class="hljs-built_in">end</span>();     std::<span class="hljs-built_in">tie</span>(beg,end) = <span class="hljs-built_in">bm</span>(end, text.<span class="hljs-built_in">end</span>())) {    std::cout &lt;&lt; <span class="hljs-string">"found '"</span> &lt;&lt; sub &lt;&lt; <span class="hljs-string">"' at index "</span>        &lt;&lt; beg - text.<span class="hljs-built_in">begin</span>() &lt;&lt; <span class="hljs-string">'-'</span>        &lt;&lt; end - text.<span class="hljs-built_in">begin</span>() &lt;&lt; <span class="hljs-string">'\n'</span>;}</code></pre></div><p>只是直接使用搜索器寻找子串的第一次出现，你可以使用如果与 初始化和结构化绑定:</p><div class="code-wrapper"><pre><code class="hljs c++">std::boyer_moore_searcher bm{sub.<span class="hljs-built_in">begin</span>(), sub.<span class="hljs-built_in">end</span>()};...;<span class="hljs-keyword">if</span> (<span class="hljs-keyword">auto</span> [beg, end] = <span class="hljs-built_in">bm</span>(text.<span class="hljs-built_in">begin</span>(), text.<span class="hljs-built_in">end</span>()); beg != text.<span class="hljs-built_in">end</span>()) {    std::cout &lt;&lt; <span class="hljs-string">"found '"</span> &lt;&lt; sub &lt;&lt; <span class="hljs-string">"' first at index "</span>        &lt;&lt; beg - text.<span class="hljs-built_in">begin</span>() &lt;&lt; <span class="hljs-string">'-'</span>        &lt;&lt; end - text.<span class="hljs-built_in">begin</span>() &lt;&lt; <span class="hljs-string">'\n'</span>;}</code></pre></div><h4><span id="23-2-shi-yong-tong-yong-zi-xu-lie-sou-suo-qi">23.2 使用通用子序列搜索器</span><a href="#23-2-shi-yong-tong-yong-zi-xu-lie-sou-suo-qi" class="header-anchor">#</a></h4><p>Boyer-Moore 和 Boyer-Moore-Horspool 是作为字符串搜索器开发的。 但是，C++17 采用它们作为通用算法，以便您可以使用它们在容器或范围中查找元素的子序列。<br>也就是说，您现在可以实现以下内容：</p><div class="code-wrapper"><pre><code class="hljs c++">std::vector&lt;<span class="hljs-type">int</span>&gt; coll;...;std::deque&lt;<span class="hljs-type">int</span>&gt; sub{<span class="hljs-number">0</span>, <span class="hljs-number">8</span>, <span class="hljs-number">15</span>, ...};pos = std::<span class="hljs-built_in">search</span>(coll.<span class="hljs-built_in">begin</span>(), coll.<span class="hljs-built_in">end</span>(),                  std::boyer_moore_searcher{sub.<span class="hljs-built_in">begin</span>(), sub.<span class="hljs-built_in">end</span>()});</code></pre></div><p>同样，您还可以使用搜索器的函数调用运算符：</p><div class="code-wrapper"><pre><code class="hljs c++">std::vector&lt;<span class="hljs-type">int</span>&gt; coll;...;std::deque&lt;<span class="hljs-type">int</span>&gt; sub{<span class="hljs-number">0</span>, <span class="hljs-number">8</span>, <span class="hljs-number">15</span>, ...};std::boyer_moore_searcher bm{sub.<span class="hljs-built_in">begin</span>(), sub.<span class="hljs-built_in">end</span>()};<span class="hljs-keyword">auto</span> [beg, end] = <span class="hljs-built_in">bm</span>(coll.<span class="hljs-built_in">begin</span>(), coll.<span class="hljs-built_in">end</span>());<span class="hljs-keyword">if</span> (beg != coll.end) {    std::cout &lt;&lt; <span class="hljs-string">"found subsequence at &lt;&lt; "</span> beg - coll.<span class="hljs-built_in">begin</span>() &lt;&lt; <span class="hljs-string">'\n'</span>;}</code></pre></div><p>为了实现这一点，元素必须能够在哈希表中使用（即必须提供一个默认的哈希函数，并且必须支持用==来比较两个元素）。如果不是这种情况，你可以使用谓词（如下所述）。<br>再说一遍。测量发现你在性能（速度和内存）方面的好处。在尝试一些例子时，我看到了更多不同的因素。例如，使用boyer_moore_searcher可以将搜索的速度再次提高100倍（这又比使用并行算法快多了）。但是使用boyer_moore_horspool_searcher可以使搜索速度提高50倍，但也会慢2倍。<br><code>lib/searcher2.cpp</code>中的代码演示了对一个向量中的子序列的不同搜索，还打印了不同搜索选项的测量结果，这样你就可以比较 在你的平台上进行比较。</p><h4><span id="23-3-shi-yong-sou-suo-qi-de-wei-ci">23.3 使用搜索器的谓词</span><a href="#23-3-shi-yong-sou-suo-qi-de-wei-ci" class="header-anchor">#</a></h4><p>使用搜索时，您可以使用谓词，这可能是必要的，原因有两个：</p><ol><li><p>您想定义自己的方式来比较两个元素。</p></li><li><p>你想提供一个哈希函数，这对于 Boyer-Moore(-Horspool) 搜索器是必需的。<br> 您必须将谓词作为附加参数提供给搜索器的构造函数。 例如，这里我们不区分大小写地搜索子字符串：</p></li></ol>  <div class="code-wrapper"><pre><code class="hljs c++">std::boyer_moore_searcher bmic{substr.<span class="hljs-built_in">begin</span>(), substr.<span class="hljs-built_in">end</span>(),                               [](<span class="hljs-type">char</span> c){                                   <span class="hljs-keyword">return</span> std::hash&lt;<span class="hljs-type">char</span>&gt;{}(std::<span class="hljs-built_in">toupper</span>(c));                               },                               [](<span class="hljs-type">char</span> c1, <span class="hljs-type">char</span> c2){                                   <span class="hljs-keyword">return</span> std::<span class="hljs-built_in">toupper</span>(c1)==std::<span class="hljs-built_in">toupper</span>(c2);                               }                              };<span class="hljs-keyword">auto</span> begend = <span class="hljs-built_in">bmic</span>(sub.<span class="hljs-built_in">begin</span>(), sub.<span class="hljs-built_in">end</span>());</code></pre></div><p>  在散列值之前不要忘记调用 toupper()，否则你违反了散列值对于所有值必须相同的要求，其中 operator== 产生 true。<br>  在这里，如果我们有一个类 Customer 定义如下：</p>  <div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Customer</span> {    ...;    <span class="hljs-keyword">public</span>:    <span class="hljs-built_in">Customer</span>() = <span class="hljs-keyword">default</span>;    <span class="hljs-function">std::string <span class="hljs-title">getID</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>{        <span class="hljs-keyword">return</span> id;    }    <span class="hljs-keyword">friend</span> <span class="hljs-type">bool</span> <span class="hljs-keyword">operator</span>== (<span class="hljs-type">const</span> Customer&amp; c1, <span class="hljs-type">const</span> Customer&amp; c2) {        <span class="hljs-keyword">return</span> c1.id == c2.id;    }};</code></pre></div><p>  我们可以在Customer vector中搜索客户子序列，如下所示：</p>  <div class="code-wrapper"><pre><code class="hljs c++">std::vector&lt;Customer&gt; customers;...;std::vector&lt;Customer&gt; sub{...};...;<span class="hljs-function">std::boyer_moore_searcher <span class="hljs-title">bmcust</span><span class="hljs-params">(sub.begin(), sub.end(),</span></span><span class="hljs-params"><span class="hljs-function">                                 [](<span class="hljs-type">const</span> Customer&amp; c) {</span></span><span class="hljs-params"><span class="hljs-function">                                     <span class="hljs-keyword">return</span> std::hash&lt;std::string&gt;{}(c.getID());</span></span><span class="hljs-params"><span class="hljs-function">                                 })</span></span>;<span class="hljs-keyword">auto</span> pos = <span class="hljs-built_in">bmcust</span>(customers.<span class="hljs-built_in">begin</span>(), customers.<span class="hljs-built_in">end</span>());<span class="hljs-keyword">if</span> (pos.first != customers.<span class="hljs-built_in">end</span>()) {    ...;}</code></pre></div><p>  但是请注意，使用谓词可能会给使用搜索器带来很大的开销，所以只有当你有大量的元素并搜索一个相当大的子序列时才值得使用它们（例如，在100万个客户的集合中寻找1000个客户的子序列）。<br>  再次强调。要有大的思维，要有大的度量。</p><h4><span id="23-4-hou-ji">23.4 后记</span><a href="#23-4-hou-ji" class="header-anchor">#</a></h4><p>这些搜索最初是由 Marshall Clow 在 <a href="https://wg21.link/n3411">https://wg21.link/n3411</a> 中提出的，将 Boost.Algorithm 作为参考实现。 它们成为第一个图书馆基础 TS 的一部分。 对于 C++17，它们随后与 Beman Dawes 和 Alisdair Meredith 在 <a href="https://wg21.link/p0220r1">https://wg21.link/p0220r1</a> 中提出的其他组件一起采用，包括 Marshall Clow 在 <a href="https://wg21.link/p0253R1">https://wg21.link/p0253R1</a> 中提出的接口修复。</p><h3><span id="24-qi-ta-gong-ju-han-shu-he-suan-fa">24 其他工具函数和算法</span><a href="#24-qi-ta-gong-ju-han-shu-he-suan-fa" class="header-anchor">#</a></h3><p>C++17 提供了一些新的实用函数和算法，本章将对其进行介绍。</p><h4><span id="24-1-size-empty-and-data">24.1 size(), empty(), and data()</span><a href="#24-1-size-empty-and-data" class="header-anchor">#</a></h4><p>为了支持通用代码的灵活性，C++标准库提供了三个新的辅助函数：size()、empty()和data()。<br>正如其他用于泛型代码迭代范围和集合的全局辅助函数std::begin(), std::end(), 和std::advance()一样，这些函数被定义在头文件<iterator>中。</iterator></p><h5><span id="24-1-1-tong-yong-de-size-han-shu">24.1.1 通用的size()函数</span><a href="#24-1-1-tong-yong-de-size-han-shu" class="header-anchor">#</a></h5><p>通用的std::size()函数允许我们询问任何范围的大小，只要它有一个迭代器接口或者是一个原始数组。有了它，你可以写这样的代码:</p><p><code>lib/last5.hpp</code></p><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">ifndef</span> LAST5_HPP</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> LAST5_HPP</span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iterator&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;</span><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">printLast5</span><span class="hljs-params">(<span class="hljs-type">const</span> T&amp; coll)</span></span><span class="hljs-function"></span>{    <span class="hljs-comment">// 计算大小:</span>    <span class="hljs-keyword">auto</span> size{std::<span class="hljs-built_in">size</span>(coll)};    <span class="hljs-comment">// 前进到从最后 5 个元素开始的位置</span>    std::cout &lt;&lt; size &lt;&lt; <span class="hljs-string">" elems: "</span>;    <span class="hljs-keyword">auto</span> pos{std::<span class="hljs-built_in">begin</span>(coll)};    <span class="hljs-keyword">if</span> (size &gt; <span class="hljs-number">5</span>) {        std::<span class="hljs-built_in">advance</span>(pos, size - <span class="hljs-number">5</span>);        std::cout &lt;&lt; <span class="hljs-string">"... "</span>;    }    <span class="hljs-comment">// 打印剩余元素:</span>    <span class="hljs-keyword">for</span> ( ; pos != std::<span class="hljs-built_in">end</span>(coll); ++pos) {        std::cout &lt;&lt; *pos &lt;&lt; <span class="hljs-string">' '</span>;    }    std::cout &lt;&lt; <span class="hljs-string">'\n'</span>;}<span class="hljs-meta">#<span class="hljs-keyword">endif</span> <span class="hljs-comment">// LAST5_HPP</span></span></code></pre></div><p>在这里，与</p><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">auto</span> size{std::<span class="hljs-built_in">size</span>(coll)};</code></pre></div><p>我们用传递的集合的大小来初始化 size，它要么映射到 coll.size() 要么映射到传递的原始数组的大小。 因此，如果我们调用：</p><div class="code-wrapper"><pre><code class="hljs c++">std::array arr{<span class="hljs-number">27</span>, <span class="hljs-number">3</span>, <span class="hljs-number">5</span>, <span class="hljs-number">8</span>, <span class="hljs-number">7</span>, <span class="hljs-number">12</span>, <span class="hljs-number">22</span>, <span class="hljs-number">0</span>, <span class="hljs-number">55</span>};std::vector v{<span class="hljs-number">0.0</span>, <span class="hljs-number">8.8</span>, <span class="hljs-number">15.15</span>};std::initializer_list&lt;std::string&gt; il{<span class="hljs-string">"just"</span>, <span class="hljs-string">"five"</span>, <span class="hljs-string">"small"</span>, <span class="hljs-string">"string"</span>,                                      <span class="hljs-string">"literals"</span>};<span class="hljs-built_in">printLast5</span>(arr);<span class="hljs-built_in">printLast5</span>(v);<span class="hljs-built_in">printLast5</span>(il);</code></pre></div><p>输出是：</p><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-number">9</span> elems: ... <span class="hljs-number">7</span> <span class="hljs-number">12</span> <span class="hljs-number">22</span> <span class="hljs-number">0</span> <span class="hljs-number">55</span><span class="hljs-number">3</span> elems: <span class="hljs-number">0</span> <span class="hljs-number">8.8</span> <span class="hljs-number">15.15</span><span class="hljs-number">5</span> elems: just five small string literal</code></pre></div><p>并且因为支持原始 C 数组，我们也可以调用:</p><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-built_in">printLast5</span>(<span class="hljs-string">"hello world"</span>);</code></pre></div><p>打印:</p><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-number">12</span> elems: ... o r l d</code></pre></div><p>请注意，此函数模板因此替换了使用 countof 或 ARRAYSIZE 定义为类似以下内容的计算数组大小的常用方法：</p><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">define</span> ARRAYSIZE(a) (sizeof(a)/sizeof(*(a)))</span></code></pre></div><p>另请注意，您不能将内联定义的初始化列表传递给 last5&lt;&gt;()。 原因是模板参数不能推导出 std::initializer_list()。 为此，您必须使用以下声明重载 last5()：</p><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;</span><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">printLast5</span><span class="hljs-params">(<span class="hljs-type">const</span> std::initializer_list&lt;T&gt;&amp; coll)</span></span></code></pre></div><p>最后，请注意此代码不适用于 forward_list&lt;&gt;，因为转发列表没有成员函数 size()。 所以，如果你只想检查集合是否为空，你最好使用std::empty()，这将在后面讨论。</p><h5><span id="24-1-2-tong-yong-de-empty-han-shu">24.1.2 通用的empty()函数</span><a href="#24-1-2-tong-yong-de-empty-han-shu" class="header-anchor">#</a></h5><p>与新的全局 size() 类似，新的通用 std::empty() 允许我们检查容器、原始 C 数组或 std::initializer_list&lt;&gt; 是否为空。<br>因此，与上面的示例类似，您可以一般地检查传递的集合是否为空：</p><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">if</span> (std::<span class="hljs-built_in">empty</span>(coll)) {    <span class="hljs-keyword">return</span>;}</code></pre></div><p>与 std::size() 相比，std::empty() 也适用于前向列表/</p><h5><span id="24-1-3-tong-yong-de-data-han-shu">24.1.3 通用的data()函数</span><a href="#24-1-3-tong-yong-de-data-han-shu" class="header-anchor">#</a></h5><p>最后，新的通用 std::data() 函数允许我们访问具有 data() 成员和原始数组的容器的原始数据。 容器、原始 C 数组或 std::initializer_list&lt;&gt;。<br>例如，以下代码每隔一个元素打印一次：</p><p><code>lib/data.hpp </code></p><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">ifndef</span> DATA_HPP</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> DATA_HPP</span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iterator&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;</span><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">printData</span><span class="hljs-params">(<span class="hljs-type">const</span> T&amp; coll)</span></span><span class="hljs-function"></span>{    <span class="hljs-comment">// 每隔一个元素打印一次:</span>    <span class="hljs-keyword">for</span> (std::<span class="hljs-type">size_t</span> idx{<span class="hljs-number">0</span>}; idx &lt; std::<span class="hljs-built_in">size</span>(coll); ++idx) {        <span class="hljs-keyword">if</span> (idx % <span class="hljs-number">2</span> == <span class="hljs-number">0</span>) {            std::cout &lt;&lt; std::<span class="hljs-built_in">data</span>(coll)[idx] &lt;&lt; <span class="hljs-string">' '</span>;        }    }    std::cout &lt;&lt; <span class="hljs-string">'\n'</span>;}<span class="hljs-meta">#<span class="hljs-keyword">endif</span> <span class="hljs-comment">// DATA_HPP</span></span></code></pre></div><p>因此，如果我们调用：</p><div class="code-wrapper"><pre><code class="hljs c++">std::array arr{<span class="hljs-number">27</span>, <span class="hljs-number">3</span>, <span class="hljs-number">5</span>, <span class="hljs-number">8</span>, <span class="hljs-number">7</span>, <span class="hljs-number">12</span>, <span class="hljs-number">22</span>, <span class="hljs-number">0</span>, <span class="hljs-number">55</span>};std::vector v{<span class="hljs-number">0.0</span>, <span class="hljs-number">8.8</span>, <span class="hljs-number">15.15</span>};std::initializer_list&lt;std::string&gt; il{<span class="hljs-string">"just"</span>, <span class="hljs-string">"five"</span>, <span class="hljs-string">"small"</span>, <span class="hljs-string">"string"</span>,                                      <span class="hljs-string">"literals"</span>};<span class="hljs-built_in">printData</span>(arr);<span class="hljs-built_in">printData</span>(v);<span class="hljs-built_in">printData</span>(il);<span class="hljs-built_in">printData</span>(<span class="hljs-string">"hello world"</span>);</code></pre></div><p>输出：</p><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-number">27</span> <span class="hljs-number">5</span> <span class="hljs-number">7</span> <span class="hljs-number">22</span> <span class="hljs-number">55</span><span class="hljs-number">0</span> <span class="hljs-number">15.15</span>just small literalsh l o w r d</code></pre></div><h4><span id="24-2-as-const">24.2 as_const()</span><a href="#24-2-as-const" class="header-anchor">#</a></h4><p>新的辅助函数 std::as_const() 将值转换为相应的 const 值，而不使用 static_cast&lt;&gt; 或 add_const_t&lt;&gt; 类型特征。<br>它允许我们强制为非 const 对象调用函数的 const 重载，以防万一：</p><div class="code-wrapper"><pre><code class="hljs c++">std::vector&lt;std::string&gt; coll;<span class="hljs-built_in">foo</span>(coll); <span class="hljs-comment">// 喜欢非常量重载</span><span class="hljs-built_in">foo</span>(std::<span class="hljs-built_in">as_const</span>(coll)); <span class="hljs-comment">// 强制使用 const 重载</span></code></pre></div><p>如果 foo() 是一个函数模板，这也将强制将模板实例化为 const 类型而不是原始的非常量类型。</p><h5><span id="24-2-1-tong-guo-chang-liang-yin-yong-jin-xing-bu-huo">24.2.1 通过常量引用进行捕获</span><a href="#24-2-1-tong-guo-chang-liang-yin-yong-jin-xing-bu-huo" class="header-anchor">#</a></h5><p>as_const() 的一种应用是通过 const 引用捕获 lambda 参数的能力。 例如：</p><div class="code-wrapper"><pre><code class="hljs c++">std::vector&lt;<span class="hljs-type">int</span>&gt; coll {<span class="hljs-number">8</span>, <span class="hljs-number">15</span>, <span class="hljs-number">7</span>, <span class="hljs-number">42</span>};<span class="hljs-keyword">auto</span> printColl = [&amp;coll = std::<span class="hljs-built_in">as_const</span>(coll)] {    std::cout &lt;&lt; <span class="hljs-string">"coll: "</span>;    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> elem : coll) {        std::cout &lt;&lt; elem &lt;&lt; <span class="hljs-string">' '</span>;    }    std::cout &lt;&lt; <span class="hljs-string">'\n'</span>;};</code></pre></div><p>现在调用:</p><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-built_in">printColl</span>();</code></pre></div><p>将打印 coll 的当前状态，而不会有意外修改其值的危险。</p><h4><span id="24-3-clamp">24.3 clamp()</span><a href="#24-3-clamp" class="header-anchor">#</a></h4><p>C++17 提供了一个新的实用函数clamp()，它可以在传递的最小值和最大值之间“钳制”一个值。 它是 min() 和 max() 的组合调用。 例如：<br><code>lib/clamp.cpp</code></p><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span> <span class="hljs-comment">// for sample()</span></span><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>{    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i : {<span class="hljs-number">-7</span>, <span class="hljs-number">0</span>, <span class="hljs-number">8</span>, <span class="hljs-number">15</span>}) {        std::cout &lt;&lt; std::<span class="hljs-built_in">clamp</span>(i, <span class="hljs-number">5</span>, <span class="hljs-number">13</span>) &lt;&lt; <span class="hljs-string">'\n'</span>;    }}</code></pre></div><p>调用clamp(i, 5, 13) 与调用std::min(std::max(i, 5), 13) 的效果相同，因此程序具有以下输出：</p><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-number">5</span><span class="hljs-number">5</span><span class="hljs-number">8</span><span class="hljs-number">13</span></code></pre></div><p>至于 min() 和 max()，clamp() 要求所有通过 const 引用传递的参数都具有相同的类型 T：</p><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">namespace</span> std {    <span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;</span><span class="hljs-function">    <span class="hljs-keyword">constexpr</span> <span class="hljs-type">const</span> T&amp; <span class="hljs-title">clamp</span><span class="hljs-params">(<span class="hljs-type">const</span> T&amp; value, <span class="hljs-type">const</span> T&amp; min, <span class="hljs-type">const</span> T&amp; max)</span></span>;}</code></pre></div><p>返回值是对传递参数之一的 const 引用。<br>如果传递不同类型的参数，则可以显式指定模板参数 T：</p><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-type">double</span> d{<span class="hljs-number">4.3</span>};<span class="hljs-type">int</span> max{<span class="hljs-number">13</span>};...std::<span class="hljs-built_in">clamp</span>(d, <span class="hljs-number">0</span>, max); <span class="hljs-comment">// 编译时错误</span>std::<span class="hljs-built_in">clamp</span>&lt;<span class="hljs-type">double</span>&gt;(d, <span class="hljs-number">0</span>, max); <span class="hljs-comment">// OK</span></code></pre></div><p>你也可以传递浮点值，只要它们没有 NaN 值。<br>至于 min() 和 max() 你可以传递一个谓词作为比较操作。 例如：</p><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i : {<span class="hljs-number">-7</span>, <span class="hljs-number">0</span>, <span class="hljs-number">8</span>, <span class="hljs-number">15</span>}) {    std::cout &lt;&lt; std::<span class="hljs-built_in">clamp</span>(i, <span class="hljs-number">5</span>, <span class="hljs-number">13</span>,                            [] (<span class="hljs-keyword">auto</span> a, <span class="hljs-keyword">auto</span> b) {                                <span class="hljs-keyword">return</span> std::<span class="hljs-built_in">abs</span>(a) &lt; std::<span class="hljs-built_in">abs</span>(b);                            })        &lt;&lt; <span class="hljs-string">'\n'</span>;}</code></pre></div><p>具有以下输出：</p><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-number">-7</span><span class="hljs-number">5</span><span class="hljs-number">8</span><span class="hljs-number">13</span></code></pre></div><p>因为 -7 的绝对值介于 5 和 13 的绝对值之间，所以在这种情况下，clamp() 产生 -7。<br>没有采用值的初始化列表（如 min() 和 max() 所具有的）的 clamp() 的重载。</p><h4><span id="24-4-sample">24.4 sample()</span><a href="#24-4-sample" class="header-anchor">#</a></h4><p>通过sample()，C++17提供了一种算法，可以从一个给定的数值范围（群体）中提取一个随机子集（样本）。这有时被称为蓄水池采样或选择采样。<br>考虑一下下面的例子程序。</p><p><code>lib/sample1.cpp </code></p><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iterator&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span> <span class="hljs-comment">// for clamp()</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;random&gt;</span> <span class="hljs-comment">// for default_random_engine</span></span><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>{    <span class="hljs-comment">// 初始化一个包含 10,000 个字符串值的vector:</span>    std::vector&lt;std::string&gt; coll;    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10000</span>; ++i) {        coll.<span class="hljs-built_in">push_back</span>(<span class="hljs-string">"value"</span> + std::<span class="hljs-built_in">to_string</span>(i));    }    <span class="hljs-comment">// 打印此集合的 10 个随机选择的值:</span>    <span class="hljs-built_in">sample</span>(coll.<span class="hljs-built_in">begin</span>(), coll.<span class="hljs-built_in">end</span>(),           std::ostream_iterator&lt;std::string&gt;{std::cout, <span class="hljs-string">"\n"</span>},           <span class="hljs-number">10</span>,           std::default_random_engine{});}</code></pre></div><p>在使用大量字符串值（value0、value1、…）初始化向量后，我们使用 sample() 来提取这些字符串值的随机子集：</p><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-comment">// 打印此集合的 10 个随机选择的值:</span><span class="hljs-built_in">sample</span>(coll.<span class="hljs-built_in">begin</span>(), coll.<span class="hljs-built_in">end</span>(),       std::ostream_iterator&lt;std::string&gt;{std::cout, <span class="hljs-string">"\n"</span>},       <span class="hljs-number">10</span>,       std::default_random_engine{});</code></pre></div><p>我们通过：</p><ul><li>我们从中提取值子集的范围的开始和结束，</li><li>一个迭代器，用于将提取的值写入（这里是一个 ostream 迭代器将它们写入标准输出）</li><li>要提取的值的最大数量（我们可能会提取较少的值，范围太小）</li><li>用于计算随机子集的随机引擎</li></ul><p>结果，我们打印了 coll 的 10 个元素的随机子集。 输出可能是：</p><div class="code-wrapper"><pre><code class="hljs c++">value0value488value963value1994value2540value2709value2835value3518value5172value7996</code></pre></div><p>如您所见，元素的顺序是稳定的（与它们在 coll 中的顺序相匹配）。 但是，只有在传递范围的迭代器至少是前向迭代器时，才能保证这一点。<br>算法声明如下：</p><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">namespace</span> std {    <span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> InputIterator, <span class="hljs-keyword">typename</span> OutputIterator,</span><span class="hljs-function">    <span class="hljs-keyword">typename</span> Distance, <span class="hljs-keyword">typename</span> UniformRandomBitGenerator&gt;</span><span class="hljs-function">        OutputIterator <span class="hljs-title">sample</span><span class="hljs-params">(InputIterator sourceBeg, InputIterator sourceEnd,</span></span><span class="hljs-params"><span class="hljs-function">                              OutputIterator destBeg,</span></span><span class="hljs-params"><span class="hljs-function">                              Distance num,</span></span><span class="hljs-params"><span class="hljs-function">                              UniformRandomBitGenerator&amp;&amp; eng)</span></span>;}</code></pre></div><p>它具有以下规范和约束：</p><ul><li>源范围的迭代器必须至少是输入迭代器，目标范围的迭代器必须至少是输出迭代器。 但是，两者都不可能。 如果源迭代器不是最小前向迭代器，则目标迭代器必须是随机访问迭代器。</li><li>像往常一样，目标迭代器会覆盖，如果没有足够的元素可以覆盖并且没有使用插入器，则会导致未定义的行为。</li><li>该算法返回最后一个复制元素之后的位置。</li><li>目标迭代器不得在传递的源范围内。</li><li>num 可以是整数类型。 如果源范围内的元素不足，则提取源范围内的所有元素。</li><li>提取元素的顺序是稳定的，除非源范围内的迭代器是纯输入迭代器。</li></ul><p>这是另一个演示 sample() 用法的示例：</p><p><code>lib/sample2.cpp </code></p><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iterator&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span> <span class="hljs-comment">// for clamp()</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;random&gt;</span> <span class="hljs-comment">// for default_random_engine</span></span><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>{    <span class="hljs-comment">// initialize a vector of 10,000 string values:</span>    std::vector&lt;std::string&gt; coll;    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10000</span>; ++i) {        coll.<span class="hljs-built_in">push_back</span>(<span class="hljs-string">"value"</span> + std::<span class="hljs-built_in">to_string</span>(i));    }    <span class="hljs-comment">// 使用随机种子初始化 Mersenne Twister 引擎:</span>    std::random_device rd; <span class="hljs-comment">// 随机种子（如果支持）</span>    std::mt19937 eng{<span class="hljs-built_in">rd</span>()}; <span class="hljs-comment">// Mersenne twister engine</span>    <span class="hljs-comment">// 初始化目标范围（必须足够大以容纳 10 个元素）:</span>    std::vector&lt;std::string&gt; subset;    subset.<span class="hljs-built_in">resize</span>(<span class="hljs-number">100</span>);    <span class="hljs-comment">// 将 10 个随机选择的值从源范围复制到目标范围:</span>    <span class="hljs-keyword">auto</span> end = <span class="hljs-built_in">sample</span>(coll.<span class="hljs-built_in">begin</span>(), coll.<span class="hljs-built_in">end</span>(),                      subset.<span class="hljs-built_in">begin</span>(),                      <span class="hljs-number">10</span>,                      eng);    <span class="hljs-comment">// 打印提取的元素（使用返回值作为新的结束）:</span>    for_each(subset.<span class="hljs-built_in">begin</span>(), end,             [] (<span class="hljs-type">const</span> <span class="hljs-keyword">auto</span>&amp; s) {                 std::cout &lt;&lt; <span class="hljs-string">"random elem: "</span> &lt;&lt; s &lt;&lt; <span class="hljs-string">'\n'</span>;             });}</code></pre></div><p>在再次用大量字符串值（value0，value1，…）初始化一个vector之后，我们初始化一个用随机种子初始化的随机数引擎：</p><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-comment">// 用一个随机种子初始化一个Mersenne Twister引擎:</span>std::random_device rd; <span class="hljs-comment">// 随机种子（如果支持）</span>std::mt19937 eng{<span class="hljs-built_in">rd</span>()}; <span class="hljs-comment">// Mersenne Twister引擎 </span></code></pre></div><p>和一个目标范围:</p><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-comment">// 初始化目标范围（必须足够大以容纳 10 个元素）:</span>std::vector&lt;std::string&gt; subset;subset.<span class="hljs-built_in">resize</span>(<span class="hljs-number">100</span>);</code></pre></div><p>sample() 的调用现在将源范围的 10 个元素复制到目标范围：</p><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-comment">// 将 10 个随机选择的值从源范围复制到目标范围:</span><span class="hljs-keyword">auto</span> end = <span class="hljs-built_in">sample</span>(coll.<span class="hljs-built_in">begin</span>(), coll.<span class="hljs-built_in">end</span>(),                  subset.<span class="hljs-built_in">begin</span>(),                  <span class="hljs-number">10</span>,                  eng);</code></pre></div><p>返回值 end 初始化为包含最后一个随机提取的元素后面的位置，之后可以使用该位置，例如，打印提取的元素：</p><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-comment">// 打印提取的元素（使用返回值作为新的结束）：</span>for_each(subset.<span class="hljs-built_in">begin</span>(), end,         [] (<span class="hljs-type">const</span> <span class="hljs-keyword">auto</span>&amp; s) {             std::cout &lt;&lt; <span class="hljs-string">"random elem: "</span> &lt;&lt; s &lt;&lt; <span class="hljs-string">'\n'</span>;         });</code></pre></div><h4><span id="24-5-for-each-n">24.5 for_each_n()</span><a href="#24-5-for-each-n" class="header-anchor">#</a></h4><p>作为并行 STL 算法的一部分，提出了一种新算法 for_each_n()，该算法从 C++17 开始也以传统的非并行形式提供。 与 copy_n()、fill_n() 和 generate_n() 类似，它需要一个整数参数来将传递的可调用对象应用于给定范围的 n 个元素。<br>例如：<br><code>lib/foreachn.cpp</code></p><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span> <span class="hljs-comment">// for for_each_n()</span></span><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>{    <span class="hljs-comment">// 初始化一个包含 10,000 个字符串值的vector:</span>    std::vector&lt;std::string&gt; coll;    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10000</span>; ++i) {        coll.<span class="hljs-built_in">push_back</span>(std::<span class="hljs-built_in">to_string</span>(i));    }    <span class="hljs-comment">// 修改前 5 个元素：</span>    for_each_n(coll.<span class="hljs-built_in">begin</span>(), <span class="hljs-number">5</span>,               [] (<span class="hljs-keyword">auto</span>&amp; elem) {                   elem = <span class="hljs-string">"value"</span> + elem;               });    <span class="hljs-comment">// 打印前 10 个元素：</span>    for_each_n(coll.<span class="hljs-built_in">begin</span>(), <span class="hljs-number">10</span>,               [] (<span class="hljs-type">const</span> <span class="hljs-keyword">auto</span>&amp; elem) {                   std::cout &lt;&lt; elem &lt;&lt; <span class="hljs-string">'\n'</span>;               });}</code></pre></div><p>在用大量字符串值（value0、value1、…）初始化一个vector后，我们首先修改前 5 个字符串：</p><div class="code-wrapper"><pre><code class="hljs c++">for_each_n(coll.<span class="hljs-built_in">begin</span>(), <span class="hljs-number">5</span>,           [] (<span class="hljs-keyword">auto</span>&amp; elem) {               elem = <span class="hljs-string">"value"</span> + elem;           });</code></pre></div><p>然后打印前 10 个字符串：</p><div class="code-wrapper"><pre><code class="hljs c++">for_each_n(coll.<span class="hljs-built_in">begin</span>(), <span class="hljs-number">10</span>,           [] (<span class="hljs-type">const</span> <span class="hljs-keyword">auto</span>&amp; elem) {               std::cout &lt;&lt; elem &lt;&lt; <span class="hljs-string">'\n'</span>;           });</code></pre></div><p>因此，该程序具有以下输出：</p><div class="code-wrapper"><pre><code class="hljs bash">value0value1value2value3value456789</code></pre></div><p>算法声明如下：</p><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">namespace</span> std {    <span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> InputIterator, <span class="hljs-keyword">typename</span> Size, <span class="hljs-keyword">typename</span> Function&gt;</span><span class="hljs-function">    InputIterator <span class="hljs-title">for_each_n</span><span class="hljs-params">(InputIterator first, Size n, Function f)</span></span>;}</code></pre></div><p>请注意以下事项：</p><ul><li>for_each_n() 的非并行版本保证为每个元素按顺序调用传递的可调用对象。</li><li>for_each_n() 算法作为迭代器返回最后处理的元素后面的位置。</li><li>由调用者确保给定范围有足够的元素。</li><li>传递的可调用对象的任何返回值都将被忽略。</li></ul><p>该算法也可用作并行 STL 算法，它允许我们将任何函数应用于前 n 个元素，而无需保证任何顺序。</p><h4><span id="24-6-hou-ji">24.6 后记</span><a href="#24-6-hou-ji" class="header-anchor">#</a></h4><p>size()、empty() 和 data() 最早由 Riccardo Marcangelo 在 <a href="https://wg21.link/n4017">https://wg21.link/n4017</a> 中提出。 最终接受的措辞由 Riccardo Marcangelo 在 <a href="https://wg21.link/n4280">https://wg21.link/n4280</a> 中制定。<br>as_const() 由 ADAM David Alan Martin 和 Alisdair Meredith 在 <a href="https://wg21.link/n4380">https://wg21.link/n4380</a> 中首次提出。 最终接受的措辞由 ADAM David Alan Martin 和 Alisdair Meredith 在 <a href="https://wg21.link/p0007r1">https://wg21.link/p0007r1</a> 中制定。<br>clamp() 由 Martin Moene 和 Niels Dekker 在 <a href="https://wg21.link/n4536">https://wg21.link/n4536</a> 中首次提出。 最终接受的措辞由 Martin Moene 和 Niels Dekker 在 <a href="https://wg21.link/p002501">https://wg21.link/p002501</a> 中制定。</p><p>sample() 由 Walter E. Brown 在 <a href="https://wg21.link/n3842">https://wg21.link/n3842</a> 中首次提出。 最终接受的措辞由 Walter E. Brown 在 <a href="https://wg21.link/n3925">https://wg21.link/n3925</a> 中制定。</p><h3><span id="25-rong-qi-kuo-zhan">25  容器扩展</span><a href="#25-rong-qi-kuo-zhan" class="header-anchor">#</a></h3><p>C++ 标准库的标准容器有一些细微的变化，本章将对此进行描述。</p><h4><span id="25-1-zhi-chi-bu-wan-zheng-de-rong-qi-lei-xing">25.1 支持不完整的容器类型</span><a href="#25-1-zhi-chi-bu-wan-zheng-de-rong-qi-lei-xing" class="header-anchor">#</a></h4><p>由于 C++17 需要 std::vector、std::list 和 std__forward_list 来支持不完整类型。<br>这样做的主要动机在 Matt Austern 的一篇名为“标准图书馆员：不完整类型的容器”的文章中进行了描述（参见 <a href="http://drdobbs.com/184403814%EF%BC%89%EF%BC%9A%E6%82%A8%E7%8E%B0%E5%9C%A8%E5%8F%AF%E4%BB%A5%E6%8B%A5%E6%9C%89%E4%B8%80%E4%B8%AA%E7%B1%BB%E5%9E%8B%EF%BC%8C%E5%AE%83%E9%80%92%E5%BD%92%E5%9C%B0%E6%8B%A5%E6%9C%89%E4%B8%80%E4%B8%AA%E6%88%90%E5%91%98">http://drdobbs.com/184403814）：您现在可以拥有一个类型，它递归地拥有一个成员</a> 其类型的容器。 例如：</p><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Node</span>{    std::string value;    std::vector&lt;Node&gt; children; <span class="hljs-comment">// 好的，因为 C++17（节点在这里是不完整的类型）</span>};</code></pre></div><p>这也适用于具有私有成员和公共 API 的类。 这是一个完整的例子：</p><p><code>lib/incomplete.hpp</code></p><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">ifndef</span> NODE_HPP</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> NODE_HPP</span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span><span class="hljs-keyword">class</span> <span class="hljs-title class_">Node</span>{<span class="hljs-keyword">private</span>:    std::string value;    std::vector&lt;Node&gt; children; <span class="hljs-comment">// 好的，因为 C++17（节点在这里是不完整的类型）</span><span class="hljs-keyword">public</span>:    <span class="hljs-comment">// 创建一个带值的节点:</span>    <span class="hljs-built_in">Node</span>(std::string s) : value{std::<span class="hljs-built_in">move</span>(s)}, children{} {    }    <span class="hljs-comment">// 添加子节点:</span>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">add</span><span class="hljs-params">(Node n)</span> </span>{        children.<span class="hljs-built_in">push_back</span>(std::<span class="hljs-built_in">move</span>(n));    }    <span class="hljs-comment">// 访问子节点:</span>    Node&amp; <span class="hljs-keyword">operator</span>[](std::<span class="hljs-type">size_t</span> idx) {        <span class="hljs-keyword">return</span> children.<span class="hljs-built_in">at</span>(idx);    }    <span class="hljs-comment">// 递归打印节点树:</span>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">print</span><span class="hljs-params">(<span class="hljs-type">int</span> indent = <span class="hljs-number">0</span>)</span> <span class="hljs-type">const</span> </span>{        std::cout &lt;&lt; std::<span class="hljs-built_in">string</span>(indent, <span class="hljs-string">' '</span>) &lt;&lt; value &lt;&lt; <span class="hljs-string">'\n'</span>;        <span class="hljs-keyword">for</span> (<span class="hljs-type">const</span> <span class="hljs-keyword">auto</span>&amp; n : children) {            n.<span class="hljs-built_in">print</span>(indent+<span class="hljs-number">2</span>);        }    }    ...;};<span class="hljs-meta">#<span class="hljs-keyword">endif</span> <span class="hljs-comment">// NODE_HPP</span></span></code></pre></div><p>您可以使用此类，例如，如下所示：</p><p><code>lib/incomplete.cpp</code></p><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">"incomplete.hpp"</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>{    <span class="hljs-comment">// 创建节点树:</span>    Node root{<span class="hljs-string">"top"</span>};    root.<span class="hljs-built_in">add</span>(Node{<span class="hljs-string">"elem1"</span>});    root.<span class="hljs-built_in">add</span>(Node{<span class="hljs-string">"elem2"</span>});    root[<span class="hljs-number">0</span>].<span class="hljs-built_in">add</span>(Node{<span class="hljs-string">"elem1.1"</span>});    <span class="hljs-comment">// print node tree:</span>    root.<span class="hljs-built_in">print</span>();}</code></pre></div><p>该程序具有以下输出：</p><div class="code-wrapper"><pre><code class="hljs bash">topelem1elem1.1elem2</code></pre></div><h4><span id="25-2-jie-dian-chu-li-cheng-xu">25.2 节点处理程序</span><a href="#25-2-jie-dian-chu-li-cheng-xu" class="header-anchor">#</a></h4><p>通过引入从关联或无序容器中拼接节点的能力，你可以轻松地：</p><ul><li>修改键或（无序）maps或maps或（无序）集合。</li><li>在（无序） sets 和 maps中使用移动语义，以及</li><li>在（无序）sets 和 maps之间移动元素。</li></ul><p>例如，在定义和初始化一个map后，如下所示。</p><div class="code-wrapper"><pre><code class="hljs c++">std::map&lt;<span class="hljs-type">int</span>, std::string&gt; m{{<span class="hljs-number">1</span>,<span class="hljs-string">"mango"</span>},                             {<span class="hljs-number">2</span>,<span class="hljs-string">"papaya"</span>},                             {<span class="hljs-number">3</span>,<span class="hljs-string">"guava"</span>}};</code></pre></div><p>您可以使用键 2 修改元素，如下所示：</p><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">auto</span> nh = m.<span class="hljs-built_in">extract</span>(<span class="hljs-number">2</span>); <span class="hljs-comment">// nh 的类型为 decltype(m)::node_type</span>nh.<span class="hljs-built_in">key</span>() = <span class="hljs-number">4</span>;m.<span class="hljs-built_in">insert</span>(std::<span class="hljs-built_in">move</span>(nh));</code></pre></div><p>代码将键为 2 的元素的节点从容器中取出，修改键，然后将其移回，如图 25.1 中所述。<br>请注意，不使用内存（取消）分配，并且对元素的指针和引用保持有效。 但是，在元素保存在节点句柄中时使用指针和引用会导致未定义的行为。</p><p>节点句柄的类型是 container::node_type。 它为会员提供</p><ul><li>所有（无序）集合类型的value()</li><li>所有（无序）map类型的成员 key() 和 mapped()</li></ul><p>您还可以使用节点句柄将元素从一个容器移动到另一个容器。 容器甚至可以通过以下方式有所不同：</p><ul><li>一个支持重复，而另一个不支持（例如，您可以将元素从多地图移动到地图）</li><li>比较函数和散列函数可能不同</li></ul><p><img src="https://gitee.com/txt1994/images/raw/master/img/Cpp17TheCompleteGuideChinese/Figure_25.1.png"> )</p><p>例子：</p><div class="code-wrapper"><pre><code class="hljs c++">std::multimap&lt;<span class="hljs-type">double</span>, std::string&gt; src {{<span class="hljs-number">1.1</span>,<span class="hljs-string">"one"</span>},                                        {<span class="hljs-number">2.2</span>,<span class="hljs-string">"two"</span>},                                        {<span class="hljs-number">3.3</span>,<span class="hljs-string">"three"</span>}};std::map&lt;<span class="hljs-type">double</span>, std::string&gt; dst {{<span class="hljs-number">3.3</span>,<span class="hljs-string">"old data"</span>}};<span class="hljs-comment">// 将一些元素从 multimap src 移动到 map dst:</span>dst.<span class="hljs-built_in">insert</span>(src.<span class="hljs-built_in">extract</span>(src.<span class="hljs-built_in">find</span>(<span class="hljs-number">1.1</span>))); <span class="hljs-comment">// 使用迭代器拼接</span>dst.<span class="hljs-built_in">insert</span>(src.<span class="hljs-built_in">extract</span>(<span class="hljs-number">2.2</span>)); <span class="hljs-comment">// 使用键拼接</span></code></pre></div><p>请注意， insert() 函数返回一个包含三个元素的结构（按以下顺序）：</p><ul><li>如果无法插入，则为现有元素的迭代器位置。</li><li>插入一个布尔值，表示插入是否成功。</li><li>如果无法插入，则带有节点句柄的 mode_type 节点。</li></ul><p>即，关键信息是插入的第二个成员。 使用结构化绑定，您可以按如下方式使用返回值：</p><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">auto</span> [pos,done,node] = dst.<span class="hljs-built_in">insert</span>(src.<span class="hljs-built_in">extract</span>(<span class="hljs-number">3.3</span>));<span class="hljs-keyword">if</span> (!done) {    std::cout &lt;&lt; <span class="hljs-string">"insert() of node handle failed:"</span>        &lt;&lt; <span class="hljs-string">" tried to insert key '"</span> &lt;&lt; node.<span class="hljs-built_in">key</span>()        &lt;&lt; <span class="hljs-string">"' with value '"</span> &lt;&lt; node.<span class="hljs-built_in">mapped</span>()        &lt;&lt; <span class="hljs-string">"' but key exists with value '"</span> &lt;&lt; pos-&gt;second &lt;&lt; <span class="hljs-string">"'\n"</span>;}</code></pre></div><h4><span id="25-3-hou-ji">25.3 后记</span><a href="#25-3-hou-ji" class="header-anchor">#</a></h4><p>容器对不完整类型的支持首先是由 Matt Austern 在 <a href="http://drdobbs.com/184403814">http://drdobbs.com/184403814</a> 中讨论的，最初是由袁志豪在 <a href="https://wg21.link/n3890">https://wg21.link/n3890</a> 中提出的。 最终接受的措辞由袁志豪在 <a href="https://wg21.link/n4510">https://wg21.link/n4510</a> 中制定。</p><p>节点句柄首先由 Alan Talbot 间接提出，请求拼接操作作为库问题 <a href="https://wg21.link/lwg839">https://wg21.link/lwg839</a> 和 Alisdair Meredith 请求对节点元素的移动支持作为库问题 <a href="https://wg21.link/lwg1041%E3%80%82">https://wg21.link/lwg1041。</a> 最终接受的措辞由 Alan Talbot、Jonathan Wakely、Howard Hinnant 和 James Dennett 在 <a href="https://wg21.link/p0083r3">https://wg21.link/p0083r3</a> 中制定。 最终，Howard E. Hinnant 在 <a href="https://wg21.link/p0508r0">https://wg21.link/p0508r0</a> 中稍微澄清了 API。</p><h3><span id="26-duo-xian-cheng-he-bing-fa">26 多线程和并发</span><a href="#26-duo-xian-cheng-he-bing-fa" class="header-anchor">#</a></h3><p>在多线程和并发领域引入了一些小的扩展和改进。</p><h4><span id="26-1-bu-chong-de-hu-chi-he-suo">26.1 补充的互斥和锁</span><a href="#26-1-bu-chong-de-hu-chi-he-suo" class="header-anchor">#</a></h4><h5><span id="26-1-1-std-scoped-lock">26.1.1 std::scoped_lock</span><a href="#26-1-1-std-scoped-lock" class="header-anchor">#</a></h5><p>C++11 引入了一个简单的 std::lock_guard 来以一种简单的 RAII 风格的方式来锁定互斥锁：</p><ul><li>构造函数锁</li><li>析构函数解锁（可能由异常引起）</li></ul><p>不幸的是，这没有标准化为可变参数模板，以便能够通过单个声明锁定多个互斥锁。<br>std::scoped_lock&lt;&gt; 弥补了这一差距。 它允许我们锁定一个或多个互斥锁。 互斥锁可能有不同的互斥锁类型。<br>例如：</p><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;mutex&gt;</span></span>...;std::vector&lt;std::string&gt; allIssues;std::mutex allIssuesMx;std::vector&lt;std::string&gt; openIssues;std::timed_mutex openIssuesMx;<span class="hljs-comment">// lock both issue lists:</span>{    <span class="hljs-function">std::scoped_lock <span class="hljs-title">lg</span><span class="hljs-params">(allIssuesMx, openIssuesMx)</span></span><span class="hljs-function">    ...</span>; <span class="hljs-comment">// 操作 allIssues 和 openIssues</span>}</code></pre></div><p>请注意，由于类模板参数推导，您在声明 lg 时不必指定互斥锁的类型。<br>此示例用法等价于以下代码，从 C++11 开始可以调用：</p><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-comment">// 锁定两个问题清单:</span>{std::<span class="hljs-built_in">lock</span>(allIssuesMx, openIssuesMx); <span class="hljs-comment">// 避免死锁的锁</span><span class="hljs-function">std::lock_guard&lt;std::mutex&gt; <span class="hljs-title">lg1</span><span class="hljs-params">(allIssuesMx, std::adopt_lock)</span></span>;<span class="hljs-function">std::lock_guard&lt;std::mutex&gt; <span class="hljs-title">lg2</span><span class="hljs-params">(openIssuesMx, std::adopt_lock)</span></span>;... <span class="hljs-comment">// 同时操作allIssues和openIssues</span>}</code></pre></div><p>因此，如果传递了多个互斥锁，则 scoped_lock 的构造函数使用可变参数便利函数 lock(…)，它保证调用不会导致死锁（标准注释：“死锁避免算法，例如 因为必须使用try-and-back-off，但没有指定具体算法以避免过度约束实现”）。<br>如果只将一个互斥锁传递给 scoped_lock 的构造函数，它只会锁定互斥锁。 因此，在具有单个构造函数参数的 scoped_lock 中，其作用类似于 lock_guard）。 然后它甚至定义了没有为多个互斥锁定义的成员 mutex_type。1 因此，您可以将 lock_guard 的所有用法替换为 scoped_lock。<br>如果没有传递互斥体，则锁守卫不起作用。<br>请注意，您还可以采用多个锁：</p><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-comment">// 锁定两个问题清单:</span>{std::<span class="hljs-built_in">lock</span>(allIssuesMx, openIssuesMx); <span class="hljs-comment">// 注意：使用的死锁避免算法</span><span class="hljs-function">std::scoped_lock <span class="hljs-title">lg</span><span class="hljs-params">(std::adopt_lock, allIssuesMx, openIssuesMx)</span></span>;... <span class="hljs-comment">// 同时操作allIssues和openIssues</span>}</code></pre></div><p>然而，请注意，采用锁的构造函数现在在前面有 adopt_lock 参数。</p><h5><span id="26-1-2-std-shared-mutex">26.1.2 std::shared_mutex</span><a href="#26-1-2-std-shared-mutex" class="header-anchor">#</a></h5><p>C++14添加了shared_timed_mutex来支持读/写锁，即多个线程同时读取一个值，而不时地有线程可能会更新这个值。因为在一些平台上，不支持定时锁的mutex可以更有效地实现，现在引入了shared_mutex类型（就像自C++11以来，除了std::timed_mutex之外，还有std::mutex存在）。<br>shared_mutex定义在头文件<shared_mutex>中，支持以下操作。</shared_mutex></p><ul><li>对于独占锁：lock(), try_lock(), unlock()</li><li>对于共享的读访问：lock_shared(), try_lock_shared(), unlock_shared()</li><li>native_handle()</li></ul><p>也就是说，与shared_times_mutex不同，它不支持try_lock_for()、try_lock_until()。try_lock_shared_for(), and try_lock_shared_until()。</p><h6><span id="shi-yong-shared-mutex">使用 shared_mutex</span><a href="#shi-yong-shared-mutex" class="header-anchor">#</a></h6><p>使用shared_mutex的方法如下。假设你有一个共享vector，它通常被多个线程读取，但不时地被修改：</p><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;shared_mutex&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;mutex&gt;</span></span>...std::vector&lt;<span class="hljs-type">double</span>&gt; v; <span class="hljs-comment">// 共享资源</span>std::shared_mutex vMutex; <span class="hljs-comment">// 控制对 v 的访问（C++14 中的 shared_timed_mutex）</span></code></pre></div><p>要进行共享读取访问（以便多个读取器不会相互阻塞），请使用 shared_lock，它是共享读取访问的锁保护（在 C++14 中引入）。 例如：</p><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">if</span> (std::shared_lock <span class="hljs-built_in">sl</span>(vMutex); v.<span class="hljs-built_in">size</span>() &gt; <span class="hljs-number">0</span>) {    ... <span class="hljs-comment">// （共享）对vector v 元素的读取访问</span>}</code></pre></div><p>只有在排他性的写访问中，你才会使用排他性的锁防护，这可能是一个简单的lock_guard或scoped_lock（如刚刚介绍的），或者是一个复杂的unique_lock。比如说:</p><div class="code-wrapper"><pre><code class="hljs c++">{    <span class="hljs-function">std::scoped_lock <span class="hljs-title">sl</span><span class="hljs-params">(vMutex)</span></span>;    ... <span class="hljs-comment">// 对vector 的独占写读访问</span>}</code></pre></div><h4><span id="26-2-yuan-zi-de-is-always-lock-free">26.2 原子的 is_always_lock_free()</span><a href="#26-2-yuan-zi-de-is-always-lock-free" class="header-anchor">#</a></h4><p>你现在可以通过一个C++库的功能来检查一个特定的原子类型是否总是可以在没有锁的情况下使用不加锁。比如说：</p><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">if</span> <span class="hljs-title">constexpr</span><span class="hljs-params">(std::atomic&lt;<span class="hljs-type">int</span>&gt;::is_always_lock_free)</span> </span>{    ...}<span class="hljs-keyword">else</span> {    ...}</code></pre></div><p>如果该值为真，那么对于相应的原子类型的任何对象来说，is_lock_free()产生真:</p><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">if</span> <span class="hljs-title">constexpr</span><span class="hljs-params">(atomic&lt;T&gt;::is_always_lock_free)</span> </span>{    <span class="hljs-built_in">static_assert</span>(<span class="hljs-built_in">atomic</span>&lt;T&gt;().<span class="hljs-built_in">is_lock_free</span>()); <span class="hljs-comment">// 从未失败</span>}</code></pre></div><p>如果有的话，这个值与相应的宏的值相匹配，在C++17之前必须使用。<br>例如，如果且仅当ATOMIC_INT_LOCK_FREE产生2（代表 “总是”），那么std::atomic<int>::is_always_lock_free()产生true。:</int></p><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">if</span> <span class="hljs-title">constexpr</span><span class="hljs-params">(std::atomic&lt;<span class="hljs-type">int</span>&gt;::is_always_lock_free)</span> </span>{    <span class="hljs-comment">// ATOMIC_INT_LOCK_FREE == 2</span>    ...}<span class="hljs-keyword">else</span> {    <span class="hljs-comment">// ATOMIC_INT_LOCK_FREE == 0 || ATOMIC_INT_LOCK_FREE == 1</span>    ...}</code></pre></div><p>用静态成员代替宏的原因是为了有更多的类型安全，并支持在棘手的通用代码中使用这种检查（例如，使用SFINAE）。<br>请记住，std::atomic&lt;&gt;也可以用于琐碎的可复制类型。因此，你也可以检查，如果你自己的结构在原子上使用，是否需要锁。比如说：</p><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">auto</span> SZ&gt;<span class="hljs-keyword">struct</span> <span class="hljs-title class_">Data</span> {    <span class="hljs-type">bool</span> set;    <span class="hljs-type">int</span> values[SZ];    <span class="hljs-type">double</span> average;};<span class="hljs-function"><span class="hljs-keyword">if</span> <span class="hljs-title">constexpr</span><span class="hljs-params">(std::atomic&lt;Data&lt;<span class="hljs-number">4</span>&gt;&gt;::is_always_lock_free)</span> </span>{    ...}<span class="hljs-keyword">else</span> {    ...}</code></pre></div><h4><span id="26-3-huan-cun-xian-de-da-xiao">26.3 缓存线的大小</span><a href="#26-3-huan-cun-xian-de-da-xiao" class="header-anchor">#</a></h4><p>有时对于一个程序来说，处理缓存线的大小是很重要的。</p><ul><li>一方面，不同线程访问的不同对象不属于同一个缓存线，这对并发性很重要。否则，当不同的线程同时访问时，同样数量的内存必须在它们之间进行同步。</li><li>另一方面，你的目标可能是将多个对象放在同一个缓存线中，这样访问第一个对象就可以直接访问其他对象，而不是将它们加载到缓存中。</li></ul><p>为此，C++标准库在头文件<new>中引入了两个内联变量。</new></p><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">namespace</span> std {    <span class="hljs-keyword">inline</span> <span class="hljs-keyword">constexpr</span> <span class="hljs-type">size_t</span> hardware_destructive_interference_size;    <span class="hljs-keyword">inline</span> <span class="hljs-keyword">constexpr</span> <span class="hljs-type">size_t</span> hardware_constructive_interference_size;}</code></pre></div><p>这些对象有以下执行定义的值。</p><ul><li>hardware_destructive_interference_size是推荐的两个可能被不同线程同时访问的对象之间的最小偏移量，以避免因为同一L1缓存线受到影响而导致性能下降。</li><li>hardware_constructive_interference_size是推荐的两个对象放在同一L1缓存行内的最大连续内存大小。</li></ul><p>这两个值只是提示，因为理想的值可能取决于具体的架构。这些常数是编译器在处理生成的代码所支持的各种平台时所能提供的最佳值。所以，如果你知道的更多，请使用特定的值，但对于支持多种平台的代码来说，使用这些值比任何假定的固定尺寸要好。<br>这些值至少都是alignof(std::max_align_t)。通常情况下，值是相同的。然而，从语义上讲，它们代表了使用不同对象的不同目的，所以你应该使用它们 相应地使用它们，</p><p>如下所示: </p><ul><li>如果你想通过不同的线程访问两个不同的（原子）对象。<div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Data</span> {    <span class="hljs-built_in">alignas</span>(std::hardware_destructive_interference_size) <span class="hljs-type">int</span> valueForOneThread;    <span class="hljs-built_in">alignas</span>(std::hardware_destructive_interference_size) <span class="hljs-type">int</span> valueForAnotherThread;};</code></pre></div></li><li>如果你想通过同一个线程访问两个不同的（原子）对象。<div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Data</span> {    <span class="hljs-type">int</span> valueForOneThread;    <span class="hljs-type">int</span> valueForTheSameThread;};<span class="hljs-comment">// 仔细检查，由于共享缓存线，我们有最好的性能。</span><span class="hljs-built_in">static_assert</span>(<span class="hljs-built_in">sizeof</span>(Data) &lt;= std::hardware_constructive_interference_size);<span class="hljs-comment">// 确保对象被正确对齐。</span><span class="hljs-built_in">alignas</span>(<span class="hljs-built_in">sizeof</span>(Data)) Data myDataForAThread;</code></pre></div></li></ul><h4><span id="26-4-hou-ji">26.4 后记</span><a href="#26-4-hou-ji" class="header-anchor">#</a></h4><p>scoped_locks 最初是由 Mike Spertus 在 <a href="https://wg21.link/n4470">https://wg21.link/n4470</a> 中将 lock_guard 修改为可变参数，被接受为 <a href="https://wg21.link/p0156r0%E3%80%82%E7%84%B6%E8%80%8C%EF%BC%8C%E5%9B%A0%E4%B8%BA%E8%BF%99%E8%A2%AB%E8%AF%81%E6%98%8E%E6%98%AF">https://wg21.link/p0156r0。然而，因为这被证明是</a> ABI 破坏，新名称 scoped_lock 由 Mike Spertus 用 <a href="https://wg21.link/p0156r2">https://wg21.link/p0156r2</a> 引入并最终被接受。 Mike Spertus、Walter E. Brown 和 Stephan T. Lavavej 后来通过 <a href="https://wg21.link/p0739r0">https://wg21.link/p0739r0</a> 将构造函数的顺序更改为针对 C++17 的缺陷：</p><p>shared_mutex 最初是由 Howard Hinnant 在 <a href="https://wg21.link/n2406">https://wg21.link/n2406</a> 中与 C++11 的所有其他互斥体一起提出的。然而，要让 C++ 标准化委员会相信所有提议的互斥锁都是有用的，需要时间。因此，最终接受的措辞是由 Gor Nishanov 在 <a href="https://wg21.link/n4508">https://wg21.link/n4508</a> 中为 C++17 制定的。</p><p>std::atomic&lt;&gt; 静态成员 std::is_always_lock_free 由 Olivier Giroux、JF Bastien 和 Jeff Snyder 在 <a href="https://wg21.link/n4509">https://wg21.link/n4509</a> 中首次提出。最终接受的措辞也是由 Olivier Giroux、JF Bastien 和 Jeff Snyder 在 <a href="https://wg21.link/p0152r1">https://wg21.link/p0152r1</a> 中制定的。</p><p>JF Bastien 和 Olivier Giroux 在 <a href="https://wg21.link/n4523">https://wg21.link/n4523</a> 中首次提出了硬件干扰（缓存线）大小。最终接受的措辞也是由 JF Bastien 和 Olivier Giroux 在 <a href="https://wg21.link/p0154r1">https://wg21.link/p0154r1</a> 中制定的。</p>]]></content>
    
    
    
    <tags>
      
      <tag>C++17</tag>
      
      <tag>STL</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>第三部分-新的标准库组件</title>
    <link href="/2022/03/19/%E7%AC%AC%E4%B8%89%E9%83%A8%E5%88%86%20%E6%96%B0%E7%9A%84%E6%A0%87%E5%87%86%E5%BA%93%E7%BB%84%E4%BB%B6/"/>
    <url>/2022/03/19/%E7%AC%AC%E4%B8%89%E9%83%A8%E5%88%86%20%E6%96%B0%E7%9A%84%E6%A0%87%E5%87%86%E5%BA%93%E7%BB%84%E4%BB%B6/</url>
    
    <content type="html"><![CDATA[<h2><span id="di-san-bu-fen-xin-de-biao-zhun-ku-zu-jian">第三部分 新的标准库组件</span><a href="#di-san-bu-fen-xin-de-biao-zhun-ku-zu-jian" class="header-anchor">#</a></h2><p>本部分介绍了 C++17 的新库组件。</p><h3><span id="15-std-optional-lt-gt">15 std::optional&lt;&gt;</span><a href="#15-std-optional-lt-gt" class="header-anchor">#</a></h3><p>在编程中，我们经常遇到可能返回/传递/使用某种类型的对象的情况。也就是说，我们可以有一个特定类型的值，或者我们可能根本没有任何值。因此，我们需要一种模拟类似于指针的语义的方法，我们可以通过使用 nullptr 来表示没有值。处理这个问题的方法是定义一个特定类型的对象，带有一个额外的布尔成员/标志，表明一个值是否存在。 std::optional&lt;&gt; 以类型安全的方式提供此类对象。</p><p>可选对象仅具有包含对象的内部存储器以及布尔标志。因此，大小通常比包含的对象大一个字节。对于某些包含的类型，甚至可能根本没有大小开销，前提是可以将附加信息放置在包含的对象中。没有分配堆内存。对象使用与包含类型相同的对齐方式。</p><p>但是，可选对象不仅仅是将布尔标志的功能添加到值成员的结构。例如，如果没有值，则不会为包含的类型调用构造函数（因此，您可以为对象提供没有的默认状态）。</p><p>与 std::variant&lt;&gt; 和 std::any 一样，结果对象具有值语义。也就是说，复制被实现为深度复制，创建一个独立的对象，带有标志和包含的值（如果有的话）在它自己的内存中。复制没有包含值的 std::optional&lt;&gt; 很便宜；复制带有包含值的 std::optional&lt;&gt; 与复制包含的类型/值一样便宜/昂贵。支持移动语义。</p><h4><span id="15-1-shi-yong-std-optional-lt-gt">15.1 使用 std::optional&lt;&gt;</span><a href="#15-1-shi-yong-std-optional-lt-gt" class="header-anchor">#</a></h4><p>std::optional&lt;&gt;模型是一个任意类型的可忽略的实例。这个实例可能是一个成员，一个参数，或者一个返回值。你也可以说，std::optional&lt;&gt;是一个容纳零或一个元素的容器。</p><h5><span id="15-1-1-ke-xuan-de-fan-hui-zhi">15.1.1 可选的返回值</span><a href="#15-1-1-ke-xuan-de-fan-hui-zhi" class="header-anchor">#</a></h5><p>以下程序演示了 std::optional&lt;&gt; 用作返回值的能力：<br><code>lib/optional.cpp</code></p><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;optional&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><span class="hljs-comment">// 如果可能，将字符串转换为 int:</span><span class="hljs-function">std::optional&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">asInt</span><span class="hljs-params">(<span class="hljs-type">const</span> std::string&amp; s)</span></span><span class="hljs-function"></span>{    <span class="hljs-keyword">try</span> {        <span class="hljs-keyword">return</span> std::<span class="hljs-built_in">stoi</span>(s);    }    <span class="hljs-built_in">catch</span> (...) {        <span class="hljs-keyword">return</span> std::<span class="hljs-literal">nullopt</span>;    }}<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>{    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> s : {<span class="hljs-string">"42"</span>, <span class="hljs-string">" 077"</span>, <span class="hljs-string">"hello"</span>, <span class="hljs-string">"0x33"</span>} ) {        <span class="hljs-comment">// 如果可能，尝试将 s 转换为 int 并打印结果:</span>        std::optional&lt;<span class="hljs-type">int</span>&gt; oi = <span class="hljs-built_in">asInt</span>(s);        <span class="hljs-keyword">if</span> (oi) {            std::cout &lt;&lt; <span class="hljs-string">"convert '"</span> &lt;&lt; s &lt;&lt; <span class="hljs-string">"' to int: "</span> &lt;&lt; *oi &lt;&lt; <span class="hljs-string">"\n"</span>;        }        <span class="hljs-keyword">else</span> {            std::cout &lt;&lt; <span class="hljs-string">"can't convert '"</span> &lt;&lt; s &lt;&lt; <span class="hljs-string">"' to int\n"</span>;        }    }}</code></pre></div><p>在程序中 asInt() 是将传递的字符串转换为整数的函数。 但是，这可能不会成功。 出于这个原因，使用了 std::optional&lt;&gt; 以便我们可以返回”no int”并避免为其定义一个特殊的 int 值或向调用者抛出异常。<br>因此，我们要么返回调用 stoi() 的结果，它用一个 int 初始化返回值，要么我们返回 std::nullopt，表明我们没有一个 int 值。 我们可以实现如下相同的行为：</p><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-function">std::optional&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">asInt</span><span class="hljs-params">(<span class="hljs-type">const</span> std::string&amp; s)</span></span><span class="hljs-function"></span>{    std::optional&lt;<span class="hljs-type">int</span>&gt; ret; <span class="hljs-comment">// 最初没有值</span>    <span class="hljs-keyword">try</span> {        ret = std::<span class="hljs-built_in">stoi</span>(s);    }    <span class="hljs-built_in">catch</span> (...) {    }    <span class="hljs-keyword">return</span> ret;}</code></pre></div><p>在 main() 中，我们为不同的字符串调用此函数。</p><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> s : {<span class="hljs-string">"42"</span>, <span class="hljs-string">" 077"</span>, <span class="hljs-string">"hello"</span>, <span class="hljs-string">"0x33"</span>} ) {    <span class="hljs-comment">// 将 s 转换为 int 并尽可能使用结果:</span>    std::optional&lt;<span class="hljs-type">int</span>&gt; oi = <span class="hljs-built_in">asInt</span>(s);    ...}</code></pre></div><p>对于我们评估的每个返回的 std::optional<int> oi，我们是否有一个值（通过将对象评估为布尔表达式）并通过“取消引用”可选对象来访问该值：</int></p><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">if</span> (oi) {    std::cout &lt;&lt; <span class="hljs-string">"convert '"</span> &lt;&lt; s &lt;&lt; <span class="hljs-string">"' to int: "</span> &lt;&lt; *oi &lt;&lt; <span class="hljs-string">"\n"</span>;}</code></pre></div><p>请注意，对于字符串“0x33”，asInt() 产生 0，因为 stoi() 不会将字符串解析为十六进制值。<br>有其他方法可以实现对返回值的处理，例如：</p><div class="code-wrapper"><pre><code class="hljs c++">std::optional&lt;<span class="hljs-type">int</span>&gt; oi = <span class="hljs-built_in">asInt</span>(s);<span class="hljs-keyword">if</span> (oi.<span class="hljs-built_in">has_value</span>()) {    std::cout &lt;&lt; <span class="hljs-string">"convert '"</span> &lt;&lt; s &lt;&lt; <span class="hljs-string">"' to int: "</span> &lt;&lt; oi.<span class="hljs-built_in">value</span>() &lt;&lt; <span class="hljs-string">"\n"</span>;}</code></pre></div><p>在这里，has_value() 用于检查是否返回了一个值，并使用 value() 访问它。 value() 比 operator * 更安全：如果不存在值，它会抛出异常。 运算符 * 仅应在您确定可选项包含值时使用； 否则你的程序将有未定义的行为。<br>请注意，我们可以通过使用新类型 std::string_view 来改进 asInt()。</p><h5><span id="15-1-2-ke-xuan-can-shu-he-shu-ju-cheng-yuan">15.1.2 可选参数和数据成员</span><a href="#15-1-2-ke-xuan-can-shu-he-shu-ju-cheng-yuan" class="header-anchor">#</a></h5><p>另一个使用 std::optional&lt;&gt; 的例子是参数的可选传递 and/or 数据成员的可选设置：</p><p><code>lib/optionalmember.cpp</code></p><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;optional&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><span class="hljs-keyword">class</span> <span class="hljs-title class_">Name</span>{<span class="hljs-keyword">private</span>:    std::string first;    std::optional&lt;std::string&gt; middle;    std::string last;<span class="hljs-keyword">public</span>:    <span class="hljs-built_in">Name</span> (std::string f, std::optional&lt;std::string&gt; m, std::string l)        : first{std::<span class="hljs-built_in">move</span>(f)}, middle{std::<span class="hljs-built_in">move</span>(m)}, last{std::<span class="hljs-built_in">move</span>(l)}     {}    <span class="hljs-keyword">friend</span> std::ostream&amp; <span class="hljs-keyword">operator</span> &lt;&lt; (std::ostream&amp; strm, <span class="hljs-type">const</span> Name&amp; n) {        strm &lt;&lt; n.first &lt;&lt; <span class="hljs-string">' '</span>;        <span class="hljs-keyword">if</span> (n.middle) {            strm &lt;&lt; *n.middle &lt;&lt; <span class="hljs-string">' '</span>;        }        <span class="hljs-keyword">return</span> strm &lt;&lt; n.last;    }};<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>{    Name n{<span class="hljs-string">"Jim"</span>, std::<span class="hljs-literal">nullopt</span>, <span class="hljs-string">"Knopf"</span>};    std::cout &lt;&lt; n &lt;&lt; <span class="hljs-string">'\n'</span>;    Name m{<span class="hljs-string">"Donald"</span>, <span class="hljs-string">"Ervin"</span>, <span class="hljs-string">"Knuth"</span>};    std::cout &lt;&lt; m &lt;&lt; <span class="hljs-string">'\n'</span>;}</code></pre></div><p>类名表示由名字、可选的中间名和姓氏组成的名称。 成员 middle 被相应地定义，并且构造函数允许在没有中间名时传递 std::nullopt 。 这是与中间名是空字符串不同的状态。</p><p>请注意，与通常具有值语义的类型一样，定义初始化相应成员的构造函数的最佳方法是按值获取参数并将参数移动到成员：</p><p>还要注意 std::optional&lt;&gt; 改变了对成员中间值的访问。 使用 middle 作为布尔表达式会产生是否存在中间名，必须使用 *middle 来访问当前值（如果有）。</p><p>访问该值的另一个选项是使用成员函数 value_or()，它可以在不存在值的情况下指定一个备用值。 例如，在类 Name 中，我们还可以实现：</p><div class="code-wrapper"><pre><code class="hljs c++">std::cout &lt;&lt; middle.<span class="hljs-built_in">value_or</span>(<span class="hljs-string">""</span>); <span class="hljs-comment">// 打印中间名或什么都没有</span></code></pre></div><h4><span id="15-2-std-optional-lt-gt-lei-xing-he-cao-zuo">15.2 std::optional&lt;&gt; 类型和操作</span><a href="#15-2-std-optional-lt-gt-lei-xing-he-cao-zuo" class="header-anchor">#</a></h4><p>本节详细介绍 std::optional&lt;&gt; 的类型和操作。</p><h5><span id="15-2-1-std-optional-lt-gt-lei-xing">15.2.1 std::optional&lt;&gt; 类型</span><a href="#15-2-1-std-optional-lt-gt-lei-xing" class="header-anchor">#</a></h5><p>在头文件 <optional> 中，C++ 标准库定义类 std::optional&lt;&gt; 如下：</optional></p><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">namespace</span> std {    <span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt; <span class="hljs-keyword">class</span> <span class="hljs-title class_">optional</span>;}</code></pre></div><p>此外，还定义了以下类型和对象：</p><ul><li>std::nullopt_t 类型的 nullopt 作为没有值的可选对象的“值”。</li><li>异常类std::bad_optional_access，它派生自std::exception，用于没有值的值访问。</li></ul><p>可选对象还使用 <utility> 中定义的对象 std::in_place（std::in_place_t 类型）来初始化具有多个参数的可选对象的值（见下文）。</utility></p><h5><span id="15-2-2-std-optional-lt-gt-cao-zuo">15.2.2 std::optional&lt;&gt; 操作</span><a href="#15-2-2-std-optional-lt-gt-cao-zuo" class="header-anchor">#</a></h5><p>表 std::optional Operations 列出了为 std::optional&lt;&gt; 提供的所有操作。</p><h6><span id="jian-zao">建造</span><a href="#jian-zao" class="header-anchor">#</a></h6><p>特殊构造函数可以将参数直接传递给包含的类型。</p><ul><li><p>您可以创建一个没有值的可选对象。 在这种情况下，您必须指定包含的<br>类型：</p><div class="code-wrapper"><pre><code class="hljs c++">std::optional&lt;<span class="hljs-type">int</span>&gt; o1;<span class="hljs-function">std::optional&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">o2</span><span class="hljs-params">(std::<span class="hljs-literal">nullopt</span>)</span></span>;</code></pre></div><p>这不会调用包含类型的任何构造函数.</p></li><li><p>您可以传递一个值来初始化包含的类型。 由于推导指南，您不必指定包含的类型，然后：</p><div class="code-wrapper"><pre><code class="hljs c++">std::optional o3{<span class="hljs-number">42</span>}; <span class="hljs-comment">// 推导出optional&lt;int&gt;</span>std::optional&lt;std::string&gt; o4{<span class="hljs-string">"hello"</span>};std::optional o5{<span class="hljs-string">"hello"</span>}; <span class="hljs-comment">// 推导出 optional&lt;const char*&gt;</span></code></pre></div></li></ul><table><thead><tr><th>操作</th><th>作用</th></tr></thead><tbody><tr><td>constructors</td><td>创建一个可选对象（可能为包含的调用构造函数类型）</td></tr><tr><td>make_optional&lt;&gt;()</td><td>创建一个可选对象（传递值来初始化它）</td></tr><tr><td>destructor</td><td>销毁一个可选对象</td></tr><tr><td>=</td><td>分配一个新值</td></tr><tr><td>emplace()</td><td>为包含的类型分配一个新值</td></tr><tr><td>reset()</td><td>销毁任何值（使对象为空）</td></tr><tr><td>has_value()</td><td>返回对象是否有值</td></tr><tr><td>conversion to bool</td><td>返回对象是否有值</td></tr><tr><td>*</td><td>值访问（如果没有值，则为未定义行为）</td></tr><tr><td>-&gt;</td><td>访问值的成员（如果没有值，则行为未定义）</td></tr><tr><td>value()</td><td>值访问（如果没有值则例外）</td></tr><tr><td>value_or()</td><td>值访问（如果没有值，则为后备参数）</td></tr><tr><td>swap()</td><td>在两个对象之间交换值</td></tr><tr><td>==, !=, &lt;, &lt;=, &gt;, &gt;=</td><td>比较可选对象</td></tr><tr><td>hash&lt;&gt;</td><td>计算哈希值的函数对象类型</td></tr></tbody></table><ul><li><p>要使用多个参数初始化可选对象，您必须创建对象或添加 std::in_place 作为第一个参数（无法推断包含的类型）：</p><div class="code-wrapper"><pre><code class="hljs c++">std::optional o6{std::complex{<span class="hljs-number">3.0</span>, <span class="hljs-number">4.0</span>}};std::optional&lt;std::complex&lt;<span class="hljs-type">double</span>&gt;&gt; o7{std::in_place, <span class="hljs-number">3.0</span>, <span class="hljs-number">4.0</span>};</code></pre></div><p>请注意，后一种形式避免了创建临时对象。 通过使用这种形式，你甚至可以传递一个初始化列表和额外的参数：</p><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-comment">// 使用 lambda 作为排序标准初始化集合:</span><span class="hljs-keyword">auto</span> sc = [] (<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y) {    <span class="hljs-keyword">return</span> std::<span class="hljs-built_in">abs</span>(x) &lt; std::<span class="hljs-built_in">abs</span>(y);};std::optional&lt;std::set&lt;<span class="hljs-type">int</span>,<span class="hljs-keyword">decltype</span>(sc)&gt;&gt; o8{std::in_place,                                             {<span class="hljs-number">4</span>, <span class="hljs-number">8</span>, <span class="hljs-number">-7</span>, <span class="hljs-number">-2</span>, <span class="hljs-number">0</span>, <span class="hljs-number">5</span>},                                              sc                                            };</code></pre></div></li><li><p>您可以复制可选对象（包括类型转换）。</p><div class="code-wrapper"><pre><code class="hljs c++">std::optional o5{<span class="hljs-string">"hello"</span>}; <span class="hljs-comment">// 推导出 optional&lt;const char*&gt;</span>std::optional&lt;std::string&gt; o9{o5}; <span class="hljs-comment">// OK</span></code></pre></div></li></ul><p>请注意，还有一个便利函数 make_optional&lt;&gt;()，它允许使用单个或多个参数进行初始化（不需要 in_place 参数）。 像往常一样 make… 函数它会衰减：</p><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">auto</span> o10 = std::<span class="hljs-built_in">make_optional</span>(<span class="hljs-number">3.0</span>); <span class="hljs-comment">// optional&lt;double&gt;</span><span class="hljs-keyword">auto</span> o11 = std::<span class="hljs-built_in">make_optional</span>(<span class="hljs-string">"hello"</span>); <span class="hljs-comment">// optional&lt;const char*&gt;</span><span class="hljs-keyword">auto</span> o12 = std::make_optional&lt;std::complex&lt;<span class="hljs-type">double</span>&gt;&gt;(<span class="hljs-number">3.0</span>, <span class="hljs-number">4.0</span>);</code></pre></div><p>但是，请注意，没有构造函数获取值并根据其值来决定是使用值初始化可选项还是 nullopt。 为此，必须使用运算符 ?:。 例如：</p><div class="code-wrapper"><pre><code class="hljs c++">std::multimap&lt;std::string, std::string&gt; englishToGerman;...<span class="hljs-keyword">auto</span> pos = englishToGerman.<span class="hljs-built_in">find</span>(<span class="hljs-string">"wisdom"</span>);<span class="hljs-keyword">auto</span> o13 = pos != englishToGerman.<span class="hljs-built_in">end</span>()    ? std::optional{pos-&gt;second}: std::<span class="hljs-literal">nullopt</span>;</code></pre></div><p>在这里，由于 std::optional{pos-&gt;second} 的类模板参数推导，o13 被初始化为 std::optional<a href="std::string">std::string</a>。 对于 std::nullopt 类模板参数推导不起作用，但 operator ?: 在推导表达式的结果类型时也将其转换为这种类型。</p><h6><span id="fang-wen-zhi">访问值</span><a href="#fang-wen-zhi" class="header-anchor">#</a></h6><p>要检查可选对象是否具有值，您可以在布尔表达式中使用它或调用 has_value()：</p><div class="code-wrapper"><pre><code class="hljs c++">std::optional o{<span class="hljs-number">42</span>};<span class="hljs-keyword">if</span> (o) ... <span class="hljs-comment">// true</span><span class="hljs-keyword">if</span> (!o) ... <span class="hljs-comment">// false</span><span class="hljs-keyword">if</span> (o.<span class="hljs-built_in">has_value</span>()) ... <span class="hljs-comment">// true</span></code></pre></div><p>然后，为了访问该值，提供了一种指针语法。 也就是说，使用 operator* 您可以直接访问它的值，而 operator-&gt; 可以访问该值的成员：</p><div class="code-wrapper"><pre><code class="hljs c++">std::optional o{std::pair{<span class="hljs-number">42</span>, <span class="hljs-string">"hello"</span>}};<span class="hljs-keyword">auto</span> p = *o; <span class="hljs-comment">// 将 p 初始化为 pair&lt;int,string&gt;</span>std::cout &lt;&lt; o-&gt;first; <span class="hljs-comment">// prints 42</span></code></pre></div><p>请注意，这些运算符要求可选项包含一个值。 在没有值的情况下使用它们是未定义的行为：</p><div class="code-wrapper"><pre><code class="hljs c++">std::optional&lt;std::string&gt; o{<span class="hljs-string">"hello"</span>};std::cout &lt;&lt; *o; <span class="hljs-comment">// OK: prints ”hello”</span>o = std::<span class="hljs-literal">nullopt</span>;std::cout &lt;&lt; *o; <span class="hljs-comment">// 未定义的行为</span></code></pre></div><p>请注意，实际上第二个输出仍然会编译并执行一些输出，例如再次打印“hello”，因为可选对象的值的底层内存没有被修改。</p><p>但是，您不能也不应该依赖它。 如果您不知道可选对象是否有值，则必须调用以下代码：</p><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">if</span> (o) std::cout &lt;&lt; *o; <span class="hljs-comment">// OK (可能什么也不输出)</span></code></pre></div><p>或者，您可以使用 value()，如果没有包含值，则会引发 std::bad_optional_access 异常：</p><div class="code-wrapper"><pre><code class="hljs c++">std::cout &lt;&lt; o.<span class="hljs-built_in">value</span>(); <span class="hljs-comment">// OK (如果没有值则抛出)</span></code></pre></div><p>std::bad_optional_access 直接派生自 std::exception。</p><p>最后，您可以请求该值并传递一个备用值，如果可选对象没有值，则使用该值：</p><div class="code-wrapper"><pre><code class="hljs c++">std::cout &lt;&lt; o.<span class="hljs-built_in">value_or</span>(<span class="hljs-string">"fallback"</span>); <span class="hljs-comment">// OK (如果没有值则输出fallback)</span></code></pre></div><p>后备参数作为右值引用传递，因此如果不使用后备，它不会花费任何成本，并且如果使用它，它支持移动语义。<br>请注意，operator* 和 value() 都通过引用返回包含的对象。 因此，在直接调用这些操作以获取临时返回值时，您必须小心。 例如：</p><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-function">std::optional&lt;std::string&gt; <span class="hljs-title">getString</span><span class="hljs-params">()</span></span>;...;<span class="hljs-keyword">auto</span> a = <span class="hljs-built_in">getString</span>().<span class="hljs-built_in">value</span>(); <span class="hljs-comment">// OK: 包含对象的副本</span><span class="hljs-keyword">auto</span> b = *<span class="hljs-built_in">getString</span>(); <span class="hljs-comment">// ERROR: 如果 std::nullopt 的行为未定义</span><span class="hljs-type">const</span> <span class="hljs-keyword">auto</span>&amp; r1 = <span class="hljs-built_in">getString</span>().<span class="hljs-built_in">value</span>(); <span class="hljs-comment">// ERROR: 引用已删除的包含对象</span><span class="hljs-keyword">auto</span>&amp;&amp; r2 = <span class="hljs-built_in">getString</span>().<span class="hljs-built_in">value</span>(); <span class="hljs-comment">// ERROR: 引用已删除的包含对象</span></code></pre></div><p>一个示例可能是基于范围的 for 循环的以下用法：</p><div class="code-wrapper"><pre><code class="hljs c++">std::optional&lt;std::vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">getVector</span>();...;<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i : <span class="hljs-built_in">getVector</span>().<span class="hljs-built_in">value</span>()) { <span class="hljs-comment">// ERROR: 迭代已删除的vector</span>    std::cout &lt;&lt; i &lt;&lt; <span class="hljs-string">'\n'</span>;}</code></pre></div><p>请注意，迭代返回的 int 向量是可行的。 所以，不要盲目地将函数 foo() 的返回类型替换为相应的可选类型，而是调用 foo().value() 。</p><h6><span id="dui-bi">对比</span><a href="#dui-bi" class="header-anchor">#</a></h6><p>您可以使用通常的比较运算符。 操作数可以是可选对象，<br>包含类型和 std::nullopt。</p><ul><li>如果两个操作数都是具有值的对象，则使用包含类型的相应运算符。</li><li>如果两个操作数都是没有值的对象，则它们被认为是相等的（== 产生 true 并且<br>所有其他比较结果为假）。</li><li>如果只有一个操作数是具有值的对象，则认为没有值的操作数小于另一个操作数。</li></ul><p>例如：</p><div class="code-wrapper"><pre><code class="hljs c++">std::optional&lt;<span class="hljs-type">int</span>&gt; o0;std::optional&lt;<span class="hljs-type">int</span>&gt; o1{<span class="hljs-number">42</span>};<span class="hljs-comment">/*</span><span class="hljs-comment">o0 == std::nullopt // yields true</span><span class="hljs-comment">o0 == 42 // yields false</span><span class="hljs-comment">o0 &lt; 42 // yields true</span><span class="hljs-comment">o0 &gt; 42 // yields false</span><span class="hljs-comment">o1 == 42 // yields true</span><span class="hljs-comment">o0 &lt; o1 // yields true</span><span class="hljs-comment">*/</span></code></pre></div><p>这意味着对于 unsigned int 的可选对象，有一个小于 0 的值，对于 bool 的可选对象，有一个小于 0 的值：</p><div class="code-wrapper"><pre><code class="hljs c++">std::optional&lt;<span class="hljs-type">unsigned</span>&gt; uo;uo &lt; <span class="hljs-number">0</span> <span class="hljs-comment">// yields true</span>std::optional&lt;<span class="hljs-type">bool</span>&gt; bo;bo &lt; <span class="hljs-literal">false</span> <span class="hljs-comment">// yields true</span></code></pre></div><p>同样，支持底层类型的隐式类型转换：</p><div class="code-wrapper"><pre><code class="hljs c++">std::optional&lt;<span class="hljs-type">int</span>&gt; o1{<span class="hljs-number">42</span>};std::optional&lt;<span class="hljs-type">double</span>&gt; o2{<span class="hljs-number">42.0</span>};<span class="hljs-comment">/*</span><span class="hljs-comment">o2 == 42 // yields true</span><span class="hljs-comment">o1 == o2 // yields true</span><span class="hljs-comment">*/</span></code></pre></div><p>请注意，可选的布尔值或原始指针值可能会导致一些意外。</p><h6><span id="geng-gai-zhi">更改值</span><a href="#geng-gai-zhi" class="header-anchor">#</a></h6><p>赋值和 emplace() 操作对应于初始化存在：</p><div class="code-wrapper"><pre><code class="hljs c++">std::optional&lt;std::complex&lt;<span class="hljs-type">double</span>&gt;&gt; o; <span class="hljs-comment">// 没有值</span>std::optional ox{<span class="hljs-number">77</span>}; <span class="hljs-comment">// optional&lt;int&gt; with value 77</span>o = <span class="hljs-number">42</span>; <span class="hljs-comment">// 值变为 complex(42.0, 0.0)</span>o = {<span class="hljs-number">9.9</span>, <span class="hljs-number">4.4</span>}; <span class="hljs-comment">// 值变为 complex(9.9, 4.4)</span>o = ox; <span class="hljs-comment">// OK, 因为 int 转换为 complex&lt;double&gt;</span>o = std::<span class="hljs-literal">nullopt</span>; <span class="hljs-comment">// o 不再具有值</span>o.<span class="hljs-built_in">emplace</span>(<span class="hljs-number">5.5</span>, <span class="hljs-number">7.7</span>); <span class="hljs-comment">// 值变为 complex(5.5, 7.7)</span></code></pre></div><p>分配 std::nullopt 会删除该值，如果之前有值，则调用包含类型的析构函数。 您可以通过调用 reset() 来获得相同的效果：</p><div class="code-wrapper"><pre><code class="hljs c++">o.<span class="hljs-built_in">reset</span>(); <span class="hljs-comment">// o 不再具有值</span></code></pre></div><p>或分配空花括号：</p><div class="code-wrapper"><pre><code class="hljs c++">o = {}; <span class="hljs-comment">// o 不再具有值</span></code></pre></div><p>最后，我们还可以使用 operator* 来修改值，因为它通过引用产生值。<br>但是，请注意，这需要有一个值要修改：</p><div class="code-wrapper"><pre><code class="hljs c++">std::optional&lt;std::complex&lt;<span class="hljs-type">double</span>&gt;&gt; o;*o = <span class="hljs-number">42</span>; <span class="hljs-comment">// 未定义的行为</span>...;<span class="hljs-keyword">if</span> (o) {    *o = <span class="hljs-number">88</span>; <span class="hljs-comment">// OK: 值变为 complex(88.0, 0.0)</span>    *o = {<span class="hljs-number">1.2</span>, <span class="hljs-number">3.4</span>}; <span class="hljs-comment">// OK: 值变为 complex(1.2, 3.4)</span>}</code></pre></div><h6><span id="yi-dong-yu-yi">移动语义</span><a href="#yi-dong-yu-yi" class="header-anchor">#</a></h6><p>std::optional&lt;&gt; 也支持移动语义。 如果将对象作为一个整体移动，则将复制状态并移动包含的对象（如果有）。 结果，移出的对象仍然具有相同的状态，但任何值都未指定。</p><p>​    但是您也可以将值移入或移出包含的对象。 例如：</p><div class="code-wrapper"><pre><code class="hljs c++">std::optional&lt;std::string&gt; os;std::string s = <span class="hljs-string">"a very very very long string"</span>;os = std::<span class="hljs-built_in">move</span>(s); <span class="hljs-comment">// OK, 移动</span>std::string s2 = *os; <span class="hljs-comment">// OK 拷贝</span>std::string s3 = std::<span class="hljs-built_in">move</span>(*os); <span class="hljs-comment">// OK, 移动</span></code></pre></div><p>请注意，在最后一次调用之后 os 仍然有一个字符串值，但对于已移动的对象，该值通常是未指定的。 因此，只要您不对它的值做任何假设，您就可以使用它。 您甚至可以在那里分配一个新的字符串值。</p><h6><span id="san-lie">散列</span><a href="#san-lie" class="header-anchor">#</a></h6><p>可选对象的哈希值是包含的非常量类型（如果有）的哈希值。</p><h4><span id="15-3-te-shu-qing-kuang">15.3 特殊情况</span><a href="#15-3-te-shu-qing-kuang" class="header-anchor">#</a></h4><p>特定的可选值类型可能会导致特殊或意外行为。</p><h5><span id="15-3-1-ke-xuan-de-bu-er-zhi-huo-yuan-shi-zhi-zhen-zhi">15.3.1 可选的布尔值或原始指针值</span><a href="#15-3-1-ke-xuan-de-bu-er-zhi-huo-yuan-shi-zhi-zhen-zhi" class="header-anchor">#</a></h5><p>请注意，使用比较运算符与使用可选对象作为布尔值具有不同的语义。 如果包含的类型是 bool 或指针类型，这可能会变得令人困惑：例如：</p><div class="code-wrapper"><pre><code class="hljs c++">std::optional&lt;<span class="hljs-type">bool</span>&gt; ob{<span class="hljs-literal">false</span>}; <span class="hljs-comment">// 有值，为假</span><span class="hljs-keyword">if</span> (!ob) ... <span class="hljs-comment">// 产生错误</span><span class="hljs-keyword">if</span> (ob == <span class="hljs-literal">false</span>) ... <span class="hljs-comment">// yields true</span>std::optional&lt;<span class="hljs-type">int</span>*&gt; op{<span class="hljs-literal">nullptr</span>};<span class="hljs-keyword">if</span> (!op) ... <span class="hljs-comment">// yields false</span><span class="hljs-keyword">if</span> (op == <span class="hljs-literal">nullptr</span>) ... <span class="hljs-comment">// yields true</span></code></pre></div><h5><span id="15-3-2-optional-de-optional">15.3.2 Optional 的 Optional</span><a href="#15-3-2-optional-de-optional" class="header-anchor">#</a></h5><p>原则上，您还可以定义可选值的可选：</p><div class="code-wrapper"><pre><code class="hljs c++">std::optional&lt;std::optional&lt;std::string&gt;&gt; oos1;std::optional&lt;std::optional&lt;std::string&gt;&gt; oos2 = <span class="hljs-string">"hello"</span>;std::optional&lt;std::optional&lt;std::string&gt;&gt;    oos3{std::in_place, std::in_place, <span class="hljs-string">"hello"</span>};std::optional&lt;std::optional&lt;std::complex&lt;<span class="hljs-type">double</span>&gt;&gt;&gt;    ooc{std::in_place, std::in_place, <span class="hljs-number">4.2</span>, <span class="hljs-number">5.3</span>};</code></pre></div><p>即使使用隐式转换，您也可以分配新值：</p><div class="code-wrapper"><pre><code class="hljs c++">oos1 = <span class="hljs-string">"hello"</span>; <span class="hljs-comment">// OK: 分配新值</span>ooc.<span class="hljs-built_in">emplace</span>(std::in_place, <span class="hljs-number">7.2</span>, <span class="hljs-number">8.3</span>);</code></pre></div><p>由于没有值的两个层次，可选的可选使得在外部或内部具有“无值”，这可以具有不同的语义含义：</p><div class="code-wrapper"><pre><code class="hljs c++">*oos1 = std::<span class="hljs-literal">nullopt</span>; <span class="hljs-comment">// 内部可选没有值</span>oos1 = std::<span class="hljs-literal">nullopt</span>; <span class="hljs-comment">// 外部可选没有值</span></code></pre></div><p>但是您必须特别注意处理可选值：</p><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">if</span> (!oos1) std::cout &lt;&lt; <span class="hljs-string">"no value\n"</span>;<span class="hljs-keyword">if</span> (oos1 &amp;&amp; !*oos1) std::cout &lt;&lt; <span class="hljs-string">"no inner value\n"</span>;<span class="hljs-keyword">if</span> (oos1 &amp;&amp; *oos1) std::cout &lt;&lt; <span class="hljs-string">"value: "</span> &lt;&lt; **oos1 &lt;&lt; <span class="hljs-string">'\n'</span>;</code></pre></div><p>但是，因为这在语义上更像是一个具有两个不同状态的值，表示没有值，所以具有两个布尔或单态替代方案的 std::variant&lt;&gt; 可能更合适。</p><h4><span id="15-4-hou-ji">15.4 后记</span><a href="#15-4-hou-ji" class="header-anchor">#</a></h4><p>可选对象于 2005 年由 Fernando Cacciola 在 <a href="https://wg21.link/n1878">https://wg21.link/n1878</a> 中首次提出，将 Boost.Optional 作为参考实现。 正如 Fernando Cacciola 和 Andrzej Krzemienski 在 <a href="https://wg21.link/n3793">https://wg21.link/n3793</a> 中提出的，该课程被采纳为图书馆基础知识 TS 的一部分。</p><p>正如 Beman Dawes 和 Alisdair Meredith 在 <a href="https://wg21.link/p0220r1">https://wg21.link/p0220r1</a> 中提出的，该类与 C++17 的其他组件一起采用。</p><p>Tony van Eerd 使用 <a href="https://wg21.link/n3765">https://wg21.link/n3765</a> 和 <a href="https://wg21.link/p0307r2">https://wg21.link/p0307r2</a> 显着改进了比较运算符的语义。 Vicente J. Botet Escriba 将 API 与 std::variant&lt;&gt; 和 std::any 与 <a href="https://wg21.link/p0032r3">https://wg21.link/p0032r3</a> 进行了协调。 Jonathan Wakely 使用 <a href="https://wg21.link/p0504r0">https://wg21.link/p0504r0</a> 修复了 in_place 标记类型的行为。</p><h3><span id="16-std-variant-lt-gt">16 std::variant&lt;&gt;</span><a href="#16-std-variant-lt-gt" class="header-anchor">#</a></h3><p>借助 std::variant&lt;&gt;，C++ 标准库提供了一个新的联合类，其中包括支持多态性和处理非同质集合的新方法。 也就是说，它允许我们处理不同数据类型的元素，而无需公共基类和指针（原始或智能）。</p><h4><span id="16-1-std-variant-lt-gt-de-shi-ji">16.1 std::variant&lt;&gt; 的时机</span><a href="#16-1-std-variant-lt-gt-de-shi-ji" class="header-anchor">#</a></h4><p>从 C 中采用，C++ 提供对联合的支持，联合是能够保存可能类型列表之一的对象。但是，此语言功能存在一些缺点：</p><ul><li>对象不知道它们当前持有哪种类型的值。</li><li>出于这个原因，您不能拥有非平凡的成员，例如 std::string （无需特别努力）。</li><li>你不能从工会派生。<br>使用 std::variant&lt;&gt;，C++ 标准库提供了一个封闭的可区分联合（这意味着有一个指定的可能类型列表，您可以指定您的意思），其中</li><li>当前值的类型总是已知的，</li><li>可以有任何指定类型的成员，并且</li><li>你可以从中得到。<br>事实上，一个 std::variant&lt;&gt; 保存着各种选择的值，这些选择通常有不同的类型。但是两个替代也可以具有相同的类型，如果具有不同语义含义的替代具有相同的类型，这很有用（例如，持有两个字符串，它们代表不同的数据库列，以便您仍然知道该值代表哪些列） .</li></ul><p>变体只是具有用于基础类型的最大大小的内部存储器以及一些固定的开销来管理使用哪个替代方案。 没有分配堆内存。</p><p>一般来说，变量不能为空，除非您使用特定的替代信号来表示空虚。 但是，在极少数情况下（例如由于在分配不同的新值期间出现异常）<br>type) 变体可以进入一个没有任何价值的状态。</p><p>与 std::optional&lt;&gt; 和 std::any 一样，结果对象具有值语义。 通过在自己的内存中创建一个具有当前替代项的当前值的独立对象来进行深度复制。 因此，复制 std::variant&lt;&gt; 与复制当前替代的 type/value 一样便宜/昂贵。 支持移动语义。</p><h4><span id="16-2-shi-yong-std-variant-lt-gt">16.2 使用 std::variant&lt;&gt;</span><a href="#16-2-shi-yong-std-variant-lt-gt" class="header-anchor">#</a></h4><p>以下示例演示了 std::variant&lt;&gt; 的核心功能：</p><p><code>lib/variant.cpp </code></p><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;variant&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>{    std::variant&lt;<span class="hljs-type">int</span>, std::string&gt; var{<span class="hljs-string">"hi"</span>}; <span class="hljs-comment">// 用字符串替代初始化</span>    std::cout &lt;&lt; var.<span class="hljs-built_in">index</span>() &lt;&lt; <span class="hljs-string">'\n'</span>; <span class="hljs-comment">// prints 1</span>    var = <span class="hljs-number">42</span>; <span class="hljs-comment">// 现在持有 int 替代品</span>    std::cout &lt;&lt; var.<span class="hljs-built_in">index</span>() &lt;&lt; <span class="hljs-string">'\n'</span>; <span class="hljs-comment">// prints 0</span>    ...;    <span class="hljs-keyword">try</span> {        <span class="hljs-type">int</span> i = std::<span class="hljs-built_in">get</span>&lt;<span class="hljs-number">0</span>&gt;(var); <span class="hljs-comment">// 按索引访问</span>        std::string s = std::<span class="hljs-built_in">get</span>&lt;std::string&gt;(var); <span class="hljs-comment">// 按类型访问（在这种情况下抛出异常）</span>        ...;    }    <span class="hljs-built_in">catch</span> (<span class="hljs-type">const</span> std::bad_variant_access&amp; e) { <span class="hljs-comment">// 如果使用了错误的type/index</span>        std::cerr &lt;&lt; <span class="hljs-string">"EXCEPTION: "</span> &lt;&lt; e.<span class="hljs-built_in">what</span>() &lt;&lt; <span class="hljs-string">'\n'</span>;        ...;    }}</code></pre></div><p>成员函数 index() 可用于找出当前设置了哪个备选方案（第一个备选方案的索引为 0）。</p><p>初始化和赋值总是使用最佳匹配来找出新的替代方案。 如果类型不完全适合，可能会出现意外。</p><p>请注意，不允许使用空变体、具有引用成员的变体、具有 C 样式数组成员的变体以及具有不完整类型（例如 void）的变体。</p><p>没有空状态。 这意味着对于每个构造对象，必须调用至少一个构造函数。 默认构造函数使用默认构造函数初始化第一个类型：</p><div class="code-wrapper"><pre><code class="hljs c++">std::variant&lt;std::string, <span class="hljs-type">int</span>&gt; var; <span class="hljs-comment">// =&gt; var.index() == 0, value == ””</span></code></pre></div><p>如果没有为第一种类型定义默认构造函数，则调用变体的默认构造函数是编译时错误：</p><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">NoDefConstr</span> {    <span class="hljs-built_in">NoDefConstr</span>(<span class="hljs-type">int</span> i) {        std::cout &lt;&lt; <span class="hljs-string">"NoDefConstr::NoDefConstr(int) called\n"</span>;    }};std::variant&lt;NoDefConstr, <span class="hljs-type">int</span>&gt; v1; <span class="hljs-comment">// ERROR: 不能默认构造第一类型</span></code></pre></div><p>辅助类型 std::monostate 提供了处理这种情况的能力，也提供了模拟空状态的能力。</p><h6><span id="std-monostate">std::monostate</span><a href="#std-monostate" class="header-anchor">#</a></h6><p>为了支持第一种类型没有默认构造函数的变体，提供了一个特殊的辅助类型：std::monostate。 std::monostate 类型的对象始终具有相同的状态。 因此，它们总是比较相等。 他们自己的目的是表示一个替代类型，以便该变体没有任何其他类型的值。</p><p>也就是说，struct std::monostate 可以作为第一个替代类型，以使变体类型默认可构造。 例如：</p><div class="code-wrapper"><pre><code class="hljs c++">std::variant&lt;std::monostate, NoDefConstr&gt; v2; <span class="hljs-comment">// OK</span>std::cout &lt;&lt; <span class="hljs-string">"index: "</span> &lt;&lt; v2.<span class="hljs-built_in">index</span>() &lt;&lt; <span class="hljs-string">'\n'</span>; <span class="hljs-comment">// prints 0</span></code></pre></div><p>在某种程度上，您可以将状态解释为表示空虚。 有多种方法可以检查单态，这也演示了其他一些操作，您可以调用变体：</p><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">if</span> (v2.<span class="hljs-built_in">index</span>() == <span class="hljs-number">0</span>) {    std::cout &lt;&lt; <span class="hljs-string">"has monostate\n"</span>;}<span class="hljs-keyword">if</span> (!v2.<span class="hljs-built_in">index</span>()) {    std::cout &lt;&lt; <span class="hljs-string">"has monostate\n"</span>;}<span class="hljs-keyword">if</span> (std::<span class="hljs-built_in">holds_alternative</span>&lt;std::monostate&gt;(v2)) {    std::cout &lt;&lt; <span class="hljs-string">"has monostate\n"</span>;}<span class="hljs-keyword">if</span> (std::<span class="hljs-built_in">get_if</span>&lt;<span class="hljs-number">0</span>&gt;(&amp;v2)) {    std::cout &lt;&lt; <span class="hljs-string">"has monostate\n"</span>;}<span class="hljs-keyword">if</span> (std::<span class="hljs-built_in">get_if</span>&lt;std::monostate&gt;(&amp;v2)) {    std::cout &lt;&lt; <span class="hljs-string">"has monostate\n"</span>;}</code></pre></div><p>get_if&lt;&gt;() 使用指向变体的指针，如果当前备选方案是 T，则返回指向当前备选方案的指针。否则返回 nullptr。 这与 get<t>() 不同，get<t>() 采用对变体的引用，如果提供的类型正确，则按值返回当前替代项，否则抛出。</t></t></p><p>像往常一样，您可以分配另一个替代的值，甚至分配单态，再次表示空虚：</p><div class="code-wrapper"><pre><code class="hljs c++">v2 = <span class="hljs-number">42</span>;std::cout &lt;&lt; <span class="hljs-string">"index: "</span> &lt;&lt; v2.<span class="hljs-built_in">index</span>() &lt;&lt; <span class="hljs-string">'\n'</span>; <span class="hljs-comment">// index: 1</span>v2 = std::monostate{};std::cout &lt;&lt; <span class="hljs-string">"index: "</span> &lt;&lt; v2.<span class="hljs-built_in">index</span>() &lt;&lt; <span class="hljs-string">'\n'</span>; <span class="hljs-comment">// index: 0</span></code></pre></div><h6><span id="cong-bian-ti-pai-sheng">从变体派生</span><a href="#cong-bian-ti-pai-sheng" class="header-anchor">#</a></h6><p>您可以从 std::variant 派生。 例如，您可以定义从 std::variant&lt;&gt; 派生的聚合，如下所示：</p><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Derived</span> : <span class="hljs-keyword">public</span> std::variant&lt;<span class="hljs-type">int</span>, std::string&gt; {};Derived d = {{<span class="hljs-string">"hello"</span>}};std::cout &lt;&lt; d.<span class="hljs-built_in">index</span>() &lt;&lt; <span class="hljs-string">'\n'</span>; <span class="hljs-comment">// prints: 1</span>std::cout &lt;&lt; std::<span class="hljs-built_in">get</span>&lt;<span class="hljs-number">1</span>&gt;(d) &lt;&lt; <span class="hljs-string">'\n'</span>; <span class="hljs-comment">// prints: hello</span>d.<span class="hljs-built_in">emplace</span>&lt;<span class="hljs-number">0</span>&gt;(<span class="hljs-number">77</span>); <span class="hljs-comment">// 初始化 int，销毁字符串</span>std::cout &lt;&lt; std::<span class="hljs-built_in">get</span>&lt;<span class="hljs-number">0</span>&gt;(d) &lt;&lt; <span class="hljs-string">'\n'</span>; <span class="hljs-comment">// prints: 77</span></code></pre></div><h4><span id="16-3-std-variant-lt-gt-lei-xing-he-cao-zuo">16.3 std::variant&lt;&gt; 类型和操作</span><a href="#16-3-std-variant-lt-gt-lei-xing-he-cao-zuo" class="header-anchor">#</a></h4><p>本节详细介绍 std::variant&lt;&gt; 的类型和操作。</p><h5><span id="16-3-1-std-variant-lt-gt-lei-xing">16.3.1 std::variant&lt;&gt; 类型</span><a href="#16-3-1-std-variant-lt-gt-lei-xing" class="header-anchor">#</a></h5><p>在头文件 <variant> 中，C++ 标准库定义类 std::variant&lt;&gt; 如下：</variant></p><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">namespace</span> std {    <span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> Types...&gt; <span class="hljs-keyword">class</span> <span class="hljs-title class_">variant</span>;}</code></pre></div><p>也就是说，std::variant&lt;&gt; 是一个可变参数类模板（C++11 引入的一个特性，允许处理任意数量的类型）。<br>此外，还定义了以下类型和对象：</p><ul><li><p>类型 std::variant_size</p></li><li><p>类型 std::variant_alternative</p></li><li><p>值 std::variant_npos</p></li><li><p>类型 std::monostate</p></li><li><p>异常类 std::bad_variant_access，派生自 std::exception。</p></li></ul><p>变体还使用在 utility&gt; 中定义的两个对象 std::in_place_type（std::in_place_type_t 类型）和 std::in_place_index（std::in_place_index_t 类型）。</p><h5><span id="16-3-2-std-variant-lt-gt-cao-zuo">16.3.2 std::variant&lt;&gt; 操作</span><a href="#16-3-2-std-variant-lt-gt-cao-zuo" class="header-anchor">#</a></h5><p>表 std::variant Operations 列出了为 std::variant&lt;&gt; 提供的所有操作.</p><h6><span id="gou-zao">构造</span><a href="#gou-zao" class="header-anchor">#</a></h6><p>默认情况下，变体的默认构造函数调用第一个替代的默认构造函数：</p><div class="code-wrapper"><pre><code class="hljs c++">std::variant&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>, std::string&gt; v1; <span class="hljs-comment">// 将第一个 int 设置为 0，index()==0</span></code></pre></div><p>另一种方法是值初始化，这意味着对于基本类型，它是 0、false 或 nullptr。<br>如果为初始化传递了一个值，则使用最佳匹配类型：</p><div class="code-wrapper"><pre><code class="hljs c++">std::variant&lt;<span class="hljs-type">long</span>, <span class="hljs-type">int</span>&gt; v2{<span class="hljs-number">42</span>};std::cout &lt;&lt; v2.<span class="hljs-built_in">index</span>() &lt;&lt; <span class="hljs-string">'\n'</span>; <span class="hljs-comment">// prints 1</span></code></pre></div><p>但是，如果两种类型匹配得一样好，则调用是模棱两可的：</p><div class="code-wrapper"><pre><code class="hljs c++">std::variant&lt;<span class="hljs-type">long</span>, <span class="hljs-type">long</span>&gt; v3{<span class="hljs-number">42</span>}; <span class="hljs-comment">// ERROR: 模糊的</span>std::variant&lt;<span class="hljs-type">int</span>, <span class="hljs-type">float</span>&gt; v4{<span class="hljs-number">42.3</span>}; <span class="hljs-comment">// ERROR: 模糊的</span>std::variant&lt;<span class="hljs-type">int</span>, <span class="hljs-type">double</span>&gt; v5{<span class="hljs-number">42.3</span>}; <span class="hljs-comment">// OK</span>std::variant&lt;<span class="hljs-type">int</span>, <span class="hljs-type">long</span> <span class="hljs-type">double</span>&gt; v6{<span class="hljs-number">42.3</span>}; <span class="hljs-comment">// ERROR: 模糊的</span>std::variant&lt;std::string, std::string_view&gt; v7{<span class="hljs-string">"hello"</span>}; <span class="hljs-comment">// ERROR: 模糊的</span>std::variant&lt;std::string, std::string_view, <span class="hljs-type">const</span> <span class="hljs-type">char</span>*&gt; v8{<span class="hljs-string">"hello"</span>}; <span class="hljs-comment">// OK</span>std::cout &lt;&lt; v8.<span class="hljs-built_in">index</span>() &lt;&lt; <span class="hljs-string">'\n'</span>; <span class="hljs-comment">// prints 2</span></code></pre></div><table><thead><tr><th>操作</th><th>作用</th></tr></thead><tbody><tr><td>constructors</td><td>创建一个变体对象（可能调用底层类型的构造函数）</td></tr><tr><td>destructor</td><td>销毁一个变体对象</td></tr><tr><td>=</td><td>分配一个新值</td></tr><tr><td>emplace<t>()</t></td><td>为具有类型 T 的替代项分配一个新值</td></tr><tr><td>emplace<idx>()</idx></td><td>为索引 Idx 的替代项分配一个新值</td></tr><tr><td>valueless_by_exception()</td><td>返回变量是否由于异常而没有值</td></tr><tr><td>index()</td><td>返回当前替代的索引</td></tr><tr><td>swap()</td><td>在两个对象之间交换值</td></tr><tr><td>==, !=, &lt;, &lt;=, &gt;, &gt;=</td><td>比较不同的对象</td></tr><tr><td>hash&lt;&gt;</td><td>计算哈希值的函数对象类型</td></tr><tr><td>holds_alternative<t>()</t></td><td>返回是否有类型 T 的值</td></tr><tr><td>get<t>()</t></td><td>返回类型为 T 或 throws 的替代项的值</td></tr><tr><td>ge<idx>t()</idx></td><td>返回具有索引 Idx 或 throws 的替代项的值</td></tr><tr><td>get_if<t>()</t></td><td>返回指向 T 或 nullptr 类型的替代值的指针</td></tr><tr><td>get_if<idx>()</idx></td><td>返回指向具有索引 Idx 或 nullptr 的替代项的值的指针</td></tr><tr><td>visit()</td><td>对当前备选方案执行操作</td></tr></tbody></table><p>要为初始化传递多个值，您必须使用 in_place_type 或 in_place_index 标签：</p><div class="code-wrapper"><pre><code class="hljs c++">std::variant&lt;std::complex&lt;<span class="hljs-type">double</span>&gt;&gt; v9{<span class="hljs-number">3.0</span>, <span class="hljs-number">4.0</span>}; <span class="hljs-comment">// ERROR</span>std::variant&lt;std::complex&lt;<span class="hljs-type">double</span>&gt;&gt; v10{{<span class="hljs-number">3.0</span>, <span class="hljs-number">4.0</span>}}; <span class="hljs-comment">// ERROR</span>std::variant&lt;std::complex&lt;<span class="hljs-type">double</span>&gt;&gt; v11{std::in_place_type&lt;std::complex&lt;<span class="hljs-type">double</span>&gt;&gt;,                                       <span class="hljs-number">3.0</span>, <span class="hljs-number">4.0</span>};std::variant&lt;std::complex&lt;<span class="hljs-type">double</span>&gt;&gt; v12{std::in_place_index&lt;<span class="hljs-number">0</span>&gt;, <span class="hljs-number">3.0</span>, <span class="hljs-number">4.0</span>};</code></pre></div><p>您还可以在初始化期间使用 in_place_index 标记来解决歧义或否决优先级：</p><div class="code-wrapper"><pre><code class="hljs c++">std::variant&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt; v13{std::in_place_index&lt;<span class="hljs-number">1</span>&gt;, <span class="hljs-number">77</span>}; <span class="hljs-comment">// 初始化第二个 int</span>std::variant&lt;<span class="hljs-type">int</span>, <span class="hljs-type">long</span>&gt; v14{std::in_place_index&lt;<span class="hljs-number">1</span>&gt;, <span class="hljs-number">77</span>}; <span class="hljs-comment">// 初始化长，而不是 int</span>std::cout &lt;&lt; v14.<span class="hljs-built_in">index</span>() &lt;&lt; <span class="hljs-string">'\n'</span>; <span class="hljs-comment">// prints 1</span></code></pre></div><p>你甚至可以传递一个初始化列表，后跟其他参数：</p><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-comment">// initialize variant with a set with lambda as sorting criterion:</span><span class="hljs-keyword">auto</span> sc = [] (<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y) {    <span class="hljs-keyword">return</span> std::<span class="hljs-built_in">abs</span>(x) &lt; std::<span class="hljs-built_in">abs</span>(y);};std::variant&lt;std::vector&lt;<span class="hljs-type">int</span>&gt;, std::set&lt;<span class="hljs-type">int</span>,<span class="hljs-keyword">decltype</span>(sc)&gt;&gt; v15{std::in_place_index&lt;<span class="hljs-number">1</span>&gt;,                                                               {<span class="hljs-number">4</span>, <span class="hljs-number">8</span>, <span class="hljs-number">-7</span>, <span class="hljs-number">-2</span>, <span class="hljs-number">0</span>, <span class="hljs-number">5</span>},                                                               sc                                                              };</code></pre></div><p>你不能对 std::variant&lt;&gt; 使用类模板参数推导。 并且没有 make_variant&lt;&gt;() 便利函数（与 std::optional&lt;&gt; 和 std::any 不同）。 两者都没有意义，因为变体的整个目标是处理多种选择。</p><h6><span id="fang-wen-zhi">访问值</span><a href="#fang-wen-zhi" class="header-anchor">#</a></h6><p>访问该值的常用方法是调用 get&lt;&gt;() 以获得相应的替代方法。 您可以传递它的索引，或者，如果一个类型不被多次使用，它的类型。 例如：</p><div class="code-wrapper"><pre><code class="hljs c++">std::variant&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>, std::string&gt; var; <span class="hljs-comment">// 将第一个 int 设置为 0，index()==0</span><span class="hljs-keyword">auto</span> a = std::<span class="hljs-built_in">get</span>&lt;<span class="hljs-type">double</span>&gt;(var); <span class="hljs-comment">// compile-time 错误：没有双精度</span><span class="hljs-keyword">auto</span> b = std::<span class="hljs-built_in">get</span>&lt;<span class="hljs-number">4</span>&gt;(var); <span class="hljs-comment">// compile-time 错误: 没有第四选择</span><span class="hljs-keyword">auto</span> c = std::<span class="hljs-built_in">get</span>&lt;<span class="hljs-type">int</span>&gt;(var); <span class="hljs-comment">// compile-time 错误: int 两次</span><span class="hljs-keyword">try</span> {    <span class="hljs-keyword">auto</span> s = std::<span class="hljs-built_in">get</span>&lt;std::string&gt;(var); <span class="hljs-comment">// 抛出异常（当前设置的第一个 int）</span>    <span class="hljs-keyword">auto</span> i = std::<span class="hljs-built_in">get</span>&lt;<span class="hljs-number">0</span>&gt;(var); <span class="hljs-comment">// OK, i==0</span>    <span class="hljs-keyword">auto</span> j = std::<span class="hljs-built_in">get</span>&lt;<span class="hljs-number">1</span>&gt;(var); <span class="hljs-comment">// 抛出异常（当前设置的其他 int）</span>}<span class="hljs-built_in">catch</span> (<span class="hljs-type">const</span> std::bad_variant_access&amp; e) { <span class="hljs-comment">// 在无效访问的情况下</span>    std::cout &lt;&lt; <span class="hljs-string">"Exception: "</span> &lt;&lt; e.<span class="hljs-built_in">what</span>() &lt;&lt; <span class="hljs-string">'\n'</span>;}</code></pre></div><p>还有一个 API 可以通过选项检查它是否存在来访问该值：</p><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">if</span> (<span class="hljs-keyword">auto</span> ip = std::<span class="hljs-built_in">get_if</span>&lt;<span class="hljs-number">1</span>&gt;(&amp;var); ip) {    std::cout &lt;&lt; *ip &lt;&lt; <span class="hljs-string">'\n'</span>;}<span class="hljs-keyword">else</span> {    std::cout &lt;&lt; <span class="hljs-string">"alternative with index 1 not set\n"</span>;}</code></pre></div><p>您必须将指向变体的指针传递给 get_if&lt;&gt;()，它要么返回指向当前值的指针，要么返回 nullptr。 请注意，如果使用 with 初始化，则可以检查刚刚初始化的值。<br>访问不同选项值的另一种方法是变体访问者。</p><h6><span id="geng-gai-zhi">更改值</span><a href="#geng-gai-zhi" class="header-anchor">#</a></h6><p>赋值和 emplace() 操作对应于初始化存在：</p><div class="code-wrapper"><pre><code class="hljs c++">std::variant&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>, std::string&gt; var; <span class="hljs-comment">// 将第一个 int 设置为 0，index()==0</span>var = <span class="hljs-string">"hello"</span>; <span class="hljs-comment">// 设置字符串，index()==2</span>var.<span class="hljs-built_in">emplace</span>&lt;<span class="hljs-number">1</span>&gt;(<span class="hljs-number">42</span>); <span class="hljs-comment">// 设置第二个 int，index()==1</span></code></pre></div><p>您还可以使用 get&lt;&gt;() 或 get_if&lt;&gt;() 为当前替代项分配一个新值：</p><div class="code-wrapper"><pre><code class="hljs c++">std::variant&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>, std::string&gt; var; <span class="hljs-comment">// 将第一个 int 设置为 0，index()==0</span>std::<span class="hljs-built_in">get</span>&lt;<span class="hljs-number">0</span>&gt;(var) = <span class="hljs-number">77</span>; <span class="hljs-comment">// OK,因为第一个 int 已经设置</span>std::<span class="hljs-built_in">get</span>&lt;<span class="hljs-number">1</span>&gt;(var) = <span class="hljs-number">99</span>; <span class="hljs-comment">// 抛出异常（当前设置的其他 int）</span><span class="hljs-keyword">if</span> (<span class="hljs-keyword">auto</span> p = std::<span class="hljs-built_in">get_if</span>&lt;<span class="hljs-number">1</span>&gt;(&amp;var); p) { <span class="hljs-comment">// 如果第二个 int 设置</span>    *p = <span class="hljs-number">42</span>; <span class="hljs-comment">// 修改它</span>}</code></pre></div><p>修改不同选项值的另一种方法是变体访问者</p><h6><span id="bi-jiao">比较</span><a href="#bi-jiao" class="header-anchor">#</a></h6><p>对于相同类型的两个变体（即具有相同顺序的相同替代项），您可以使用通常的比较运算符。 运营商按照以下规则行事：</p><ul><li>具有较早替代值的变体小于具有较晚替代值的变体。</li><li>如果两个变体具有相同的备选方案，则评估备选方案类型的相应运算符。 注意 std::monostate 类型的所有对象总是相等的。</li><li>特殊状态 valueless_by_exception() 为 true 的两个变体是相等的。 否则，任何 valueless_by_exception() 为 true 的变体都小于任何其他变体。</li></ul><p>例如：</p><div class="code-wrapper"><pre><code class="hljs c++">std::variant&lt;std::monostate, <span class="hljs-type">int</span>, std::string&gt; v1, v2{<span class="hljs-string">"hello"</span>}, v3{<span class="hljs-number">42</span>};std::variant&lt;std::monostate, std::string, <span class="hljs-type">int</span>&gt; v4;<span class="hljs-comment">/*</span><span class="hljs-comment">    v1 == v4 // COMPILE-TIME ERROR</span><span class="hljs-comment">    v1 == v2 // yields false</span><span class="hljs-comment">    v1 &lt; v2 // yields true</span><span class="hljs-comment">    v1 &lt; v3 // yields true</span><span class="hljs-comment">    v2 &lt; v3 // yields false</span><span class="hljs-comment">    v1 = "hello";</span><span class="hljs-comment">    v1 == v2 // yields true</span><span class="hljs-comment">    v2 = 41;</span><span class="hljs-comment">    v2 &lt; v3 // yields true</span><span class="hljs-comment">*/</span></code></pre></div><h6><span id="yi-dong-yu-yi">移动语义</span><a href="#yi-dong-yu-yi" class="header-anchor">#</a></h6><p>std::variant&lt;&gt; 也支持移动语义。 如果您将对象作为一个整体移动，则将复制状态并移动当前替代项的值。 结果，移出的对象仍然具有相同的选择，但任何值都变得未指定。<br>您还可以将值移入或移出包含的对象。</p><h6><span id="san-lie">散列</span><a href="#san-lie" class="header-anchor">#</a></h6><p>当且仅当每个成员类型都可以提供哈希值时，才启用变体对象的哈希值。 请注意，哈希值不是当前备选方案的哈希值。</p><h5><span id="16-3-3-fang-ke">16.3.3 访客</span><a href="#16-3-3-fang-ke" class="header-anchor">#</a></h5><p>他们必须明确地为每种可能的类型提供函数调用运算符。 然后，使用相应的重载来处理当前的替代方案。</p><h6><span id="shi-yong-han-shu-dui-xiang-zuo-wei-fang-wen-zhe">使用函数对象作为访问者</span><a href="#shi-yong-han-shu-dui-xiang-zuo-wei-fang-wen-zhe" class="header-anchor">#</a></h6><p>例子：</p><p><code>lib/variantvisit.cpp </code></p><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;variant&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><span class="hljs-keyword">struct</span> <span class="hljs-title class_">MyVisitor</span>{    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">operator</span><span class="hljs-params">()</span> <span class="hljs-params">(<span class="hljs-type">int</span> i)</span> <span class="hljs-type">const</span> </span>{        std::cout &lt;&lt; <span class="hljs-string">"int: "</span> &lt;&lt; i &lt;&lt; <span class="hljs-string">'\n'</span>;    }    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">operator</span><span class="hljs-params">()</span> <span class="hljs-params">(std::string s)</span> <span class="hljs-type">const</span> </span>{        std::cout &lt;&lt; <span class="hljs-string">"string: "</span> &lt;&lt; s &lt;&lt; <span class="hljs-string">'\n'</span>;    }    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">operator</span><span class="hljs-params">()</span> <span class="hljs-params">(<span class="hljs-type">long</span> <span class="hljs-type">double</span> d)</span> <span class="hljs-type">const</span> </span>{        std::cout &lt;&lt; <span class="hljs-string">"double: "</span> &lt;&lt; d &lt;&lt; <span class="hljs-string">'\n'</span>;    }};<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>{    <span class="hljs-function">std::variant&lt;<span class="hljs-type">int</span>, std::string, <span class="hljs-type">double</span>&gt; <span class="hljs-title">var</span><span class="hljs-params">(<span class="hljs-number">42</span>)</span></span>;    std::<span class="hljs-built_in">visit</span>(<span class="hljs-built_in">MyVisitor</span>(), var); <span class="hljs-comment">// 为 int 调用 operator()</span>    var = <span class="hljs-string">"hello"</span>;    std::<span class="hljs-built_in">visit</span>(<span class="hljs-built_in">MyVisitor</span>(), var); <span class="hljs-comment">// 为string调用 operator()</span>    var = <span class="hljs-number">42.7</span>;    std::<span class="hljs-built_in">visit</span>(<span class="hljs-built_in">MyVisitor</span>(), var); <span class="hljs-comment">// 为long double调用 operator()</span>}</code></pre></div><p>如果 operator() 不支持所有可能的类型或调用不明确，则 visit() 调用是编译时错误。 此处的示例运行良好，因为 long double 比 int 更适合 double 值。<br>您还可以使用访问者来修改当前替代的值（但不能分配新的替代）。 例如：</p><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Twice</span>{    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">operator</span><span class="hljs-params">()</span><span class="hljs-params">(<span class="hljs-type">double</span>&amp; d)</span> <span class="hljs-type">const</span> </span>{        d *= <span class="hljs-number">2</span>;    }    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">operator</span><span class="hljs-params">()</span><span class="hljs-params">(<span class="hljs-type">int</span>&amp; i)</span> <span class="hljs-type">const</span> </span>{        i *= <span class="hljs-number">2</span>;    }    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">operator</span><span class="hljs-params">()</span><span class="hljs-params">(std::string&amp; s)</span> <span class="hljs-type">const</span> </span>{        s = s + s;    }};std::<span class="hljs-built_in">visit</span>(<span class="hljs-built_in">Twice</span>(), var); <span class="hljs-comment">// calls operator() for matching type</span></code></pre></div><p>因为只有类型很重要，所以对于具有相同类型的替代方案，您不能有不同的行为。<br>请注意，函数调用运算符应标记为 const，因为它们是无状态的（它们不会改变行为，只会改变传递的值）。</p><h6><span id="shi-yong-tong-yong-lambda-zuo-wei-fang-wen-zhe">使用通用 Lambda 作为访问者</span><a href="#shi-yong-tong-yong-lambda-zuo-wei-fang-wen-zhe" class="header-anchor">#</a></h6><p>使用此功能的最简单方法是使用通用 lambda，它是任意类型的函数对象：</p><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">auto</span> printvariant = [](<span class="hljs-type">const</span> <span class="hljs-keyword">auto</span>&amp; val) {    std::cout &lt;&lt; val &lt;&lt; <span class="hljs-string">'\n'</span>;};...;std::<span class="hljs-built_in">visit</span>(printvariant, var);</code></pre></div><p>在这里，通用 lambda 定义了一个闭包类型，其中函数调用运算符作为成员模板：</p><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">CompilerSpecifyClosureTypeName</span> {<span class="hljs-keyword">public</span>:    <span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;</span><span class="hljs-function">    <span class="hljs-keyword">auto</span> <span class="hljs-title">operator</span><span class="hljs-params">()</span> <span class="hljs-params">(<span class="hljs-type">const</span> T&amp; val)</span> <span class="hljs-type">const</span> </span>{        std::cout &lt;&lt; val &lt;&lt; <span class="hljs-string">'\n'</span>;    }};</code></pre></div><p>因此，如果生成的函数调用运算符中的语句有效（即调用输出运算符有效），则传递给 std::visit() 的 lambda 调用将编译。<br>您还可以使用 lambda 来修改当前替代项的值：</p><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-comment">// 将当前替代品的值翻倍:</span>std::<span class="hljs-built_in">visit</span>([](<span class="hljs-keyword">auto</span>&amp; val) {    val = val + val;},var);</code></pre></div><p>或者：</p><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-comment">// 恢复为当前替代的默认值;</span>std::<span class="hljs-built_in">visit</span>([](<span class="hljs-keyword">auto</span>&amp; val) {val = std::<span class="hljs-type">remove_reference_t</span>&lt;<span class="hljs-keyword">decltype</span>(val)&gt;{};},var);</code></pre></div><p>您甚至可以使用编译时语言功能以不同方式处理不同的替代方案。 例如：</p><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">auto</span> dblvar = [](<span class="hljs-keyword">auto</span>&amp; val) {    <span class="hljs-keyword">if</span> <span class="hljs-built_in">constexpr</span>(std::is_convertible_v&lt;<span class="hljs-keyword">decltype</span>(val),                 std::string&gt;) {        val = val + val;    }    <span class="hljs-keyword">else</span> {        val *= <span class="hljs-number">2</span>;    }};...;std::<span class="hljs-built_in">visit</span>(dblvar, var);</code></pre></div><p>在这里，对于 std::string 替代方案，通用 lambda 的调用实例化其通用函数调用模板以进行计算：</p><div class="code-wrapper"><pre><code class="hljs c++">val = val + val;</code></pre></div><p>而对于其他替代方案，例如 int 或 double，lambda 的调用实例化其通用函数调用模板来计算：</p><div class="code-wrapper"><pre><code class="hljs c++">val *= <span class="hljs-number">2</span>;</code></pre></div><h6><span id="shi-yong-chong-zai-de-lambda-zuo-wei-fang-wen-zhe">使用重载的 Lambda 作为访问者</span><a href="#shi-yong-chong-zai-de-lambda-zuo-wei-fang-wen-zhe" class="header-anchor">#</a></h6><p>通过对函数对象和 lambda 使用重载器，您还可以定义一组 lambda，其中最佳匹配用作访问者。<br>假设重载器是重载定义如下：</p><p><code>tmpl/overload.hpp </code></p><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-comment">// “继承”传递的基类型的所有函数调用运算符:</span><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span>... Ts&gt;<span class="hljs-keyword">struct</span> <span class="hljs-title class_">overload</span> : Ts...{    <span class="hljs-function"><span class="hljs-keyword">using</span> <span class="hljs-title">Ts::operator</span><span class="hljs-params">()</span>...</span>;};<span class="hljs-comment">// 基类型是从传递的参数推导出来的:</span><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span>... Ts&gt;</span><span class="hljs-function"><span class="hljs-title">overload</span><span class="hljs-params">(Ts...)</span> -&gt; overload&lt;Ts...&gt;</span>;</code></pre></div><p>您可以通过为每个替代方案提供 lambdas 来使用重载来访问变体：</p><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-function">std::variant&lt;<span class="hljs-type">int</span>, std::string&gt; <span class="hljs-title">var</span><span class="hljs-params">(<span class="hljs-number">42</span>)</span></span>;...;std::<span class="hljs-built_in">visit</span>(overload{ <span class="hljs-comment">// 调用当前替代的最佳匹配 lambda</span>    [](<span class="hljs-type">int</span> i) { std::cout &lt;&lt; <span class="hljs-string">"int: "</span> &lt;&lt; i &lt;&lt; <span class="hljs-string">'\n'</span>; },    [](<span class="hljs-type">const</span> std::string&amp; s) {        std::cout &lt;&lt; <span class="hljs-string">"string: "</span> &lt;&lt; s &lt;&lt; <span class="hljs-string">'\n'</span>; },},var);</code></pre></div><p>您还可以使用通用 lambda。 始终使用最佳匹配。 例如，要修改变体的当前替代项，您可以使用重载将字符串和其他类型的值“加倍”：</p><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">auto</span> twice = overload{    [](std::string&amp; s) { s += s; },    [](<span class="hljs-keyword">auto</span>&amp; i) { i *= <span class="hljs-number">2</span>; },};</code></pre></div><p>有了这个重载，对于字符串替代，当前值被附加，而对于所有其他类型，该值乘以 2，这演示了以下变体的应用：</p><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-function">std::variant&lt;<span class="hljs-type">int</span>, std::string&gt; <span class="hljs-title">var</span><span class="hljs-params">(<span class="hljs-number">42</span>)</span></span>;std::<span class="hljs-built_in">visit</span>(twice, var); <span class="hljs-comment">// value 42 becomes 84</span>...;var = <span class="hljs-string">"hi"</span>;std::<span class="hljs-built_in">visit</span>(twice, var); <span class="hljs-comment">// value "hi" becomes "hihi"</span></code></pre></div><h5><span id="16-3-4-li-wai-qing-kuang-xia-wu-zhi">16.3.4 例外情况下无值</span><a href="#16-3-4-li-wai-qing-kuang-xia-wu-zhi" class="header-anchor">#</a></h5><p>当修改变体以获取新值并且此修改引发异常时，变体可能会进入一个非常特殊的状态：变体已经失去了旧值，但没有获得新值。 例如：</p><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">S</span> {    <span class="hljs-function"><span class="hljs-keyword">operator</span> <span class="hljs-title">int</span><span class="hljs-params">()</span> </span>{ <span class="hljs-keyword">throw</span> <span class="hljs-string">"EXCEPTION"</span>; } <span class="hljs-comment">// 任何到 int 的转换都会抛出</span>};std::variant&lt;<span class="hljs-type">double</span>,<span class="hljs-type">int</span>&gt; var{<span class="hljs-number">12.2</span>}; <span class="hljs-comment">// 初始化为 double</span>var.<span class="hljs-built_in">emplace</span>&lt;<span class="hljs-number">1</span>&gt;(S{}); <span class="hljs-comment">// OOPS: 设置为 int 时抛出</span></code></pre></div><p>如果发生这种情况，那么：</p><ul><li>var.valueless_by_exception() 返回真</li><li>var.index() 返回 std::variant_npos<br>这表明该变体根本没有任何价值。<br>具体保证如下：</li><li>如果 emplace() 抛出 valueless_by_exception() 总是设置为 true。</li><li>如果 operator=() 抛出并且修改不会改变替代 valueless_by_exception() 并且 index() 保持它们的旧状态。值的状态取决于值类型的异常保证。</li><li>如果 operator=() 抛出并且新值将设置不同的替代项，则该变体可能没有值（valueless_by_exception() 可能变为 true）。这取决于何时抛出异常。如果它发生在值的实际修改开始之前的类型转换期间，则变体仍将保留其旧值。</li></ul><p>通常，只要您不再使用您尝试修改的变体，这种行为应该没有问题。如果你仍然想使用一个变体，尽管使用它会导致异常，你最好检查它的状态。例如：</p><div class="code-wrapper"><pre><code class="hljs c++">std::variant&lt;<span class="hljs-type">double</span>,<span class="hljs-type">int</span>&gt; var{<span class="hljs-number">12.2</span>}; <span class="hljs-comment">// 初始化为 double</span><span class="hljs-keyword">try</span> {    var.<span class="hljs-built_in">emplace</span>&lt;<span class="hljs-number">1</span>&gt;(S{}); <span class="hljs-comment">// OOPS: 设置为 int 时抛出</span>}<span class="hljs-built_in">catch</span> (...) {    <span class="hljs-keyword">if</span> (!var.<span class="hljs-built_in">valueless_by_exception</span>()) {        ...;    }}</code></pre></div><h4><span id="16-4-shi-yong-std-variant-de-duo-tai-xing-he-fei-tong-zhi-hua-de-ji-he">16.4 使用std::variant的多态性和非同质化的集合</span><a href="#16-4-shi-yong-std-variant-de-duo-tai-xing-he-fei-tong-zhi-hua-de-ji-he" class="header-anchor">#</a></h4><p>具有 std::variant 的多态性和非同质集合</p><p>std::variant 启用了一种新形式的多态性并处理非同质集合。 它是一种具有一组紧密数据类型的 compile-time 多态性形式。</p><p>也就是说，通过使用 variant&lt;&gt;，您可以定义一个对象是多种可能的类型之一。 然后，该对象具有值语义，您可以将这些对象插入到非同质集合中。 因为每个变体都知道它拥有哪个替代方案，并且由于访问者界面，我们可以在运行时针对不同类型进行编程，调用不同的函数/方法（不需要任何虚函数、引用和指针）。 </p><h5><span id="16-4-1-shi-yong-std-variant-de-ji-he-dui-xiang">16.4.1 使用std::variant的几何对象</span><a href="#16-4-1-shi-yong-std-variant-de-ji-he-dui-xiang" class="header-anchor">#</a></h5><p>例如，假设我们必须对几何对象系统进行编程：</p><p><code>lib/variantpoly1.cpp </code></p><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;variant&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">"coord.hpp"</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">"line.hpp"</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">"circle.hpp"</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">"rectangle.hpp"</span></span><span class="hljs-comment">// 所有几何对象类型的通用类型:</span><span class="hljs-keyword">using</span> GeoObj = std::variant&lt;Line, Circle, Rectangle&gt;;<span class="hljs-comment">// 创建和初始化几何对象的集合:</span><span class="hljs-function">std::vector&lt;GeoObj&gt; <span class="hljs-title">createFigure</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>{    std::vector&lt;GeoObj&gt; f;    f.<span class="hljs-built_in">push_back</span>(Line{Coord{<span class="hljs-number">1</span>,<span class="hljs-number">2</span>},Coord{<span class="hljs-number">3</span>,<span class="hljs-number">4</span>}});    f.<span class="hljs-built_in">push_back</span>(Circle{Coord{<span class="hljs-number">5</span>,<span class="hljs-number">5</span>},<span class="hljs-number">2</span>});    f.<span class="hljs-built_in">push_back</span>(Rectangle{Coord{<span class="hljs-number">3</span>,<span class="hljs-number">3</span>},Coord{<span class="hljs-number">6</span>,<span class="hljs-number">4</span>}});    <span class="hljs-keyword">return</span> f;}<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>{    std::vector&lt;GeoObj&gt; figure = <span class="hljs-built_in">createFigure</span>();    <span class="hljs-keyword">for</span> (<span class="hljs-type">const</span> GeoObj&amp; geoobj : figure) {        std::<span class="hljs-built_in">visit</span>([] (<span class="hljs-type">const</span> <span class="hljs-keyword">auto</span>&amp; obj) {            obj.<span class="hljs-built_in">draw</span>(); <span class="hljs-comment">// draw() 的多态调用</span>        },        geoobj);    }}</code></pre></div><p>首先，我们为所有可能的类型定义一个通用数据类型：</p><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">using</span> GeoObj = std::variant&lt;Line, Circle, Rectangle&gt;;</code></pre></div><p>这三种类型不需要任何特殊关系。 事实上，它们不必有一个通用的基类，没有虚函数，它们的接口甚至可能不同。 例如：</p><p><code>lib/circle.hpp</code></p><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">ifndef</span> CIRCLE_HPP</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> CIRCLE_HPP</span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">"coord.hpp"</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><span class="hljs-keyword">class</span> <span class="hljs-title class_">Circle</span> {    <span class="hljs-keyword">private</span>:    Coord center;    <span class="hljs-type">int</span> rad;    <span class="hljs-keyword">public</span>:    <span class="hljs-built_in">Circle</span> (Coord c, <span class="hljs-type">int</span> r)        : center{c}, rad{r} {        }    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">move</span><span class="hljs-params">(<span class="hljs-type">const</span> Coord&amp; c)</span> </span>{        center += c;    }    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">draw</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>{        std::cout &lt;&lt; <span class="hljs-string">"circle at "</span> &lt;&lt; center            &lt;&lt; <span class="hljs-string">" with radius "</span> &lt;&lt; rad &lt;&lt; <span class="hljs-string">'\n'</span>;    }};<span class="hljs-meta">#<span class="hljs-keyword">endif</span></span></code></pre></div><p>现在我们可以通过创建相应的对象并将它们按值传递到容器中来将这些类型的元素放入一个集合中：</p><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-function">std::vector&lt;GeoObj&gt; <span class="hljs-title">createFigure</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>{    std::vector&lt;GeoObj&gt; f;    f.<span class="hljs-built_in">push_back</span>(Line{Coord{<span class="hljs-number">1</span>,<span class="hljs-number">2</span>},Coord{<span class="hljs-number">3</span>,<span class="hljs-number">4</span>}});    f.<span class="hljs-built_in">push_back</span>(Circle{Coord{<span class="hljs-number">5</span>,<span class="hljs-number">5</span>},<span class="hljs-number">2</span>});    f.<span class="hljs-built_in">push_back</span>(Rectangle{Coord{<span class="hljs-number">3</span>,<span class="hljs-number">3</span>},Coord{<span class="hljs-number">6</span>,<span class="hljs-number">4</span>}});    <span class="hljs-keyword">return</span> f;}</code></pre></div><p>这段代码在运行时多态下是不可能的，因为那样的话类型必须将 GeoObj 作为一个公共基类，我们需要一个 GeoObj 元素的指针向量，并且由于指针，我们必须使用 new 创建对象，这样 我们必须跟踪何时调用 delete 或使用智能指针（unique_ptr 或 shared_ptr）。<br>通过使用访问者，我们可以遍历元素并根据元素类型“做正确的事”：</p><div class="code-wrapper"><pre><code class="hljs c++">std::vector&lt;GeoObj&gt; figure = <span class="hljs-built_in">createFigure</span>();<span class="hljs-keyword">for</span> (<span class="hljs-type">const</span> GeoObj&amp; geoobj : figure) {    std::<span class="hljs-built_in">visit</span>([] (<span class="hljs-type">const</span> <span class="hljs-keyword">auto</span>&amp; obj) {        obj.<span class="hljs-built_in">draw</span>(); <span class="hljs-comment">// polymorphic call of draw()</span>    },    geoobj);}</code></pre></div><p>在这里，visit() 使用通用 lambda 来为每个可能的 GeoObj 类型实例化。 也就是说，在编译 visit() 调用时，lambda 被实例化并编译为三个函数：</p><ul><li><p>编译 Line 类型的代码：</p><div class="code-wrapper"><pre><code class="hljs c++">[] (<span class="hljs-type">const</span> Line&amp; obj) {    obj.<span class="hljs-built_in">draw</span>(); <span class="hljs-comment">// call of Line::draw()</span>}</code></pre></div></li><li><p>编译 Circle 类型的代码：</p><div class="code-wrapper"><pre><code class="hljs c++">[] (<span class="hljs-type">const</span> Circle&amp; obj) {    obj.<span class="hljs-built_in">draw</span>(); <span class="hljs-comment">// call of Circle::draw()</span>}</code></pre></div></li><li><p>编译 Rectangle 类型的代码：</p><div class="code-wrapper"><pre><code class="hljs c++">[] (<span class="hljs-type">const</span> Rectangle&amp; obj) {    obj.<span class="hljs-built_in">draw</span>(); <span class="hljs-comment">// call of Rectangle::draw()</span>}</code></pre></div></li></ul><p>如果这些实例之一没有编译，则 visit() 的调用根本不会编译。 如果全部编译，则为每种元素类型生成调用相应函数的代码。 请注意，生成的代码没有 if-else 链。 该标准保证调用的性能不依赖于备选方案的数量。<br>也就是说，实际上我们得到了与虚函数表相同的行为（每个 visit() 都有一个本地虚函数表）。 请注意，调用的 draw() 函数不必是虚拟的。</p><p>如果类型接口不同，我们可以使用编译时 if 或访问者重载来处理这种情况（参见下面的第二个示例）。</p><h5><span id="16-4-2-qi-ta-shi-yong-std-variant-de-fei-tong-zhi-ji-he">16.4.2 其他使用std::variant的非同质集合</span><a href="#16-4-2-qi-ta-shi-yong-std-variant-de-fei-tong-zhi-ji-he" class="header-anchor">#</a></h5><p>作为将非同质集合与 std::variant&lt;&gt; 一起使用的另一个示例，请考虑以下示例：</p><p><code>lib/variantpoly2.cpp</code></p><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;variant&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;type_traits&gt;</span></span><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>{    <span class="hljs-keyword">using</span> Var = std::variant&lt;<span class="hljs-type">int</span>, <span class="hljs-type">double</span>, std::string&gt;;    std::vector&lt;Var&gt; values {<span class="hljs-number">42</span>, <span class="hljs-number">0.19</span>, <span class="hljs-string">"hello world"</span>, <span class="hljs-number">0.815</span>};        <span class="hljs-keyword">for</span> (<span class="hljs-type">const</span> Var&amp; val : values) {        std::<span class="hljs-built_in">visit</span>([] (<span class="hljs-type">const</span> <span class="hljs-keyword">auto</span>&amp; v) {            <span class="hljs-keyword">if</span> <span class="hljs-built_in">constexpr</span>(std::is_same_v&lt;<span class="hljs-keyword">decltype</span>(v),                         <span class="hljs-type">const</span> std::string&amp;&gt;) {                std::cout &lt;&lt; <span class="hljs-string">'"'</span> &lt;&lt; v &lt;&lt; <span class="hljs-string">"\" "</span>;            }            <span class="hljs-keyword">else</span> {                std::cout &lt;&lt; v &lt;&lt; <span class="hljs-string">' '</span>;            }        },        val);    }}</code></pre></div><p>同样，我们为表示多种可能类型之一的对象定义自己的类型：</p><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">using</span> Var = std::variant&lt;<span class="hljs-type">int</span>, <span class="hljs-type">double</span>, std::string&gt;;</code></pre></div><p>我们可以用它们创建一个初始化非同质集合：</p><div class="code-wrapper"><pre><code class="hljs c++">std::vector&lt;Var&gt; values {<span class="hljs-number">42</span>, <span class="hljs-number">0.19</span>, <span class="hljs-string">"hello world"</span>, <span class="hljs-number">0.815</span>};</code></pre></div><p>请注意，我们可以使用不均匀的元素集合来初始化vector，因为它们都转换为变体类型。 只有当我们传递一个 long 时，编译器才会知道是将它转换为 int 还是 double，这样就不会编译。</p><p>当我们迭代时，我们使用访问者为他们调用不同的函数。 然而，因为在这里我们想做不同的事情（如果值是字符串，则在值周围加上引号），我们使用compile-time if：</p><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">for</span> (<span class="hljs-type">const</span> Var&amp; val : values) {    std::<span class="hljs-built_in">visit</span>([] (<span class="hljs-type">const</span> <span class="hljs-keyword">auto</span>&amp; v) {        <span class="hljs-keyword">if</span> <span class="hljs-built_in">constexpr</span>(std::is_same_v&lt;<span class="hljs-keyword">decltype</span>(v),                     <span class="hljs-type">const</span> std::string&amp;&gt;) {            std::cout &lt;&lt; <span class="hljs-string">'"'</span> &lt;&lt; v &lt;&lt; <span class="hljs-string">"\" "</span>;        }        <span class="hljs-keyword">else</span> {            std::cout &lt;&lt; v &lt;&lt; <span class="hljs-string">' '</span>;        }    },    val);}</code></pre></div><p>这样输出就变成了：</p><div class="code-wrapper"><pre><code class="hljs bash">42 0.19 <span class="hljs-string">"hello world"</span> 0.815</code></pre></div><p>通过使用访问者重载，我们还可以如下实现：</p><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">for</span> (<span class="hljs-type">const</span> <span class="hljs-keyword">auto</span>&amp; val : values) {    std::<span class="hljs-built_in">visit</span>(overload{        [] (<span class="hljs-keyword">auto</span> v) {            std::cout &lt;&lt; v &lt;&lt; <span class="hljs-string">' '</span>;        },        [] (<span class="hljs-type">const</span> std::string&amp; v) {            std::cout &lt;&lt; <span class="hljs-string">'"'</span> &lt;&lt; v &lt;&lt; <span class="hljs-string">"\" "</span>;        }    },               val);}</code></pre></div><h5><span id="16-4-3-bi-jiao-bian-ti-duo-tai-xing">16.4.3 比较变体多态性</span><a href="#16-4-3-bi-jiao-bian-ti-duo-tai-xing" class="header-anchor">#</a></h5><p>让我们总结一下使用 std::variant&lt;&gt; 处理多态性和非同质集合的优缺点。<br>好处是：</p><ul><li>您不需要常见的基本类型（非侵入式）。</li><li>您不必为非同质集合使用指针。</li><li>不需要虚拟成员函数。</li><li>值语义（无法访问已释放的内存或内存泄漏）。</li><li>向量中的元素位于一起（而不是通过堆内存中的指针分布）。</li></ul><p>限制和缺点是：</p><ul><li>关闭类型集（您必须在编译时了解所有替代方案）。</li><li>元素都具有最大元素类型的大小（如果元素类型大小差异很大，则会出现问题）。</li><li>复制元素可能更昂贵。</li></ul><p>一般来说，我现在建议默认使用 std::variant&lt;&gt; 来编程多态，因为它通常更快（没有 new 和 delete，没有用于非多态使用的虚函数），更安全（没有指针），并且 通常所有类型在所有代码的编译时都是已知的。<br>就在您必须处理引用语义（在多个地方使用相同的对象）或传递对象变得昂贵（即使使用移动语义）时，运行时多态性<br>继承可能仍然是合适的。</p><h4><span id="16-5-std-variant-lt-gt-de-te-shu-qing-kuang">16.5 std::variant&lt;&gt; 的特殊情况</span><a href="#16-5-std-variant-lt-gt-de-te-shu-qing-kuang" class="header-anchor">#</a></h4><p>特定变体可能导致特殊或意外行为</p><h5><span id="16-5-1-tong-shi-yong-you-bool-he-std-string-de-xuan-ze">16.5.1 同时拥有bool和std::string的选择</span><a href="#16-5-1-tong-shi-yong-you-bool-he-std-string-de-xuan-ze" class="header-anchor">#</a></h5><p>如果 std::variant&lt;&gt; 同时具有 bool 和 std::string 替代项，则分配字符串文字可能会变得令人惊讶，因为字符串文字转换为 bool 比转换为 std::string 更好。 例如：</p><div class="code-wrapper"><pre><code class="hljs c++">std::variant&lt;<span class="hljs-type">bool</span>, std::string&gt; v;v = <span class="hljs-string">"hi"</span>; <span class="hljs-comment">// OOPS: sets the bool alternative</span>std::cout &lt;&lt; <span class="hljs-string">"index: "</span> &lt;&lt; v.<span class="hljs-built_in">index</span>() &lt;&lt; <span class="hljs-string">'\n'</span>;std::<span class="hljs-built_in">visit</span>([](<span class="hljs-type">const</span> <span class="hljs-keyword">auto</span>&amp; val) {    std::cout &lt;&lt; <span class="hljs-string">"value: "</span> &lt;&lt; val &lt;&lt; <span class="hljs-string">'\n'</span>;}, v);</code></pre></div><p>此代码段将具有以下输出：</p><div class="code-wrapper"><pre><code class="hljs c++">index: <span class="hljs-number">0</span>value: <span class="hljs-literal">true</span></code></pre></div><p>因此，字符串文字被解释为通过布尔值 true 初始化变量（因为指针不为 0，所以为 true）。<br>这里有几个选项可以“修复”分配：</p><div class="code-wrapper"><pre><code class="hljs c++">v.<span class="hljs-built_in">emplace</span>&lt;<span class="hljs-number">1</span>&gt;(<span class="hljs-string">"hello"</span>); <span class="hljs-comment">// 明确分配给第二个备选方案</span>v.<span class="hljs-built_in">emplace</span>&lt;std::string&gt;(<span class="hljs-string">"hello"</span>); <span class="hljs-comment">// 显式分配给字符串替代</span>v = std::string{<span class="hljs-string">"hello"</span>}; <span class="hljs-comment">// 确保分配了一个字符串</span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std::literals; <span class="hljs-comment">// 确保分配了一个字符串</span>v = <span class="hljs-string">"hello"</span>s;</code></pre></div><h4><span id="16-6-hou-ji">16.6 后记</span><a href="#16-6-hou-ji" class="header-anchor">#</a></h4><p>变体对象于 2005 年由 Axel Naumann 在 <a href="https://wg21.link/n4218">https://wg21.link/n4218</a> 中首次提出，将 Boost.Variant 作为参考实现。 制定了最终接受的措辞 Axel Naumann 在 <a href="https://wg21.link/p0088r3">https://wg21.link/p0088r3</a> 中。</p><p>Tony van Eerd 使用 <a href="https://wg21.link/p0393r3">https://wg21.link/p0393r3</a> 显着改进了比较运算符的语义。 Vicente J. Botet Escriba 将 API 与 std::optional&lt;&gt; 和 std::any 与 <a href="https://wg21.link/p0032r3">https://wg21.link/p0032r3</a> 进行了协调。 Jonathan Wakely 使用 <a href="https://wg21.link/p0504r0">https://wg21.link/p0504r0</a> 修复了 in_place 标记类型的行为。 Erich Keane 与 <a href="https://wg21.link/p0510r0">https://wg21.link/p0510r0</a> 制定了禁止引用、不完整类型和数组以及空变体的限制。 在 C++17 发布后，Mike Spertus、Walter E. Brown 和 Stephan T. Lavavej 使用 <a href="https://wg21.link/p0739r0">https://wg21.link/p0739r0</a> 修复了一个小缺陷。</p><h3><span id="17-std-any">17 std::any</span><a href="#17-std-any" class="header-anchor">#</a></h3><p>一般来说，C++ 是一种具有类型绑定和类型安全性的语言。值对象被声明为具有特定类型，它定义了哪些操作是可能的以及它们的行为方式。并且值对象不能改变它们的类型。</p><p>std::any 是一种能够改变其类型的值类型，同时仍具有类型安全性。也就是说，对象可以保存任意类型的值，但它们知道当前保存的值是哪种类型。声明此类型的对象时无需指定可能的类型。</p><p>诀窍是对象既包含包含的值，也包含使用 typeid 的包含值的类型。因为该值可以具有任何大小，所以内存可能会在堆上分配。但是，实现应避免将堆内存用于包含的小值，例如 int。</p><p>也就是说，如果您分配一个字符串，该对象会为该值分配内存并复制该字符串，同时还在内部存储分配的字符串。稍后，可以进行运行时检查以找出当前值具有哪种类型，并将该值用作其类型，any_cast&lt;&gt; 是必要的。</p><p>至于 std::optional&lt;&gt; 和 std::variant&lt;&gt; 结果对象具有值语义。也就是说，通过在自己的内存中创建一个具有当前包含值及其类型的独立对象来进行深度复制。因为可能涉及堆内存，所以复制 std::any 通常很昂贵，您应该更喜欢通过引用传递对象或移动值。部分支持移动语义。</p><h4><span id="17-1-shi-yong-std-any">17.1 使用 std::any</span><a href="#17-1-shi-yong-std-any" class="header-anchor">#</a></h4><p>以下示例演示了 std::any 的核心功能：</p><div class="code-wrapper"><pre><code class="hljs c++">std::any a; <span class="hljs-comment">// a 为空</span>std::any b = <span class="hljs-number">4.3</span>; <span class="hljs-comment">// b 具有 double 类型的值 4.3</span>a = <span class="hljs-number">42</span>; <span class="hljs-comment">// a 具有 int 类型的值 42</span>b = std::string{<span class="hljs-string">"hi"</span>}; <span class="hljs-comment">// b 具有 std::string 类型的值 "hi"</span><span class="hljs-keyword">if</span> (a.<span class="hljs-built_in">type</span>() == <span class="hljs-built_in">typeid</span>(std::string)) {    std::string s = std::<span class="hljs-built_in">any_cast</span>&lt;std::string&gt;(a);    <span class="hljs-built_in">useString</span>(s);}<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (a.<span class="hljs-built_in">type</span>() == <span class="hljs-built_in">typeid</span>(<span class="hljs-type">int</span>)) {    <span class="hljs-built_in">useInt</span>(std::<span class="hljs-built_in">any_cast</span>&lt;<span class="hljs-type">int</span>&gt;(a));}</code></pre></div><p>您可以将 std::any 声明为空或由特定类型的值初始化。 初始值的类型成为包含值的类型。</p><p>通过使用成员函数 type()，您可以根据任何类型的类型 ID 检查包含值的类型。 如果对象为空，则类型 ID 为 typeid(void)。</p><p>要访问包含的值，您必须使用 std::any_cast&lt;&gt; 将其转换为它的类型：</p><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">auto</span> s = std::<span class="hljs-built_in">any_cast</span>&lt;std::string&gt;(a);</code></pre></div><p>如果转换失败，因为对象为空或包含的类型不适合，则抛出 std::bad_any_cast。 因此，在不检查或不知道类型的情况下，您最好实现以下内容：</p><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">try</span> {    <span class="hljs-keyword">auto</span> s = std::<span class="hljs-built_in">any_cast</span>&lt;std::string&gt;(a);    ...}<span class="hljs-built_in">catch</span> (std::bad_any_cast&amp; e) {    std::cerr &lt;&lt; <span class="hljs-string">"EXCEPTION: "</span> &lt;&lt; e.<span class="hljs-built_in">what</span>() &lt;&lt; <span class="hljs-string">'\n'</span>;}</code></pre></div><p>注意 std::any_cast&lt;&gt; 创建一个传递类型的对象。 如果您将 std::string 作为模板参数传递给 std::any_cast&lt;&gt;，它会创建一个临时字符串（prvalue），然后用于初始化新对象 s。 如果没有这样的初始化，通常最好转换为引用类型以避免创建临时对象：</p><div class="code-wrapper"><pre><code class="hljs c++">std::cout &lt;&lt; std::<span class="hljs-built_in">any_cast</span>&lt;<span class="hljs-type">const</span> std::string&amp;&gt;(a);</code></pre></div><p>为了能够修改该值，您需要强制转换为相应的引用类型：</p><div class="code-wrapper"><pre><code class="hljs c++">std::<span class="hljs-built_in">any_cast</span>&lt;std::string&amp;&gt;(a) = <span class="hljs-string">"world"</span>;</code></pre></div><p>您还可以调用 std::any_cast 以获得 std::any 对象的地址。 在这种情况下，如果类型适合，则强制转换返回相应的指针，否则返回 nullptr：</p><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">auto</span> p = std::<span class="hljs-built_in">any_cast</span>&lt;std::string&gt;(&amp;a);<span class="hljs-keyword">if</span> (p) {    ...}</code></pre></div><p>要清空现有的 std::any 对象，您可以调用：</p><div class="code-wrapper"><pre><code class="hljs c++">a.<span class="hljs-built_in">reset</span>(); <span class="hljs-comment">// 使其为空</span></code></pre></div><p>或者：</p><div class="code-wrapper"><pre><code class="hljs c++">a = std::any{};</code></pre></div><p>要不就：</p><div class="code-wrapper"><pre><code class="hljs c++">a = {};</code></pre></div><p>您可以直接检查对象是否为空：</p><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">if</span> (a.<span class="hljs-built_in">has_value</span>()) {    ...}</code></pre></div><p>另请注意，值是使用其衰减类型存储的（数组转换为指针，顶级引用和 const 被忽略）。 对于字符串文字，这意味着值类型是 const char*。</p><p>要检查 type() 并使用 std::any_cast&lt;&gt; 您必须完全使用这种类型：</p><div class="code-wrapper"><pre><code class="hljs c++">std::any a = <span class="hljs-string">"hello"</span>; <span class="hljs-comment">// type() is const char*</span><span class="hljs-keyword">if</span> (a.<span class="hljs-built_in">type</span>() == <span class="hljs-built_in">typeid</span>(<span class="hljs-type">const</span> <span class="hljs-type">char</span>*)) { <span class="hljs-comment">// true</span>    ...}<span class="hljs-keyword">if</span> (a.<span class="hljs-built_in">type</span>() == <span class="hljs-built_in">typeid</span>(std::string)) { <span class="hljs-comment">// false</span>    ...}std::cout &lt;&lt; std::<span class="hljs-built_in">any_cast</span>&lt;<span class="hljs-type">const</span> <span class="hljs-type">char</span>*&gt;(v[<span class="hljs-number">1</span>]) &lt;&lt; <span class="hljs-string">'\n'</span>; <span class="hljs-comment">// OK</span>std::cout &lt;&lt; std::<span class="hljs-built_in">any_cast</span>&lt;std::string&gt;(v[<span class="hljs-number">1</span>]) &lt;&lt; <span class="hljs-string">'\n'</span>; <span class="hljs-comment">// EXCEPTION</span></code></pre></div><p>这些或多或少都是所有操作。 没有定义比较运算符（因此，您不能比较或排序对象），没有定义散列函数，也没有定义 value() 成员函数。 并且因为类型只在运行时才知道，所以不能使用通用 lambda 来处理独立于其类型的当前值。 您总是需要运行时函数 std::any_cast&lt;&gt; 才能处理当前值，这意味着在处理值时需要一些特定于类型的代码来重新进入 C++ 类型系统。</p><p>但是，可以将 std::any 对象放入容器中。 例如：</p><div class="code-wrapper"><pre><code class="hljs c++">std::vector&lt;std::any&gt; v;v.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">42</span>);std::string s = <span class="hljs-string">"hello"</span>;v.<span class="hljs-built_in">push_back</span>(s);<span class="hljs-keyword">for</span> (<span class="hljs-type">const</span> <span class="hljs-keyword">auto</span>&amp; a : v) {    <span class="hljs-keyword">if</span> (a.<span class="hljs-built_in">type</span>() == <span class="hljs-built_in">typeid</span>(std::string)) {        std::cout &lt;&lt; <span class="hljs-string">"string: "</span> &lt;&lt; std::<span class="hljs-built_in">any_cast</span>&lt;<span class="hljs-type">const</span> std::string&amp;&gt;(a) &lt;&lt; <span class="hljs-string">'\n'</span>;    }    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (a.<span class="hljs-built_in">type</span>() == <span class="hljs-built_in">typeid</span>(<span class="hljs-type">int</span>)) {        std::cout &lt;&lt; <span class="hljs-string">"int: "</span> &lt;&lt; std::<span class="hljs-built_in">any_cast</span>&lt;<span class="hljs-type">int</span>&gt;(a) &lt;&lt; <span class="hljs-string">'\n'</span>;    }}</code></pre></div><h4><span id="17-2-std-any-lei-xing-he-cao-zuo">17.2 std::any 类型和操作</span><a href="#17-2-std-any-lei-xing-he-cao-zuo" class="header-anchor">#</a></h4><p>本节详细介绍 std::any 的类型和操作。</p><h5><span id="17-2-1-any-lei-xing">17.2.1 Any 类型</span><a href="#17-2-1-any-lei-xing" class="header-anchor">#</a></h5><p>在头文件 <any> 中，C++ 标准库定义类 std::any 如下：</any></p><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">namespace</span> std {    <span class="hljs-keyword">class</span> <span class="hljs-title class_">any</span>;}</code></pre></div><p>也就是说， std::any 根本不是类模板。<br>此外，还定义了以下类型和对象：</p><ul><li>异常类std::bad_any_cast，派生自std::bad_cast，派生自std::exception，如果类型转换失败。</li></ul><p>任何对象也使用 <utility> 中定义的对象 std::in_place_type（类型为 std::in_place_type_t）。</utility></p><h5><span id="17-2-2-any-cao-zuo">17.2.2 Any 操作</span><a href="#17-2-2-any-cao-zuo" class="header-anchor">#</a></h5><p>表 std::any 操作列出了为 std::any 提供的所有操作。</p><table><thead><tr><th>Operation</th><th>作用</th></tr></thead><tbody><tr><td>constructors</td><td>创建一个任意对象（可能调用底层类型的构造函数）</td></tr><tr><td>make_any()</td><td>创建一个任意对象（传递值来初始化它）</td></tr><tr><td>destructor</td><td>销毁任何对象</td></tr><tr><td>=</td><td>分配一个新值</td></tr><tr><td>emplace<t>()</t></td><td>分配一个类型为 T 的新值</td></tr><tr><td>reset()</td><td>销毁任何值（使对象为空）</td></tr><tr><td>has_value()</td><td>返回对象是否有值</td></tr><tr><td>type()</td><td>将当前类型作为 std::type_info 对象返回</td></tr><tr><td>any_cast<t>()</t></td><td>使用当前值作为类型 T 的值（其他类型除外）</td></tr><tr><td>swap()</td><td>在两个对象之间交换值</td></tr></tbody></table><h6><span id="gou-zao">构造</span><a href="#gou-zao" class="header-anchor">#</a></h6><p>默认情况下， std::any 初始化为空。</p><div class="code-wrapper"><pre><code class="hljs c++">std::any a1; <span class="hljs-comment">// a1 为空</span></code></pre></div><p>如果一个值被传递给初始化，它的衰减类型被用作包含值的类型：</p><div class="code-wrapper"><pre><code class="hljs c++">std::any a2 = <span class="hljs-number">42</span>; <span class="hljs-comment">// a2 包含 int 类型的值</span>std::any a3 = <span class="hljs-string">"hello"</span>; <span class="hljs-comment">// a2 包含 const char* 类型的值</span></code></pre></div><p>要保存与初始值类型不同的类型，您必须使用 in_place_type<br>标签：</p><div class="code-wrapper"><pre><code class="hljs c++">std::any a4{std::in_place_type&lt;<span class="hljs-type">long</span>&gt;, <span class="hljs-number">42</span>};std::any a5{std::in_place_type&lt;std::string&gt;, <span class="hljs-string">"hello"</span>};</code></pre></div><p>甚至传递给 in_place_type 的类型也会衰减。 以下声明包含一个 const char*：</p><div class="code-wrapper"><pre><code class="hljs c++">std::any a5b{std::in_place_type&lt;<span class="hljs-type">const</span> <span class="hljs-type">char</span>[<span class="hljs-number">6</span>]&gt;, <span class="hljs-string">"hello"</span>};</code></pre></div><p>要通过多个参数初始化可选对象，您必须创建对象或添加 std::in_place_type 作为第一个参数（无法推断包含的类型）：</p><div class="code-wrapper"><pre><code class="hljs c++">std::any a6{std::complex{<span class="hljs-number">3.0</span>, <span class="hljs-number">4.0</span>}};std::any a7{std::in_place_type&lt;std::complex&lt;<span class="hljs-type">double</span>&gt;&gt;, <span class="hljs-number">3.0</span>, <span class="hljs-number">4.0</span>};</code></pre></div><p>你甚至可以传递一个初始化列表，后跟其他参数：</p><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-comment">// initialize a std::any with a set with lambda as sorting criterion:</span><span class="hljs-keyword">auto</span> sc = [] (<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y) {    <span class="hljs-keyword">return</span> std::<span class="hljs-built_in">abs</span>(x) &lt; std::<span class="hljs-built_in">abs</span>(y);};std::any a8{std::in_place_type&lt;std::set&lt;<span class="hljs-type">int</span>,<span class="hljs-keyword">decltype</span>(sc)&gt;&gt;,            {<span class="hljs-number">4</span>, <span class="hljs-number">8</span>, <span class="hljs-number">-7</span>, <span class="hljs-number">-2</span>, <span class="hljs-number">0</span>, <span class="hljs-number">5</span>},            sc};</code></pre></div><p>请注意，还有一个便利函数 make_any&lt;&gt;()，可用于单个或多个参数（不需要 in_place_type 参数）。 您始终必须明确指定初始化类型（如果仅传递一个参数，则不会推导出）：</p><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">auto</span> a10 = std::<span class="hljs-built_in">make_any</span>&lt;<span class="hljs-type">float</span>&gt;(<span class="hljs-number">3.0</span>);<span class="hljs-keyword">auto</span> a11 = std::<span class="hljs-built_in">make_any</span>&lt;std::string&gt;(<span class="hljs-string">"hello"</span>);<span class="hljs-keyword">auto</span> a13 = std::make_any&lt;std::complex&lt;<span class="hljs-type">double</span>&gt;&gt;(<span class="hljs-number">3.0</span>, <span class="hljs-number">4.0</span>);<span class="hljs-keyword">auto</span> a14 = std::make_any&lt;std::set&lt;<span class="hljs-type">int</span>,<span class="hljs-keyword">decltype</span>(sc)&gt;&gt;({<span class="hljs-number">4</span>, <span class="hljs-number">8</span>, <span class="hljs-number">-7</span>, <span class="hljs-number">-2</span>, <span class="hljs-number">0</span>, <span class="hljs-number">5</span>},                                                     sc);</code></pre></div><h6><span id="geng-gai-zhi">更改值</span><a href="#geng-gai-zhi" class="header-anchor">#</a></h6><p>存在相应的赋值和 emplace() 操作。 例如：</p><div class="code-wrapper"><pre><code class="hljs c++">std::any a;a = <span class="hljs-number">42</span>; <span class="hljs-comment">// a 包含 int 类型的值</span>a = <span class="hljs-string">"hello"</span>; <span class="hljs-comment">// a 包含 const char* 类型的值</span>a.emplace{std::in_place_type&lt;std::string&gt;, <span class="hljs-string">"hello"</span>};<span class="hljs-comment">// a 包含 std::string 类型的值</span>a.emplace{std::in_place_type&lt;std::complex&lt;<span class="hljs-type">double</span>&gt;&gt;, <span class="hljs-number">4.4</span>, <span class="hljs-number">5.5</span>};<span class="hljs-comment">// a 包含 std::complex&lt;double&gt; 类型的值</span></code></pre></div><h6><span id="fang-wen-zhi">访问值</span><a href="#fang-wen-zhi" class="header-anchor">#</a></h6><p>要访问包含的值，您必须使用 std::any_cast&lt;&gt; 将其转换为它的类型。 要将值转换为字符串，您有几个选项：</p><div class="code-wrapper"><pre><code class="hljs c++">std::<span class="hljs-built_in">any_cast</span>&lt;std::string&gt;(a) <span class="hljs-comment">// 生成值的副本</span>std::<span class="hljs-built_in">any_cast</span>&lt;std::string&amp;&gt;(a); <span class="hljs-comment">// 通过引用写入值</span>std::<span class="hljs-built_in">any_cast</span>&lt;<span class="hljs-type">const</span> std::string&amp;&gt;(a); <span class="hljs-comment">// 引用读访问</span></code></pre></div><p>在这里，如果转换失败，则抛出 std::bad_any_cast 异常。<br>如果删除了顶级引用的传递类型具有相同的类型 ID，则该类型适合。<br>如果转换失败，您可以传递一个地址来获取 nullptr，因为当前类型不适合：</p><div class="code-wrapper"><pre><code class="hljs c++">std::<span class="hljs-built_in">any_cast</span>&lt;std::string&gt;(&amp;a) <span class="hljs-comment">// 通过指针写访问</span>std::<span class="hljs-built_in">any_cast</span>&lt;<span class="hljs-type">const</span> std::string&gt;(&amp;a); <span class="hljs-comment">// 通过指针读取访问</span></code></pre></div><p>请注意，此处转换为引用会导致运行时错误：</p><div class="code-wrapper"><pre><code class="hljs c++">std::<span class="hljs-built_in">any_cast</span>&lt;std::string&amp;&gt;(&amp;a); <span class="hljs-comment">// RUN-TIME ERROR</span></code></pre></div><h6><span id="yi-dong-yu-yi">移动语义</span><a href="#yi-dong-yu-yi" class="header-anchor">#</a></h6><p>std::any 还支持移动语义。 但是，请注意，仅具有复制语义的类型才支持移动语义。 也就是说，不支持将仅移动类型作为包含值类型。</p><p>处理移动语义的最佳方式可能并不明显。 所以，这里是你应该怎么做：</p><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-function">std::string <span class="hljs-title">s</span><span class="hljs-params">(<span class="hljs-string">"hello, world!"</span>)</span></span>;std::any a;a = std::<span class="hljs-built_in">move</span>(s); <span class="hljs-comment">// move s into a</span>s = std::<span class="hljs-built_in">move</span>(std::<span class="hljs-built_in">any_cast</span>&lt;string&amp;&gt;(a)); <span class="hljs-comment">// 将 a 中的分配字符串移动到 s</span></code></pre></div><p>像往常一样，对于移出对象，在最后一次调用之后，a 的包含值是未指定的。 因此，只要不假设包含的字符串值具有哪个值，就可以将 a 用作字符串。 以下语句的输出可能是空字符串，而不是“NIL”：</p><div class="code-wrapper"><pre><code class="hljs c++">std::cout &lt;&lt; (a.<span class="hljs-built_in">has_value</span>() ? std::<span class="hljs-built_in">any_cast</span>&lt;std::string&gt;(a) : std::<span class="hljs-built_in">string</span>(<span class="hljs-string">"NIL"</span>));</code></pre></div><p>注意：</p><div class="code-wrapper"><pre><code class="hljs c++">s = std::<span class="hljs-built_in">any_cast</span>&lt;string&gt;(std::<span class="hljs-built_in">move</span>(a));</code></pre></div><p>也可以，但需要额外的动作。</p><p>直接转换为右值引用不会编译：</p><div class="code-wrapper"><pre><code class="hljs c++">s = std::<span class="hljs-built_in">any_cast</span>&lt;std::string&amp;&amp;&gt;(a); <span class="hljs-comment">// compile-time error</span></code></pre></div><p>请注意，而不是调用</p><div class="code-wrapper"><pre><code class="hljs c++">a = std::<span class="hljs-built_in">move</span>(s); <span class="hljs-comment">// 将 s 移动到 a</span></code></pre></div><p>以下可能并不总是有效（尽管它是 C++ 标准中的一个示例）：</p><div class="code-wrapper"><pre><code class="hljs c++">std::<span class="hljs-built_in">any_cast</span>&lt;string&amp;&gt;(a) = std::<span class="hljs-built_in">move</span>(s); <span class="hljs-comment">// OOPS: a 必须持有一个字符串</span></code></pre></div><p>这仅在 a 已经包含 std::string 类型的值时才有效。 如果不是，则在我们移动分配新值之前，演员表会抛出一个 std::bad_any_cast 异常。</p><h4><span id="17-3-hou-ji">17.3 后记</span><a href="#17-3-hou-ji" class="header-anchor">#</a></h4><p>2006 年，Kevlin Henney 和 Beman Dawes 在 <a href="https://wg21.link/n1939">https://wg21.link/n1939</a> 中首次提出任何对象，将 Boost.Any 作为参考实现。 正如 Beman Dawes、Kevlin Henney 和 Daniel Krugler 在 <a href="https://wg21.link/n3804">https://wg21.link/n3804</a> 中提出的，该课程被采纳为图书馆基础知识 TS 的一部分。</p><p>正如 Beman Dawes 和 Alisdair Meredith 在 <a href="https://wg21.link/p0220r1">https://wg21.link/p0220r1</a> 中提出的，该类与 C++17 的其他组件一起采用。</p><p>Vicente J. Botet Escriba 将 API 与 std::variant&lt;&gt; 和 std::optional&lt;&gt; 与 <a href="https://wg21.link/p0032r3">https://wg21.link/p0032r3</a> 进行了协调。 Jonathan Wakely 使用 <a href="https://wg21.link/p0504r0">https://wg21.link/p0504r0</a> 修复了 in_place 标记类型的行为。  </p><h3><span id="18-std-byte">18 std::byte</span><a href="#18-std-byte" class="header-anchor">#</a></h3><p>程序将数据保存在内存中。 对于 std::byte，C++17 为它引入了一种类型，它确实代表了内存元素字节的“自然”类型。 与 char 或 int 等类型的主要区别在于，这种类型不能（容易）（ab）用作整数值或字符类型。 对于数字计算或字符序列不是目标的情况，这会带来更多的类型安全性。</p><p>唯一支持的“计算”操作是按位运算符。</p><h4><span id="18-1-shi-yong-std-byte">18.1 使用 std::byte</span><a href="#18-1-shi-yong-std-byte" class="header-anchor">#</a></h4><p>以下示例演示了 std::byte 的核心功能：</p><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstddef&gt;</span> <span class="hljs-comment">// for std::byte</span></span>std::byte b1{<span class="hljs-number">0x3F</span>};std::byte b2{<span class="hljs-number">0b1111</span>’<span class="hljs-number">0000</span>};std::byte b3[<span class="hljs-number">4</span>] {b1, b2, std::byte{<span class="hljs-number">1</span>}}; <span class="hljs-comment">// 4 bytes (last is 0)</span><span class="hljs-keyword">if</span> (b1 == b3[<span class="hljs-number">0</span>]) {    b1 &lt;&lt;= <span class="hljs-number">1</span>;}std::cout &lt;&lt; std::<span class="hljs-built_in">to_integer</span>&lt;<span class="hljs-type">int</span>&gt;(b1) &lt;&lt; <span class="hljs-string">'\n'</span>; <span class="hljs-comment">// outputs: 126</span></code></pre></div><p>在这里，我们定义了两个具有两个不同初始值的字节。 b2 使用自 C++14 以来可用的两个功能进行初始化：</p><ul><li>前缀 0b 可以定义二进制文字。</li><li>数字分隔符 ‘ 允许使数字文字在源代码中更具可读性（它可以放在数字文字的任意两位之间）。</li></ul><p>请注意，列表初始化（使用花括号）是您可以直接初始化 std::byte 对象的单个值的唯一方法。 所有其他形式不编译：</p><div class="code-wrapper"><pre><code class="hljs c++">std::byte b1{<span class="hljs-number">42</span>}; <span class="hljs-comment">// ok（对于自 C++17 以来具有固定基础类型的所有枚举）</span><span class="hljs-function">std::byte <span class="hljs-title">b2</span><span class="hljs-params">(<span class="hljs-number">42</span>)</span></span>; <span class="hljs-comment">// ERROR</span>std::byte b3 = <span class="hljs-number">42</span>; <span class="hljs-comment">// ERROR</span>std::byte b4 = {<span class="hljs-number">42</span>}; <span class="hljs-comment">// ERROR</span></code></pre></div><p>这是 std::byte 被实现为枚举类型这一事实的直接结果，使用可以用整数值初始化作用域枚举的新方式。<br>也没有隐式转换，因此您必须使用显式转换的整数文字来初始化字节数组：</p><div class="code-wrapper"><pre><code class="hljs c++">std::byte b5[] {<span class="hljs-number">1</span>}; <span class="hljs-comment">// ERROR</span>std::byte b6[] {std::byte{<span class="hljs-number">1</span>}}; <span class="hljs-comment">// OK</span></code></pre></div><p>在没有任何初始化的情况下，堆栈上的对象的 std::byte 的值是未定义的：</p><div class="code-wrapper"><pre><code class="hljs c++">std::byte b; <span class="hljs-comment">// 未定义的值</span></code></pre></div><p>像往常一样（除了原子），您可以通过列表初始化强制将所有位设置为零的初始化：</p><div class="code-wrapper"><pre><code class="hljs c++">std::byte b{}; <span class="hljs-comment">// 与b{0}一样 </span></code></pre></div><p>std::to_integer&lt;&gt;() 提供将字节对象用作整数值（包括 bool 和 char）的能力。 如果没有转换，输出运算符将无法编译。 请注意，因为它是一个模板，您甚至需要使用 std:: 完全限定的转换</p><div class="code-wrapper"><pre><code class="hljs c++">std::cout &lt;&lt; b1; <span class="hljs-comment">// ERROR</span>std::cout &lt;&lt; <span class="hljs-built_in">to_integer</span>&lt;<span class="hljs-type">int</span>&gt;(b1); <span class="hljs-comment">// ERROR (ADL 在这里不起作用)</span>std::cout &lt;&lt; std::<span class="hljs-built_in">to_integer</span>&lt;<span class="hljs-type">int</span>&gt;(b1); <span class="hljs-comment">// OK</span></code></pre></div><p>这样的转换对于使用 std::byte 作为布尔值也是必要的。 例如：</p><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">if</span> (b2) ... <span class="hljs-comment">// ERROR</span><span class="hljs-keyword">if</span> (b2 != std::byte{<span class="hljs-number">0</span>}) ... <span class="hljs-comment">// OK</span><span class="hljs-keyword">if</span> (<span class="hljs-built_in">to_integer</span>&lt;<span class="hljs-type">bool</span>&gt;(b2)) ... <span class="hljs-comment">// ERROR (ADL 在这里不起作用)</span><span class="hljs-keyword">if</span> (std::<span class="hljs-built_in">to_integer</span>&lt;<span class="hljs-type">bool</span>&gt;(b2)) ... <span class="hljs-comment">// OK</span></code></pre></div><p>因为 std::byte 被定义为枚举类型，底层类型为 unsigned char，所以 std::byte 的大小始终为 1：</p><div class="code-wrapper"><pre><code class="hljs c++">std::cout &lt;&lt; <span class="hljs-built_in">sizeof</span>(b); <span class="hljs-comment">// always 1</span></code></pre></div><p>位数取决于 unsigned char 类型的位数，您可以通过标准数字限制找到：</p><div class="code-wrapper"><pre><code class="hljs c++">std::cout &lt;&lt; std::numeric_limits&lt;<span class="hljs-type">unsigned</span> <span class="hljs-type">char</span>&gt;::digits; <span class="hljs-comment">// std::byte 的位数</span></code></pre></div><p>大多数时候是 8，但有些平台并非如此。</p><h4><span id="18-2-std-byte-lei-xing-he-cao-zuo">18.2 std::byte 类型和操作</span><a href="#18-2-std-byte-lei-xing-he-cao-zuo" class="header-anchor">#</a></h4><p>本节详细介绍 std::byte 的类型和操作。</p><h5><span id="18-2-1-std-byte-lei-xing">18.2.1 std::byte 类型</span><a href="#18-2-1-std-byte-lei-xing" class="header-anchor">#</a></h5><p>在头文件 <cstddef> 中，C++ 标准库定义类型 std::byte 如下：</cstddef></p><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">namespace</span> std {    <span class="hljs-keyword">enum class</span> <span class="hljs-title class_">byte</span> : <span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> {    };}</code></pre></div><p>也就是说，std::byte 只不过是一个范围枚举类型，其中定义了一些补充的按位运算符：</p><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">namespace</span> std {    ...    <span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> IntType&gt;    <span class="hljs-keyword">constexpr</span> byte <span class="hljs-keyword">operator</span>&lt;&lt; (byte b, IntType shift) <span class="hljs-keyword">noexcept</span>;    <span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> IntType&gt;    <span class="hljs-keyword">constexpr</span> byte&amp; <span class="hljs-keyword">operator</span>&lt;&lt;= (byte&amp; b, IntType shift) <span class="hljs-keyword">noexcept</span>;    <span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> IntType&gt;    <span class="hljs-keyword">constexpr</span> byte <span class="hljs-keyword">operator</span>&gt;&gt; (byte b, IntType shift) <span class="hljs-keyword">noexcept</span>;    <span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> IntType&gt;    <span class="hljs-keyword">constexpr</span> byte&amp; <span class="hljs-keyword">operator</span>&gt;&gt;= (byte&amp; b, IntType shift) <span class="hljs-keyword">noexcept</span>;    <span class="hljs-keyword">constexpr</span> byte&amp; <span class="hljs-keyword">operator</span>|= (byte&amp; l, byte r) <span class="hljs-keyword">noexcept</span>;    <span class="hljs-keyword">constexpr</span> byte <span class="hljs-keyword">operator</span>| (byte l, byte r) <span class="hljs-keyword">noexcept</span>;    <span class="hljs-keyword">constexpr</span> byte&amp; <span class="hljs-keyword">operator</span>&amp;= (byte&amp; l, byte r) <span class="hljs-keyword">noexcept</span>;    <span class="hljs-keyword">constexpr</span> byte <span class="hljs-keyword">operator</span>&amp; (byte l, byte r) <span class="hljs-keyword">noexcept</span>;    <span class="hljs-keyword">constexpr</span> byte&amp; <span class="hljs-keyword">operator</span>^= (byte&amp; l, byte r) <span class="hljs-keyword">noexcept</span>;    <span class="hljs-keyword">constexpr</span> byte <span class="hljs-keyword">operator</span>^ (byte l, byte r) <span class="hljs-keyword">noexcept</span>;    <span class="hljs-keyword">constexpr</span> byte <span class="hljs-keyword">operator</span>~ (byte b) <span class="hljs-keyword">noexcept</span>;    <span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> IntType&gt;</span><span class="hljs-function">    <span class="hljs-keyword">constexpr</span> IntType <span class="hljs-title">to_integer</span> <span class="hljs-params">(byte b)</span> <span class="hljs-keyword">noexcept</span></span>;}</code></pre></div><h5><span id="18-2-2-std-byte-cao-zuo">18.2.2 std::byte 操作</span><a href="#18-2-2-std-byte-cao-zuo" class="header-anchor">#</a></h5><p>表 std::byte 操作列出了为 std::byte 提供的所有操作。</p><table><thead><tr><th>Operation</th><th>作用</th></tr></thead><tbody><tr><td>constructors</td><td>创建一个字节对象（使用默认构造函数未定义的值）</td></tr><tr><td>destructor</td><td>销毁一个字节对象（什么都不做）</td></tr><tr><td>=</td><td>分配一个新值</td></tr><tr><td>==, !=, &lt;, &lt;=, &gt;, &gt;=</td><td>比较字节对象</td></tr><tr><td>`&lt;&lt;, &gt;&gt;,</td><td>, &amp;, ^, ~`</td></tr><tr><td>`&lt;&lt;=, &gt;&gt;=,</td><td>=, &amp;=, ^=`</td></tr><tr><td>to_integer<t>()</t></td><td>将字节对象转换为整型 T</td></tr><tr><td>sizeof()</td><td>Yields 1</td></tr></tbody></table><h6><span id="zhuan-huan-wei-zheng-xing">转换为整型</span><a href="#zhuan-huan-wei-zheng-xing" class="header-anchor">#</a></h6><p>通过使用 to_integer&lt;&gt;()，您可以将 std::byte 转换为任何基本的整数类型（bool、字符类型或整数类型）。 例如，这是将 std::byte 与数值进行比较或在条件中使用它所必需的：</p><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">if</span> (b2) ... <span class="hljs-comment">// ERROR</span><span class="hljs-keyword">if</span> (b2 != std::byte{<span class="hljs-number">0</span>}) ... <span class="hljs-comment">// OK</span><span class="hljs-keyword">if</span> (<span class="hljs-built_in">to_integer</span>&lt;<span class="hljs-type">bool</span>&gt;(b2)) ... <span class="hljs-comment">// ERROR (ADL 在这里不起作用)</span><span class="hljs-keyword">if</span> (std::<span class="hljs-built_in">to_integer</span>&lt;<span class="hljs-type">bool</span>&gt;(b2)) ... <span class="hljs-comment">// OK</span></code></pre></div><p>另一个使用示例是 std::byte I/O to_integer&lt;&gt;() 使用从 unsigned char 到目标类型的静态转换规则。<br>例如：</p><div class="code-wrapper"><pre><code class="hljs c++">std::byte ff{<span class="hljs-number">0xFF</span>};std::cout &lt;&lt; std::<span class="hljs-built_in">to_integer</span>&lt;<span class="hljs-type">unsigned</span> <span class="hljs-type">int</span>&gt;(ff); <span class="hljs-comment">// 255</span>std::cout &lt;&lt; std::<span class="hljs-built_in">to_integer</span>&lt;<span class="hljs-type">int</span>&gt;(ff); <span class="hljs-comment">// also 255 (没有负值)</span>std::cout &lt;&lt; <span class="hljs-built_in">static_cast</span>&lt;<span class="hljs-type">int</span>&gt;(std::<span class="hljs-built_in">to_integer</span>&lt;<span class="hljs-type">signed</span> <span class="hljs-type">char</span>&gt;(ff)); <span class="hljs-comment">// -1</span></code></pre></div><h6><span id="dai-you-std-byte-de-i-o">带有 std::byte 的 I/O</span><a href="#dai-you-std-byte-de-i-o" class="header-anchor">#</a></h6><p>没有为 std::byte 定义输入和输出运算符，因此您必须将它们转换为整数值：</p><div class="code-wrapper"><pre><code class="hljs c++">std::byte b;...std::cout &lt;&lt; std::<span class="hljs-built_in">to_integer</span>&lt;<span class="hljs-type">int</span>&gt;(b); <span class="hljs-comment">// 将值打印为十进制值</span>std::cout &lt;&lt; std::hex &lt;&lt; std::<span class="hljs-built_in">to_integer</span>&lt;<span class="hljs-type">int</span>&gt;(b); <span class="hljs-comment">// 将值打印为十六进制值</span></code></pre></div><p>通过使用 std::bitset&lt;&gt;，您还可以将值输出为二进制值（位序列）：</p><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bitset&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;limits&gt;</span></span><span class="hljs-keyword">using</span> ByteBitset = std::bitset&lt;std::numeric_limits&lt;<span class="hljs-type">unsigned</span> <span class="hljs-type">char</span>&gt;::digits&gt;;std::cout &lt;&lt; ByteBitset{std::<span class="hljs-built_in">to_integer</span>&lt;<span class="hljs-type">unsigned</span> <span class="hljs-type">char</span>&gt;(b1)};</code></pre></div><p>using 声明定义了一个 bitset 类型，其位数与 std::byte 一样，然后我们创建并输出这样一个用字节的整数类型初始化的对象。<br>您还可以使用它将 std::byte 的二进制表示形式写入字符串：</p><div class="code-wrapper"><pre><code class="hljs c++">std::string s = ByteBitset{std::<span class="hljs-built_in">to_integer</span>&lt;<span class="hljs-type">unsigned</span> <span class="hljs-type">char</span>&gt;(b1)}.<span class="hljs-built_in">to_string</span>();</code></pre></div><p>输入方式类似：只需将值读取为整数、字符串或位集值并进行转换。 例如，您可以编写一个输入运算符，从二进制表示中读取一个字节，如下所示：</p><div class="code-wrapper"><pre><code class="hljs c++">std::istream&amp; <span class="hljs-keyword">operator</span>&gt;&gt; (std::istream&amp; strm, std::byte&amp; b){    <span class="hljs-comment">// 读入 bitset:</span>    std::bitset&lt;std::numeric_limits&lt;<span class="hljs-type">unsigned</span> <span class="hljs-type">char</span>&gt;::digits&gt; bs;    strm &gt;&gt; bs;    <span class="hljs-comment">// 没有失败，转换为 std::byte:</span>    <span class="hljs-keyword">if</span> (! std::cin.<span class="hljs-built_in">fail</span>()) {        b = <span class="hljs-built_in">static_cast</span>&lt;std::byte&gt;(bs.<span class="hljs-built_in">to_ulong</span>()); <span class="hljs-comment">// OK</span>    }    <span class="hljs-keyword">return</span> strm;}</code></pre></div><p>请注意，我们必须使用 static_cast&lt;&gt;() 将 bitset 转换为 unsigned long 转换为 std::byte。 列表初始化不起作用，因为转换范围缩小：</p><div class="code-wrapper"><pre><code class="hljs c++">b = std::byte{bs.<span class="hljs-built_in">to_ulong</span>()}; <span class="hljs-comment">// ERROR: 缩小</span></code></pre></div><p>而且我们没有其他的初始化方式.</p><h4><span id="18-3-hou-ji">18.3 后记</span><a href="#18-3-hou-ji" class="header-anchor">#</a></h4><p>std::byte 最初由 Neil MacIntosh 提出，传入 <a href="https://wg21.link/p0298r0%E3%80%82">https://wg21.link/p0298r0。</a> 最终接受的措辞由 Neil MacIntosh 在 <a href="https://wg21.link/p0298r3">https://wg21.link/p0298r3</a> 中制定。</p><h3><span id="19-string-views">19 String Views</span><a href="#19-string-views" class="header-anchor">#</a></h3><p>在 C++17 中，C++ 标准库采用了一个特殊的字符串类，它允许我们处理像字符串这样的字符序列，而无需为它们分配内存：std::string_view。<br>也就是说，std::string_view 对象引用外部字符序列而不拥有它们。<br>也就是说，对象可以被认为是对字符序列的引用。</p><p><img src="C:\string_view.png" alt="string_view"></p><p>使用这样的字符串视图既便宜又快速（按值传递 string_view 总是很便宜）。 然而，它也有潜在的危险，因为与原始指针类似，程序员需要确保在使用 string_view 时引用的字符序列仍然有效）。</p><h4><span id="19-1-yu-std-string-de-qu-bie">19.1 与 std::string 的区别</span><a href="#19-1-yu-std-string-de-qu-bie" class="header-anchor">#</a></h4><p>与 std::string 相比，std::string_view 对象具有以下属性：</p><ul><li><p>底层字符序列是只读的。 没有允许修改字符的操作。 您只能分配新值、交换值以及删除开头或结尾的字符。</p></li><li><p>不保证字符序列以空值结尾。 因此，字符串视图不是以空结尾的字节流 (NTBS)。</p></li><li><p>该值可以是 nullptr，例如在使用默认构造函数初始化字符串视图后由 data() 返回。</p></li><li><p>没有分配器支持。<br>由于可能的 nullptr 值和可能缺少的 null 终止符，您应该始终在通过 operator[] 或 data() 访问字符之前使用 size() （除非您知道得更好）。</p></li></ul><h4><span id="19-2-shi-yong-string-views">19.2 使用 String Views</span><a href="#19-2-shi-yong-string-views" class="header-anchor">#</a></h4><p>字符串视图有两个主要应用：</p><ol><li><p>您可能已经使用字符序列或字符串分配或映射数据，并希望在不分配更多内存的情况下使用这些数据。典型的例子是使用内存映射文件或处理大文本中的子字符串。   </p></li><li><p>您想提高接收字符串的函数/操作的性能，只是直接以只读方式处理它们，不需要尾随的空终止符。<br>这种情况的一种特殊形式可能是将字符串文字处理为具有类似于字符串的 API 的对象：</p></li></ol><div class="code-wrapper"><pre><code class="hljs C++"><span class="hljs-type">static</span> <span class="hljs-keyword">constexpr</span> std::string_view hello{<span class="hljs-string">"hello world"</span>};</code></pre></div><p>第一个示例通常意味着通常只传递字符串视图，而编程逻辑必须确保底层字符序列保持有效（即，映射的文件内容未被取消映射）。在任何时候，您都可以使用字符串视图来初始化或将它们的值分配给 std::string。</p><p>但请注意，使用字符串视图就像“更好的字符串”一样。这可能会导致更差的性能和严重的运行时错误。因此，请仔细阅读以下小节。</p><h4><span id="19-3-shi-yong-yu-zi-fu-chuan-xiang-si-de-zi-fu-chuan-shi-tu">19.3 使用与字符串相似的字符串视图</span><a href="#19-3-shi-yong-yu-zi-fu-chuan-xiang-si-de-zi-fu-chuan-shi-tu" class="header-anchor">#</a></h4><p>第一个示例，使用像只读字符串一样的 string_view，是一个打印带有作为字符串视图传递的前缀的元素集合的函数： </p><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string_view&gt;</span></span><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;</span><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">printElems</span><span class="hljs-params">(<span class="hljs-type">const</span> T&amp; coll, std::string_view prefix = std::string_view{})</span></span><span class="hljs-function"></span>{    <span class="hljs-keyword">for</span> (<span class="hljs-type">const</span> <span class="hljs-keyword">auto</span>&amp; elem : coll) {        <span class="hljs-keyword">if</span> (prefix.<span class="hljs-built_in">data</span>()) { <span class="hljs-comment">// 检查 nullptr</span>            std::cout &lt;&lt; prefix &lt;&lt; <span class="hljs-string">' '</span>;        }        std::cout &lt;&lt; elem &lt;&lt; <span class="hljs-string">'\n'</span>;    }}</code></pre></div><p>在这里，仅通过声明函数将采用 std::string_view，与采用 std::string 的函数相比，我们可以节省分配堆内存的调用。 详细信息取决于是否传递了短字符串以及是否使用了短字符串优化 (SSO)。 例如，如果我们将函数声明如下：</p><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;</span><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">printElems</span><span class="hljs-params">(<span class="hljs-type">const</span> T&amp; coll, <span class="hljs-type">const</span> std::string&amp; prefix = std::string{})</span></span>;</code></pre></div><p>我们传递一个字符串文字，调用会创建一个临时字符串，它将分配内存，除非字符串很短并且使用了短字符串优化。 通过使用字符串视图，不需要分配，因为字符串视图只引用字符串文字。</p><p>但是，请注意，在使用字符串视图的任何未知值之前，必须根据 nullptr 检查 data()。</p><p>另一个示例，使用像只读字符串一样的 string_view，是 std::optional&lt;&gt; 的 asInt() 示例的改进版本，它是为字符串参数声明的：</p><p><code>lib/asint.cpp </code></p><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;optional&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string_view&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;charconv&gt;</span> <span class="hljs-comment">// 对于 from_chars()</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><span class="hljs-comment">// 如果可能，将字符串转换为 int:</span><span class="hljs-function">std::optional&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">asInt</span><span class="hljs-params">(std::string_view sv)</span></span><span class="hljs-function"></span>{    <span class="hljs-type">int</span> val;    <span class="hljs-comment">// 将字符序列读入 int:</span>    <span class="hljs-keyword">auto</span> [ptr, ec] = std::<span class="hljs-built_in">from_chars</span>(sv.<span class="hljs-built_in">data</span>(), sv.<span class="hljs-built_in">data</span>()+sv.<span class="hljs-built_in">size</span>(),                                     val);    <span class="hljs-comment">// 如果我们有错误代码，则不返回任何值:</span>    <span class="hljs-keyword">if</span> (ec != std::errc{}) {        <span class="hljs-keyword">return</span> std::<span class="hljs-literal">nullopt</span>;    }    <span class="hljs-keyword">return</span> val;}<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>{    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> s : {<span class="hljs-string">"42"</span>, <span class="hljs-string">" 077"</span>, <span class="hljs-string">"hello"</span>, <span class="hljs-string">"0x33"</span>} ) {        <span class="hljs-comment">// 如果可能，尝试将 s 转换为 int 并打印结果:</span>        std::optional&lt;<span class="hljs-type">int</span>&gt; oi = <span class="hljs-built_in">asInt</span>(s);        <span class="hljs-keyword">if</span> (oi) {            std::cout &lt;&lt; <span class="hljs-string">"convert '"</span> &lt;&lt; s &lt;&lt; <span class="hljs-string">"' to int: "</span> &lt;&lt; *oi &lt;&lt; <span class="hljs-string">"\n"</span>;        }        <span class="hljs-keyword">else</span> {            std::cout &lt;&lt; <span class="hljs-string">"can't convert '"</span> &lt;&lt; s &lt;&lt; <span class="hljs-string">"' to int\n"</span>;        }    }}</code></pre></div><p>现在， asInt() 按值获取字符串视图。但是，这会产生重大影响。首先，使用 std::stoi() 创建整数不再有意义，因为 stoi() 接受一个字符串，而从字符串视图创建一个字符串是一项相对昂贵的操作。</p><p>相反，我们将字符串视图的字符范围传递给新的标准库函数 std::from_chars()。它需要一对原始字符指针来转换字符的开头和结尾。请注意，这意味着我们可以跳过对空字符串视图的任何特殊处理，其中 data() 为 nullptr 且 size() 为 0，因为从 nullptr 到 nullptr+0 的范围是有效的空范围（对于添加的任何指针类型0 受支持且无效）。</p><p>std_from_chars() 返回一个 std::from_chars_result，它是一个具有两个成员的结构，一个指向未处理的第一个字符的指针 ptr 和一个 std::errc ec，其中 std::errc 表示没有错误。因此，在使用返回值的 ec 成员（使用结构化绑定）初始化 ec 后，如果转换失败，则以下检查返回 nullopt：</p><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">if</span> (ec != std::errc{}) {    <span class="hljs-keyword">return</span> std::<span class="hljs-literal">nullopt</span>;}</code></pre></div><p>在对子字符串进行排序时，使用字符串视图还可以显着提高性能。</p><h5><span id="19-3-1-bei-ren-wei-shi-you-hai-de-zi-fu-chuan-shi-tu">19.3.1 被认为是有害的字符串视图</span><a href="#19-3-1-bei-ren-wei-shi-you-hai-de-zi-fu-chuan-shi-tu" class="header-anchor">#</a></h5><p>通常，诸如智能指针之类的“智能对象”被认为比相应的语言功能更安全（或至少不更危险）。 因此，给人的印象可能是字符串视图（一种字符串引用）更安全，或者至少与使用字符串引用一样安全。 但不幸的是，事实并非如此。 字符串视图实际上比字符串引用或智能指针更危险。<br>它们的行为更像原始字符指针。</p><h6><span id="bu-yao-jiang-zi-fu-chuan-fen-pei-gei-zi-fu-chuan-shi-tu">不要将字符串分配给字符串视图</span><a href="#bu-yao-jiang-zi-fu-chuan-fen-pei-gei-zi-fu-chuan-shi-tu" class="header-anchor">#</a></h6><p>考虑我们声明一个返回新字符串的函数：</p><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-function">std::string <span class="hljs-title">retString</span><span class="hljs-params">()</span></span>;</code></pre></div><p>使用返回值通常很安全：</p><ul><li><p>将其分配给使用 auto 声明的字符串或对象是安全的（但可以移动，这通常是可以的，但没有最佳性能）：</p><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">auto</span> std::string s1 = <span class="hljs-built_in">retString</span>(); <span class="hljs-comment">// safe</span></code></pre></div></li><li><p>如果可能的话，将返回值分配给字符串引用是非常安全的，只要我们在本地使用该对象，因为引用会将返回值的生命周期延长到其生命周期的末尾：</p><div class="code-wrapper"><pre><code class="hljs c++">std::string&amp; s2 = <span class="hljs-built_in">retString</span>(); <span class="hljs-comment">// 编译时错误（缺少常量）</span><span class="hljs-type">const</span> std::string&amp; s3 = <span class="hljs-built_in">retString</span>(); <span class="hljs-comment">// s3 延长返回字符串的生命周期</span>std::cout &lt;&lt; s3 &lt;&lt; <span class="hljs-string">'\n'</span>; <span class="hljs-comment">// OK</span><span class="hljs-keyword">auto</span>&amp;&amp; s4 = <span class="hljs-built_in">retString</span>(); <span class="hljs-comment">// s4 延长返回字符串的生命周期</span>std::cout &lt;&lt; <span class="hljs-number">4</span> &lt;&lt; <span class="hljs-string">'\n'</span>; <span class="hljs-comment">// OK</span></code></pre></div></li></ul><p>对于字符串视图，没有给出这种安全性。 它既不复制也不延长返回值的生命周期：</p><div class="code-wrapper"><pre><code class="hljs c++">std::string_view sv = <span class="hljs-built_in">retString</span>(); <span class="hljs-comment">// sv 不会延长返回字符串的生命周期</span>std::cout &lt;&lt; sv &lt;&lt; <span class="hljs-string">'\n'</span>; <span class="hljs-comment">// 运行时错误：返回的字符串被破坏</span></code></pre></div><p>在这里，返回的字符串在第一条语句的末尾被破坏，因此从字符串视图 sv 中引用它是一个致命的运行时错误，导致未定义的行为。<br>问题与调用时相同：</p><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-type">const</span> <span class="hljs-type">char</span>* p = <span class="hljs-built_in">retString</span>().<span class="hljs-built_in">c_str</span>();</code></pre></div><p>或者：</p><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">auto</span> p = <span class="hljs-built_in">retString</span>().<span class="hljs-built_in">c_str</span>();</code></pre></div><p>出于这个原因，您还应该非常小心地返回一个字符串视图：</p><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-comment">// 非常危险:</span><span class="hljs-function">std::string_view <span class="hljs-title">substring</span><span class="hljs-params">(<span class="hljs-type">const</span> std::string&amp;, std::<span class="hljs-type">size_t</span> idx = <span class="hljs-number">0</span>)</span></span>;<span class="hljs-comment">// 因为:</span><span class="hljs-keyword">auto</span> sub = <span class="hljs-built_in">substring</span>(<span class="hljs-string">"very nice"</span>, <span class="hljs-number">5</span>); <span class="hljs-comment">// 将视图返回到传递的临时字符串</span><span class="hljs-comment">// 但调用后临时字符串被破坏</span>std::cout &lt;&lt; sub &lt;&lt; <span class="hljs-string">'\n'</span>; <span class="hljs-comment">// 运行时错误：tmp 字符串已被破坏</span></code></pre></div><h6><span id="bu-yao-jiang-zi-fu-chuan-shi-tu-fan-hui-gei-zi-fu-chuan">不要将字符串视图返回给字符串</span><a href="#bu-yao-jiang-zi-fu-chuan-shi-tu-fan-hui-gei-zi-fu-chuan" class="header-anchor">#</a></h6><p>尤其是让字符串成员的 getter 返回字符串视图是一种非常危险的设计。 因此，您不应执行以下操作：</p><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span> {    std::string name;<span class="hljs-keyword">public</span>:    <span class="hljs-built_in">Person</span> (std::string n) : name{std::<span class="hljs-built_in">move</span>(n)} {    }    <span class="hljs-function">std::string_view <span class="hljs-title">getName</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>{ <span class="hljs-comment">// don’t do this</span>        <span class="hljs-keyword">return</span> name;    }};</code></pre></div><p>因为，同样，以下结果将成为致命的运行时错误，导致未定义的行为：</p><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-function">Person <span class="hljs-title">createPerson</span><span class="hljs-params">()</span></span>;<span class="hljs-keyword">auto</span> n = <span class="hljs-built_in">createPerson</span>().<span class="hljs-built_in">getName</span>(); <span class="hljs-comment">// OOPS：删除临时字符串</span>std::cout &lt;&lt; <span class="hljs-string">"name: "</span> &lt;&lt; n &lt;&lt; <span class="hljs-string">'\n'</span>; <span class="hljs-comment">// 致命的运行时错误</span></code></pre></div><p>如果 getName() 按值或按引用返回字符串，这又是一个问题。</p><h6><span id="han-shu-mo-ban-ying-gai-shi-yong-fan-hui-lei-xing-auto">函数模板应该使用返回类型 auto</span><a href="#han-shu-mo-ban-ying-gai-shi-yong-fan-hui-lei-xing-auto" class="header-anchor">#</a></h6><p>请注意，很容易意外地将返回的字符串分配给字符串视图。 例如，考虑两个单独看起来非常有用的函数的定义：</p><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-comment">// 为返回字符串的字符串视图定义 +:</span>std::string <span class="hljs-keyword">operator</span>+ (std::string_view sv1, std::string_view sv2) {    <span class="hljs-keyword">return</span> std::<span class="hljs-built_in">string</span>(sv1) + std::<span class="hljs-built_in">string</span>(sv2);}<span class="hljs-comment">// 泛型串联:</span><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;</span><span class="hljs-function">T <span class="hljs-title">concat</span> <span class="hljs-params">(<span class="hljs-type">const</span> T&amp; x, <span class="hljs-type">const</span> T&amp; y)</span> </span>{    <span class="hljs-keyword">return</span> x + y;}</code></pre></div><p>但是，再次将它们一起使用可能很容易导致致命的运行时错误：</p><div class="code-wrapper"><pre><code class="hljs c++">std::string_view hi = <span class="hljs-string">"hi"</span>;<span class="hljs-keyword">auto</span> xy = <span class="hljs-built_in">concat</span>(hi, hi); <span class="hljs-comment">// xy 是 std::string_view</span>std::cout &lt;&lt; xy &lt;&lt; <span class="hljs-string">'\n'</span>; <span class="hljs-comment">// 致命的运行时错误：引用的字符串被破坏</span></code></pre></div><p>这样的代码很容易被意外编写。 这里真正的问题是 concat() 的返回类型。 如果声明它的返回类型由编译器推断，上面的示例将 xy 初始化为 std::string：</p><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-comment">// 改进的通用连接:</span><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;</span><span class="hljs-function"><span class="hljs-keyword">auto</span> <span class="hljs-title">concat</span> <span class="hljs-params">(<span class="hljs-type">const</span> T&amp; x, <span class="hljs-type">const</span> T&amp; y)</span> </span>{    <span class="hljs-keyword">return</span> x + y;}</code></pre></div><p>此外，在调用链中使用字符串视图会适得其反，因为在调用链中或在其末尾需要字符串。 例如，如果您使用以下构造函数定义类 Person：</p><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span> {    std::string name;<span class="hljs-keyword">public</span>:    <span class="hljs-built_in">Person</span> (std::string_view n) : name{n} {    }    ...};</code></pre></div><p>传递您仍然需要的字符串文字或字符串很好：</p><div class="code-wrapper"><pre><code class="hljs c++">Person p1{<span class="hljs-string">"Jim"</span>}; <span class="hljs-comment">// 没有性能开销</span>std::string s = <span class="hljs-string">"Joe"</span>;Person p2{s}; <span class="hljs-comment">// 没有性能开销</span></code></pre></div><p>但是在字符串中移动变得不必要的昂贵，因为传递的字符串首先被隐式转换为字符串视图，然后用于创建一个新的字符串再次分配内存：</p><div class="code-wrapper"><pre><code class="hljs c++">Person p3{std::<span class="hljs-built_in">move</span>(s)}; <span class="hljs-comment">// 性能开销：移动损坏</span></code></pre></div><p>不要在这里处理 std::string_view 。 按值取参数并将其移动到成员仍然是最好的解决方案。 因此，构造函数和 getter 应该如下所示：</p><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span> {    std::string name;<span class="hljs-keyword">public</span>:    <span class="hljs-built_in">Person</span> (std::string n) : name{std::<span class="hljs-built_in">move</span>(n)} {    }    <span class="hljs-function">std::string <span class="hljs-title">getName</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>{        <span class="hljs-keyword">return</span> name;    }};</code></pre></div><h6><span id="zi-fu-chuan-shi-tu-de-an-quan-shi-yong-zong-jie">字符串视图的安全使用总结</span><a href="#zi-fu-chuan-shi-tu-de-an-quan-shi-yong-zong-jie" class="header-anchor">#</a></h6><p>总而言之，请谨慎使用 std::string_view，这意味着您还应该更改<br>您编程的一般风格：</p><ul><li>不要在 API 中使用将参数传递给字符串的字符串视图。<br>– 不要从字符串视图参数初始化字符串成员。<br>– 字符串视图链的末尾没有字符串。</li><li>不要返回字符串视图。<br>– 除非它只是一个转发的输入参数，或者您通过例如相应地命名函数来发出危险信号。</li><li>出于这个原因，函数模板永远不应该返回传递的泛型参数的类型 T。<br>– 改为返回 auto。</li><li>永远不要使用返回值来初始化字符串视图。</li><li>出于这个原因，不要将返回泛型类型的函数模板的返回值分配给 auto。<br>– 这意味着，AAA（几乎总是自动）模式被字符串视图打破。<br>如果这些规则太复杂或难以遵循，请不要使用 std::string_view （除非您知道自己在做什么）。</li></ul><h4><span id="19-4-string-view-lei-xing-he-cao-zuo">19.4 String View 类型和操作</span><a href="#19-4-string-view-lei-xing-he-cao-zuo" class="header-anchor">#</a></h4><p>本节详细介绍字符串视图的类型和操作。</p><h5><span id="19-4-1-ju-ti-zi-fu-chuan-shi-tu-lei-xing">19.4.1 具体字符串视图类型</span><a href="#19-4-1-ju-ti-zi-fu-chuan-shi-tu-lei-xing" class="header-anchor">#</a></h5><p>在头文件 <string_view> 中，C++ 标准库提供了一些类 basic_string_view&lt;&gt; 的特化：</string_view></p><ul><li>类 std::string_view 是该模板的预定义特化，用于 char 类型的字符：</li></ul><div class="code-wrapper"><pre><code class="hljs C++"><span class="hljs-keyword">namespace</span> std {    <span class="hljs-keyword">using</span> string_view = basic_string_view&lt;<span class="hljs-type">char</span>&gt;;}</code></pre></div><ul><li>对于使用更广泛字符集（例如 Unicode 或某些亚洲字符集）的字符串，预定义了其他三种类型：</li></ul><div class="code-wrapper"><pre><code class="hljs C++"><span class="hljs-keyword">namespace</span> std {    <span class="hljs-keyword">using</span> u16string_view = basic_string_view&lt;<span class="hljs-type">char16_t</span>&gt;;    <span class="hljs-keyword">using</span> u32string_view = basic_string_view&lt;<span class="hljs-type">char32_t</span>&gt;;    <span class="hljs-keyword">using</span> wstring_view = basic_string_view&lt;<span class="hljs-type">wchar_t</span>&gt;;}</code></pre></div><p>在以下部分中，这些类型的字符串视图之间没有区别。用法和问题是相同的，因为所有字符串视图类都具有相同的接口。因此，“字符串视图”表示任何字符串视图类型：string_view、u16string_view、u32string_view 和 wstring_view。本书中的示例通常使用 string_view 类型，因为欧洲和英美环境是软件开发的常见环境。</p><h5><span id="19-4-2-zi-fu-chuan-shi-tu-cao-zuo">19.4.2 字符串视图操作</span><a href="#19-4-2-zi-fu-chuan-shi-tu-cao-zuo" class="header-anchor">#</a></h5><p>表字符串视图操作列出了为字符串视图提供的所有操作。<br>除了 remove_prefix() 和 remove_suffix() 之外，还为 std::strings 提供了字符串视图的所有操作。 但是，保证可能略有不同，因为对于字符串视图， data() 返回的值可能是 nullptr 并且缺少保证以空终止符结束序列。</p><table><thead><tr><th>操作</th><th>作用</th></tr></thead><tbody><tr><td>constructors</td><td>创建或复制字符串视图</td></tr><tr><td>destructor</td><td>销毁字符串视图</td></tr><tr><td>=</td><td>分配一个新值</td></tr><tr><td>swap()</td><td>在两个字符串视图之间交换值</td></tr><tr><td>==, !=, &lt;, &lt;=, &gt;, &gt;=, compare()</td><td>比较字符串视图</td></tr><tr><td>empty()</td><td>返回字符串视图是否为空</td></tr><tr><td>size(), length()</td><td>返回字符数</td></tr><tr><td>max_size()</td><td>返回最大可能的字符数</td></tr><tr><td>[], at()</td><td>访问一个字符</td></tr><tr><td>front(), back()</td><td>访问第一个或最后一个字符</td></tr><tr><td>&lt;&lt;</td><td>将值写入流</td></tr><tr><td>copy()</td><td>将内容复制或写入字符数组</td></tr><tr><td>data()</td><td>将值作为 nullptr 或常量字符返回，数组（注意：没有终止空字符）</td></tr><tr><td>find functions</td><td>搜索某个子字符串或字符</td></tr><tr><td>begin(), end()</td><td>提供正常的迭代器支持</td></tr><tr><td>cbegin(), cend()</td><td>提供常量迭代器支持</td></tr><tr><td>rbegin(), rend()</td><td>提供反向迭代器支持</td></tr><tr><td>crbegin(), crend()</td><td>提供常量反向迭代器支持</td></tr><tr><td>substr()</td><td>返回某个子字符串</td></tr><tr><td>remove_prefix()</td><td>删除前导字符</td></tr><tr><td>remove_suffix()</td><td>删除尾随字符</td></tr><tr><td>hash&lt;&gt;</td><td>计算哈希值的函数对象类型</td></tr></tbody></table><h6><span id="gou-zao">构造</span><a href="#gou-zao" class="header-anchor">#</a></h6><p>您可以使用默认构造函数创建字符串视图，作为副本，从原始字符数组（以 null 终止或具有指定长度），从 std::string 或作为带有后缀 sv 的文字。 但是，请注意以下几点：</p><ul><li><p>使用默认构造函数创建的字符串视图将 nullptr 作为 data()。 因此，没有有效的 operator[] 调用。</p><div class="code-wrapper"><pre><code class="hljs c++">std::string_view sv;<span class="hljs-keyword">auto</span> p = sv.<span class="hljs-built_in">data</span>(); <span class="hljs-comment">// 产生 nullptr</span>std::cout &lt;&lt; sv[<span class="hljs-number">0</span>]; <span class="hljs-comment">// ERROR: 没有有效字符</span></code></pre></div></li><li><p>当通过空终止字节流初始化字符串视图时，结果大小是不带 ‘\0’ 的字符数，并且使用终止空字符的索引是无效的：</p><div class="code-wrapper"><pre><code class="hljs c++">std::string_view sv{<span class="hljs-string">"hello"</span>};std::cout &lt;&lt; sv; <span class="hljs-comment">// OK</span>std::cout &lt;&lt; sv.<span class="hljs-built_in">size</span>(); <span class="hljs-comment">// 5</span>std::cout &lt;&lt; sv.<span class="hljs-built_in">at</span>(<span class="hljs-number">5</span>); <span class="hljs-comment">// 抛出 std::out_of_range 异常</span>std::cout &lt;&lt; sv[<span class="hljs-number">5</span>]; <span class="hljs-comment">// 未定义的行为，但在这里它通常有效</span>std::cout &lt;&lt; sv.<span class="hljs-built_in">data</span>(); <span class="hljs-comment">// 未定义的行为，但在这里它通常有效</span></code></pre></div><p>最后两个调用是形式上未定义的行为。 因此，它们不能保证工作，尽管在这种情况下您可以假设在最后一个字符之后有空终止符。<br>您可以通过传递包括空终止符在内的字符数来初始化具有空终止符作为其值的一部分的字符串视图：</p><div class="code-wrapper"><pre><code class="hljs c++">std::string_view sv{<span class="hljs-string">"hello"</span>, <span class="hljs-number">6</span>}; <span class="hljs-comment">// <span class="hljs-doctag">NOTE:</span> 6 to include ’\0’</span>std::cout &lt;&lt; sv.<span class="hljs-built_in">size</span>(); <span class="hljs-comment">// 6</span>std::cout &lt;&lt; sv.<span class="hljs-built_in">at</span>(<span class="hljs-number">5</span>); <span class="hljs-comment">// OK, 打印  ’\0’的值</span>std::cout &lt;&lt; sv[<span class="hljs-number">5</span>]; <span class="hljs-comment">// OK, 打印 '\0' 的值</span>std::cout &lt;&lt; sv.<span class="hljs-built_in">data</span>(); <span class="hljs-comment">// OK</span></code></pre></div></li><li><p>要从 std::string 创建字符串视图，std::string 类中提供了隐式转换运算符。 同样，在最后一个字符之后有空终止符，通常保证字符串，不保证字符串视图存在：</p><div class="code-wrapper"><pre><code class="hljs c++">std::string s = <span class="hljs-string">"hello"</span>;std::cout &lt;&lt; s.<span class="hljs-built_in">size</span>(); <span class="hljs-comment">// 5</span>std::cout &lt;&lt; s.<span class="hljs-built_in">at</span>(<span class="hljs-number">5</span>); <span class="hljs-comment">// OK, 打印 '\0' 的值</span>std::cout &lt;&lt; s[<span class="hljs-number">5</span>]; <span class="hljs-comment">// OK, 打印 '\0' 的值</span>std::string_view sv{s};std::cout &lt;&lt; sv.<span class="hljs-built_in">size</span>(); <span class="hljs-comment">// 5</span>std::cout &lt;&lt; sv.<span class="hljs-built_in">at</span>(<span class="hljs-number">5</span>); <span class="hljs-comment">// 抛出 std::out_of_range 异常</span>std::cout &lt;&lt; sv[<span class="hljs-number">5</span>]; <span class="hljs-comment">// 未定义的行为，但在这里它通常有效</span>std::cout &lt;&lt; sv.<span class="hljs-built_in">data</span>(); <span class="hljs-comment">// 未定义的行为，但在这里它通常有效</span></code></pre></div></li><li><p>由于为后缀 sv 定义了文字运算符，因此您还可以创建一个字符串视图，如下所示：</p><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std::literals;<span class="hljs-keyword">auto</span> s = <span class="hljs-string">"hello"</span>sv;</code></pre></div></li></ul><p>这里的关键点是，通常你不应该期望空终止字符并且在访问字符之前总是使用 size() （除非你知道关于值的具体事情）。</p><p>作为一种解决方法，您可以将 ‘\0’ 作为字符串视图的一部分，但您不应该使用字符串视图作为空终止字符串，而空终止符不是它的一部分，即使空终止符就在后面。</p><h6><span id="san-lie">散列</span><a href="#san-lie" class="header-anchor">#</a></h6><p>C++ 标准库保证字符串和字符串视图的哈希值是相等的。</p><h6><span id="xiu-gai-zi-fu-chuan-shi-tu">修改字符串视图</span><a href="#xiu-gai-zi-fu-chuan-shi-tu" class="header-anchor">#</a></h6><p>只提供了几个操作来修改字符串视图：</p><ul><li><p>您可以分配一个新值或交换两个字符串视图的值：</p><div class="code-wrapper"><pre><code class="hljs c++">std::string_view sv1 = <span class="hljs-string">"hey"</span>;std::string_view sv2 = <span class="hljs-string">"world"</span>;sv1.<span class="hljs-built_in">swap</span>(sv2);sv2 = sv1;</code></pre></div></li><li><p>您可以跳过前导或尾随字符（即，将开头移动到第一个字符后面的字符或将结尾移动到最后一个字符之前的字符）。</p><div class="code-wrapper"><pre><code class="hljs c++">std::string_view sv = <span class="hljs-string">"I like my kindergarten"</span>;sv.<span class="hljs-built_in">remove_prefix</span>(<span class="hljs-number">2</span>);sv.<span class="hljs-built_in">remove_suffix</span>(<span class="hljs-number">8</span>);std::cout &lt;&lt; sv; <span class="hljs-comment">// prints: like my kind</span></code></pre></div></li></ul><p>​    请注意，不支持 operator+。 因此：</p><div class="code-wrapper"><pre><code class="hljs c++">std::string_view sv1 = <span class="hljs-string">"hello"</span>;std::string_view sv2 = <span class="hljs-string">"world"</span>;<span class="hljs-keyword">auto</span> s1 = sv1 + sv2; <span class="hljs-comment">// ERROR</span></code></pre></div><p>其中一个操作数必须是字符串：</p><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">auto</span> s2 = std::<span class="hljs-built_in">string</span>(sv1) + sv2; <span class="hljs-comment">// OK</span></code></pre></div><p>请注意，没有隐式转换为字符串，因为这是一项昂贵的操作，因为它可能会分配内存。 因此，只能进行显式转换。</p><h5><span id="19-4-3-qi-ta-lei-xing-de-zi-fu-chuan-shi-tu-zhi-chi">19.4.3 其他类型的字符串视图支持</span><a href="#19-4-3-qi-ta-lei-xing-de-zi-fu-chuan-shi-tu-zhi-chi" class="header-anchor">#</a></h5><p>原则上，可以传递字符串的每个地方也传递字符串视图是有意义的，期望接收者何时需要将该值以空值终止（例如，通过将值传递给字符串的 C 函数）。</p><p>​    但是，到目前为止，我们只添加了对最重要的地方的支持：</p><ul><li>字符串可以在有用的地方使用或与字符串视图结合使用。 您可以从中创建一个字符串（构造函数是显式的）、分配、追加、插入、替换、比较或通过传递字符串视图来查找子字符串。<br>还有从字符串到字符串视图的隐式转换。</li><li>你可以将一个字符串视图传递给std::quoted，它可以打印出其带引号的值。比如说:</li></ul><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std::literals;<span class="hljs-keyword">auto</span> s = <span class="hljs-string">R""(some\value) "sv; // 原始字符串视图</span><span class="hljs-string">std::cout &lt;&lt; std::quoted(s); // 输出。"some\value"</span><span class="hljs-string"></span></code></pre></div><ul><li>你可以用字符串视图初始化、扩展或比较文件系统路径。</li></ul><p>但是，例如，在C++标准库的regex组件中还没有对字符串视图的支持。标准库中，还没有对字符串视图的支持。</p><h4><span id="19-5-shi-yong-string-views-in-api-s">19.5 使用 String Views in API’s</span><a href="#19-5-shi-yong-string-views-in-api-s" class="header-anchor">#</a></h4><p>字符串视图很便宜，每个std::string都可以作为一个字符串视图使用。所以，似乎std::string_view是处理字符串参数的更好的类型。嗯，细节很重要…<br>首先，使用std::string_view只有在使用该参数的函数具有以下条件时才有意义<br>以下的限制条件时，使用std::string_view才有意义。</p><ul><li><p>它不期望在结尾处有一个空的终结符。例如，当把参数作为一个单一的const char*传递给C函数时，情况就不是这样了。</p></li><li><p>它尊重所传递参数的生命周期。通常这意味着接收函数只使用传递的值，直到它结束。</p></li><li><p>调用函数不应该处理底层字符的所有者（比如删除它，改变它的值，或者释放它的内存）。</p></li><li><p>它可以将nullptr作为值来处理。<br>请注意，如果你同时为std::string和std::string_view的函数重载，可能会出现歧义错误。std::string_view。</p><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">foo</span><span class="hljs-params">(<span class="hljs-type">const</span> std::string&amp;)</span></span>;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">foo</span><span class="hljs-params">(std::string_view)</span></span>;<span class="hljs-built_in">foo</span>(<span class="hljs-string">"hello"</span>); <span class="hljs-comment">// ERROR: 模糊的</span></code></pre></div></li></ul><h5><span id="19-5-1-shi-yong-yong-yu-chu-shi-hua-zi-fu-chuan-de-zi-fu-chuan-shi-tu">19.5.1 使用用于初始化字符串的字符串视图</span><a href="#19-5-1-shi-yong-yong-yu-chu-shi-hua-zi-fu-chuan-de-zi-fu-chuan-shi-tu" class="header-anchor">#</a></h5><p>看起来字符串视图的一个简单而有用的应用是在初始化字符串时将其声明为参数类型 当初始化一个字符串时。但是要注意!</p><p>考虑用 “老办法 “来初始化一个字符串成员。</p><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span> {    std::string name;<span class="hljs-keyword">public</span>:    <span class="hljs-built_in">Person</span> (<span class="hljs-type">const</span> std::string&amp; n) : <span class="hljs-built_in">name</span>(n) {    }    ...};</code></pre></div><p>这个构造函数有其缺点。用一个字符串字头初始化一个人，会产生一个不必要的拷贝，这可能会导致对堆内存的不必要的请求。比如说:</p><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-function">Person <span class="hljs-title">p</span><span class="hljs-params">(<span class="hljs-string">"Aprettylong NonSSO Name"</span>)</span></span>;</code></pre></div><p>首先调用 std::string 构造函数来创建临时参数 n，因为请求了 std::string 类型的引用。 如果字符串很长或没有启用短字符串优化，这意味着为字符串值分配堆内存。 即使使用移动语义，临时字符串也会被复制以初始化成员名称，这意味着再次分配内存。<br>您只能通过添加更多构造函数重载或引入模板构造函数来避免这种开销，这可能会导致其他问题。<br>相反，如果我们使用字符串视图，性能会更好：</p><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span> {    std::string name;<span class="hljs-keyword">public</span>:    <span class="hljs-built_in">Person</span> (std::string_view n) : <span class="hljs-built_in">name</span>(n) {    }    ...};</code></pre></div><p>现在，一个临时的字符串视图n被创建，它根本不分配内存，因为字符串视图只引用了字符串字面的字符。只有name的初始化为成员name分配了一次内存。</p><p>然而，有一个问题：如果你传递一个临时字符串或用std::move()标记的字符串，该字符串被转换为字符串视图的类型（这很便宜），然后字符串视图被用来为新字符串分配内存（这很昂贵）。换句话说。使用字符串视图会禁用移动语义，除非你为它提供一个额外的重载。</p><p>对于如何初始化带有字符串成员的对象，仍然有明确的建议。以 字符串的值和移动。</p><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span> {    std::string name;<span class="hljs-keyword">public</span>:    <span class="hljs-built_in">Person</span> (std::string n) : <span class="hljs-built_in">name</span>(std::<span class="hljs-built_in">move</span>(n)) {    }    ...};</code></pre></div><p>无论如何，我们必须创建一个字符串。因此，尽快创建它可以使我们在传递参数的那一刻就能从所有可能的优化中受益。当我们拥有它时，我们只需移动，这是一个廉价的操作。</p><p>如果我们通过一个返回临时字符串的辅助函数来初始化这个字符串:</p><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-function">std::string <span class="hljs-title">newName</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>{    ...;    <span class="hljs-keyword">return</span> std::string{...};}Person p{<span class="hljs-built_in">newName</span>()};</code></pre></div><p>强制性的复制消除将推迟新字符串的物化，直到该值被传递给构造函数。在那里我们有一个名为n的字符串，这样我们就有了一个有位置的对象（一个glvalue）。<br>然后这个对象的值被移动到初始化成员名。<br>这个例子再次证明了。</p><ul><li>字符串视图并不是一个更好的取用字符串的接口。</li><li>事实上，字符串视图只应该在调用链中使用，在那里它们永远不必作为字符串使用</li></ul><h5><span id="19-5-2-shi-yong-zi-fu-chuan-shi-tu-er-bu-shi-zi-fu-chuan">19.5.2 使用字符串视图而不是字符串</span><a href="#19-5-2-shi-yong-zi-fu-chuan-shi-tu-er-bu-shi-zi-fu-chuan" class="header-anchor">#</a></h5><p>还有其他通过字符串视图替换字符串的可能。但还是要小心。<br>例如，用下面的代码代替:</p><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-comment">// 将时间点（带前缀）转换为字符串:</span><span class="hljs-function">std::string <span class="hljs-title">toString</span> <span class="hljs-params">(<span class="hljs-type">const</span> std::string&amp; prefix, <span class="hljs-type">const</span> std::chrono::system_clock::time_point&amp; tp)</span></span><span class="hljs-function"></span>{    <span class="hljs-comment">// 转换为日历时间:</span>    <span class="hljs-keyword">auto</span> rawtime = std::chrono::system_clock::<span class="hljs-built_in">to_time_t</span>(tp);    std::string ts = std::<span class="hljs-built_in">ctime</span>(&amp;rawtime); <span class="hljs-comment">// 注意：不是线程安全的</span>    ts.<span class="hljs-built_in">resize</span>(ts.<span class="hljs-built_in">size</span>()<span class="hljs-number">-1</span>); <span class="hljs-comment">// 跳过尾随换行符</span>    <span class="hljs-keyword">return</span> prefix + ts;}</code></pre></div><p>您可以实现以下内容：</p><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-function">std::string <span class="hljs-title">toString</span> <span class="hljs-params">(std::string_view prefix,</span></span><span class="hljs-params"><span class="hljs-function">                      <span class="hljs-type">const</span> std::chrono::system_clock::time_point&amp; tp)</span></span><span class="hljs-function"></span>{    <span class="hljs-keyword">auto</span> rawtime = std::chrono::system_clock::<span class="hljs-built_in">to_time_t</span>(tp);    std::string_view ts = std::<span class="hljs-built_in">ctime</span>(&amp;rawtime); <span class="hljs-comment">// 注意：不是线程安全的</span>    ts.<span class="hljs-built_in">remove_suffix</span>(<span class="hljs-number">1</span>); <span class="hljs-comment">// 跳过尾随换行符</span>    <span class="hljs-keyword">return</span> std::<span class="hljs-built_in">string</span>(prefix) + ts; <span class="hljs-comment">// 不幸的是还没有运算符 +</span>}</code></pre></div><p>除了通过值获取前缀的传递字符串值作为 std::string_view 的优化之外，我们还可以在内部使用字符串视图。 但只是因为 ctime() 返回的 C 字符串在一段时间内有效（直到下一次调用 ctime() 或 asctime() 才有效）。 请注意，我们可以从字符串中删除尾随的换行符，但是我们不能通过简单地调用 operator+ 来连接两个字符串视图。 相反，我们必须将其中一个操作数转换为 std::string （不幸的是，这可能会不必要地分配额外的内存）。</p><h4><span id="19-6-hou-ji">19.6 后记</span><a href="#19-6-hou-ji" class="header-anchor">#</a></h4><p>除了通过值获取前缀的传递字符串值作为 std::string_view 的优化之外，我们还可以在内部使用字符串视图。但只是因为ctime()返回的C字符串有一段时间有效（一直有效到下一个有引用语义的字符串类是由Jeffrey Yasskin在<a href="https://wg21.link/n3334%E6%8F%90%E5%87%BA%E7%9A%84%EF%BC%88%E4%BD%BF%E7%94%A8%E5%90%8D%E7%A7%B0string_ref">https://wg21.link/n3334提出的（使用名称string_ref</a> ). 该课程被 Jeffrey Yasskin 在 <a href="https://wg21.link/n3921">https://wg21.link/n3921</a> 中提出的图书馆基础知识 TS 中采用。<br>正如 Beman Dawes 和 Alisdair Meredith 在 <a href="https://wg21.link/p0220r1">https://wg21.link/p0220r1</a> 中提出的，该类与 C++17 的其他组件一起采用。 Marshall Clow 在 <a href="https://wg21.link/p0254r2">https://wg21.link/p0254r2</a> 和 <a href="https://wg21.link/p0403r1">https://wg21.link/p0403r1</a> 以及 Nicolai Josuttis 在 <a href="https://wg21.link/p0392r0">https://wg21.link/p0392r0</a> 中添加了一些用于更好集成的修改。<br>Daniel Krugler 的其他修复在  <a href="https://wg21.link/lwg2946">https://wg21.link/lwg2946</a> 中（这可能是针对 C++17 的缺陷）。调用 ctime() 或 asctime())。请注意，我们可以从字符串中删除尾随的换行符，但是我们不能通过简单地调用 operator+ 来连接两个字符串视图。相反，我们必须将其中一个操作数转换为 std::string （不幸的是，这可能会不必要地分配额外的内存）。</p><h3><span id="20-wen-jian-xi-tong-ku">20 文件系统库</span><a href="#20-wen-jian-xi-tong-ku" class="header-anchor">#</a></h3><p>在C++17中，Boost.filesystem库最终被采纳为C++标准库。通过这样做，该库根据新的语言特性进行了调整，与库的其他部分更加一致，进行了清理，并对一些缺失的部分进行了扩展（比如计算文件系统路径之间相对路径的操作）。</p><h4><span id="20-1-ji-ben-li-zi">20.1 基本例子</span><a href="#20-1-ji-ben-li-zi" class="header-anchor">#</a></h4><p>让我们从一些基本的例子开始。</p><h5><span id="20-1-1-da-yin-yi-ge-tong-guo-wen-jian-xi-tong-lu-jing-de-shu-xing">20.1.1 打印一个通过文件系统路径的属性</span><a href="#20-1-1-da-yin-yi-ge-tong-guo-wen-jian-xi-tong-lu-jing-de-shu-xing" class="header-anchor">#</a></h5><p>以下程序允许我们使用传递的字符串作为文件系统路径来根据文件类型打印补丁的某些方面：</p><p><code>filesystem/checkpath1.cpp</code></p><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;filesystem&gt;</span></span><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span>* argv[])</span></span><span class="hljs-function"></span>{    <span class="hljs-keyword">if</span> (argc &lt; <span class="hljs-number">2</span>) {        std::cout &lt;&lt; <span class="hljs-string">"Usage: "</span> &lt;&lt; argv[<span class="hljs-number">0</span>] &lt;&lt; <span class="hljs-string">" &lt;path&gt; \n"</span>;        <span class="hljs-keyword">return</span> EXIT_FAILURE;    }    std::filesystem::path p{argv[<span class="hljs-number">1</span>]}; <span class="hljs-comment">// p 表示文件系统路径（可能不存在）</span>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">is_regular_file</span>(p)) { <span class="hljs-comment">// 路径 p 是常规文件吗？</span>        std::cout &lt;&lt; p &lt;&lt; <span class="hljs-string">" exists with "</span> &lt;&lt; <span class="hljs-built_in">file_size</span>(p) &lt;&lt; <span class="hljs-string">" bytes\n"</span>;    }    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-built_in">is_directory</span>(p)) { <span class="hljs-comment">// 路径 p 是目录吗？</span>        std::cout &lt;&lt; p &lt;&lt; <span class="hljs-string">" is a directory containing:\n"</span>;        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span>&amp; e : std::filesystem::directory_iterator{p}) {            std::cout &lt;&lt; <span class="hljs-string">" "</span> &lt;&lt; e.<span class="hljs-built_in">path</span>() &lt;&lt; <span class="hljs-string">'\n'</span>;        }    }    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-built_in">exists</span>(p)) { <span class="hljs-comment">// 路径 p 真的存在吗？</span>        std::cout &lt;&lt; p &lt;&lt; <span class="hljs-string">" is a special file\n"</span>;    }    <span class="hljs-keyword">else</span> {        std::cout &lt;&lt; <span class="hljs-string">"path "</span> &lt;&lt; p &lt;&lt; <span class="hljs-string">" does not exist\n"</span>;    }}</code></pre></div><p>我们首先将任何传递的命令行参数转换为文件系统路径：</p><div class="code-wrapper"><pre><code class="hljs c++">std::filesystem::path p{argv[<span class="hljs-number">1</span>]}; <span class="hljs-comment">// p 表示文件系统路径（可能不存在）</span></code></pre></div><p>然后，我们执行以下检查：</p><ul><li><p>如果路径代表一个现有的常规文件，我们打印它的大小：</p><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">if</span> (<span class="hljs-built_in">is_regular_file</span>(p)) { <span class="hljs-comment">// 路径 p 是普通文件吗?</span>    std::cout &lt;&lt; p &lt;&lt; <span class="hljs-string">" exists with "</span> &lt;&lt; <span class="hljs-built_in">file_size</span>(p) &lt;&lt; <span class="hljs-string">" bytes\n"</span>;}</code></pre></div><p>调用这个程序如下：</p><div class="code-wrapper"><pre><code class="hljs bash">checkpath checkpath.cpp</code></pre></div><p>将输出如下内容：</p><div class="code-wrapper"><pre><code class="hljs bash"><span class="hljs-string">"checkpath.cpp"</span> exists with 907 bytes</code></pre></div><p>请注意，路径的输出运算符会自动写入引用的路径名（在双引号内，反斜杠被另一个反斜杠转义，这是 Windows 路径的一个问题）。</p></li><li><p>如果文件系统路径作为目录存在，我们遍历目录中的文件并打印路径：</p><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">if</span> (<span class="hljs-built_in">is_directory</span>(p)) { <span class="hljs-comment">// 路径 p 是目录吗?</span>    std::cout &lt;&lt; p &lt;&lt; <span class="hljs-string">" is a directory containing:\n"</span>;    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span>&amp; e : std::filesystem::<span class="hljs-built_in">directory_iterator</span>(p)) {        std::cout &lt;&lt; <span class="hljs-string">" "</span> &lt;&lt; e.<span class="hljs-built_in">path</span>() &lt;&lt; <span class="hljs-string">'\n'</span>;    }}</code></pre></div></li></ul><p>这里我们使用了 directory_iterator，它提供了 begin() 和 end()，我们可以使用基于范围的 for 循环遍历 directory_entry 元素。 在这种情况下，我们使用 directory_entry 成员函数 path()，它产生条目的文件系统路径。<br>调用这个程序如下：</p><div class="code-wrapper"><pre><code class="hljs bash">checkpath .</code></pre></div><p>将输出如下内容：</p><div class="code-wrapper"><pre><code class="hljs bash"><span class="hljs-string">"."</span> is a directory containing:<span class="hljs-string">"./checkpath.cpp"</span><span class="hljs-string">"./checkpath.exe"</span>...</code></pre></div><ul><li><p>最后，我们检查传递的文件系统路径是否存在：</p><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">if</span> (!<span class="hljs-built_in">exists</span>(p)) { <span class="hljs-comment">// 路径 p 真的存在吗?</span>    ...}</code></pre></div></li></ul><h6><span id="windows-xia-de-lu-jing-chu-li">Windows下的路径处理</span><a href="#windows-xia-de-lu-jing-chu-li" class="header-anchor">#</a></h6><p>在 Windows 下，默认情况下路径被引用的事实是一个问题，因为通常的目录分隔符反斜杠总是被转义并写入两次。 因此，在 Windows 下调用该程序如下：</p><div class="code-wrapper"><pre><code class="hljs bash">checkpath C:\</code></pre></div><p>将输出如下内容：</p><div class="code-wrapper"><pre><code class="hljs bash"><span class="hljs-string">"C:\\"</span> is a directory containing:...<span class="hljs-string">"C:\\Users"</span><span class="hljs-string">"C:\\Windows"</span></code></pre></div><p>写入引用的路径可确保写入的文件名可以读入程序，以便您取回原始文件名。 但是，对于标准输出，这通常是不可接受的。</p><p>出于这个原因，在 Windows 下运行良好的可移植版本应该避免使用成员函数 string() 将引用的路径写入标准输出：</p><p><code>filesystem/checkpath2.cpp </code></p><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;filesystem&gt;</span></span><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span>* argv[])</span></span><span class="hljs-function"></span>{    <span class="hljs-keyword">if</span> (argc &lt; <span class="hljs-number">2</span>) {        std::cout &lt;&lt; <span class="hljs-string">"Usage: "</span> &lt;&lt; argv[<span class="hljs-number">0</span>] &lt;&lt; <span class="hljs-string">" &lt;path&gt; \n"</span>;        <span class="hljs-keyword">return</span> EXIT_FAILURE;    }    std::filesystem::path p{argv[<span class="hljs-number">1</span>]}; <span class="hljs-comment">// p 表示文件系统路径（可能不存在）</span>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">is_regular_file</span>(p)) { <span class="hljs-comment">// 路径 p 是普通文件吗?</span>        std::cout &lt;&lt; <span class="hljs-string">'"'</span> &lt;&lt; p &lt;&lt; <span class="hljs-string">"\" exists with "</span> &lt;&lt; <span class="hljs-built_in">file_size</span>(p) &lt;&lt; <span class="hljs-string">" bytes\n"</span>;    }    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-built_in">is_directory</span>(p)) { <span class="hljs-comment">// 路径 p 是目录吗?</span>        std::cout &lt;&lt; <span class="hljs-string">'"'</span> &lt;&lt; p &lt;&lt; <span class="hljs-string">"\" is a directory containing:\n"</span>;        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span>&amp; e : std::filesystem::directory_iterator{p}) {            std::cout &lt;&lt; <span class="hljs-string">" \""</span> &lt;&lt; e.<span class="hljs-built_in">path</span>().<span class="hljs-built_in">string</span>() &lt;&lt; <span class="hljs-string">"\"\n"</span>;        }    }    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-built_in">exists</span>(p)) { <span class="hljs-comment">// 路径 p 真的存在吗?</span>        std::cout &lt;&lt; <span class="hljs-string">'"'</span> &lt;&lt; p &lt;&lt; <span class="hljs-string">"\" is a special file\n"</span>;    }    <span class="hljs-keyword">else</span> {        std::cout &lt;&lt; <span class="hljs-string">"path \""</span> &lt;&lt; p &lt;&lt; <span class="hljs-string">"\" does not exist\n"</span>;    }}</code></pre></div><p>现在，在 Windows 下调用这个程序如下：</p><div class="code-wrapper"><pre><code class="hljs bash">checkpath C:\</code></pre></div><p>将输出如下内容：</p><div class="code-wrapper"><pre><code class="hljs bash"><span class="hljs-string">"C:\" is a directory containing:</span><span class="hljs-string">...</span><span class="hljs-string">"</span>C:\Users<span class="hljs-string">"</span><span class="hljs-string">"</span>C:\Windows<span class="hljs-string">"</span></code></pre></div><p>提供了其他转换以使用通用字符串格式或将字符串转换为本机编码。</p><h5><span id="20-1-2-qie-huan-wen-jian-xi-tong-lei-xing">20.1.2 切换文件系统类型</span><a href="#20-1-2-qie-huan-wen-jian-xi-tong-lei-xing" class="header-anchor">#</a></h5><p>我们仍然可以对之前的程序进行一些修改和改进，如下所示：</p><p><code>filesystem/checkpath3.cpp</code></p><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;filesystem&gt;</span></span><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span>* argv[])</span></span><span class="hljs-function"></span>{    <span class="hljs-keyword">if</span> (argc &lt; <span class="hljs-number">2</span>) {        std::cout &lt;&lt; <span class="hljs-string">"Usage: "</span> &lt;&lt; argv[<span class="hljs-number">0</span>] &lt;&lt; <span class="hljs-string">" &lt;path&gt; \n"</span>;        <span class="hljs-keyword">return</span> EXIT_FAILURE;    }    <span class="hljs-keyword">namespace</span> fs = std::filesystem;    <span class="hljs-keyword">switch</span> (fs::path p{argv[<span class="hljs-number">1</span>]}; <span class="hljs-built_in">status</span>(p).<span class="hljs-built_in">type</span>()) {        <span class="hljs-keyword">case</span> fs::file_type::not_found:            std::cout &lt;&lt; <span class="hljs-string">"path \""</span> &lt;&lt; p.<span class="hljs-built_in">string</span>() &lt;&lt; <span class="hljs-string">"\" does not exist\n"</span>;            <span class="hljs-keyword">break</span>;        <span class="hljs-keyword">case</span> fs::file_type::regular:            std::cout &lt;&lt; <span class="hljs-string">'"'</span> &lt;&lt; p.<span class="hljs-built_in">string</span>() &lt;&lt; <span class="hljs-string">"\" exists with "</span>                &lt;&lt; <span class="hljs-built_in">file_size</span>(p) &lt;&lt; <span class="hljs-string">" bytes\n"</span>;            <span class="hljs-keyword">break</span>;        <span class="hljs-keyword">case</span> fs::file_type::directory:            std::cout &lt;&lt; <span class="hljs-string">'"'</span> &lt;&lt; p.<span class="hljs-built_in">string</span>() &lt;&lt; <span class="hljs-string">"\" is a directory containing:\n"</span>;            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span>&amp; e : std::filesystem::directory_iterator{p}) {                std::cout &lt;&lt; <span class="hljs-string">" "</span> &lt;&lt; e.<span class="hljs-built_in">path</span>().<span class="hljs-built_in">string</span>() &lt;&lt; <span class="hljs-string">'\n'</span>;            }            <span class="hljs-keyword">break</span>;        <span class="hljs-keyword">default</span>:            std::cout &lt;&lt; <span class="hljs-string">'"'</span> &lt;&lt; p.<span class="hljs-built_in">string</span>() &lt;&lt; <span class="hljs-string">"\" is a special file\n"</span>;            <span class="hljs-keyword">break</span>;    }}</code></pre></div><h6><span id="ming-ming-kong-jian-fs">命名空间 fs</span><a href="#ming-ming-kong-jian-fs" class="header-anchor">#</a></h6><p>首先，我们做一些非常常见的事情：将 fs 定义为命名空间 std::filesystem 的快捷方式：</p><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">namespace</span> fs = std::filesystem;</code></pre></div><p>使用这个命名空间，我们初始化，例如，switch 语句中的路径 p：</p><div class="code-wrapper"><pre><code class="hljs c++">fs::path p{argv[<span class="hljs-number">1</span>]};</code></pre></div><p>switch 语句是带有初始化的新 switch 的应用，我们在其中初始化路径并为其类型提供不同的情况：</p><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">switch</span> (fs::path p{argv[<span class="hljs-number">1</span>]}; <span class="hljs-built_in">status</span>(p).<span class="hljs-built_in">type</span>()) {        ...}</code></pre></div><p>表达式 status(p).type() 创建一个 file_status，type() 为此创建一个 file_type。 这样我们就可以直接处理不同的类型，而不是像 is_regular_file()、is_directory() 等一连串的调用。 提供类型是在多个步骤中有意提供的，这样如果我们对状态信息不感兴趣，我们就不必支付操作系统调用的代价。</p><p>另请注意，特定于实现的 file_type 可能存在。 例如，Windows 提供了特殊的文件类型连接。 但是使用它不是便携式的。</p><h5><span id="20-1-3-chuang-jian-bu-tong-lei-xing-de-wen-jian">20.1.3 创建不同类型的文件</span><a href="#20-1-3-chuang-jian-bu-tong-lei-xing-de-wen-jian" class="header-anchor">#</a></h5><p>在仅对文件系统进行读取访问之后，现在让我们给出第一个修改它的示例。 以下程序在子目录 tmp 中创建不同类型的文件：</p><p><code>filesystem/createfiles.cpp </code></p><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;fstream&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;filesystem&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstdlib&gt;</span></span><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span> <span class="hljs-params">()</span></span><span class="hljs-function"></span>{    <span class="hljs-keyword">namespace</span> fs = std::filesystem;    <span class="hljs-keyword">try</span> {        <span class="hljs-comment">// 创建目录 tmp/test/（如果它们还不存在）:</span>        fs::path testDir{<span class="hljs-string">"tmp/test"</span>};        <span class="hljs-built_in">create_directories</span>(testDir);        <span class="hljs-comment">// 创建数据文件 tmp/test/data.txt:</span>        <span class="hljs-keyword">auto</span> testFile = testDir / <span class="hljs-string">"data.txt"</span>;        std::ofstream dataFile{testFile};        <span class="hljs-keyword">if</span> (!dataFile) {            std::cerr &lt;&lt; <span class="hljs-string">"OOPS, can't open \""</span> &lt;&lt; testFile.<span class="hljs-built_in">string</span>() &lt;&lt; <span class="hljs-string">"\"\n"</span>;            std::<span class="hljs-built_in">exit</span>(EXIT_FAILURE); <span class="hljs-comment">// 退出程序失败</span>        }        dataFile &lt;&lt; <span class="hljs-string">"The answer is 42\n"</span>;        <span class="hljs-comment">// 创建从 tmp/slink/ 到 tmp/test/ 的符号链接:</span>        <span class="hljs-built_in">create_directory_symlink</span>(<span class="hljs-string">"test"</span>, testDir.<span class="hljs-built_in">parent_path</span>() / <span class="hljs-string">"slink"</span>);        <span class="hljs-comment">// 递归列出所有文件（也遵循符号链接）</span>        std::cout &lt;&lt; fs::<span class="hljs-built_in">current_path</span>().<span class="hljs-built_in">string</span>() &lt;&lt; <span class="hljs-string">":\n"</span>;        <span class="hljs-keyword">auto</span> iterOpts{fs::directory_options::follow_directory_symlink};        <span class="hljs-keyword">for</span> (<span class="hljs-type">const</span> <span class="hljs-keyword">auto</span>&amp; e : fs::<span class="hljs-built_in">recursive_directory_iterator</span>(<span class="hljs-string">"."</span>, iterOpts)) {            std::cout &lt;&lt; <span class="hljs-string">" "</span> &lt;&lt; e.<span class="hljs-built_in">path</span>().<span class="hljs-built_in">lexically_normal</span>().<span class="hljs-built_in">string</span>() &lt;&lt; <span class="hljs-string">'\n'</span>;        }    }    <span class="hljs-built_in">catch</span> (fs::filesystem_error&amp; e) {        std::cerr &lt;&lt; <span class="hljs-string">"EXCEPTION: "</span> &lt;&lt; e.<span class="hljs-built_in">what</span>() &lt;&lt; <span class="hljs-string">'\n'</span>;        std::cerr &lt;&lt; <span class="hljs-string">" path1: \""</span> &lt;&lt; e.<span class="hljs-built_in">path1</span>().<span class="hljs-built_in">string</span>() &lt;&lt; <span class="hljs-string">"\"\n"</span>;    }}</code></pre></div><p>让我们一步一步地完成这个程序。</p><h6><span id="ming-ming-kong-jian-fs">命名空间 fs</span><a href="#ming-ming-kong-jian-fs" class="header-anchor">#</a></h6><p>首先，我们做一些非常常见的事情：将 fs 定义为命名空间 std::filesystem 的快捷方式：</p><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">namespace</span> fs = std::filesystem;</code></pre></div><p>例如，我们使用这个命名空间初始化临时文件的基本子目录的路径：</p><div class="code-wrapper"><pre><code class="hljs c++">fs::path testDir{<span class="hljs-string">"tmp/test"</span>};</code></pre></div><h6><span id="chuang-jian-mu-lu">创建目录</span><a href="#chuang-jian-mu-lu" class="header-anchor">#</a></h6><p>然后我们尝试创建子目录：</p><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-built_in">create_directories</span>(testDir);</code></pre></div><p>通过使用 create_directories() 我们创建整个传递路径的所有缺失目录（还有 create_directory() 仅在现有目录内创建目录）。</p><p>如果目录已经存在，则执行此调用不是错误。 但是，任何其他问题都是错误并引发相应的异常。</p><p>如果 testDir 已经存在，create_directories() 返回 false。 因此，您也可以调用：</p><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">if</span> (!<span class="hljs-built_in">create_directories</span>(testDir)) {    std::cout &lt;&lt; <span class="hljs-string">"\""</span> &lt;&lt; testDir.<span class="hljs-built_in">string</span>() &lt;&lt; <span class="hljs-string">"\" already exists\n"</span>;}</code></pre></div><p>但是，请注意，如果 testDir 存在但不是目录，这也不是错误。 因此，返回 true 并不意味着在调用之后有一个具有请求名称的目录。 我们可以检查一下，但在这种情况下，这是间接涉及的，因为下一次在目录中创建文件的调用将失败。 但是，错误消息可能会令人困惑。 为了获得更好的错误消息，您可能需要检查之后是否真的存在目录。</p><h6><span id="chuang-jian-chang-gui-wen-jian">创建常规文件</span><a href="#chuang-jian-chang-gui-wen-jian" class="header-anchor">#</a></h6><p>然后我们创建一个包含一些内容的新文件 /tmp/test/data.txt：</p><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">auto</span> testFile = testDir / <span class="hljs-string">"data.txt"</span>;<span class="hljs-function">std::ofstream <span class="hljs-title">dataFile</span><span class="hljs-params">(testFile)</span></span>;<span class="hljs-keyword">if</span> (!dataFile) {    std::cerr &lt;&lt; <span class="hljs-string">"OOPS, can't open \""</span> &lt;&lt; testFile.<span class="hljs-built_in">string</span>() &lt;&lt; <span class="hljs-string">"\"\n"</span>;    std::<span class="hljs-built_in">exit</span>(EXIT_FAILURE); <span class="hljs-comment">// 退出程序失败</span>}dataFile &lt;&lt; <span class="hljs-string">"The answer is 42\n"</span>;</code></pre></div><p>这里我们使用运算符 / 来扩展路径，然后我们将其作为参数传递给文件流的构造函数。 如您所见，常规文件的创建仍然只能使用现有的 I/O 流库来完成。 但是，为构造函数提供了一个新的重载，以便能够直接传递文件系统路径。<br>请注意，您仍应始终检查创建/打开文件是否成功。 很多事情都可能在这里出错（见下文）。</p><h6><span id="chuang-jian-fu-hao-lian-jie">创建符号链接</span><a href="#chuang-jian-fu-hao-lian-jie" class="header-anchor">#</a></h6><p>下一条语句尝试创建一个引用目录 tmp/test 的符号链接 tmp/slink：</p><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-built_in">create_directory_symlink</span>(<span class="hljs-string">"test"</span>, testDir.<span class="hljs-built_in">parent_path</span>() / <span class="hljs-string">"slink"</span>);</code></pre></div><p>请注意，第一个参数定义了创建链接视图的路径。 因此，您必须通过“test”而不是“tmp/test”才能有效地从 tmp/slink 链接到 tmp/test。 如果你调用：</p><div class="code-wrapper"><pre><code class="hljs c++">std::filesystem::<span class="hljs-built_in">create_directory_symlink</span>(<span class="hljs-string">"tmp/test"</span>, <span class="hljs-string">"tmp/slink"</span>);</code></pre></div><p>您将有效地创建 tmp/slink 作为指向 tmp/tmp/test 的符号链接。</p><p>请注意，通常调用 create_symlink() 而不是 create_directory_symlink() 也可以，但是某些操作系统对目录的符号链接有特殊处理，或者当它们知道文件是目录时执行得更好，因此如果您应该使用 create_directory_symlink() 知道符号链接是指一个目录。</p><h6><span id="mu-lu-di-gui">目录递归</span><a href="#mu-lu-di-gui" class="header-anchor">#</a></h6><p>最后，我们递归地列出当前目录：</p><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">auto</span> iterOpts = fs::directory_options::follow_directory_symlink;<span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span>&amp; e : fs::<span class="hljs-built_in">recursive_directory_iterator</span>(<span class="hljs-string">"."</span>, iterOpts)) {    std::cout &lt;&lt; <span class="hljs-string">" "</span> &lt;&lt; e.<span class="hljs-built_in">path</span>().<span class="hljs-built_in">lexically_normal</span>().<span class="hljs-built_in">string</span>() &lt;&lt; <span class="hljs-string">'\n'</span>;}</code></pre></div><p>因为我们使用递归目录迭代器并传递选项以跟随符号链接，follow_directory_symlink，我们应该在基于 POSIX 的系统上获得如下输出：</p><div class="code-wrapper"><pre><code class="hljs bash"><span class="hljs-comment"># /home/nico:</span>...tmptmp/slinktmp/slink/data.txttmp/testtmp/test/data.txt...</code></pre></div><p>在 Windows 系统上的输出如下所示：</p><div class="code-wrapper"><pre><code class="hljs bash"><span class="hljs-comment"># C:/Users/nico:</span>...tmptmp\slinktmp\slink\data.txttmp\<span class="hljs-built_in">test</span>tmp\<span class="hljs-built_in">test</span>\data.txt...</code></pre></div><p>请注意，我们在打印所有目录条目的路径时使用 lexically_normal()。 如果我们跳过它，目录条目的路径将包含一个带有初始化迭代器的目录的前缀。 因此，只打印循环内的路径：</p><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">auto</span> iterOpts = fs::directory_options::follow_directory_symlink;<span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span>&amp; e : fs::<span class="hljs-built_in">recursive_directory_iterator</span>(<span class="hljs-string">"."</span>, iterOpts)) {    std::cout &lt;&lt; <span class="hljs-string">" "</span> &lt;&lt; e.<span class="hljs-built_in">path</span>() &lt;&lt; <span class="hljs-string">'\n'</span>;}</code></pre></div><p>将在基于 POSIX 的系统下输出：</p><div class="code-wrapper"><pre><code class="hljs bash"><span class="hljs-comment"># all files:</span>...<span class="hljs-string">"./testdir"</span><span class="hljs-string">"./testdir/data.txt"</span><span class="hljs-string">"./tmp"</span><span class="hljs-string">"./tmp/test"</span><span class="hljs-string">"./tmp/test/data.txt"</span></code></pre></div><p>在 Windows 上，输出将是：</p><div class="code-wrapper"><pre><code class="hljs bash"><span class="hljs-comment"># all files:</span>...<span class="hljs-string">".\\testdir"</span><span class="hljs-string">".\\testdir\\data.txt"</span><span class="hljs-string">".\\tmp"</span><span class="hljs-string">".\\tmp\\test"</span><span class="hljs-string">".\\tmp\\test\\data.txt"</span></code></pre></div><p>因此，通过调用 lexically_normal() 我们产生了规范化的路径，它确实删除了当前目录的前导点。 如前所述，通过调用 string() 我们避免了每个路径都被引用，这对于基于 POSIX 的系统来说是可以的（只是将名称放在双引号中），但在 Windows 系统上看起来非常令人惊讶（因为每个反斜杠 被另一个反斜杠转义）。</p><h6><span id="cuo-wu-chu-li">错误处理</span><a href="#cuo-wu-chu-li" class="header-anchor">#</a></h6><p>文件系统是麻烦的根源。 由于使用了错误的字符、没有必要的权限或其他进程可能会在您处理文件系统时修改文件系统，您可能无法执行操作。 因此，根据平台和权限，该程序可能会出现一些问题。</p><p>对于那些没有被返回值覆盖的情况（这里是目录已经存在的情况），我们捕获相应的异常并打印一般消息和其中的第一个路径：</p><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">try</span> {    ...}<span class="hljs-built_in">catch</span> (fs::filesystem_error&amp; e) {    std::cerr &lt;&lt; <span class="hljs-string">"EXCEPTION: "</span> &lt;&lt; e.<span class="hljs-built_in">what</span>() &lt;&lt; <span class="hljs-string">'\n'</span>;    std::cerr &lt;&lt; <span class="hljs-string">" path1: \""</span> &lt;&lt; e.<span class="hljs-built_in">path1</span>().<span class="hljs-built_in">string</span>() &lt;&lt; <span class="hljs-string">"\"\n"</span>;}</code></pre></div><p>例如，如果我们无法创建目录，则可能会打印出如下消息：</p><div class="code-wrapper"><pre><code class="hljs bash">EXCEPTION: filesystem error: cannot create directory: [tmp/test]path1: <span class="hljs-string">"tmp/test"</span></code></pre></div><p>或者，如果我们无法创建符号链接，例如因为它已经存在，您会收到类似以下消息：</p><div class="code-wrapper"><pre><code class="hljs bash">EXCEPTION: create_directory_symlink: Can’t create a file when it alreadyexists: <span class="hljs-string">"tmp\test\data.txt"</span>, <span class="hljs-string">"testdir"</span>path1: <span class="hljs-string">"tmp\test\data.txt"</span></code></pre></div><p>如前所述，当目录已经作为常规文件存在时，在目录中创建新文件的尝试将失败。因此，不要忘记检查打开文件的状态。默认情况下，用于读取和写入常规文件的 I/O Stream 库不会将错误作为异常处理。</p><p>无论如何请注意，多用户/多进程操作系统中的情况随时可能发生变化。因此，您创建的目录甚至可能在您创建后被删除、重命名或替换为常规文件。因此，根本不可能通过找出当前情况来确保未来请求的有效性。出于这个原因，它通常是尝试做你想做的事情（即创建目录、打开文件）并处理异常和错误或验证检查预期行为的最佳方法。</p><p>但是，有时尝试对文件系统做一些事情可能会奏效，但不是您想的那样。例如，如果您想在特定目录中创建文件并且已经存在指向另一个目录的符号链接，则该文件会在意外位置创建或覆盖。这可能没问题（用户可能有充分的理由在预期目录的位置创建符号链接）。但是，如果您想检测这种情况，则必须在创建文件之前检查文件是否存在（这比您最初想象的要复杂一些）。</p><p>但同样：不能保证文件系统检查的结果在您处理它们时仍然有效。</p><h5><span id="20-1-4-shi-yong-bing-xing-suan-fa-chu-li-wen-jian-xi-tong-de-wen-ti">20.1.4 使用并行算法处理文件系统的问题</span><a href="#20-1-4-shi-yong-bing-xing-suan-fa-chu-li-wen-jian-xi-tong-de-wen-ti" class="header-anchor">#</a></h5><p>有关使用并行算法累积目录树中所有常规文件大小的另一个示例，请参见 dirsize.cpp。</p><h4><span id="20-2-yuan-ze-he-zhu-yu">20.2 原则和术语</span><a href="#20-2-yuan-ze-he-zhu-yu" class="header-anchor">#</a></h4><p>在讨论文件系统库的细节之前，我们必须介绍一些设计原则和术语。 这是必要的，因为该标准涵盖了不同的操作系统并将它们映射到一个通用 API。</p><h5><span id="20-2-1-yi-ban-ke-yi-zhi-xing-sheng-ming">20.2.1 一般可移植性声明</span><a href="#20-2-1-yi-ban-ke-yi-zhi-xing-sheng-ming" class="header-anchor">#</a></h5><p>C++ 标准不仅标准化了所有可能的操作系统对其文件系统的共同点。 在许多情况下，它遵循 POSIX 标准，而 C++ 标准要求尽可能地遵循 POSIX。 只要它是合理的，行为应该仍然存在，但有一些限制。 如果不可能有合理的行为，则实现应报告错误。<br>此类错误的可能示例是：</p><ul><li>字符用于不支持的文件名</li><li>创建了不受支持的文件系统元素（例如，符号链接） 特定文件系统的差异仍然可能很重要：</li><li>区分大小写：<br>“hello.txt”和“Hello.txt”和“hello.TXT”可能指同一个（Windows）或三个不同的文件（基于POSIX）。</li><li>绝对路径与相对路径：<br>在某些系统上，“/bin”是绝对路径（基于 POSIX），而在其他系统上则不是（Windows）。</li></ul><h5><span id="20-2-2-ming-ming-kong-jian">20.2.2 命名空间</span><a href="#20-2-2-ming-ming-kong-jian" class="header-anchor">#</a></h5><p>文件系统库在 std 中有自己的子命名空间文件系统。 为其引入快捷方式 fs 是一个非常常见的约定：</p><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">namespace</span> fs = std::filesystem;</code></pre></div><p>例如，这允许使用 fs::current_path() 而不是 std::filesystem::current_path()。<br>本章的进一步代码示例通常会使用 fs 作为相应的快捷方式。<br>请注意，不限定文件系统调用有时会导致意外行为。</p><h5><span id="20-2-3-lu-jing">20.2.3 路径</span><a href="#20-2-3-lu-jing" class="header-anchor">#</a></h5><p>文件系统库的关键元素是路径。它是一个名称，表示文件系统中文件的（潜在）位置。它由一个可选的根名称、一个可选的根目录和一系列由目录分隔符分隔的文件名组成。路径可以是相对的（因此文件位置取决于当前工作目录）或绝对的。<br>不同的格式是可能的：</p><ul><li><p>通用格式，可移植</p></li><li><p>一种原生格式，特定于底层文件系统<br>在基于 POSIX 的操作系统上，通用格式和本机格式之间没有区别。<br>在 Windows 上，通用格式 /tmp/test.txt 是除 \tmp\test.txt 之外的有效原生格式，它也受支持（因此，/tmp/test.txt 和 \tmp\test.txt 是相同的路径）。在 OpenVMS 上，相应的原生格式可能是 [tmp]test.txt。<br>存在特殊文件名：</p></li><li><p>“.”代表当前目录</p></li><li><p>“..” 代表父目录<br>通用路径格式如下：</p><div class="code-wrapper"><pre><code class="hljs bash">[rootname] [rootdir] [relativepath]</code></pre></div></li></ul><p> 在哪里：</p><ul><li>可选的根名称是特定于实现的（例如，在 POSIX 系统上可以是 //host，在 Windows 系统上可以是 C:）</li><li>可选的根目录是目录分隔符</li><li>相对路径是由目录分隔符分隔的一系列文件名</li></ul><p>根据定义，目录分隔符由一个或多个“/”或特定于实现的首选目录分隔符组成。</p><p>可移植通用路径的示例是：</p><div class="code-wrapper"><pre><code class="hljs bash">//host1/bin/hello.txt.tmp//a/b//../c</code></pre></div><p>请注意，最后一个路径与 /a/c 指向相同的位置，并且在 POSIX 系统上是绝对的，但在 Windows 系统上是相对的（因为缺少驱动器/分区）。</p><p>另一方面，诸如 C:/bin 之类的路径在 Windows 系统上是绝对路径（“C”驱动器/分区上的根目录“bin”），但在 POSIX 上是相对路径（目录中的子目录“bin”） “C：”）。</p><p>在 Windows 系统上，反斜杠是实现特定的目录分隔符，因此上面的路径也可以通过使用反斜杠作为首选目录分隔符来编写：</p><div class="code-wrapper"><pre><code class="hljs bash">\\host1\bin\hello.txt.tmp\\a\b\..\c</code></pre></div><p>文件系统库提供了在本地格式和通用格式之间转换路径的功能。<br>路径可能是空的。 这意味着没有定义路径。 这不一定与“.”相同。 它的含义取决于上下文。</p><h5><span id="20-2-4-gui-fan-hua">20.2.4 规范化</span><a href="#20-2-4-gui-fan-hua" class="header-anchor">#</a></h5><p>路径可能已经或可以被规范化。 在规范化路径中：</p><ul><li>文件名仅由一个首选目录分隔符分隔。</li><li>文件名“.”除非整个路径只是“.”，否则不使用。 （代表当前目录）。</li><li>文件名不包含“..”文件名（我们不会先向下然后再向上），除非它们位于相对路径的开头。</li><li>如果尾部的文件名是一个名称不是”… “或”… “的目录，路径才以目录分隔符结束。</li></ul><p>请注意，规范化仍然意味着以目录分隔符结尾的文件名与不以分隔符结尾的文件名不同。原因是在某些操作系统上，当知道路径是目录时，行为会有所不同（例如，带有尾随分隔符的符号链接可能会被解析）。</p><p>路径规范化的表效果列出了一些在 POSIX 和 Windows 系统上进行规范化的示例。再次注意，在 POSIX 系统上，C:bar 和 C: are 只是文件名，并没有像在 Windows 上那样指定分区的特殊含义。</p><table><thead><tr><th>路径</th><th>POSIX 标准化</th><th>windows 标准化</th></tr></thead><tbody><tr><td>foo/.///bar/../</td><td>foo/</td><td>foo\</td></tr><tr><td>//host/../foo.txt</td><td>//host/foo.txt</td><td>\host\foo.txt</td></tr><tr><td>./f/../.f/</td><td>.f/</td><td>.f\</td></tr><tr><td>C:bar/../</td><td>.</td><td>C:</td></tr><tr><td>C:/bar/..</td><td>C:/</td><td>C:\</td></tr><tr><td>C:\bar..</td><td>C:\bar..</td><td>C:\</td></tr><tr><td>/./../data.txt</td><td>/data.txt</td><td>\data.txt</td></tr><tr><td>././</td><td>.</td><td>.</td></tr></tbody></table><p>请注意，在基于POSIX的系统上进行规范化处理时，路径C:\bar...保持不变。原因是在那里反斜杠不是目录分隔符，所以整个路径只是一个文件名，其中有一个冒号、两个反斜杠和两个点作为其名称的一部分。<br>文件系统为词法规范化（不考虑文件系统）和依赖文件系统的规范化都提供了功能。</p><h5><span id="20-2-5-cheng-yuan-han-shu-yu-du-li-de-han-shu">20.2.5 成员函数与独立的函数</span><a href="#20-2-5-cheng-yuan-han-shu-yu-du-li-de-han-shu" class="header-anchor">#</a></h5><p>文件系统库提供了几个函数，它们既可以是成员函数也可以是独立函数。一般的做法是：</p><ul><li><p>成员函数很便宜。原因是它们是纯词法操作，不考虑实际的文件系统，所以不需要调用操作系统。</p><p>例如：</p><div class="code-wrapper"><pre><code class="hljs c++">mypath.<span class="hljs-built_in">is_absolute</span>() <span class="hljs-comment">// 检查路径是绝对的还是相对的</span></code></pre></div></li><li><p>独立的函数是昂贵的，因为它们通常考虑到实际的文件系统，所以不需要调用操作系统。</p><p>例子：</p><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-built_in">equivalent</span>(path1, path2); <span class="hljs-comment">// 如果两个路径都指向同一个文件，则为true</span></code></pre></div></li></ul><p>有时，文件系统库甚至提供了相同的功能，既在词法上操作，又考虑到了实际的文件系统。</p><div class="code-wrapper"><pre><code class="hljs c++">std::filesystem::path fromP, toP;...toP.<span class="hljs-built_in">lexically_relative</span>(fromP); <span class="hljs-comment">// 产生从 fromP 到 toP 的词法路径</span><span class="hljs-built_in">relative</span>(toP, fromP); <span class="hljs-comment">// 产生从 fromP 到 toP 的实际路径</span></code></pre></div><p>由于参数依赖性查找（ADL），在调用独立的文件系统函数和一个参数具有文件系统的特定类型时，你通常不需要指定完整的命名空间std::filesystem。只有在使用其他类型的隐式转换时，你才需要限定 调用。比如说:</p><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-built_in">create_directory</span>(std::filesystem::path{<span class="hljs-string">"tmpdir"</span>}); <span class="hljs-comment">// OK</span><span class="hljs-built_in">remove</span>(std::filesystem::path{<span class="hljs-string">"tmpdir"</span>}); <span class="hljs-comment">// OK</span>std::filesystem::<span class="hljs-built_in">create_directory</span>(<span class="hljs-string">"tmpdir"</span>); <span class="hljs-comment">// OK</span>std::filesystem::<span class="hljs-built_in">remove</span>(<span class="hljs-string">"tmpdir"</span>); <span class="hljs-comment">// OK</span><span class="hljs-built_in">create_directory</span>(<span class="hljs-string">"tmpdir"</span>); <span class="hljs-comment">// ERROR</span><span class="hljs-built_in">remove</span>(<span class="hljs-string">"tmpdir"</span>); <span class="hljs-comment">// OOPS: 调用 C 函数 remove()</span></code></pre></div><p>请注意，最后一个调用通常会编译，但会找到C函数remove()，它也会删除一个指定的文件，但在Windows下不会删除空目录。</p><h5><span id="20-2-6-cuo-wu-chu-li">20.2.6 错误处理</span><a href="#20-2-6-cuo-wu-chu-li" class="header-anchor">#</a></h5><p>正如第二个例子所讨论的，文件系统是一个错误的来源。你必须考虑到必要的文件可能不存在，文件操作不被允许，或者操作违反了资源限制。此外，当程序运行时，其他进程可能会创建、修改或删除文件，因此，即使提前检查也不能保证没有错误。</p><p>问题是，原则上你无法确保下一个文件系统操作会成功。任何检查的结果在你处理它时可能不再有效。因此，通常最好的方法是执行一个或多个文件系统操作，并处理由此产生的异常或错误。</p><p>还要注意的是，当用普通文件进行读写时，I/O流库默认不会抛出错误。它将任何操作转换为无操作。因此，我们建议至少检查一下文件是否能成功打开。</p><p>因为处理异常并不总是合适的（比如当你想直接对一个失败的文件系统调用做出反应时），文件系统库在处理以下问题时使用了混合方法 文件系统时，采用混合方法:</p><ul><li>默认情况下，文件系统错误被作为异常处理。</li><li>但是，如果你有或者想要，你可以在本地处理特定的错误。<br>这是通过文件系统操作实现的，通常每个操作都有两个重载。</li></ul><ol><li>默认情况下（没有额外的错误处理参数），操作在出错时抛出一个filesystem_error异常。</li><li>通过传递一个额外的输出参数，你可以在出错时得到一个错误代码。<br>请注意，在后一种情况下，你可能仍然有特殊的返回值，标志着一个特定的错误没有被作为异常处理。</li></ol><h6><span id="shi-yong-filesystem-error-yi-chang">使用 filesystem_error 异常</span><a href="#shi-yong-filesystem-error-yi-chang" class="header-anchor">#</a></h6><p>例如，你可以尝试创建一个目录，如下所示:</p><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">if</span> (!<span class="hljs-built_in">create_directory</span>(p)) { <span class="hljs-comment">// 错误异常（除非路径存在）</span>    std::cout &lt;&lt; p &lt;&lt; <span class="hljs-string">" already exists\n"</span>; <span class="hljs-comment">// 路径存在</span>}</code></pre></div><p>这里，没有传递错误代码参数，所以错误通常会引发一个异常。但是请注意，路径已经存在的特殊情况（是否是一个目录并不重要），将通过返回false来处理。因此，一个异常是由于其他问题引起的，比如缺少创建目录的权限，无效的路径p，或者违反文件系统资源（比如超过路径长度<br>限制）。<br>像这样的代码应该直接或间接地包含在一个try-catch子句中，它可以处理std::filesystem::filesystem_error类型的异常:</p><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">try</span> {    ...;    <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">create_directory</span>(p)) { <span class="hljs-comment">// 错误异常（除非路径存在）</span>        std::cout &lt;&lt; p &lt;&lt; <span class="hljs-string">" already exists\n"</span>; <span class="hljs-comment">// 路径存在</span>    }    ...;}<span class="hljs-built_in">catch</span> (<span class="hljs-type">const</span> std::filesystem::filesystem_error&amp; e) { <span class="hljs-comment">// 源自 std::exception</span>    std::cout &lt;&lt; <span class="hljs-string">"EXCEPTION: "</span> &lt;&lt; e.<span class="hljs-built_in">what</span>() &lt;&lt; <span class="hljs-string">'\n'</span>;    std::cout &lt;&lt; <span class="hljs-string">" path: "</span> &lt;&lt; e.<span class="hljs-built_in">path1</span>() &lt;&lt; <span class="hljs-string">'\n'</span>;}</code></pre></div><p>正如你所看到的，文件系统异常提供了通常的标准异常API，通过what()产生一个特定于实现的错误信息。然而，它还提供了path1()，如果涉及到一个路径，甚至是 path2()，如果涉及到第二个路径。</p><h6><span id="shi-yong-error-code-can-shu">使用 error_code 参数</span><a href="#shi-yong-error-code-can-shu" class="header-anchor">#</a></h6><p>使用error_code参数<br>另一种调用函数创建目录的方法如下。</p><div class="code-wrapper"><pre><code class="hljs c++">std::error_code ec;<span class="hljs-built_in">create_directory</span>(p, ec); <span class="hljs-comment">// 出错时设置错误代码</span><span class="hljs-keyword">if</span> (ec) { <span class="hljs-comment">// 如果设置了错误代码(由于错误)</span>    std::cout &lt;&lt; <span class="hljs-string">"ERROR: "</span> &lt;&lt; ec.<span class="hljs-built_in">message</span>() &lt;&lt; <span class="hljs-string">"\n"</span>;}</code></pre></div><p>之后，我们还可以针对特定的错误代码进行检查。</p><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">if</span> (ec == std::errc::read_only_file_system) { <span class="hljs-comment">// if specific error code set</span>    std::cout &lt;&lt; <span class="hljs-string">"ERROR: "</span> &lt;&lt; p &lt;&lt; <span class="hljs-string">" is read-only/n"</span>;}</code></pre></div><p>注意，在这种情况下，我们仍然可以检查create_directory()的返回值。</p><div class="code-wrapper"><pre><code class="hljs c++">std::error_code ec;<span class="hljs-keyword">if</span> (!<span class="hljs-built_in">create_directory</span>(p, ec)) { <span class="hljs-comment">// 出错时设置错误代码</span>    std::cout &lt;&lt; <span class="hljs-string">"can't create directory "</span> &lt;&lt; p &lt;&lt; <span class="hljs-string">"\n"</span>; <span class="hljs-comment">// any error occurred</span>    std::cout &lt;&lt; <span class="hljs-string">"ERROR:"</span> &lt;&lt; ec.<span class="hljs-built_in">message</span>() &lt;&lt; <span class="hljs-string">"\n"</span>;}</code></pre></div><p>然而，并不是所有的文件系统操作都提供这种能力（因为它们在正常情况下返回一些值正常情况下）。<br>在C++11中引入了error_code类型，包括一个可移植错误条件的列表，如<br>如std::errc::read_only_filesystem。在POSIX系统中，这些映射为errno值</p><h5><span id="20-2-7-wen-jian-lei-xing">20.2.7 文件类型</span><a href="#20-2-7-wen-jian-lei-xing" class="header-anchor">#</a></h5><p>不同的操作系统支持不同的文件类型。标准文件系统库考虑到了这一点。原则上，有一个枚举类型file_type，它被标准化为有以下值:</p><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">namespace</span> std::filesystem {    <span class="hljs-keyword">enum class</span> <span class="hljs-title class_">file_type</span> {        regular, directory, symlink,        block, character, fifo, socket,        ...;        none, not_found, unknown,    };}</code></pre></div><p>表file_type Values列出了这些值的含义。<br>平台可能会提供额外的文件类型值，但这是不可移植的。例如:</p><p> Windows提供了文件类型值junction，它用于NTFS文件系统的NTFS结点（也称为软链接）。它们被用作位于同一台计算机的不同本地卷上的目录的链接。在同一台计算机上的不同卷上的目录的链接。</p><table><thead><tr><th>值</th><th>意义</th></tr></thead><tbody><tr><td>regular</td><td>常规文件</td></tr><tr><td>directory</td><td>目录文件</td></tr><tr><td>symlink</td><td>符号连接</td></tr><tr><td>character</td><td>字符专用文件</td></tr><tr><td>block</td><td>块特殊文件</td></tr><tr><td>fifo</td><td>FIFO或管道文件</td></tr><tr><td>socket</td><td>套接字文件</td></tr><tr><td>…</td><td>额外的执行定义的文件类型</td></tr><tr><td>none</td><td>文件类型未知（尚）</td></tr><tr><td>unknown</td><td>文件存在但无法确定类型</td></tr><tr><td>not_found</td><td>表示未找到该文件的伪类型</td></tr></tbody></table><p>除了常规文件和目录之外，最常见的其他类型是符号链接，它是一种指向另一个文件系统位置的文件的类型。在那个位置可能有一个文件，也可能没有。请注意，某些操作系统和/或文件系统（例如 FAT 文件系统）根本不支持符号链接。某些操作系统仅对常规文件支持它们。请注意，在 Windows 上，您需要特殊权限才能创建符号链接，例如，您可以使用 mklink 命令执行此操作。<br>字符特殊文件、块特殊文件、FIFO 和套接字来自 UNIX 文件系统。目前，所有四种类型都不能与 Visual C++ 一起使用。<br>如您所见，对于文件不存在或其文件类型未知或无法检测的情况，存在特殊值。在本章的其余部分中，我使用两个通用类别来表示几种文件类型：</p><ul><li>其他文件：具有除常规文件、目录和符号链接之外的任何文件类型的文件。库函数 is_other() 匹配该术语。</li><li>特殊文件：具有以下任何文件类型的文件：字符特殊文件、块特殊文件、FIFO 和套接字。<br>特殊文件类型加上实现定义的文件类型共同构成了其他文件类型。</li></ul><h4><span id="20-3-lu-jing-cao-zuo">20.3 路径操作</span><a href="#20-3-lu-jing-cao-zuo" class="header-anchor">#</a></h4><p>为了处理文件系统，有很多操作可以调用。处理文件系统的一个关键类型是std::filesystem::path，它可以作为一个文件的绝对或相对路径，这个文件可能存在，也可能不存在（尚未存在）。</p><p>你可以创建路径，检查它们，修改它们，以及比较它们。因为这些操作通常不考虑文件系统（关心现有文件、符号链接等），所以它们的调用很便宜。因此，它们通常是成员函数（如果它们不是构造函数或 操作符）。</p><h5><span id="20-3-1-chuang-jian-lu-jing">20.3.1 创建路径</span><a href="#20-3-1-chuang-jian-lu-jing" class="header-anchor">#</a></h5><p>表Path Creation列出了创建新路径对象的方法。</p><table><thead><tr><th>调用</th><th>作用</th></tr></thead><tbody><tr><td>path(string)</td><td>从一个字符串创建路径</td></tr><tr><td>path(beg,end)</td><td>从一个范围创建路径</td></tr><tr><td>u8path(u8string)</td><td>从一个UTF-8字符串中创建路径</td></tr><tr><td>current_path()</td><td>产生当前工作目录的路径</td></tr><tr><td>temp_directory_path()</td><td>产生临时文件的路径</td></tr></tbody></table><p>注意，current_path()和temp_directory_path()都是比较昂贵的操作，因为它们是基于操作系统的调用。通过传递一个参数，current_path()也可以用来修改当前工作目录。<br>通过u8path()，你可以使用所有UTF-8字符创建可移植的路径。比如说:</p><div class="code-wrapper"><pre><code class="hljs c++">std::filesystem::path{<span class="hljs-built_in">u8path</span>(<span class="hljs-string">u8"K\u00F6ln"</span>); <span class="hljs-comment">// ”Koln” (Cologne native) ¨</span>...<span class="hljs-comment">// 从返回的UTF-8字符串中创建目录:</span>std::string utf8String = <span class="hljs-built_in">readUTF8String</span>(...);<span class="hljs-built_in">create_directory</span>(std::filesystem::<span class="hljs-built_in">u8path</span>(utf8String));</code></pre></div><h5><span id="20-3-2-lu-jing-jian-cha">20.3.2 路径检查</span><a href="#20-3-2-lu-jing-jian-cha" class="header-anchor">#</a></h5><p>表Path Inspection列出了你可以调用的检查路径p的函数。注意，这些操作不考虑文件系统，因此是路径的成员函数。<br>每个路径都是绝对或相对的。如果它没有根目录，它就是相对的（根名称是可能的；例如，C:hello.txt在Windows下是一个相对路径）。<br>has_…()函数检查没有has_的相应函数是否产生一个空路径。<br>请注意以下几点。</p><ul><li>如果根元素或目录分隔符是路径的一部分，总是有一个父路径。如果路径只由根元素组成（即相对路径是空的），parent_path()得到的是相同的路径。也就是说，例如，”/“的父路径是”/“。只有像 “hello.txt “这样的纯文件名的父路径是空的。</li></ul><table><thead><tr><th>调用</th><th>作用</th></tr></thead><tbody><tr><td>p.empty()</td><td>产生路径是否为空</td></tr><tr><td>p.is_absolute()</td><td>产生一个路径是否是绝对的</td></tr><tr><td>p.is_relative()</td><td>产生是否是相对路径</td></tr><tr><td>p.has_filename()</td><td>产生路径是否既不是目录也不是根名的问题</td></tr><tr><td>p.has_stem()</td><td>与has_filename()相同（因为任何文件名都有一个干）。</td></tr><tr><td>p.has_extension()</td><td>产生路径是否有扩展名</td></tr><tr><td>p.has_root_name()</td><td>yields 路径是否有根名</td></tr><tr><td>p.has_root_directory()</td><td>yields 路径是否有根目录</td></tr><tr><td>p.has_root_path()</td><td>yields 路径是否有根名或根目录</td></tr><tr><td>p.has_parent_path()</td><td>产生路径是否有一个父路径</td></tr><tr><td>p.has_relative_path()</td><td>产生路径是否不只由根元素组成</td></tr><tr><td>p.filename()</td><td>产生文件名（或空路径）。</td></tr><tr><td>p.stem()</td><td>产生不带扩展名的文件名（或空路径）</td></tr><tr><td>p.extension()</td><td>产生扩展名(或空路径)</td></tr><tr><td>p.root_name()</td><td>产生根名(或空路径)</td></tr><tr><td>p.root_directory()</td><td>产生根目录(或空路径)</td></tr><tr><td>p.root_path()</td><td>产生根元素(或空路径)</td></tr><tr><td>p.parent_path()</td><td>产生父路径(或空路径)</td></tr><tr><td>p.relative_path()</td><td>产生没有根元素的路径(或空路径)</td></tr><tr><td>p.begin()</td><td>路径迭代的开始</td></tr><tr><td>p.end()</td><td>路径迭代结束</td></tr></tbody></table><ul><li>如果一个路径有一个文件名，它也总是有一个茎。</li><li>空路径是一个相对路径（对于除is_empty()和is_relative()之外的所有其他操作，产生false或空路径）。<br>这些操作的结果可能取决于操作系统。例如，路径C:/hello.txt</li><li>在Unix系统上<ul><li>是相对的</li><li>没有根元素（既没有根名称也没有根目录），因为C:是一个文件名。</li><li>有父路径C:</li><li>具有相对路径C:/hello.txt</li></ul></li><li>在Windows系统上<ul><li>是绝对的</li><li>有根名称C：和根目录/</li><li>没有父路径</li><li>有相对路径 hello.txt</li></ul></li></ul><h6><span id="lu-jing-die-dai">路径迭代</span><a href="#lu-jing-die-dai" class="header-anchor">#</a></h6><p>你可以对一个路径进行迭代，产生路径中的元素：根名（如果有），根目录（如果有），以及所有的文件名。如果路径以目录分隔符结束，最后一个元素是一个空文件名。<br>迭代器是一个双向的迭代器，这样你就可以使用—-。迭代器引用的值又是路径类型的。然而，两个迭代器在同一路径上迭代时，即使它们引用了相同的元素，也可能不会引用相同的路径对象。<br>比如说：</p><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">printPath</span><span class="hljs-params">(<span class="hljs-type">const</span> std::filesystem::path&amp; p)</span></span><span class="hljs-function"></span>{    std::cout &lt;&lt; <span class="hljs-string">"path elements of "</span> &lt;&lt; p.string &lt;&lt; <span class="hljs-string">":\n"</span>;    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> pos = p.<span class="hljs-built_in">begin</span>(); pos != p.<span class="hljs-built_in">end</span>(); ++pos) {        std::filesystem::path elem = *pos;        std::cout &lt;&lt; <span class="hljs-string">" "</span> &lt;&lt; elem;    }    std::cout &lt;&lt; <span class="hljs-string">'\n'</span>;}</code></pre></div><p>如果这个函数被调用如下:</p><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-built_in">printPath</span>(<span class="hljs-string">"../sub/file.txt"</span>);<span class="hljs-built_in">printPath</span>(<span class="hljs-string">"/usr/tmp/test/dir/"</span>);<span class="hljs-built_in">printPath</span>(<span class="hljs-string">"C:\\usr\\tmp\\test\\dir\\"</span>);</code></pre></div><p>在基于POSIX的系统上的输出将是:</p><div class="code-wrapper"><pre><code class="hljs bash">path elements of <span class="hljs-string">"../sub/file.txt"</span>:<span class="hljs-string">".."</span> <span class="hljs-string">"sub"</span> <span class="hljs-string">"file.txt"</span>path elements of <span class="hljs-string">"/usr/tmp/test/dir/"</span>:<span class="hljs-string">"/"</span> <span class="hljs-string">"usr"</span> <span class="hljs-string">"tmp"</span> <span class="hljs-string">"test"</span> <span class="hljs-string">"dir"</span> <span class="hljs-string">""</span>path elements of <span class="hljs-string">"C:\\usr\\tmp\\test\\dir\\"</span>:<span class="hljs-string">"C:\\usr\\tmp\\test\\dir\\"</span></code></pre></div><p>注意，最后一个路径只是一个文件名，因为在基于POSIX的系统下，C:既不是有效的根名，反斜杠也不是有效的目录分隔符。<br>在Windows系统上的输出将是：</p><div class="code-wrapper"><pre><code class="hljs bash">path elements of <span class="hljs-string">"../sub/file.txt"</span>:<span class="hljs-string">".."</span> <span class="hljs-string">"sub"</span> <span class="hljs-string">"file.txt"</span>path elements of <span class="hljs-string">"/usr/tmp/test/dir/"</span>:<span class="hljs-string">"/"</span> <span class="hljs-string">"usr"</span> <span class="hljs-string">"tmp"</span> <span class="hljs-string">"test"</span> <span class="hljs-string">"dir"</span> <span class="hljs-string">""</span>path elements of <span class="hljs-string">"C:\\usr\\tmp\\test\\dir\\"</span>:<span class="hljs-string">"C:"</span> <span class="hljs-string">"\\"</span> <span class="hljs-string">"usr"</span> <span class="hljs-string">"tmp"</span> <span class="hljs-string">"test"</span> <span class="hljs-string">"dir"</span> <span class="hljs-string">""</span></code></pre></div><p>要检查一个路径p是否以目录分隔符结束，你可以实现:</p><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">if</span> (!p.<span class="hljs-built_in">empty</span>() &amp;&amp; (--p.<span class="hljs-built_in">end</span>())-&gt;<span class="hljs-built_in">empty</span>()) {    std::cout &lt;&lt; p &lt;&lt; <span class="hljs-string">" has a trailing separator\n"</span>;}</code></pre></div><h5><span id="20-3-3-lu-jing-i-o-he-zhuan-huan">20.3.3 路径I/O和转换</span><a href="#20-3-3-lu-jing-i-o-he-zhuan-huan" class="header-anchor">#</a></h5><p>表中路径I/O和转换列出了读取或写入以及产生转换后的路径的操作。<br>这些功能没有考虑到实际的文件系统。如果你必须处理符号链接重要的路径，你可能想使用与文件系统相关的路径转换。</p><table><thead><tr><th>调用</th><th>作用</th></tr></thead><tbody><tr><td>strm &lt;&lt; p</td><td>把路径的值写成引号字符串</td></tr><tr><td>strm &gt;&gt; p</td><td>将路径的值读成带引号的字符串</td></tr><tr><td>p.string()</td><td>得到的路径是std::string</td></tr><tr><td>p.wstring()</td><td>得到的路径是std::wstring</td></tr><tr><td>p.u8string()</td><td>产生路径的UTF-8字符串，类型为std::u8string</td></tr><tr><td>p.u16string()</td><td>产生路径的UTF-16字符串，类型为std::u16string</td></tr><tr><td>p.u32string()</td><td>产生路径的UTF-32字符串，类型为std::u32string</td></tr><tr><td>p.string&lt;…&gt;()</td><td>得到的路径是std::basic_string&lt;…&gt;。</td></tr><tr><td>p.lexically_normal()</td><td>产生 p 作为标准化路径</td></tr><tr><td>p.lexically_relative(p2)</td><td>产生从p2到p的路径（如果没有则为空路）。</td></tr><tr><td>p.lexically_proximate(p2)</td><td>产生从 p2 到 p 的路径（如果没有，则为 p）</td></tr></tbody></table><p>lexically_…()函数返回一个新的路径，而其他转换函数产生一个相应的字符串类型。这些函数都没有修改它们所调用的路径。<br>例如，下面的代码:</p><div class="code-wrapper"><pre><code class="hljs c++">std::filesystem::path p{<span class="hljs-string">"/dir/./sub//sub1/../sub2"</span>};std::cout &lt;&lt; <span class="hljs-string">"path: "</span> &lt;&lt; p &lt;&lt; <span class="hljs-string">'\n'</span>;std::cout &lt;&lt; <span class="hljs-string">"string(): "</span> &lt;&lt; p.<span class="hljs-built_in">string</span>() &lt;&lt; <span class="hljs-string">'\n'</span>;std::wcout &lt;&lt; <span class="hljs-string">"wstring(): "</span> &lt;&lt; p.<span class="hljs-built_in">wstring</span>() &lt;&lt; <span class="hljs-string">'\n'</span>;std::cout &lt;&lt; <span class="hljs-string">"lexically_normal(): "</span> &lt;&lt; p.<span class="hljs-built_in">lexically_normal</span>() &lt;&lt; <span class="hljs-string">'\n'</span>;</code></pre></div><p>对前三行有相同的输出:</p><div class="code-wrapper"><pre><code class="hljs bash">path: <span class="hljs-string">"/dir/./sub//sub1/../sub2"</span>string(): /dir/./sub//sub1/../sub2wstring(): /dir/./sub//sub1/../sub2</code></pre></div><p>但最后一行的输出取决于目录分隔符。在基于POSIX的系统中，它是:</p><div class="code-wrapper"><pre><code class="hljs bash">lexically_normal(): <span class="hljs-string">"/dir/sub/sub2"</span></code></pre></div><p>而在Windows上，它是:</p><div class="code-wrapper"><pre><code class="hljs bash">lexically_normal(): <span class="hljs-string">"\\dir\\sub\\sub2"</span></code></pre></div><h6><span id="lu-jing-i-o">路径I/O</span><a href="#lu-jing-i-o" class="header-anchor">#</a></h6><p>首先，请注意，I/O操作符是以带引号的字符串形式写入和读取路径。你必须把它们转换为字符串，以便在写它们时不加引号:</p><div class="code-wrapper"><pre><code class="hljs c++">std::filesystem::path file{<span class="hljs-string">"test.txt"</span>}std::cout &lt;&lt; file &lt;&lt; <span class="hljs-string">'\n'</span>; <span class="hljs-comment">// writes: "test.txt"</span>std::cout &lt;&lt; file.<span class="hljs-built_in">string</span>() &lt;&lt; <span class="hljs-string">'\n'</span>; <span class="hljs-comment">// writes: test.txt</span></code></pre></div><p>在Windows上，这有更糟糕的效果。下面的代码:</p><div class="code-wrapper"><pre><code class="hljs c++">std::filesystem::path tmp{<span class="hljs-string">"C:\\Windows\\Temp"</span>};std::cout &lt;&lt; tmp &lt;&lt; <span class="hljs-string">'\n'</span>;std::cout &lt;&lt; tmp.<span class="hljs-built_in">string</span>() &lt;&lt; <span class="hljs-string">'\n'</span>;std::cout &lt;&lt; <span class="hljs-string">'"'</span> &lt;&lt; tmp.<span class="hljs-built_in">string</span>() &lt;&lt; <span class="hljs-string">"\"\n"</span>;</code></pre></div><p>有以下输出:</p><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-string">"C:\\Windows\\Temp"</span>C:\Windows\Temp<span class="hljs-string">"C:\Windows\Temp"</span></code></pre></div><p>注意，读取文件名支持两种形式（带前导 “的引号和不带引号）。因此，所有打印出来的形式将被正确地读回，使用标准输入操作符的路径:</p><div class="code-wrapper"><pre><code class="hljs c++">std::filesystem::path tmp;std::cin &gt;&gt; tmp; <span class="hljs-comment">// 正确读取带引号和不带引号的路径</span></code></pre></div><h6><span id="zheng-chang-hua">正常化</span><a href="#zheng-chang-hua" class="header-anchor">#</a></h6><p>当你处理可移植代码时，malization可能有更多令人惊讶的结果。比如说：</p><div class="code-wrapper"><pre><code class="hljs c++">td::filesystem::path p2{<span class="hljs-string">"//dir\\subdir/subsubdir\\/./\\"</span>};std::cout &lt;&lt; <span class="hljs-string">"p2: "</span> &lt;&lt; p2 &lt;&lt; <span class="hljs-string">'\n'</span>;std::cout &lt;&lt; <span class="hljs-string">"lexically_normal(): "</span> &lt;&lt; p2.<span class="hljs-built_in">lexically_normal</span>() &lt;&lt; <span class="hljs-string">'\n'</span>;</code></pre></div><p>在Windows系统上有以下可能的预期输出:</p><div class="code-wrapper"><pre><code class="hljs bash">p2: <span class="hljs-string">"//host\\dir/sub\\/./\\"</span>lexically_normal(): <span class="hljs-string">"\\\\host\\dir\\sub\\"</span></code></pre></div><p>然而，在基于POSIX的系统上，输出变成了:</p><div class="code-wrapper"><pre><code class="hljs bash">p2: <span class="hljs-string">"//host\\dir/sub\\/./\\"</span>lexically_normal(): <span class="hljs-string">"/host\\dir/sub\\/\\"</span></code></pre></div><p>原因是在基于POSIX的系统中，反斜杠不是目录分隔符，也不是根名的有效字符，所以我们有一个绝对路径，有三个文件名host\dir、sub\和\。在基于POSIX的系统中，没有办法检测到反斜杠是一个可能的目录分隔符（在这种情况下，generic_string()和make_preferred()都没有帮助）。<br>因此，对于可移植代码来说，在处理路径时，你应该始终使用通用路径格式。<br>尽管如此，在迭代当前目录时，使用lexically_normal()函数去掉前面的点也是一个好办法。</p><h6><span id="xiang-dui-lu-jing">相对路径</span><a href="#xiang-dui-lu-jing" class="header-anchor">#</a></h6><p>lexically_relative()和lexically_proximate()都可以被调用来计算相对于<br>路径之间的相对路径。唯一的区别是在没有路径的情况下的行为，只有在一个路径是相对的，另一个是绝对的或者根名称不同的情况下才会发生。在这种情况下。</p><ul><li><p>p.lexically_relative(p2)如果没有从p2到p的相对路径，则产生空路径。</p></li><li><p>p.lexically_proximate(p2)如果没有从p2到p的相对路径，则产生p。<br>由于这两个操作都是词法操作，实际的文件系统（可能有符号链接）和current_path()都没有被考虑在内。如果两个路径相等，则相对路径为”.”。<br>例子:</p><div class="code-wrapper"><pre><code class="hljs c++">fs::path{<span class="hljs-string">"/a/d"</span>}.<span class="hljs-built_in">lexically_relative</span>(<span class="hljs-string">"/a/b/c"</span>) <span class="hljs-comment">// "../../d"</span>fs::path{<span class="hljs-string">"/a/b/c"</span>}.<span class="hljs-built_in">lexically_relative</span>(<span class="hljs-string">"/a/d"</span>) <span class="hljs-comment">// "../b/c"</span>fs::path{<span class="hljs-string">"/a/b"</span>}.<span class="hljs-built_in">lexically_relative</span>(<span class="hljs-string">"/a/b"</span>) <span class="hljs-comment">// "."</span>fs::path{<span class="hljs-string">"/a/b"</span>}.<span class="hljs-built_in">lexically_relative</span>(<span class="hljs-string">"/a/b/"</span>) <span class="hljs-comment">// "."</span>fs::path{<span class="hljs-string">"/a/b"</span>}.<span class="hljs-built_in">lexically_relative</span>(<span class="hljs-string">"/a/b\\"</span>) <span class="hljs-comment">// "."</span>fs::path{<span class="hljs-string">"/a/b"</span>}.<span class="hljs-built_in">lexically_relative</span>(<span class="hljs-string">"/a/d/../c"</span>) <span class="hljs-comment">// "../b</span>fs::path{<span class="hljs-string">"a/d/../b"</span>}.<span class="hljs-built_in">lexically_relative</span>(<span class="hljs-string">"a/c"</span>) <span class="hljs-comment">// "../d/../b"</span>fs::path{<span class="hljs-string">"a//d/..//b"</span>}.<span class="hljs-built_in">lexically_relative</span>(<span class="hljs-string">"a/c"</span>) <span class="hljs-comment">// "../d/../b"</span></code></pre></div><p>在Windows系统上，我们有:</p><div class="code-wrapper"><pre><code class="hljs c++">fs::path{<span class="hljs-string">"C:/a/b"</span>}.<span class="hljs-built_in">lexically_relative</span>(<span class="hljs-string">"c:/c/d"</span>) ; <span class="hljs-comment">// ""</span>fs::path{<span class="hljs-string">"C:/a/b"</span>}.<span class="hljs-built_in">lexically_relative</span>(<span class="hljs-string">"D:/c/d"</span>) ; <span class="hljs-comment">// ""</span>fs::path{<span class="hljs-string">"C:/a/b"</span>}.<span class="hljs-built_in">lexically_proximate</span>(<span class="hljs-string">"D:/c/d"</span>) ; <span class="hljs-comment">// "C:/a/b"</span></code></pre></div></li></ul><h6><span id="zhuan-huan-wei-zi-fu-chuan">转换为字符串</span><a href="#zhuan-huan-wei-zi-fu-chuan" class="header-anchor">#</a></h6><p>  使用u8string()，你可以将路径作为UTF-8字符串使用，这也是当今存储数据的常用格式。存储数据的常用格式。比如说;</p>  <div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-comment">// 将路径存储为UTF-8字符串:</span>std::vector&lt;std::string&gt; utf8paths; <span class="hljs-comment">// std::u8string with C++20</span><span class="hljs-keyword">for</span> (<span class="hljs-type">const</span> <span class="hljs-keyword">auto</span>&amp; entry : fs::<span class="hljs-built_in">directory_iterator</span>(p)) {    utf8paths.<span class="hljs-built_in">push_back</span>(entry.<span class="hljs-built_in">path</span>().<span class="hljs-built_in">u8string</span>());}</code></pre></div><p>  请注意，u8string()的返回值可能会在C++20中从std::string变为std::u8string（新的UTF-8字符串类型，与char8_t一起在<a href="https://wg21.link/p0482%EF%BC%8C%E7%94%A8%E4%BA%8EUTF-8%E5%AD%97%E7%AC%A6%EF%BC%89%E3%80%82">https://wg21.link/p0482，用于UTF-8字符）。</a><br>  成员模板string&lt;&gt;()可以用来转换为一个特殊的字符串类型，例如一个不区分大小写的字符串类型:</p>  <div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">ignoreCaseTraits</span> : <span class="hljs-keyword">public</span> std::char_traits&lt;<span class="hljs-type">char</span>&gt; {    <span class="hljs-comment">// 不敏感地比较两个字符的情况:</span>    <span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">bool</span> <span class="hljs-title">eq</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span>&amp; c1, <span class="hljs-type">const</span> <span class="hljs-type">char</span>&amp; c2)</span> </span>{        <span class="hljs-keyword">return</span> std::<span class="hljs-built_in">toupper</span>(c1) == std::<span class="hljs-built_in">toupper</span>(c2);    }    <span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">bool</span> <span class="hljs-title">lt</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span>&amp; c1, <span class="hljs-type">const</span> <span class="hljs-type">char</span>&amp; c2)</span> </span>{        <span class="hljs-keyword">return</span> std::<span class="hljs-built_in">toupper</span>(c1) &lt; std::<span class="hljs-built_in">toupper</span>(c2);    }    <span class="hljs-comment">// 比较s1和s2的多达n个字符:</span>    <span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">int</span> <span class="hljs-title">compare</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span>* s1, <span class="hljs-type">const</span> <span class="hljs-type">char</span>* s2, std::<span class="hljs-type">size_t</span> n)</span></span>;    <span class="hljs-comment">// 检索字符c在s中的位置:</span>    <span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">const</span> <span class="hljs-type">char</span>* <span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span>* s, std::<span class="hljs-type">size_t</span> n, <span class="hljs-type">const</span> <span class="hljs-type">char</span>&amp; c)</span></span>;};<span class="hljs-comment">// 为这类字符串定义一个特殊的类型:</span><span class="hljs-keyword">using</span> icstring = std::basic_string&lt;<span class="hljs-type">char</span>, ignoreCaseTraits&gt;;std::filesystem::path p{<span class="hljs-string">"/dir\\subdir/subsubdir\\/./\\"</span>};icstring s2 = p.<span class="hljs-built_in">string</span>&lt;<span class="hljs-type">char</span>,ignoreCaseTraits&gt;();</code></pre></div><p>还需要注意的是，你不应该使用同样提供的函数c_str()，因为它可以转换为本地字符串格式，可能是一个wchar_t，这样你就必须使用，例如 std::wcout而不是std::cout来将其写入流中。</p><h5><span id="20-3-4-ben-di-ge-shi-he-tong-yong-ge-shi-zhi-jian-de-zhuan-huan">20.3.4 本地格式和通用格式之间的转换</span><a href="#20-3-4-ben-di-ge-shi-he-tong-yong-ge-shi-zhi-jian-de-zhuan-huan" class="header-anchor">#</a></h5><p>在本地和通用格式之间的转换表列出了在通用路径格式和实际平台的特定实现格式之间的转换操作。</p><p>这些函数在基于POSIX的系统中应该没有影响，因为本地路径格式和通用路径格式之间没有区别。在其他平台上调用这些函数可能会有影响：</p><ul><li><p>generic…() path 函数产生转换为具有通用格式的相应字符串格式的路径，</p><table><thead><tr><th>调用</th><th>作用</th></tr></thead><tbody><tr><td>p.generic_string()</td><td>得到的路径是一个通用的std::string</td></tr><tr><td>p.generic_wstring()</td><td>得到的路径是一个通用的std::wstring</td></tr><tr><td>p.generic_u8string()</td><td>得到的路径是一个通用的std::u8string</td></tr><tr><td>p.generic_u16string()</td><td>得到的路径是一个通用的std::u16string</td></tr><tr><td>p.generic_u32string()</td><td>得到的路径是一个通用的std::u32string</td></tr><tr><td>p.generic_string&lt;…&gt;()</td><td>得到的路径是一个通用的std::basic_string&lt;…&gt;</td></tr><tr><td>p.native()</td><td>产生本地格式的路径，类型为path::string_type</td></tr><tr><td>conversionToNativeString</td><td>隐式转换为本地字符串类型</td></tr><tr><td>p.c_str()</td><td>产生作为本地字符串格式的字符序列的路径</td></tr><tr><td>p.make_preferred()</td><td>用本地格式替换p中的目录分隔符，并得到修改后的p</td></tr></tbody></table><ul><li>native()产生转换为本地字符串编码的路径，它由std::filesystem::path::string_type类型定义。在Windows下，这个类型是std::wstring类型，所以你必须使用std::wcout而不是std::cout来直接将其写入标准输出流。新的重载允许我们将本地字符串传递给文件流的新重载。</li><li>c_str()做了同样的事情，但产生的结果是一个空尾的字符序列。注意，使用这个函数也是不可移植的，因为在Windows上用std::cout打印序列并不能产生正确的输出。你必须在那里使用std::wcout。</li><li>make_preferred()用本地目录分隔符替换了除根名之外的任何目录分隔符。注意，这是唯一一个修改它所调用的路径的函数。因此，严格来说属于下一节修改路径的函数，但由于它处理的是本地格式的转换，所以也在这里列出。</li></ul><p>例如，在Windows下，下面的代码。</p><div class="code-wrapper"><pre><code class="hljs c++">std::filesystem::path p{<span class="hljs-string">"/dir\\subdir/subsubdir\\/./\\"</span>};std::cout &lt;&lt; <span class="hljs-string">"p: "</span> &lt;&lt; p &lt;&lt; <span class="hljs-string">'\n'</span>;std::cout &lt;&lt; <span class="hljs-string">"string(): "</span> &lt;&lt; p.<span class="hljs-built_in">string</span>() &lt;&lt; <span class="hljs-string">'\n'</span>;std::wcout &lt;&lt; <span class="hljs-string">"wstring(): "</span> &lt;&lt; p.<span class="hljs-built_in">wstring</span>() &lt;&lt; <span class="hljs-string">'\n'</span>;std::cout &lt;&lt; <span class="hljs-string">"lexically_normal(): "</span> &lt;&lt; p.<span class="hljs-built_in">lexically_normal</span>() &lt;&lt; <span class="hljs-string">'\n'</span>;std::cout &lt;&lt; <span class="hljs-string">"generic_string(): "</span> &lt;&lt; p.<span class="hljs-built_in">generic_string</span>() &lt;&lt; <span class="hljs-string">'\n'</span>;std::wcout &lt;&lt; <span class="hljs-string">"generic_wstring(): "</span> &lt;&lt; p.<span class="hljs-built_in">generic_wstring</span>() &lt;&lt; <span class="hljs-string">'\n'</span>;<span class="hljs-comment">// 因为它是Windows，而且本地字符串类型是wstring。:</span>std::wcout &lt;&lt; <span class="hljs-string">"native(): "</span> &lt;&lt; p.<span class="hljs-built_in">native</span>() &lt;&lt; <span class="hljs-string">'\n'</span>; <span class="hljs-comment">// Windows!</span>std::wcout &lt;&lt; <span class="hljs-string">"c_str(): "</span> &lt;&lt; p.<span class="hljs-built_in">c_str</span>() &lt;&lt; <span class="hljs-string">'\n'</span>;std::cout &lt;&lt; <span class="hljs-string">"make_preferred(): "</span> &lt;&lt; p.<span class="hljs-built_in">make_preferred</span>() &lt;&lt; <span class="hljs-string">'\n'</span>;std::cout &lt;&lt; <span class="hljs-string">"p: "</span> &lt;&lt; p &lt;&lt; <span class="hljs-string">'\n'</span>;</code></pre></div><p>有以下输出:</p><div class="code-wrapper"><pre><code class="hljs bash">p: <span class="hljs-string">"/dir\\subdir/subsubdir\\/./\\"</span>string(): /dir\subdir/subsubdir\/./\wstring(): /dir\subdir/subsubdir\/./\lexically_normal(): <span class="hljs-string">"\\dir\\subdir\\subsubdir\\"</span>generic_string(): /dir/subdir/subsubdir//.//generic_wstring(): /dir/subdir/subsubdir//.//native(): /dir\subdir/subsubdir\/./\c_str(): /dir\subdir/subsubdir\/./\make_preferred(): <span class="hljs-string">"\\dir\\subdir\\subsubdir\\\\.\\\\"</span>p: <span class="hljs-string">"\\dir\\subdir\\subsubdir\\\\.\\\\"</span></code></pre></div><p>再次注意:</p><ul><li>本地字符串类型是不可移植的。在Windows上它是一个wstring，在基于POSIX的系统上它是一个字符串，所以你必须使用cout而不是wcout来打印native()和c_str()的结果。使用wcout只对wstring()和generic_wstring()的返回值具有可移植性。generic_wstring()的返回值。</li><li>只有make_preferred()的调用会修改它所调用的路径。所有其他的调用使p 不受影响。</li></ul></li></ul><h5><span id="20-3-5-lu-jing-xiu-gai">20.3.5 路径修改</span><a href="#20-3-5-lu-jing-xiu-gai" class="header-anchor">#</a></h5><p>表Path Modifications列出了允许我们直接修改路径的操作。<br>+=和concat()只是在路径上添加新的字符，而/、/=和append()则是在路径上添加一个子 路径，并用当前目录的分隔符分隔:</p><div class="code-wrapper"><pre><code class="hljs c++">std::filesystem::path p{<span class="hljs-string">"myfile"</span>};p += <span class="hljs-string">".git"</span>; <span class="hljs-comment">// p: myfile.git</span>p /= <span class="hljs-string">".git"</span>; <span class="hljs-comment">// p: myfile.git/.git</span>p.<span class="hljs-built_in">concat</span>(<span class="hljs-string">"1"</span>); <span class="hljs-comment">// p: myfile.git/git1</span>p.<span class="hljs-built_in">append</span>(<span class="hljs-string">"1"</span>); <span class="hljs-comment">// p: myfile.git/git1/1</span>std::cout &lt;&lt; p &lt;&lt; <span class="hljs-string">'\n'</span>;std::cout &lt;&lt; p / p &lt;&lt; <span class="hljs-string">'\n'</span>;</code></pre></div><p>在基于POSIX的系统上，输出是:</p><div class="code-wrapper"><pre><code class="hljs bash"><span class="hljs-string">"myfile.git/.git1/1"</span><span class="hljs-string">"myfile.git/.git1/1/myfile.git/.git1/1"</span></code></pre></div><p>在Windows系统上，输出为:</p><div class="code-wrapper"><pre><code class="hljs bash"><span class="hljs-string">"myfile.git\\.git1\\1"</span><span class="hljs-string">"myfile.git\\.git1\\1\\myfile.git\\.git1\\1"</span></code></pre></div><p>注意，追加一个绝对子路径意味着替换现有的路径。例如，在:</p><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">namespace</span> fs = std::filesystem;<span class="hljs-keyword">auto</span> p1 = fs::<span class="hljs-built_in">path</span>(<span class="hljs-string">"/usr"</span>) / <span class="hljs-string">"tmp"</span>; <span class="hljs-comment">// path is /usr/tmp or /usr\tmp</span><span class="hljs-keyword">auto</span> p2 = fs::<span class="hljs-built_in">path</span>(<span class="hljs-string">"/usr/"</span>) / <span class="hljs-string">"tmp"</span>; <span class="hljs-comment">// path is /usr/tmp</span><span class="hljs-keyword">auto</span> p3 = fs::<span class="hljs-built_in">path</span>(<span class="hljs-string">"/usr"</span>) / <span class="hljs-string">"/tmp"</span>; <span class="hljs-comment">// path is /tmp</span></code></pre></div><table><thead><tr><th>调用</th><th>作用</th></tr></thead><tbody><tr><td>p = p2</td><td>指定一个新的路径</td></tr><tr><td>p = sv</td><td>指定一个字符串（视图）作为新的路径</td></tr><tr><td>p.assign(p2)</td><td>指定一个新的路径</td></tr><tr><td>p.assign(sv)</td><td>将一个字符串(视图)作为一个新的路径。</td></tr><tr><td>p.assign(beg, end)</td><td>将范围内的元素从开始到结束分配给路径</td></tr><tr><td>p1 / p2</td><td>将p2作为p1的子路径连接起来，产生路径。</td></tr><tr><td>p /= sub</td><td>将子路径作为子路径附加到路径p上</td></tr><tr><td>p.append(sub)</td><td>将子路径作为子路径附加到路径p上</td></tr><tr><td>p.append(beg, end)</td><td>将范围内从开始到结束的元素作为子路径附加到<br>路径p</td></tr><tr><td>p += str</td><td>将str的字符附加到路径p中</td></tr><tr><td>p.concat(sub)</td><td>将str的字符附加到路径p中</td></tr><tr><td>p.concat(beg, end)</td><td>将范围内从beg到end的元素追加到路径p中。</td></tr><tr><td>p.remove_filename()</td><td>从路径中删除尾部的文件名</td></tr><tr><td>p.replace_filename(repl)</td><td>替换尾部的文件名（如果有的话）</td></tr><tr><td>p.replace_extension()</td><td>删除任何尾部的文件名扩展名</td></tr><tr><td>p.replace_extension(repl)</td><td>替换尾部文件名的扩展名（如果有）。</td></tr><tr><td>p.clear()</td><td>使路径为空</td></tr><tr><td>p.swap(p2)</td><td>交换两个路径的值</td></tr><tr><td>swap(p1, p2)</td><td>交换两个路径的值</td></tr><tr><td>p.make_preferred()</td><td>用本地格式替换p中的目录分隔符，并产生<br>修改后的p</td></tr></tbody></table><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">auto</span> p4 = fs::<span class="hljs-built_in">path</span>(<span class="hljs-string">"/usr/"</span>) / <span class="hljs-string">"/tmp"</span>; <span class="hljs-comment">// path is /tmp</span></code></pre></div><p>我们有4个路径，分别指向两个不同的文件。</p><ul><li><p>p1和p2相等，指向文件/usr/tmp（注意，在Windows下它们相等，p1是/usr/tmp）。</p></li><li><p>p3和p4是相等的，指的是文件/tmp，因为附加了一个绝对路径。<br>对于根元素来说，是否分配了一个新元素也很重要。例如，在Windows下 </p><p>我们有:</p><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">auto</span> p1 = fs::<span class="hljs-built_in">path</span>(<span class="hljs-string">"usr"</span>) / <span class="hljs-string">"C:/tmp"</span>; <span class="hljs-comment">// path is C:/tmp</span><span class="hljs-keyword">auto</span> p2 = fs::<span class="hljs-built_in">path</span>(<span class="hljs-string">"usr"</span>) / <span class="hljs-string">"C:"</span>; <span class="hljs-comment">// path is C:</span><span class="hljs-keyword">auto</span> p3 = fs::<span class="hljs-built_in">path</span>(<span class="hljs-string">"C:"</span>) / <span class="hljs-string">""</span>; <span class="hljs-comment">// path is C:</span><span class="hljs-keyword">auto</span> p4 = fs::<span class="hljs-built_in">path</span>(<span class="hljs-string">"C:usr"</span>) / <span class="hljs-string">"/tmp"</span>; <span class="hljs-comment">// path is C:/tmp</span><span class="hljs-keyword">auto</span> p5 = fs::<span class="hljs-built_in">path</span>(<span class="hljs-string">"C:usr"</span>) / <span class="hljs-string">"C:tmp"</span>; <span class="hljs-comment">// path is C:usr\tmp</span><span class="hljs-keyword">auto</span> p6 = fs::<span class="hljs-built_in">path</span>(<span class="hljs-string">"C:usr"</span>) / <span class="hljs-string">"c:tmp"</span>; <span class="hljs-comment">// path is c:tmp</span><span class="hljs-keyword">auto</span> p7 = fs::<span class="hljs-built_in">path</span>(<span class="hljs-string">"C:usr"</span>) / <span class="hljs-string">"D:tmp"</span>; <span class="hljs-comment">// path is D:tmp</span></code></pre></div><p>函数make_preferred()将路径中的目录分隔符转换为本地格式。<br>比如说:</p><div class="code-wrapper"><pre><code class="hljs c++">std::filesystem::path p{<span class="hljs-string">"//server/dir//subdir///file.txt"</span>};p.<span class="hljs-built_in">make_preferred</span>();std::cout &lt;&lt; p &lt;&lt; <span class="hljs-string">'\n'</span>;</code></pre></div><p>写在基于POSIX的平台上:</p><div class="code-wrapper"><pre><code class="hljs bash"><span class="hljs-string">"//server/dir/subdir/file.txt"</span></code></pre></div><p>在Windows上，输出结果如下:</p><div class="code-wrapper"><pre><code class="hljs bash"><span class="hljs-string">"\\\\server\\dir\\\\subdir\\\\\\file.txt"</span></code></pre></div><p>请注意，前导根名不会被修改，因为它必须由两个斜线或反斜线组成。<br>还要注意的是，在基于POSIX的系统上，这个函数不能将反斜线转换为斜线，因为反斜线不被认为是目录分隔符。<br>replace_extension() 替换、添加或删除一个扩展名。</p><ul><li><p>如果文件有一个扩展名，它被替换</p></li><li><p>如果文件没有扩展名，将添加新的扩展名。</p></li><li><p>如果你跳过新的扩展名或者新的扩展名是空的，任何现有的扩展名都会被删除。<br>你是否在替换处放置一个前导点并不重要。该函数确保 例如：</p><div class="code-wrapper"><pre><code class="hljs c++">fs::path{<span class="hljs-string">"file.txt"</span>}.<span class="hljs-built_in">replace_extension</span>(<span class="hljs-string">"tmp"</span>) <span class="hljs-comment">// file.tmp</span>fs::path{<span class="hljs-string">"file.txt"</span>}.<span class="hljs-built_in">replace_extension</span>(<span class="hljs-string">".tmp"</span>) <span class="hljs-comment">// file.tmp</span>fs::path{<span class="hljs-string">"file.txt"</span>}.<span class="hljs-built_in">replace_extension</span>(<span class="hljs-string">""</span>) <span class="hljs-comment">// file</span>fs::path{<span class="hljs-string">"file.txt"</span>}.<span class="hljs-built_in">replace_extension</span>() <span class="hljs-comment">// file</span>fs::path{<span class="hljs-string">"dir"</span>}.<span class="hljs-built_in">replace_extension</span>(<span class="hljs-string">"tmp"</span>) <span class="hljs-comment">// dir.tmp</span>fs::path{<span class="hljs-string">".git"</span>}.<span class="hljs-built_in">replace_extension</span>(<span class="hljs-string">"tmp"</span>) <span class="hljs-comment">// .git.tmp</span></code></pre></div><p>注意，作为 “纯扩展名 “的文件名（如.git）不算是扩展名。</p></li></ul></li></ul><h5><span id="20-3-6-lu-jing-bi-jiao">20.3.6 路径比较</span><a href="#20-3-6-lu-jing-bi-jiao" class="header-anchor">#</a></h5><p>表路径比较列出了你可以用来比较两个不同路径的操作。<br>请注意，大多数比较不考虑文件系统，这意味着它们只进行词法操作，这很便宜，但可能会导致令人惊讶的返回值。</p><ul><li><p>使用==、!=和compare()，下列路径都是不同的。</p><div class="code-wrapper"><pre><code class="hljs bash">tmp1/f./tmp1/ftmp1/./ftmp1/tmp11/../f</code></pre></div><table><thead><tr><th>调用</th><th>作用</th></tr></thead><tbody><tr><td>p1 == p2</td><td>产生两个路径是否相等</td></tr><tr><td>p1 != p2</td><td>得出两条路径是否不相等</td></tr><tr><td>p1 &lt; p2</td><td>产生一个路径是否小于另一个路径的结果</td></tr><tr><td>p1 &lt;= p2</td><td>产生一条路径是否小于或等于另一条路径</td></tr><tr><td>p1 &gt;= p2</td><td>产生一条路径是否大于或等于另一条路径</td></tr><tr><td>p1 &gt; p2</td><td>产生一条路径是否大于另一条路径</td></tr><tr><td>p.compare(p2)</td><td>得出p2是否小于、等于或大于p的结论</td></tr><tr><td>p.compare(sv)</td><td>产生p2是否小于、等于或大于字符串(view)的结果，sv转换为路径</td></tr><tr><td>equivalent(p1, p2)</td><td>考虑到文件系统的昂贵的路径比较</td></tr></tbody></table><ul><li><p>只检测指定目录分隔符的不同格式。因此，下列路径都是相同的（只要反斜线是有效的目录分隔符）。</p><div class="code-wrapper"><pre><code class="hljs c++">tmp1/f/tmp1<span class="hljs-comment">//f</span>/tmp1\ftmp1/\/f</code></pre></div></li></ul><p>只有当你为每个路径调用lexically_normal()时，上面所有的路径才是相等的（只要反斜杠是有效的目录分隔符）。比如说:</p><div class="code-wrapper"><pre><code class="hljs c++">std::filesystem::path p1{<span class="hljs-string">"tmp1/f"</span>};std::filesystem::path p2{<span class="hljs-string">"./tmp1/f"</span>};p1 == p2 <span class="hljs-comment">// true</span>p1.<span class="hljs-built_in">compare</span>(p2) <span class="hljs-comment">// not 0</span>p1.<span class="hljs-built_in">lexically_normal</span>() == p2.<span class="hljs-built_in">lexically_normal</span>() <span class="hljs-comment">// true</span>p1.<span class="hljs-built_in">lexically_normal</span>().<span class="hljs-built_in">compare</span>(p2.<span class="hljs-built_in">lexically_normal</span>()) <span class="hljs-comment">// 0</span></code></pre></div><p>如果你想把文件系统考虑进去，以便正确处理符号链接，你可以使用equivalent()。然而，请注意，这个函数要求两个路径都代表现有的文件。因此，一个尽可能准确地比较路径的通用方法（但没有最好的性能） 是这样的:</p><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">pathsAreEqual</span><span class="hljs-params">(<span class="hljs-type">const</span> std::filesystem::path&amp; p1,</span></span><span class="hljs-params"><span class="hljs-function">                   <span class="hljs-type">const</span> std::filesystem::path&amp; p2)</span></span><span class="hljs-function"></span>{    <span class="hljs-keyword">return</span> <span class="hljs-built_in">exists</span>(p1) &amp;&amp; <span class="hljs-built_in">exists</span>(p2) ? <span class="hljs-built_in">equivalent</span>(p1, p2)        : p1.<span class="hljs-built_in">lexically_normal</span>() == p2.<span class="hljs-built_in">lexically_normal</span>();}</code></pre></div></li></ul><h5><span id="20-3-7-qi-ta-lu-jing-cao-zuo">20.3.7 其他路径操作</span><a href="#20-3-7-qi-ta-lu-jing-cao-zuo" class="header-anchor">#</a></h5><p>表中其他路径操作列出了尚未列出的其余路径操作。</p><table><thead><tr><th>调用</th><th>作用</th></tr></thead><tbody><tr><td>p.hash_value()</td><td>产生一个路径的哈希值</td></tr></tbody></table><p>注意，只有相等的路径才有相同的哈希值。也就是说，以下的路径产生不同的 哈希值：</p><div class="code-wrapper"><pre><code class="hljs bash">tmp1/f./tmp1/ftmp1/./ftmp1/tmp11/../f</code></pre></div><p>出于这个原因，你可能想在将路径放入哈希表之前将其规范化。</p><h4><span id="20-4-wen-jian-xi-tong-cao-zuo">20.4 文件系统操作</span><a href="#20-4-wen-jian-xi-tong-cao-zuo" class="header-anchor">#</a></h4><p>本节涵盖了考虑到当前文件系统的更昂贵的文件系统操作。<br>因为这些操作通常要考虑到文件系统（照顾现有文件、符号链接等），所以它们比纯路径操作要昂贵。 因此，它们通常是独立的函数。</p><h5><span id="20-4-1-wen-jian-shu-xing">20.4.1 文件属性</span><a href="#20-4-1-wen-jian-shu-xing" class="header-anchor">#</a></h5><ol><li>有几个属性你可以得到关于一个给定路径后面的文件。首先，表 “文件类型的操作 “列出了你可以调用的函数，以检查由路径p指定的文件是否存在以及它的整体类型（如果有的话）。注意，这些操作确实考虑到了文件系统，因此是独立的函数。</li><li>文件系统类型的函数与相应的file_type值相匹配。然而，请注意，这些函数（除了is_symlink()）遵循符号链接。也就是说，对于一个目录的符号链接，is_symlink()和is_directory()都会产生true。</li><li>还要注意的是，根据其他文件类型的定义，对于所有检查特殊文件（没有普通文件、没有目录、没有符号链接）的is_other()也会产生真值。</li><li>对于特定实现的文件类型，没有特定的便利函数，因此对它们来说 只有is_other()为真（如果我们有一个符号链接到这样的文件，则is_symlink()为真）。你可以 使用文件状态API来检查这些特定的类型。</li><li>为了不跟踪符号链接，使用symlink_status()并为返回的 file_status，正如接下来讨论的exists()。</li></ol><table><thead><tr><th>调用</th><th>作用</th></tr></thead><tbody><tr><td>exists(p)</td><td>产生是否有文件可以打开的结果</td></tr><tr><td>is_symlink(p)</td><td>产生文件p是否存在并且是一个符号链接</td></tr><tr><td>is_regular_file(p)</td><td>产生文件p是否存在并且是一个普通文件</td></tr><tr><td>is_directory(p)</td><td>产生文件p是否存在并且是一个目录</td></tr><tr><td>is_other(p)</td><td>产生文件是否存在 p 并且既不是常规也不是目录也不是符号链接</td></tr><tr><td>is_block_file(p)</td><td>产生文件p是否存在并且是一个块状的特殊文件</td></tr><tr><td>is_character_file(p)</td><td>产生文件p是否存在并且是一个特殊字符的文件</td></tr><tr><td>is_fifo(p)</td><td>产生文件 p 是否存在，并且是 FIFO 或管道文件</td></tr><tr><td>is_socket(p)</td><td>产生文件p是否存在并且是一个套接字文件</td></tr></tbody></table><h6><span id="jian-cha-wen-jian-shi-fou-cun-zai">检查文件是否存在</span><a href="#jian-cha-wen-jian-shi-fou-cun-zai" class="header-anchor">#</a></h6><p>exists()回答的问题是，是否有一个有效的文件可以打开。因此，正如刚才讨论的，它遵循符号链接。所以，如果有一个符号链接到一个不存在的文件，它就会产生错误。<br>因此，像这样的代码不会像预期的那样工作：</p><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-comment">// 如果还没有做，就创建一个符号链接到文件:</span><span class="hljs-keyword">if</span> (!<span class="hljs-built_in">exists</span>(p)) { <span class="hljs-comment">// OOPS：检查p所指的文件是否不存在</span>    std::filesystem::<span class="hljs-built_in">create_symlink</span>(file, p);}</code></pre></div><p>如果p已经作为一个不存在的文件的符号链接存在，它将尝试在已经存在符号链接的位置创建符号链接，并引发一个相应的异常。</p><p>因为多用户/多进程文件系统中的情况可能随时发生变化，通常最好的办法是尝试执行一个操作，并在操作失败时处理错误。因此，我们可以简单地调用操作并处理相应的异常或处理作为附加参数传递的错误代码。</p><p>然而，有时你需要检查一个文件是否存在（在执行文件系统操作之前）。例如，如果你想在一个特定的位置创建一个文件，而那里已经有一个符号链接，那么这个文件就会在一个可能意想不到的位置被创建或被覆盖。在这种情况下，你 在这种情况下，你应该检查文件是否存在，方法如下:</p><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">if</span> (!<span class="hljs-built_in">exists</span>(<span class="hljs-built_in">symlink_status</span>(p))) { <span class="hljs-comment">// OK: 检查p是否还不存在（作为符号链接）。</span>    ...}</code></pre></div><p>这里我们使用symlink_status()，它产生的是不跟随符号链接的状态，来检查 检查在p的位置是否存在任何文件。</p><h6><span id="qi-ta-wen-jian-shu-xing">其他文件属性</span><a href="#qi-ta-wen-jian-shu-xing" class="header-anchor">#</a></h6><p>文件属性的表操作列出了几个独立的函数来检查额外的文件属性。</p><table><thead><tr><th>调用</th><th>作用</th></tr></thead><tbody><tr><td>is_empty(p)</td><td>产生文件是否为空</td></tr><tr><td>file_size(p)</td><td>产生文件的大小</td></tr><tr><td>hard_link_count(p)</td><td>产生硬链接的数量</td></tr><tr><td>last_write_time(p)</td><td>产生最后一次写到一个文件的时间点</td></tr></tbody></table><p>请注意，一个路径是否为空和一个路径所指定的文件是否为是空的：</p><div class="code-wrapper"><pre><code class="hljs c++">p.<span class="hljs-built_in">empty</span>() <span class="hljs-comment">// 如果路径p是空的，则为真（廉价操作）。</span><span class="hljs-built_in">is_empty</span>(p) <span class="hljs-comment">// 如果路径p上的文件是空的，则为真(文件系统操作)</span></code></pre></div><p>file_size(p)返回文件p的大小，如果它作为常规文件存在的话（就像POSIX函数stat()的成员st_size一样）。对于所有其他的文件，其结果是执行定义的，不可移植。<br>hard_link_count(p) 返回一个文件在文件系统中存在的次数。通常这个数字是1，但在某些文件系统中，同一个文件可以存在于文件系统的不同位置（即有不同的路径）。这与符号链接不同，在符号链接中，一个文件指的是另一个文件。在这里，我们有一个具有不同路径的文件，可以直接访问它。只有当最后一个硬链接被删除时，文件本身才会被删除。文件本身也会被删除。</p><h6><span id="chu-li-zui-hou-yi-ci-xiu-gai">处理最后一次修改</span><a href="#chu-li-zui-hou-yi-ci-xiu-gai" class="header-anchor">#</a></h6><p>last_write_time(p)返回文件最后一次修改或写入的时间点。返回类型是标准Chrono库中用于时间点的特殊time_point类型:</p><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">namespace</span> std::filesystem {    <span class="hljs-keyword">using</span> file_time_type = chrono::time_point&lt;trivialClock&gt;;}</code></pre></div><p>时钟类型trivialClock是一个特定实现的时钟类型，反映了文件时间值的分辨率和范围。例如，你可以按以下方式使用它:</p><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">printFileTime</span><span class="hljs-params">(<span class="hljs-type">const</span> std::filesystem::path&amp; p)</span></span><span class="hljs-function"></span>{    <span class="hljs-keyword">auto</span> filetime = <span class="hljs-built_in">last_write_time</span>(p);    <span class="hljs-keyword">auto</span> diff = std::filesystem::file_time_type::clock::<span class="hljs-built_in">now</span>() - filetime;    std::cout &lt;&lt; p &lt;&lt; <span class="hljs-string">" is "</span>        &lt;&lt; std::chrono::<span class="hljs-built_in">duration_cast</span>&lt;std::chrono::seconds&gt;(diff).<span class="hljs-built_in">count</span>()        &lt;&lt; <span class="hljs-string">" Seconds old.\n"</span>;}</code></pre></div><p>这可能会输出:</p><div class="code-wrapper"><pre><code class="hljs bash"><span class="hljs-string">"fileattr.cpp"</span> is 4 Seconds old.</code></pre></div><p>而不是</p><div class="code-wrapper"><pre><code class="hljs c++">std::filesystem::file_time_type::clock::<span class="hljs-built_in">now</span>()</code></pre></div><p>在这个例子中，你也可以这样写:</p><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">decltype</span>(filetime)::clock::<span class="hljs-built_in">now</span>()</code></pre></div><p>请注意，文件系统时间点使用的时钟并不保证是标准的system_clock。由于这个原因，目前还没有标准化的支持将文件系统的时间点转换为time_t类型，以便在字符串或输出中使用它作为绝对时间。下面的函数 “大致 “地将任何时钟的时间点转换为time_t对象:</p><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> TimePoint&gt;</span><span class="hljs-function">std::<span class="hljs-type">time_t</span> <span class="hljs-title">toTimeT</span><span class="hljs-params">(TimePoint tp)</span></span><span class="hljs-function"></span>{    <span class="hljs-keyword">using</span> system_clock = std::chrono::system_clock;    <span class="hljs-keyword">return</span> system_clock::<span class="hljs-built_in">to_time_t</span>(system_clock::<span class="hljs-built_in">now</span>()                                   + (tp - <span class="hljs-keyword">decltype</span>(tp)::clock::<span class="hljs-built_in">now</span>()));}</code></pre></div><p>诀窍是计算出文件系统时间点相对于现在的持续时间，然后把这个差值加到系统时钟的当前时间上。这个函数并不精确，因为两个时钟可能有不同的分辨率，而且我们在稍微不同的时间调用now()两次。然而，在一般情况下 一般来说，这样做效果很好。<br>例如，对于一个路径p，我们可以调用:</p><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">auto</span> ftime = <span class="hljs-built_in">last_write_time</span>(p);std::<span class="hljs-type">time_t</span> t = <span class="hljs-built_in">toTimeT</span>(ftime);<span class="hljs-comment">// 转换为日历时间（包括跳过尾部换行）。:</span>std::string ts = <span class="hljs-built_in">ctime</span>(&amp;t);ts.<span class="hljs-built_in">resize</span>(ts.<span class="hljs-built_in">size</span>()<span class="hljs-number">-1</span>);std::cout &lt;&lt; <span class="hljs-string">"last access of "</span> &lt;&lt; p &lt;&lt; <span class="hljs-string">": "</span> &lt;&lt; ts &lt;&lt; <span class="hljs-string">'\n'</span>;</code></pre></div><p>其中可能会打印:</p><div class="code-wrapper"><pre><code class="hljs bash">last access of <span class="hljs-string">"fileattr.exe"</span>: Sun Jun 24 10:41:12 2018</code></pre></div><p>为了以我们想要的方式格式化一个字符串，我们可以调用:</p><div class="code-wrapper"><pre><code class="hljs c++">std::<span class="hljs-type">time_t</span> t = <span class="hljs-built_in">toTimeT</span>(ftime);<span class="hljs-type">char</span> mbstr[<span class="hljs-number">100</span>];<span class="hljs-keyword">if</span> (std::<span class="hljs-built_in">strftime</span>(mbstr, <span class="hljs-built_in">sizeof</span>(mbstr), <span class="hljs-string">"last access: %B %d, %Y at %H:%M\n"</span>,                  std::<span class="hljs-built_in">localtime</span>(&amp;t))) {    std::cout &lt;&lt; mbstr;}</code></pre></div><p>这可能会输出:</p><div class="code-wrapper"><pre><code class="hljs bash">last access: June 24, 2018 at 10:41</code></pre></div><p>将任何文件系统的时间点转换为字符串的一个有用的辅助工具是:</p><p><code>filesystem/ftimeAsString.hpp </code></p><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;chrono&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;filesystem&gt;</span></span><span class="hljs-function">std::string <span class="hljs-title">asString</span><span class="hljs-params">(<span class="hljs-type">const</span> std::filesystem::file_time_type&amp; ft)</span></span><span class="hljs-function"></span>{    <span class="hljs-keyword">using</span> system_clock = std::chrono::system_clock;    <span class="hljs-keyword">auto</span> t = system_clock::<span class="hljs-built_in">to_time_t</span>(system_clock::<span class="hljs-built_in">now</span>()                                     + (ft - std::filesystem::file_time_type::clock::<span class="hljs-built_in">now</span>()));    <span class="hljs-comment">// 转换为日历时间（包括跳过尾部的新行）。</span>    std::string ts = <span class="hljs-built_in">ctime</span>(&amp;t);    ts.<span class="hljs-built_in">resize</span>(ts.<span class="hljs-built_in">size</span>()<span class="hljs-number">-1</span>);    <span class="hljs-keyword">return</span> ts;}</code></pre></div><p>注意，ctime()和strftime()不是线程安全的，不能同时调用。<br>请参阅修改现有文件，了解修改最后一次写入权限的相应API。</p><h5><span id="20-4-2-wen-jian-zhuang-tai">20.4.2 文件状态</span><a href="#20-4-2-wen-jian-zhuang-tai" class="header-anchor">#</a></h5><p>为了避免文件系统的访问，有一个特殊的类型file_status，可以用来保持和修改缓存的文件类型和权限。<br>缓存的文件类型和权限。这个状态可以在询问特定路径的文件状态时被设置。</p><ul><li><p>当询问特定路径的文件状态时，如表 “文件状态的操作 “中所列。</p></li><li><p>当在一个目录上迭代时</p><table><thead><tr><th>调用</th><th>作用</th></tr></thead><tbody><tr><td>status(p)</td><td>产生文件p的file_status（包括符号链接)</td></tr><tr><td>symlink_status(p)</td><td>读取p的文件状态（不遵循符号链接）</td></tr></tbody></table></li></ul><p>不同的是，如果路径p在符号链接中解析，status()跟随链接并打印那里的文件属性（状态可能是没有文件），而symlink_status(p)打印的是符号链接本身的状态。<br>表file_status Operations列出了对file_status对象fs的可能调用。</p><table><thead><tr><th>调用</th><th>作用</th></tr></thead><tbody><tr><td>exists(fs)</td><td>产生一个文件是否存在。</td></tr><tr><td>is_regular_file(fs)</td><td>产生文件是否存在并且是一个常规文件</td></tr><tr><td>is_directory(fs)</td><td>产生文件是否存在并且是一个目录。</td></tr><tr><td>is_symlink(fs)</td><td>产生文件是否存在并且是一个符号链接。</td></tr><tr><td>is_other(fs)</td><td>产生文件是否存在，并且既不是普通文件也不是目录<br>也不是象征性链接</td></tr><tr><td>is_character_file(fs)</td><td>产生文件是否存在并且是一个特殊字符的文件。</td></tr><tr><td>is_block_file(fs)</td><td>产生文件是否存在并且是一个块状特殊文件。</td></tr><tr><td>is_fifo(fs)</td><td>产生文件是否存在并且是FIFO或管道文件</td></tr><tr><td>is_socket(fs)</td><td>产生文件是否存在并且是一个套接字。</td></tr><tr><td>fs.type()</td><td>产生文件的文件类型。</td></tr><tr><td>fs.permissions()</td><td>产生文件的权限。</td></tr></tbody></table><p>状态操作的一个好处是，你可以为同一个文件保存多个操作系统的调用。同一个文件。例如，不使用</p><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">if</span> (!<span class="hljs-built_in">is_directory</span>(path)) {    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">is_character_file</span>(path) || <span class="hljs-built_in">is_block_file</span>(path)) {        ...    }    ...}</code></pre></div><p>你最好执行:</p><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">auto</span> pathStatus{<span class="hljs-built_in">status</span>(path)};<span class="hljs-keyword">if</span> (!<span class="hljs-built_in">is_directory</span>(pathStatus)) {    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">is_character_file</span>(pathStatus) || <span class="hljs-built_in">is_block_file</span>(pathStatus)) {        ...    }    ...}</code></pre></div><p>另一个关键的好处是，通过使用symlink_status()，你可以在不遵循任何符号链接的情况下检查路径的状态。例如，这有助于检查某个特定路径上是否存在任何文件。<br>因为这些文件状态不使用操作系统，所以不提供返回错误代码的重载。提供。</p><p>路径参数的exists()和is_…()函数是调用和检查文件状态的type()的捷径。比如说:</p><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-built_in">is_regular_file</span>(mypath)</code></pre></div><p>快捷方式:</p><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-built_in">is_regular_file</span>(<span class="hljs-built_in">status</span>(mypath))</code></pre></div><p>捷径，它是</p><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-built_in">status</span>(mypath).<span class="hljs-built_in">type</span>() == file_type::regular</code></pre></div><h5><span id="20-4-3-quan-xian">20.4.3 权限</span><a href="#20-4-3-quan-xian" class="header-anchor">#</a></h5><p>处理文件权限的模式是从UNIX/POSIX世界中采用的。有一些位来表示对文件所有者、同一组的成员或所有其他人的阅读、写入和/或执行/搜索访问。此外，还有 “执行时设置用户ID”、”执行时设置组ID “和粘性位（或其他与系统有关的含义）的特殊位。<br>表Permission Bits列出了在命名空间std::filesystem中定义的bitmask范围枚举类型perms的值，它代表一个或多个权限位。</p><table><thead><tr><th>枚举</th><th>八进制</th><th>POSIX</th><th>意义</th></tr></thead><tbody><tr><td>none</td><td>0</td><td></td><td>未设置权限</td></tr><tr><td>owner_read</td><td>0400</td><td>S_IRUSR</td><td>对所有者的阅读权限</td></tr><tr><td>owner_write</td><td>0200</td><td>S_IWUSR</td><td>对所有者的写入权限</td></tr><tr><td>owner_exec</td><td>0100</td><td>S_IXUSR</td><td>所有者的执行/搜索权限</td></tr><tr><td>owner_all</td><td>0700</td><td>S_IRWXU</td><td>所有者的所有权限</td></tr><tr><td>group_read</td><td>040</td><td>S_IRGRP</td><td>组的读取权限</td></tr><tr><td>group_write</td><td>020</td><td>S_IWGRP</td><td>组的写入权限</td></tr><tr><td>group_exec</td><td>010</td><td>S_IXGRP</td><td>组的执行/搜索权限</td></tr><tr><td>group_all</td><td>070</td><td>S_IRWXG</td><td>群组的所有权限</td></tr><tr><td>others_read</td><td>04</td><td>S_IROTH</td><td>所有其他人的读取权限</td></tr><tr><td>others_write</td><td>02</td><td>S_IWOTH</td><td>所有其他人的写入权限</td></tr><tr><td>others_exec</td><td>01</td><td>S_IXOTH</td><td>所有其他人的执行/搜索权限</td></tr><tr><td>others_all</td><td>07</td><td>S_IRWXO</td><td>所有其他人的所有权限</td></tr><tr><td>all</td><td>0777</td><td></td><td>所有人的所有权限</td></tr><tr><td>set_uid</td><td>04000</td><td>S_ISUID</td><td>在执行时设置用户 ID</td></tr><tr><td>set_gid</td><td>02000</td><td>S_ISGID</td><td>在执行时设置组 ID</td></tr><tr><td>sticky_bit</td><td>01000</td><td>S_ISVTX</td><td>依赖于操作系统</td></tr><tr><td>mask</td><td>07000</td><td></td><td>所有可能位掩码</td></tr><tr><td>unkonwn</td><td>0xFFFF</td><td></td><td>权限未知</td></tr></tbody></table><p>你可以询问当前的权限，结果是检查返回的perms对象的位。<br>为了组合标志，你必须使用位操作符。比如说：</p><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-comment">// 如果可写:</span><span class="hljs-keyword">if</span> ((fileStatus.<span class="hljs-built_in">permissions</span>()     &amp; (fs::perms::owner_write | fs::perms::group_write        | fs::perms::others_write))    != fs::perms::none) {    ...}</code></pre></div><p>初始化比特掩码的一个更短的方法（但可能不太容易读懂）是直接使用相应的八进制值和放松枚举的初始化:</p><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-comment">// 如果可写:</span><span class="hljs-keyword">if</span> ((fileStatus.<span class="hljs-built_in">permissions</span>() &amp; fs::perms{<span class="hljs-number">0222</span>}) != fs::perms::none) {    ...}</code></pre></div><p>注意，在将结果与特定的值进行比较之前，你必须将&amp;表达式放在括号里。还要注意的是，你不能跳过比较，因为对于比特掩码范围的枚举类型，没有隐含的转换为bool。<br>再比如，要把一个文件的权限转换为UNIX ls -l命令中的字符串，你可以使用下面的辅助函数:</p><p><code>filesystem/permAsString.hpp</code></p><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;chrono&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;filesystem&gt;</span></span><span class="hljs-function">std::string <span class="hljs-title">asString</span><span class="hljs-params">(<span class="hljs-type">const</span> std::filesystem::perms&amp; pm)</span></span><span class="hljs-function"></span>{    <span class="hljs-keyword">using</span> perms = std::filesystem::perms;    std::string s;    s.<span class="hljs-built_in">resize</span>(<span class="hljs-number">9</span>);    s[<span class="hljs-number">0</span>] = (pm &amp; perms::owner_read) != perms::none ? <span class="hljs-string">'r'</span> : <span class="hljs-string">'-'</span>;    s[<span class="hljs-number">1</span>] = (pm &amp; perms::owner_write) != perms::none ? <span class="hljs-string">'w'</span> : <span class="hljs-string">'-'</span>;    s[<span class="hljs-number">2</span>] = (pm &amp; perms::owner_exec) != perms::none ? <span class="hljs-string">'x'</span> : <span class="hljs-string">'-'</span>;    s[<span class="hljs-number">3</span>] = (pm &amp; perms::group_read) != perms::none ? <span class="hljs-string">'r'</span> : <span class="hljs-string">'-'</span>;    s[<span class="hljs-number">4</span>] = (pm &amp; perms::group_write) != perms::none ? <span class="hljs-string">'w'</span> : <span class="hljs-string">'-'</span>;    s[<span class="hljs-number">5</span>] = (pm &amp; perms::group_exec) != perms::none ? <span class="hljs-string">'x'</span> : <span class="hljs-string">'-'</span>;    s[<span class="hljs-number">6</span>] = (pm &amp; perms::others_read) != perms::none ? <span class="hljs-string">'r'</span> : <span class="hljs-string">'-'</span>;    s[<span class="hljs-number">7</span>] = (pm &amp; perms::others_write) != perms::none ? <span class="hljs-string">'w'</span> : <span class="hljs-string">'-'</span>;    s[<span class="hljs-number">8</span>] = (pm &amp; perms::others_exec) != perms::none ? <span class="hljs-string">'x'</span> : <span class="hljs-string">'-'</span>;    <span class="hljs-keyword">return</span> s;}</code></pre></div><p>这允许你打印一个文件的权限，作为标准ostream命令的一部分:</p><div class="code-wrapper"><pre><code class="hljs c++">std::cout &lt;&lt; <span class="hljs-string">"permissions: "</span> &lt;&lt; <span class="hljs-built_in">asString</span>(<span class="hljs-built_in">status</span>(mypath).<span class="hljs-built_in">permissions</span>())    &lt;&lt; <span class="hljs-string">'\n'</span>;</code></pre></div><p>对于一个拥有所有者所有权限和所有其他人的读/执行权限的文件，可能的输出结果是:</p><div class="code-wrapper"><pre><code class="hljs bash">permissions: rwxr-xr-x</code></pre></div><p>然而，请注意，Windows的ACL（访问控制列表）方法并不真正适合这个方案。由于这个原因，在使用Visual C++时，可写文件总是设置了所有的读、写和执行位（即使它们不是可执行文件），带有只读标志的文件总是设置了所有的读和可执行位。这也影响了可移植地修改权限的API。</p><h5><span id="20-4-4-wen-jian-xi-tong-de-xiu-gai">20.4.4 文件系统的修改</span><a href="#20-4-4-wen-jian-xi-tong-de-xiu-gai" class="header-anchor">#</a></h5><p>你也可以通过创建和删除文件或修改现有文件来修改文件系统。</p><h6><span id="chuang-jian-he-shan-chu-wen-jian">创建和删除文件</span><a href="#chuang-jian-he-shan-chu-wen-jian" class="header-anchor">#</a></h6><p>创建和删除文件表列出了路径 p 创建和删除文件的操作。</p><table><thead><tr><th>调用</th><th>作用</th></tr></thead><tbody><tr><td>create_directory(p)</td><td>创建一个目录</td></tr><tr><td>create_directory(p, attrPath)</td><td>创建一个具有attrPath属性的目录。</td></tr><tr><td>create_directories(p)</td><td>创建一个目录和上面的所有目录，还不存在的目录</td></tr><tr><td>create_hard_link(old, new)</td><td>创建另一个文件系统的条目，以取代现有的文件old</td></tr><tr><td>create_symlink(to, new)</td><td>创建一个符号链接，从新文件到新文件。</td></tr><tr><td>create_directory_symlink(to, new)</td><td>创建一个符号链接，从新的目录连接到</td></tr><tr><td>copy(from, to)</td><td>复制一个任何类型的文件</td></tr><tr><td>copy(from, to, options)</td><td>复制一个带有选项的任何类型的文件</td></tr><tr><td>copy_file(from, to)</td><td>复制一个文件（但不是目录或符号链接）</td></tr><tr><td>copy_file(from, to, options)</td><td>拷贝一个带有选项的文件</td></tr><tr><td>copy_symlink(from, to)</td><td>复制一个符号链接（to指的是from指的地方）。</td></tr><tr><td>remove(p)</td><td>remove(p) 删除一个文件或空目录</td></tr><tr><td>remove_all(p)</td><td>删除p和其子树中的所有文件（如果有的话）任何）。</td></tr></tbody></table><p>没有创建普通文件的功能。这是由I/O流标准库涵盖的。<br>例如，下面的语句创建一个新的空文件（如果它还不存在）:</p><div class="code-wrapper"><pre><code class="hljs c++">std::ofstream{<span class="hljs-string">"log.txt"</span>};</code></pre></div><p>创建一个或多个目录的函数会返回是否创建了一个新目录。 因此，查找已经存在的目录不会出错。 但是，在那里找到不是目录的文件也不是错误。 因此，在 create_directory() 或 create_directories() 返回 false 之后，您不知道是否已经存在请求的目录或其他内容。 当然，如果您之后对该文件执行特定于目录的操作并获得异常，您会发现它可能没问题（因为处理这个罕见的问题可能不值得付出努力）。 但是，如果您想要更正错误消息或出于其他原因必须确保确实有一个目录，您必须执行以下操作：</p><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">if</span> (!<span class="hljs-built_in">create_directory</span>(myPath) &amp;&amp; !<span class="hljs-built_in">is_directory</span>(myPath)) {    std::cerr &lt;&lt; <span class="hljs-string">"OOPS, \""</span> &lt;&lt; myPath.<span class="hljs-built_in">string</span>() &lt;&lt; <span class="hljs-string">"\" is already something else\n"</span>;    ... <span class="hljs-comment">// 处理这个错误</span>}</code></pre></div><p>copy…() 函数不适用于特殊文件类型。 默认情况下，它们：</p><ul><li><p>如果现有文件被覆盖，则报告错误</p></li><li><p>不要递归操作</p></li><li><p>按照符号链接<br>这个默认值可以被参数 options 覆盖，它具有位掩码范围的枚举类型 copy_options，定义在命名空间 std::filesystem 中。 表复制选项。 列出可能的值。</p><table><thead><tr><th>复制选项</th><th>作用</th></tr></thead><tbody><tr><td>none</td><td>默认值（值 0）</td></tr><tr><td>skip_existing</td><td>跳过覆盖现有文件</td></tr><tr><td>overwrite_existing</td><td>覆盖现有文件</td></tr><tr><td>update_existing</td><td>如果新文件较新，则覆盖现有文件</td></tr><tr><td>recursive</td><td>递归复制子目录及其内容</td></tr><tr><td>copy_symlinks</td><td>将符号链接复制为符号链接</td></tr><tr><td>skip_symlinks</td><td>忽略符号链接</td></tr><tr><td>directories_only</td><td>仅复制目录</td></tr><tr><td>create_hard_links</td><td>创建额外的硬链接而不是文件副本</td></tr><tr><td>create_symlinks</td><td>创建符号链接而不是文件副本（源路径必须是<br>绝对路径，除非目标路径在当前目录中）</td></tr></tbody></table><p>rename() 可以处理任何类型的文件，包括目录和符号链接。 对于符号链接，链接被重命名，而不是它所指的位置。 请注意， rename() 需要包含文件名的完整新路径才能将其移动到不同的目录：</p><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-comment">// move "tmp/sub/x" to "tmp/x":</span>std::filesystem::<span class="hljs-built_in">rename</span>(<span class="hljs-string">"tmp/sub/x"</span>, <span class="hljs-string">"top"</span>); <span class="hljs-comment">// ERROR</span>std::filesystem::<span class="hljs-built_in">rename</span>(<span class="hljs-string">"tmp/sub/x"</span>, <span class="hljs-string">"top/x"</span>); <span class="hljs-comment">// OK</span></code></pre></div><p>last_write_time() 使用处理上次修改中描述的时间点格式。 例如：</p><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-comment">// 创建文件p（更新最后的文件访问）。:</span><span class="hljs-built_in">last_write_time</span>(p, std::filesystem::file_time_type::clock::<span class="hljs-built_in">now</span>());</code></pre></div><p>permissions() 使用权限中描述的权限 API 格式。 可选模式是位掩码枚举类型 perm_options，在命名空间 std::filesystem 中定义。 它一方面允许在替换、添加和删除之间进行选择，另一方面允许使用 nofollow 来修改符号链接而不是它们所引用的文件的权限。<br>例如：</p><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-comment">// 删除组的写访问权限和其他人的任何访问权限:</span><span class="hljs-built_in">permissions</span>(mypath,            std::filesystem::perms::group_write            | std::filesystem::perms::others_all,            std::filesystem::perm_options::remove);</code></pre></div><p>再次注意，Windows 由于其 ACL 权限概念仅支持两种模式：</p><ul><li><p>读取、写入和执行/搜索所有 (rwxrwxrwx)</p></li><li><p>读取、执行/搜索所有（r-xr-xr-x）<br>要在这两种模式之间进行可移植的切换，您必须同时启用或禁用所有三个写入标志（一个接一个地删除不起作用）：</p><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-comment">// 启用/禁用写访问的可移植值:</span><span class="hljs-keyword">auto</span> allWrite = std::filesystem::perms::owner_write| std::filesystem::perms::group_write| std::filesystem::perms::others_write;<span class="hljs-comment">// 可移植地删除写入权限:</span><span class="hljs-built_in">permissions</span>(file, allWrite, std::filesystem::perm_options::remove);</code></pre></div><p>初始化allWrite的一个更短的方法（但可能不那么好读）（使用放松的枚举初始化）如下。:</p><div class="code-wrapper"><pre><code class="hljs c++">std::filesystem::perms allWrite{<span class="hljs-number">0222</span>};</code></pre></div><p>resize_file() 可用于减小或扩展常规文件的大小：例如：</p><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-comment">// 使文件为空:</span><span class="hljs-built_in">resize_file</span>(file, <span class="hljs-number">0</span>);</code></pre></div></li></ul></li></ul><h5><span id="20-4-5-fu-hao-lian-jie-he-yi-lai-wen-jian-xi-tong-de-lu-jing-zhuan-huan">20.4.5 符号链接和依赖文件系统的路径转换</span><a href="#20-4-5-fu-hao-lian-jie-he-yi-lai-wen-jian-xi-tong-de-lu-jing-zhuan-huan" class="header-anchor">#</a></h5><p>表中文件系统路径转换列出了处理文件路径的操作，其中考虑到了文件系统。如果你需要处理符号链接，这一点尤其重要。对于不考虑文件系统的廉价路径转换，请参见纯路径转换。<br>注意，这些调用对文件是否必须存在、是否规范化以及是否遵循符号链接的处理方式不同。表中的文件系统路径转换属性给出了这些函数的要求和执行情况的概述。<br>下面的函数演示了大多数这些操作的用法和效果（在处理符号链接时）:</p><p><code>filesystem/symlink.hpp </code></p><table><thead><tr><th align="left">调用</th><th align="left">作用</th></tr></thead><tbody><tr><td align="left">read_symlink(symlink)</td><td align="left">产生现有符号链接引用的文件</td></tr><tr><td align="left">absolute(p)</td><td align="left">产生现有的 p 作为绝对路径（不遵循符号链接）</td></tr><tr><td align="left">canonical(p)</td><td align="left">产生现有的 p 作为绝对路径（遵循符号链接）</td></tr><tr><td align="left">weakly_canonical(p)</td><td align="left">产生 p 作为绝对路径（遵循符号链接）</td></tr><tr><td align="left">relative(p)</td><td align="left">产生从当前目录到 p 的相对（或空）路径</td></tr><tr><td align="left">relative(p, base)</td><td align="left">产生从 base 到 p 的相对（或空）路径</td></tr><tr><td align="left">proximate(p)</td><td align="left">产生从当前目录到 p 的相对（或绝对）路径</td></tr><tr><td align="left">proximate(p, base)</td><td align="left">产生从 base 到 p 的相对（或绝对）路径</td></tr></tbody></table><table><thead><tr><th align="left">调用</th><th align="left">必须存在</th><th align="left">规范化</th><th align="left">遵循符号链接</th></tr></thead><tbody><tr><td align="left">read_symlink()</td><td align="left">yes</td><td align="left">yes</td><td align="left">once</td></tr><tr><td align="left">absolute()</td><td align="left">no</td><td align="left">yes</td><td align="left">no</td></tr><tr><td align="left">canonical()</td><td align="left">yes</td><td align="left">yes</td><td align="left">all</td></tr><tr><td align="left">weakly_canonical()</td><td align="left">no</td><td align="left">yes</td><td align="left">all</td></tr><tr><td align="left">relative()</td><td align="left">no</td><td align="left">yes</td><td align="left">all</td></tr><tr><td align="left">proximate()</td><td align="left">no</td><td align="left">yes</td><td align="left">all</td></tr></tbody></table><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;filesystem&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">testSymLink</span><span class="hljs-params">(std::filesystem::path top)</span></span><span class="hljs-function"></span>{    top = <span class="hljs-built_in">absolute</span>(top); <span class="hljs-comment">// 在我们更改当前路径时使用绝对路径</span>    <span class="hljs-built_in">create_directory</span>(top); <span class="hljs-comment">// 确保 top 存在</span>    <span class="hljs-built_in">current_path</span>(top); <span class="hljs-comment">// 这样我们就可以将目录更改为它</span>    std::cout &lt;&lt; std::filesystem::<span class="hljs-built_in">current_path</span>() &lt;&lt; <span class="hljs-string">'\n'</span>; <span class="hljs-comment">// 打印top路径</span>    <span class="hljs-comment">// 定义我们的子目录（不创建它们）:</span>    std::filesystem::path px{top / <span class="hljs-string">"a/x"</span>};    std::filesystem::path py{top / <span class="hljs-string">"a/y"</span>};    std::filesystem::path ps{top / <span class="hljs-string">"a/s"</span>};    <span class="hljs-comment">// 打印一些相对路径（对于不存在的文件）：</span>    std::cout &lt;&lt; px.<span class="hljs-built_in">relative_path</span>() &lt;&lt; <span class="hljs-string">'\n'</span>; <span class="hljs-comment">// 相对路径，从top</span>    std::cout &lt;&lt; px.<span class="hljs-built_in">lexically_relative</span>(py) &lt;&lt; <span class="hljs-string">'\n'</span>; <span class="hljs-comment">// 从 py 到 px: "../x"</span>    std::cout &lt;&lt; <span class="hljs-built_in">relative</span>(px, py) &lt;&lt; <span class="hljs-string">'\n'</span>; <span class="hljs-comment">// 从 py 到 px: "../x"</span>    std::cout &lt;&lt; <span class="hljs-built_in">relative</span>(px) &lt;&lt; <span class="hljs-string">'\n'</span>; <span class="hljs-comment">// 从curr.path到px : "a/x"</span>    std::cout &lt;&lt; px.<span class="hljs-built_in">lexically_relative</span>(ps) &lt;&lt; <span class="hljs-string">'\n'</span>; <span class="hljs-comment">// 从 ps 到 px: "../x"</span>    std::cout &lt;&lt; <span class="hljs-built_in">relative</span>(px, ps) &lt;&lt; <span class="hljs-string">'\n'</span>; <span class="hljs-comment">// 从 ps 到 px: "../x"</span>    <span class="hljs-comment">// 现在创建所有子目录和符号链接:</span>    <span class="hljs-built_in">create_directories</span>(px);    <span class="hljs-built_in">create_directories</span>(py);    <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">is_symlink</span>(ps)) {        <span class="hljs-built_in">create_directory_symlink</span>(top, ps);    }    std::cout &lt;&lt; <span class="hljs-string">"ps: "</span> &lt;&lt; ps &lt;&lt; <span class="hljs-string">'\n'</span>        &lt;&lt; <span class="hljs-string">" -&gt; "</span> &lt;&lt; <span class="hljs-built_in">read_symlink</span>(ps) &lt;&lt; <span class="hljs-string">'\n'</span>;    <span class="hljs-comment">// 并查看词法和文件系统相关之间的区别:</span>    std::cout &lt;&lt; px.<span class="hljs-built_in">lexically_relative</span>(ps) &lt;&lt; <span class="hljs-string">'\n'</span>; <span class="hljs-comment">// 从 ps 到 px: "../x"</span>    std::cout &lt;&lt; <span class="hljs-built_in">relative</span>(px, ps) &lt;&lt; <span class="hljs-string">'\n'</span>; <span class="hljs-comment">// 从 ps 到 px: "a/x"</span>}</code></pre></div><p>注意，我们首先将可能的相对路径转换为绝对路径，因为否则改变当前路径会影响路径变量的位置。 relative_path()和lexically_relative()是廉价的路径成员函数，没有考虑到实际的文件系统。因此，它们忽略了符号链接。独立的函数relative()<br>将文件系统考虑在内。只要我们还没有文件，它的作用就像lexically_relative()。但在创建符号链接ps（top/a/s）之后，它就会跟随符号链接，并给出不同的结果。<br>在POSIX系统中，从”/tmp “调用该函数，参数为 “top”，其输出结果如下:</p><div class="code-wrapper"><pre><code class="hljs bash"><span class="hljs-string">"/tmp/sub"</span><span class="hljs-string">"tmp/sub/a/x"</span><span class="hljs-string">"../x"</span><span class="hljs-string">"../x"</span><span class="hljs-string">"a/x"</span><span class="hljs-string">"../x"</span><span class="hljs-string">"../x"</span>ps: <span class="hljs-string">"/tmp/sub/a/s"</span> -&gt; <span class="hljs-string">"/tmp/sub"</span><span class="hljs-string">"../x"</span><span class="hljs-string">"a/x"</span></code></pre></div><p>在Windows系统中，从 “C:/temp “调用该函数，参数为 “top”，输出结果为如下所示:</p><div class="code-wrapper"><pre><code class="hljs bash"><span class="hljs-string">"C:\\temp\\top"</span><span class="hljs-string">"temp\\top\\a/x"</span><span class="hljs-string">"..\\x"</span><span class="hljs-string">"..\\x"</span><span class="hljs-string">"a\\x"</span><span class="hljs-string">"..\\x"</span><span class="hljs-string">"..\\x"</span>ps: <span class="hljs-string">"C:\\temp\\top\\a/s"</span> -&gt; <span class="hljs-string">"C:\\temp\\top"</span><span class="hljs-string">"..\\x"</span><span class="hljs-string">"a\\x"</span></code></pre></div><p>请再次注意，你需要管理员权限才能在Windows上创建符号链接。</p><h5><span id="20-4-6-qi-ta-wen-jian-xi-tong-cao-zuo">20.4.6 其他文件系统操作</span><a href="#20-4-6-qi-ta-wen-jian-xi-tong-cao-zuo" class="header-anchor">#</a></h5><p>表 “其他操作 “列出了尚未提及的其他文件系统操作。</p><table><thead><tr><th>调用</th><th>作用</th></tr></thead><tbody><tr><td>equivalent(p1, p2)</td><td>得出 p1 和 p2 是否引用同一个文件</td></tr><tr><td>space(p)</td><td>产生有关路径 p 处可用磁盘空间的信息</td></tr><tr><td>current_path(p)</td><td>将当前工作目录的路径设置为 p</td></tr></tbody></table><p>在关于路径比较的章节中讨论了equivalent()函数。<br>space()的返回值是以下结构：</p><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">namespace</span> std::filesystem {    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">space_info</span> {        <span class="hljs-type">uintmax_t</span> capacity;        <span class="hljs-type">uintmax_t</span> free;        <span class="hljs-type">uintmax_t</span> available;    };}</code></pre></div><p>因此，使用结构化绑定可以打印 root 的可用磁盘空间，如下所示：</p><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">auto</span> [cap, _, avail] = std::filesystem::<span class="hljs-built_in">space</span>(<span class="hljs-string">"/"</span>);std::cout &lt;&lt; std::fixed &lt;&lt; std::<span class="hljs-built_in">precision</span>(<span class="hljs-number">2</span>)    &lt;&lt; avail/<span class="hljs-number">1.0e6</span> &lt;&lt; <span class="hljs-string">" of "</span> &lt;&lt; cap/<span class="hljs-number">1.0e6</span> &lt;&lt; <span class="hljs-string">" MB available\n\n"</span>;</code></pre></div><p>输出可能是例如：</p><div class="code-wrapper"><pre><code class="hljs bash">43019.82 of 150365.79 MB available</code></pre></div><p>为路径参数调用的 current_path() 会修改整个程序的当前工作目录（因此，它适用于所有线程）。 离开范围时，您可以通过以下方式切换到另一个工作目录并恢复旧目录：</p><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">auto</span> current{std::filesystem::<span class="hljs-built_in">current_path</span>()};<span class="hljs-keyword">try</span> {    std::filesystem::<span class="hljs-built_in">current_path</span>(subdir);    ...;}<span class="hljs-built_in">catch</span> (...) {    std::filesystem::<span class="hljs-built_in">current_path</span>(current);    <span class="hljs-keyword">throw</span>;}std::filesystem::<span class="hljs-built_in">current_path</span>(subdir);</code></pre></div><h4><span id="20-5-bian-li-mu-lu">20.5 遍历目录</span><a href="#20-5-bian-li-mu-lu" class="header-anchor">#</a></h4><p>文件系统库的一个关键应用是遍历目录或文件系统（子）树的所有文件。<br>最方便的方法是使用基于范围的 for 循环。 您可以遍历目录中的所有文件：</p> <div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">for</span> (<span class="hljs-type">const</span> <span class="hljs-keyword">auto</span>&amp; e : std::filesystem::<span class="hljs-built_in">directory_iterator</span>(dir)) {    std::cout &lt;&lt; e.<span class="hljs-built_in">path</span>() &lt;&lt; <span class="hljs-string">'\n'</span>;}</code></pre></div><p>或递归遍历文件系统（子）树中的所有文件：</p><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">for</span> (<span class="hljs-type">const</span> <span class="hljs-keyword">auto</span>&amp; e : std::filesystem::<span class="hljs-built_in">recursive_directory_iterator</span>(dir)) {    std::cout &lt;&lt; e.<span class="hljs-built_in">path</span>() &lt;&lt; <span class="hljs-string">'\n'</span>;}</code></pre></div><p>传递的参数 dir 可以是路径或任何可隐式转换为路径的内容（尤其是所有形式的字符串）；<br>请注意， e.path() 产生的文件名包括迭代开始的目录。</p><p>因此，如果我们遍历“.” 文件名 file.txt 变为 ./file.txt 或 .\file.txt。</p><p>此外，此路径被引用到流中，因此此文件名的输出变为“./file.txt”或“.\file.txt”。 因此，正如之前在初始示例中所讨论的，以下循环更便于移植：</p><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">for</span> (<span class="hljs-type">const</span> <span class="hljs-keyword">auto</span>&amp; e : std::filesystem::<span class="hljs-built_in">directory_iterator</span>(dir)) {    std::cout &lt;&lt; e.<span class="hljs-built_in">path</span>().<span class="hljs-built_in">lexically_normal</span>().<span class="hljs-built_in">string</span>() &lt;&lt; <span class="hljs-string">'\n'</span>;}</code></pre></div><p>要在当前目录上进行迭代，你应该传递”. “作为当前目录而不是””。传递一个空的路径在Windows上是可行的，但不能移植。</p><h6><span id="fan-wei-de-mu-lu-die-dai-qi">范围的目录迭代器</span><a href="#fan-wei-de-mu-lu-die-dai-qi" class="header-anchor">#</a></h6><p>你可以将一个迭代器传递给一个基于范围的for循环，这可能看起来令人惊讶，因为你通常需要一个范围。</p><p>诀窍在于，directory_iterator和recursive_directory_iterator都是提供begin()和end()的全局重载的类。</p><ul><li>begin()产生迭代器本身。</li><li>end()产生结束迭代器，你也可以用默认的构造函数来创建它。</li></ul><p> 出于这个原因，你也可以按以下方式进行迭代。</p><div class="code-wrapper"><pre><code class="hljs c++">std::filesystem::directory_iterator di{p};<span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> pos = <span class="hljs-built_in">begin</span>(di); pos != <span class="hljs-built_in">end</span>(di); ++pos) {    std::cout &lt;&lt; pos-&gt;<span class="hljs-built_in">path</span>() &lt;&lt; <span class="hljs-string">'\n'</span>;}</code></pre></div><p>或者如下:</p><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">for</span> (std::filesystem::directory_iterator pos{p};     pos != std::filesystem::directory_iterator{};     ++pos) {    std::cout &lt;&lt; pos-&gt;<span class="hljs-built_in">path</span>() &lt;&lt; <span class="hljs-string">'\n'</span>;}</code></pre></div><h6><span id="mu-lu-die-dai-qi-xuan-xiang">目录迭代器选项</span><a href="#mu-lu-die-dai-qi-xuan-xiang" class="header-anchor">#</a></h6><p>遍历目录时，您可以传递 directory_options 类型的值，这些值列在表 Directory Iterator Options 中。 该类型是位掩码范围的枚举类型，在命名空间 std::filesystem 中定义。</p><table><thead><tr><th>目录选项</th><th>作用</th></tr></thead><tbody><tr><td>none</td><td>默认（值 0）</td></tr><tr><td>follow_directory_symlink</td><td>跟随符号链接（而不是跳过它们）</td></tr><tr><td>skip_permission_denied</td><td>跳过权限被拒绝的目录</td></tr></tbody></table><p>默认情况下，不跟踪符号链接，并跳过你不允许迭代的目录。使用 skip_permission_denied 遍历一个被拒绝的目录时，会产生一个异常。<br>createfiles.cpp显示了follow_directory_symlink的一个应用:</p><h5><span id="20-5-1-mu-lu-tiao-mu">20.5.1 目录条目</span><a href="#20-5-1-mu-lu-tiao-mu" class="header-anchor">#</a></h5><p>目录迭代器所迭代的元素是std::filesystem::directory_entry类型的。因此，如果一个目录迭代器是有效的，operator*()就会产生该类型。这意味着，基于范围的for循环的正确类型如下。</p><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">for</span> (<span class="hljs-type">const</span> std::filesystem::directory_entry&amp; e     : std::filesystem::<span class="hljs-built_in">directory_iterator</span>(p)) {    std::cout &lt;&lt; e.<span class="hljs-built_in">path</span>() &lt;&lt; <span class="hljs-string">'\n'</span>;}</code></pre></div><p>目录条目既包含路径对象，也包含额外的属性，如硬链接计数、文件状态、文件大小、最后写入时间、是否是符号链接，以及如果是的话，它指向哪里。</p><p>注意，这些迭代器是输入迭代器。原因是在一个目录上迭代可能导致不同的结果，因为在任何时候目录条目都可能改变。在并行算法中使用目录迭代器时，必须考虑到这一点。</p><p>表中目录条目操作列出了你可以为一个目录条目e调用的操作，它们或多或少是你可以调用的查询文件属性、获取文件状态检查权限和比较路径的操作。</p><table><thead><tr><th>调用</th><th>作用</th></tr></thead><tbody><tr><td>e.path()</td><td>产生当前条目的文件系统路径</td></tr><tr><td>e.exists()</td><td>产生文件是否存在</td></tr><tr><td>e.is_regular_file()</td><td>产生文件是否存在并且是一个普通文件</td></tr><tr><td>e.is_directory()</td><td>产生文件是否存在并且是一个目录</td></tr><tr><td>e.is_symlink()</td><td>得出文件是否存在并且是一个符号链接</td></tr><tr><td>e.is_other()</td><td>产生文件是否存在，并且既不是常规文件也不是目录也不是象征性链接</td></tr><tr><td>e.is_block_file()</td><td>产生文件是否存在并且是一个块状特殊文件</td></tr><tr><td>e.is_character_file()</td><td>产生文件是否存在并且是一个特殊字符的文件。</td></tr><tr><td>e.is_fifo()</td><td>产生文件是否存在，并且是FIFO或管道文件</td></tr><tr><td>e.is_socket()</td><td>产生文件是否存在并且是一个套接字。</td></tr><tr><td>e.file_size()</td><td>产生文件的大小。</td></tr><tr><td>e.hard_link_count()</td><td>产生硬链接的数量</td></tr><tr><td>e.last_write_time()</td><td>产生最后一次写到文件的时间点</td></tr><tr><td>e.status()</td><td>产生文件的状态p</td></tr><tr><td>e.symlink_status()</td><td>产生文件的状态（在符号链接之后） p</td></tr><tr><td>e1 == e2</td><td>产生两个入口的路径是否相等</td></tr><tr><td>e1 != e2</td><td>产生两个入口路径是否不相等</td></tr><tr><td>e1 &lt; e2</td><td>产生是否一个条目路径小于另一个条目路径的结果</td></tr><tr><td>e1 &lt;= e2</td><td>产生一个条目路径是否比另一个条目路径小或相等</td></tr><tr><td>e1 &gt;= e2</td><td>产生一个条目路径是否大于或等于另一个条目路径</td></tr><tr><td>e1 &gt; e2</td><td>产生一个条目路径是否大于另一个条目路径。</td></tr><tr><td>e.assign(p)</td><td>用p替换e的路径并更新所有条目属性</td></tr><tr><td>e.replace_filename(p)</td><td>用p替换e的当前路径的文件名并更新所有条目属性</td></tr><tr><td>e.refresh()</td><td>更新此条目的所有缓存属性</td></tr></tbody></table><p>assign()和replace_filename()调用相应的修改路径操作，但不修改底层文件系统中的文件。</p><h6><span id="mu-lu-tiao-mu-huan-cun">目录条目缓存</span><a href="#mu-lu-tiao-mu-huan-cun" class="header-anchor">#</a></h6><p>我们鼓励实现者缓存这些额外的文件属性，以避免在使用条目时对文件系统的额外访问。然而，实现并不要求缓存数据，这意味着这些通常很便宜的操作可能会变得更昂贵。<br>因为所有的值通常都被缓存了，这些调用通常是廉价的，因此是成员函数。</p><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">for</span> (<span class="hljs-type">const</span> <span class="hljs-keyword">auto</span>&amp; e : std::filesystem::directory_iterator{<span class="hljs-string">"."</span>}){    <span class="hljs-keyword">auto</span> t = e.<span class="hljs-built_in">last_write_time</span>(); <span class="hljs-comment">// 通常便宜</span>    ...}</code></pre></div><p>无论是否有缓存，在一个多用户或多进程的操作系统中，所有这些迭代可能产生不再有效的文件数据。文件内容和大小可能会改变，文件可能被删除或替换（因此，甚至文件类型也可能改变），权限可能被修改。<br>在这种情况下，你可以要求刷新一个目录项所持有的数据:</p><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">for</span> (<span class="hljs-type">const</span> <span class="hljs-keyword">auto</span>&amp; e : std::filesystem::directory_iterator{<span class="hljs-string">"."</span>}){    ...; <span class="hljs-comment">// 数据数据变旧</span>    e.<span class="hljs-built_in">refresh</span>(); <span class="hljs-comment">// 刷新文件的缓存数据</span>    <span class="hljs-keyword">if</span> (e.<span class="hljs-built_in">exists</span>()) {        <span class="hljs-keyword">auto</span> t = e.<span class="hljs-built_in">last_write_time</span>();        ...;    }}</code></pre></div><p>另外，你可能总是问当前的情况：</p><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">for</span> (<span class="hljs-type">const</span> <span class="hljs-keyword">auto</span>&amp; e : std::filesystem::directory_iterator{<span class="hljs-string">"."</span>}){    ...; <span class="hljs-comment">// 数据数据变旧</span>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">exists</span>(e.<span class="hljs-built_in">path</span>())) {        <span class="hljs-keyword">auto</span> t = <span class="hljs-built_in">last_write_time</span>(e.<span class="hljs-built_in">path</span>());        ...    }}</code></pre></div><h4><span id="20-6-hou-ji">20.6 后记</span><a href="#20-6-hou-ji" class="header-anchor">#</a></h4><p>文件系统库在Beman Dawes的领导下作为一个Boost库开发了多年。在2014年，它第一次成为一个正式的测试标准，即文件系统技术规范（见<a href="https://wg21.link/n4100%EF%BC%89%E3%80%82">https://wg21.link/n4100）。</a><br>随着<a href="https://wg21.link/p0218r0%EF%BC%8C%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E6%8A%80%E6%9C%AF%E8%A7%84%E8%8C%83%E8%A2%AB%E9%87%87%E7%BA%B3%E4%B8%BA">https://wg21.link/p0218r0，文件系统技术规范被采纳为</a> 由Beman Dawes提出的标准库。对计算相对路径的支持被添加到<br>由Beman Dawes, Nicolai Josuttis和Jamie Allsop在<a href="https://wg21.link/p0219r1%E3%80%82%E7%94%B1Beman">https://wg21.link/p0219r1。由Beman</a> Dawes在<a href="https://wg21.link/p0317r1">https://wg21.link/p0317r1</a> 中提议增加了几个小的修正。Nicolai Josuttis在<a href="https://wg21.link/p0392r0%EF%BC%8CJason">https://wg21.link/p0392r0，Jason</a> Liu和Hubert Tong在https: //wg21.link/p0430r2，特别是文件系统小组的成员（Beman Dawes, S. Davis Herring, Nicolai Josuttis, Jason Liu, Billy O’Neal, P.J. Plauger, and Jonathan Wakely）在<a href="https://wg21.link/p0492r2%E3%80%82">https://wg21.link/p0492r2。</a></p>]]></content>
    
    
    
    <tags>
      
      <tag>C++17</tag>
      
      <tag>STL</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>第二部分-模板特性</title>
    <link href="/2022/03/19/%E7%AC%AC%E4%BA%8C%E9%83%A8%E5%88%86%20%E6%A8%A1%E6%9D%BF%E7%89%B9%E6%80%A7/"/>
    <url>/2022/03/19/%E7%AC%AC%E4%BA%8C%E9%83%A8%E5%88%86%20%E6%A8%A1%E6%9D%BF%E7%89%B9%E6%80%A7/</url>
    
    <content type="html"><![CDATA[<h2><span id="di-er-bu-fen-mo-ban-te-xing">第二部分: 模板特性</span><a href="#di-er-bu-fen-mo-ban-te-xing" class="header-anchor">#</a></h2><h3><span id="9-lei-mo-ban-can-shu-tui-dao">9 类模板参数推导</span><a href="#9-lei-mo-ban-can-shu-tui-dao" class="header-anchor">#</a></h3><p>C++17之前，你必须显式指定类模板的所有模板参数类型。比如，你不能忽略这里的double：</p><div class="code-wrapper"><pre><code class="hljs c++">std::complex&lt;<span class="hljs-type">double</span>&gt; c{<span class="hljs-number">5.1</span>,<span class="hljs-number">3.3</span>};</code></pre></div><p>也不能忽略第二次的<code>std::mutex</code>：</p><div class="code-wrapper"><pre><code class="hljs c++">std::mutex mx;<span class="hljs-function">std::lock_guard&lt;std::mutex&gt; <span class="hljs-title">lg</span><span class="hljs-params">(mx)</span></span>;</code></pre></div><p>C++17开始，必须显式指定类模板的所有模板参数类型这个限制变得宽松了。有了类模板参数推导（class template argument deduction，CTAD）技术，如果构造函数可以推导出所有模板参数，那么你可以跳过显式指定模板实参。</p><p>比如：</p><ul><li>你可以这样声明：</li></ul><div class="code-wrapper"><pre><code class="hljs c++">std::complex c{<span class="hljs-number">5.1</span>,<span class="hljs-number">3.3</span>}; <span class="hljs-comment">// 好的：推断出 std::complex&lt;double&gt;</span></code></pre></div><ul><li>你可以这样实现：</li></ul><div class="code-wrapper"><pre><code class="hljs c++">std::mutex mx;std::lock_guard lg{mx}; <span class="hljs-comment">// OK: 推断出 std::lock_guard&lt;std_mutex&gt;</span></code></pre></div><ul><li>你甚至可以让容器推导其元素的类型：</li></ul><div class="code-wrapper"><pre><code class="hljs c++">std::vector v1 {<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>} <span class="hljs-comment">// OK: 推断出 std::vector&lt;int&gt;</span>std::vector v2 {<span class="hljs-string">"hello"</span>, <span class="hljs-string">"world"</span>}; <span class="hljs-comment">// OK: 推断出 std::vector&lt;const char*&gt; </span></code></pre></div><h4><span id="9-1-lei-mo-ban-can-shu-tui-dao-de-shi-yong">9.1 类模板参数推导的使用</span><a href="#9-1-lei-mo-ban-can-shu-tui-dao-de-shi-yong" class="header-anchor">#</a></h4><p>只要传给构造函数的实参可以用来推导类型模板参数，那么就可以使用类模板参数推导技术。该技术支持所有初始化方式：</p><div class="code-wrapper"><pre><code class="hljs c++">std::complex c1{<span class="hljs-number">1.1</span>, <span class="hljs-number">2.2</span>}; <span class="hljs-comment">// 推断出  std::complex&lt;double&gt;</span><span class="hljs-function">std::complex <span class="hljs-title">c2</span><span class="hljs-params">(<span class="hljs-number">2.2</span>, <span class="hljs-number">3.3</span>)</span></span>; <span class="hljs-comment">// 推断出  std::complex&lt;double&gt;</span>std::complex c3 = <span class="hljs-number">3.3</span>; <span class="hljs-comment">// 推断出  std::complex&lt;double&gt;</span>std::complex c4 = {<span class="hljs-number">4.4</span>}; <span class="hljs-comment">// 推断出  std::complex&lt;double&gt;</span></code></pre></div><p>c3和c4的初始化方式是可行的，因为你可以传递一个值来初始化<code>std::complex&lt;&gt;</code>，这对于推导出模板参数T来说足够了，它会被用于实数和虚数部分：</p><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">namespace</span> std {    <span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;    <span class="hljs-keyword">class</span> <span class="hljs-title class_">complex</span> {        <span class="hljs-function"><span class="hljs-keyword">constexpr</span> <span class="hljs-title">complex</span><span class="hljs-params">(<span class="hljs-type">const</span> T&amp; re = T(), <span class="hljs-type">const</span> T&amp; im = T())</span></span>;        ...    }};</code></pre></div><p>假设有如下声明</p><div class="code-wrapper"><pre><code class="hljs c++">std::complex c1{<span class="hljs-number">1.1</span>, <span class="hljs-number">2.2</span>};</code></pre></div><p>编译器会在调用的地方找到构造函数</p><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">constexpr</span> <span class="hljs-title">complex</span><span class="hljs-params">(<span class="hljs-type">const</span> T&amp; re = T(), <span class="hljs-type">const</span> T&amp; im = T())</span></span>;</code></pre></div><p>因为两个参数T都是double，所以编译器推导出T是double，然后编译下面的代码：</p><div class="code-wrapper"><pre><code class="hljs c++">complex&lt;<span class="hljs-type">double</span>&gt;::<span class="hljs-built_in">complex</span>(<span class="hljs-type">const</span> <span class="hljs-type">double</span>&amp; re = <span class="hljs-built_in">double</span>(),                         <span class="hljs-type">const</span> <span class="hljs-type">double</span>&amp; im = <span class="hljs-built_in">double</span>());</code></pre></div><p>注意模板参数必须是无歧义、可推导的。因此，下面的初始化是有问题的：</p><div class="code-wrapper"><pre><code class="hljs c++">std::complex c5{<span class="hljs-number">5</span>,<span class="hljs-number">3.3</span>}; <span class="hljs-comment">// 错误：尝试将 int 和 double 作为 T</span></code></pre></div><p>对于模板来说，不会在推导模板参数的时候做类型转换。</p><p>对于可变参数模板的类模板参数推导也是支持的。比如，<code>std::tuple&lt;&gt;</code>定义如下：</p><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">namespace</span> std {  <span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span>... Types&gt;  <span class="hljs-keyword">class</span> <span class="hljs-title class_">tuple</span>;    <span class="hljs-keyword">public</span>:    <span class="hljs-function"><span class="hljs-keyword">constexpr</span> <span class="hljs-title">tuple</span><span class="hljs-params">(<span class="hljs-type">const</span> Types&amp;...)</span></span>;    ...  };};</code></pre></div><p>这个声明：</p><div class="code-wrapper"><pre><code class="hljs c++">std::tuple t{<span class="hljs-number">42</span>, <span class="hljs-string">'x'</span>, <span class="hljs-literal">nullptr</span>};</code></pre></div><p>推导出的类型是<code>std::tuple</code>。</p><p>你也可以推导出非类型模板参数。举个例子，像下面例子中传递一个数组，在推导模板参数的时候可以同时推导出元素类型和数组大小：</p><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T, <span class="hljs-type">int</span> SZ&gt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">MyClass</span> {    <span class="hljs-keyword">public</span>:    <span class="hljs-built_in">MyClass</span> (<span class="hljs-built_in">T</span>(&amp;)[SZ]) {        ...    }};<span class="hljs-function">MyClass <span class="hljs-title">mc</span><span class="hljs-params">(<span class="hljs-string">"hello"</span>)</span></span>; <span class="hljs-comment">// 将 T 推导出为 const char 并将 SZ 推导出为 6</span></code></pre></div><p>SZ推导为6，因为模板参数类型传递了一个六个字符的字符串字面值。</p><p>你甚至可以推导出<strong>用作基类的lambda</strong>的类型，或者推导出<strong>auto模板参数</strong>类型。</p><h5><span id="9-1-1-mo-ren-fu-zhi">9.1.1 默认复制</span><a href="#9-1-1-mo-ren-fu-zhi" class="header-anchor">#</a></h5><p>如果类模板参数推导发现一个行为更像是拷贝初始化，它就倾向于这么认为。比如，在用一个元素初始化<code>std::vector</code>后：</p><div class="code-wrapper"><pre><code class="hljs c++">std::vector v1{<span class="hljs-number">42</span>}; <span class="hljs-comment">// 带有一个元素的vector&lt;int&gt;</span></code></pre></div><p>用这个vector去初始化另一个vector：</p><div class="code-wrapper"><pre><code class="hljs c++">std::vector v2{v1}; <span class="hljs-comment">// v2 也是 vector&lt;int&gt;</span></code></pre></div><p>v2会被解释为<code>vector</code>而不是<code>vector&gt;</code></p><p>又比如，这个规则适用于下面所有初始化形式：</p><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-function">std::vector <span class="hljs-title">v3</span><span class="hljs-params">(v1)</span></span>; <span class="hljs-comment">// v3 也是 vector&lt;int&gt;</span>std::vector v4 = {v1}; <span class="hljs-comment">// v4 也是 vector&lt;int&gt;</span><span class="hljs-keyword">auto</span> v5 = std::vector{v1}; <span class="hljs-comment">// v5 也是 vector&lt;int&gt;</span></code></pre></div><p>如果传递多个元素时，就不能被解释为拷贝初始化，此时initializer list的类型会成为新vector的元素类型：</p><div class="code-wrapper"><pre><code class="hljs c++">std::vector vv{v, v}; <span class="hljs-comment">// vv vector&lt;vector&lt;int&gt;&gt;</span></code></pre></div><p>那么问题来了，如果传递可变参数模板，那么类模板参数推导会发生什么：</p><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span>... Args&gt;</span><span class="hljs-function"><span class="hljs-keyword">auto</span> <span class="hljs-title">make_vector</span><span class="hljs-params">(<span class="hljs-type">const</span> Args&amp;... elems)</span> </span>{    <span class="hljs-keyword">return</span> std::vector{elems...};}std::vector&lt;<span class="hljs-type">int</span>&gt; v{<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>};<span class="hljs-keyword">auto</span> x1 = <span class="hljs-built_in">make_vector</span>(v, v); <span class="hljs-comment">// vector&lt;vector&lt;int&gt;&gt;</span><span class="hljs-keyword">auto</span> x2 = <span class="hljs-built_in">make_vector</span>(v); <span class="hljs-comment">// vector&lt;int&gt; 或vector&lt;vector&lt;int&gt;&gt; ?</span></code></pre></div><p>当前，不同的编译器有不同的处理方式，这个问题还在讨论中。</p><h5><span id="9-1-2-tui-dao-lambda-de-lei-xing">9.1.2 推导 Lambda 的类型</span><a href="#9-1-2-tui-dao-lambda-de-lei-xing" class="header-anchor">#</a></h5><p>有了类模板参数推导，我们现在终于可以用lambda的类型实例化类模板类。举个例子，我们可以提供一个泛型类，然后包装一下callback，并统计调用了多少次callback：</p><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-comment">// tmpl/classarglambda.hpp</span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;utility&gt;</span> <span class="hljs-comment">// for std::forward()</span></span><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> CB&gt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">CountCalls</span>{<span class="hljs-keyword">private</span>:  CB callback; <span class="hljs-comment">// callback to call</span>  <span class="hljs-type">long</span> calls = <span class="hljs-number">0</span>; <span class="hljs-comment">// counter for calls</span><span class="hljs-keyword">public</span>:  <span class="hljs-built_in">CountCalls</span>(CB cb) : <span class="hljs-built_in">callback</span>(cb) {  }  <span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span>... Args&gt;</span><span class="hljs-function">  <span class="hljs-keyword">auto</span> <span class="hljs-title">operator</span><span class="hljs-params">()</span> <span class="hljs-params">(Args&amp;&amp;... args)</span> </span>{    ++calls;    <span class="hljs-keyword">return</span> <span class="hljs-built_in">callback</span>(std::forward&lt;Args&gt;(args)...);  }  <span class="hljs-function"><span class="hljs-type">long</span> <span class="hljs-title">count</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>{    <span class="hljs-keyword">return</span> calls;  }};</code></pre></div><p>这里，构造函数接受一个callback，然后包装一下，用它的类型来推导出模板参数CB。比如，我们可以传一个lambda：</p><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-function">CountCalls <span class="hljs-title">sc</span><span class="hljs-params">([](<span class="hljs-keyword">auto</span> x, <span class="hljs-keyword">auto</span> y) {</span></span><span class="hljs-params"><span class="hljs-function">    <span class="hljs-keyword">return</span> x &gt; y;</span></span><span class="hljs-params"><span class="hljs-function">})</span></span>;</code></pre></div><p>这意味着sc的类型被推导为<code>CountCalls</code>。</p><p>通过这种方式，我们可以计算传递给排序函数的sc的调用次数：</p><div class="code-wrapper"><pre><code class="hljs c++">std::<span class="hljs-built_in">sort</span>(v.<span class="hljs-built_in">begin</span>(), v.<span class="hljs-built_in">end</span>(),          td::<span class="hljs-built_in">ref</span>(sc));std::cout &lt;&lt; <span class="hljs-string">"sorted with "</span> &lt;&lt; sc.<span class="hljs-built_in">count</span>() &lt;&lt; <span class="hljs-string">" calls\n"</span>;</code></pre></div><p>包装后的lambda通过引用的方式传递给排序函数，因为如若不然<code>std::sort()</code>只会计算传递给他的lambda的拷贝的调用，毕竟是传值的方式。</p><p>然而，我没可以传递包装后的lambda给<code>std::for_each</code>，因为这个算法可以返回传递给他的callback的拷贝：</p><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">auto</span> fo = std::for_each(v.<span class="hljs-built_in">begin</span>(), v.<span class="hljs-built_in">end</span>(),                        <span class="hljs-built_in">CountCalls</span>([](<span class="hljs-keyword">auto</span> i) {                                      std::cout &lt;&lt; <span class="hljs-string">"elem: "</span> &lt;&lt; i &lt;&lt; <span class="hljs-string">'\n'</span>;                        }));std::cout &lt;&lt; <span class="hljs-string">"output with "</span> &lt;&lt; fo.<span class="hljs-built_in">count</span>() &lt;&lt; <span class="hljs-string">" calls\n"</span>;</code></pre></div><h5><span id="9-1-3-fei-bu-fen-lei-mo-ban-can-shu-tui-dao">9.1.3 非部分类模板参数推导</span><a href="#9-1-3-fei-bu-fen-lei-mo-ban-can-shu-tui-dao" class="header-anchor">#</a></h5><p>不像函数模板那样，类模板参数不能部分推导（显示模板参数的一部分）。比如：</p><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T1, <span class="hljs-keyword">typename</span> T2, <span class="hljs-keyword">typename</span> T3 = T2&gt;<span class="hljs-keyword">class</span> C {    <span class="hljs-keyword">public</span>:    <span class="hljs-built_in">C</span> (T1 x = T1{}, T2 y = T2{}, T3 z = T3{}) {        ...    }    ...};<span class="hljs-comment">// all deduced:</span><span class="hljs-function">C <span class="hljs-title">c1</span><span class="hljs-params">(<span class="hljs-number">22</span>, <span class="hljs-number">44.3</span>, <span class="hljs-string">"hi"</span>)</span></span>; <span class="hljs-comment">// OK：T1 是 int，T2 是 double，T3 是 const char*</span><span class="hljs-function">C <span class="hljs-title">c2</span><span class="hljs-params">(<span class="hljs-number">22</span>, <span class="hljs-number">44.3</span>)</span></span>; <span class="hljs-comment">// OK: T1 是 int，T2 和 T3 是 double</span><span class="hljs-function">C <span class="hljs-title">c3</span><span class="hljs-params">(<span class="hljs-string">"hi"</span>, <span class="hljs-string">"guy"</span>)</span></span>; <span class="hljs-comment">// OK: T1、T2 和 T3 是 const char*</span><span class="hljs-comment">// only some deduced:</span><span class="hljs-function">C&lt;string&gt; <span class="hljs-title">c4</span><span class="hljs-params">(<span class="hljs-string">"hi"</span>, <span class="hljs-string">"my"</span>)</span></span>; <span class="hljs-comment">// ERROR: 只有 T1 明确定义</span>C&lt;&gt; <span class="hljs-built_in">c5</span>(<span class="hljs-number">22</span>, <span class="hljs-number">44.3</span>); <span class="hljs-comment">// ERROR: 既不是 T1 也不是 T2 明确定义</span>C&lt;&gt; <span class="hljs-built_in">c6</span>(<span class="hljs-number">22</span>, <span class="hljs-number">44.3</span>, <span class="hljs-number">42</span>); <span class="hljs-comment">// ERROR: T1 和 T2 都没有明确定义</span><span class="hljs-comment">// all specified:</span>C&lt;string,string,<span class="hljs-type">int</span>&gt; c7; <span class="hljs-comment">// OK: T1,T2 是字符串，T3 是整数</span><span class="hljs-function">C&lt;<span class="hljs-type">int</span>,string&gt; <span class="hljs-title">c8</span><span class="hljs-params">(<span class="hljs-number">52</span>, <span class="hljs-string">"my"</span>)</span></span>; <span class="hljs-comment">// OK: T1 是 int，T2 和 T3 是字符串</span><span class="hljs-function">C&lt;string,string&gt; <span class="hljs-title">c9</span><span class="hljs-params">(<span class="hljs-string">"a"</span>, <span class="hljs-string">"b"</span>, <span class="hljs-string">"c"</span>)</span></span>; <span class="hljs-comment">// OK: T1,T2,T3 是字符串</span></code></pre></div><p>因为第三个模板参数类型有默认值，所以如果已经指定了第二个就可以省略第三个。</p><p>如果i想知道为什么不支持偏特化，下面是造成这个抉择的原因：</p><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-function">std::tuple&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">t</span><span class="hljs-params">(<span class="hljs-number">42</span>, <span class="hljs-number">43</span>)</span></span>; <span class="hljs-comment">// still ERROR</span></code></pre></div><p><code>std::tuple</code>是一个可变参数模板，所以你可以指定任意数量的参数。在这种情况下，到底是认为这是只指定了一个类型的而导致的错误还是有意为之很难说清。看起来是有问题的。后期有更多考量后，偏特化也有可能加入C++标准。尽管目前没有。</p><p>不幸的是，缺少部分特化就不能解决一个常见代码需求。对于关联容器的排序规则，或者无序容器的hash函数，我们仍然不能简单的传一个lambda：</p><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-function">std::set&lt;Cust&gt; <span class="hljs-title">coll</span><span class="hljs-params">([](<span class="hljs-type">const</span> Cust&amp; x, <span class="hljs-type">const</span> Cust&amp; y) { <span class="hljs-comment">// still ERROR</span></span></span><span class="hljs-params"><span class="hljs-function">    <span class="hljs-keyword">return</span> x.name() &gt; y.name();</span></span><span class="hljs-params"><span class="hljs-function">})</span></span>;</code></pre></div><p>我们还是得指定lambda的类型，因此需要像下面这样写：</p><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">auto</span> sortcrit = [](<span class="hljs-type">const</span> Cust&amp; x, <span class="hljs-type">const</span> Cust&amp; y) {    <span class="hljs-keyword">return</span> x.<span class="hljs-built_in">name</span>() &gt; y.<span class="hljs-built_in">name</span>();};<span class="hljs-function">std::set&lt;Cust, <span class="hljs-title">decltype</span><span class="hljs-params">(sortcrit)</span>&gt; <span class="hljs-title">coll</span><span class="hljs-params">(sortcrit)</span></span>; <span class="hljs-comment">// OK</span></code></pre></div><h5><span id="9-1-4-lei-mo-ban-can-shu-tui-dao-dai-ti-bian-jie-de-gong-ju-han-shu">9.1.4 类模板参数推导代替便捷的工具函数。</span><a href="#9-1-4-lei-mo-ban-can-shu-tui-dao-dai-ti-bian-jie-de-gong-ju-han-shu" class="header-anchor">#</a></h5><p>有了类模板参数推导，我们可以不再使用那些目的仅是推导传的参数的类型的便捷工具函数。</p><p>最明显的是<code>make_pair</code>，他允许我们不指定传的参数的类型。比如，对于v：</p><div class="code-wrapper"><pre><code class="hljs c++">std::vector&lt;<span class="hljs-type">int</span>&gt; v;</code></pre></div><p>我们可以使用:</p><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">auto</span> p = std::<span class="hljs-built_in">make_pair</span>(v.<span class="hljs-built_in">begin</span>(), v.<span class="hljs-built_in">end</span>());</code></pre></div><p>来代替</p><div class="code-wrapper"><pre><code class="hljs c++">std::pair&lt;<span class="hljs-keyword">typename</span> std::vector&lt;<span class="hljs-type">int</span>&gt;::iterator,<span class="hljs-keyword">typename</span> std::vector&lt;<span class="hljs-type">int</span>&gt;::iterator&gt; <span class="hljs-built_in">p</span>(v.<span class="hljs-built_in">begin</span>(), v.<span class="hljs-built_in">end</span>());</code></pre></div><p>现在，<code>make_pair()</code>不再需要了，可以直接这么写：</p><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-function">std::pair <span class="hljs-title">p</span><span class="hljs-params">(v.begin(), v.end())</span></span>;</code></pre></div><p>然而，std::make_pair() 也是一个很好的例子，它证明了有时便利函数不仅仅是推导模板参数。 事实上，std::make_pair()<br>也会衰减，这尤其意味着传递的字符串文字的类型被转换为 const<br> char *：</p><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">auto</span> q = std::<span class="hljs-built_in">make_pair</span>(<span class="hljs-string">"hi"</span>, <span class="hljs-string">"world"</span>); <span class="hljs-comment">// 一对指针</span></code></pre></div><p>在这种情况下，q 的类型为 std::pair&lt;const char*, const char*&gt;。<br>通过使用类模板参数推导，事情变得更加复杂。 让我们看看像 std::pair 这样的简单类声明的相关部分：</p><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T1, <span class="hljs-keyword">typename</span> T2&gt;<span class="hljs-keyword">struct</span> <span class="hljs-title class_">Pair1</span> {    T1 first;    T2 second;    <span class="hljs-built_in">Pair1</span>(<span class="hljs-type">const</span> T1&amp; x, <span class="hljs-type">const</span> T2&amp; y) : first{x}, second{y} {    }};</code></pre></div><p>关键是元素是通过引用传递的。 并且根据语言规则，当通过引用传递模板类型的参数时，参数类型不会衰减，这就是<br>将原始数组类型转换为相应的原始指针类型的机制。 因此，在调用时：</p><div class="code-wrapper"><pre><code class="hljs c++">Pair1 p1{<span class="hljs-string">"hi"</span>, <span class="hljs-string">"world"</span>}; <span class="hljs-comment">// 推导出一对不同大小的数组，但是......</span></code></pre></div><p>T1 推导出为 char[3]，T2 推导为 char[6]。 原则上，这样的推导是有效的。<br>但是，我们使用 T1 和 T2 来声明成员 first 和 second。 结果，他们是<br>声明为：</p><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-type">char</span> first[<span class="hljs-number">3</span>];<span class="hljs-type">char</span> second[<span class="hljs-number">6</span>];</code></pre></div><p>并且不允许从数组的左值初始化数组。 这就像尝试编译：</p><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-type">const</span> <span class="hljs-type">char</span> x[<span class="hljs-number">3</span>] = <span class="hljs-string">"hi"</span>;<span class="hljs-type">const</span> <span class="hljs-type">char</span> y[<span class="hljs-number">6</span>] = <span class="hljs-string">"world"</span>;<span class="hljs-type">char</span> first[<span class="hljs-number">3</span>] {x}; <span class="hljs-comment">// ERROR</span><span class="hljs-type">char</span> second[<span class="hljs-number">6</span>] {y}; <span class="hljs-comment">// ERROR</span></code></pre></div><p>请注意，在声明要按值传递的参数时，我们不会遇到这个问题：</p><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T1, <span class="hljs-keyword">typename</span> T2&gt;<span class="hljs-keyword">struct</span> <span class="hljs-title class_">Pair2</span> {    T1 first;    T2 second;    <span class="hljs-built_in">Pair2</span>(T1 x, T2 y) : first{x}, second{y} {    }};</code></pre></div><p> 如果对于这种类型，我们会调用：</p><div class="code-wrapper"><pre><code class="hljs c++">Pair2 p2{<span class="hljs-string">"hi"</span>, <span class="hljs-string">"world"</span>}; <span class="hljs-comment">// 推导出一对指针</span></code></pre></div><p>T1 和 T2 都将被推导出为 const char*。<br>因为声明了类 std::pair&lt;&gt; 以便构造函数通过引用获取参数，<br>您现在可能期望以下初始化不会编译：</p><div class="code-wrapper"><pre><code class="hljs c++">std::pair p{<span class="hljs-string">"hi"</span>, <span class="hljs-string">"world"</span>}; <span class="hljs-comment">// 似乎推断出一对不同大小的数组，但是......</span></code></pre></div><p>但它编译。 原因是我们使用推到。</p><h4><span id="9-2-tui-dao-zhi-nan">9.2 推导指南</span><a href="#9-2-tui-dao-zhi-nan" class="header-anchor">#</a></h4><p>您可以定义特定的推导指南以提供额外的类模板参数推导<br>或修复构造函数定义的现有扣除。 例如，您可以定义每当<br>推导出 Pair3 的类型，类型推导应该像类型被传递一样操作<br>价值：</p><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T1, <span class="hljs-keyword">typename</span> T2&gt;<span class="hljs-keyword">struct</span> <span class="hljs-title class_">Pair3</span> {    T1 first;    T2 second;    <span class="hljs-built_in">Pair3</span>(<span class="hljs-type">const</span> T1&amp; x, <span class="hljs-type">const</span> T2&amp; y) : first{x}, second{y} {    }};<span class="hljs-comment">// 构造函数的推导指南：</span><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T1, <span class="hljs-keyword">typename</span> T2&gt;</span><span class="hljs-function"><span class="hljs-title">Pair3</span><span class="hljs-params">(T1, T2)</span> -&gt; Pair3&lt;T1, T2&gt;</span>;</code></pre></div><p>在这里，在-&gt;的左边，我们声明我们要推导的东西。在这个例子中，它是由两个任意类型的对象T1和T2通过值创建一个<br>Pair3，由两个任意类型的T1和T2的对象通过值传递。在”-&gt;”的右边，我们<br>的右边定义了所产生的推理。在这个例子中，Pair3被实例化为两个类型的T1和T2。<br>你可能会说，这就是构造函数已经做的事情。然而，构造函数采用<br>参数的引用，这是不一样的。一般来说，即使在模板之外，参数<br>衰减，而通过引用传递的参数不会衰减。衰减意味着，原始<br>数组转换为指针，而顶级限定符，如const和引用，则被忽略。<br>如果没有推导指南，例如，在声明以下内容时：</p><div class="code-wrapper"><pre><code class="hljs c++">Pair3 p3{<span class="hljs-string">"hi"</span>, <span class="hljs-string">"world"</span>};</code></pre></div><p>参数 x 的类型，因此 T1 是 const char[3] 和参数 y 的类型，因此<br>T2 是 const char[6]。<br>由于推导，模板参数衰减，这意味着传递的数组或<br>字符串文字衰减为相应的指针类型。 现在，当声明以下内容时：</p><div class="code-wrapper"><pre><code class="hljs c++">Pair3 p3{<span class="hljs-string">"hi"</span>, <span class="hljs-string">"world"</span>};</code></pre></div><p>使用推导指南，它按值获取参数，以便两种类型都衰减为 const<br>char*。 声明的效果就好像我们已经声明了：</p><div class="code-wrapper"><pre><code class="hljs c++">Pair3&lt;<span class="hljs-type">const</span> <span class="hljs-type">char</span>*, <span class="hljs-type">const</span> <span class="hljs-type">char</span>*&gt; p3{<span class="hljs-string">"hi"</span>, <span class="hljs-string">"world"</span>};</code></pre></div><p>请注意，构造函数仍然通过引用获取参数。 推导指南只重要<br>用于推导模板类型。 这与类型之后的实际构造函数调用无关<br>推导出 T1 和 T2。</p><h5><span id="9-2-1-shi-yong-tui-dao-yin-dao-qiang-zhi-shuai-jian">9.2.1 使用推导引导强制衰减</span><a href="#9-2-1-shi-yong-tui-dao-yin-dao-qiang-zhi-shuai-jian" class="header-anchor">#</a></h5><p>正如前面的例子所展示的，一般来说，这些重载的一个非常有用的应用<br>规则是确保模板参数 T 在推导时衰减。考虑一个典型的类模板：</p><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;<span class="hljs-keyword">struct</span> <span class="hljs-title class_">C</span> {    <span class="hljs-built_in">C</span>(<span class="hljs-type">const</span> T&amp;) {    }    ...};</code></pre></div><p>如果我们在这里传递一个字符串字面量“hello”，则推导出 T 为字符串字面量的类型，即 const char[6]：</p><div class="code-wrapper"><pre><code class="hljs c++">C x{<span class="hljs-string">"hello"</span>}; <span class="hljs-comment">// T 推导出为 const char[6]</span></code></pre></div><p>原因是模板参数推导没有衰减到对应的指针类型，当参数通过引用传递时。<br>有一个简单的推导指南</p><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt; <span class="hljs-title">C</span><span class="hljs-params">(T)</span> -&gt; C&lt;T&gt;</span>;</code></pre></div><p>我们解决了这个问题：</p><div class="code-wrapper"><pre><code class="hljs c++">C x{<span class="hljs-string">"hello"</span>}; <span class="hljs-comment">// T 推导出为 const char*</span></code></pre></div><p>现在，因为推导指南按值接受它，它的类型衰减了，所以”hello”<br>推导出 T 为 const char* 类型。<br>因此，对于任何类模板，相应的推导指南听起来都非常合理<br>有一个构造函数通过引用获取其模板参数的对象。 C++ 标准<br>库提供了 pair 和 tuple 的相应推导指南。</p><h5><span id="9-2-2-fei-mo-ban-tui-dao">9.2.2 非模板推导</span><a href="#9-2-2-fei-mo-ban-tui-dao" class="header-anchor">#</a></h5><p>推导指南不必是模板，也不必适用于构造函数。 例如，<br>给定以下结构和推导指南：</p><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;<span class="hljs-keyword">struct</span> <span class="hljs-title class_">S</span> {    T val;};<span class="hljs-built_in">S</span>(<span class="hljs-type">const</span> <span class="hljs-type">char</span>*) -&gt; S&lt;std::string&gt;; <span class="hljs-comment">// 将字符串文字的 S&lt;&gt; 映射到 S&lt;std::string&gt;</span></code></pre></div><p>以下声明是可能的，其中 std::string 从 const 推导出为 T 的类型<br>char* 因为传递的字符串文字隐式转换为它：</p><div class="code-wrapper"><pre><code class="hljs c++">S s1{<span class="hljs-string">"hello"</span>}; <span class="hljs-comment">// OK, 等同于： S&lt;std::string&gt; s1{"hello"};</span>S s2 = {<span class="hljs-string">"hello"</span>}; <span class="hljs-comment">// OK, 等同于: S&lt;std::string&gt; s2 = {"hello"};</span>S s3 = S{<span class="hljs-string">"hello"</span>}; <span class="hljs-comment">// OK, 两个 S 都推断为 S&lt;std::string&gt;</span></code></pre></div><p>请注意，聚合需要列表初始化（推导有效，但不允许初始化）：</p><p>S s4 = “hello”;  // 错误（不能以这种方式初始化聚合）</p><h5><span id="9-2-3-tui-dao-yu-gou-zao-han-shu">9.2.3 推导与构造函数</span><a href="#9-2-3-tui-dao-yu-gou-zao-han-shu" class="header-anchor">#</a></h5><p>推导指南与类的构造函数竞争。类模板参数推导使用根据重载决议具有最高优先级的构造函数/指南。如果构造函数和推导指南同样匹配，则优选推导指南。</p><p>考虑我们有以下定义：</p><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;<span class="hljs-keyword">struct</span> <span class="hljs-title class_">C1</span> {    <span class="hljs-built_in">C1</span>(<span class="hljs-type">const</span> T&amp;) {    }};<span class="hljs-built_in">C1</span>(<span class="hljs-type">int</span>) -&gt; C1&lt;<span class="hljs-type">long</span>&gt;;</code></pre></div><p>当传递一个int时，使用推导指南，因为它被重载解析所青睐。<br>因此，T被推导为long：</p><div class="code-wrapper"><pre><code class="hljs c++">C1 x1{<span class="hljs-number">42</span>}; <span class="hljs-comment">// T 被推导为 long</span></code></pre></div><p>但是如果我们传递一个char，构造函数是更好的匹配（因为不需要类型转换），所以<br>我们将 T 推导出为 char：</p><div class="code-wrapper"><pre><code class="hljs c++">C1 x3{<span class="hljs-string">'x'</span>}; <span class="hljs-comment">// T 被推导为 char</span></code></pre></div><p>因为通过值匹配取参数与通过引用取参数和演绎指南同样适用于同样好的匹配，所以通常让演绎指南取<br>价值论据（这也有衰减的优势）。</p><h5><span id="9-2-4-xian-shi-tui-dao">9.2.4 显式推导</span><a href="#9-2-4-xian-shi-tui-dao" class="header-anchor">#</a></h5><p>一个推导指南可以被声明为是明确的。然后它只在以下情况下被忽略，即<br>显式会使初始化或转换失效。例如，鉴于:</p><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;<span class="hljs-keyword">struct</span> <span class="hljs-title class_">S</span> {    T val;};<span class="hljs-function"><span class="hljs-keyword">explicit</span> <span class="hljs-title">S</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span>*)</span> -&gt; S&lt;std::string&gt;</span>;</code></pre></div><p>传递推导指南参数类型的 S 对象的复制初始化（使用 =）忽略<br>扣除指南。 在这里，这意味着初始化变得无效：</p><div class="code-wrapper"><pre><code class="hljs c++">S s1 = {<span class="hljs-string">"hello"</span>}; <span class="hljs-comment">// ERROR (推导指南被忽略，否则无效)</span></code></pre></div><p>直接初始化或在右侧进行显式推导仍然是可能的：</p><div class="code-wrapper"><pre><code class="hljs c++">S s2{<span class="hljs-string">"hello"</span>}; <span class="hljs-comment">// OK, same as: S&lt;std::string&gt; s1{"hello"};</span>S s3 = S{<span class="hljs-string">"hello"</span>}; <span class="hljs-comment">// OK</span>S s4 = {S{<span class="hljs-string">"hello"</span>}}; <span class="hljs-comment">// OK</span></code></pre></div><p>作为另一个示例，我们可以执行以下操作：</p><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;<span class="hljs-keyword">struct</span> <span class="hljs-title class_">Ptr</span>{    <span class="hljs-built_in">Ptr</span>(T) { std::cout &lt;&lt; <span class="hljs-string">"Ptr(T)\n"</span>; }    <span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> U&gt;</span><span class="hljs-function">    <span class="hljs-title">Ptr</span><span class="hljs-params">(U)</span> </span>{ std::cout &lt;&lt; <span class="hljs-string">"Ptr(U)\n"</span>; }};<span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;</span><span class="hljs-function"><span class="hljs-keyword">explicit</span> <span class="hljs-title">Ptr</span><span class="hljs-params">(T)</span> -&gt; Ptr&lt;T*&gt;</span>;</code></pre></div><p>这将产生以下效果：</p><div class="code-wrapper"><pre><code class="hljs c++">Ptr p1{<span class="hljs-number">42</span>}; <span class="hljs-comment">// 由于推导引导推导 Ptr&lt;int*&gt;</span>Ptr p2 = <span class="hljs-number">42</span>; <span class="hljs-comment">// 由于构造函数推导出 Ptr&lt;int&gt;</span><span class="hljs-type">int</span> i = <span class="hljs-number">42</span>;Ptr p3{&amp;i}; <span class="hljs-comment">// 由于推导引导推导 Ptr&lt;int**&gt;</span>Ptr p4 = &amp;i; <span class="hljs-comment">// 由于构造函数推导出 Ptr&lt;int*&gt;</span></code></pre></div><h5><span id="9-2-5-ji-he-ti-tui-dao">9.2.5 集合体推导</span><a href="#9-2-5-ji-he-ti-tui-dao" class="header-anchor">#</a></h5><p>推导指南可用于通用聚合以启用类模板参数推导<br>那里。 例如，对于：</p><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;<span class="hljs-keyword">struct</span> <span class="hljs-title class_">A</span> {    T val;};</code></pre></div><p>任何没有推导指南的类模板参数推导试验都是错误的：</p><div class="code-wrapper"><pre><code class="hljs c++">A i1{<span class="hljs-number">42</span>}; <span class="hljs-comment">// ERROR</span><span class="hljs-function">A <span class="hljs-title">s1</span><span class="hljs-params">(<span class="hljs-string">"hi"</span>)</span></span>; <span class="hljs-comment">// ERROR</span>A s2{<span class="hljs-string">"hi"</span>}; <span class="hljs-comment">// ERROR</span>A s3 = <span class="hljs-string">"hi"</span>; <span class="hljs-comment">// ERROR</span>A s4 = {<span class="hljs-string">"hi"</span>}; <span class="hljs-comment">// ERROR</span></code></pre></div><p>您必须显式传递类型 T 的参数：</p><div class="code-wrapper"><pre><code class="hljs c++">A&lt;<span class="hljs-type">int</span>&gt; i2{<span class="hljs-number">42</span>};A&lt;std::string&gt; s5 = {<span class="hljs-string">"hi"</span>};</code></pre></div><p>但经过推导如：</p><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-built_in">A</span>(<span class="hljs-type">const</span> <span class="hljs-type">char</span>*) -&gt; A&lt;std::string&gt;;</code></pre></div><p>您可以按如下方式初始化聚合：</p><div class="code-wrapper"><pre><code class="hljs c++">A s2{<span class="hljs-string">"hi"</span>}; <span class="hljs-comment">// OK</span>A s4 = {<span class="hljs-string">"hi"</span>}; <span class="hljs-comment">// OK</span></code></pre></div><p>但是，与聚合一样，您仍然需要花括号。 否则，类型 T 成功<br>推导出来，但初始化是错误的：</p><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-function">A <span class="hljs-title">s1</span><span class="hljs-params">(<span class="hljs-string">"hi"</span>)</span></span>; <span class="hljs-comment">// 错误：T 是字符串，但没有聚合初始化</span>A s3 = <span class="hljs-string">"hi"</span>; <span class="hljs-comment">// 错误：T 是字符串，但没有聚合初始化</span></code></pre></div><p>std::array 的推导指南是聚合推导指南的另一个示例。</p><h5><span id="9-2-6-biao-zhun-tui-dao">9.2.6 标准推导</span><a href="#9-2-6-biao-zhun-tui-dao" class="header-anchor">#</a></h5><p>C++ 标准库在 C++17 中引入了一些推导指南。<br>Pairs 和 Tuples 推导指南<br>正如在推导指南的动机中所介绍的那样，std::pair 需要推导指南来确保<br>类模板参数推导使用传入参数的衰减类型：</p><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">namespace</span> std {    <span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T1, <span class="hljs-keyword">typename</span> T2&gt;    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">pair</span> {        ...    <span class="hljs-function"><span class="hljs-keyword">constexpr</span> <span class="hljs-title">pair</span><span class="hljs-params">(<span class="hljs-type">const</span> T1&amp; x, <span class="hljs-type">const</span> T2&amp; y)</span></span>; <span class="hljs-comment">// 引用参数</span>        ...    };    <span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T1, <span class="hljs-keyword">typename</span> T2&gt;</span><span class="hljs-function">    <span class="hljs-title">pair</span><span class="hljs-params">(T1, T2)</span> -&gt; pair&lt;T1, T2&gt;</span>; <span class="hljs-comment">// 按值推断参数类型</span>}</code></pre></div><p>因此，声明</p><div class="code-wrapper"><pre><code class="hljs C++">std::pair p{<span class="hljs-string">"hi"</span>, <span class="hljs-string">"world"</span>}; <span class="hljs-comment">// 采用 const char[3] 和 const char[6] 等价于:</span>std::pair&lt;<span class="hljs-type">const</span> <span class="hljs-type">char</span>*, <span class="hljs-type">const</span> <span class="hljs-type">char</span>*&gt; p{<span class="hljs-string">"hi"</span>, <span class="hljs-string">"world"</span>};</code></pre></div><p>对于可变参数类模板 std::tuple，使用相同的方法：</p><div class="code-wrapper"><pre><code class="hljs C++"><span class="hljs-keyword">namespace</span> std {    <span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span>... Types&gt;    <span class="hljs-keyword">class</span> <span class="hljs-title class_">tuple</span> {    <span class="hljs-keyword">public</span>:    <span class="hljs-function"><span class="hljs-keyword">constexpr</span> <span class="hljs-title">tuple</span><span class="hljs-params">(<span class="hljs-type">const</span> Types&amp;...)</span></span>; <span class="hljs-comment">// 通过引用获取参数</span>        <span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span>... UTypes&gt; <span class="hljs-keyword">constexpr</span> <span class="hljs-title">tuple</span><span class="hljs-params">(UTypes&amp;&amp;...)</span></span>;        ...    };    <span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span>... Types&gt;</span><span class="hljs-function">    <span class="hljs-title">tuple</span><span class="hljs-params">(Types...)</span> -&gt; tuple&lt;Types...&gt;</span>; <span class="hljs-comment">// 按值推断参数类型</span>};</code></pre></div><p>因此，声明：</p><div class="code-wrapper"><pre><code class="hljs c++">std::tuple t{<span class="hljs-number">42</span>, <span class="hljs-string">"hello"</span>, <span class="hljs-literal">nullptr</span>};</code></pre></div><p>将 t 的类型推导出为 std::tuple&lt;int, const char*, std::nullptr_t&gt;。</p><p>迭代器的推导：<br>为了能够从定义初始化范围的迭代器中推断出元素的类型，<br>容器对 std::vector&lt;&gt; 有如下推导指南：</p><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-comment">// let std::vector&lt;&gt; 从初始化迭代器推断元素类型:</span><span class="hljs-keyword">namespace</span> std {    <span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> Iterator&gt;</span><span class="hljs-function">    <span class="hljs-title">vector</span><span class="hljs-params">(Iterator, Iterator)</span></span><span class="hljs-function">    -&gt; vector&lt;<span class="hljs-keyword">typename</span> iterator_traits&lt;Iterator&gt;::value_type&gt;</span>;}</code></pre></div><p>例如，这允许：</p><div class="code-wrapper"><pre><code class="hljs c++">std::set&lt;<span class="hljs-type">float</span>&gt; s;<span class="hljs-function">std::vector <span class="hljs-title">v1</span><span class="hljs-params">(s.begin(), s.end())</span></span>; <span class="hljs-comment">// OK, 推导出 std::vector&lt;float&gt;</span></code></pre></div><p>请注意，此处使用带括号的初始化很重要。 如果使用花括号：</p><div class="code-wrapper"><pre><code class="hljs c++">std::vector v2{s.<span class="hljs-built_in">begin</span>(), s.<span class="hljs-built_in">end</span>()}; <span class="hljs-comment">// 注意：不推断 std::vector&lt;float&gt;</span></code></pre></div><p>这两个参数被视为初始化列表的元素（根据<br>重载决议规则）。 也就是说，相当于：</p><div class="code-wrapper"><pre><code class="hljs c++">std::vector&lt;std::set&lt;<span class="hljs-type">float</span>&gt;::iterator&gt; v2{s.<span class="hljs-built_in">begin</span>(), s.<span class="hljs-built_in">end</span>()};</code></pre></div><p>这样我们就初始化了一个包含两个元素的向量，第一个引用第一个元素，第二个引用表示最后一个元素后面的位置。<br>另一方面，考虑：</p><div class="code-wrapper"><pre><code class="hljs c++">std::vector v3{<span class="hljs-string">"hi"</span>, <span class="hljs-string">"world"</span>}; <span class="hljs-comment">// OK, 推导std::vector&lt;const char*&gt;</span><span class="hljs-function">std::vector <span class="hljs-title">v4</span><span class="hljs-params">(<span class="hljs-string">"hi"</span>, <span class="hljs-string">"world"</span>)</span></span>; <span class="hljs-comment">// OOPS：致命的运行时错误</span></code></pre></div><p>虽然 v3 的声明还使用两个元素（都是 C 字符串）初始化向量，但<br>第二个导致致命的运行时错误，这可能会导致核心转储。 问题是那个字符串<br>文字转换为字符指针，这是有效的迭代器。 因此，我们传递了两个迭代器<br>不指向同一个对象。 换句话说：我们传递了一个无效的范围。 取决于两者在哪里<br>文字被存储，你会得到一个带有任意数量元素的 std::vector<const char> 。 如果<br>它太大了你得到一个 bad_alloc 异常，或者你得到一个核心转储，因为没有距离<br>全部，或者你会得到一些存储在它们之间的未定义字符的范围。<br>因此，在初始化向量的元素时，使用花括号总是最好的。 唯一的<br>例外是传递单个向量时（首选复制构造函数）。 通过时<br>别的东西，使用括号更好。</const></p><h6><span id="std-array-lt-gt-tui-dao">std::array&lt;&gt; 推导</span><a href="#std-array-lt-gt-tui-dao" class="header-anchor">#</a></h6><p>一个更有趣的例子提供了 std::array&lt;&gt; 类：为了能够推导出这两个元素<br>类型和元素数量：</p><div class="code-wrapper"><pre><code class="hljs c++">std::array a{<span class="hljs-number">42</span>,<span class="hljs-number">45</span>,<span class="hljs-number">77</span>}; <span class="hljs-comment">// OK, 推导出 std::array&lt;int,3&gt;</span></code></pre></div><p>定义了以下推导指南：</p><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-comment">// let std::array&lt;&gt; 推断它们的元素数量（必须具有相同的类型）:</span><span class="hljs-keyword">namespace</span> std {    <span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T, <span class="hljs-keyword">typename</span>... U&gt;</span><span class="hljs-function">    <span class="hljs-title">array</span><span class="hljs-params">(T, U...)</span></span><span class="hljs-function">    -&gt; array&lt;<span class="hljs-type">enable_if_t</span>&lt;<span class="hljs-params">(is_same_v&lt;T,U&gt; &amp;&amp; ...)</span>, T&gt;,</span><span class="hljs-function">    <span class="hljs-params">(<span class="hljs-number">1</span> + <span class="hljs-keyword">sizeof</span>...(U))</span>&gt;</span>;}</code></pre></div><p>演绎指南使用折叠表达式</p><div class="code-wrapper"><pre><code class="hljs c++">(is_same_v&lt;T,U&gt; &amp;&amp; ...)</code></pre></div><p>确保所有传递的参数的类型相同。 因此，以下是不可能的：</p><div class="code-wrapper"><pre><code class="hljs c++">std::array a{<span class="hljs-number">42</span>,<span class="hljs-number">45</span>,<span class="hljs-number">77.7</span>}; <span class="hljs-comment">// ERROR: 类型不同</span></code></pre></div><h6><span id="wu-xu-map-tui-dao">(无序)Map推导</span><a href="#wu-xu-map-tui-dao" class="header-anchor">#</a></h6><p>可以证明获得行为正确的演绎指南所涉及的复杂性<br>通过试验为具有 key/value 对（map、multimap、<br>unordered_map，unordered_multimap）。<br>这些容器的元素具有 std::pair&lt;const keytype, valuetype&gt; 类型。 常量<br>是必要的，因为元素的位置取决于键的值，因此能够<br>修改密钥可能会在容器内产生不一致。<br>因此，C++17 标准中用于 std::map 的方法：</p><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">namespace</span> std {    <span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> Key, <span class="hljs-keyword">typename</span> T,    <span class="hljs-keyword">typename</span> Compare = less&lt;Key&gt;,    <span class="hljs-keyword">typename</span> Allocator = allocator&lt;pair&lt;<span class="hljs-type">const</span> Key, T&gt;&gt;&gt;        <span class="hljs-keyword">class</span> map {            ...        };}</code></pre></div><p>例如，为以下构造函数定义：</p><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-built_in">map</span>(initializer_list&lt;pair&lt;<span class="hljs-type">const</span> Key, T&gt;&gt;,    <span class="hljs-type">const</span> Compare&amp; = <span class="hljs-built_in">Compare</span>(),    <span class="hljs-type">const</span> Allocator&amp; = <span class="hljs-built_in">Allocator</span>());</code></pre></div><p>以下推导指南：</p><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">namespace</span> std {    <span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> Key, <span class="hljs-keyword">typename</span> T,    <span class="hljs-keyword">typename</span> Compare = less&lt;Key&gt;,    <span class="hljs-keyword">typename</span> Allocator = allocator&lt;pair&lt;<span class="hljs-type">const</span> Key, T&gt;&gt;&gt;        <span class="hljs-built_in">map</span>(initializer_list&lt;pair&lt;<span class="hljs-type">const</span> Key, T&gt;&gt;,            Compare = <span class="hljs-built_in">Compare</span>(),            Allocator = <span class="hljs-built_in">Allocator</span>())        -&gt; map&lt;Key, T, Compare, Allocator&gt;;}</code></pre></div><p>由于所有参数都是按值传递的，因此本推导指南允许传递的比较器或分配器的类型如所讨论的那样衰减。 然而，我们天真地使用了相同的参数类型，<br>意味着初始化列表采用 const 键类型。 但结果是，以下不起作用<br>正如 Ville Voutilainen 在 <a href="https://wg21.link/lwg3025">https://wg21.link/lwg3025</a> 中指出的那样：</p><div class="code-wrapper"><pre><code class="hljs c++">std::pair elem1{<span class="hljs-number">1</span>,<span class="hljs-number">2</span>};std::pair elem2{<span class="hljs-number">3</span>,<span class="hljs-number">4</span>};...std::map m1{elem1, elem2}; <span class="hljs-comment">// 与原始 C++17 指南有关的错误</span></code></pre></div><p>因为这里的元素被推导为 std::pair&lt;int,int&gt;，这与需要 const 类型作为第一对类型的推导指南不匹配。 因此，您仍然必须编写以下内容：</p><div class="code-wrapper"><pre><code class="hljs c++">std::map&lt;<span class="hljs-type">int</span>,<span class="hljs-type">int</span>&gt; m1{elem1, elem2}; <span class="hljs-comment">// OK, 因此，在推导指南中，应该删除 const：</span><span class="hljs-keyword">namespace</span> std {    <span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> Key, <span class="hljs-keyword">typename</span> T,    <span class="hljs-keyword">typename</span> Compare = less&lt;Key&gt;,    <span class="hljs-keyword">typename</span> Allocator = allocator&lt;pair&lt;<span class="hljs-type">const</span> Key, T&gt;&gt;&gt;        <span class="hljs-built_in">map</span>(initializer_list&lt;pair&lt;Key, T&gt;&gt;,            Compare = <span class="hljs-built_in">Compare</span>(),            Allocator = <span class="hljs-built_in">Allocator</span>())        -&gt; map&lt;Key, T, Compare, Allocator&gt;;}</code></pre></div><p>然而，为了仍然支持比较器和分配器的衰减，我们还必须重载<br>具有 const 键类型的对的推导指南。 否则将使用构造函数，以便<br>当与 const 和配对时，类模板参数推导的行为会略有不同<br>非常量键被传递。</p><h6><span id="zhi-neng-zhi-zhen-wu-tui-dao-zhi-nan">智能指针无推导指南</span><a href="#zhi-neng-zhi-zhen-wu-tui-dao-zhi-nan" class="header-anchor">#</a></h6><p>请注意，C++ 标准库中的某些地方没有推导指南，尽管您可能<br>期望它们可用。<br>例如，您可能希望有共享和唯一指针的推导指南，以便<br>代替：</p><div class="code-wrapper"><pre><code class="hljs c++">std::shared_ptr&lt;<span class="hljs-type">int</span>&gt; sp{<span class="hljs-keyword">new</span> <span class="hljs-built_in">int</span>(<span class="hljs-number">7</span>)};</code></pre></div><p>你可以写：</p><div class="code-wrapper"><pre><code class="hljs c++">std::shared_ptr sp{<span class="hljs-keyword">new</span> <span class="hljs-built_in">int</span>(<span class="hljs-number">7</span>)}; <span class="hljs-comment">// 不支持</span></code></pre></div><p>这不会自动工作，因为对应的构造函数是一个模板，所以没有<br>隐式推导指南适用：</p><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">namespace</span> std {    <span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;     <span class="hljs-keyword">class</span> <span class="hljs-title class_">shared_ptr</span> {        <span class="hljs-keyword">public</span>:        ...        <span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> Y&gt; <span class="hljs-keyword">explicit</span> <span class="hljs-title">shared_ptr</span><span class="hljs-params">(Y* p)</span></span>;        ...    };}</code></pre></div><p>Y 是与 T 不同的模板参数，因此从构造函数推导出 Y 并不意味着<br>我们可以推导出类型 T。这是一个能够调用类似以下内容的功能：</p><div class="code-wrapper"><pre><code class="hljs c++">std::shared_ptr&lt;Base&gt; sp{<span class="hljs-keyword">new</span> <span class="hljs-built_in">Derived</span>(...)};</code></pre></div><p>相应的推导指南将很容易提供：</p><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">namespace</span> std{    <span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> Y&gt; <span class="hljs-title">shared_ptr</span><span class="hljs-params">(Y*)</span> -&gt; shared_ptr&lt;Y&gt;</span>;}</code></pre></div><p>但是，这也意味着在分配数组时会采用本指南：</p><div class="code-wrapper"><pre><code class="hljs c++">std::shared_ptr sp{<span class="hljs-keyword">new</span> <span class="hljs-type">int</span>[<span class="hljs-number">10</span>]}; <span class="hljs-comment">// OOPS：会推导出 shared_ptr&lt;int&gt;</span></code></pre></div><p>在 C++ 中，我们经常遇到令人讨厌的 C 问题，即指向一个对象的指针的类型和<br>对象数组具有或衰减为相同类型。<br>因为这个问题看起来很危险，所以 C++ 标准委员会决定不支持<br>(还没完成）。 您仍然需要调用单个对象：</p><div class="code-wrapper"><pre><code class="hljs c++">std::shared_ptr&lt;<span class="hljs-type">int</span>&gt; sp1{<span class="hljs-keyword">new</span> <span class="hljs-type">int</span>}; <span class="hljs-comment">// OK</span><span class="hljs-keyword">auto</span> sp2 = std::<span class="hljs-built_in">make_shared</span>&lt;<span class="hljs-type">int</span>&gt;(); <span class="hljs-comment">// OK</span></code></pre></div><p>对于数组：</p><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-function">std::shared_ptr&lt;std::string&gt; <span class="hljs-title">p</span><span class="hljs-params">(<span class="hljs-keyword">new</span> std::string[<span class="hljs-number">10</span>],</span></span><span class="hljs-params"><span class="hljs-function">                               [](std::string* p) {</span></span><span class="hljs-params"><span class="hljs-function">                                   <span class="hljs-keyword">delete</span>[] p;</span></span><span class="hljs-params"><span class="hljs-function">                               })</span></span>;</code></pre></div><p>或者：</p><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-function">std::shared_ptr&lt;std::string&gt; <span class="hljs-title">p</span><span class="hljs-params">(<span class="hljs-keyword">new</span> std::string[<span class="hljs-number">10</span>],</span></span><span class="hljs-params"><span class="hljs-function">std::default_delete&lt;std::string[]&gt;())</span></span>;</code></pre></div><h4><span id="9-3-hou-ji">9.3 后记</span><a href="#9-3-hou-ji" class="header-anchor">#</a></h4><p>类模板参数推导由 Michael Spertus 于 2007 年在 https 中首次提出：<br>//wg21.link/n2332。 该提案于 2013 年由 Michael Spertus 和 David Vandevoorde 在 <a href="https://wg21.link/n3602">https://wg21.link/n3602</a> 中提出。 最终接受的措辞由迈克尔制定<br>Spertus、Faisal Vali 和 Richard Smith 在 <a href="https://wg21.link/p0091r3">https://wg21.link/p0091r3</a> 中进行了修改<br><a href="https://wg21.link/p0512r0">https://wg21.link/p0512r0</a> 中的 Michael Spertus、Faisal Vali 和 Richard Smith，<a href="https://wg21.link/p0620r0">https://wg21.link/p0620r0</a> 中的 Jason Merrill，以及 Michael Spertus 和 Jason Merrill（作为缺陷报告）<br>反对 C++17) 在 <a href="https://wg21.link/p702r1%E3%80%82">https://wg21.link/p702r1。</a><br>Michael 添加了对标准库中类模板参数推导的支持<br>Spertus、Walter E. Brown 和 Stephan T. Lavavej 在 <a href="https://wg21.link/p0433r2">https://wg21.link/p0433r2</a> 和（作为<br><a href="https://wg21.link/p0739r0">https://wg21.link/p0739r0</a> 中针对 C++17 的缺陷报告。 </p><h3><span id="10-bian-yi-shi-if">10 编译时<code>if</code></span><a href="#10-bian-yi-shi-if" class="header-anchor">#</a></h3><p>使用 if constexpr(. . . ) 语法，编译器使用编译时表达式在编译时决定是使用 if 语句的 then 部分还是 else 部分（如果有）。 另一部分（如果<br>any) 被丢弃，因此不会生成任何代码。 这并不意味着它是丢弃的部分.<br>不过，完全忽略了。 它将像未使用模板的代码一样进行检查。<br>例如：</p><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;<span class="hljs-function">std::string <span class="hljs-title">asString</span><span class="hljs-params">(T x)</span></span><span class="hljs-function"></span>{    <span class="hljs-function"><span class="hljs-keyword">if</span> <span class="hljs-title">constexpr</span><span class="hljs-params">(std::is_same_v&lt;T, std::string&gt;)</span> </span>{        <span class="hljs-keyword">return</span> x; <span class="hljs-comment">// 语句无效，如果没有转换为字符串</span>    }    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> <span class="hljs-built_in">constexpr</span>(std::is_arithmetic_v&lt;T&gt;) {        <span class="hljs-keyword">return</span> std::<span class="hljs-built_in">to_string</span>(x); <span class="hljs-comment">// 声明无效，如果 x 不是数字</span>    }    <span class="hljs-keyword">else</span> {        <span class="hljs-keyword">return</span> std::<span class="hljs-built_in">string</span>(x); <span class="hljs-comment">// 语句无效，如果没有转换为字符串</span>    }}</code></pre></div><p>在这里，我们使用这个特性在编译时决定是否只返回一个传递的字符串，调用<br>std::to_string() 获取传递的整数或浮点值，或尝试将传递的参数转换为 std::string。 因为无效调用被丢弃，下面的代码编译（其中<br>如果使用常规运行时，则不会出现这种情况）：</p><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">"ifcomptime.hpp"</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>{    std::cout &lt;&lt; <span class="hljs-built_in">asString</span>(<span class="hljs-number">42</span>) &lt;&lt; <span class="hljs-string">'\n'</span>;    std::cout &lt;&lt; <span class="hljs-built_in">asString</span>(std::<span class="hljs-built_in">string</span>(<span class="hljs-string">"hello"</span>)) &lt;&lt; <span class="hljs-string">'\n'</span>;    std::cout &lt;&lt; <span class="hljs-built_in">asString</span>(<span class="hljs-string">"hello"</span>) &lt;&lt; <span class="hljs-string">'\n'</span>;}</code></pre></div><h4><span id="10-1-bian-yi-shi-if-de-shi-ji">10.1 编译时<code>if</code>的时机</span><a href="#10-1-bian-yi-shi-if-de-shi-ji" class="header-anchor">#</a></h4><p>如果我们在刚刚介绍的示例中使用运行时 if：</p><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;<span class="hljs-function">std::string <span class="hljs-title">asString</span><span class="hljs-params">(T x)</span></span><span class="hljs-function"></span>{    <span class="hljs-keyword">if</span> (std::is_same_v&lt;T, std::string&gt;) {        <span class="hljs-keyword">return</span> x; <span class="hljs-comment">// ERROR, 如果没有转换为字符串</span>    }    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (std::is_numeric_v&lt;T&gt;) {        <span class="hljs-keyword">return</span> std::<span class="hljs-built_in">to_string</span>(x); <span class="hljs-comment">// ERROR, 如果 x 不是数字</span>    }    <span class="hljs-keyword">else</span> {        <span class="hljs-keyword">return</span> std::<span class="hljs-built_in">string</span>(x); <span class="hljs-comment">// ERROR, 如果没有转换为字符串</span>    }}</code></pre></div><p>相应的代码永远不会编译。 这是函数模板通常不编译或作为一个整体编译的规则的结果。 if 条件的检查是<br>运行时功能。 即使在编译时很明显条件必须为假，那么<br>部分必须能够编译。 因此，当传递 std::string 或字符串文字时，编译失败，<br>因为对传递的参数调用 std::to_string() 无效。 当通过一个<br>数值，编译失败，因为第三个和第三个返回语句无效。<br>现在且仅通过使用编译时 if，无法使用的 then 和 else 部分变成<br>丢弃的语句：</p><ul><li><p>当传递一个std::string 值时，第一个if 的else 部分被丢弃。</p></li><li><p>当传递一个数值时，第一个if 的then 部分和最后一个else 部分被丢弃。</p></li><li><p>当传递一个字符串文字（即类型 const char*）时，第一个和第二个 if 的 then 部分<br>被丢弃。</p></li></ul><p>因此，每个无效组合在编译时都不会再出现，代码编译成功。<br>请注意，丢弃的语句不会被忽略。 效果是它没有被实例化，当<br>取决于模板参数。 语法必须正确，不依赖模板参数的调用必须有效。 实际上，执行第一个翻译阶段（定义时间），<br>它检查正确的语法和所有不依赖于模板参数的名称的使用。<br>所有 static_asserts 也必须有效，即使在未编译的分支中也是如此。<br>例如：</p><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;</span><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">foo</span><span class="hljs-params">(T t)</span></span><span class="hljs-function"></span>{    <span class="hljs-function"><span class="hljs-keyword">if</span> <span class="hljs-title">constexpr</span><span class="hljs-params">(std::is_integral_v&lt;T&gt;)</span> </span>{        <span class="hljs-keyword">if</span> (t &gt; <span class="hljs-number">0</span>) {            <span class="hljs-built_in">foo</span>(t<span class="hljs-number">-1</span>); <span class="hljs-comment">// OK</span>        }    }    <span class="hljs-keyword">else</span> {        <span class="hljs-built_in">undeclared</span>(t); <span class="hljs-comment">// 如果未声明且未丢弃则错误（即 T 不是整数）</span>        <span class="hljs-built_in">undeclared</span>(); <span class="hljs-comment">// 如果未声明则错误（即使已丢弃）</span>        <span class="hljs-built_in">static_assert</span>(<span class="hljs-literal">false</span>, <span class="hljs-string">"no integral"</span>); <span class="hljs-comment">// 总是断言（即使被丢弃）</span>    }}</code></pre></div><p> 使用符合标准的编译器，此示例永远不会编译，原因有两个：</p><p>即使 T 是整数类型，调用</p><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-built_in">undeclared</span>(); <span class="hljs-comment">// 如果未声明则错误（即使已丢弃）</span></code></pre></div><p>如果没有声明这样的函数，则丢弃的 else 部分是一个错误，因为这个调用没有<br>依赖于模板参数</p><p>调用：</p><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-built_in">static_assert</span>(<span class="hljs-literal">false</span>, <span class="hljs-string">"no integral"</span>); <span class="hljs-comment">// 总是断言（即使被丢弃）</span></code></pre></div><p>即使它是被丢弃的 else 部分的一部分，它也总是会下降，因为这个调用再次不依赖于<br>模板参数。 重复编译时条件的静态断言会很好：</p><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-built_in">static_assert</span>(!std::is_integral_v&lt;T&gt;, <span class="hljs-string">"no integral"</span>);</code></pre></div><p>请注意，某些编译器（例如，Visual C++ 2013 和 2015）没有正确实现或执行模板的两阶段转换。 它们将第一阶段（定义时间）的大部分时间推迟到第二阶段（实例化时间），因此无效的函数调用甚至一些语法错误都可能编译。</p><h4><span id="10-2-shi-yong-bian-yi-shi-if">10.2 使用编译时<code>if</code></span><a href="#10-2-shi-yong-bian-yi-shi-if" class="header-anchor">#</a></h4><p>原则上，如果条件是<br>编译时表达式。 在以下情况下，您还可以混合编译时和运行时：</p><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">if</span> <span class="hljs-title">constexpr</span> <span class="hljs-params">(std::is_integral_v&lt;std::<span class="hljs-type">remove_reference_t</span>&lt;T&gt;&gt;)</span> </span>{    <span class="hljs-keyword">if</span> (val &gt; <span class="hljs-number">10</span>) {        <span class="hljs-function"><span class="hljs-keyword">if</span> <span class="hljs-title">constexpr</span> <span class="hljs-params">(std::numeric_limits&lt;<span class="hljs-type">char</span>&gt;::is_signed)</span> </span>{            ...        }        <span class="hljs-keyword">else</span> {            ...        }    }    <span class="hljs-keyword">else</span> {        ...    }}<span class="hljs-keyword">else</span> {    ...}</code></pre></div><p>请注意，您不能在函数体之外使用 if constexpr。 因此，你不能用它来代替<br>条件预处理器指令。</p><h5><span id="10-2-1-bian-yi-shi-if-de-zhu-yi-shi-xiang">10.2.1 编译时<code>if</code>的注意事项</span><a href="#10-2-1-bian-yi-shi-if-de-zhu-yi-shi-xiang" class="header-anchor">#</a></h5><p>即使有可能使用 <code>compile-time if</code> ，如果可能有一些后果不是<br>很明显，这将在以下小节中讨论。</p><h6><span id="compile-time-if-ying-xiang-fan-hui-lei-xing"><code>compile-time if</code> 影响返回类型</span><a href="#compile-time-if-ying-xiang-fan-hui-lei-xing" class="header-anchor">#</a></h6><p><code>compile-time if</code>可能影响函数的返回类型。例如，下面的代码总是可以编译，但返回类型可能不同:</p><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">auto</span> <span class="hljs-title">foo</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>{    <span class="hljs-function"><span class="hljs-keyword">if</span> <span class="hljs-title">constexpr</span> <span class="hljs-params">(<span class="hljs-keyword">sizeof</span>(<span class="hljs-type">int</span>) &gt; <span class="hljs-number">4</span>)</span> </span>{        <span class="hljs-keyword">return</span> <span class="hljs-number">42</span>;    }    <span class="hljs-keyword">else</span> {        <span class="hljs-keyword">return</span> <span class="hljs-number">42u</span>;    }}</code></pre></div><p>在这里，由于我们使用了auto，函数的返回类型取决于返回语句，而返回语句则<br>取决于int的大小。</p><ul><li>如果大小大于4，只有一个有效的返回语句返回42，所以返回<br>类型是int。</li><li>否则，只有一个返回语句返回42u，所以返回类型变成了<br>unsigned int.。</li></ul><p>这样一来，带有if constexpr的函数的返回类型可能会有更大的差别例如，如果我们跳过else部分，返回类型可能是int或void。</p><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">auto</span> <span class="hljs-title">foo</span><span class="hljs-params">()</span> <span class="hljs-comment">// 返回类型可能是int或void</span></span><span class="hljs-function"></span>{    <span class="hljs-function"><span class="hljs-keyword">if</span> <span class="hljs-title">constexpr</span> <span class="hljs-params">(<span class="hljs-keyword">sizeof</span>(<span class="hljs-type">int</span>) &gt; <span class="hljs-number">4</span>)</span> </span>{         <span class="hljs-keyword">return</span> <span class="hljs-number">42</span>;    }}</code></pre></div><p>请注意，如果这里使用了<code>compile-time if</code>，这段代码永远不会被编译，因为那样的话，两个返回语句都会被考虑在内，这样一来，对返回类型的推断就会变得模糊不清了。</p><h6><span id="else-matters-even-if-then-returns">else Matters Even if then Returns</span><a href="#else-matters-even-if-then-returns" class="header-anchor">#</a></h6><p>对于<code>compile-time if</code>语句，有一种模式不适用于<code>compile-time if</code>语句。如果<br>代码的then和else部分都有返回语句，你可以跳过<code>compile-time if</code>语句中的else语句。也就是说，不要用:</p><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">if</span> (...) {    <span class="hljs-keyword">return</span> a;}<span class="hljs-keyword">else</span> {    <span class="hljs-keyword">return</span> b;}</code></pre></div><p>你总是可以写:</p><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">if</span> (...) {    <span class="hljs-keyword">return</span> a;}<span class="hljs-keyword">return</span> b;</code></pre></div><p>如果条件为真（int的大小大于4），编译器会推断出两种不同的返回类型，这是不成立的。否则，我们只有一个重要的返回语句，这样代码就可以编译了。</p><h6><span id="duan-hui-lu-compile-time-tiao-jian">短回路<code>compile-time</code>条件</span><a href="#duan-hui-lu-compile-time-tiao-jian" class="header-anchor">#</a></h6><p>考虑以下代码：</p><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;</span><span class="hljs-function"><span class="hljs-keyword">constexpr</span> <span class="hljs-keyword">auto</span> <span class="hljs-title">foo</span><span class="hljs-params">(<span class="hljs-type">const</span> T&amp; val)</span></span><span class="hljs-function"></span>{    <span class="hljs-function"><span class="hljs-keyword">if</span> <span class="hljs-title">constexpr</span> <span class="hljs-params">(std::is_integral&lt;T&gt;::value)</span> </span>{         <span class="hljs-function"><span class="hljs-keyword">if</span> <span class="hljs-title">constexpr</span> <span class="hljs-params">(T{} &lt; <span class="hljs-number">10</span>)</span> </span>{            <span class="hljs-keyword">return</span> val * <span class="hljs-number">2</span>;        }    }    <span class="hljs-keyword">return</span> val;}</code></pre></div><p>这里我们有两个compile-time条件来决定是按原样返回传递的值还是加倍。</p><p>这为两者编译：</p><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">constexpr</span> <span class="hljs-keyword">auto</span> x1 = <span class="hljs-built_in">foo</span>(<span class="hljs-number">42</span>); <span class="hljs-comment">// yields 84</span><span class="hljs-keyword">constexpr</span> <span class="hljs-keyword">auto</span> x2 = <span class="hljs-built_in">foo</span>(<span class="hljs-string">"hi"</span>); <span class="hljs-comment">// OK, yields ”hi”</span></code></pre></div><p>运行时ifs中的条件是短路的（评估带有&amp;&amp;的条件只到第一个<code>false</code>，评估带有||的条件只到第一个<code>true</code>）。这可能会导致人们期望<code>compile-time if</code>也是这种情况:</p><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;</span><span class="hljs-function"><span class="hljs-keyword">constexpr</span> <span class="hljs-keyword">auto</span> <span class="hljs-title">bar</span><span class="hljs-params">(<span class="hljs-type">const</span> T&amp; val)</span></span><span class="hljs-function"></span>{    <span class="hljs-function"><span class="hljs-keyword">if</span> <span class="hljs-title">constexpr</span> <span class="hljs-params">(std::is_integral&lt;T&gt;::value &amp;&amp; T{} &lt; <span class="hljs-number">10</span>)</span> </span>{         <span class="hljs-keyword">return</span> val * <span class="hljs-number">2</span>;                                     }    <span class="hljs-keyword">return</span> val;}</code></pre></div><p>然而，<code>compile-time if</code>的条件总是被实例化的，并且需要整体有效，因此，传递一个不支持&lt;10的类型不再能编译:</p><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">constexpr</span> <span class="hljs-keyword">auto</span> x2 = <span class="hljs-built_in">bar</span>(<span class="hljs-string">"hi"</span>); <span class="hljs-comment">// compile-time ERROR</span></code></pre></div><p>因此，<code>compile-time if</code>不会使实例化short-circuit。 如果编译时条件的有效性依赖于较早的编译时条件，则必须像在 foo() 中那样嵌套它们。 作为另一个例子，你必须写：</p><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">if</span> <span class="hljs-title">constexpr</span> <span class="hljs-params">(std::is_same_v&lt;MyType, T&gt;)</span> </span>{     <span class="hljs-function"><span class="hljs-keyword">if</span> <span class="hljs-title">constexpr</span> <span class="hljs-params">(T::i == <span class="hljs-number">42</span>)</span> </span>{        ...    }}</code></pre></div><p>而不仅仅是：</p><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">if</span> <span class="hljs-title">constexpr</span> <span class="hljs-params">(std::is_same_v&lt;MyType, T&gt; &amp;&amp; T::i == <span class="hljs-number">42</span>)</span> </span>{    ...}</code></pre></div><h5><span id="10-2-2-qi-ta-bian-yi-shi-if-de-li-zi">10.2.2 其他编译时<code>if</code>的例子</span><a href="#10-2-2-qi-ta-bian-yi-shi-if-de-li-zi" class="header-anchor">#</a></h5><p>编译时的一种应用是返回值的完美转发，当它们必须得到处理才能返回时。 因为 void 不能推导出 decltype(auto) （因为 void 是一个不完整的类型），所以你必须编写如下内容：</p><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;functional&gt;</span> <span class="hljs-comment">// for std::forward()</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;type_traits&gt;</span> <span class="hljs-comment">// for std::is_same&lt;&gt; and std::invoke_result&lt;&gt;</span></span><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> Callable, <span class="hljs-keyword">typename</span>... Args&gt;</span><span class="hljs-function"><span class="hljs-keyword">decltype</span>(<span class="hljs-keyword">auto</span>) <span class="hljs-title">call</span><span class="hljs-params">(Callable op, Args&amp;&amp;... args)</span></span><span class="hljs-function"></span>{    <span class="hljs-function"><span class="hljs-keyword">if</span> <span class="hljs-title">constexpr</span><span class="hljs-params">(std::is_void_v&lt;std::<span class="hljs-type">invoke_result_t</span>&lt;Callable, Args...&gt;&gt;)</span> </span>{        <span class="hljs-comment">// return type is void:</span>        <span class="hljs-built_in">op</span>(std::forward&lt;Args&gt;(args)...);        ... <span class="hljs-comment">// do something before we return</span>        <span class="hljs-keyword">return</span>;    }    <span class="hljs-keyword">else</span> {        <span class="hljs-comment">// return type is not void:</span>        <span class="hljs-keyword">decltype</span>(<span class="hljs-keyword">auto</span>) ret{<span class="hljs-built_in">op</span>(std::forward&lt;Args&gt;(args)...)};        ... <span class="hljs-comment">// do something (with ret) before we return</span>        <span class="hljs-keyword">return</span> ret;    }}</code></pre></div><h6><span id="compile-time-if-yong-yu-biao-qian-diao-du">Compile-Time if用于标签调度</span><a href="#compile-time-if-yong-yu-biao-qian-diao-du" class="header-anchor">#</a></h6><p>编译时 if 的一个典型应用是标签调度。 在 C+17 之前，您必须提供<br>为您要处理的每种类型设置一个单独的函数的重载。 现在，在编译时<br>如果，您可以将所有逻辑放在一个函数中。<br>例如，不要重载 std::advance() 算法：</p><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> Iterator, <span class="hljs-keyword">typename</span> Distance&gt;</span><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">advance</span><span class="hljs-params">(Iterator&amp; pos, Distance n)</span> </span>{    <span class="hljs-keyword">using</span> cat = std::iterator_traits&lt;Iterator&gt;::iterator_category;    <span class="hljs-built_in">advanceImpl</span>(pos, n, cat); <span class="hljs-comment">// 迭代器类别上的标签调度</span>}<span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> Iterator, <span class="hljs-keyword">typename</span> Distance&gt;</span><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">advanceImpl</span><span class="hljs-params">(Iterator&amp; pos, Distance n, std::random_access_iterator_tag)</span> </span>{    pos += n;}<span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> Iterator, <span class="hljs-keyword">typename</span> Distance&gt;</span><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">advanceImpl</span><span class="hljs-params">(Iterator&amp; pos, Distance n, std::bidirectional_iterator_tag)</span> </span>{    <span class="hljs-keyword">if</span> (n &gt;= <span class="hljs-number">0</span>) {        <span class="hljs-keyword">while</span> (n--) {            ++pos;        }    }    <span class="hljs-keyword">else</span> {        <span class="hljs-keyword">while</span> (n++) {            --pos;        }    }}<span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> Iterator, <span class="hljs-keyword">typename</span> Distance&gt;</span><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">advanceImpl</span><span class="hljs-params">(Iterator&amp; pos, Distance n, std::input_iterator_tag)</span> </span>{    <span class="hljs-keyword">while</span> (n--) {        ++pos;    }}</code></pre></div><p>我们现在可以在一个函数中实现所有行为：</p><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> Iterator, <span class="hljs-keyword">typename</span> Distance&gt;</span><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">advance</span><span class="hljs-params">(Iterator&amp; pos, Distance n)</span> </span>{    <span class="hljs-keyword">using</span> cat = std::iterator_traits&lt;Iterator&gt;::iterator_category;    <span class="hljs-function"><span class="hljs-keyword">if</span> <span class="hljs-title">constexpr</span> <span class="hljs-params">(std::is_same_v&lt;cat, std::random_access_iterator_tag&gt;)</span> </span>{        pos += n;    }    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> <span class="hljs-built_in">constexpr</span> (std::is_same_v&lt;cat,                       std::bidirectional_access_iterator_tag&gt;) {        <span class="hljs-keyword">if</span> (n &gt;= <span class="hljs-number">0</span>) {            <span class="hljs-keyword">while</span> (n--) {                ++pos;            }        }        <span class="hljs-keyword">else</span> {            <span class="hljs-keyword">while</span> (n++) {                --pos;            }        }    }    <span class="hljs-keyword">else</span> { <span class="hljs-comment">// input_iterator_tag</span>        <span class="hljs-keyword">while</span> (n--) {            ++pos;        }    }}</code></pre></div><p>所以，在某种程度上，我们现在有一个compile-time切换，不同的情况必须在这里得到 但是，由 if constexpr 子句制定。 但是，请注意一个可能很重要的区别：</p><ul><li><p>重载函数集为您提供最佳匹配语义。</p></li><li><p>编译时if 的实现为您提供了第一个匹配语义。</p></li></ul><p>标签调度的另一个例子是使用编译时 if for get&lt;&gt;() 重载来实现结构绑定接口。 </p><p>第三个例子是通用 lambda 中不同类型的处理，如 <code>std::variant&lt;&gt; visitors</code>。</p><h4><span id="10-3-dai-you-chu-shi-hua-de-bian-yi-shi-if">10.3 带有初始化的编译时<code>if</code></span><a href="#10-3-dai-you-chu-shi-hua-de-bian-yi-shi-if" class="header-anchor">#</a></h4><p>请注意，compile-time if 也可以使用新形式的 if with 初始化。 例如，如果<br>有一个 constexpr 函数 foo()，你可以使用：</p><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;</span><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">bar</span><span class="hljs-params">(<span class="hljs-type">const</span> T x)</span></span><span class="hljs-function"></span>{    <span class="hljs-function"><span class="hljs-keyword">if</span> <span class="hljs-title">constexpr</span> <span class="hljs-params">(<span class="hljs-keyword">auto</span> obj = foo(x); std::is_same_v&lt;<span class="hljs-keyword">decltype</span>(obj), T&gt;)</span> </span>{        std::cout &lt;&lt; <span class="hljs-string">"foo(x) yields same type\n"</span>;        ...    }    <span class="hljs-keyword">else</span> {        std::cout &lt;&lt; <span class="hljs-string">"foo(x) yields different type\n"</span>;        ...    }}</code></pre></div><p>如果传递的类型有 constexpr 函数 foo()，您可以使用此代码提供不同的<br>关于 foo(x) 是否产生与 x 相同类型的行为。<br>要确定 foo(x) 返回的值，您可以编写：</p><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">constexpr</span> <span class="hljs-keyword">auto</span> c = ...;<span class="hljs-function"><span class="hljs-keyword">if</span> <span class="hljs-title">constexpr</span> <span class="hljs-params">(<span class="hljs-keyword">constexpr</span> <span class="hljs-keyword">auto</span> obj = foo(c); obj == <span class="hljs-number">0</span>)</span> </span>{    std::cout &lt;&lt; <span class="hljs-string">"foo() == 0\n"</span>;    ...}</code></pre></div><p>请注意，必须将 obj 声明为 constexpr 才能在条件中使用其值。</p><h4><span id="10-4-zai-mo-ban-zhi-wai-shi-yong-bian-yi-shi-if">10.4 在模板之外使用编译时<code>if</code></span><a href="#10-4-zai-mo-ban-zhi-wai-shi-yong-bian-yi-shi-if" class="header-anchor">#</a></h4><p>if constexpr 可以在任何函数中使用，而不仅仅是在模板中。 我们只需要一个编译时表达式，它会产生可转换为 bool 的东西。 但是，在那种情况下，在 then 和 the<br>else 部分即使被丢弃，所有语句也必须始终有效。</p><p>例如，下面的代码总是会编译失败，因为 undeclared() 的调用必须是有效的，即使 chars 被签名并且 else 部分被丢弃：</p><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;limits&gt;</span></span><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;</span><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">foo</span><span class="hljs-params">(T t)</span></span>;<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>{    <span class="hljs-function"><span class="hljs-keyword">if</span> <span class="hljs-title">constexpr</span><span class="hljs-params">(std::numeric_limits&lt;<span class="hljs-type">char</span>&gt;::is_signed)</span> </span>{        <span class="hljs-built_in">foo</span>(<span class="hljs-number">42</span>); <span class="hljs-comment">// OK</span>    }    <span class="hljs-keyword">else</span> {        <span class="hljs-built_in">undeclared</span>(<span class="hljs-number">42</span>); <span class="hljs-comment">// 如果没有声明总是错误（即使被丢弃）</span>    }}</code></pre></div><p>此外，以下代码永远无法成功编译，因为其中一个静态断言将始终失败：</p><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">if</span> <span class="hljs-title">constexpr</span><span class="hljs-params">(std::numeric_limits&lt;<span class="hljs-type">char</span>&gt;::is_signed)</span> </span>{    <span class="hljs-built_in">static_assert</span>(std::numeric_limits&lt;<span class="hljs-type">char</span>&gt;::is_signed);}<span class="hljs-keyword">else</span> {    <span class="hljs-built_in">static_assert</span>(!std::numeric_limits&lt;<span class="hljs-type">char</span>&gt;::is_signed);}</code></pre></div><p>如果在泛型代码之外，编译时的（唯一）好处是被丢弃语句中的代码，尽管它必须是有效的，但不会成为结果程序的一部分，这减少了生成的可执行文件。 例如，在这个程序中：</p><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;limits&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;array&gt;</span></span><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>{    <span class="hljs-keyword">if</span> (!std::numeric_limits&lt;<span class="hljs-type">char</span>&gt;::is_signed) {        <span class="hljs-type">static</span> std::array&lt;std::string,1000&gt; arr1;        ...    }    <span class="hljs-keyword">else</span> {        <span class="hljs-type">static</span> std::array&lt;std::string,<span class="hljs-number">1000</span>&gt; arr2;        ...    }}</code></pre></div><p>arr1或arr2是最终可执行文件的一部分，但不是两者都是。</p><h4><span id="10-5-hou-ji">10.5 后记</span><a href="#10-5-hou-ji" class="header-anchor">#</a></h4><p>Compile-time if最初是由Walter Bright, Herb Sutter, 和Andrei Alexandrescu在 <a href="https://wg21.link/n3329%EF%BC%8C%E4%BB%A5%E5%8F%8AVille">https://wg21.link/n3329，以及Ville</a> Voutilainen在<a href="https://wg21.link/n4461%EF%BC%8C%E6%8F%90%E5%87%BA%E4%BA%86%E9%9D%99%E6%80%81%E7%9A%84if%E8%AF%AD%E8%A8%80%E7%89%B9%E6%80%A7%E3%80%82">https://wg21.link/n4461，提出了静态的if语言特性。</a><br>一个静态的if语言特性。在<a href="https://wg21.link/p0128r0%EF%BC%8CVille">https://wg21.link/p0128r0，Ville</a> Voutilainen提出了这个 该特性首次被称为constexpr_if（该特性的名称由此而来）。最终被接受的 措辞是由Jens Maurer <a href="https://wg21.link/p0292r2%E3%80%82">https://wg21.link/p0292r2。</a></p><h3><span id="11-zhe-die-biao-da-shi">11 折叠表达式</span><a href="#11-zhe-die-biao-da-shi" class="header-anchor">#</a></h3><p>从C++17开始，有一个功能是计算在一个参数包的所有参数上使用二元运算符的结果（有一个可选的初始值）。<br>例如，下面的函数返回所有传递参数的总和:</p><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span>... T&gt;</span><span class="hljs-function"><span class="hljs-keyword">auto</span> <span class="hljs-title">foldSum</span> <span class="hljs-params">(T... args)</span> </span>{    <span class="hljs-keyword">return</span> (... + args); <span class="hljs-comment">// ((arg1 + arg2) + arg3) ...</span>}</code></pre></div><p>注意，返回表达式周围的括号是折叠表达式的一部分，不能省略。</p><p>调用函数时要注意</p><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-built_in">foldSum</span>(<span class="hljs-number">47</span>, <span class="hljs-number">11</span>, val, <span class="hljs-number">-1</span>);</code></pre></div><p>实例化要执行的模板：</p><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">return</span> <span class="hljs-number">47</span> + <span class="hljs-number">11</span> + val + <span class="hljs-number">-1</span>;</code></pre></div><p>调用它:</p><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-built_in">foldSum</span>(std::<span class="hljs-built_in">string</span>(<span class="hljs-string">"hello"</span>), <span class="hljs-string">"world"</span>, <span class="hljs-string">"!"</span>);</code></pre></div><p>实例化模板：</p><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">return</span> std::<span class="hljs-built_in">string</span>(<span class="hljs-string">"hello"</span>) + <span class="hljs-string">"world"</span> + <span class="hljs-string">"!"</span>;</code></pre></div><p>另请注意，折叠表达式参数的顺序可能不同且很重要（并且可能看起来有点违反直觉）：如所写，</p><div class="code-wrapper"><pre><code class="hljs c++">(... + args)</code></pre></div><p>结果是</p><div class="code-wrapper"><pre><code class="hljs c++">((arg1 + arg2) + arg3) ...</code></pre></div><p>这意味着它会反复“添加”东西。 你也可以写</p><div class="code-wrapper"><pre><code class="hljs c++">(args + ...)</code></pre></div><p>它反复“预添加”事物，因此结果表达式为：</p><div class="code-wrapper"><pre><code class="hljs c++">(arg1 + (arg2 + arg3)) ...</code></pre></div><h4><span id="11-1-zhe-die-biao-da-shi-de-dong-yin">11.1 折叠表达式的动因</span><a href="#11-1-zhe-die-biao-da-shi-de-dong-yin" class="header-anchor">#</a></h4><p>折叠表达式避免了递归实例化模板以对参数包的所有参数执行操作的需要。 在 C++17 之前，您必须实现：</p><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;</span><span class="hljs-function"><span class="hljs-keyword">auto</span> <span class="hljs-title">foldSumRec</span> <span class="hljs-params">(T arg)</span> </span>{    <span class="hljs-keyword">return</span> arg;}<span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T1, <span class="hljs-keyword">typename</span>... Ts&gt;</span><span class="hljs-function"><span class="hljs-keyword">auto</span> <span class="hljs-title">foldSumRec</span> <span class="hljs-params">(T1 arg1, Ts... otherArgs)</span> </span>{    <span class="hljs-keyword">return</span> arg1 + <span class="hljs-built_in">foldSumRec</span>(otherArgs...);}</code></pre></div><p>这样的实现不仅写起来麻烦，而且对 C++ 编译器也有压力。 和</p><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span>... T&gt;</span><span class="hljs-function"><span class="hljs-keyword">auto</span> <span class="hljs-title">foldSum</span> <span class="hljs-params">(T... args)</span> </span>{    <span class="hljs-keyword">return</span> (... + args); <span class="hljs-comment">// arg1 + arg2 + arg3 ...</span>}</code></pre></div><p>程序员和编译器的工作量都大大减少了。</p><h4><span id="11-2-shi-yong-zhe-die-biao-da-shi">11.2 使用折叠表达式</span><a href="#11-2-shi-yong-zhe-die-biao-da-shi" class="header-anchor">#</a></h4><p>给定参数 args 和运算符 op，C++17 允许我们编写</p><ul><li><p>要么是一元左折叠</p><div class="code-wrapper"><pre><code class="hljs c++">( ... op args )</code></pre></div><p>扩展为： ((arg1 op arg2) op arg3) op . . .</p></li><li><p>或一元右折叠</p><div class="code-wrapper"><pre><code class="hljs c++">( args op ... )</code></pre></div><p>扩展为：arg1 op (arg2 op . . . (argN-1 op argN))</p></li></ul><p>括号是必需的。 但是，括号和省略号 (…) 不必用空格分隔。<br>左右折叠之间的差异比预期的更重要。 例如，即使使用 operator + 也可能会有不同的效果。 使用左折叠表达式时：</p><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span>... T&gt;</span><span class="hljs-function"><span class="hljs-keyword">auto</span> <span class="hljs-title">foldSumL</span><span class="hljs-params">(T... args)</span></span>{    <span class="hljs-keyword">return</span> (... + args); <span class="hljs-comment">// ((arg1 + arg2) + arg3) ...</span>}</code></pre></div><p>调用</p><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-built_in">foldSumL</span>(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>)</code></pre></div><p>计算结果为：</p><div class="code-wrapper"><pre><code class="hljs bash">(1 + 2) + 3)</code></pre></div><p>这也意味着以下示例可以编译：</p><div class="code-wrapper"><pre><code class="hljs c++">std::cout &lt;&lt; <span class="hljs-built_in">foldSumL</span>(std::<span class="hljs-built_in">string</span>(<span class="hljs-string">"hello"</span>), <span class="hljs-string">"world"</span>, <span class="hljs-string">"!"</span>) &lt;&lt; <span class="hljs-string">'\n'</span>; <span class="hljs-comment">// OK</span></code></pre></div><p>请记住，运算符 + 是为标准字符串定义的，前提是至少有一个操作数是 std::string。<br>因为使用了左折叠，所以调用首先计算:</p><div class="code-wrapper"><pre><code class="hljs c++">std::<span class="hljs-built_in">string</span>(<span class="hljs-string">"hello"</span>) + <span class="hljs-string">"world"</span></code></pre></div><p>它返回一个 std::string，以便添加字符串文字”!” 那么也是有效的。</p><p>但是，诸如:</p><div class="code-wrapper"><pre><code class="hljs c++">std::cout &lt;&lt; <span class="hljs-built_in">foldSumL</span>(<span class="hljs-string">"hello"</span>, <span class="hljs-string">"world"</span>, std::<span class="hljs-built_in">string</span>(<span class="hljs-string">"!"</span>)) &lt;&lt; <span class="hljs-string">'\n'</span>; <span class="hljs-comment">// ERROR</span></code></pre></div><p>不会编译，因为它的计算结果为:</p><div class="code-wrapper"><pre><code class="hljs bash">(<span class="hljs-string">"hello"</span> + <span class="hljs-string">"world"</span>) + std::string(<span class="hljs-string">"!"</span>)</code></pre></div><p>并且不允许添加两个字符串文字。</p><p>但是，如果我们将实现更改为：</p><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span>... T&gt;</span><span class="hljs-function"><span class="hljs-keyword">auto</span> <span class="hljs-title">foldSumR</span><span class="hljs-params">(T... args)</span></span>{    <span class="hljs-keyword">return</span> (args + ...); <span class="hljs-comment">// (arg1 + (arg2 + arg3)) ...</span>}</code></pre></div><p>调用：</p><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-built_in">foldSumR</span>(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>)</code></pre></div><p>计算结果为：</p><div class="code-wrapper"><pre><code class="hljs bash">(1 + (2 + 3)</code></pre></div><p>这意味着以下示例不再编译：</p><div class="code-wrapper"><pre><code class="hljs c++">std::cout &lt;&lt; <span class="hljs-built_in">foldSumR</span>(std::<span class="hljs-built_in">string</span>(<span class="hljs-string">"hello"</span>), <span class="hljs-string">"world"</span>, <span class="hljs-string">"!"</span>) &lt;&lt; <span class="hljs-string">'\n'</span>; <span class="hljs-comment">// ERROR</span></code></pre></div><p>而下面的调用现在编译：</p><div class="code-wrapper"><pre><code class="hljs c++">std::cout &lt;&lt; <span class="hljs-built_in">foldSumR</span>(<span class="hljs-string">"hello"</span>, <span class="hljs-string">"world"</span>, std::<span class="hljs-built_in">string</span>(<span class="hljs-string">"!"</span>)) &lt;&lt; <span class="hljs-string">'\n'</span>; <span class="hljs-comment">// OK</span></code></pre></div><p>因为在几乎所有情况下，从左到右的评估都是意图，通常应该首选带有参数包的左折叠语法（除非这不起作用）：</p><div class="code-wrapper"><pre><code class="hljs c++">(... + args); <span class="hljs-comment">// 折叠表达式的首选语法</span></code></pre></div><h5><span id="11-2-1-chu-li-kong-can-shu-bao">11.2.1 处理空参数包</span><a href="#11-2-1-chu-li-kong-can-shu-bao" class="header-anchor">#</a></h5><p>如果折叠表达式使用了一个空的参数包，那么以下规则适用。</p><ul><li><p>如果使用了操作符&amp;&amp;，其值为真。</p></li><li><p>如果使用了操作符||，则值为假。</p></li><li><p>如果使用了逗号运算符，值是void()。</p></li><li><p>对于所有其他的操作符来说，调用是不符合格式的。<br>对于所有其他情况（以及一般情况下），你可以添加一个初始值。给定一个参数包args，一个初始值值和一个运算符op，C++17还允许我们写出以下两种情况</p></li><li><p>或者二元左折叠</p><div class="code-wrapper"><pre><code class="hljs c++">( value op ... op args )</code></pre></div><p>扩展为： (((value op arg1) op arg2) op arg3) op . . .</p></li><li><p>或二元右折叠</p><div class="code-wrapper"><pre><code class="hljs c++">( args op ... op value )</code></pre></div></li></ul><p>省略号两边的运算符 op 必须相同。<br>  例如，以下定义允许在添加值时传递一个空参数包：</p><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span>... T&gt;</span><span class="hljs-function"><span class="hljs-keyword">auto</span> <span class="hljs-title">foldSum</span> <span class="hljs-params">(T... s)</span></span>{    <span class="hljs-keyword">return</span> (<span class="hljs-number">0</span> + ... + s); <span class="hljs-comment">// 如果 sizeof...(s)==0 甚至可以工作</span>}</code></pre></div><p>从概念上讲，我们是否将 0 添加为第一个或最后一个操作数并不重要：</p><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span>... T&gt;</span><span class="hljs-function"><span class="hljs-keyword">auto</span> <span class="hljs-title">foldSum</span> <span class="hljs-params">(T... s)</span></span>{    <span class="hljs-keyword">return</span> (s + ... + <span class="hljs-number">0</span>); <span class="hljs-comment">// 如果 sizeof...(s)==0 甚至可以工作</span>}</code></pre></div><p>但是对于一元折叠表达式，不同的评估顺序比想象的更重要，应该首选二元左折叠：</p><div class="code-wrapper"><pre><code class="hljs c++">(val + ... + args); <span class="hljs-comment">// 二进制折叠表达式的首选语法</span></code></pre></div><p>此外，第一个操作数可能是特殊的，例如在此示例中：</p><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span>... T&gt;</span><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">print</span> <span class="hljs-params">(<span class="hljs-type">const</span> T&amp;... args)</span></span><span class="hljs-function"></span>{    (std::cout &lt;&lt; ... &lt;&lt; args) &lt;&lt; <span class="hljs-string">'\n'</span>;}</code></pre></div><p>在这里，重要的是第一个调用是第一个传递给 print() 的参数的输出，它返回流以执行其他输出调用。 其他实现可能无法编译甚至做一些意想不到的事情。 例如，与</p><div class="code-wrapper"><pre><code class="hljs c++">std::cout &lt;&lt; (args &lt;&lt; ... &lt;&lt; <span class="hljs-string">'\n'</span>);</code></pre></div><p>像 print(1) 这样的调用将编译但打印值 1 左移了 ‘\n’ 的值，通常为 10，因此结果输出为 1024。<br>请注意，在此 print() 示例中，没有空格将参数包的所有元素彼此分开。 诸如 print(“hello”, 42, “world”) 之类的调用将打印：</p><div class="code-wrapper"><pre><code class="hljs bash">hello42world</code></pre></div><p>要通过空格分隔传递的元素，您需要一个帮助器来确保除第一个参数之外的任何输出都由前导空格扩展。 例如，这可以使用辅助函数模板 spaceBefore() 来完成：</p><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;</span><span class="hljs-function"><span class="hljs-type">const</span> T&amp; <span class="hljs-title">spaceBefore</span><span class="hljs-params">(<span class="hljs-type">const</span> T&amp; arg)</span> </span>{    std::cout &lt;&lt; <span class="hljs-string">' '</span>;    <span class="hljs-keyword">return</span> arg;}<span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> First, <span class="hljs-keyword">typename</span>... Args&gt;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">print</span> <span class="hljs-params">(<span class="hljs-type">const</span> First&amp; firstarg, <span class="hljs-type">const</span> Args&amp;... args)</span> </span>{    std::cout &lt;&lt; firstarg;    (std::cout &lt;&lt; ... &lt;&lt; <span class="hljs-built_in">spaceBefore</span>(args)) &lt;&lt; <span class="hljs-string">'\n'</span>;}</code></pre></div><p>这里，</p><div class="code-wrapper"><pre><code class="hljs c++">(std::cout &lt;&lt; ... &lt;&lt; <span class="hljs-built_in">spaceBefore</span>(args))</code></pre></div><p>是一个折叠表达式，展开为：</p><div class="code-wrapper"><pre><code class="hljs c++">std::cout &lt;&lt; <span class="hljs-built_in">spaceBefore</span>(arg1) &lt;&lt; <span class="hljs-built_in">spaceBefore</span>(arg2) &lt;&lt; ...</code></pre></div><p>因此，对于参数包 args 中的每个元素，它调用一个辅助函数，在返回传递的参数之前打印出一个空格字符，并将其写入 std::cout。 为了确保这不适用于第一个参数，我们添加了一个不使用 spaceBefore() 的附加第一个参数。<br>请注意，参数包输出的评估要求左侧的所有输出都在为实际元素调用 spaceBefore() 之前完成。 由于定义了运算符 &lt;&lt; 和函数调用的评估顺序，这保证从 C++17 开始就可以工作。<br>我们还可以使用 lambda 在 print() 中定义 spaceBefore()：</p><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> First, <span class="hljs-keyword">typename</span>... Args&gt;</span><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">print</span> <span class="hljs-params">(<span class="hljs-type">const</span> First&amp; firstarg, <span class="hljs-type">const</span> Args&amp;... args)</span> </span>{    std::cout &lt;&lt; firstarg;    <span class="hljs-keyword">auto</span> spaceBefore = [](<span class="hljs-type">const</span> <span class="hljs-keyword">auto</span>&amp; arg) {        std::cout &lt;&lt; <span class="hljs-string">' '</span>;        <span class="hljs-keyword">return</span> arg;    };    (std::cout &lt;&lt; ... &lt;&lt; <span class="hljs-built_in">spaceBefore</span>(args)) &lt;&lt; <span class="hljs-string">'\n'</span>;}</code></pre></div><p>但是，请注意 lambdas 默认按值返回对象，这意味着这将创建传递参数的不必要副本。 避免这种情况的方法是将 lambda 的返回类型显式声明为 const auto&amp; 或 decltype(auto)：</p><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> First, <span class="hljs-keyword">typename</span>... Args&gt;</span><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">print</span> <span class="hljs-params">(<span class="hljs-type">const</span> First&amp; firstarg, <span class="hljs-type">const</span> Args&amp;... args)</span> </span>{    std::cout &lt;&lt; firstarg;    <span class="hljs-keyword">auto</span> spaceBefore = [](<span class="hljs-type">const</span> <span class="hljs-keyword">auto</span>&amp; arg) -&gt; <span class="hljs-type">const</span> <span class="hljs-keyword">auto</span>&amp; {        std::cout &lt;&lt; <span class="hljs-string">' '</span>;        <span class="hljs-keyword">return</span> arg;    };    (std::cout &lt;&lt; ... &lt;&lt; <span class="hljs-built_in">spaceBefore</span>(args)) &lt;&lt; <span class="hljs-string">'\n'</span>;}</code></pre></div><p>如果你不能将这一切结合在一个语句中，C++ 就不会是 C++：</p><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> First, <span class="hljs-keyword">typename</span>... Args&gt;</span><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">print</span> <span class="hljs-params">(<span class="hljs-type">const</span> First&amp; firstarg, <span class="hljs-type">const</span> Args&amp;... args)</span> </span>{    std::cout &lt;&lt; firstarg;    (std::cout &lt;&lt; ... &lt;&lt; [](<span class="hljs-type">const</span> <span class="hljs-keyword">auto</span>&amp; arg) -&gt; <span class="hljs-keyword">decltype</span>(<span class="hljs-keyword">auto</span>) {        std::cout &lt;&lt; <span class="hljs-string">' '</span>;        <span class="hljs-keyword">return</span> arg;    }(args)) &lt;&lt; <span class="hljs-string">'\n'</span>;}</code></pre></div><p>然而，实现 print() 的一种更简单的方法是使用 lambda 打印空间和参数并将其传递给一元折叠：</p><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> First, <span class="hljs-keyword">typename</span>... Args&gt;</span><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">print</span><span class="hljs-params">(First first, <span class="hljs-type">const</span> Args&amp;... args)</span> </span>{    std::cout &lt;&lt; first;    <span class="hljs-keyword">auto</span> outWithSpace = [](<span class="hljs-type">const</span> <span class="hljs-keyword">auto</span>&amp; arg) {        std::cout &lt;&lt; <span class="hljs-string">' '</span> &lt;&lt; arg;    };    (... , <span class="hljs-built_in">outWithSpace</span>(args));    std::cout &lt;&lt; <span class="hljs-string">'\n'</span>;}</code></pre></div><p>通过使用使用 auto 声明的附加模板参数，我们可以使 print() 更加灵活，可以将分隔符参数化为字符、字符串或任何其他可打印类型。</p><h5><span id="11-2-2-zhi-chi-de-cao-zuo-fu">11.2.2 支持的操作符</span><a href="#11-2-2-zhi-chi-de-cao-zuo-fu" class="header-anchor">#</a></h5><p>您可以将所有二元运算符用于折叠表达式，除了 ., -&gt;, and []。</p><h6><span id="zhe-die-han-shu-diao-yong">折叠函数调用</span><a href="#zhe-die-han-shu-diao-yong" class="header-anchor">#</a></h6><p>折叠表达式也可以用于逗号运算符，将多个表达式组合成一个语句。 例如，您可以折叠逗号运算符，它可以执行对可变数量的基类的成员函数的函数调用：</p><p><code>tmpl/foldcalls.cpp </code></p><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><span class="hljs-comment">// template fo ame... Bases&gt;</span><span class="hljs-keyword">class</span> <span class="hljs-title class_">MultiBase</span> : <span class="hljs-keyword">private</span> Bases...{    <span class="hljs-keyword">public</span>:    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">print</span><span class="hljs-params">()</span> </span>{        <span class="hljs-comment">// call print() of all base classes:</span>        (... , Bases::<span class="hljs-built_in">print</span>());    }};<span class="hljs-keyword">struct</span> <span class="hljs-title class_">A</span> {    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">print</span><span class="hljs-params">()</span> </span>{ std::cout &lt;&lt; <span class="hljs-string">"A::print()\n"</span>; }};<span class="hljs-keyword">struct</span> <span class="hljs-title class_">B</span> {    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">print</span><span class="hljs-params">()</span> </span>{ std::cout &lt;&lt; <span class="hljs-string">"B::print()\n"</span>; }};<span class="hljs-keyword">struct</span> <span class="hljs-title class_">C</span> {    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">print</span><span class="hljs-params">()</span> </span>{ std::cout &lt;&lt; <span class="hljs-string">"C::print()\n"</span>; }};<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>{    MultiBase&lt;A,B,C&gt; mb;    mb.<span class="hljs-built_in">print</span>();}</code></pre></div><p>这里，</p><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span>... Bases&gt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">MultiBase</span> : <span class="hljs-keyword">private</span> Bases...{    ...};</code></pre></div><p>允许我们使用可变数量的基类来初始化对象：</p><div class="code-wrapper"><pre><code class="hljs c++">MultiBase&lt;A,B,C&gt; mb;</code></pre></div><p>并与</p><div class="code-wrapper"><pre><code class="hljs c++">(... , Bases::<span class="hljs-built_in">print</span>());</code></pre></div><p>折叠表达式用于扩展它以调用每个基类的打印。 也就是说，带有折叠表达式的语句扩展为以下内容：</p><div class="code-wrapper"><pre><code class="hljs c++">(A::<span class="hljs-built_in">print</span>() , B::<span class="hljs-built_in">print</span>()) , C::<span class="hljs-built_in">print</span>();</code></pre></div><p>但是，请注意，由于逗号运算符的性质，我们使用左折叠运算符还是右折叠运算符并不重要。 函数总是从左到右调用。 和</p><div class="code-wrapper"><pre><code class="hljs c++">(Bases::<span class="hljs-built_in">print</span>() , ...);</code></pre></div><p>括号仅对调用进行分组，以便第一个 print() 调用与其他两个 print() 调用的结果组合如下：</p><div class="code-wrapper"><pre><code class="hljs c++">A::<span class="hljs-built_in">print</span>() , (B::<span class="hljs-built_in">print</span>() , C::<span class="hljs-built_in">print</span>());</code></pre></div><p>但是因为逗号运算符的计算顺序总是从左到右，所以第一个调用发生在括号内的两个调用组之前，其中中间调用仍然发生在右调用之前。<br>尽管如此，由于左折叠表达式与结果求值顺序匹配，因此在将左折叠表达式用于多个函数调用时，再次建议使用左折叠表达式。</p><h6><span id="jie-he-ha-xi-han-shu">结合哈希函数</span><a href="#jie-he-ha-xi-han-shu" class="header-anchor">#</a></h6><p>使用逗号运算符的一个示例是组合散列值。 这可以按如下方式完成：</p><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;</span><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">hashCombine</span> <span class="hljs-params">(std::<span class="hljs-type">size_t</span>&amp; seed, <span class="hljs-type">const</span> T&amp; val)</span></span><span class="hljs-function"></span>{    seed ^= std::<span class="hljs-built_in">hash</span>&lt;T&gt;()(val) + <span class="hljs-number">0x9e3779b9</span> + (seed&lt;&lt;<span class="hljs-number">6</span>) + (seed&gt;&gt;<span class="hljs-number">2</span>);}<span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span>... Types&gt;</span><span class="hljs-function">std::<span class="hljs-type">size_t</span> <span class="hljs-title">combinedHashValue</span> <span class="hljs-params">(<span class="hljs-type">const</span> Types&amp;... args)</span></span><span class="hljs-function"></span>{    std::<span class="hljs-type">size_t</span> seed = <span class="hljs-number">0</span>; <span class="hljs-comment">// initial seed</span>    (... , <span class="hljs-built_in">hashCombine</span>(seed,args)); <span class="hljs-comment">// chain of hashCombine() calls</span>    <span class="hljs-keyword">return</span> seed;}</code></pre></div><p>通过调用</p><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-function">std::<span class="hljs-type">size_t</span> <span class="hljs-title">combinedHashValue</span> <span class="hljs-params">(<span class="hljs-string">"Hello"</span>, <span class="hljs-string">"World"</span>, <span class="hljs-number">42</span>,)</span></span>;</code></pre></div><p>中间的语句扩展为：</p><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-built_in">hashCombine</span>(seed,<span class="hljs-string">"Hello"</span>), (<span class="hljs-built_in">hashCombine</span>(seed,<span class="hljs-string">"World"</span>), <span class="hljs-built_in">hashCombine</span>(seed,<span class="hljs-number">42</span>);</code></pre></div><p>通过这个定义，我们可以轻松地为诸如 Customer 的类型定义一个新的散列函数对象：</p><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">CustomerHash</span>{    <span class="hljs-function">std::<span class="hljs-type">size_t</span> <span class="hljs-title">operator</span><span class="hljs-params">()</span> <span class="hljs-params">(<span class="hljs-type">const</span> Customer&amp; c)</span> <span class="hljs-type">const</span> </span>{        <span class="hljs-keyword">return</span> <span class="hljs-built_in">combinedHashValue</span>(c.<span class="hljs-built_in">getFirstname</span>(), c.<span class="hljs-built_in">getLastname</span>(), c.<span class="hljs-built_in">getValue</span>());    }};</code></pre></div><p>我们可以用它来把客户放在一个无序的集合中：</p><div class="code-wrapper"><pre><code class="hljs c++">std::unordered_set&lt;Customer, CustomerHash&gt; coll;</code></pre></div><p>折叠路径遍历</p><p>您还可以使用折叠表达式通过运算符 -&gt;* 遍历二叉树中的路径：</p><p><code>tmpl/foldtraverse.cpp</code></p><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-comment">// 定义二叉树结构和遍历辅助函数:</span><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Node</span> {    <span class="hljs-type">int</span> value;    Node* left;    Node* right;    <span class="hljs-built_in">Node</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>) : <span class="hljs-built_in">value</span>(i), <span class="hljs-built_in">left</span>(<span class="hljs-literal">nullptr</span>), <span class="hljs-built_in">right</span>(<span class="hljs-literal">nullptr</span>) {    }    ...};<span class="hljs-keyword">auto</span> left = &amp;Node::left;<span class="hljs-keyword">auto</span> right = &amp;Node::right;<span class="hljs-comment">// 遍历树，使用折叠表达式:</span><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T, <span class="hljs-keyword">typename</span>... TP&gt;</span><span class="hljs-function">Node* <span class="hljs-title">traverse</span> <span class="hljs-params">(T np, TP... paths)</span> </span>{    <span class="hljs-keyword">return</span> (np -&gt;* ... -&gt;* paths); <span class="hljs-comment">// np -&gt;* paths1 -&gt;* paths2 ...</span>}<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>{    <span class="hljs-comment">// 初始化二叉树结构:</span>    Node* root = <span class="hljs-keyword">new</span> Node{<span class="hljs-number">0</span>};    root-&gt;left = <span class="hljs-keyword">new</span> Node{<span class="hljs-number">1</span>};    root-&gt;left-&gt;right = <span class="hljs-keyword">new</span> Node{<span class="hljs-number">2</span>};    ...    <span class="hljs-comment">// 遍历二叉树:</span>    Node* node = <span class="hljs-built_in">traverse</span>(root, left, right);    ...}</code></pre></div><p>这里，</p><div class="code-wrapper"><pre><code class="hljs c++">(np -&gt;* ... -&gt;* paths)</code></pre></div><p>使用折叠表达式来遍历来自 np 的路径的可变参数元素。 调用时</p><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-built_in">traverse</span>(root, left, right);</code></pre></div><p>fold 表达式的调用扩展为：</p><div class="code-wrapper"><pre><code class="hljs bash">root -&gt; left -&gt; right</code></pre></div><h5><span id="11-2-3-wei-lei-xing-shi-yong-zhe-die-biao-da-shi">11.2.3 为类型使用折叠表达式</span><a href="#11-2-3-wei-lei-xing-shi-yong-zhe-die-biao-da-shi" class="header-anchor">#</a></h5><p>通过使用类型特征，我们还可以使用折叠表达式来处理模板参数包（作为模板参数传递的任意数量的类型）。 例如，您可以使用折叠表达式来确定类型列表是否是齐次的：</p><p><code>tmpl/ishomogeneous.hpp</code></p><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;type_traits&gt;</span></span><span class="hljs-comment">// 检查传递的类型是否是同质的:</span><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T1, <span class="hljs-keyword">typename</span>... TN&gt;<span class="hljs-keyword">struct</span> <span class="hljs-title class_">IsHomogeneous</span> {    <span class="hljs-type">static</span> <span class="hljs-keyword">constexpr</span> <span class="hljs-type">bool</span> value = (std::is_same&lt;T1,TN&gt;::value &amp;&amp; ...);};<span class="hljs-comment">// 检查传递的参数是否具有相同的类型:</span><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T1, <span class="hljs-keyword">typename</span>... TN&gt;</span><span class="hljs-function"><span class="hljs-keyword">constexpr</span> <span class="hljs-type">bool</span> <span class="hljs-title">isHomogeneous</span><span class="hljs-params">(T1, TN...)</span></span><span class="hljs-function"></span>{    <span class="hljs-keyword">return</span> (std::is_same&lt;T1,TN&gt;::value &amp;&amp; ...);}</code></pre></div><p>可以使用类型特征 IsHomogeneous&lt;&gt;，例如，如下所示：</p><div class="code-wrapper"><pre><code class="hljs c++">IsHomogeneous&lt;<span class="hljs-type">int</span>, Size, <span class="hljs-keyword">decltype</span>(<span class="hljs-number">42</span>)&gt;::value</code></pre></div><p>在这种情况下，初始化成员值的折叠表达式扩展为：</p><div class="code-wrapper"><pre><code class="hljs c++">std::is_same&lt;<span class="hljs-type">int</span>,MyType&gt;::value &amp;&amp; std::is_same&lt;<span class="hljs-type">int</span>,<span class="hljs-keyword">decltype</span>(<span class="hljs-number">42</span>)&gt;::value</code></pre></div><p>可以使用函数模板isHomogeneous&lt;&gt;()，例如如下：</p><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-built_in">isHomogeneous</span>(<span class="hljs-number">43</span>, <span class="hljs-number">-1</span>, <span class="hljs-string">"hello"</span>, <span class="hljs-literal">nullptr</span>)</code></pre></div><p>在这种情况下，初始化成员值的折叠表达式扩展为：</p><div class="code-wrapper"><pre><code class="hljs c++">std::is_same&lt;<span class="hljs-type">int</span>,<span class="hljs-type">int</span>&gt;::value &amp;&amp; std::is_same&lt;<span class="hljs-type">int</span>,<span class="hljs-type">const</span> <span class="hljs-type">char</span>*&gt;::value    &amp;&amp; std::is_same&lt;<span class="hljs-type">int</span>,std::<span class="hljs-type">nullptr_t</span>&gt;::value</code></pre></div><p>像往常一样，操作符&amp;&amp;是短 循环的（在第一个假的之后中止评估）。<br>std::array&lt;&gt;的推导指南在标准库中使用了这个特性。</p><h4><span id="11-3-hou-ji">11.3 后记</span><a href="#11-3-hou-ji" class="header-anchor">#</a></h4><p>折叠表达式首先由 Andrew Sutton 和 Richard Smith 在 <a href="https://wg21.link/n4191">https://wg21.link/n4191</a> 中提出。 最终接受的措辞由 Andrew Sutton 和 Richard Smith 在 <a href="https://wg21.link/n4295">https://wg21.link/n4295</a> 中制定。 后来删除了对运算符 *、+、&amp; 和 | 的空序列支持 正如 Thibaut Le Jehan 在 <a href="https://wg21.link/p0036">https://wg21.link/p0036</a> 中提出的那样。</p><h3><span id="12-jiang-zi-fu-chuan-zuo-wei-mo-ban-can-shu-chu-li">12 将字符串作为模板参数处理</span><a href="#12-jiang-zi-fu-chuan-zuo-wei-mo-ban-can-shu-chu-li" class="header-anchor">#</a></h3><p>随着时间的推移，不同版本的 C++ 放宽了可用作模板参数的规则，而在 C++17 中，这种情况再次发生。 现在可以使用模板，而无需在当前范围之外定义它们。</p><h4><span id="12-1-zai-mo-ban-zhong-shi-yong-zi-fu-chuan">12.1 在模板中使用字符串</span><a href="#12-1-zai-mo-ban-zhong-shi-yong-zi-fu-chuan" class="header-anchor">#</a></h4><p>非类型模板参数只能是常量整数值（包括枚举）、指向对象/函数/成员的指针、对对象或函数的左值引用或 std::nullptr_t（nullptr 的类型）。<br>对于指针，链接是必需的，这意味着您不能直接传递字符串文字。 但是，从 C++17 开始，您可以拥有带有内部链接的指针。 例如：</p><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">template</span>&lt;<span class="hljs-type">const</span> <span class="hljs-type">char</span>* str&gt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">Message</span> {    ...};<span class="hljs-keyword">extern</span> <span class="hljs-type">const</span> <span class="hljs-type">char</span> hello[] = <span class="hljs-string">"Hello World!"</span>; <span class="hljs-comment">// 外联</span><span class="hljs-type">const</span> <span class="hljs-type">char</span> hello11[] = <span class="hljs-string">"Hello World!"</span>; <span class="hljs-comment">// 内部链接</span><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">foo</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>{    Message&lt;hello&gt; msg; <span class="hljs-comment">// OK (all C++ versions)</span>    Message&lt;hello11&gt; msg11; <span class="hljs-comment">// OK since C++11</span>    <span class="hljs-type">static</span> <span class="hljs-type">const</span> <span class="hljs-type">char</span> hello17[] = <span class="hljs-string">"Hello World!"</span>; <span class="hljs-comment">// 无联动</span>    Message&lt;hello17&gt; msg17; <span class="hljs-comment">// OK since C++17</span>}</code></pre></div><p>也就是说，从 C++17 开始，您仍然需要两行来将字符串文字传递给模板。 但是您可以将第一行放在与类实例化相同的范围内。<br>这种能力也解决了一个不幸的限制：虽然你可以将指针传递给自 C++11 以来的类模板：</p><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">template</span>&lt;<span class="hljs-type">int</span>* p&gt; <span class="hljs-keyword">struct</span> <span class="hljs-title class_">A</span> {};<span class="hljs-type">int</span> num;A&lt;&amp;num&gt; a; <span class="hljs-comment">// OK since C++11</span></code></pre></div><p>您不能使用返回地址的编译时函数，现在支持：</p><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-type">int</span> num;...<span class="hljs-function"><span class="hljs-keyword">constexpr</span> <span class="hljs-type">int</span>* <span class="hljs-title">pNum</span><span class="hljs-params">()</span> </span>{    <span class="hljs-keyword">return</span> &amp;num;}A&lt;<span class="hljs-built_in">pNum</span>()&gt; b; <span class="hljs-comment">// ERROR before C++17, now OK</span></code></pre></div><h4><span id="12-2-hou-ji">12.2 后记</span><a href="#12-2-hou-ji" class="header-anchor">#</a></h4><p>允许对所有非类型模板参数进行持续评估是由 Richard Smith 在 <a href="https://wg21.link/n4198">https://wg21.link/n4198</a> 中首次提出的。 最终接受的措辞由 Richard Smith 在 <a href="https://wg21.link/n4268">https://wg21.link/n4268</a> 中制定。</p><h3><span id="13-zhan-wei-fu-lei-xing-li-ru-auto-zuo-wei-mo-ban-can-shu">13 占位符类型（例如 auto）作为模板参数</span><a href="#13-zhan-wei-fu-lei-xing-li-ru-auto-zuo-wei-mo-ban-can-shu" class="header-anchor">#</a></h3><p>从 C++17 开始，您可以使用占位符类型（auto 和 decltype(auto)）作为非类型模板参数类型。 这意味着，我们可以为不同类型的非类型参数编写通用代码。</p><h4><span id="13-1-shi-yong-auto-zuo-wei-mo-ban-can-shu">13.1 使用auto作为模板参数</span><a href="#13-1-shi-yong-auto-zuo-wei-mo-ban-can-shu" class="header-anchor">#</a></h4><p>从 C++17 开始，您可以使用 auto 来声明非类型模板参数。 例如：</p><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">auto</span> N&gt; <span class="hljs-keyword">class</span> <span class="hljs-title class_">S</span> {    ...};</code></pre></div><p>这允许我们为不同类型实例化非类型模板参数 N：</p><div class="code-wrapper"><pre><code class="hljs c++">S&lt;<span class="hljs-number">42</span>&gt; s1; <span class="hljs-comment">// OK: S 中 N 的类型是 int</span>S&lt;<span class="hljs-string">'a'</span>&gt; s2; <span class="hljs-comment">// OK: S 中 N 的类型是 char</span></code></pre></div><p>但是，您不能使用此功能来获取通常不允许作为模板参数的类型的实例化：</p><div class="code-wrapper"><pre><code class="hljs c++">S&lt;<span class="hljs-number">2.5</span>&gt; s3； <span class="hljs-comment">// 错误：模板参数类型仍然不能为双精度</span></code></pre></div><p>我们甚至可以有一个特定的类型作为部分特化：</p><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">template</span>&lt;<span class="hljs-type">int</span> N&gt; <span class="hljs-keyword">class</span> <span class="hljs-title class_">S</span>&lt;N&gt; {    ...};</code></pre></div><p>甚至支持类模板参数推导。 例如：</p><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T, <span class="hljs-keyword">auto</span> N&gt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span> {<span class="hljs-keyword">public</span>:    <span class="hljs-built_in">A</span>(<span class="hljs-type">const</span> std::array&lt;T,N&gt;&amp;) {    }    <span class="hljs-built_in">A</span>(<span class="hljs-built_in">T</span>(&amp;)[N]) {    }    ...};</code></pre></div><p>这个类可以推导出T的类型，N的类型，N的值：</p><div class="code-wrapper"><pre><code class="hljs c++">A a2{<span class="hljs-string">"hello"</span>}; <span class="hljs-comment">// OK, 推导出 A&lt;const char, 6&gt; 其中 N 为 int</span>std::array&lt;<span class="hljs-type">double</span>,10&gt; sa1;A a1{sa1}; <span class="hljs-comment">// OK, 推导出 A&lt;double, 10&gt; 其中 N 为 std::size_t</span></code></pre></div><p>您还可以限定 auto，例如，要求模板参数的类型是指针：</p><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">template</span>&lt;<span class="hljs-type">const</span> <span class="hljs-keyword">auto</span>* P&gt; <span class="hljs-keyword">struct</span> <span class="hljs-title class_">S</span>;</code></pre></div><p> 通过使用可变参数模板，您可以参数化模板以使用异构常量模板参数列表：</p><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">auto</span>... VS&gt; <span class="hljs-keyword">class</span> <span class="hljs-title class_">HeteroValueList</span> {};</code></pre></div><p>或同质常量模板参数列表：</p><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">auto</span> V1, <span class="hljs-keyword">decltype</span>(V1)... VS&gt; <span class="hljs-keyword">class</span> <span class="hljs-title class_">HomoValueList</span> {};</code></pre></div><p>例如：</p><div class="code-wrapper"><pre><code class="hljs c++">HeteroValueList&lt;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>&gt; vals1; <span class="hljs-comment">// OK</span>HeteroValueList&lt;<span class="hljs-number">1</span>, <span class="hljs-string">'a'</span>, <span class="hljs-literal">true</span>&gt; vals2; <span class="hljs-comment">// OK</span>HomoValueList&lt;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>&gt; vals3; <span class="hljs-comment">// OK</span>HomoValueList&lt;<span class="hljs-number">1</span>, <span class="hljs-string">'a'</span>, <span class="hljs-literal">true</span>&gt; vals4; <span class="hljs-comment">// ERROR</span></code></pre></div><h5><span id="13-1-1-zi-fu-he-zi-fu-chuan-de-can-shu-hua-mo-ban">13.1.1 字符和字符串的参数化模板</span><a href="#13-1-1-zi-fu-he-zi-fu-chuan-de-can-shu-hua-mo-ban" class="header-anchor">#</a></h5><p>此功能的一个应用是允许将字符或字符串作为模板参数传递。<br>例如，我们可以改进使用折叠表达式输出任意数量参数的方式，如下所示：</p><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">auto</span> Sep </span>= <span class="hljs-string">' '</span>, <span class="hljs-keyword">typename</span> First, <span class="hljs-keyword">typename</span>... Args&gt;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">print</span><span class="hljs-params">(<span class="hljs-type">const</span> First&amp; first, <span class="hljs-type">const</span> Args&amp;... args)</span> </span>{    std::cout &lt;&lt; first;    <span class="hljs-keyword">auto</span> outWithSep = [](<span class="hljs-type">const</span> <span class="hljs-keyword">auto</span>&amp; arg) {        std::cout &lt;&lt; Sep &lt;&lt; arg;    };    (... , <span class="hljs-built_in">outWithSep</span>(args));    std::cout &lt;&lt; <span class="hljs-string">'\n'</span>;}</code></pre></div><p>尽管如此，我们可以打印带有空格的参数作为模板参数的默认参数<br> Sep:  </p><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">auto</span> Sep </span>= <span class="hljs-string">' '</span>, <span class="hljs-keyword">typename</span> First, <span class="hljs-keyword">typename</span>... Args&gt;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">print</span> <span class="hljs-params">(<span class="hljs-type">const</span> First&amp; firstarg, <span class="hljs-type">const</span> Args&amp;... args)</span> </span>{    ...}</code></pre></div><p>也就是说，我们仍然可以调用：</p><div class="code-wrapper"><pre><code class="hljs c++">std::string s{<span class="hljs-string">"world"</span>};<span class="hljs-built_in">print</span>(<span class="hljs-number">7.5</span>, <span class="hljs-string">"hello"</span>, s); <span class="hljs-comment">// prints: 7.5 hello world</span></code></pre></div><p>但是通过为分隔符 Sep 参数化 print()，我们现在可以显式传递一个不同的字符作为第一个模板参数：</p><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-built_in">print</span>&lt;<span class="hljs-string">'-'</span>&gt;(<span class="hljs-number">7.5</span>, <span class="hljs-string">"hello"</span>, s); <span class="hljs-comment">// prints: 7.5-hello-world</span></code></pre></div><p>由于使用了 auto，我们甚至可以传递一个字符串文字，我们必须将其声明为没有链接的对象，不过：</p><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-type">static</span> <span class="hljs-type">const</span> <span class="hljs-type">char</span> sep[] = <span class="hljs-string">", "</span>;<span class="hljs-built_in">print</span>&lt;sep&gt;(<span class="hljs-number">7.5</span>, <span class="hljs-string">"hello"</span>, s); <span class="hljs-comment">// prints: 7.5, hello, world</span></code></pre></div><p>或者我们可以传递可用作模板参数的任何其他类型的分隔符（这比这里更有意义）：</p><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-built_in">print</span>&lt;<span class="hljs-number">-11</span>&gt;(<span class="hljs-number">7.5</span>, <span class="hljs-string">"hello"</span>, s); <span class="hljs-comment">// prints: 7.5-11hello-11world</span></code></pre></div><h5><span id="13-1-2-ding-yi-yuan-bian-cheng-chang-liang">13.1.2 定义元编程常量</span><a href="#13-1-2-ding-yi-yuan-bian-cheng-chang-liang" class="header-anchor">#</a></h5><p>模板参数自动特性的另一个应用是更容易定义编译时常量。 而不是定义：</p><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T, T v&gt;<span class="hljs-keyword">struct</span> <span class="hljs-title class_">constant</span>{    <span class="hljs-type">static</span> <span class="hljs-keyword">constexpr</span> T value = v;};<span class="hljs-keyword">using</span> i = constant&lt;<span class="hljs-type">int</span>, <span class="hljs-number">42</span>&gt;;<span class="hljs-keyword">using</span> c = constant&lt;<span class="hljs-type">char</span>, <span class="hljs-string">'x'</span>&gt;;<span class="hljs-keyword">using</span> b = constant&lt;<span class="hljs-type">bool</span>, <span class="hljs-literal">true</span>&gt;;</code></pre></div><p>您现在可以执行以下操作：</p><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">auto</span> v&gt;<span class="hljs-keyword">struct</span> <span class="hljs-title class_">constant</span>{    <span class="hljs-type">static</span> <span class="hljs-keyword">constexpr</span> <span class="hljs-keyword">auto</span> value = v;};<span class="hljs-keyword">using</span> i = constant&lt;<span class="hljs-number">42</span>&gt;;<span class="hljs-keyword">using</span> c = constant&lt;<span class="hljs-string">'x'</span>&gt;;<span class="hljs-keyword">using</span> b = constant&lt;<span class="hljs-literal">true</span>&gt;;</code></pre></div><p>而不是：</p><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T, T... Elements&gt;<span class="hljs-keyword">struct</span> <span class="hljs-title class_">sequence</span> {};<span class="hljs-keyword">using</span> indexes = sequence&lt;<span class="hljs-type">int</span>, <span class="hljs-number">0</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>&gt;;</code></pre></div><p>你现在可以实现：</p><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">auto</span>... Elements&gt;<span class="hljs-keyword">struct</span> <span class="hljs-title class_">sequence</span> {};<span class="hljs-keyword">using</span> indexes = sequence&lt;<span class="hljs-number">0</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>&gt;;</code></pre></div><p>您现在甚至可以定义表示异构值列表的编译时对象（类似于压缩元组）：</p><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">using</span> tuple = sequence&lt;<span class="hljs-number">0</span>, <span class="hljs-string">'h'</span>, <span class="hljs-literal">true</span>&gt;;</code></pre></div><h4><span id="13-2-shi-yong-auto-zuo-wei-ke-bian-mo-ban-can-shu">13.2 使用 auto 作为可变模板参数</span><a href="#13-2-shi-yong-auto-zuo-wei-ke-bian-mo-ban-can-shu" class="header-anchor">#</a></h4><p>您还可以将 auto 用作带有变量模板的模板参数。 例如，以下可能出现在头文件中的声明定义了一个变量模板 arr 参数化为元素的类型以及元素数量的磁带和值：</p><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T, <span class="hljs-keyword">auto</span> N&gt; std::array&lt;T,N&gt; arr;</code></pre></div><p>在每个翻译单元中， arr&lt;int,10&gt; 的所有用法共享同一个全局对象，而 arr&lt;long,10&gt; 和 arr&lt;int,10u&gt; 将是不同的全局对象（同样，它们都可用于所有翻译单元）。</p><p>作为一个完整的示例，请考虑以下头文件：</p><p><code>tmpl/vartmplauto.hpp</code></p><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">ifndef</span> VARTMPLAUTO_HPP</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> VARTMPLAUTO_HPP</span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;array&gt;</span></span><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T, <span class="hljs-keyword">auto</span> N&gt; std::array&lt;T,N&gt; arr{};<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">printArr</span><span class="hljs-params">()</span></span>;<span class="hljs-meta">#<span class="hljs-keyword">endif</span> <span class="hljs-comment">// VARTMPLAUTO_HPP</span></span></code></pre></div><p>在这里，一个翻译单元可以修改这个变量模板的两个不同实例的值</p><p><code>tmpl/vartmplauto1.cpp </code></p><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">"vartmplauto.hpp"</span></span><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>{    arr&lt;<span class="hljs-type">int</span>,<span class="hljs-number">5</span>&gt;[<span class="hljs-number">0</span>] = <span class="hljs-number">17</span>;    arr&lt;<span class="hljs-type">int</span>,<span class="hljs-number">5</span>&gt;[<span class="hljs-number">3</span>] = <span class="hljs-number">42</span>;    arr&lt;<span class="hljs-type">int</span>,<span class="hljs-number">5u</span>&gt;[<span class="hljs-number">1</span>] = <span class="hljs-number">11</span>;    arr&lt;<span class="hljs-type">int</span>,<span class="hljs-number">5u</span>&gt;[<span class="hljs-number">3</span>] = <span class="hljs-number">33</span>;    <span class="hljs-built_in">printArr</span>();}</code></pre></div><p>另一个翻译单元可以打印这两个变量：</p><p><code>tmpl/vartmplauto2.cpp </code></p><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">"vartmplauto.hpp"</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">printArr</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>{    std::cout &lt;&lt; <span class="hljs-string">"arr&lt;int,5&gt;: "</span>;    <span class="hljs-keyword">for</span> (<span class="hljs-type">const</span> <span class="hljs-keyword">auto</span>&amp; elem : arr&lt;<span class="hljs-type">int</span>,<span class="hljs-number">5</span>&gt;) {        std::cout &lt;&lt; elem &lt;&lt; <span class="hljs-string">' '</span>;    }    std::cout &lt;&lt; <span class="hljs-string">"\narr&lt;int,5u&gt;: "</span>;    <span class="hljs-keyword">for</span> (<span class="hljs-type">const</span> <span class="hljs-keyword">auto</span>&amp; elem : arr&lt;<span class="hljs-type">int</span>,<span class="hljs-number">5u</span>&gt;) {        std::cout &lt;&lt; elem &lt;&lt; <span class="hljs-string">' '</span>;    }    std::cout &lt;&lt; <span class="hljs-string">'\n'</span>;}</code></pre></div><p>该程序的输出将是：</p><div class="code-wrapper"><pre><code class="hljs c++">arr&lt;<span class="hljs-type">int</span>,<span class="hljs-number">5</span>&gt;: <span class="hljs-number">17</span> <span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">42</span> <span class="hljs-number">0</span>arr&lt;<span class="hljs-type">int</span>,<span class="hljs-number">5u</span>&gt;: <span class="hljs-number">0</span> <span class="hljs-number">11</span> <span class="hljs-number">0</span> <span class="hljs-number">33</span> <span class="hljs-number">0</span></code></pre></div><p>与声明从其初始值推导出的任意类型的常量变量相同的方式：</p><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">auto</span> N&gt; <span class="hljs-keyword">constexpr</span> <span class="hljs-keyword">auto</span> val = N; <span class="hljs-comment">// OK since C++17</span></code></pre></div><p>并在以后使用它，例如，如下：</p><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">auto</span> v1 = val&lt;<span class="hljs-number">5</span>&gt;; <span class="hljs-comment">// v1 == 5, v1 is int</span><span class="hljs-keyword">auto</span> v2 = val&lt;<span class="hljs-literal">true</span>&gt;; <span class="hljs-comment">// v2 == true, v2 is bool</span><span class="hljs-keyword">auto</span> v3 = val&lt;<span class="hljs-string">'a'</span>&gt;; <span class="hljs-comment">// v3 == ’a’, v3 is char</span></code></pre></div><p>为了澄清这里发生了什么：</p><div class="code-wrapper"><pre><code class="hljs c++">std::is_same_v&lt;<span class="hljs-keyword">decltype</span>(val&lt;<span class="hljs-number">5</span>&gt;), <span class="hljs-type">int</span>&gt; <span class="hljs-comment">// yields false</span>std::is_same_v&lt;<span class="hljs-keyword">decltype</span>(val&lt;<span class="hljs-number">5</span>&gt;), <span class="hljs-type">const</span> <span class="hljs-type">int</span>&gt; <span class="hljs-comment">// yields true</span>std::is_same_v&lt;<span class="hljs-keyword">decltype</span>(v1), <span class="hljs-type">int</span>&gt;; <span class="hljs-comment">// yields true (because auto decays)</span></code></pre></div><h4><span id="13-3-shi-yong-decltype-auto-zuo-wei-mo-ban-can-shu">13.3 使用decltype(auto)作为模板参数</span><a href="#13-3-shi-yong-decltype-auto-zuo-wei-mo-ban-can-shu" class="header-anchor">#</a></h4><p>您还可以使用 C++14 引入的其他占位符类型 decltype(auto)。 但是请注意，这种类型有非常特殊的规则来推断类型。 根据decltype，如果传递的是表达式而不是名称，它会根据表达式的值类别推导类型：</p><ul><li>纯右值的类型（例如，临时值）</li><li>type&amp; 用于左值（例如，具有名称的对象）</li><li>xvalue 的类型&amp;&amp;（例如，转换为右值引用的对象，与 std::move() 一样。<br>这意味着，您可以轻松地将模板参数推导出为引用，这可能会产生令人惊讶的效果。<br>例如：</li></ul><p><code>tmpl/decltypeauto.cpp </code></p><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">decltype</span>(<span class="hljs-keyword">auto</span>) N&gt;<span class="hljs-keyword">struct</span> <span class="hljs-title class_">S</span> {    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">printN</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>{        std::cout &lt;&lt; <span class="hljs-string">"N: "</span> &lt;&lt; N &lt;&lt; <span class="hljs-string">'\n'</span>;    }};<span class="hljs-type">static</span> <span class="hljs-type">const</span> <span class="hljs-type">int</span> c = <span class="hljs-number">42</span>;<span class="hljs-type">static</span> <span class="hljs-type">int</span> v = <span class="hljs-number">42</span>;<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>{    S&lt;c&gt; s1; <span class="hljs-comment">// 将 N 推导出为 const int 42</span>    S&lt;(c)&gt; s2; <span class="hljs-comment">// 将 N 推导出为 const int&amp; 引用 c</span>    s1.<span class="hljs-built_in">printN</span>();    s2.<span class="hljs-built_in">printN</span>();    S&lt;(v)&gt; s3; <span class="hljs-comment">// 将 N 推导出为 int&amp; 引用 v</span>    v = <span class="hljs-number">77</span>;    s3.<span class="hljs-built_in">printN</span>(); <span class="hljs-comment">// prints: N: 77</span>}</code></pre></div><h4><span id="13-4-hou-ji">13.4 后记</span><a href="#13-4-hou-ji" class="header-anchor">#</a></h4><p>非类型模板参数的占位符类型最早由 James Touton 和 Michael 提出<br>Spertus 作为 <a href="https://wg21.link/n4469">https://wg21.link/n4469</a> 的一部分。 最终接受的措辞是由<br><a href="https://wg21.link/p0127r2">https://wg21.link/p0127r2</a> 中的 James Touton 和 Michael Spertus。</p><h3><span id="14-kuo-zhan-using-sheng-ming">14  扩展Using声明</span><a href="#14-kuo-zhan-using-sheng-ming" class="header-anchor">#</a></h3><p>使用声明被扩展为允许以逗号分隔的声明列表，以允许它们在包扩展中使用。<br>例如，您现在可以编程：</p><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Base</span> {    <span class="hljs-keyword">public</span>:    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">a</span><span class="hljs-params">()</span></span>;    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">b</span><span class="hljs-params">()</span></span>;    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">c</span><span class="hljs-params">()</span></span>;};<span class="hljs-keyword">class</span> <span class="hljs-title class_">Derived</span> : <span class="hljs-keyword">private</span> Base {    <span class="hljs-keyword">public</span>:    <span class="hljs-keyword">using</span> Base::a, Base::b, Base::c;};</code></pre></div><p>在 C++17 之前，您需要三种不同的 using 声明。</p><h4><span id="14-1-shi-yong-ke-bian-can-shu-using-sheng-ming">14.1 使用可变参数using声明</span><a href="#14-1-shi-yong-ke-bian-can-shu-using-sheng-ming" class="header-anchor">#</a></h4><p>使用逗号分隔的声明提供了从基类的可变参数列表中一般派生所有同类操作的能力。<br>这种技术的一个非常酷的应用是创建一组 lambda 重载。 通过定义以下内容：</p><p> <code>tmpl/overload.hpp</code></p><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-comment">// ”inherit” all function call operators of passed base types:</span><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span>... Ts&gt;<span class="hljs-keyword">struct</span> <span class="hljs-title class_">overload</span> : Ts...{    <span class="hljs-function"><span class="hljs-keyword">using</span> <span class="hljs-title">Ts::operator</span><span class="hljs-params">()</span>...</span>;};<span class="hljs-comment">// base types are deduced from passed arguments:</span><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span>... Ts&gt;</span><span class="hljs-function"><span class="hljs-title">overload</span><span class="hljs-params">(Ts...)</span> -&gt; overload&lt;Ts...&gt;</span>;</code></pre></div><p>您可以重载两个 lambda，如下所示：</p><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">auto</span> twice = overload {    [](std::string&amp; s) { s += s; },    [](<span class="hljs-keyword">auto</span>&amp; v) { v *= <span class="hljs-number">2</span>; }};</code></pre></div><p>这里我们创建了一个类型重载的对象，我们使用推导指南将 lambdas 的类型推导出为模板类型重载的基类，并使用聚合初始化来初始化具有闭包类型的复制构造函数的基类的子对象 ，每个 lambda 都有。<br>然后 using 声明使两个函数调用运算符都可用于类型重载。 如果没有 using 声明，基类将具有同一成员的两个不同重载<br>函数 operator()，这是模棱两可的。<br>因此，您可以传递一个字符串，它调用第一个重载或传递另一个类型，它（假设运算符 *= 有效）使用第二个重载：</p><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-type">int</span> i = <span class="hljs-number">42</span>;<span class="hljs-built_in">twice</span>(i);std::cout &lt;&lt; <span class="hljs-string">"i: "</span> &lt;&lt; i &lt;&lt; <span class="hljs-string">'\n'</span>; <span class="hljs-comment">// prints: 84</span>std::string s = <span class="hljs-string">"hi"</span>;<span class="hljs-built_in">twice</span>(s);std::cout &lt;&lt; <span class="hljs-string">"s: "</span> &lt;&lt; s &lt;&lt; <span class="hljs-string">'\n'</span>; <span class="hljs-comment">// prints: hihi</span></code></pre></div><p>这种技术的一个应用是 std::variant 访问者。</p><h4><span id="14-2-shi-yong-sheng-ming-ji-cheng-gou-zao-han-shu-de-ke-bian-can-shu">14.2 使用声明继承构造函数的可变参数</span><a href="#14-2-shi-yong-sheng-ming-ji-cheng-gou-zao-han-shu-de-ke-bian-can-shu" class="header-anchor">#</a></h4><p>除了对继承构造函数的一些说明外，现在还可以进行以下操作：您可以声明一个可变参数类模板 Multi，该模板派生自其每个传递的类型的基类：</p><p><code>tmpl/using2.hpp </code></p><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">Base</span> {    T value{};    <span class="hljs-keyword">public</span>:    <span class="hljs-built_in">Base</span>() {        ...    }    <span class="hljs-built_in">Base</span>(T v) : value{v} {        ...    }    ...};<span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span>... Types&gt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">Multi</span> : <span class="hljs-keyword">private</span> Base&lt;Types&gt;...{    <span class="hljs-keyword">public</span>:    <span class="hljs-comment">// derive all constructors:</span>    <span class="hljs-keyword">using</span> Base&lt;Types&gt;::Base...;    ...};</code></pre></div><p>使用所有基类构造函数的 using 声明，您可以为每种类型派生一个对应的构造函数.</p><p>现在，当为三种不同类型的值声明 Multi&lt;&gt; 类型时：</p><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">using</span> MultiISB = Multi&lt;<span class="hljs-type">int</span>,std::string,<span class="hljs-type">bool</span>&gt;;</code></pre></div><p>您可以使用每个相应的构造函数来声明对象：</p><div class="code-wrapper"><pre><code class="hljs c++">MultiISB m1 = <span class="hljs-number">42</span>;MultiISB m2 = std::<span class="hljs-built_in">string</span>(<span class="hljs-string">"hello"</span>);MultiISB m3 = <span class="hljs-literal">true</span>;</code></pre></div><p>根据新的语言规则，每次初始化都会为匹配的基类调用相应的构造函数，并为所有其他基类调用默认构造函数。 因此:</p><div class="code-wrapper"><pre><code class="hljs c++">MultiISB m2 = std::<span class="hljs-built_in">string</span>(<span class="hljs-string">"hello"</span>);</code></pre></div><p>调用 Base<int> 的默认构造函数、Base<a href="std::string">std::string</a> 的字符串构造函数和 Base<bool> 的默认构造函数。<br>原则上，您还可以通过指定启用 Multi&lt;&gt; 中的所有赋值运算符：</bool></int></p><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span>... Types&gt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">Multi</span> : <span class="hljs-keyword">private</span> Base&lt;Types&gt;...{    ...    <span class="hljs-comment">// 导出所有赋值运算符:</span>    <span class="hljs-keyword">using</span> Base&lt;Types&gt;::<span class="hljs-keyword">operator</span>=...;}</code></pre></div><h4><span id="14-3-hou-ji">14.3 后记</span><a href="#14-3-hou-ji" class="header-anchor">#</a></h4><p>逗号分隔的 using 声明由 Robert Haberlach 在 <a href="https://wg21.link/p0195r0">https://wg21.link/p0195r0</a> 中提出。 最终接受的措辞由 Robert Haberlach 和 Richard Smith 在 <a href="https://wg21.link/p0195r2">https://wg21.link/p0195r2</a> 中制定。<br>各种核心问题要求对继承构造函数进行澄清。 最终接受的修复它们的措辞由 Richard Smith 在 <a href="https://wg21.link/n4429">https://wg21.link/n4429</a> 中制定。<br>Vicente J. Botet Escriba 提出了一个建议，即添加一个泛型重载函数来重载 lambda，以及普通函数和成员函数。 然而，这篇论文并没有进入 C++17。 有关详细信息，请参阅 <a href="https://wg21.link/p0051r1%E3%80%82">https://wg21.link/p0051r1。</a></p>]]></content>
    
    
    
    <tags>
      
      <tag>C++17</tag>
      
      <tag>Template</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Hello World</title>
    <link href="/2022/03/18/hello-world/"/>
    <url>/2022/03/18/hello-world/</url>
    
    <content type="html"><![CDATA[<div class="toc"><!-- toc --><ul><li><a href="#quick-start">Quick Start</a><ul><li><a href="#create-a-new-post">Create a new post</a></li><li><a href="#run-server">Run server</a></li><li><a href="#generate-static-files">Generate static files</a></li><li><a href="#deploy-to-remote-sites">Deploy to remote sites</a></li></ul></li></ul><!-- tocstop --></div><p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2><span id="quick-start">Quick Start</span><a href="#quick-start" class="header-anchor">#</a></h2><h3><span id="create-a-new-post">Create a new post</span><a href="#create-a-new-post" class="header-anchor">#</a></h3><div class="code-wrapper"><pre><code class="hljs bash">$ hexo new <span class="hljs-string">"My New Post"</span></code></pre></div><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3><span id="run-server">Run server</span><a href="#run-server" class="header-anchor">#</a></h3><div class="code-wrapper"><pre><code class="hljs bash">$ hexo server</code></pre></div><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3><span id="generate-static-files">Generate static files</span><a href="#generate-static-files" class="header-anchor">#</a></h3><div class="code-wrapper"><pre><code class="hljs bash">$ hexo generate</code></pre></div><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3><span id="deploy-to-remote-sites">Deploy to remote sites</span><a href="#deploy-to-remote-sites" class="header-anchor">#</a></h3><div class="code-wrapper"><pre><code class="hljs bash">$ hexo deploy</code></pre></div><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>QT文档翻译</title>
    <link href="/2022/02/23/QT%E6%96%87%E6%A1%A3%E7%BF%BB%E8%AF%91/"/>
    <url>/2022/02/23/QT%E6%96%87%E6%A1%A3%E7%BF%BB%E8%AF%91/</url>
    
    <content type="html"><![CDATA[<div class="toc"><!-- toc --><!-- tocstop --></div><p>此文档来自于👉 <a href="https://github.com/QtDocumentCN/QtDocumentCN">QtDocumentCN/QtDocumentCN: Qt中文文档翻译 (github.com)</a> </p><p>并由本人补充了一些文档</p>]]></content>
    
    
    
    <tags>
      
      <tag>QT</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>左值和右值</title>
    <link href="/2022/02/20/%E5%B7%A6%E5%80%BC%E5%92%8C%E5%8F%B3%E5%80%BC/"/>
    <url>/2022/02/20/%E5%B7%A6%E5%80%BC%E5%92%8C%E5%8F%B3%E5%80%BC/</url>
    
    <content type="html"><![CDATA[<div class="toc"><!-- toc --><!-- tocstop --></div><ol><li><p>左值有地址和值，可以出现在赋值运算符左边或者右边。</p></li><li><p>右值只有值，只能出现在赋值运算符右边。</p></li><li><p>右值只有值，没有地址， 右值是一个优化技巧（C++)，因为右值往往是临时变量的。</p></li><li><p>左值代表另一个值，右值是值本身。</p></li></ol>]]></content>
    
    
    
    <tags>
      
      <tag>C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>并发_并行_同步_异步</title>
    <link href="/2022/02/20/%E5%B9%B6%E5%8F%91-%E5%B9%B6%E8%A1%8C-%E5%90%8C%E6%AD%A5-%E5%BC%82%E6%AD%A5/"/>
    <url>/2022/02/20/%E5%B9%B6%E5%8F%91-%E5%B9%B6%E8%A1%8C-%E5%90%8C%E6%AD%A5-%E5%BC%82%E6%AD%A5/</url>
    
    <content type="html"><![CDATA[<div class="toc"><!-- toc --><!-- tocstop --></div><p>并发：</p><ul><li>​    计算机可以同时执行多个任务；单核处理器可以通过分配时间片的方式 单线程</li></ul><p>并行：</p><ul><li>针对多核处理器，不用用过分配时间片方式执行任务，少了线程的上下文切换</li></ul><p>同步：</p><ul><li>上一个任务执行完毕后才可以进行下一个任务，所以没有并发和并行概念 多线程同步（资源争抢）</li></ul><p>异步：</p><ul><li><p>不同任务不会相互等待，执行任务A时也可以在执行任务B，当任务A没有算出结果时，不会呆呆的等A，而是会去执行B，也有可能也同时执行C，D…，等未来的某个时间A的结果返回也没问题。</p></li><li><ol><li>同步里面没有并行和异步的概念，异步是一种任务执行序列，其应用可以在多线程并行、单线程并发</li></ol></li><li><ol start="2"><li>多线程的应用场景下，如果有资源竞争的情况，适合使用异步（单线程）</li></ol></li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Visual_Studio_2022_PRE添加OpenCV库</title>
    <link href="/2022/02/19/Visual-Studio-2022-PRE%E6%B7%BB%E5%8A%A0OpenCV%E5%BA%93/"/>
    <url>/2022/02/19/Visual-Studio-2022-PRE%E6%B7%BB%E5%8A%A0OpenCV%E5%BA%93/</url>
    
    <content type="html"><![CDATA[<div class="toc"><!-- toc --><ul><li><a href="#1-chuang-jian-yi-ge-xin-gong-cheng">1. 创建一个新工程</a></li><li><a href="#2-chuang-jian-wan-gong-cheng-hou-qie-dao-shu-xing-guan-li-qi">2. 创建完工程后切到属性管理器</a></li><li><a href="#3-tian-jia-xin-xiang-mu-shu-xing-lie-biao">3. 添加新项目属性列表</a></li><li><a href="#4-tian-jia-ku-tou-wen-jian-lu-jing-he-ku-wen-jian-lu-jing">4. 添加库头文件路径和库文件路径</a></li><li><a href="#5-tian-xie-yao-shi-yong-de-ku-wen-jian-ming">5. 填写要使用的库文件名</a></li></ul><!-- tocstop --></div><p>此篇是VS添加OpenCV库教程</p><h1><span id="1-chuang-jian-yi-ge-xin-gong-cheng">1. 创建一个新工程</span><a href="#1-chuang-jian-yi-ge-xin-gong-cheng" class="header-anchor">#</a></h1><p><img src="https://gitee.com/txt1994/images/raw/master/img/opencv/visual_studio_opencv_1.jpg" alt="img"></p><p><img src="https://gitee.com/txt1994/images/raw/master/img/opencv/visual_studio_opencv_2.jpg" alt="img"></p><h1><span id="2-chuang-jian-wan-gong-cheng-hou-qie-dao-shu-xing-guan-li-qi">2. 创建完工程后切到属性管理器</span><a href="#2-chuang-jian-wan-gong-cheng-hou-qie-dao-shu-xing-guan-li-qi" class="header-anchor">#</a></h1><p><img src="https://gitee.com/txt1994/images/raw/master/img/opencv/visual_studio_opencv_3.jpg" alt="img"></p><h1><span id="3-tian-jia-xin-xiang-mu-shu-xing-lie-biao">3. 添加新项目属性列表</span><a href="#3-tian-jia-xin-xiang-mu-shu-xing-lie-biao" class="header-anchor">#</a></h1><p>然后切到<code>Debug | x64</code>添加新项目属性列表(P)<br><img src="https://gitee.com/txt1994/images/raw/master/img/opencv/visual_studio_opencv_4.jpg" alt="img"></p><p>然后双击新建的文件。</p><h1><span id="4-tian-jia-ku-tou-wen-jian-lu-jing-he-ku-wen-jian-lu-jing">4. 添加库头文件路径和库文件路径</span><a href="#4-tian-jia-ku-tou-wen-jian-lu-jing-he-ku-wen-jian-lu-jing" class="header-anchor">#</a></h1><p>添加库头文件路径<br><img src="https://gitee.com/txt1994/images/raw/master/img/opencv/visual_studio_opencv_5.jpg" alt="img"><br><img src="https://gitee.com/txt1994/images/raw/master/img/opencv/visual_studio_opencv_6.jpg" alt="img"></p><p>添加库文件路径</p><p><img src="https://gitee.com/txt1994/images/raw/master/img/opencv/visual_studio_opencv_7.jpg" alt="img"></p><h1><span id="5-tian-xie-yao-shi-yong-de-ku-wen-jian-ming">5. 填写要使用的库文件名</span><a href="#5-tian-xie-yao-shi-yong-de-ku-wen-jian-ming" class="header-anchor">#</a></h1><p><img src="https://gitee.com/txt1994/images/raw/master/img/opencv/visual_studio_opencv_8.jpg" alt="img"></p><p>这里使用debug版</p><p>End.</p>]]></content>
    
    
    
    <tags>
      
      <tag>OpenCV</tag>
      
      <tag>VS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>cmake编译opencv及Clion使用</title>
    <link href="/2022/02/15/cmake%E7%BC%96%E8%AF%91opencv%E5%8F%8AClion%E4%BD%BF%E7%94%A8/"/>
    <url>/2022/02/15/cmake%E7%BC%96%E8%AF%91opencv%E5%8F%8AClion%E4%BD%BF%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<div class="toc"><!-- toc --><ul><li><a href="#1-xia-zai-opencv-yuan-ma">1. 下载OpenCV源码</a></li><li><a href="#2-bian-yi-opencv-yuan-ma">2. 编译OpenCV源码</a></li><li><a href="#3-hou-xu-pei-zhi">3. 后续配置</a></li></ul><!-- tocstop --></div><p>采用了linux下编译OpenCV, Visual Studio 2022, QT6.2.3都不成功。</p><p>最终采用在win下编译OpenCV + Clion成功，此文记录踩下的坑。</p><h1><span id="1-xia-zai-opencv-yuan-ma">1. 下载OpenCV源码</span><a href="#1-xia-zai-opencv-yuan-ma" class="header-anchor">#</a></h1><p>源码地址👇</p><p>Github:</p><p><code>https://github.com/opencv/opencv/archive/4.5.5.zip</code></p><h1><span id="2-bian-yi-opencv-yuan-ma">2. 编译OpenCV源码</span><a href="#2-bian-yi-opencv-yuan-ma" class="header-anchor">#</a></h1><ol><li>解压文件夹</li></ol><p> <img src="https://gitee.com/txt1994/images/raw/master/img/opencv/opencv_1.jpg" alt="OpenCV源码"><br>解压win下exe文件解压后由两个文件夹，source为源码目录<br><img src="https://gitee.com/txt1994/images/raw/master/img/opencv/opencv_2.jpg" alt="OpenCV源码"> </p><p><code>build</code>为已经建好的库文件目录</p><p><img src="https://gitee.com/txt1994/images/raw/master/img/opencv/opencv_3.jpg" alt="OpenCV源码"> </p><ol start="2"><li><p>CMake-gui工具构建</p><p><img src="https://gitee.com/txt1994/images/raw/master/img/opencv/opencv_4.jpg" alt="OpenCV源码"></p></li></ol><ul><li><ol><li><code>source code</code>选择带有源码的目录，<code>binaries</code>选择一个新创建一个mingw-build目录，然后点击<code>Configure</code>，弹出的窗口选择<code>MinGW Makefiles</code>,第一次可能会失败，失败后再点击<code>Configure</code>，还不行的百度吧。</li></ol></li><li><ol start="2"><li>配置成功后点击<code>Generate</code></li></ol></li><li><ol start="3"><li>cd到<code>mingw-bulid</code>目录执行<code>mingw32-make -j8</code>,根据自己机器性能设置线程数，这里设置8个线程，编译时间较久，等待完成。</li></ol></li><li><ol start="4"><li>然后执行<code>mingw32-make install</code>生成库，在<code>mingw-build</code>生成<code>install</code>保存了生成库库文件和头文件。</li></ol></li></ul><h1><span id="3-hou-xu-pei-zhi">3. 后续配置</span><a href="#3-hou-xu-pei-zhi" class="header-anchor">#</a></h1><p>把<code>C:\\Users\\用户名\\Downloads\\opencv\\mingw-build\\install\\x64\\mingw\\bin</code>路径添加到win的环境变量</p><p>👇此为一个CMakeLists.txt</p><div class="code-wrapper"><pre><code class="hljs cmake"><span class="hljs-keyword">cmake_minimum_required</span>(VERSION <span class="hljs-number">3.19</span>)<span class="hljs-keyword">project</span>(opencv_learn)<span class="hljs-keyword">set</span>(CMAKE_CXX_STANDARD <span class="hljs-number">20</span>)<span class="hljs-keyword">include_directories</span>($ENV{CMAKE_INCLUDE_PATH})<span class="hljs-keyword">set</span>(OpenCV_DIR C:\\Users\\用户名\\Downloads\\opencv\\mingw-build\\<span class="hljs-keyword">install</span>\\x64\\mingw\\bin)<span class="hljs-comment">#需要的openCV库</span><span class="hljs-keyword">FIND_PACKAGE</span>(OpenCV REQUIRED)<span class="hljs-comment">#显示OpenCV的版本号</span><span class="hljs-keyword">MESSAGE</span>(<span class="hljs-string">"OpenCV version : ${OpenCV_VERSION}"</span>)<span class="hljs-keyword">MESSAGE</span>(<span class="hljs-string">"OpenCV include : ${OpenCV_INCLUDE_DIRS}"</span>)<span class="hljs-keyword">MESSAGE</span>(<span class="hljs-string">"OpenCV libs11 : ${OpenCV_LIBS}"</span>)<span class="hljs-keyword">MESSAGE</span>(<span class="hljs-string">"OpenCV DIR : ${OpenCV_DIR}"</span>)<span class="hljs-keyword">include_directories</span>(<span class="hljs-variable">${OpenCV_INCLUDE_DIRS}</span>)<span class="hljs-keyword">link_directories</span>(<span class="hljs-variable">${OpenCV_LIBS}</span>)<span class="hljs-keyword">MESSAGE</span>(<span class="hljs-string">"OpenCV libs : ${OpenCV_LIBS}"</span>)<span class="hljs-keyword">include_directories</span>(<span class="hljs-variable">${OpenCV_INCLUDE_DIRS}</span>)<span class="hljs-keyword">link_directories</span>(<span class="hljs-variable">${OpenCV_LIBS}</span>)<span class="hljs-keyword">set</span>(SOURCE main.cpp)<span class="hljs-comment"># 将源代码添加到此项目的可执行文件。</span><span class="hljs-keyword">add_executable</span> (<span class="hljs-variable">${PROJECT_NAME}</span> <span class="hljs-variable">${SOURCE}</span>)<span class="hljs-keyword">TARGET_LINK_LIBRARIES</span>(<span class="hljs-variable">${PROJECT_NAME}</span> <span class="hljs-variable">${OpenCV_LIBS}</span>)</code></pre></div>]]></content>
    
    
    
    <tags>
      
      <tag>C++</tag>
      
      <tag>OpenCV</tag>
      
      <tag>Clion</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C++计时器</title>
    <link href="/2022/02/10/C++%E8%AE%A1%E6%97%B6%E5%99%A8/"/>
    <url>/2022/02/10/C++%E8%AE%A1%E6%97%B6%E5%99%A8/</url>
    
    <content type="html"><![CDATA[<p>此文来自于👉由UP主神经元猫 <a href="https://space.bilibili.com/364152971">神经元猫的个人空间_哔哩哔哩_bilibili</a> 翻译 <a href="https://www.bilibili.com/video/BV1Z5411P7gT?spm_id_from=333.999.0.0">【63】【Cherno C++】【中字】C++的计时_哔哩哔哩_bilibili</a> ，并由我整理。</p><div class="toc"><!-- toc --><!-- tocstop --></div><p>C++计时器</p><blockquote><p>std::chrono::high_resolution_clock高分辨率时钟在不同标准库有所区别，尽量不要使用。</p></blockquote><ul><li>对时长度量使用 steady_clock </li><li>对壁钟时间使用 system_clock 。</li></ul><p>基础计时器</p><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;chrono&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;thread&gt;</span></span><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span></span><span class="hljs-function"></span>{        <span class="hljs-keyword">auto</span> start = std::chrono::steady_clock::<span class="hljs-built_in">now</span>();    std::this_thread::<span class="hljs-built_in">sleep_for</span>(std::chrono::<span class="hljs-built_in">seconds</span>(<span class="hljs-number">1</span>));    <span class="hljs-keyword">auto</span> end = std::chrono::steady_clock::<span class="hljs-built_in">now</span>();        std::chrono::duration&lt;<span class="hljs-type">float</span>&gt; time = end - start;    std::cout &lt;&lt; time.<span class="hljs-built_in">count</span>() &lt;&lt; <span class="hljs-string">"s \n"</span>;     std::cin.<span class="hljs-built_in">get</span>();}</code></pre></div><p>计算打印<code>hello</code>用时</p><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Timer</span>{    std::chrono::time_point&lt;std::chrono::steady_clock&gt; start, end;    std::chrono::duration&lt;<span class="hljs-type">float</span>&gt; duration;    <span class="hljs-built_in">Timer</span>()    {        start = std::chrono::steady_clock::<span class="hljs-built_in">now</span>();    }    ~<span class="hljs-built_in">Timer</span>()    {        end = std::chrono::steady_clock::<span class="hljs-built_in">now</span>();        duration = end - start;        <span class="hljs-type">float</span> ms = duration.<span class="hljs-built_in">count</span>() * <span class="hljs-number">1000.0f</span>;        std::cout &lt;&lt; <span class="hljs-string">"Timer took "</span> &lt;&lt; ms &lt;&lt; <span class="hljs-string">"ms \n"</span>;    }};<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Function</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>{    Timer timer; <span class="hljs-comment">// 计算此函数生命周期耗时</span>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">100</span>; i++)        std::cout &lt;&lt; <span class="hljs-string">"Hello\n"</span>;}</code></pre></div>]]></content>
    
    
    
    <tags>
      
      <tag>C++</tag>
      
      <tag>Timer</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>让字符串及字符操作更加快速</title>
    <link href="/2022/02/07/%E8%AE%A9%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8F%8A%E5%AD%97%E7%AC%A6%E6%93%8D%E4%BD%9C%E6%9B%B4%E5%8A%A0%E5%BF%AB%E9%80%9F/"/>
    <url>/2022/02/07/%E8%AE%A9%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8F%8A%E5%AD%97%E7%AC%A6%E6%93%8D%E4%BD%9C%E6%9B%B4%E5%8A%A0%E5%BF%AB%E9%80%9F/</url>
    
    <content type="html"><![CDATA[<div class="toc"><!-- toc --><!-- tocstop --></div><p>视频由up神经元猫 <a href="https://space.bilibili.com/364152971?from=search&amp;seid=13878555076785526167&amp;spm_id_from=333.337.0.0">神经元猫的个人空间_哔哩哔哩_bilibili</a> 翻译自 <a href="https://youtube.com/cherno">youtube.com/cherno</a>  并发布到👉  <a href="https://www.bilibili.com/video/BV1YR4y1j7R3?from=search&amp;seid=12951915106297778311&amp;spm_id_from=333.337.0.0">【80】【Cherno C++】【中字】如何让C++字符串更快_哔哩哔哩_bilibili</a> 并由我整理。</p><p>此本不会讲解为什么std::string会很慢和其背后的细节，只有些例子。</p><p>std::string的主要问题之一是 <strong>字符串格式化及字符串操作</strong> 时需要分配内存</p><p>bad例子：</p><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span><span class="hljs-type">static</span> <span class="hljs-type">uint32_t</span> s_AllocCount = <span class="hljs-number">0</span>;<span class="hljs-comment">// 查看分配多少次内存和如何跟踪这些内存，需要重载new操作符</span><span class="hljs-function"><span class="hljs-type">void</span>* <span class="hljs-keyword">operator</span> <span class="hljs-title">new</span><span class="hljs-params">(<span class="hljs-type">size_t</span> size)</span> </span>{    s_AllocCount++;    std::cout &lt;&lt; <span class="hljs-string">"allocating: "</span> &lt;&lt; size &lt;&lt; <span class="hljs-string">" bytes\n"</span>;    <span class="hljs-keyword">return</span> <span class="hljs-built_in">malloc</span>(size);}<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">PrintName</span><span class="hljs-params">(<span class="hljs-type">const</span> std::string&amp; name)</span> </span>{    std::cout &lt;&lt; name &lt;&lt; <span class="hljs-string">'\n'</span>;}    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span> </span>{    std::string name = <span class="hljs-string">"Yan Chernikov"</span>;        std::string firstname = name.<span class="hljs-built_in">substr</span>(<span class="hljs-number">0</span>, <span class="hljs-number">3</span>);    std::string lasttname = name.<span class="hljs-built_in">substr</span>(<span class="hljs-number">4</span>, <span class="hljs-number">9</span>);    <span class="hljs-built_in">PrintName</span>(firstname);        std::cout &lt;&lt; s_AllocCount &lt;&lt; <span class="hljs-string">" allocations"</span> &lt;&lt; <span class="hljs-string">'\n'</span>;    std::cin.<span class="hljs-built_in">get</span>();}</code></pre></div><p><code>std::string_views</code>, 它本质上是一个指向内存的指针，就是const char指针，指向其他人拥有的现有字符串，再加上一个size；</p><ul><li>比如一个字符串 “hello world”,有一个指向第一个字符(h)的指针,大小是3</li><li>再比如有一个指针指向<code>h</code>的指针，大小是4个字节，把我带到那个lastname的开头，大小是9</li></ul><blockquote><p>这是在创建一个进入现有内存的小视窗，而不是分配一个新的字符串用substr()创建一个新的字符串，</p><p>我想要的是一个窗口的视图，到一个已有自己内存的字符串</p></blockquote><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span><span class="hljs-type">static</span> <span class="hljs-type">uint32_t</span> s_AllocCount = <span class="hljs-number">0</span>;<span class="hljs-comment">// 查看分配多少次内存和如何跟踪这些内存，需要重载new操作符</span><span class="hljs-function"><span class="hljs-type">void</span>* <span class="hljs-keyword">operator</span> <span class="hljs-title">new</span><span class="hljs-params">(<span class="hljs-type">size_t</span> size)</span> </span>{    s_AllocCount++;    std::cout &lt;&lt; <span class="hljs-string">"allocating: "</span> &lt;&lt; size &lt;&lt; <span class="hljs-string">" bytes\n"</span>;    <span class="hljs-keyword">return</span> <span class="hljs-built_in">malloc</span>(size);}<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">PrintName</span><span class="hljs-params">(std::string_virew name)</span> </span>{    std::cout &lt;&lt; name &lt;&lt; <span class="hljs-string">'\n'</span>;}    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span> </span>{    std::string name = <span class="hljs-string">"Yan Chernikov"</span>;        <span class="hljs-function">std::string_view <span class="hljs-title">firstname</span><span class="hljs-params">(name.c_str(), <span class="hljs-number">3</span>)</span></span>;    <span class="hljs-function">std::string_view <span class="hljs-title">firstname</span><span class="hljs-params">(name.c_str() + <span class="hljs-number">4</span>, <span class="hljs-number">9</span>)</span></span>;    <span class="hljs-built_in">PrintName</span>(firstname);        std::cout &lt;&lt; s_AllocCount &lt;&lt; <span class="hljs-string">" allocations"</span> &lt;&lt; <span class="hljs-string">'\n'</span>;    std::cin.<span class="hljs-built_in">get</span>();}</code></pre></div>]]></content>
    
    
    
    <tags>
      
      <tag>C++17</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>让C++程序更快的运行</title>
    <link href="/2022/02/06/%E8%AE%A9C-%E7%A8%8B%E5%BA%8F%E6%9B%B4%E5%BF%AB%E7%9A%84%E8%BF%90%E8%A1%8C/"/>
    <url>/2022/02/06/%E8%AE%A9C-%E7%A8%8B%E5%BA%8F%E6%9B%B4%E5%BF%AB%E7%9A%84%E8%BF%90%E8%A1%8C/</url>
    
    <content type="html"><![CDATA[<div class="toc"><!-- toc --><!-- tocstop --></div><p>视频由up神经元猫 <a href="https://space.bilibili.com/364152971?from=search&amp;seid=13878555076785526167&amp;spm_id_from=333.337.0.0">神经元猫的个人空间_哔哩哔哩_bilibili</a> 翻译自 <a href="https://youtube.com/cherno">youtube.com/cherno</a>  并发布到👉 <a href="https://www.bilibili.com/video/BV1UR4y1j7YL?spm_id_from=333.999.0.0">【79】【Cherno C++】【中字】如何让C++运行得更快_哔哩哔哩_bilibili</a> 并由我整理。</p><ul><li><p><strong>通过编码方式利用多核或多处理器</strong> ,利用这些线程，不只是让你的程序顺序执行一条条指令，而是把一些东西，推迟到不同的线程，甚至不是推迟，二十把东西分派到不同的线程，让计算机更快地处理这些东西。</p></li><li><p>每一个资源，每一个纹理模型，他们通常独立于彼此，意味着这是良好的多线程候选场景。</p></li></ul><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-type">static</span> std::mutex s_MeshesMutex;<span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title">LoadMesh</span><span class="hljs-params">(std::vector&lt;Ref&lt;Mesh&gt;&gt;* meshes, std::string filepath)</span></span><span class="hljs-function"></span>{    <span class="hljs-keyword">auto</span> mesh = Mesh::<span class="hljs-built_in">Load</span>(filepath);        <span class="hljs-function">std::lock_guard&lt;std::mutex&gt; <span class="hljs-title">lock</span><span class="hljs-params">(s_MeshesMutex)</span></span>;    meshes.<span class="hljs-built_in">push_back</span>(mesh);}<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">EditLayer::LoadMeshes</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>{    <span class="hljs-function">std::ifstream <span class="hljs-title">stream</span><span class="hljs-params">(<span class="hljs-string">"src/Models.txt"</span>)</span></span>;    std::string line;    std::vector&lt;std::string&gt; meshFilepaths;    <span class="hljs-keyword">while</span> (std::<span class="hljs-built_in">getline</span>(stream, line))        meshFilepaths.<span class="hljs-built_in">push_back</span>(line);    <span class="hljs-meta">#<span class="hljs-keyword">define</span> ASYNC 1</span><span class="hljs-meta">#id ASYNC</span>    <span class="hljs-keyword">for</span> (<span class="hljs-type">const</span> <span class="hljs-keyword">auto</span>&amp; file : meshFilepaths)        <span class="hljs-comment">// std::launch::async告知std库创建一个线程处理。</span>        <span class="hljs-comment">// 我们需要保留std::async的返回值，如果不保留的话，因为它会被C++标准库摧毁，在摧毁时，标准库需要确保过程实际已被完成，这基本不是并行了，所以需要创建一个std::future的向量。</span>        m_Futures.<span class="hljs-built_in">push_back</span>(std::<span class="hljs-built_in">async</span>(std::launch::async, LoadMesh, &amp;m_Meshes, file));<span class="hljs-meta">#<span class="hljs-keyword">else</span> </span>    <span class="hljs-keyword">for</span> (<span class="hljs-type">const</span> <span class="hljs-keyword">auto</span>&amp; file : meshFilepaths)        m_Meshes.<span class="hljs-built_in">push_back</span>(Mesh::<span class="hljs-built_in">Load</span>(file));}std::vector&lt;std::future&lt;<span class="hljs-type">void</span>&gt; m_Meshes;</code></pre></div><p>通过把任务分派的不同的线程，资源加载速度由<code>6.3s</code>,缩减到<code>600ms</code>，速度快了10倍。</p><p>End.</p>]]></content>
    
    
    
    <tags>
      
      <tag>C++11</tag>
      
      <tag>Thread</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>qt添加第三方库方法</title>
    <link href="/2022/02/03/qt%E6%B7%BB%E5%8A%A0%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93%E6%96%B9%E6%B3%95/"/>
    <url>/2022/02/03/qt%E6%B7%BB%E5%8A%A0%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93%E6%96%B9%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<div class="toc"><!-- toc --><ul><li><a href="#tian-jia-ku">添加库</a></li></ul><!-- tocstop --></div><p>qt添加第三方库方法</p><h2><span id="tian-jia-ku">添加库</span><a href="#tian-jia-ku" class="header-anchor">#</a></h2><ol><li><p>选择项目名右击</p></li><li><p>选择添加库</p></li></ol><p> <img src="https://gitee.com/txt1994/images/raw/master/img/QT/libs_1.jpg"> </p><ol start="3"><li>选择外部库，下一步</li></ol><p><img src="https://gitee.com/txt1994/images/raw/master/img/QT/libs_2.jpg"></p><ol start="4"><li>库文件填写<code>库文件路径和库名字</code>，包含路径是库头文件路径，平台<code>选择一个或全部选择</code>，链接选择<code>动态</code>，点击下一步</li></ol><p><img src="https://gitee.com/txt1994/images/raw/master/img/QT/libs_3.jpg"></p><ol start="5"><li>汇总将会显示添加到<code>.pro</code>文件中，在项目中可以添加头文件使用此库了<br><img src="https://gitee.com/txt1994/images/raw/master/img/QT/libs_4.jpg"></li></ol>]]></content>
    
    
    
    <tags>
      
      <tag>QT</tag>
      
      <tag>Lib</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>qt中ui简单介绍</title>
    <link href="/2022/02/02/qt%E4%B8%ADui%E7%AE%80%E5%8D%95%E4%BB%8B%E7%BB%8D/"/>
    <url>/2022/02/02/qt%E4%B8%ADui%E7%AE%80%E5%8D%95%E4%BB%8B%E7%BB%8D/</url>
    
    <content type="html"><![CDATA[<div class="toc"><!-- toc --><!-- tocstop --></div><p>qt ui区别：</p><ol><li>无ui的mainWindow.h</li></ol><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">ifndef</span> MAINWINDOW_H</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> MAINWINDOW_H</span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;QMainWindow&gt;</span></span><span class="hljs-keyword">class</span> <span class="hljs-title class_">MainWindow</span> : <span class="hljs-keyword">public</span> QMainWindow{    Q_OBJECT<span class="hljs-keyword">public</span>:    <span class="hljs-built_in">MainWindow</span>(QWidget *parent = <span class="hljs-literal">nullptr</span>);    ~<span class="hljs-built_in">MainWindow</span>();};<span class="hljs-meta">#<span class="hljs-keyword">endif</span> <span class="hljs-comment">// MAINWINDOW_H</span></span></code></pre></div><ol start="2"><li>有ui的mainWindow.h</li></ol><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">ifndef</span> MAINWINDOW_H</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> MAINWINDOW_H</span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;QMainWindow&gt;</span></span>QT_BEGIN_NAMESPACE<span class="hljs-keyword">namespace</span> Ui { <span class="hljs-keyword">class</span> <span class="hljs-title class_">MainWindow</span>; }QT_END_NAMESPACE<span class="hljs-comment">// 这个MainWindow和下边的MainWindow没有关系，在不同命名空间内。</span>    <span class="hljs-keyword">class</span> <span class="hljs-title class_">MainWindow</span> : <span class="hljs-keyword">public</span> QMainWindow{    Q_OBJECT<span class="hljs-keyword">public</span>:    <span class="hljs-built_in">MainWindow</span>(QWidget *parent = <span class="hljs-literal">nullptr</span>);    ~<span class="hljs-built_in">MainWindow</span>();<span class="hljs-keyword">private</span>:    Ui::MainWindow *ui;<span class="hljs-comment">// ui的指针</span>};<span class="hljs-meta">#<span class="hljs-keyword">endif</span> <span class="hljs-comment">// MAINWINDOW_H</span></span></code></pre></div><ol start="3"><li>无ui的mainWindow.cpp</li></ol><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">"mainwindow.h"</span></span>MainWindow::<span class="hljs-built_in">MainWindow</span>(QWidget *parent)    : <span class="hljs-built_in">QMainWindow</span>(parent){}MainWindow::~<span class="hljs-built_in">MainWindow</span>(){}</code></pre></div><ol start="4"><li>有ui的mainWindow.cpp<div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">"mainwindow.h"</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">"./ui_mainwindow.h"</span></span>MainWindow::<span class="hljs-built_in">MainWindow</span>(QWidget *parent)    : <span class="hljs-built_in">QMainWindow</span>(parent)    , <span class="hljs-built_in">ui</span>(<span class="hljs-keyword">new</span> Ui::MainWindow)<span class="hljs-comment">// 实例化ui指针</span>{    ui-&gt;<span class="hljs-built_in">setupUi</span>(<span class="hljs-keyword">this</span>);<span class="hljs-comment">// 设置ui指针</span>}MainWindow::~<span class="hljs-built_in">MainWindow</span>(){    <span class="hljs-keyword">delete</span> ui;<span class="hljs-comment">// 删除ui指针</span>}</code></pre></div></li></ol><p>qt的ui文件实质是xml文件：👇</p><p><img src="https://gitee.com/txt1994/images/raw/master/img/QT/qt-ui.png" alt="qt的ui文件"> </p><ol start="5"><li>main.cpp</li></ol><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">"mainwindow.h"</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;QApplication&gt;</span></span><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> *argv[])</span></span><span class="hljs-function"></span>{    <span class="hljs-function">QApplication <span class="hljs-title">a</span><span class="hljs-params">(argc, argv)</span></span>;    MainWindow w;<span class="hljs-comment">// 实例化mainWindow.h中的类MainWindow</span>    w.<span class="hljs-built_in">show</span>();<span class="hljs-comment">// 类MainWindow继承于QMainWindow，所以可以调用show()</span>    <span class="hljs-keyword">return</span> a.<span class="hljs-built_in">exec</span>();}</code></pre></div>]]></content>
    
    
    
    <tags>
      
      <tag>XML</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Qt概述</title>
    <link href="/2022/02/01/Qt%E6%A6%82%E8%BF%B0/"/>
    <url>/2022/02/01/Qt%E6%A6%82%E8%BF%B0/</url>
    
    <content type="html"><![CDATA[<div class="toc"><!-- toc --><ul><li><a href="#1-qt-gai-shu">1. Qt概述</a><ul><li><a href="#1-1-shi-me-shi-qt">1.1 什么是Qt</a></li><li><a href="#1-2-qt-de-fa-zhan-shi">1.2 Qt的发展史</a></li><li><a href="#1-3-zhi-chi-de-ping-tai">1.3 支持的平台</a></li><li><a href="#1-4-qt-ban-ben">1.4 Qt版本</a></li><li><a href="#1-5-qt-de-xia-zai-yu-an-zhuang">1.5 Qt的下载与安装</a><ul><li><a href="#xia-zai-di-zhi">下载地址：</a></li><li><a href="#linux-host">Linux Host</a></li><li><a href="#os-x-host">OS X Host</a></li><li><a href="#windows-host">Windows Host</a></li><li><a href="#an-zhuang">安装</a></li></ul></li><li><a href="#1-6-qt-de-you-dian">1.6 Qt的优点</a></li><li><a href="#1-7-cheng-gong-an-li">1.7 成功案例</a></li></ul></li><li><a href="#2-chuang-jian-qt-xiang-mu"><strong>2</strong> 创建Qt项目</a><ul><li><a href="#2-1-shi-yong-xiang-dao-chuang-jian">2.1 使用向导创建</a></li><li><a href="#2-2-shou-dong-chuang-jian"><strong>2.2</strong> 手动创建</a></li><li><a href="#2-3-pro-wen-jian"><strong>2.3</strong> .pro文件</a></li><li><a href="#2-4-yi-ge-zui-jian-dan-de-qt-ying-yong-cheng-xu"><strong>2.4</strong> 一个最简单的Qt应用程序</a></li></ul></li><li><a href="#3-di-yi-ge-qt-xiao-cheng-xu">3 第一个Qt小程序</a><ul><li><a href="#3-1-an-niu-de-chuang-jian">3.1 按钮的创建</a></li><li><a href="#3-2-dui-xiang-mo-xing-dui-xiang-shu">3.2 对象模型（对象树）</a></li><li><a href="#3-3-qt-chuang-kou-zuo-biao-ti-xi">3.3 Qt窗口坐标体系</a></li></ul></li><li><a href="#4-xin-hao-he-cao-ji-zhi">4 信号和槽机制</a><ul><li><a href="#4-1-xi-tong-zi-dai-de-xin-hao-he-cao">4.1 系统自带的信号和槽</a></li><li><a href="#4-2-zi-ding-yi-xin-hao-he-cao">4.2 自定义信号和槽</a></li><li><a href="#4-3-xin-hao-cao-de-tuo-zhan">4.3信号槽的拓展</a></li><li><a href="#4-4-qt4-ban-ben-de-xin-hao-cao-xie-fa">4.4 Qt4版本的信号槽写法</a></li><li><a href="#4-5-lambda-biao-da-shi">4.5 Lambda表达式</a></li></ul></li><li><a href="#5-qmainwindow">5 QMainWindow</a><ul><li><a href="#5-1-cai-dan-lan">5.1 菜单栏</a></li><li><a href="#5-2-gong-ju-lan">5.2 工具栏</a></li><li><a href="#5-3-zhuang-tai-lan">5.3 状态栏</a></li><li><a href="#5-4-liu-jie-bu-jian">5.4 铆接部件</a></li><li><a href="#5-5-he-xin-bu-jian-zhong-xin-bu-jian">5.5 核心部件（中心部件）</a></li><li><a href="#5-6-zi-yuan-wen-jian">5.6 资源文件</a></li></ul></li><li><a href="#6-dui-hua-kuang-qdialog">6 对话框QDialog</a><ul><li><a href="#6-1-ji-ben-gai-nian">6.1 基本概念</a></li><li><a href="#6-2-biao-zhun-dui-hua-kuang">6.2 标准对话框</a></li><li><a href="#6-3-zi-ding-yi-xiao-xi-kuang">6.3 自定义消息框</a></li><li><a href="#6-4-xiao-xi-dui-hua-kuang">6.4 消息对话框</a></li><li><a href="#6-5-biao-zhun-wen-jian-dui-hua-kuang">6.5 标准文件对话框</a></li></ul></li><li><a href="#7-bu-ju-guan-li-qi">7 布局管理器</a><ul><li><a href="#7-1-xi-tong-ti-gong-de-bu-ju-kong-jian">7.1 系统提供的布局控件</a></li><li><a href="#7-2-li-yong-widget-zuo-bu-ju">7.2 利用widget做布局</a></li></ul></li><li><a href="#8-chang-yong-kong-jian">8 常用控件</a><ul><li><a href="#8-1-qlabel-kong-jian-shi-yong">8.1 QLabel控件使用</a><ul><li><a href="#xian-shi-wen-zi-pu-tong-wen-ben-html">显示文字 （普通文本、html）</a></li><li><a href="#xian-shi-tu-pian">显示图片</a></li><li><a href="#xian-shi-dong-hua">显示动画</a></li></ul></li><li><a href="#8-2-qlineedit">8.2 QLineEdit</a></li><li><a href="#8-3-qi-ta-kong-jian">8.3 其他控件</a></li><li><a href="#8-4-zi-ding-yi-kong-jian">8.4 自定义控件</a></li></ul></li><li><a href="#9-qt-xiao-xi-ji-zhi-he-shi-jian">9 Qt消息机制和事件</a><ul><li><a href="#9-1-shi-jian">9.1 事件</a></li><li><a href="#9-2-event">9.2 event（）</a></li><li><a href="#9-3-shi-jian-guo-lu-qi">9.3 事件过滤器</a></li><li><a href="#9-4-zong-jie">9.4 总结</a></li></ul></li><li><a href="#10-hui-tu-he-hui-tu-she-bei">10 绘图和绘图设备</a><ul><li><a href="#10-1-qpainter">10.1 QPainter</a></li><li><a href="#10-2-hui-tu-she-bei">10.2 绘图设备</a><ul><li><a href="#10-2-1-qpixmap-qbitmap-qimage">10.2.1 QPixmap、QBitmap、QImage</a></li><li><a href="#10-2-2-qpicture">10.2.2 QPicture</a></li></ul></li></ul></li><li><a href="#11-wen-jian-xi-tong">11 文件系统</a><ul><li><a href="#11-1-ji-ben-wen-jian-cao-zuo">11.1 基本文件操作</a></li><li><a href="#11-2-er-jin-zhi-wen-jian-du-xie">11.2 二进制文件读写</a></li><li><a href="#11-3-wen-ben-wen-jian-du-xie">11.3 文本文件读写</a></li></ul></li></ul><!-- tocstop --></div><h1><span id="1-qt-gai-shu">1. Qt概述</span><a href="#1-qt-gai-shu" class="header-anchor">#</a></h1><h2><span id="1-1-shi-me-shi-qt">1.1 什么是Qt</span><a href="#1-1-shi-me-shi-qt" class="header-anchor">#</a></h2><p>Qt是一个跨平台的C++图形用户界面应用程序框架。它为应用程序开发者提供建立艺术级图形界面所需的所有功能。它是完全面向对象的，很容易扩展，并且允许真正的组件编程。</p><h2><span id="1-2-qt-de-fa-zhan-shi">1.2 Qt的发展史</span><a href="#1-2-qt-de-fa-zhan-shi" class="header-anchor">#</a></h2><p>1991年 Qt最早由奇趣科技开发</p><p>1996年 进入商业领域，它也是目前流行的Linux桌面环境KDE的基础</p><p>2008年 奇趣科技被诺基亚公司收购，Qt称为诺基亚旗下的编程语言</p><p>2012年 Qt又被Digia公司收购</p><p>2014年4月 跨平台的集成开发环境Qt Creator3.1.0发布，同年5月20日配发了Qt5.3正式版，至此Qt实现了对iOS、Android、WP等各平台的全面支持。</p><p>截至2022年1月31日Qt最新版本为 6.2.3</p><h2><span id="1-3-zhi-chi-de-ping-tai">1.3 支持的平台</span><a href="#1-3-zhi-chi-de-ping-tai" class="header-anchor">#</a></h2><ul><li><p>Windows – XP、Vista、Win7、Win8、Win2008、Win10、Win11</p></li><li><p>Uinux/X11 – Linux、Sun Solaris、HP-UX、Compaq Tru64 UNIX、IBM AIX、SGI IRIX、FreeBSD、BSD/OS、和其他很多X11平台</p></li><li><p>Macintosh – Mac OS X</p></li><li><p>Embedded – 有帧缓冲支持的嵌入式Linux平台，Windows CE</p></li></ul><h2><span id="1-4-qt-ban-ben">1.4 Qt版本</span><a href="#1-4-qt-ban-ben" class="header-anchor">#</a></h2><p>Qt按照不同的版本发行，分为商业版和开源版</p><ul><li>商业版</li></ul><p>为商业软件提供开发，他们提供传统商业软件发行版，并且提供在商业有效期内的免费升级和技术支持服务。</p><ul><li>开源的LGPL版本：</li></ul><p>为了开发自有而设计的开放源码软件，它提供了和商业版本同样的功能，在GNU通用公共许可下，它是免费的。</p><h2><span id="1-5-qt-de-xia-zai-yu-an-zhuang">1.5 Qt的下载与安装</span><a href="#1-5-qt-de-xia-zai-yu-an-zhuang" class="header-anchor">#</a></h2><h3><span id="xia-zai-di-zhi">下载地址：</span><a href="#xia-zai-di-zhi" class="header-anchor">#</a></h3><p>现在QT有两种安装方式</p><ol><li><p>在线安装：使用qt的安装器</p><div class="code-wrapper"><pre><code class="hljs bash">https://download.qt.io/archive/online_installers/4.2/</code></pre></div><p>不同系统下载对应安装器,然后安装</p></li><li><p>离线安装</p><p>qt最后的一个离线安装版本是5.14.2,超过此版本是在线安装版，不提供整合二进制版本。</p></li></ol><h3><span id="linux-host">Linux Host</span><a href="#linux-host" class="header-anchor">#</a></h3><p>下载链接👉<a href="https://download.qt.io/archive/qt/5.14/5.14.2/qt-opensource-linux-x64-5.14.2.run">Qt 5.14.2 for Linux 64-bit ( 1.2G )</a></p><h3><span id="os-x-host">OS X Host</span><a href="#os-x-host" class="header-anchor">#</a></h3><p>下载链接👉<a href="https://download.qt.io/archive/qt/5.14/5.14.2/qt-opensource-mac-x64-5.14.2.dmg">Qt 5.14.2 for Mac 64-bit ( 2.6G )</a></p><h3><span id="windows-host">Windows Host</span><a href="#windows-host" class="header-anchor">#</a></h3><p>下载链接👉<a href="https://download.qt.io/archive/qt/5.14/5.14.2/qt-opensource-windows-x86-5.14.2.exe">Qt 5.14.2 for Win 64-bit ( 2.3G )</a></p><h3><span id="an-zhuang">安装</span><a href="#an-zhuang" class="header-anchor">#</a></h3><p>默认安装（建议组件全部选中）</p><p>· Qt对不同的平台提供了不同版本的安装包，可根据实际情况自行下载安装，本文档使用<code>qt-opensource-windows-x86-5.14.2</code> 版本进行讲解</p><h2><span id="1-6-qt-de-you-dian">1.6 Qt的优点</span><a href="#1-6-qt-de-you-dian" class="header-anchor">#</a></h2><ul><li><p>跨平台，几乎支持所有的平台</p></li><li><p>接口简单，容易上手，学习QT框架对学习其他框架有参考意义。 </p></li><li><p>一定程度上简化了内存回收机制 </p></li><li><p>有很好的社区氛围，市场份额在缓慢上升。</p></li><li><p>可以进行嵌入式开发。</p></li></ul><p><img src="https://gitee.com/txt1994/images/raw/master/img/QT/wps1.jpg" alt="img"> </p><h2><span id="1-7-cheng-gong-an-li">1.7 成功案例</span><a href="#1-7-cheng-gong-an-li" class="header-anchor">#</a></h2><ul><li><p>Linux桌面环境KDE</p></li><li><p>WPS Office 办公软件</p></li><li><p>Skype 网络电话</p></li><li><p>Google Earth 谷歌地图</p></li><li><p>VLC多媒体播放器</p></li><li><p>VirtualBox虚拟机软件</p></li></ul><h1><span id="2-chuang-jian-qt-xiang-mu"><strong>2</strong> 创建Qt项目</span><a href="#2-chuang-jian-qt-xiang-mu" class="header-anchor">#</a></h1><h2><span id="2-1-shi-yong-xiang-dao-chuang-jian">2.1 使用向导创建</span><a href="#2-1-shi-yong-xiang-dao-chuang-jian" class="header-anchor">#</a></h2><p>打开Qt Creator 界面选择 New Project或者选择菜单栏 【文件】-【新建文件或项目】菜单项</p><p><img src="https://gitee.com/txt1994/images/raw/master/img/QT/wps2.png" alt="img"> </p><p>弹出New Project对话框，选择Qt Widgets Application， </p><p><img src="https://gitee.com/txt1994/images/raw/master/img/QT/wps3.jpg" alt="img"> </p><p>选择【Choose】按钮，弹出如下对话框</p><p><img src="https://gitee.com/txt1994/images/raw/master/img/QT/wps4.jpg" alt="img"> </p><p>选择项目构建系统</p><p><img src="https://gitee.com/txt1994/images/raw/master/img/QT/wps4-1.jpg" alt="img"></p><p>向导会默认添加一个继承自MainWindow的类，可以在此修改类的名字和基类。默认的基类有QMainWindow、QWidget以及QDialog三个，我们可以选择QWidget（类似于空窗口），这里我们可以先创建一个不带UI的界面，继续下一步</p><p><img src="https://gitee.com/txt1994/images/raw/master/img/QT/wps6.jpg" alt="img"> </p><p>语言默认，下一步</p><p><img src="https://gitee.com/txt1994/images/raw/master/img/QT/wps6-1.jpg" alt="img"></p><p>设置项目名称和路径，按照向导进行下一步，选择编译套件</p><p><img src="https://gitee.com/txt1994/images/raw/master/img/QT/wps5.jpg" alt="img"> </p><p>系统会默认给我们添加main.cpp、mywidget.cpp、 mywidget.h和一个CMakeLists.txt文件，点击完成，即可创建出一个Qt桌面程序。</p><p><img src="https://gitee.com/txt1994/images/raw/master/img/QT/wps7.jpg" alt="img"> </p><h2><span id="2-2-shou-dong-chuang-jian"><strong>2.2</strong> 手动创建</span><a href="#2-2-shou-dong-chuang-jian" class="header-anchor">#</a></h2><p>添加一个空项目</p><p><img src="https://gitee.com/txt1994/images/raw/master/img/QT/wps8.jpg" alt="img"> </p><p>选择【choose】进行下一步。设置项目名称和路径 —&gt; 选择编译套件 –&gt; 修改类信息 –&gt; 完成（步骤同上），生成一个空项目。在空项目中添加文件：在项目名称上单击鼠标右键弹出右键菜单，选择【添加新文件】</p><p><img src="https://gitee.com/txt1994/images/raw/master/img/QT/wps9.jpg" alt="img"> </p><p>弹出新建文件对话框</p><p><img src="https://gitee.com/txt1994/images/raw/master/img/QT/wps10.jpg" alt="img"> </p><p>在此对话框中选择要添加的类或者文件，根据向导完成文件的添加。</p><h2><span id="2-3-pro-wen-jian"><strong>2.3</strong> .pro文件</span><a href="#2-3-pro-wen-jian" class="header-anchor">#</a></h2><p>在使用Qt向导生成的应用程序.pro文件格式如下：</p><p>QT    += core gui  //包含的模块</p><p>greaterThan(QT_MAJOR_VERSION, 4): QT += widgets //大于Qt4版本 才包含widget模块</p><p>TARGET = QtFirst  //应用程序名  生成的.exe程序名称</p><p>TEMPLATE = app   //模板类型   应用程序模板</p><p>SOURCES += main.cpp\  //源文件</p><p>​    mywidget.cpp</p><p>HEADERS  += mywidget.h  //头文件</p><p>.pro就是工程文件(project)，它是qmake自动生成的用于生产makefile的配置文件。.pro文件的写法如下：</p><p>注释</p><p>从“#”开始，到这一行结束。</p><ul><li><p>模板变量告诉qmake为这个应用程序生成哪种makefile。下面是可供使用的选择：TEMPLATE = app</p></li><li><p>app -建立一个应用程序的makefile。这是默认值，所以如果模板没有被指定，这个将被使用。</p></li><li><p>lib - 建立一个库的makefile。</p></li><li><p>vcapp - 建立一个应用程序的VisualStudio项目文件。</p></li><li><p>vclib - 建立一个库的VisualStudio项目文件。</p></li><li><p>subdirs -这是一个特殊的模板，它可以创建一个能够进入特定目录并且为一个项目文件生成makefile并且为它调用make的makefile。</p></li><li><p>#指定生成的应用程序名：</p></li></ul><p>TARGET = QtDemo</p><ul><li>#工程中包含的头文件</li></ul><p>HEADERS += include/painter.h</p><ul><li>#工程中包含的.ui设计文件</li></ul><p>FORMS += forms/painter.ui</p><ul><li>#工程中包含的源文件</li></ul><p>SOURCES += sources/main.cpp sources</p><ul><li>#工程中包含的资源文件</li></ul><p>RESOURCES += qrc/painter.qrc</p><p>greaterThan(QT_MAJOR_VERSION, 4): QT += widgets</p><p>这条语句的含义是，如果<code>QT_MAJOR_VERSION</code>大于4（也就是当前使用的Qt5及更高版本）需要增加widgets模块。如果项目仅需支持Qt5，也可以直接添加“QT += widgets”一句。不过为了保持代码兼容，最好还是按照QtCreator生成的语句编写。</p><ul><li>#配置信息</li></ul><p>CONFIG用来告诉qmake关于应用程序的配置信息。</p><p>CONFIG += c++11    //使用c++11的特性</p><p>在这里使用“+=”，是因为我们添加我们的配置选项到任何一个已经存在中。这样做比使用“=”那样替换已经指定的所有选项更安全。</p><h2><span id="2-4-yi-ge-zui-jian-dan-de-qt-ying-yong-cheng-xu"><strong>2.4</strong> 一个最简单的Qt应用程序</span><a href="#2-4-yi-ge-zui-jian-dan-de-qt-ying-yong-cheng-xu" class="header-anchor">#</a></h2><p>main入口函数中</p><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">"widget.h"</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;QApplication&gt;</span></span><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> *argv[])</span></span><span class="hljs-function"></span>{    <span class="hljs-function">QApplication <span class="hljs-title">a</span><span class="hljs-params">(argc, argv)</span></span>;    Widget w;    w.<span class="hljs-built_in">show</span>();    <span class="hljs-keyword">return</span> a.<span class="hljs-built_in">exec</span>();}</code></pre></div><p>解释：</p><ul><li><p>Qt系统提供的标准类名声明头文件没有.h后缀</p></li><li><p>Qt一个类对应一个头文件，类名就是头文件名</p></li><li><p>QApplication应用程序类</p></li><li><p>管理图形用户界面应用程序的控制流和主要设置。</p></li><li><p>是Qt的整个后台管理的命脉它包含主事件循环，在其中来自窗口系统和其它资源的所有事件处理和调度。它也处理应用程序的初始化和结束，并且提供对话管理。</p></li><li><p>对于任何一个使用Qt的图形用户界面应用程序，都正好存在一个QApplication 对象，而不论这个应用程序在同一时间内是不是有0、1、2或更多个窗口。</p></li><li><p>a.exec()</p></li></ul><p>程序进入消息循环，等待对用户输入进行响应。这里main()把控制权转交给Qt，Qt完成事件处理工作，当应用程序退出的时候exec()的值就会返回。在exec()中，Qt接受并处理用户和系统的事件并且把它们传递给适当的窗口部件。</p><h1><span id="3-di-yi-ge-qt-xiao-cheng-xu">3 第一个Qt小程序</span><a href="#3-di-yi-ge-qt-xiao-cheng-xu" class="header-anchor">#</a></h1><h2><span id="3-1-an-niu-de-chuang-jian">3.1 按钮的创建</span><a href="#3-1-an-niu-de-chuang-jian" class="header-anchor">#</a></h2><p>在Qt程序中，最常用的控件之一就是按钮了，首先我们来看下如何创建一个按钮</p> <div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;QPushButton&gt;</span></span>QPushButton * btn = <span class="hljs-keyword">new</span> QPushButton;<span class="hljs-comment">//设置父亲</span>btn-&gt;<span class="hljs-built_in">setParent</span>(<span class="hljs-keyword">this</span>);<span class="hljs-comment">//设置文字</span>btn-&gt;<span class="hljs-built_in">setText</span>(<span class="hljs-string">"德玛西亚"</span>);<span class="hljs-comment">//移动位置</span>btn-&gt;<span class="hljs-built_in">move</span>(<span class="hljs-number">100</span>,<span class="hljs-number">100</span>);<span class="hljs-comment">//第二种创建</span>QPushButton * btn2 = <span class="hljs-keyword">new</span> <span class="hljs-built_in">QPushButton</span>(<span class="hljs-string">"孙悟空"</span>,<span class="hljs-keyword">this</span>);<span class="hljs-comment">//重新指定窗口大小</span><span class="hljs-keyword">this</span>-&gt;<span class="hljs-built_in">resize</span>(<span class="hljs-number">600</span>,<span class="hljs-number">400</span>);<span class="hljs-comment">//设置窗口标题</span><span class="hljs-keyword">this</span>-&gt;<span class="hljs-built_in">setWindowTitle</span>(<span class="hljs-string">"第一个项目"</span>);<span class="hljs-comment">//限制窗口大小</span><span class="hljs-keyword">this</span>-&gt;<span class="hljs-built_in">setFixedSize</span>(<span class="hljs-number">600</span>,<span class="hljs-number">400</span>);</code></pre></div><p>上面代码中，一个按钮其实就是一个<code>QPushButton类</code>下的对象，如果只是创建出对象，是无法显示到窗口中的，所以我们需要依赖一个父窗口，也就是指定一个父亲利用setParent函数即可，如果想设置按钮上显示的文字利用setText，移动按钮位置用move</p><p>​    对于窗口而言，我们可以修改左上角窗口的标题setWindowTitle，重新指定窗口大小：resize，或者设置固定的窗口大小setFixedSize；</p><h2><span id="3-2-dui-xiang-mo-xing-dui-xiang-shu">3.2 对象模型（对象树）</span><a href="#3-2-dui-xiang-mo-xing-dui-xiang-shu" class="header-anchor">#</a></h2><p>在Qt中创建对象的时候会提供一个Parent对象指针，下面来解释这个parent到底是干什么的。</p><ul><li><p>QObject是以对象树的形式组织起来的。</p></li><li><p>parent，也就是父对象指针。</p></li></ul><p>这相当于，在创建QObject对象时，可以提供一个其父对象，我们创建的这个QObject对象会自动添加到其父对象的children()列表。</p><ul><li>当父对象析构的时候，这个列表中的所有对象也会被析构。（注意，这里的父对象并不是继承意义上的父类！）</li></ul><p>这种机制在 GUI 程序设计中相当有用。例如，一个按钮有一个QShortcut（快捷键）对象作为其子对象。当我们删除按钮的时候，这个快捷键理应被删除。这是合理的。</p><ul><li><p>QWidget是能够在屏幕上显示的一切组件的父类。</p></li><li><p>QWidget继承自QObject，因此也继承了这种对象树关系。一个孩子自动地成为父组件的一个子组件。因此，它会显示在父组件的坐标系统中，被父组件的边界剪裁。例如，当用户关闭一个对话框的时候，应用程序将其删除，那么，我们希望属于这个对话框的按钮、图标等应该一起被删除。事实就是如此，因为这些都是对话框的子组件。</p></li><li><p>当然，我们也可以自己删除子对象，它们会自动从其父对象列表中删除。比如，当我们删除了一个工具栏时，其所在的主窗口会自动将该工具栏从其子对象列表中删除，并且自动调整屏幕显示。</p></li></ul><p>Qt 引入对象树的概念，在一定程度上解决了内存问题。</p><ul><li><p>当一个QObject对象在堆上创建的时候，Qt 会同时为其创建一个对象树。不过，对象树中对象的顺序是没有定义的。这意味着，销毁这些对象的顺序也是未定义的。</p></li><li><p>任何对象树中的 QObject对象 delete 的时候，如果这个对象有 parent，则自动将其从 parent 的children()列表中删除；如果有孩子，则自动 delete 每一个孩子。Qt 保证没有QObject会被 delete 两次，这是由析构顺序决定的。</p></li></ul><p>如果QObject在栈上创建，Qt 保持同样的行为。正常情况下，这也不会发生什么问题。来看下下面的代码片段：</p><div class="code-wrapper"><pre><code class="hljs c++">{    QWidget window;    <span class="hljs-function">QPushButton <span class="hljs-title">quit</span><span class="hljs-params">(<span class="hljs-string">"Quit"</span>, &amp;window)</span></span>;}</code></pre></div><p>作为父组件的 window 和作为子组件的 quit 都是QObject的子类（事实上，它们都是QWidget的子类，而QWidget是QObject的子类）。这段代码是正确的，quit 的析构函数不会被调用两次，因为标准 C++要求，局部对象的析构顺序应该按照其创建顺序的相反过程。因此，这段代码在超出作用域时，会先调用 quit 的析构函数，将其从父对象 window 的子对象列表中删除，然后才会再调用 window 的析构函数。</p><p>但是，如果我们使用下面的代码：</p><div class="code-wrapper"><pre><code class="hljs c++">{    <span class="hljs-function">QPushButton <span class="hljs-title">quit</span><span class="hljs-params">(<span class="hljs-string">"Quit"</span>)</span></span>;    QWidget window;    quit.<span class="hljs-built_in">setParent</span>(&amp;window);}</code></pre></div><p>情况又有所不同，析构顺序就有了问题。我们看到，在上面的代码中，作为父对象的 window 会首先被析构，因为它是最后一个创建的对象。在析构过程中，它会调用子对象列表中每一个对象的析构函数，也就是说， quit 此时就被析构了。然后，代码继续执行，在 window 析构之后，quit 也会被析构，因为 quit 也是一个局部变量，在超出作用域的时候当然也需要析构。但是，这时候已经是第二次调用 quit 的析构函数了，C++ 不允许调用两次析构函数，因此，程序崩溃了。</p><p>由此我们看到，Qt 的对象树机制虽然帮助我们在一定程度上解决了内存问题，但是也引入了一些值得注意的事情。这些细节在今后的开发过程中很可能时不时跳出来烦扰一下，所以，我们最好从开始就养成良好习惯，在 Qt 中，尽量在构造的时候就指定 parent 对象，并且大胆在堆上创建。</p><h2><span id="3-3-qt-chuang-kou-zuo-biao-ti-xi">3.3 Qt窗口坐标体系</span><a href="#3-3-qt-chuang-kou-zuo-biao-ti-xi" class="header-anchor">#</a></h2><p>坐标体系：</p><p>以左上角为原点（0,0），X向右增加，Y向下增加。</p><p><img src="https://gitee.com/txt1994/images/raw/master/img/QT/wps11.jpg" alt="img"> </p><p>对于嵌套窗口，其坐标是相对于父窗口来说的。</p><h1><span id="4-xin-hao-he-cao-ji-zhi">4 信号和槽机制</span><a href="#4-xin-hao-he-cao-ji-zhi" class="header-anchor">#</a></h1><p>信号槽是 Qt 框架引以为豪的机制之一。所谓信号槽，实际就是观察者模式。当某个事件发生之后，比如，按钮检测到自己被点击了一下，它就会发出一个信号（signal）。这种发出是没有目的的，类似广播。如果有对象对这个信号感兴趣，它就会使用连接（connect）函数，意思是，将想要处理的信号和自己的一个函数（称为槽（slot））绑定来处理这个信号。也就是说，当信号发出时，被连接的槽函数会自动被回调。这就类似观察者模式：当发生了感兴趣的事件，某一个操作就会被自动触发。</p><h2><span id="4-1-xi-tong-zi-dai-de-xin-hao-he-cao">4.1 系统自带的信号和槽</span><a href="#4-1-xi-tong-zi-dai-de-xin-hao-he-cao" class="header-anchor">#</a></h2><p>下面我们完成一个小功能，上面我们已经学习了按钮的创建，但是还没有体现出按钮的功能，按钮最大的功能也就是点击后触发一些事情，比如我们点击按钮，就把当前的窗口给关闭掉，那么在Qt中，这样的功能如何实现呢？</p><p>​    其实无法两行代码就可以搞定了，我们看下面的代码</p><div class="code-wrapper"><pre><code class="hljs c++">QPushButton * quitBtn = <span class="hljs-keyword">new</span> <span class="hljs-built_in">QPushButton</span>(<span class="hljs-string">"关闭窗口"</span>,<span class="hljs-keyword">this</span>);<span class="hljs-built_in">connect</span>(quitBtn,&amp;QPushButton::clicked,<span class="hljs-keyword">this</span>,&amp;MyWidget::close);</code></pre></div><p>第一行是创建一个关闭按钮，这个之前已经学过，第二行就是核心了，也就是信号槽的使用方式</p><p>connect()函数最常用的一般形式：</p><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-built_in">connect</span>(sender, signal, receiver, slot);</code></pre></div><p>参数解释：</p><ul><li><p>sender：发出信号的对象</p></li><li><p>signal：发送对象发出的信号</p></li><li><p>receiver：接收信号的对象</p></li><li><p>slot：接收对象在接收到信号之后所需要调用的函数（槽函数）</p></li></ul><p>那么系统自带的信号和槽通常如何查找呢，这个就需要利用帮助文档了，在帮助文档中比如我们上面的按钮的点击信号，在帮助文档中输入<code>QPushButton</code>，首先我们可以在Contents中寻找关键字 signals，信号的意思，但是我们发现并没有找到，这时候我们应该想到也许这个信号的被父类继承下来的，因此我们去他的<code>父类QAbstractButton</code>中就可以找到该关键字，点击signals索引到系统自带的信号有如下几个</p><p><img src="https://gitee.com/txt1994/images/raw/master/img/QT/wps12.jpg" alt="img"> </p><p>这里的clicked就是我们要找到，槽函数的寻找方式和信号一样，只不过他的关键字是slot。</p><h2><span id="4-2-zi-ding-yi-xin-hao-he-cao">4.2 自定义信号和槽</span><a href="#4-2-zi-ding-yi-xin-hao-he-cao" class="header-anchor">#</a></h2><p>使用connect()可以让我们连接系统提供的信号和槽。但是，Qt 的信号槽机制并不仅仅是使用系统提供的那部分，还会允许我们自己设计自己的信号和槽。</p><p>下面我们看看使用 Qt 的信号槽：</p><p>首先定义一个学生类和老师类：</p><p>​    老师类中声明信号 饿了 hungry</p><div class="code-wrapper"><pre><code class="hljs c++">signals:<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">hungury</span><span class="hljs-params">()</span></span>;<span class="hljs-comment">//学生类中声明槽  请客 treat</span><span class="hljs-keyword">public</span> slots:<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">treat</span><span class="hljs-params">()</span></span>;<span class="hljs-comment">//在窗口中声明一个公共方法下课，这个方法的调用会触发老师饿了这个信号，而响应槽函数学生请客</span><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">MyWidget::ClassIsOver</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>{    <span class="hljs-comment">//发送信号</span>    emit teacher-&gt;<span class="hljs-built_in">hungury</span>();}<span class="hljs-comment">//学生响应了槽函数，并且打印信息</span><span class="hljs-comment">//自定义槽函数 实现</span><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Student::eat</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>{    <span class="hljs-built_in">qDebug</span>() &lt;&lt; <span class="hljs-string">"该吃饭了！"</span>;}</code></pre></div><p>在窗口中连接信号槽</p> <div class="code-wrapper"><pre><code class="hljs c++">teacher = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Teacher</span>(<span class="hljs-keyword">this</span>);student = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Student</span>(<span class="hljs-keyword">this</span>);<span class="hljs-built_in">connect</span>(teacher,&amp;Teacher::hungury,student,&amp;Student::treat);</code></pre></div><p>并且调用下课函数，测试打印出 “该吃饭了”</p><p>自定义的信号 hungry带参数，需要提供重载的自定义信号和 自定义槽</p><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">hungury</span><span class="hljs-params">(QString name)</span></span>; <span class="hljs-comment">// 自定义信号</span><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">treat</span><span class="hljs-params">(QString name )</span></span>;  <span class="hljs-comment">// 自定义槽</span></code></pre></div><p>但是由于有两个重名的自定义信号和自定义的槽，直接连接会报错，所以需要利用函数指针来指向函数地址， 然后在做连接</p><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-built_in">void</span> (Teacher:: * teacherSingal)(QString) = &amp;Teacher::hungury;<span class="hljs-built_in">void</span> (Student:: * studentSlot)(QString) = &amp;Student::treat;<span class="hljs-built_in">connect</span>(teacher,teacherSingal,student,studentSlot);</code></pre></div><p>自定义信号槽需要注意的事项：</p><ol><li><p>发送者和接收者都需要是QObject的子类（当然，槽函数是全局函数、Lambda 表达式等无需接收者的时候除外）；</p></li><li><p>信号和槽函数返回值是 void</p></li><li><p>信号只需要声明，不需要实现</p></li><li><p>槽函数需要声明也需要实现</p></li><li><p>槽函数是普通的成员函数，作为成员函数，会受到 public、private、protected 的影响；</p></li><li><p>使用 emit 在恰当的位置发送信号；</p></li><li><p>使用connect()函数连接信号和槽。</p></li><li><p>任何成员函数、static 函数、全局函数和 Lambda 表达式都可以作为槽函数</p></li><li><p>信号槽要求信号和槽的参数一致，所谓一致，是参数类型一致。</p></li><li><p>如果信号和槽的参数不一致，允许的情况是，槽函数的参数可以比信号的少，即便如此，槽函数存在的那些参数的顺序也必须和信号的前面几个一致起来。这是因为，你可以在槽函数中选择忽略信号传来的数据（也就是槽函数的参数比信号的少）。</p></li></ol><h2><span id="4-3-xin-hao-cao-de-tuo-zhan">4.3信号槽的拓展</span><a href="#4-3-xin-hao-cao-de-tuo-zhan" class="header-anchor">#</a></h2><ol><li>一个信号可以和多个槽相连</li></ol><p>如果是这种情况，这些槽会一个接一个的被调用，但是它们的调用顺序是不确定的。</p><ol start="2"><li>多个信号可以连接到一个槽</li></ol><p>只要任意一个信号发出，这个槽就会被调用。</p><ol start="3"><li>一个信号可以连接到另外的一个信号</li></ol><p>当第一个信号发出时，第二个信号被发出。除此之外，这种信号-信号的形式和信号-槽的形式没有什么区别。</p><ol start="4"><li>槽可以被取消链接</li></ol><p>这种情况并不经常出现，因为当一个对象delete之后，Qt自动取消所有连接到这个对象上面的槽。</p><ol start="5"><li>信号槽可以断开</li></ol><p>利用disconnect关键字是可以断开信号槽的</p><ol start="6"><li>使用Lambda 表达式</li></ol><p>在使用 Qt 5 的时候，能够支持 Qt 5 的编译器都是支持 Lambda 表达式的。</p><p>​    在连接信号和槽的时候，槽函数可以使用Lambda表达式的方式进行处理。后面我们会详细介绍什么是Lambda表达式</p><h2><span id="4-4-qt4-ban-ben-de-xin-hao-cao-xie-fa">4.4 Qt4版本的信号槽写法</span><a href="#4-4-qt4-ban-ben-de-xin-hao-cao-xie-fa" class="header-anchor">#</a></h2><p>connect(zt, SIGNAL(hungry(QString)), st, SLOT(treat(QString)));</p><p>这里使用了SIGNAL和SLOT这两个宏，将两个函数名转换成了字符串。注意到connect()函数的 signal 和 slot 都是接受字符串，一旦出现连接不成功的情况，Qt4是没有编译错误的（因为一切都是字符串，编译期是不检查字符串是否匹配），而是在运行时给出错误。这无疑会增加程序的不稳定性。</p><p>Qt5在语法上完全兼容Qt4，而反之是不可以的。</p><h2><span id="4-5-lambda-biao-da-shi">4.5 Lambda表达式</span><a href="#4-5-lambda-biao-da-shi" class="header-anchor">#</a></h2><p>C++11中的Lambda表达式用于定义并创建匿名的函数对象，以简化编程工作。首先看一下Lambda表达式的基本构成：</p><div class="code-wrapper"><pre><code class="hljs c++">[capture](parameters) <span class="hljs-keyword">mutable</span> -&gt;<span class="hljs-keyword">return</span>-type{    statement}</code></pre></div><p><code>[函数对象参数](操作符重载函数参数)mutable -&gt;返回值{函数体}</code></p><p>① 函数对象参数；</p><p>[]，标识一个Lambda的开始，这部分必须存在，<em><strong>不能省略</strong></em>。函数对象参数是传递给编译器自动生成的函数对象类的构造函数的。函数对象参数只能使用那些到定义Lambda为止时Lambda所在作用范围内可见的局部变量（包括Lambda所在类的this）。函数对象参数有以下形式：</p><ul><li><p><code>空</code>。没有使用任何函数对象参数。</p></li><li><p><code>=</code>。函数体内可以使用Lambda所在作用范围内所有可见的局部变量（包括Lambda所在类的this），并且是值传递方式（相当于编译器自动为我们按值传递了所有局部变量）。</p></li><li><p><code>&amp;</code>。函数体内可以使用Lambda所在作用范围内所有可见的局部变量（包括Lambda所在类的this），并且是引用传递方式（相当于编译器自动为我们按引用传递了所有局部变量）。</p></li><li><p><code>this</code>。函数体内可以使用Lambda所在类中的成员变量。</p></li><li><p><code>a</code>。将a按值进行传递。按值进行传递时，函数体内不能修改传递进来的a的拷贝，因为默认情况下函数是const的。要修改传递进来的a的拷贝，可以添加mutable修饰符。</p></li><li><p><code>&amp;a</code>。将a按引用进行传递。</p></li><li><p><code>a, &amp;b</code>。将a按值进行传递，b按引用进行传递。</p></li><li><p><code>=，&amp;a, &amp;b</code>。除a和b按引用进行传递外，其他参数都按值进行传递。</p></li><li><p><code>&amp;, a, b</code>。除a和b按值进行传递外，其他参数都按引用进行传递。</p></li></ul><p>② 操作符重载函数参数；</p><p>标识重载的()操作符的参数，没有参数时，这部分可以省略。参数可以通过按值（如：(a,b)）和按引用（如：(&amp;a,&amp;b)）两种方式进行传递。</p><p>③ 可修改标示符；</p><p>mutable声明，这部分可以省略。按值传递函数对象参数时，加上mutable修饰符后，可以修改按值传递进来的拷贝（注意是能修改拷贝，而不是值本身）。</p><div class="code-wrapper"><pre><code class="hljs c++">QPushButton * myBtn = <span class="hljs-keyword">new</span> <span class="hljs-built_in">QPushButton</span> (<span class="hljs-keyword">this</span>);QPushButton * myBtn2 = <span class="hljs-keyword">new</span> <span class="hljs-built_in">QPushButton</span> (<span class="hljs-keyword">this</span>);myBtn2-&gt;<span class="hljs-built_in">move</span>(<span class="hljs-number">100</span>,<span class="hljs-number">100</span>);<span class="hljs-type">int</span> m = <span class="hljs-number">10</span>;<span class="hljs-built_in">connect</span>(myBtn,&amp;QPushButton::clicked,<span class="hljs-keyword">this</span>,[m] ()<span class="hljs-keyword">mutable</span> { m = <span class="hljs-number">20</span>; <span class="hljs-built_in">qDebug</span>() &lt;&lt; m; });<span class="hljs-built_in">connect</span>(myBtn2,&amp;QPushButton::clicked,<span class="hljs-keyword">this</span>,[=] ()  { <span class="hljs-built_in">qDebug</span>() &lt;&lt; m; });<span class="hljs-built_in">qDebug</span>() &lt;&lt; m;</code></pre></div><p>④ 函数返回值；</p><p>-&gt;返回值类型，标识函数返回值的类型，当返回值为void，或者函数体中只有一处return的地方（此时编译器可以自动推断出返回值类型）时，这部分可以省略。</p><p>⑤ 是函数体；</p><p>​    {}，标识函数的实现，这部分不能省略，但函数体可以为空。</p><h1><span id="5-qmainwindow">5 QMainWindow</span><a href="#5-qmainwindow" class="header-anchor">#</a></h1><p>QMainWindow是一个为用户提供主窗口程序的类，包含一个菜单栏（menu bar）、多个工具栏(tool bars)、多个锚接部件(dock widgets)、一个状态栏(status bar)及一个中心部件(central widget)，是许多应用程序的基础，如文本编辑器，图片编辑器等。</p><p><img src="https://gitee.com/txt1994/images/raw/master/img/QT/wps13.jpg" alt="img"> </p><h2><span id="5-1-cai-dan-lan">5.1 菜单栏</span><a href="#5-1-cai-dan-lan" class="header-anchor">#</a></h2><p>一个主窗口最多只有一个菜单栏。位于主窗口顶部、主窗口标题栏下面。</p><ul><li>创建菜单栏，通过QMainWindow类的menubar（）函数获取主窗口菜单栏指针</li></ul><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-function">QMenuBar *<span class="hljs-title">menuBar</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span>;</code></pre></div><ul><li>创建菜单，调用QMenu的成员函数addMenu来添加菜单</li></ul><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-function">QAction* <span class="hljs-title">addMenu</span><span class="hljs-params">(QMenu * menu)</span></span><span class="hljs-function"></span><span class="hljs-function">QMenu* <span class="hljs-title">addMenu</span><span class="hljs-params">(<span class="hljs-type">const</span> QString &amp; title)</span></span><span class="hljs-function"></span><span class="hljs-function">QMenu* <span class="hljs-title">addMenu</span><span class="hljs-params">(<span class="hljs-type">const</span> QIcon &amp; icon, <span class="hljs-type">const</span> QString &amp; title)</span></span></code></pre></div><ul><li>创建菜单项，调用QMenu的成员函数addAction来添加菜单项</li></ul><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-function">QAction* <span class="hljs-title">activeAction</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span><span class="hljs-function"></span><span class="hljs-function">QAction* <span class="hljs-title">addAction</span><span class="hljs-params">(<span class="hljs-type">const</span> QString &amp; text)</span></span><span class="hljs-function"></span><span class="hljs-function">QAction* <span class="hljs-title">addAction</span><span class="hljs-params">(<span class="hljs-type">const</span> QIcon &amp; icon, <span class="hljs-type">const</span> QString &amp; text)</span></span><span class="hljs-function"></span><span class="hljs-function">QAction* <span class="hljs-title">addAction</span><span class="hljs-params">(<span class="hljs-type">const</span> QString &amp; text, <span class="hljs-type">const</span> QObject * receiver,</span></span><span class="hljs-params"><span class="hljs-function"></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-type">const</span> <span class="hljs-type">char</span> * member, <span class="hljs-type">const</span> QKeySequence &amp; shortcut = <span class="hljs-number">0</span>)</span></span><span class="hljs-function"></span><span class="hljs-function">QAction* <span class="hljs-title">addAction</span><span class="hljs-params">(<span class="hljs-type">const</span> QIcon &amp; icon, <span class="hljs-type">const</span> QString &amp; text, </span></span><span class="hljs-params"><span class="hljs-function"></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-type">const</span> QObject * receiver, <span class="hljs-type">const</span> <span class="hljs-type">char</span> * member, </span></span><span class="hljs-params"><span class="hljs-function"></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-type">const</span> QKeySequence &amp; shortcut = <span class="hljs-number">0</span>)</span></span></code></pre></div><p>Qt 并没有专门的菜单项类，只是使用一个QAction类，抽象出公共的动作。当我们把QAction对象添加到菜单，就显示成一个菜单项，添加到工具栏，就显示成一个工具按钮。用户可以通过点击菜单项、点击工具栏按钮、点击快捷键来激活这个动作。</p><h2><span id="5-2-gong-ju-lan">5.2 工具栏</span><a href="#5-2-gong-ju-lan" class="header-anchor">#</a></h2><p>主窗口的工具栏上可以有多个工具条，通常采用一个菜单对应一个工具条的的方式，也可根据需要进行工具条的划分。</p><ul><li><p>直接调用QMainWindow类的addToolBar（）函数获取主窗口的工具条对象，每增加一个工具条都需要调用一次该函数。</p></li><li><p>插入属于工具条的动作，即在工具条上添加操作。</p></li></ul><p>通过QToolBar类的addAction函数添加。</p><ul><li><p>工具条是一个可移动的窗口，它的停靠区域由QToolBar的allowAreas决定，包括：</p></li><li><p>Qt::LeftToolBarArea        停靠在左侧</p></li><li><p>Qt::RightToolBarArea        停靠在右侧</p></li><li><p>Qt::TopToolBarArea        停靠在顶部</p></li><li><p>Qt::BottomToolBarArea      停靠在底部</p></li><li><p>Qt::AllToolBarAreas        以上四个位置都可停靠</p></li></ul><p>使用setAllowedAreas（）函数指定停靠区域：</p><div class="code-wrapper"><pre><code class="hljs c++">setAllowedAreas（Qt::LeftToolBarArea | Qt::RightToolBarArea）</code></pre></div><p>使用setMoveable（）函数设定工具栏的可移动性：</p><p>setMoveable（false）//工具条不可移动, 只能停靠在初始化的位置上</p><h2><span id="5-3-zhuang-tai-lan">5.3 状态栏</span><a href="#5-3-zhuang-tai-lan" class="header-anchor">#</a></h2><p>派生自QWidget类，使用方法与QWidget类似，QStatusBar类常用成员函数：</p><p>状态栏也只能最多有一个</p><p>// 添加小部件</p><ul><li>void addWidget(QWidget * widget, int stretch = 0)</li></ul><p>// 插入小部件</p><ul><li>int    insertWidget(int index, QWidget * widget, int stretch = 0)</li></ul><p>// 删除小部件</p><ul><li>void removeWidget(QWidget * widget)</li></ul><h2><span id="5-4-liu-jie-bu-jian">5.4 铆接部件</span><a href="#5-4-liu-jie-bu-jian" class="header-anchor">#</a></h2><p>铆接部件 QDockWidget，也称浮动窗口，可以有多个。</p><div class="code-wrapper"><pre><code class="hljs c++">QDockWidget * dock = <span class="hljs-keyword">new</span> <span class="hljs-built_in">QDockWidget</span>(<span class="hljs-string">"标题"</span>,<span class="hljs-keyword">this</span>);<span class="hljs-built_in">addDockWidget</span>(Qt::LeftDockWidgetArea,dock);dock-&gt;<span class="hljs-built_in">setAllowedAreas</span>(Qt::LeftDockWidgetArea | Qt::RightDockWidgetArea | Qt::TopDockWidgetArea); <span class="hljs-comment">//设置区域范围</span></code></pre></div><h2><span id="5-5-he-xin-bu-jian-zhong-xin-bu-jian">5.5 核心部件（中心部件）</span><a href="#5-5-he-xin-bu-jian-zhong-xin-bu-jian" class="header-anchor">#</a></h2><p>除了以上几个部件，中心显示的部件都可以作为核心部件，例如一个记事本文件，可以利用QTextEdit做核心部件</p><div class="code-wrapper"><pre><code class="hljs c++">QTextEdit * edit = <span class="hljs-keyword">new</span> <span class="hljs-built_in">QTextEdit</span>(<span class="hljs-keyword">this</span>);<span class="hljs-built_in">setCentralWidget</span>(edit);</code></pre></div><h2><span id="5-6-zi-yuan-wen-jian">5.6 资源文件</span><a href="#5-6-zi-yuan-wen-jian" class="header-anchor">#</a></h2><p>Qt 资源系统是一个跨平台的资源机制，用于将程序运行时所需要的资源以二进制的形式存储于可执行文件内部。如果你的程序需要加载特定的资源（图标、文本翻译等），那么，将其放置在资源文件中，就再也不需要担心这些文件的丢失。也就是说，如果你将资源以资源文件形式存储，它是会编译到可执行文件内部。</p><p>使用 Qt Creator 可以很方便地创建资源文件。我们可以在工程上点右键，选择“添加新文件…”，可以在 Qt 分类下找到“Qt 资源文件”：</p><p><img src="https://gitee.com/txt1994/images/raw/master/img/QT/wps14.jpg" alt="img"> </p><p>点击“选择…”按钮，打开“新建 Qt 资源文件”对话框。在这里我们输入资源文件的名字和路径：</p><p><img src="https://gitee.com/txt1994/images/raw/master/img/QT/wps15.jpg" alt="img"> </p><p>点击下一步，选择所需要的版本控制系统，然后直接选择完成。我们可以在 Qt Creator 的左侧文件列表中看到“资源文件”一项，也就是我们新创建的资源文件：</p><p><img src="https://gitee.com/txt1994/images/raw/master/img/QT/wps16.jpg" alt="img"> </p><p>右侧的编辑区有个“添加”，我们首先需要添加前缀，比如我们将前缀取名为 images。然后选中这个前缀，继续点击添加文件，可以找到我们所需添加的文件。这里，我们选择 document-open.png 文件。当我们完成操作之后，Qt Creator 应该是这样子的：</p><p><img src="https://gitee.com/txt1994/images/raw/master/img/QT/wps17.jpg" alt="img"> </p><p>接下来，我们还可以添加另外的前缀或者另外的文件。这取决于你的需要。当我们添加完成之后，我们可以像前面一章讲解的那样，通过使用 : 开头的路径来找到这个文件。比如，我们的前缀是 /images，文件是 document-open.png，那么就可以使用:/images/document-open.png找到这个文件。</p><p>这么做带来的一个问题是，如果以后我们要更改文件名，比如将 docuemnt-open.png 改成 docopen.png，那么，所有使用了这个名字的路径都需要修改。所以，更好的办法是，我们给这个文件去一个“别名”，以后就以这个别名来引用这个文件。具体做法是，选中这个文件，添加别名信息：</p><p><img src="https://gitee.com/txt1994/images/raw/master/img/QT/wps18.jpg" alt="img"> </p><p>这样，我们可以直接使用:/images/doc-open引用到这个资源，无需关心图片的真实文件名。</p><p>如果我们使用文本编辑器打开 res.qrc 文件，就会看到一下内容：</p><div class="code-wrapper"><pre><code class="hljs bash">&lt;RCC&gt;  &lt;qresource prefix=<span class="hljs-string">"/images"</span>&gt;    &lt;file <span class="hljs-built_in">alias</span>=<span class="hljs-string">"doc-open"</span>&gt;document-open.png&lt;/file&gt;  &lt;/qresource&gt;  &lt;qresource prefix=<span class="hljs-string">"/images/fr"</span> lang=<span class="hljs-string">"fr"</span>&gt;    &lt;file <span class="hljs-built_in">alias</span>=<span class="hljs-string">"doc-open"</span>&gt;document-open-fr.png&lt;/file&gt;  &lt;/qresource&gt;&lt;/RCC&gt;</code></pre></div><p>我们可以对比一下，看看 Qt Creator 帮我们生成的是怎样的 qrc 文件。当我们编译工程之后，我们可以在构建目录中找到 qrc_res.cpp 文件，这就是 Qt 将我们的资源编译成了 C++ 代码。</p><h1><span id="6-dui-hua-kuang-qdialog">6 对话框QDialog</span><a href="#6-dui-hua-kuang-qdialog" class="header-anchor">#</a></h1><h2><span id="6-1-ji-ben-gai-nian">6.1 基本概念</span><a href="#6-1-ji-ben-gai-nian" class="header-anchor">#</a></h2><p>对话框是 GUI 程序中不可或缺的组成部分。很多不能或者不适合放入主窗口的功能组件都必须放在对话框中设置。对话框通常会是一个顶层窗口，出现在程序最上层，用于实现短期任务或者简洁的用户交互。</p><p>Qt 中使用QDialog类实现对话框。就像主窗口一样，我们通常会设计一个类继承QDialog。QDialog（及其子类，以及所有Qt::Dialog类型的类）的对于其 parent 指针都有额外的解释：如果 parent 为 NULL，则该对话框会作为一个顶层窗口，否则则作为其父组件的子对话框（此时，其默认出现的位置是 parent 的中心）。顶层窗口与非顶层窗口的区别在于，顶层窗口在任务栏会有自己的位置，而非顶层窗口则会共享其父组件的位置。</p><p>对话框分为模态对话框和非模态对话框。</p><ul><li>模态对话框，就是会阻塞同一应用程序中其它窗口的输入。</li></ul><p>模态对话框很常见，比如“打开文件”功能。你可以尝试一下记事本的打开文件，当打开文件对话框出现时，我们是不能对除此对话框之外的窗口部分进行操作的。</p><ul><li>与此相反的是非模态对话框，例如查找对话框，我们可以在显示着查找对话框的同时，继续对记事本的内容进行编辑。</li></ul><h2><span id="6-2-biao-zhun-dui-hua-kuang">6.2 标准对话框</span><a href="#6-2-biao-zhun-dui-hua-kuang" class="header-anchor">#</a></h2><p>所谓标准对话框，是 Qt 内置的一系列对话框，用于简化开发。事实上，有很多对话框都是通用的，比如打开文件、设置颜色、打印设置等。这些对话框在所有程序中几乎相同，因此没有必要在每一个程序中都自己实现这么一个对话框。</p><p>Qt 的内置对话框大致分为以下几类：</p><ul><li><p>QColorDialog：        选择颜色；</p></li><li><p>QFileDialog：            选择文件或者目录；</p></li><li><p>QFontDialog：            选择字体；</p></li><li><p>QInputDialog：        允许用户输入一个值，并将其值返回；</p></li><li><p>QMessageBox：            模态对话框，用于显示信息、询问问题等；</p></li><li><p>QPageSetupDialog：    为打印机提供纸张相关的选项；</p></li><li><p>QPrintDialog：        打印机配置；</p></li><li><p>QPrintPreviewDialog：打印预览；</p></li><li><p>QProgressDialog：        显示操作过程。</p></li></ul><h2><span id="6-3-zi-ding-yi-xiao-xi-kuang">6.3 自定义消息框</span><a href="#6-3-zi-ding-yi-xiao-xi-kuang" class="header-anchor">#</a></h2><p>Qt 支持模态对话框和非模态对话框。</p><p>模态与非模态的实现：</p><ul><li><p>使用QDialog::exec()实现应用程序级别的模态对话框</p></li><li><p>使用QDialog::open()实现窗口级别的模态对话框</p></li><li><p>使用QDialog::show()实现非模态对话框。</p></li></ul><h4><span id="mo-tai-dui-hua-kuang">模态对话框</span><a href="#mo-tai-dui-hua-kuang" class="header-anchor">#</a></h4><ul><li>Qt 有两种级别的模态对话框：</li></ul><ol><li>应用程序级别的模态</li></ol><p>当该种模态的对话框出现时，用户必须首先对对话框进行交互，直到关闭对话框，然后才能访问程序中其他的窗口。</p><ol start="2"><li>窗口级别的模态</li></ol><p>该模态仅仅阻塞与对话框关联的窗口，但是依然允许用户与程序中其它窗口交互。窗口级别的模态尤其适用于多窗口模式。</p><p>一般默认是应用程序级别的模态。</p><p>在下面的示例中，我们调用了exec()将对话框显示出来，因此这就是一个模态对话框。当对话框出现时，我们不能与主窗口进行任何交互，直到我们关闭了该对话框。</p><div class="code-wrapper"><pre><code class="hljs c++">QDialog dialog;dialog.<span class="hljs-built_in">setWindowTitle</span>(<span class="hljs-built_in">tr</span>(<span class="hljs-string">"Hello, dialog!"</span>));dialog.<span class="hljs-built_in">exec</span>();</code></pre></div><h4><span id="fei-mo-tai-dui-hua-kuang">非模态对话框</span><a href="#fei-mo-tai-dui-hua-kuang" class="header-anchor">#</a></h4><p>下面我们试着将exec()修改为show()，看看非模态对话框：</p><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-function">QDialog <span class="hljs-title">dialog</span><span class="hljs-params">(<span class="hljs-keyword">this</span>)</span></span>;dialog.<span class="hljs-built_in">setWindowTitle</span>(<span class="hljs-built_in">tr</span>(<span class="hljs-string">"Hello, dialog!"</span>));dialog.<span class="hljs-built_in">show</span>();</code></pre></div><p>是不是事与愿违？对话框竟然一闪而过！这是因为，show()函数不会阻塞当前线程，对话框会显示出来，然后函数立即返回，代码继续执行。注意，dialog 是建立在栈上的，show()函数返回，MainWindow::open()函数结束，dialog 超出作用域被析构，因此对话框消失了。知道了原因就好改了，我们将 dialog 改成堆上建立，当然就没有这个问题了：</p><div class="code-wrapper"><pre><code class="hljs c++">QDialog *dialog = <span class="hljs-keyword">new</span> QDialog;dialog-&gt;<span class="hljs-built_in">setWindowTitle</span>(<span class="hljs-built_in">tr</span>(<span class="hljs-string">"Hello, dialog!"</span>));dialog-&gt;<span class="hljs-built_in">show</span>();</code></pre></div><p>如果你足够细心，应该发现上面的代码是有问题的：dialog 存在内存泄露！dialog 使用 new 在堆上分配空间，却一直没有 delete。解决方案也很简单：将 MainWindow 的指针赋给 dialog 即可。还记得我们前面说过的 Qt 的对象系统吗？</p><p>不过，这样做有一个问题：如果我们的对话框不是在一个界面类中出现呢？由于QWidget的 parent 必须是QWidget指针，那就限制了我们不能将一个普通的 C++ 类指针传给 Qt 对话框。另外，如果对内存占用有严格限制的话，当我们将主窗口作为 parent 时，主窗口不关闭，对话框就不会被销毁，所以会一直占用内存。在这种情景下，我们可以设置 dialog 的WindowAttribute：</p><div class="code-wrapper"><pre><code class="hljs c++">QDialog *dialog = <span class="hljs-keyword">new</span> QDialog;dialog-&gt;<span class="hljs-built_in">setAttribute</span>(Qt::WA_DeleteOnClose);dialog-&gt;<span class="hljs-built_in">setWindowTitle</span>(<span class="hljs-built_in">tr</span>(<span class="hljs-string">"Hello, dialog!"</span>));dialog-&gt;<span class="hljs-built_in">show</span>();</code></pre></div><p>setAttribute()函数设置对话框关闭时，自动销毁对话框。</p><h2><span id="6-4-xiao-xi-dui-hua-kuang">6.4 消息对话框</span><a href="#6-4-xiao-xi-dui-hua-kuang" class="header-anchor">#</a></h2><p>QMessageBox用于显示消息提示。我们一般会使用其提供的几个 static 函数：</p><ol><li>显示关于对话框。</li></ol><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">about</span><span class="hljs-params">(QWidget * parent, <span class="hljs-type">const</span> QString &amp; title, <span class="hljs-type">const</span> QString &amp; text)</span></span></code></pre></div><p>这是一个最简单的对话框，其标题是 title，内容是 text，父窗口是 parent。对话框只有一个 OK 按钮。</p><ol start="2"><li>显示关于 Qt 对话框。该对话框用于显示有关 Qt 的信息。</li></ol><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">aboutQt</span><span class="hljs-params">(QWidget * parent, <span class="hljs-type">const</span> QString &amp; title = QString())</span></span></code></pre></div><ol start="3"><li>显示严重错误对话框。</li></ol><p>StandardButton critical(QWidget * parent, </p><p>const QString &amp; title, </p><p>const QString &amp; text, </p><p>StandardButtons buttons = Ok, </p><p>StandardButton defaultButton = NoButton)：</p><p>这个对话框将显示一个红色的错误符号。我们可以通过 buttons 参数指明其显示的按钮。默认情况下只有一个 Ok 按钮，我们可以使用StandardButtons类型指定多种按钮。</p><ol><li>与QMessageBox::critical()类似，不同之处在于这个对话框提供一个普通信息图标。</li></ol><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-function">StandardButton <span class="hljs-title">information</span><span class="hljs-params">(QWidget * parent, </span></span><span class="hljs-params"><span class="hljs-function"></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-type">const</span> QString &amp; title, </span></span><span class="hljs-params"><span class="hljs-function"></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-type">const</span> QString &amp; text, </span></span><span class="hljs-params"><span class="hljs-function"></span></span><span class="hljs-params"><span class="hljs-function">StandardButtons buttons = Ok, </span></span><span class="hljs-params"><span class="hljs-function"></span></span><span class="hljs-params"><span class="hljs-function">StandardButton defaultButton = NoButton)</span></span></code></pre></div><ol start="2"><li>与QMessageBox::critical ()类似，不同之处在于这个对话框提供一个问号图标，并且其显示的按钮是“是”和“否”。</li></ol><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-function">StandardButton <span class="hljs-title">question</span><span class="hljs-params">(QWidget * parent,</span></span><span class="hljs-params"><span class="hljs-function"></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-type">const</span> QString &amp; title, </span></span><span class="hljs-params"><span class="hljs-function"></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-type">const</span> QString &amp; text, </span></span><span class="hljs-params"><span class="hljs-function"></span></span><span class="hljs-params"><span class="hljs-function">StandardButtons buttons = StandardButtons( Yes | No ), </span></span><span class="hljs-params"><span class="hljs-function"></span></span><span class="hljs-params"><span class="hljs-function">StandardButton defaultButton = NoButton)</span> </span></code></pre></div><ol start="3"><li>与QMessageBox::critical()类似，不同之处在于这个对话框提供一个黄色叹号图标。</li></ol><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-function">StandardButton <span class="hljs-title">warning</span><span class="hljs-params">(QWidget * parent, </span></span><span class="hljs-params"><span class="hljs-function"></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-type">const</span> QString &amp; title, </span></span><span class="hljs-params"><span class="hljs-function"></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-type">const</span> QString &amp; text, </span></span><span class="hljs-params"><span class="hljs-function"></span></span><span class="hljs-params"><span class="hljs-function">StandardButtons buttons = Ok, </span></span><span class="hljs-params"><span class="hljs-function"></span></span><span class="hljs-params"><span class="hljs-function">StandardButton defaultButton = NoButton)</span></span></code></pre></div><p>我们可以通过下面的代码来演示下如何使用QMessageBox。</p><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">if</span> (QMessageBox::Yes == QMessageBox::<span class="hljs-built_in">question</span>(<span class="hljs-keyword">this</span>,                                              <span class="hljs-built_in">tr</span>(<span class="hljs-string">"Question"</span>), <span class="hljs-built_in">tr</span>(<span class="hljs-string">"Are you OK?"</span>),                                              QMessageBox::Yes | QMessageBox::No,                                              QMessageBox::Yes)) {    QMessageBox::<span class="hljs-built_in">information</span>(<span class="hljs-keyword">this</span>, <span class="hljs-built_in">tr</span>(<span class="hljs-string">"Hmmm..."</span>),                              <span class="hljs-built_in">tr</span>(<span class="hljs-string">"I'm glad to hear that!"</span>));} <span class="hljs-keyword">else</span> {    QMessageBox::<span class="hljs-built_in">information</span>(<span class="hljs-keyword">this</span>, <span class="hljs-built_in">tr</span>(<span class="hljs-string">"Hmmm..."</span>),                              <span class="hljs-built_in">tr</span>(<span class="hljs-string">"I'm sorry!"</span>));}</code></pre></div><p>我们使用QMessageBox::question()来询问一个问题。</p><ol><li>这个对话框的父窗口是 this。</li></ol><p>QMessageBox是QDialog的子类，这意味着它的初始显示位置将会是在 parent 窗口的中央。</p><ol start="2"><li><p>第二个参数是对话框的标题。</p></li><li><p>第三个参数是我们想要显示的内容。</p></li><li><p>第四个参数是关联的按键类型，我们可以使用或运算符（|）指定对话框应该出现的按钮。比如我们希望是一个 Yes 和一个 No。</p></li><li><p>最后一个参数指定默认选择的按钮。</p></li></ol><p>这个函数有一个返回值，用于确定用户点击的是哪一个按钮。按照我们的写法，应该很容易的看出，这是一个模态对话框，因此我们可以直接获取其返回值。</p><p>QMessageBox类的 static 函数优点是方便使用，缺点也很明显：非常不灵活。我们只能使用简单的几种形式。为了能够定制QMessageBox细节，我们必须使用QMessageBox的属性设置 API。如果我们希望制作一个询问是否保存的对话框，我们可以使用如下的代码：</p><div class="code-wrapper"><pre><code class="hljs c++">QMessageBox msgBox;msgBox.<span class="hljs-built_in">setText</span>(<span class="hljs-built_in">tr</span>(<span class="hljs-string">"The document has been modified."</span>));msgBox.<span class="hljs-built_in">setInformativeText</span>(<span class="hljs-built_in">tr</span>(<span class="hljs-string">"Do you want to save your changes?"</span>));msgBox.<span class="hljs-built_in">setDetailedText</span>(<span class="hljs-built_in">tr</span>(<span class="hljs-string">"Differences here..."</span>));msgBox.<span class="hljs-built_in">setStandardButtons</span>(QMessageBox::Save;                           QMessageBox::Discard;                            QMessageBox::Cancel);msgBox.<span class="hljs-built_in">setDefaultButton</span>(QMessageBox::Save);<span class="hljs-type">int</span> ret = msgBox.<span class="hljs-built_in">exec</span>();<span class="hljs-keyword">switch</span> (ret) {    <span class="hljs-keyword">case</span> QMessageBox::Save:      <span class="hljs-built_in">qDebug</span>() &lt;&lt; <span class="hljs-string">"Save document!"</span>;      <span class="hljs-keyword">break</span>;    <span class="hljs-keyword">case</span> QMessageBox::Discard:      <span class="hljs-built_in">qDebug</span>() &lt;&lt; <span class="hljs-string">"Discard changes!"</span>;      <span class="hljs-keyword">break</span>;    <span class="hljs-keyword">case</span> QMessageBox::Cancel:      <span class="hljs-built_in">qDebug</span>() &lt;&lt; <span class="hljs-string">"Close document!"</span>;      <span class="hljs-keyword">break</span>;}</code></pre></div><p>msgBox 是一个建立在栈上的QMessageBox实例。我们设置其主要文本信息为“The document has been modified.”，informativeText 则是会在对话框中显示的简单说明文字。下面我们使用了一个detailedText，也就是详细信息，当我们点击了详细信息按钮时，对话框可以自动显示更多信息。我们自己定义的对话框的按钮有三个：保存、丢弃和取消。然后我们使用了exec()是其成为一个模态对话框，根据其返回值进行相应的操作。</p><h2><span id="6-5-biao-zhun-wen-jian-dui-hua-kuang">6.5 标准文件对话框</span><a href="#6-5-biao-zhun-wen-jian-dui-hua-kuang" class="header-anchor">#</a></h2><p>QFileDialog，也就是文件对话框。在本节中，我们将尝试编写一个简单的文本文件编辑器，我们将使用QFileDialog来打开一个文本文件，并将修改过的文件保存到硬盘。</p><p>首先，我们需要创建一个带有文本编辑功能的窗口。借用我们前面的程序代码，应该可以很方便地完成：</p><div class="code-wrapper"><pre><code class="hljs c++">openAction = <span class="hljs-keyword">new</span> <span class="hljs-built_in">QAction</span>(<span class="hljs-built_in">QIcon</span>(<span class="hljs-string">":/images/file-open"</span>),<span class="hljs-built_in">tr</span>(<span class="hljs-string">"&amp;Open..."</span>), <span class="hljs-keyword">this</span>);openAction-&gt;<span class="hljs-built_in">setStatusTip</span>(<span class="hljs-built_in">tr</span>(<span class="hljs-string">"Open an existing file"</span>));saveAction = <span class="hljs-keyword">new</span> <span class="hljs-built_in">QAction</span>(<span class="hljs-built_in">QIcon</span>(<span class="hljs-string">":/images/file-save"</span>), <span class="hljs-built_in">tr</span>(<span class="hljs-string">"&amp;Save..."</span>), <span class="hljs-keyword">this</span>);saveAction-&gt;<span class="hljs-built_in">setStatusTip</span>(<span class="hljs-built_in">tr</span>(<span class="hljs-string">"Save a new file"</span>)); QMenu *file = <span class="hljs-built_in">menuBar</span>()-&gt;<span class="hljs-built_in">addMenu</span>(<span class="hljs-built_in">tr</span>(<span class="hljs-string">"&amp;File"</span>));file-&gt;<span class="hljs-built_in">addAction</span>(openAction);file-&gt;<span class="hljs-built_in">addAction</span>(saveAction);QToolBar *toolBar = <span class="hljs-built_in">addToolBar</span>(<span class="hljs-built_in">tr</span>(<span class="hljs-string">"&amp;File"</span>));toolBar-&gt;<span class="hljs-built_in">addAction</span>(openAction);toolBar-&gt;<span class="hljs-built_in">addAction</span>(saveAction);textEdit = <span class="hljs-keyword">new</span> <span class="hljs-built_in">QTextEdit</span>(<span class="hljs-keyword">this</span>);<span class="hljs-built_in">setCentralWidget</span>(textEdit);</code></pre></div><p>我们在菜单和工具栏添加了两个动作：打开和保存。接下来是一个QTextEdit类，这个类用于显示富文本文件。也就是说，它不仅仅用于显示文本，还可以显示图片、表格等等。不过，我们现在只用它显示纯文本文件。QMainWindow有一个setCentralWidget()函数，可以将一个组件作为窗口的中心组件，放在窗口中央显示区。显然，在一个文本编辑器中，文本编辑区就是这个中心组件，因此我们将QTextEdit作为这种组件。</p><p>我们使用connect()函数，为这两个QAction对象添加响应的动作：</p><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-built_in">connect</span>(openAction, &amp;QAction::triggered,         <span class="hljs-keyword">this</span>, &amp;MainWindow::openFile);<span class="hljs-built_in">connect</span>(saveAction, &amp;QAction::triggered,         <span class="hljs-keyword">this</span>, &amp;MainWindow::saveFile);</code></pre></div><p>下面是最主要的openFile()和saveFile()这两个函数的代码：</p><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-comment">//打开文件</span><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">MainWindow::openFile</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>{    QString path = QFileDialog::<span class="hljs-built_in">getOpenFileName</span>(<span class="hljs-keyword">this</span>,                                                <span class="hljs-built_in">tr</span>(<span class="hljs-string">"Open File"</span>), <span class="hljs-string">"."</span>, <span class="hljs-built_in">tr</span>(<span class="hljs-string">"Text Files(*.txt)"</span>));    <span class="hljs-keyword">if</span>(!path.<span class="hljs-built_in">isEmpty</span>())     {        <span class="hljs-function">QFile <span class="hljs-title">file</span><span class="hljs-params">(path)</span></span>;        <span class="hljs-keyword">if</span> (!file.<span class="hljs-built_in">open</span>(QIODevice::ReadOnly | QIODevice::Text))         {            QMessageBox::<span class="hljs-built_in">warning</span>(<span class="hljs-keyword">this</span>, <span class="hljs-built_in">tr</span>(<span class="hljs-string">"Read File"</span>),                                 <span class="hljs-built_in">tr</span>(<span class="hljs-string">"Cannot open file:\n%1"</span>).<span class="hljs-built_in">arg</span>(path));            <span class="hljs-keyword">return</span>;        }        <span class="hljs-function">QTextStream <span class="hljs-title">in</span><span class="hljs-params">(&amp;file)</span></span>;        textEdit-&gt;<span class="hljs-built_in">setText</span>(in.<span class="hljs-built_in">readAll</span>());        file.<span class="hljs-built_in">close</span>();    }     <span class="hljs-keyword">else</span>     {        QMessageBox::<span class="hljs-built_in">warning</span>(<span class="hljs-keyword">this</span>, <span class="hljs-built_in">tr</span>(<span class="hljs-string">"Path"</span>),                             <span class="hljs-built_in">tr</span>(<span class="hljs-string">"You did not select any file."</span>));    }}<span class="hljs-comment">//保存文件</span><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">MainWindow::saveFile</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>{    QString path = QFileDialog::<span class="hljs-built_in">getSaveFileName</span>(<span class="hljs-keyword">this</span>,                                                <span class="hljs-built_in">tr</span>(<span class="hljs-string">"Open File"</span>), <span class="hljs-string">"."</span>, <span class="hljs-built_in">tr</span>(<span class="hljs-string">"Text Files(*.txt)"</span>));    <span class="hljs-keyword">if</span>(!path.<span class="hljs-built_in">isEmpty</span>())     {        <span class="hljs-function">QFile <span class="hljs-title">file</span><span class="hljs-params">(path)</span></span>;        <span class="hljs-keyword">if</span> (!file.<span class="hljs-built_in">open</span>(QIODevice::WriteOnly | QIODevice::Text))         {            QMessageBox::<span class="hljs-built_in">warning</span>(<span class="hljs-keyword">this</span>, <span class="hljs-built_in">tr</span>(<span class="hljs-string">"Write File"</span>),                                 <span class="hljs-built_in">tr</span>(<span class="hljs-string">"Cannot open file:\n%1"</span>).<span class="hljs-built_in">arg</span>(path));            <span class="hljs-keyword">return</span>;        }        <span class="hljs-function">QTextStream <span class="hljs-title">out</span><span class="hljs-params">(&amp;file)</span></span>;        out &lt;&lt; textEdit-&gt;<span class="hljs-built_in">toPlainText</span>();        file.<span class="hljs-built_in">close</span>();    }     <span class="hljs-keyword">else</span>     {        QMessageBox::<span class="hljs-built_in">warning</span>(<span class="hljs-keyword">this</span>, <span class="hljs-built_in">tr</span>(<span class="hljs-string">"Path"</span>),                             <span class="hljs-built_in">tr</span>(<span class="hljs-string">"You did not select any file."</span>));    }}</code></pre></div><p>在openFile()函数中，我们使用QFileDialog::getOpenFileName()来获取需要打开的文件的路径。这个函数原型如下：</p><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-function">QString <span class="hljs-title">getOpenFileName</span><span class="hljs-params">(QWidget * parent = <span class="hljs-number">0</span>,</span></span><span class="hljs-params"><span class="hljs-function">                        <span class="hljs-type">const</span> QString &amp; caption = QString(),</span></span><span class="hljs-params"><span class="hljs-function">                        <span class="hljs-type">const</span> QString &amp; dir = QString(),</span></span><span class="hljs-params"><span class="hljs-function">                        <span class="hljs-type">const</span> QString &amp; filter = QString(),</span></span><span class="hljs-params"><span class="hljs-function">                        QString * selectedFilter = <span class="hljs-number">0</span>,</span></span><span class="hljs-params"><span class="hljs-function">                        Options options = <span class="hljs-number">0</span>)</span></span></code></pre></div><p>不过注意，它的所有参数都是可选的，因此在一定程度上说，这个函数也是简单的。这六个参数分别是：</p><ul><li>parent：父窗口。</li></ul><p>Qt 的标准对话框提供静态函数，用于返回一个模态对话框；</p><ul><li><p>caption：对话框标题；</p></li><li><p>dir：对话框打开时的默认目录</p></li><li><p>“.” 代表程序运行目录</p></li><li><p>“/” 代表当前盘符的根目录（特指 Windows 平台；Linux 平台当然就是根目录），这个参数也可以是平台相关的，比如“C:\”等；</p></li><li><p>filter：过滤器。</p></li></ul><p>我们使用文件对话框可以浏览很多类型的文件，但是，很多时候我们仅希望打开特定类型的文件。比如，文本编辑器希望打开文本文件，图片浏览器希望打开图片文件。过滤器就是用于过滤特定的后缀名。如果我们使用“Image Files(<em>.jpg <em>.png)”，则只能显示后缀名是 jpg 或者 png 的文件。如果需要多个过滤器，使用“;;”分割，比如“JPEG Files(</em>.jpg);;PNG Files(</em>.png)”；</p><ul><li><p>selectedFilter：默认选择的过滤器；</p></li><li><p>options：对话框的一些参数设定</p></li></ul><p>比如只显示文件夹等等，它的取值是enum QFileDialog::Option，每个选项可以使用 | 运算组合起来。</p><p>QFileDialog::getOpenFileName()返回值是选择的文件路径。我们将其赋值给 path。通过判断 path 是否为空，可以确定用户是否选择了某一文件。只有当用户选择了一个文件时，我们才执行下面的操作。</p><p>在saveFile()中使用的QFileDialog::getSaveFileName()也是类似的。使用这种静态函数，在 Windows、Mac OS 上面都是直接调用本地对话框，但是 Linux 上则是QFileDialog自己的模拟。这暗示了，如果你不使用这些静态函数，而是直接使用QFileDialog进行设置，那么得到的对话框很可能与系统对话框的外观不一致。这一点是需要注意的。</p><h1><span id="7-bu-ju-guan-li-qi">7 布局管理器</span><a href="#7-bu-ju-guan-li-qi" class="header-anchor">#</a></h1><p>所谓 GUI 界面，归根结底，就是一堆组件的叠加。我们创建一个窗口，把按钮放上面，把图标放上面，这样就成了一个界面。在放置时，组件的位置尤其重要。我们必须要指定组件放在哪里，以便窗口能够按照我们需要的方式进行渲染。这就涉及到组件定位的机制。</p><p>Qt 提供了两种组件定位机制：绝对定位和布局定位。</p><ul><li>绝对定位就是一种最原始的定位方法：给出这个组件的坐标和长宽值。</li></ul><p>这样，Qt 就知道该把组件放在哪里以及如何设置组件的大小。但是这样做带来的一个问题是，如果用户改变了窗口大小，比如点击最大化按钮或者使用鼠标拖动窗口边缘，采用绝对定位的组件是不会有任何响应的。这也很自然，因为你并没有告诉 Qt，在窗口变化时，组件是否要更新自己以及如何更新。或者，还有更简单的方法：禁止用户改变窗口大小。但这总不是长远之计。</p><ul><li>布局定位：你只要把组件放入某一种布局，布局由专门的布局管理器进行管理。当需要调整大小或者位置的时候，Qt 使用对应的布局管理器进行调整。</li></ul><p>布局定位完美的解决了使用绝对定位的缺陷。</p><p>Qt 提供的布局中以下三种是我们最常用的：</p><ul><li><p>QHBoxLayout：按照水平方向从左到右布局；</p></li><li><p>QVBoxLayout：按照竖直方向从上到下布局；</p></li><li><p>QGridLayout：在一个网格中进行布局，类似于 HTML 的 table；</p></li></ul><h2><span id="7-1-xi-tong-ti-gong-de-bu-ju-kong-jian">7.1 系统提供的布局控件</span><a href="#7-1-xi-tong-ti-gong-de-bu-ju-kong-jian" class="header-anchor">#</a></h2><p><img src="https://gitee.com/txt1994/images/raw/master/img/QT/wps19.jpg" alt="img"> </p><p>这4个为系统给我们提供的布局的控件，但是使用起来不是非常的灵活，这里就不详细介绍了。</p><h2><span id="7-2-li-yong-widget-zuo-bu-ju">7.2 利用widget做布局</span><a href="#7-2-li-yong-widget-zuo-bu-ju" class="header-anchor">#</a></h2><p>第二种布局方式是利用控件里的widget来做布局，在Containers中</p><p><img src="https://gitee.com/txt1994/images/raw/master/img/QT/wps20.jpg" alt="img"> </p><p>在widget中的控件可以进行水平、垂直、栅格布局等操作，比较灵活。</p><p>再布局的同时我们需要灵活运用弹簧的特性让我们的布局更加的美观，下面是一个登陆窗口，利用widget可以搭建出如下登陆界面：</p><p><img src="https://gitee.com/txt1994/images/raw/master/img/QT/wps21.jpg" alt="img"> </p><h1><span id="8-chang-yong-kong-jian">8 常用控件</span><a href="#8-chang-yong-kong-jian" class="header-anchor">#</a></h1><p>Qt为我们应用程序界面开发提供的一系列的控件，下面我们介绍两种最常用一些控件，所有控件的使用方法我们都可以通过帮助文档获取。</p><h2><span id="8-1-qlabel-kong-jian-shi-yong">8.1 QLabel控件使用</span><a href="#8-1-qlabel-kong-jian-shi-yong" class="header-anchor">#</a></h2><p>QLabel是我们最常用的控件之一，其功能很强大，我们可以用来显示文本，图片和动画等。</p><h3><span id="xian-shi-wen-zi-pu-tong-wen-ben-html">显示文字 （普通文本、html）</span><a href="#xian-shi-wen-zi-pu-tong-wen-ben-html" class="header-anchor">#</a></h3><p>通过QLabel类的setText函数设置显示的内容:</p><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span><span class="hljs-title">setText</span><span class="hljs-params">(<span class="hljs-type">const</span> QString &amp;)</span></span>;</code></pre></div><ul><li>可以显示普通文本字符串</li></ul> <div class="code-wrapper"><pre><code class="hljs c++">QLable *label = <span class="hljs-keyword">new</span> QLable;label-&gt;<span class="hljs-built_in">setText</span>(“Hello, World!”);</code></pre></div><ul><li>可以显示HTML格式的字符串</li></ul><p>比如显示一个链接:</p><div class="code-wrapper"><pre><code class="hljs c++">QLabel * label = <span class="hljs-keyword">new</span> <span class="hljs-built_in">QLabel</span>(<span class="hljs-keyword">this</span>);label -&gt;<span class="hljs-built_in">setText</span>(<span class="hljs-string">"Hello, World"</span>);label -&gt;<span class="hljs-built_in">setText</span>(<span class="hljs-string">"&lt;h1&gt;&lt;a href=\"https://www.baidu.com\"&gt;百度一下&lt;/a&gt;&lt;/h1&gt;"</span>);label -&gt;<span class="hljs-built_in">setOpenExternalLinks</span>(<span class="hljs-literal">true</span>);</code></pre></div><p>其中setOpenExternalLinks()函数是用来设置用户点击链接之后是否自动打开链接，如果参数指定为true则会自动打开。</p><h3><span id="xian-shi-tu-pian">显示图片</span><a href="#xian-shi-tu-pian" class="header-anchor">#</a></h3><p>可以使用QLabel的成员函数setPixmap设置图片</p><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">setPixmap</span><span class="hljs-params">(<span class="hljs-type">const</span> QPixmap &amp;)</span></span></code></pre></div><p>首先定义QPixmap对象</p><div class="code-wrapper"><pre><code class="hljs c++">QPixmap pixmap;</code></pre></div><p>然后加载图片</p><div class="code-wrapper"><pre><code class="hljs c++">pixmap.<span class="hljs-built_in">load</span>(<span class="hljs-string">":/Image/boat.jpg"</span>);</code></pre></div><p>最后将图片设置到QLabel中</p><div class="code-wrapper"><pre><code class="hljs c++">QLabel *label = <span class="hljs-keyword">new</span> QLabel;label.<span class="hljs-built_in">setPixmap</span>(pixmap);</code></pre></div><h3><span id="xian-shi-dong-hua">显示动画</span><a href="#xian-shi-dong-hua" class="header-anchor">#</a></h3><p>可以使用QLabel 的成员函数setMovie加载动画，可以播放gif格式的文件</p><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span><span class="hljs-title">setMovie</span><span class="hljs-params">(QMovie * movie)</span></span></code></pre></div><p>首先定义QMovied对象，并初始化:</p><div class="code-wrapper"><pre><code class="hljs c++">QMovie *movie = <span class="hljs-keyword">new</span> <span class="hljs-built_in">QMovie</span>(<span class="hljs-string">":/Mario.gif"</span>);</code></pre></div><p>播放加载的动画：</p><div class="code-wrapper"><pre><code class="hljs c++">movie-&gt;<span class="hljs-built_in">start</span>();</code></pre></div><p>将动画设置到QLabel中：</p><div class="code-wrapper"><pre><code class="hljs c++">QLabel *label = <span class="hljs-keyword">new</span> QLabel；label-&gt;<span class="hljs-built_in">setMovie</span>(movie);</code></pre></div><h2><span id="8-2-qlineedit">8.2 QLineEdit</span><a href="#8-2-qlineedit" class="header-anchor">#</a></h2><p>Qt提供的单行文本编辑框。</p><h4><span id="she-zhi-huo-qu-nei-rong">设置/获取内容</span><a href="#she-zhi-huo-qu-nei-rong" class="header-anchor">#</a></h4><ul><li>获取编辑框内容使用text（），函数声明如下：</li></ul><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-function">QString<span class="hljs-title">text</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span></code></pre></div><ul><li>设置编辑框内容</li></ul><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span><span class="hljs-title">setText</span><span class="hljs-params">(<span class="hljs-type">const</span> QString &amp;)</span></span>;</code></pre></div><h4><span id="she-zhi-xian-shi-mo-shi">设置显示模式</span><a href="#she-zhi-xian-shi-mo-shi" class="header-anchor">#</a></h4><p>使用QLineEdit类的setEchoMode () 函数设置文本的显示模式,函数声明:</p><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span><span class="hljs-title">setEchoMode</span><span class="hljs-params">(EchoMode mode)</span></span></code></pre></div><p>EchoMode是一个枚举类型,一共定义了四种显示模式:</p><ul><li><p>QLineEdit::Normal     模式显示方式，按照输入的内容显示。</p></li><li><p>QLineEdit::NoEcho    不显示任何内容，此模式下无法看到用户的输入。</p></li><li><p>QLineEdit::Password    密码模式，输入的字符会根据平台转换为特殊字符。</p></li><li><p>QLineEdit::PasswordEchoOnEdit    编辑时显示字符否则显示字符作为密码。</p></li></ul><p>另外，我们再使用QLineEdit显示文本的时候，希望在左侧留出一段空白的区域，那么，就可以使用QLineEdit给我们提供的setTextMargins函数：</p><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">setTextMargins</span><span class="hljs-params">(<span class="hljs-type">int</span> left, <span class="hljs-type">int</span> top, <span class="hljs-type">int</span> right, <span class="hljs-type">int</span> bottom)</span></span></code></pre></div><p>用此函数可以指定显示的文本与输入框上下左右边界的间隔的像素数。</p><h2><span id="8-3-qi-ta-kong-jian">8.3 其他控件</span><a href="#8-3-qi-ta-kong-jian" class="header-anchor">#</a></h2><p>Qt中控件的使用方法可参考Qt提供的帮助文档。</p><h2><span id="8-4-zi-ding-yi-kong-jian">8.4 自定义控件</span><a href="#8-4-zi-ding-yi-kong-jian" class="header-anchor">#</a></h2><p>在搭建Qt窗口界面的时候，在一个项目中很多窗口，或者是窗口中的某个模块会被经常性的重复使用。一般遇到这种情况我们都会将这个窗口或者模块拿出来做成一个独立的窗口类，以备以后重复使用。</p><p>在使用Qt的ui文件搭建界面的时候，工具栏栏中只为我们提供了标准的窗口控件，如果我们想使用自定义控件怎么办？</p><p>例如：我们从QWidget派生出一个类SmallWidget，实现了一个自定窗口，</p><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-comment">// smallwidget.h</span><span class="hljs-keyword">class</span> <span class="hljs-title class_">SmallWidget</span> : <span class="hljs-keyword">public</span> QWidget{    Q_OBJECT<span class="hljs-keyword">public</span>:    <span class="hljs-function"><span class="hljs-keyword">explicit</span> <span class="hljs-title">SmallWidget</span><span class="hljs-params">(QWidget *parent = <span class="hljs-number">0</span>)</span></span>;signals:<span class="hljs-keyword">public</span> slots:<span class="hljs-keyword">private</span>:    QSpinBox* spin;    QSlider* slider;};<span class="hljs-comment">// smallwidget.cpp</span>SmallWidget::<span class="hljs-built_in">SmallWidget</span>(QWidget *parent) : <span class="hljs-built_in">QWidget</span>(parent){    spin = <span class="hljs-keyword">new</span> <span class="hljs-built_in">QSpinBox</span>(<span class="hljs-keyword">this</span>);    slider = <span class="hljs-keyword">new</span> <span class="hljs-built_in">QSlider</span>(Qt::Horizontal, <span class="hljs-keyword">this</span>);    <span class="hljs-comment">// 创建布局对象</span>    QHBoxLayout* layout = <span class="hljs-keyword">new</span> QHBoxLayout;    <span class="hljs-comment">// 将控件添加到布局中</span>    layout-&gt;<span class="hljs-built_in">addWidget</span>(spin);    layout-&gt;<span class="hljs-built_in">addWidget</span>(slider);    <span class="hljs-comment">// 将布局设置到窗口中</span>    <span class="hljs-built_in">setLayout</span>(layout);    <span class="hljs-comment">// 添加消息响应</span>    <span class="hljs-built_in">connect</span>(spin,             <span class="hljs-built_in">static_cast</span>&lt;<span class="hljs-built_in">void</span> (QSpinBox::*)(<span class="hljs-type">int</span>)&gt;(&amp;QSpinBox::valueChanged),            slider, &amp;QSlider::setValue);    <span class="hljs-built_in">connect</span>(slider, &amp;QSlider::valueChanged,             spin, &amp;QSpinBox::setValue);}</code></pre></div><p><img src="https://gitee.com/txt1994/images/raw/master/img/QT/wps22.jpg" alt="img"> </p><p>那么这个SmallWidget可以作为独立的窗口显示,也可以作为一个控件来使用：</p><p>打开Qt的.ui文件,因为SmallWidget是派生自Qwidget类,所以需要在ui文件中先放入一个QWidget控件, 然后再上边鼠标右键</p><p><img src="https://gitee.com/txt1994/images/raw/master/img/QT/wps23.jpg" alt="img"> </p><p>弹出提升窗口部件对话框</p><p><img src="https://gitee.com/txt1994/images/raw/master/img/QT/wps24.jpg" alt="img"> </p><p>添加要提升的类的名字,然后选择 添加 </p><p><img src="https://gitee.com/txt1994/images/raw/master/img/QT/wps25.jpg" alt="img"> </p><p>添加之后,类名会显示到上边的列表框中,然后单击提升按钮,完成操作.</p><p>我们可以看到, 这个窗口对应的类从原来的QWidget变成了SmallWidget</p><p><img src="https://gitee.com/txt1994/images/raw/master/img/QT/wps26.jpg" alt="img"> </p><p>再次运行程序,这个widget_3中就能显示出我们自定义的窗口了.</p><h1><span id="9-qt-xiao-xi-ji-zhi-he-shi-jian">9 Qt消息机制和事件</span><a href="#9-qt-xiao-xi-ji-zhi-he-shi-jian" class="header-anchor">#</a></h1><h2><span id="9-1-shi-jian">9.1 事件</span><a href="#9-1-shi-jian" class="header-anchor">#</a></h2><p>事件（event）是由系统或者 Qt 本身在不同的时刻发出的。当用户按下鼠标、敲下键盘，或者是窗口需要重新绘制的时候，都会发出一个相应的事件。一些事件在对用户操作做出响应时发出，如键盘事件等；另一些事件则是由系统自动发出，如计时器事件。</p><p>在前面我们也曾经简单提到，Qt 程序需要在main()函数创建一个QApplication对象，然后调用它的exec()函数。这个函数就是开始 Qt 的事件循环。在执行exec()函数之后，程序将进入事件循环来监听应用程序的事件。当事件发生时，Qt 将创建一个事件对象。Qt 中所有事件类都继承于QEvent。在事件对象创建完毕后，Qt 将这个事件对象传递给QObject的event()函数。event()函数并不直接处理事件，而是按照事件对象的类型分派给特定的事件处理函数（event handler），关于这一点，会在后边详细说明。</p><p>在所有组件的父类QWidget中，定义了很多事件处理的回调函数，如</p><ul><li><p>keyPressEvent()</p></li><li><p>keyReleaseEvent()</p></li><li><p>mouseDoubleClickEvent()</p></li><li><p>mouseMoveEvent()</p></li><li><p>mousePressEvent()</p></li><li><p>mouseReleaseEvent() 等。</p></li></ul><p>这些函数都是 protected virtual 的，也就是说，我们可以在子类中重新实现这些函数。下面来看一个例子：</p><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">EventLabel</span> : <span class="hljs-keyword">public</span> QLabel{    <span class="hljs-keyword">protected</span>:    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">mouseMoveEvent</span><span class="hljs-params">(QMouseEvent *event)</span></span>;    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">mousePressEvent</span><span class="hljs-params">(QMouseEvent *event)</span></span>;    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">mouseReleaseEvent</span><span class="hljs-params">(QMouseEvent *event)</span></span>;};<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">EventLabel::mouseMoveEvent</span><span class="hljs-params">(QMouseEvent *event)</span></span><span class="hljs-function"></span>{    <span class="hljs-keyword">this</span>-&gt;<span class="hljs-built_in">setText</span>(<span class="hljs-built_in">QString</span>(<span class="hljs-string">"&lt;center&gt;&lt;h1&gt;Move: (%1, %2)</span><span class="hljs-string">                          &lt;/h1&gt;&lt;/center&gt;"</span>).<span class="hljs-built_in">arg</span>(QString::<span class="hljs-built_in">number</span>(event-&gt;<span class="hljs-built_in">x</span>()),                          QString::<span class="hljs-built_in">number</span>(event-&gt;<span class="hljs-built_in">y</span>())));}<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">EventLabel::mousePressEvent</span><span class="hljs-params">(QMouseEvent *event)</span></span><span class="hljs-function"></span>{    <span class="hljs-keyword">this</span>-&gt;<span class="hljs-built_in">setText</span>(<span class="hljs-built_in">QString</span>(<span class="hljs-string">"&lt;center&gt;&lt;h1&gt;Press:(%1, %2)</span><span class="hljs-string">                          &lt;/h1&gt;&lt;/center&gt;"</span>).<span class="hljs-built_in">arg</span>(QString::<span class="hljs-built_in">number</span>(event-&gt;<span class="hljs-built_in">x</span>()),                          QString::<span class="hljs-built_in">number</span>(event-&gt;<span class="hljs-built_in">y</span>())));}<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">EventLabel::mouseReleaseEvent</span><span class="hljs-params">(QMouseEvent *event)</span></span><span class="hljs-function"></span>{    QString msg;    msg.<span class="hljs-built_in">sprintf</span>(<span class="hljs-string">"&lt;center&gt;&lt;h1&gt;Release: (%d, %d)&lt;/h1&gt;&lt;/center&gt;"</span>,                event-&gt;<span class="hljs-built_in">x</span>(), event-&gt;<span class="hljs-built_in">y</span>());    <span class="hljs-keyword">this</span>-&gt;<span class="hljs-built_in">setText</span>(msg);}<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> *argv[])</span></span><span class="hljs-function"></span>{    <span class="hljs-function">QApplication <span class="hljs-title">a</span><span class="hljs-params">(argc, argv)</span></span>;    EventLabel *label = <span class="hljs-keyword">new</span> EventLabel;    label-&gt;<span class="hljs-built_in">setWindowTitle</span>(<span class="hljs-string">"MouseEvent Demo"</span>);    label-&gt;<span class="hljs-built_in">resize</span>(<span class="hljs-number">300</span>, <span class="hljs-number">200</span>);    label-&gt;<span class="hljs-built_in">show</span>();    <span class="hljs-keyword">return</span> a.<span class="hljs-built_in">exec</span>();}</code></pre></div><ul><li><p>EventLabel继承了QLabel，覆盖了mousePressEvent()、mouseMoveEvent()和MouseReleaseEvent()三个函数。我们并没有添加什么功能，只是在鼠标按下（press）、鼠标移动（move）和鼠标释放（release）的时候，把当前鼠标的坐标值显示在这个Label上面。由于QLabel是支持 HTML 代码的，因此我们直接使用了 HTML 代码来格式化文字。</p></li><li><p>QString的arg()函数可以自动替换掉QString中出现的占位符。其占位符以 % 开始，后面是占位符的位置，例如 %1，%2 这种。</p></li></ul><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-built_in">QString</span>(<span class="hljs-string">"[%1, %2]"</span>).<span class="hljs-built_in">arg</span>(x).<span class="hljs-built_in">arg</span>(y);</code></pre></div><p>语句将会使用x替换 %1，y替换 %2，因此，生成的QString为[x, y]。</p><ul><li>在mouseReleaseEvent()函数中，我们使用了另外一种QString的构造方法。我们使用类似 C 风格的格式化函数sprintf()来构造QString。</li></ul><p>运行上面的代码，当我们点击了一下鼠标之后，label 上将显示鼠标当前坐标值。</p><p><img src="https://gitee.com/txt1994/images/raw/master/img/QT/wps27.jpg" alt="img"> </p><p>为什么要点击鼠标之后才能在mouseMoveEvent()函数中显示鼠标坐标值？</p><p>这是因为QWidget中有一个mouseTracking属性，该属性用于设置是否追踪鼠标。只有鼠标被追踪时，mouseMoveEvent()才会发出。如果mouseTracking是 false（默认即是），组件在至少一次鼠标点击之后，才能够被追踪，也就是能够发出mouseMoveEvent()事件。如果mouseTracking为 true，则mouseMoveEvent()直接可以被发出。</p><p>知道了这一点，我们就可以在main()函数中添加如下代码：</p><div class="code-wrapper"><pre><code class="hljs c++">label-&gt;<span class="hljs-built_in">setMouseTracking</span>(<span class="hljs-literal">true</span>);</code></pre></div><p>在运行程序就没有这个问题了。    </p><h2><span id="9-2-event">9.2 event（）</span><a href="#9-2-event" class="header-anchor">#</a></h2><p>事件对象创建完毕后，Qt 将这个事件对象传递给QObject的event()函数。event()函数并不直接处理事件，而是将这些事件对象按照它们不同的类型，分发给不同的事件处理器（event handler）。</p><p>如上所述，event()函数主要用于事件的分发。所以，如果你希望在事件分发之前做一些操作，就可以重写这个event()函数了。例如，我们希望在一个QWidget组件中监听 tab 键的按下，那么就可以继承QWidget，并重写它的event()函数，来达到这个目的：</p><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">CustomWidget::event</span><span class="hljs-params">(QEvent *e)</span></span><span class="hljs-function"></span>{    <span class="hljs-keyword">if</span> (e-&gt;<span class="hljs-built_in">type</span>() == QEvent::KeyPress) {        QKeyEvent *keyEvent = <span class="hljs-built_in">static_cast</span>&lt;QKeyEvent *&gt;(e);        <span class="hljs-keyword">if</span> (keyEvent-&gt;<span class="hljs-built_in">key</span>() == Qt::Key_Tab) {            <span class="hljs-built_in">qDebug</span>() &lt;&lt; <span class="hljs-string">"You press tab."</span>;            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;        }    }    <span class="hljs-keyword">return</span> QWidget::<span class="hljs-built_in">event</span>(e);}</code></pre></div><p>CustomWidget是一个普通的QWidget子类。我们重写了它的event()函数，这个函数有一个QEvent对象作为参数，也就是需要转发的事件对象。函数返回值是 bool 类型。</p><ul><li><p>如果传入的事件已被识别并且处理，则需要返回 true，否则返回 false。如果返回值是 true，那么 Qt 会认为这个事件已经处理完毕，不会再将这个事件发送给其它对象，而是会继续处理事件队列中的下一事件。</p></li><li><p>在event()函数中，调用事件对象的accept()和ignore()函数是没有作用的，不会影响到事件的传播。</p></li></ul><p>我们可以通过使用QEvent::type()函数可以检查事件的实际类型，其返回值是QEvent::Type类型的枚举。我们处理过自己感兴趣的事件之后，可以直接返回 true，表示我们已经对此事件进行了处理；对于其它我们不关心的事件，则需要调用父类的event()函数继续转发，否则这个组件就只能处理我们定义的事件了。为了测试这一种情况，我们可以尝试下面的代码：</p><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">CustomTextEdit::event</span><span class="hljs-params">(QEvent *e)</span></span><span class="hljs-function"></span>{    <span class="hljs-keyword">if</span> (e-&gt;<span class="hljs-built_in">type</span>() == QEvent::KeyPress)     {        QKeyEvent *keyEvent = <span class="hljs-built_in">static_cast</span>&lt;QKeyEvent *&gt;(e);        <span class="hljs-keyword">if</span> (keyEvent-&gt;<span class="hljs-built_in">key</span>() == Qt::Key_Tab)         {            <span class="hljs-built_in">qDebug</span>() &lt;&lt; <span class="hljs-string">"You press tab."</span>;            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;        }    }    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;}</code></pre></div><p>CustomTextEdit是QTextEdit的一个子类。我们重写了其event()函数，却没有调用父类的同名函数。这样，我们的组件就只能处理 Tab 键，再也无法输入任何文本，也不能响应其它事件，比如鼠标点击之后也不会有光标出现。这是因为我们只处理的KeyPress类型的事件，并且如果不是KeyPress事件，则直接返回 false，鼠标事件根本不会被转发，也就没有了鼠标事件。</p><p>通过查看QObject::event()的实现，我们可以理解，event()函数同前面的章节中我们所说的事件处理器有什么联系：</p><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-comment">//!!! Qt5</span><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">QObject::event</span><span class="hljs-params">(QEvent *e)</span></span><span class="hljs-function"></span>{    <span class="hljs-keyword">switch</span> (e-&gt;<span class="hljs-built_in">type</span>()) {        <span class="hljs-keyword">case</span> QEvent::Timer:            <span class="hljs-built_in">timerEvent</span>((QTimerEvent*)e);            <span class="hljs-keyword">break</span>;        <span class="hljs-keyword">case</span> QEvent::ChildAdded:        <span class="hljs-keyword">case</span> QEvent::ChildPolished:        <span class="hljs-keyword">case</span> QEvent::ChildRemoved:            <span class="hljs-built_in">childEvent</span>((QChildEvent*)e);            <span class="hljs-keyword">break</span>;            <span class="hljs-comment">// ...</span>        <span class="hljs-keyword">default</span>:            <span class="hljs-keyword">if</span> (e-&gt;<span class="hljs-built_in">type</span>() &gt;= QEvent::User) {                <span class="hljs-built_in">customEvent</span>(e);                <span class="hljs-keyword">break</span>;            }            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;    }    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;}</code></pre></div><p>这是 Qt 5 中QObject::event()函数的源代码（Qt 4 的版本也是类似的）。我们可以看到，同前面我们所说的一样，Qt 也是使用QEvent::type()判断事件类型，然后调用了特定的事件处理器。比如，如果event-&gt;type()返回值是QEvent::Timer，则调用timerEvent()函数。可以想象，QWidget::event()中一定会有如下的代码：</p><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">switch</span> (event-&gt;<span class="hljs-built_in">type</span>()) {    <span class="hljs-keyword">case</span> QEvent::MouseMove:        <span class="hljs-built_in">mouseMoveEvent</span>((QMouseEvent*)event);        <span class="hljs-keyword">break</span>;        <span class="hljs-comment">// ...</span>}</code></pre></div><p>事实也的确如此。timerEvent()和mouseMoveEvent()这样的函数，就是我们前面章节所说的事件处理器 event handler。也就是说，event()函数中实际是通过事件处理器来响应一个具体的事件。这相当于event()函数将具体事件的处理“委托”给具体的事件处理器。而这些事件处理器是 protected virtual 的，因此，我们重写了某一个事件处理器，即可让 Qt 调用我们自己实现的版本。</p><p>由此可以见，event()是一个集中处理不同类型的事件的地方。如果你不想重写一大堆事件处理器，就可以重写这个event()函数，通过<code>QEvent::type()</code>判断不同的事件。鉴于重写event()函数需要十分小心注意父类的同名函数的调用，一不留神就可能出现问题，所以一般还是建议只重写事件处理器（当然，也必须记得是不是应该调用父类的同名处理器）。这其实暗示了event()函数的另外一个作用：屏蔽掉某些不需要的事件处理器。正如我们前面的CustomTextEdit例子看到的那样，我们创建了一个只能响应 tab 键的组件。这种作用是重写事件处理器所不能实现的。</p><h2><span id="9-3-shi-jian-guo-lu-qi">9.3 事件过滤器</span><a href="#9-3-shi-jian-guo-lu-qi" class="header-anchor">#</a></h2><p>有时候，对象需要查看、甚至要拦截发送到另外对象的事件。例如，对话框可能想要拦截按键事件，不让别的组件接收到；或者要修改回车键的默认处理。</p><p>通过前面的章节，我们已经知道，Qt 创建了QEvent事件对象之后，会调用QObject的event()函数处理事件的分发。显然，我们可以在event()函数中实现拦截的操作。由于event()函数是 protected 的，因此，需要继承已有类。如果组件很多，就需要重写很多个event()函数。这当然相当麻烦，更不用说重写event()函数还得小心一堆问题。好在 Qt 提供了另外一种机制来达到这一目的：事件过滤器。</p><p>QObject有一个eventFilter()函数，用于建立事件过滤器。函数原型如下：</p><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">bool</span> <span class="hljs-title">QObject::eventFilter</span> <span class="hljs-params">( QObject * watched, QEvent * event )</span></span>;</code></pre></div><p>这个函数正如其名字显示的那样，是一个“事件过滤器”。所谓事件过滤器，可以理解成一种过滤代码。事件过滤器会检查接收到的事件。如果这个事件是我们感兴趣的类型，就进行我们自己的处理；如果不是，就继续转发。这个函数返回一个 bool 类型，如果你想将参数 event 过滤出来，比如，不想让它继续转发，就返回 true，否则返回 false。事件过滤器的调用时间是目标对象（也就是参数里面的watched对象）接收到事件对象之前。也就是说，如果你在事件过滤器中停止了某个事件，那么，watched对象以及以后所有的事件过滤器根本不会知道这么一个事件。</p><p>我们来看一段简单的代码：</p><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MainWindow</span> : <span class="hljs-keyword">public</span> QMainWindow{<span class="hljs-keyword">public</span>:    <span class="hljs-built_in">MainWindow</span>();<span class="hljs-keyword">protected</span>:    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">eventFilter</span><span class="hljs-params">(QObject *obj, QEvent *event)</span></span>;<span class="hljs-keyword">private</span>:    QTextEdit *textEdit;};MainWindow::<span class="hljs-built_in">MainWindow</span>(){    textEdit = <span class="hljs-keyword">new</span> QTextEdit;    <span class="hljs-built_in">setCentralWidget</span>(textEdit);    textEdit-&gt;<span class="hljs-built_in">installEventFilter</span>(<span class="hljs-keyword">this</span>);}<span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">MainWindow::eventFilter</span><span class="hljs-params">(QObject *obj, QEvent *event)</span></span><span class="hljs-function"></span>{    <span class="hljs-keyword">if</span> (obj == textEdit) {        <span class="hljs-keyword">if</span> (event-&gt;<span class="hljs-built_in">type</span>() == QEvent::KeyPress) {            QKeyEvent *keyEvent = <span class="hljs-built_in">static_cast</span>&lt;QKeyEvent *&gt;(event);            <span class="hljs-built_in">qDebug</span>() &lt;&lt; <span class="hljs-string">"Ate key press"</span> &lt;&lt; keyEvent-&gt;<span class="hljs-built_in">key</span>();            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;        } <span class="hljs-keyword">else</span> {            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;        }    } <span class="hljs-keyword">else</span> {        <span class="hljs-comment">// pass the event on to the parent class</span>        <span class="hljs-keyword">return</span> QMainWindow::<span class="hljs-built_in">eventFilter</span>(obj, event);    }}</code></pre></div><ul><li><p>MainWindow是我们定义的一个类。我们重写了它的eventFilter()函数。为了过滤特定组件上的事件，首先需要判断这个对象是不是我们感兴趣的组件，然后判断这个事件的类型。在上面的代码中，我们不想让textEdit组件处理键盘按下的事件。所以，首先我们找到这个组件，如果这个事件是键盘事件，则直接返回 true，也就是过滤掉了这个事件，其他事件还是要继续处理，所以返回 false。对于其它的组件，我们并不保证是不是还有过滤器，于是最保险的办法是调用父类的函数。</p></li><li><p>eventFilter()函数相当于创建了过滤器，然后我们需要安装这个过滤器。安装过滤器需要调用QObject::installEventFilter()函数。函数的原型如下：</p></li></ul><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">QObject::installEventFilter</span> <span class="hljs-params">( QObject * filterObj )</span></span></code></pre></div><p>这个函数接受一个QObject *类型的参数。记得刚刚我们说的，eventFilter()函数是QObject的一个成员函数，因此，任意QObject都可以作为事件过滤器（问题在于，如果你没有重写eventFilter()函数，这个事件过滤器是没有任何作用的，因为默认什么都不会过滤）。已经存在的过滤器则可以通过QObject::removeEventFilter()函数移除。</p><ul><li>我们可以向一个对象上面安装多个事件处理器，只要调用多次installEventFilter()函数。如果一个对象存在多个事件过滤器，那么，最后一个安装的会第一个执行，也就是后进先执行的顺序。</li></ul><p>还记得我们前面的那个例子吗？我们使用event()函数处理了 Tab 键：</p><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">CustomWidget::event</span><span class="hljs-params">(QEvent *e)</span></span><span class="hljs-function"></span>{    <span class="hljs-keyword">if</span> (e-&gt;<span class="hljs-built_in">type</span>() == QEvent::KeyPress) {        QKeyEvent *keyEvent = <span class="hljs-built_in">static_cast</span>&lt;QKeyEvent *&gt;(e);        <span class="hljs-keyword">if</span> (keyEvent-&gt;<span class="hljs-built_in">key</span>() == Qt::Key_Tab) {            <span class="hljs-built_in">qDebug</span>() &lt;&lt; <span class="hljs-string">"You press tab."</span>;            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;        }    }    <span class="hljs-keyword">return</span> QWidget::<span class="hljs-built_in">event</span>(e);}</code></pre></div><p>现在，我们可以给出一个使用事件过滤器的版本：</p><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">FilterObject::eventFilter</span><span class="hljs-params">(QObject *object, QEvent *event)</span></span><span class="hljs-function"></span>{    <span class="hljs-keyword">if</span> (object == target &amp;&amp; event-&gt;<span class="hljs-built_in">type</span>() == QEvent::KeyPress)     {        QKeyEvent *keyEvent = <span class="hljs-built_in">static_cast</span>&lt;QKeyEvent *&gt;(event);        <span class="hljs-keyword">if</span> (keyEvent-&gt;<span class="hljs-built_in">key</span>() == Qt::Key_Tab) {            <span class="hljs-built_in">qDebug</span>() &lt;&lt; <span class="hljs-string">"You press tab."</span>;            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;        } <span class="hljs-keyword">else</span> {            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;        }    }    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;}</code></pre></div><p>事件过滤器的强大之处在于，我们可以为整个应用程序添加一个事件过滤器。记得，installEventFilter()函数是QObject的函数，QApplication或者QCoreApplication对象都是QObject的子类，因此，我们可以向QApplication或者QCoreApplication添加事件过滤器。这种全局的事件过滤器将会在所有其它特性对象的事件过滤器之前调用。尽管很强大，但这种行为会严重降低整个应用程序的事件分发效率。因此，除非是不得不使用的情况，否则的话我们不应该这么做。</p><p><strong>注意，</strong></p><p>事件过滤器和被安装过滤器的组件必须在同一线程，否则，过滤器将不起作用。另外，如果在安装过滤器之后，这两个组件到了不同的线程，那么，只有等到二者重新回到同一线程的时候过滤器才会有效。</p><h2><span id="9-4-zong-jie">9.4 总结</span><a href="#9-4-zong-jie" class="header-anchor">#</a></h2><p>Qt 的事件是整个 Qt 框架的核心机制之一，也比较复杂。说它复杂，更多是因为它涉及到的函数众多，而处理方法也很多，有时候让人难以选择。现在我们简单总结一下 Qt 中的事件机制。</p><p>Qt 中有很多种事件：鼠标事件、键盘事件、大小改变的事件、位置移动的事件等等。如何处理这些事件，实际有两种选择：</p><p>l 所有事件对应一个事件处理函数，在这个事件处理函数中用一个很大的分支语句进行选择，其代表作就是 win32 API 的WndProc()函数：</p><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-function">LRESULT CALLBACK <span class="hljs-title">WndProc</span><span class="hljs-params">(HWND hWnd,</span></span><span class="hljs-params"><span class="hljs-function">                         UINT message,</span></span><span class="hljs-params"><span class="hljs-function">                         WPARAM wParam,</span></span><span class="hljs-params"><span class="hljs-function">                         LPARAM lParam)</span></span>;</code></pre></div><p>在这个函数中，我们需要使用switch语句，选择message参数的类型进行处理，典型代码是：</p><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">switch</span>(message){    <span class="hljs-keyword">case</span> WM_PAINT:        <span class="hljs-comment">// ...</span>        <span class="hljs-keyword">break</span>;    <span class="hljs-keyword">case</span> WM_DESTROY:        <span class="hljs-comment">// ...</span>        <span class="hljs-keyword">break</span>;        ...}</code></pre></div><ul><li>每一种事件对应一个事件处理函数。Qt 就是使用的这么一种机制：</li></ul><p>mouseEvent()</p><p>keyPressEvent()</p><p>…</p><p>Qt 具有这么多种事件处理函数，肯定有一个地方对其进行分发，否则，Qt 怎么知道哪一种事件调用哪一个事件处理函数呢？这个分发的函数，就是event()。显然，当QMouseEvent产生之后，event()函数将其分发给mouseEvent()事件处理器进行处理。</p><p>event()函数会有两个问题：</p><ol><li><p>event()函数是一个 protected 的函数，这意味着我们要想重写event()，必须继承一个已有的类。试想，我的程序根本不想要鼠标事件，程序中所有组件都不允许处理鼠标事件，是不是我得继承所有组件，一一重写其event()函数？protected 函数带来的另外一个问题是，如果我基于第三方库进行开发，而对方没有提供源代码，只有一个链接库，其它都是封装好的。我怎么去继承这种库中的组件呢？</p></li><li><p>event()函数的确有一定的控制，不过有时候我的需求更严格一些：我希望那些组件根本看不到这种事件。event()函数虽然可以拦截，但其实也是接收到了QMouseEvent对象。我连让它收都收不到。这样做的好处是，模拟一种系统根本没有那个事件的效果，所以其它组件根本不会收到这个事件，也就无需修改自己的事件处理函数。这种需求怎么办呢？</p></li></ol><p>这两个问题是event()函数无法处理的。于是，Qt 提供了另外一种解决方案：事件过滤器。事件过滤器给我们一种能力，让我们能够完全移除某种事件。事件过滤器可以安装到任意QObject类型上面，并且可以安装多个。如果要实现全局的事件过滤器，则可以安装到QApplication或者QCoreApplication上面。这里需要注意的是，如果使用installEventFilter()函数给一个对象安装事件过滤器，那么该事件过滤器只对该对象有效，只有这个对象的事件需要先传递给事件过滤器的eventFilter()函数进行过滤，其它对象不受影响。如果给QApplication对象安装事件过滤器，那么该过滤器对程序中的每一个对象都有效，任何对象的事件都是先传给eventFilter()函数。</p><p>事件过滤器可以解决刚刚我们提出的event()函数的两点不足：</p><ol><li><p>首先，事件过滤器不是 protected 的，因此我们可以向任何QObject子类安装事件过滤器；</p></li><li><p>其次，事件过滤器在目标对象接收到事件之前进行处理，如果我们将事件过滤掉，目标对象根本不会见到这个事件。</p></li></ol><p>事实上，还有一种方法，我们没有介绍。Qt 事件的调用最终都会追溯到QCoreApplication::notify()函数，因此，最大的控制权实际上是重写QCoreApplication::notify()。这个函数的声明是：</p><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">bool</span> <span class="hljs-title">QCoreApplication::notify</span> <span class="hljs-params">( QObject * receiver,</span></span><span class="hljs-params"><span class="hljs-function">                                       QEvent * event )</span></span>;</code></pre></div><p>该函数会将event发送给receiver，也就是调用receiver-&gt;event(event)，其返回值就是来自receiver的事件处理器。注意，这个函数为任意线程的任意对象的任意事件调用，因此，它不存在事件过滤器的线程的问题。不过我们并不推荐这么做，因为notify()函数只有一个，而事件过滤器要灵活得多。</p><p>现在我们可以总结一下 Qt 的事件处理，实际上是有五个层次：</p><ol><li><p>重写paintEvent()、mousePressEvent()等事件处理函数。这是最普通、最简单的形式，同时功能也最简单。</p></li><li><p>重写event()函数。event()函数是所有对象的事件入口，QObject和QWidget中的实现，默认是把事件传递给特定的事件处理函数。</p></li><li><p>在特定对象上面安装事件过滤器。该过滤器仅过滤该对象接收到的事件。</p></li><li><p>在QCoreApplication::instance()上面安装事件过滤器。该过滤器将过滤所有对象的所有事件，因此和notify()函数一样强大，但是它更灵活，因为可以安装多个过滤器。全局的事件过滤器可以看到 disabled 组件上面发出的鼠标事件。全局过滤器有一个问题：只能用在主线程。</p></li><li><p>重写QCoreApplication::notify()函数。这是最强大的，和全局事件过滤器一样提供完全控制，并且不受线程的限制。但是全局范围内只能有一个被使用（因为QCoreApplication是单例的）。</p></li></ol><h1><span id="10-hui-tu-he-hui-tu-she-bei">10 绘图和绘图设备</span><a href="#10-hui-tu-he-hui-tu-she-bei" class="header-anchor">#</a></h1><h2><span id="10-1-qpainter">10.1 QPainter</span><a href="#10-1-qpainter" class="header-anchor">#</a></h2><p>Qt 的绘图系统允许使用相同的 API 在屏幕和其它打印设备上进行绘制。整个绘图系统基于QPainter，QPainterDevice和QPaintEngine三个类。</p><p>QPainter用来执行绘制的操作；QPaintDevice是一个二维空间的抽象，这个二维空间允许QPainter在其上面进行绘制，也就是QPainter工作的空间；QPaintEngine提供了画笔（QPainter）在不同的设备上进行绘制的统一的接口。QPaintEngine类应用于QPainter和QPaintDevice之间，通常对开发人员是透明的。除非你需要自定义一个设备，否则你是不需要关心QPaintEngine这个类的。我们可以把QPainter理解成画笔；把QPaintDevice理解成使用画笔的地方，比如纸张、屏幕等；而对于纸张、屏幕而言，肯定要使用不同的画笔绘制，为了统一使用一种画笔，我们设计了QPaintEngine类，这个类让不同的纸张、屏幕都能使用一种画笔。</p><p>下图给出了这三个类之间的层次结构:</p><p><img src="https://gitee.com/txt1994/images/raw/master/img/QT/wps28.jpg" alt="img"> </p><p>上面的示意图告诉我们，Qt 的绘图系统实际上是，使用QPainter在QPainterDevice上进行绘制，它们之间使用QPaintEngine进行通讯（也就是翻译QPainter的指令）。</p><p>下面我们通过一个实例来介绍QPainter的使用：</p><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">PaintedWidget</span> : <span class="hljs-keyword">public</span> QWidget{    Q_OBJECT<span class="hljs-keyword">public</span>:    <span class="hljs-built_in">PaintedWidget</span>(QWidget *parent = <span class="hljs-number">0</span>);    <span class="hljs-keyword">protected</span>:    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">paintEvent</span><span class="hljs-params">(QPaintEvent *)</span></span>;}</code></pre></div><p>注意我们重写了QWidget的paintEvent()函数。接下来就是PaintedWidget的源代码：</p><div class="code-wrapper"><pre><code class="hljs c++">PaintedWidget::<span class="hljs-built_in">PaintedWidget</span>(QWidget *parent) :<span class="hljs-built_in">QWidget</span>(parent){    <span class="hljs-built_in">resize</span>(<span class="hljs-number">800</span>, <span class="hljs-number">600</span>);    <span class="hljs-built_in">setWindowTitle</span>(<span class="hljs-built_in">tr</span>(<span class="hljs-string">"Paint Demo"</span>));}<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">PaintedWidget::paintEvent</span><span class="hljs-params">(QPaintEvent *)</span></span><span class="hljs-function"></span>{    <span class="hljs-function">QPainter <span class="hljs-title">painter</span><span class="hljs-params">(<span class="hljs-keyword">this</span>)</span></span>;    painter.<span class="hljs-built_in">drawLine</span>(<span class="hljs-number">80</span>, <span class="hljs-number">100</span>, <span class="hljs-number">650</span>, <span class="hljs-number">500</span>);    painter.<span class="hljs-built_in">setPen</span>(Qt::red);    painter.<span class="hljs-built_in">drawRect</span>(<span class="hljs-number">10</span>, <span class="hljs-number">10</span>, <span class="hljs-number">100</span>, <span class="hljs-number">400</span>);    painter.<span class="hljs-built_in">setPen</span>(<span class="hljs-built_in">QPen</span>(Qt::green, <span class="hljs-number">5</span>));    painter.<span class="hljs-built_in">setBrush</span>(Qt::blue);    painter.<span class="hljs-built_in">drawEllipse</span>(<span class="hljs-number">50</span>, <span class="hljs-number">150</span>, <span class="hljs-number">400</span>, <span class="hljs-number">200</span>);}</code></pre></div><p>在构造函数中，我们仅仅设置了窗口的大小和标题。而paintEvent()函数则是绘制的代码。首先，我们在栈上创建了一个QPainter对象，也就是说，每次运行paintEvent()函数的时候，都会重建这个QPainter对象。注意，这一点可能会引发某些细节问题：由于我们每次重建QPainter，因此第一次运行时所设置的画笔颜色、状态等，第二次再进入这个函数时就会全部丢失。有时候我们希望保存画笔状态，就必须自己保存数据，否则的话则需要将QPainter作为类的成员变量。</p><p>QPainter接收一个QPaintDevice指针作为参数。QPaintDevice有很多子类，比如QImage，以及QWidget。注意回忆一下，QPaintDevice可以理解成要在哪里去绘制，而现在我们希望画在这个组件，因此传入的是 this 指针。</p><p>QPainter有很多以 draw 开头的函数，用于各种图形的绘制，比如这里的drawLine()，drawRect()以及drawEllipse()等。当绘制轮廓线时，使用QPainter的pen()属性。比如，我们调用了painter.setPen(Qt::red)将 pen 设置为红色，则下面绘制的矩形具有红色的轮廓线。接下来，我们将 pen 修改为绿色，5 像素宽（painter.setPen(QPen(Qt::green, 5))），又设置了画刷为蓝色。这时候再调用 draw 函数，则是具有绿色 5 像素宽轮廓线、蓝色填充的椭圆。</p><h2><span id="10-2-hui-tu-she-bei">10.2 绘图设备</span><a href="#10-2-hui-tu-she-bei" class="header-anchor">#</a></h2><p>绘图设备是指继承QPainterDevice的子类。Qt提供了很多这样的类，例如QPixmap、QBitmap、QImage和 QPicture。其中，</p><ul><li><p>QPixmap专门为图像在屏幕上的显示做了优化</p></li><li><p>QBitmap是QPixmap的一个子类，它的色深限定为1，可以使用 QPixmap的isQBitmap()函数来确定这个QPixmap是不是一个QBitmap。</p></li><li><p>QImage专门为图像的像素级访问做了优化。 </p></li><li><p>QPicture则可以记录和重现QPainter的各条命令。</p></li></ul><h3><span id="10-2-1-qpixmap-qbitmap-qimage">10.2.1 QPixmap、QBitmap、QImage</span><a href="#10-2-1-qpixmap-qbitmap-qimage" class="header-anchor">#</a></h3><p>QPixmap继承了QPaintDevice，因此，你可以使用QPainter直接在上面绘制图形。QPixmap也可以接受一个字符串作为一个文件的路径来显示这个文件，比如你想在程序之中打开png、jpeg之类的文件，就可以使用 QPixmap。使用QPainter的drawPixmap()函数可以把这个文件绘制到一个QLabel、QPushButton或者其他的设备上面。QPixmap是针对屏幕进行特殊优化的，因此，它与实际的底层显示设备息息相关。注意，这里说的显示设备并不是硬件，而是操作系统提供的原生的绘图引擎。所以，在不同的操作系统平台下，QPixmap的显示可能会有所差别。</p><p>QBitmap继承自QPixmap，因此具有QPixmap的所有特性，提供单色图像。QBitmap的色深始终为1. 色深这个概念来自计算机图形学，是指用于表现颜色的二进制的位数。我们知道，计算机里面的数据都是使用二进制表示的。为了表示一种颜色，我们也会使用二进制。比如我们要表示8种颜色，需要用3个二进制位，这时我们就说色深是3. 因此，所谓色深为1，也就是使用1个二进制位表示颜色。1个位只有两种状态：0和1，因此它所表示的颜色就有两种，黑和白。所以说，QBitmap实际上是只有黑白两色的图像数据。</p><p>由于QBitmap色深小，因此只占用很少的存储空间，所以适合做光标文件和笔刷。</p><p>下面我们来看同一个图像文件在QPixmap和QBitmap下的不同表现：</p><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">PaintWidget::paintEvent</span><span class="hljs-params">(QPaintEvent *)</span></span><span class="hljs-function"></span>{    <span class="hljs-function">QPixmap <span class="hljs-title">pixmap</span><span class="hljs-params">(<span class="hljs-string">":/Image/butterfly.png"</span>)</span></span>;    <span class="hljs-function">QPixmap <span class="hljs-title">pixmap1</span><span class="hljs-params">(<span class="hljs-string">":/Image/butterfly1.png"</span>)</span></span>;    <span class="hljs-function">QBitmap <span class="hljs-title">bitmap</span><span class="hljs-params">(<span class="hljs-string">":/Image/butterfly.png"</span>)</span></span>;    <span class="hljs-function">QBitmap <span class="hljs-title">bitmap1</span><span class="hljs-params">(<span class="hljs-string">":/Image/butterfly1.png"</span>)</span></span>;    <span class="hljs-function">QPainter <span class="hljs-title">painter</span><span class="hljs-params">(<span class="hljs-keyword">this</span>)</span></span>;    painter.<span class="hljs-built_in">drawPixmap</span>(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, pixmap);    painter.<span class="hljs-built_in">drawPixmap</span>(<span class="hljs-number">200</span>, <span class="hljs-number">0</span>, pixmap1);    painter.<span class="hljs-built_in">drawPixmap</span>(<span class="hljs-number">0</span>, <span class="hljs-number">130</span>, bitmap);    painter.<span class="hljs-built_in">drawPixmap</span>(<span class="hljs-number">200</span>, <span class="hljs-number">130</span>, bitmap1);}</code></pre></div><p><img src="https://gitee.com/txt1994/images/raw/master/img/QT/wps29.jpg" alt="img"> </p><p>这里我们给出了两张png图片。butterfly1.png是没有透明色的纯白背景，而butterfly.png是具有透明色的背景。我们分别使用QPixmap和QBitmap来加载它们。注意看它们的区别：白色的背景在QBitmap中消失了，而透明色在QBitmap中转换成了黑色；其他颜色则是使用点的疏密程度来体现的。</p><p>QPixmap使用底层平台的绘制系统进行绘制，无法提供像素级别的操作，而QImage则是使用独立于硬件的绘制系统，实际上是自己绘制自己，因此提供了像素级别的操作，并且能够在不同系统之上提供一个一致的显示形式。</p><p>我们声明了一个QImage对象，大小是300 x 300，颜色模式是RGB32，即使用32位数值表示一个颜色的RGB值，也就是说每种颜色使用8位。然后我们对每个像素进行颜色赋值，从而构成了这个图像。我们可以把QImage想象成一个RGB颜色的二维数组，记录了每一像素的颜色。</p><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">PaintWidget::paintEvent</span><span class="hljs-params">(QPaintEvent *)</span></span><span class="hljs-function"></span>{    <span class="hljs-function">QPainter <span class="hljs-title">painter</span><span class="hljs-params">(<span class="hljs-keyword">this</span>)</span></span>;    <span class="hljs-function">QImage <span class="hljs-title">image</span><span class="hljs-params">(<span class="hljs-number">300</span>, <span class="hljs-number">300</span>, QImage::Format_RGB32)</span></span>;    QRgb value;    <span class="hljs-comment">//将图片背景填充为白色</span>    image.<span class="hljs-built_in">fill</span>(Qt::white);    <span class="hljs-comment">//改变指定区域的像素点的值</span>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">50</span>; i&lt;<span class="hljs-number">100</span>; ++i)    {        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">50</span>; j&lt;<span class="hljs-number">100</span>; ++j)        {            value = <span class="hljs-built_in">qRgb</span>(<span class="hljs-number">255</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>); <span class="hljs-comment">// 红色</span>            image.<span class="hljs-built_in">setPixel</span>(i, j, value);        }    }    <span class="hljs-comment">//将图片绘制到窗口中</span>    painter.<span class="hljs-built_in">drawImage</span>(<span class="hljs-built_in">QPoint</span>(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>), image);}</code></pre></div><p><img src="https://gitee.com/txt1994/images/raw/master/img/QT/wps30.jpg" alt="img"> </p><p>QImage与QPixmap的区别:</p><ul><li><p>QPixmap主要是用于绘图，针对屏幕显示而最佳化设计，QImage主要是为图像I/O、图片访问和像素修改而设计的</p></li><li><p>QPixmap依赖于所在的平台的绘图引擎，故例如反锯齿等一些效果在不同的平台上可能会有不同的显示效果，QImage使用Qt自身的绘图引擎，可在不同平台上具有相同的显示效果</p></li><li><p>由于QImage是独立于硬件的，也是一种QPaintDevice，因此我们可以在另一个线程中对其进行绘制，而不需要在GUI线程中处理，使用这一方式可以很大幅度提高UI响应速度。</p></li><li><p>QImage可通过setPixpel()和pixel()等方法直接存取指定的像素。</p></li></ul><p>QImage与QPixmap之间的转换:</p><ul><li>QImage转QPixmap</li></ul><p>使用QPixmap的静态成员函数: fromImage()</p><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-function">QPixmap<span class="hljs-title">fromImage</span><span class="hljs-params">(<span class="hljs-type">const</span> QImage &amp; image, </span></span><span class="hljs-params"><span class="hljs-function"></span></span><span class="hljs-params"><span class="hljs-function">Qt::ImageConversionFlags flags = Qt::AutoColor)</span></span></code></pre></div><ul><li>QPixmap转QImage:</li></ul><p>使用QPixmap类的成员函数: toImage()</p><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-function">QImage <span class="hljs-title">toImage</span><span class="hljs-params">()</span> cons</span></code></pre></div><h3><span id="10-2-2-qpicture">10.2.2 QPicture</span><a href="#10-2-2-qpicture" class="header-anchor">#</a></h3><p>最后一个需要说明的是QPicture。这是一个可以记录和重现QPainter命令的绘图设备。 QPicture将QPainter的命令序列化到一个IO设备，保存为一个平台独立的文件格式。这种格式有时候会是“元文件(meta- files)”。Qt的这种格式是二进制的，不同于某些本地的元文件，Qt的pictures文件没有内容上的限制，只要是能够被QPainter绘制的元素，不论是字体还是pixmap，或者是变换，都可以保存进一个picture中。</p><p>QPicture是平台无关的，因此它可以使用在多种设备之上，比如svg、pdf、ps、打印机或者屏幕。回忆下我们这里所说的QPaintDevice，实际上是说可以有QPainter绘制的对象。QPicture使用系统的分辨率，并且可以调整 QPainter来消除不同设备之间的显示差异。</p><p>如果我们要记录下QPainter的命令，首先要使用QPainter::begin()函数，将QPicture实例作为参数传递进去，以便告诉系统开始记录，记录完毕后使用QPainter::end()命令终止。代码示例如下：</p><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">PaintWidget::paintEvent</span><span class="hljs-params">(QPaintEvent *)</span></span><span class="hljs-function"></span>{    QPicture pic;    QPainter painter;    <span class="hljs-comment">//将图像绘制到QPicture中,并保存到文件</span>    painter.<span class="hljs-built_in">begin</span>(&amp;pic);    painter.<span class="hljs-built_in">drawEllipse</span>(<span class="hljs-number">20</span>, <span class="hljs-number">20</span>, <span class="hljs-number">100</span>, <span class="hljs-number">50</span>);    painter.<span class="hljs-built_in">fillRect</span>(<span class="hljs-number">20</span>, <span class="hljs-number">100</span>, <span class="hljs-number">100</span>, <span class="hljs-number">100</span>, Qt::red);    painter.<span class="hljs-built_in">end</span>();    pic.<span class="hljs-built_in">save</span>(<span class="hljs-string">"D:\\drawing.pic"</span>);    <span class="hljs-comment">//将保存的绘图动作重新绘制到设备上</span>    pic.<span class="hljs-built_in">load</span>(<span class="hljs-string">"D:\\drawing.pic"</span>);    painter.<span class="hljs-built_in">begin</span>(<span class="hljs-keyword">this</span>);    painter.<span class="hljs-built_in">drawPicture</span>(<span class="hljs-number">200</span>, <span class="hljs-number">200</span>, pic);    painter.<span class="hljs-built_in">end</span>();}</code></pre></div><h1><span id="11-wen-jian-xi-tong">11 文件系统</span><a href="#11-wen-jian-xi-tong" class="header-anchor">#</a></h1><p>文件操作是应用程序必不可少的部分。Qt 作为一个通用开发库，提供了跨平台的文件操作能力。Qt 通过QIODevice提供了对 I/O 设备的抽象，这些设备具有读写字节块的能力。下面是 I/O 设备的类图（Qt5）：</p><p><img src="https://gitee.com/txt1994/images/raw/master/img/QT/wps31.jpg" alt="img"> </p><ul><li><p>QIODevice：所有 I/O 设备类的父类，提供了字节块读写的通用操作以及基本接口；</p></li><li><p>QFileDevice：Qt5新增加的类，提供了有关文件操作的通用实现。</p></li><li><p>QFlie：访问本地文件或者嵌入资源；</p></li><li><p>QTemporaryFile：创建和访问本地文件系统的临时文件；</p></li><li><p>QBuffer：读写QbyteArray, 内存文件；</p></li><li><p>QProcess：运行外部程序，处理进程间通讯；</p></li><li><p>QAbstractSocket：所有套接字类的父类；</p></li><li><p>QTcpSocket：TCP协议网络数据传输；</p></li><li><p>QUdpSocket：传输 UDP 报文；</p></li><li><p>QSslSocket：使用 SSL/TLS 传输数据；</p></li></ul><p><strong>文件系统分类:</strong></p><ul><li>顺序访问设备:</li></ul><p>是指它们的数据只能访问一遍：从头走到尾，从第一个字节开始访问，直到最后一个字节，中途不能返回去读取上一个字节，这其中，QProcess、QTcpSocket、QUdpSoctet和QSslSocket是顺序访问设备。</p><ul><li>随机访问设备:</li></ul><p>可以访问任意位置任意次数，还可以使用QIODevice::seek()函数来重新定位文件访问位置指针，QFile、QTemporaryFile和QBuffer是随机访问设备， </p><h2><span id="11-1-ji-ben-wen-jian-cao-zuo">11.1 基本文件操作</span><a href="#11-1-ji-ben-wen-jian-cao-zuo" class="header-anchor">#</a></h2><p>文件操作是应用程序必不可少的部分。Qt 作为一个通用开发库，提供了跨平台的文件操作能力。在所有的 I/O 设备中，文件 I/O 是最重要的部分之一。因为我们大多数的程序依旧需要首先访问本地文件（当然，在云计算大行其道的将来，这一观点可能改变）。<strong>QFile提供了从文件中读取和写入数据的能力。</strong></p><p><strong>我们通常会将文件路径作为参数传给QFile的构造函数。不过也可以在创建好对象最后，使用setFileName()来修改</strong>。QFile需要使用 / 作为文件分隔符，不过，它会自动将其转换成操作系统所需要的形式。例如 C:/windows 这样的路径在 Windows 平台下同样是可以的。</p><p>QFile主要提供了有关文件的各种操作，比如打开文件、关闭文件、刷新文件等。我们可以使用QDataStream或QTextStream类来读写文件，也可以使用QIODevice类提供的read()、readLine()、readAll()以及write()这样的函数。值得注意的是，有关文件本身的信息，比如文件名、文件所在目录的名字等，则是通过QFileInfo获取，而不是自己分析文件路径字符串。</p><p>下面我们使用一段代码来看看QFile的有关操作：</p><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> *argv[])</span></span><span class="hljs-function"></span>{    <span class="hljs-function">QApplication <span class="hljs-title">app</span><span class="hljs-params">(argc, argv)</span></span>;    <span class="hljs-function">QFile <span class="hljs-title">file</span><span class="hljs-params">(<span class="hljs-string">"in.txt"</span>)</span></span>;    <span class="hljs-keyword">if</span> (!file.<span class="hljs-built_in">open</span>(QIODevice::ReadOnly | QIODevice::Text)) {        <span class="hljs-built_in">qDebug</span>() &lt;&lt; <span class="hljs-string">"Open file failed."</span>;        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;    } <span class="hljs-keyword">else</span> {        <span class="hljs-keyword">while</span> (!file.<span class="hljs-built_in">atEnd</span>()) {            <span class="hljs-built_in">qDebug</span>() &lt;&lt; file.<span class="hljs-built_in">readLine</span>();        }    }    <span class="hljs-function">QFileInfo <span class="hljs-title">info</span><span class="hljs-params">(file)</span></span>;    <span class="hljs-built_in">qDebug</span>() &lt;&lt; info.<span class="hljs-built_in">isDir</span>();    <span class="hljs-built_in">qDebug</span>() &lt;&lt; info.<span class="hljs-built_in">isExecutable</span>();    <span class="hljs-built_in">qDebug</span>() &lt;&lt; info.<span class="hljs-built_in">baseName</span>();    <span class="hljs-built_in">qDebug</span>() &lt;&lt; info.<span class="hljs-built_in">completeBaseName</span>();    <span class="hljs-built_in">qDebug</span>() &lt;&lt; info.<span class="hljs-built_in">suffix</span>();    <span class="hljs-built_in">qDebug</span>() &lt;&lt; info.<span class="hljs-built_in">completeSuffix</span>();    <span class="hljs-keyword">return</span> app.<span class="hljs-built_in">exec</span>();}</code></pre></div><ul><li>我们首先使用QFile创建了一个文件对象。</li></ul><p>这个文件名字是 in.txt。如果你不知道应该把它放在哪里，可以使用QDir::currentPath()来获得应用程序执行时的当前路径。只要将这个文件放在与当前路径一致的目录下即可。</p><ul><li>使用open()函数打开这个文件，打开形式是只读方式，文本格式。</li></ul><p>这个类似于fopen()的 r 这样的参数。open()函数返回一个 bool 类型，如果打开失败，我们在控制台输出一段提示然后程序退出。否则，我们利用 while 循环，将每一行读到的内容输出。</p><ul><li>可以使用QFileInfo获取有关该文件的信息。</li></ul><p>QFileInfo有很多类型的函数，我们只举出一些例子。比如：</p><ul><li><ul><li>isDir()检查该文件是否是目录；</li></ul></li><li><ul><li>isExecutable()    检查该文件是否是可执行文件等。</li></ul></li><li><ul><li>baseName()        可以直接获得文件名；</li></ul></li><li><ul><li>completeBaseName()     获取完整的文件名</li></ul></li><li><ul><li>suffix()    则直接获取文件后缀名。</li></ul></li><li><ul><li>completeSuffix()     获取完整的文件后缀</li></ul></li></ul><p>我们可以由下面的示例看到，baseName()和completeBaseName()，以及suffix()和completeSuffix()的区别：</p><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-function">QFileInfo <span class="hljs-title">fi</span><span class="hljs-params">(<span class="hljs-string">"/tmp/archive.tar.gz"</span>)</span></span>;QString base  = fi.<span class="hljs-built_in">baseName</span>();  <span class="hljs-comment">// base = "archive"</span>QString base  = fi.<span class="hljs-built_in">completeBaseName</span>();  <span class="hljs-comment">// base = "archive.tar"</span>QString ext  = fi.<span class="hljs-built_in">suffix</span>();  <span class="hljs-comment">// ext = "gz"</span>QString ext  = fi.<span class="hljs-built_in">completeSuffix</span>();  <span class="hljs-comment">// ext = "tar.gz"</span></code></pre></div><h2><span id="11-2-er-jin-zhi-wen-jian-du-xie">11.2 二进制文件读写</span><a href="#11-2-er-jin-zhi-wen-jian-du-xie" class="header-anchor">#</a></h2><p>QDataStream提供了基于QIODevice的二进制数据的序列化。数据流是一种二进制流，这种流完全不依赖于底层操作系统、CPU 或者字节顺序（大端或小端）。例如，在安装了 Windows 平台的 PC 上面写入的一个数据流，可以不经过任何处理，直接拿到运行了 Solaris 的 SPARC 机器上读取。由于数据流就是二进制流，因此我们也可以直接读写没有编码的二进制数据，例如图像、视频、音频等。</p><p>QDataStream既能够存取 C++ 基本类型，如 int、char、short 等，也可以存取复杂的数据类型，例如自定义的类。实际上，QDataStream对于类的存储，是将复杂的类分割为很多基本单元实现的。</p><p>结合QIODevice，QDataStream可以很方便地对文件、网络套接字等进行读写操作。我们从代码开始看起：</p><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-function">QFile <span class="hljs-title">file</span><span class="hljs-params">(<span class="hljs-string">"file.dat"</span>)</span></span>;file.<span class="hljs-built_in">open</span>(QIODevice::WriteOnly);<span class="hljs-function">QDataStream <span class="hljs-title">out</span><span class="hljs-params">(&amp;file)</span></span>;out &lt;&lt; <span class="hljs-built_in">QString</span>(<span class="hljs-string">"the answer is"</span>);out &lt;&lt; (qint32)<span class="hljs-number">42</span>;</code></pre></div><ul><li><p>在这段代码中，我们首先打开一个名为 file.dat 的文件（注意，我们为简单起见，并没有检查文件打开是否成功，这在正式程序中是不允许的）。然后，我们将刚刚创建的file对象的指针传递给一个QDataStream实例out。类似于std::cout标准输出流，QDataStream也重载了输出重定向&lt;&lt;运算符。后面的代码就很简单了：将“the answer is”和数字 42 输出到数据流。由于我们的 out 对象建立在file之上，因此相当于将问题和答案写入file。</p></li><li><p>需要指出一点：最好使用 Qt 整型来进行读写，比如程序中的qint32。这保证了在任意平台和任意编译器都能够有相同的行为。</p></li></ul><p>如果你直接运行这段代码，你会得到一个空白的 file.dat，并没有写入任何数据。这是因为我们的file没有正常关闭。为性能起见，数据只有在文件关闭时才会真正写入。因此，我们必须在最后添加一行代码：</p><p>file.close(); // 如果不想关闭文件，可以使用 file.flush();</p><p>接下来我们将存储到文件中的答案取出来</p><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-function">QFile <span class="hljs-title">file</span><span class="hljs-params">(<span class="hljs-string">"file.dat"</span>)</span></span>;file.<span class="hljs-built_in">open</span>(QIODevice::ReadOnly);<span class="hljs-function">QDataStream <span class="hljs-title">in</span><span class="hljs-params">(&amp;file)</span></span>;QString str;qint32 a;in &gt;&gt; str &gt;&gt; a;</code></pre></div><p>唯一需要注意的是，你必须按照写入的顺序，将数据读取出来。顺序颠倒的话，程序行为是不确定的，严重时会直接造成程序崩溃。</p><p>那么，既然QIODevice提供了read()、readLine()之类的函数，为什么还要有QDataStream呢？QDataStream同QIODevice有什么区别？区别在于，QDataStream提供流的形式，性能上一般比直接调用原始 API 更好一些。我们通过下面一段代码看看什么是流的形式：</p><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-function">QFile <span class="hljs-title">file</span><span class="hljs-params">(<span class="hljs-string">"file.dat"</span>)</span></span>;file.<span class="hljs-built_in">open</span>(QIODevice::ReadWrite);<span class="hljs-function">QDataStream <span class="hljs-title">stream</span><span class="hljs-params">(&amp;file)</span></span>;QString str = <span class="hljs-string">"the answer is 42"</span>;stream &lt;&lt; str;</code></pre></div><h2><span id="11-3-wen-ben-wen-jian-du-xie">11.3 文本文件读写</span><a href="#11-3-wen-ben-wen-jian-du-xie" class="header-anchor">#</a></h2><p>上一节我们介绍了有关二进制文件的读写。二进制文件比较小巧，却不是人可读的格式。而文本文件是一种人可读的文件。为了操作这种文件，我们需要使用QTextStream类。QTextStream和QDataStream的使用类似，只不过它是操作纯文本文件的。</p><p>QTextStream会自动将 Unicode 编码同操作系统的编码进行转换，这一操作对开发人员是透明的。它也会将换行符进行转换，同样不需要自己处理。QTextStream使用 16 位的QChar作为基础的数据存储单位，同样，它也支持 C++ 标准类型，如 int 等。实际上，这是将这种标准类型与字符串进行了相互转换。</p><p>QTextStream同QDataStream的使用基本一致，例如下面的代码将把“The answer is 42”写入到 file.txt 文件中：</p><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-function">QFile <span class="hljs-title">data</span><span class="hljs-params">(<span class="hljs-string">"file.txt"</span>)</span></span>;<span class="hljs-keyword">if</span> (data.<span class="hljs-built_in">open</span>(QFile::WriteOnly | QIODevice::Truncate)) {    <span class="hljs-function">QTextStream <span class="hljs-title">out</span><span class="hljs-params">(&amp;data)</span></span>;    out &lt;&lt; <span class="hljs-string">"The answer is "</span> &lt;&lt; <span class="hljs-number">42</span>;}</code></pre></div><p>这里，我们在open()函数中增加了QIODevice::Truncate打开方式。我们可以从下表中看到这些打开方式的区别：</p><table><thead><tr><th>枚举值</th><th align="left">描述</th></tr></thead><tbody><tr><td>QIODevice::NotOpen</td><td align="left">未打开</td></tr><tr><td>QIODevice::ReadOnly</td><td align="left">以只读方式打开</td></tr><tr><td>QIODevice::WriteOnly</td><td align="left">以只写方式打开</td></tr><tr><td>QIODevice::ReadWrite</td><td align="left">以读写方式打开</td></tr><tr><td>QIODevice::Append</td><td align="left">以追加的方式打开,新增加的内容将被追加到文件末尾</td></tr><tr><td>QIODevice::Truncate</td><td align="left">以重写的方式打开，在写入新的数据时会将原有数据全部清除，游标设置在文件开头。</td></tr><tr><td>QIODevice::Text</td><td align="left">在读取时，将行结束符转换成 \n；在写入时，将行结束符转换成本地格式，例如 Win32 平台上是 \r\n</td></tr><tr><td>QIODevice::Unbuffered</td><td align="left">忽略缓存</td></tr></tbody></table><p>我们在这里使用了QFile::WriteOnly | QIODevice::Truncate，也就是以只写并且覆盖已有内容的形式操作文件。注意，QIODevice::Truncate会直接将文件内容清空。</p><p>虽然QTextStream的写入内容与QDataStream一致，但是读取时却会有些困难：</p><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-function">QFile <span class="hljs-title">data</span><span class="hljs-params">(<span class="hljs-string">"file.txt"</span>)</span></span>;<span class="hljs-keyword">if</span> (data.<span class="hljs-built_in">open</span>(QFile::ReadOnly)) {    <span class="hljs-function">QTextStream <span class="hljs-title">in</span><span class="hljs-params">(&amp;data)</span></span>;    QString str;    <span class="hljs-type">int</span> ans = <span class="hljs-number">0</span>;    in &gt;&gt; str &gt;&gt; ans;}</code></pre></div><p>在使用QDataStream的时候，这样的代码很方便，但是使用了QTextStream时却有所不同：读出的时候，str 里面将是 The answer is 42，ans 是 0。这是因为当使用QDataStream写入的时候，实际上会在要写入的内容前面，额外添加一个这段内容的长度值。而以文本形式写入数据，是没有数据之间的分隔的。因此，使用文本文件时，很少会将其分割开来读取，而是使用诸如使用：</p><ul><li><p>QTextStream::readLine()    读取一行</p></li><li><p>QTextStream::readAll()读取所有文本</p></li></ul><p>这种函数之后再对获得的QString对象进行处理。</p><p>默认情况下，QTextStream的编码格式是 Unicode，如果我们需要使用另外的编码，可以使用：</p><p><code>stream.setCodec("UTF-8");</code></p><p>这样的函数进行设置。</p>]]></content>
    
    
    
    <tags>
      
      <tag>C++</tag>
      
      <tag>QT</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>设计模式准则</title>
    <link href="/2022/01/31/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%87%86%E5%88%99/"/>
    <url>/2022/01/31/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%87%86%E5%88%99/</url>
    
    <content type="html"><![CDATA[<div class="toc"><!-- toc --><ul><li><a href="#zui-zhong-mu-de-gao-nei-ju-di-ou-he">最终目的：高内聚，低耦合</a><ul><li><a href="#1-kai-fang-feng-bi-yuan-ze-ocp-open-for-extension-closed-for-modification-principle"><em><strong>1. 开放封闭原则  (OCP,Open For Extension, Closed For Modification Principle)</strong></em></a></li><li><a href="#2-dan-yi-zhi-ze-yuan-ze-srp-single-responsibility-principle">2. 单一职责原则  (SRP,Single Responsibility Principle)</a></li><li><a href="#3-yi-lai-dao-zhi-yuan-ze-dip-dependence-inversion-principle">3. 依赖倒置原则 (DIP,Dependence Inversion Principle)</a></li><li><a href="#4-jie-kou-ge-chi-yuan-ze-isp-interface-segegation-principle">4. 接口隔离原则 (ISP,Interface Segegation Principle)</a></li><li><a href="#5-li-shi-ti-huan-yuan-ze-lsp-liskov-substitution-principle">5. 里氏替换原则 (LSP, Liskov Substitution Principle)</a></li><li><a href="#6-you-xian-shi-yong-zu-he-er-bu-shi-ji-cheng-yuan-ze-carp-composite-aggregate-reuse-principle">6. 优先使用组合而不是继承原则(CARP,Composite/Aggregate Reuse Principle)</a></li><li><a href="#7-di-mi-te-fa-ze-lod-law-of-demeter">7. 迪米特法则(LOD,Law of Demeter)</a></li></ul></li></ul><!-- tocstop --></div><h1><span id="zui-zhong-mu-de-gao-nei-ju-di-ou-he">最终目的：高内聚，低耦合</span><a href="#zui-zhong-mu-de-gao-nei-ju-di-ou-he" class="header-anchor">#</a></h1><h2><span id="1-kai-fang-feng-bi-yuan-ze-ocp-open-for-extension-closed-for-modification-principle"><em><strong>1. 开放封闭原则  (OCP,Open For Extension, Closed For Modification Principle)</strong></em></span><a href="#1-kai-fang-feng-bi-yuan-ze-ocp-open-for-extension-closed-for-modification-principle" class="header-anchor">#</a></h2><p>😎类的改动是通过增加代码进行的，而不是修改源代码。</p><h2><span id="2-dan-yi-zhi-ze-yuan-ze-srp-single-responsibility-principle">2. 单一职责原则  (SRP,Single Responsibility Principle)</span><a href="#2-dan-yi-zhi-ze-yuan-ze-srp-single-responsibility-principle" class="header-anchor">#</a></h2><p>类的职责要单一，对外只提供一种功能，而引起类变化的原因都应该只有一个。</p><h2><span id="3-yi-lai-dao-zhi-yuan-ze-dip-dependence-inversion-principle">3. 依赖倒置原则 (DIP,Dependence Inversion Principle)</span><a href="#3-yi-lai-dao-zhi-yuan-ze-dip-dependence-inversion-principle" class="header-anchor">#</a></h2><p>😎依赖于抽象(接口),不要依赖具体的实现(类)，也就是针对接口编程。</p><h2><span id="4-jie-kou-ge-chi-yuan-ze-isp-interface-segegation-principle">4. 接口隔离原则 (ISP,Interface Segegation Principle)</span><a href="#4-jie-kou-ge-chi-yuan-ze-isp-interface-segegation-principle" class="header-anchor">#</a></h2><p>不应该强迫客户的程序依赖他们不需要的接口方法。一个接口应该只提供一种对外功能，不应该把所有操作都封装到一个接口中去。</p><h2><span id="5-li-shi-ti-huan-yuan-ze-lsp-liskov-substitution-principle">5. 里氏替换原则 (LSP, Liskov Substitution Principle)</span><a href="#5-li-shi-ti-huan-yuan-ze-lsp-liskov-substitution-principle" class="header-anchor">#</a></h2><p>任何抽象类出现的地方都可以用他的实现类进行替换。实际就是虚拟机制，语言级别实现面向对象功能。</p><h2><span id="6-you-xian-shi-yong-zu-he-er-bu-shi-ji-cheng-yuan-ze-carp-composite-aggregate-reuse-principle">6. 优先使用组合而不是继承原则(CARP,Composite/Aggregate Reuse Principle)</span><a href="#6-you-xian-shi-yong-zu-he-er-bu-shi-ji-cheng-yuan-ze-carp-composite-aggregate-reuse-principle" class="header-anchor">#</a></h2><p>如果使用继承，会导致父类的任何变换都可能影响到子类的行为。<br>如果使用对象组合，就降低了这种依赖关系。</p><h2><span id="7-di-mi-te-fa-ze-lod-law-of-demeter">7. 迪米特法则(LOD,Law of Demeter)</span><a href="#7-di-mi-te-fa-ze-lod-law-of-demeter" class="header-anchor">#</a></h2><p>😎一个对象应当对其他对象尽可能少的了解，从而降低各个对象之间的耦合，提高系统的可维护性。例如在一个程序中，各个模块之间相互调用时，通常会提供一个统一的接口来实现。这样其他模块不需要了解另外一个模块的内部实现细节，这样当一个模块内部的实现发生改变时，不会影响其他模块的使用。(黑盒原理)</p>]]></content>
    
    
    
    <tags>
      
      <tag>设计模式</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>for和while的几种用法</title>
    <link href="/2022/01/30/for%E5%92%8Cwhile%E7%9A%84%E5%87%A0%E7%A7%8D%E7%94%A8%E6%B3%95/"/>
    <url>/2022/01/30/for%E5%92%8Cwhile%E7%9A%84%E5%87%A0%E7%A7%8D%E7%94%A8%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<div class="toc"><!-- toc --><ul><li><a href="#san-duan-shi-for-xun-huan">三段式for循环</a></li><li><a href="#fan-wei-for-xun-huan">范围for循环</a></li><li><a href="#while">while</a></li></ul><!-- tocstop --></div><h1><span id="san-duan-shi-for-xun-huan">三段式for循环</span><a href="#san-duan-shi-for-xun-huan" class="header-anchor">#</a></h1><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-comment">// 变量声明在for里面，自增在里面</span><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; ++i){<span class="hljs-comment">//...</span>}</code></pre></div><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-comment">// 变量声明在外面,自增在里面</span><span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;<span class="hljs-keyword">for</span> (; i &lt; <span class="hljs-number">10</span>; ){<span class="hljs-comment">//...</span>++i;}</code></pre></div><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-type">bool</span> condition = <span class="hljs-literal">true</span>;<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;<span class="hljs-keyword">for</span> (; condition; ){<span class="hljs-comment">//...</span>++i;<span class="hljs-keyword">if</span> (!(i &lt; <span class="hljs-number">5</span>))condition = <span class="hljs-literal">false</span>;}</code></pre></div><p>无限循环版本</p><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-type">bool</span> condition = <span class="hljs-literal">true</span>;<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;<span class="hljs-keyword">for</span> (; ; ){<span class="hljs-comment">//...</span>++i;<span class="hljs-keyword">if</span> (!(i &lt; <span class="hljs-number">5</span>))condition = <span class="hljs-literal">false</span>;}</code></pre></div><h1><span id="fan-wei-for-xun-huan">范围for循环</span><a href="#fan-wei-for-xun-huan" class="header-anchor">#</a></h1><div class="code-wrapper"><pre><code class="hljs c++">std::vector&lt;<span class="hljs-type">int</span>&gt; l{<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>,<span class="hljs-number">7</span>,<span class="hljs-number">8</span>,<span class="hljs-number">9</span>};<span class="hljs-keyword">for</span> (<span class="hljs-type">const</span> <span class="hljs-keyword">auto</span>&amp; it : l){std::cout &lt;&lt; it &lt;&lt; std::endl;}</code></pre></div><h1><span id="while">while</span><a href="#while" class="header-anchor">#</a></h1><p>普通条件while,循环五次退出while</p><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;<span class="hljs-keyword">do</span> {++i;} <span class="hljs-keyword">while</span> ( i &lt; <span class="hljs-number">5</span> )</code></pre></div><p>循环一次推出while</p><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">do</span> {} <span class="hljs-keyword">while</span> ( <span class="hljs-literal">false</span> )</code></pre></div>]]></content>
    
    
    
    <tags>
      
      <tag>C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Visual-Studio-2022基本设置</title>
    <link href="/2022/01/30/Visual-Studio-2022%E5%9F%BA%E6%9C%AC%E8%AE%BE%E7%BD%AE/"/>
    <url>/2022/01/30/Visual-Studio-2022%E5%9F%BA%E6%9C%AC%E8%AE%BE%E7%BD%AE/</url>
    
    <content type="html"><![CDATA[<div class="toc"><!-- toc --><!-- tocstop --></div><p>用微软家的<code>Visual Studio 2022</code>创建项目，为了避免文件混乱，可以采用下边的设置方法,当然也可以使用默认的设置。</p><p>点击解决方案下的项目名，例如sendbox👇</p><p><img src="https://gitee.com/txt1994/images/raw/master/img/Visual_Studio/vs-setting-1.png"></p><p>在弹出的对话窗中点击属性👇</p><p><img src="https://gitee.com/txt1994/images/raw/master/img/Visual_Studio/vs-setting-2.png"></p><p>然后在弹出的对话框中👇，选择<code>所有配置</code>,平台选择<code>所有平台</code></p><p><img src="https://gitee.com/txt1994/images/raw/master/img/Visual_Studio/vs-setting-3.png"></p><p>上图有一个错误去掉<code>bin</code>前面的<code>\</code>.</p><p>配置属性-&gt;常规，</p><ul><li><p>在常规属性-&gt;输出目录填写<code>$(SolutionDir)bin\$(Platform)\$(Configuration)\</code></p></li><li><p>在常规属性-&gt;中间目录填写<code>$(SolutionDir)bin\intermediates\$(Platform)\$(Configuration)\</code></p></li></ul><p>其中<code>Platform</code>根据平台选择不同而不同，比如选择x64,那么<code>Platform</code>就是<code>Win64</code>，还有<code>Win32</code></p><p>设置完点击项目，选择清理，然后重新生成</p><hr><p>编译器语言标准</p><p>配置属性-&gt;常规-&gt;C++语言标准 </p><p><img src="https://gitee.com/txt1994/images/raw/master/img/Visual_Studio/ISO_C%20%20STD.jpg" alt="C++标准"></p><p>配置属性-&gt;常规-&gt;C语言标准 </p><p><img src="https://gitee.com/txt1994/images/raw/master/img/Visual_Studio/ISO_C_STD.jpg" alt="C标准"></p><p>End.</p>]]></content>
    
    
    
    <tags>
      
      <tag>C++</tag>
      
      <tag>VS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C++单一变量存放多种类型的数据</title>
    <link href="/2022/01/29/C-%E5%8D%95%E4%B8%80%E5%8F%98%E9%87%8F%E5%AD%98%E6%94%BE%E5%A4%9A%E7%A7%8D%E7%B1%BB%E5%9E%8B%E7%9A%84%E6%95%B0%E6%8D%AE/"/>
    <url>/2022/01/29/C-%E5%8D%95%E4%B8%80%E5%8F%98%E9%87%8F%E5%AD%98%E6%94%BE%E5%A4%9A%E7%A7%8D%E7%B1%BB%E5%9E%8B%E7%9A%84%E6%95%B0%E6%8D%AE/</url>
    
    <content type="html"><![CDATA[<div class="toc"><!-- toc --><!-- tocstop --></div><p>此文来源于👉 <a href="https://www.bilibili.com/video/BV1au411R72N/?spm_id_from=pageDriver">【77】【Cherno C++】【中字】单一变量存放多种类型的数据_哔哩哔哩_bilibili</a> </p><p>用来处理可能存在也可能不存在的数据，也可能是与我们预期不同的类型。当然也不一定，而是让我们存储不同的数据。<br><code>std::variant</code>的作用是让我们不用担心处理的确切类型，指定一个<code>std::variant</code>的东西，然后列出他可能的数据类型。<br>例子：</p><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;variant&gt;</span></span><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span></span><span class="hljs-function"></span>{    std::variant&lt;std::string, <span class="hljs-type">int</span>&gt; data;    data = <span class="hljs-string">"Cherno"</span>;    std::cout &lt;&lt; std::<span class="hljs-built_in">get</span>&lt;std::string&gt;(data) &lt;&lt; <span class="hljs-string">'\n'</span>;        data = <span class="hljs-number">2</span>;<span class="hljs-comment">// data被重新赋值为2</span>    std::cout &lt;&lt; std::<span class="hljs-built_in">get</span>&lt;<span class="hljs-type">int</span>&gt;(data) &lt;&lt; <span class="hljs-string">'\n'</span>;        data.<span class="hljs-built_in">index</span>();<span class="hljs-comment">// index函数会告诉你类型的索引， 此时会打印1。</span>        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">auto</span> value = std::<span class="hljs-built_in">get_if</span>&lt;<span class="hljs-type">int</span>&gt;(&amp;data))    {        std::string&amp;v = *value;    }    <span class="hljs-keyword">else</span>    {        <span class="hljs-comment">//...</span>    }        <span class="hljs-comment">/*</span><span class="hljs-comment">    std::cout &lt;&lt; std::get&lt;std::string&gt;(data) &lt;&lt; '\n';</span><span class="hljs-comment">    </span><span class="hljs-comment">    错误的访问方法，在data被置为int后依旧按照std::string访问，会抛出一个</span><span class="hljs-comment">    bad variant access异常</span><span class="hljs-comment">    */</span>        std::cin.<span class="hljs-built_in">get</span>();        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;}</code></pre></div>]]></content>
    
    
    
    <tags>
      
      <tag>C++17</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C++数据存在或不存在处理方法</title>
    <link href="/2022/01/29/C-%E6%95%B0%E6%8D%AE%E5%AD%98%E5%9C%A8%E6%88%96%E4%B8%8D%E5%AD%98%E5%9C%A8%E5%A4%84%E7%90%86%E6%96%B9%E6%B3%95/"/>
    <url>/2022/01/29/C-%E6%95%B0%E6%8D%AE%E5%AD%98%E5%9C%A8%E6%88%96%E4%B8%8D%E5%AD%98%E5%9C%A8%E5%A4%84%E7%90%86%E6%96%B9%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<div class="toc"><!-- toc --><!-- tocstop --></div><p>此文来源于👉 <a href="https://www.bilibili.com/video/BV11Z4y1Z7Lh?spm_id_from=333.999.0.0">【76】【Cherno C++】【中字】如何处理OPTIONAL数据_哔哩哔哩_bilibili</a> </p><p>有一个返回的函数， 比如正在读取一个文件，但是如果这个文件不能被读取，会发生什么，虽然读取失败，但我们仍然需要从函数中返回一些东西，返回一个空字符串没有意义。</p><p>如果文件是空的，应有办法看到数据存在或不存在，而<code>std::optional</code>可以给我们一些帮助，此特性在C++17加入。</p><p>非<code>std::optional</code>版本</p><p>例子：</p><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#incldue <span class="hljs-string">&lt;iostream&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;fstream&gt;</span></span><span class="hljs-function">std::string <span class="hljs-title">ReadStringFromFile</span><span class="hljs-params">(<span class="hljs-type">const</span> std::&amp;string filepath, <span class="hljs-type">bool</span>&amp; outSuccess)</span></span><span class="hljs-function"></span>{    <span class="hljs-function">std::ifstream <span class="hljs-title">stream</span><span class="hljs-params">(filepath)</span></span>;    <span class="hljs-keyword">if</span> (stream)    {        std::string result;        <span class="hljs-comment">// read file</span>        stream.<span class="hljs-built_in">close</span>();        outSuccess = <span class="hljs-literal">true</span>;        <span class="hljs-keyword">return</span> result;    }    outSuccess = <span class="hljs-literal">false</span>;    <span class="hljs-keyword">return</span> {};}<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span></span><span class="hljs-function"></span>{    <span class="hljs-type">bool</span> fileOpenedSuccessfully;    std::string data = <span class="hljs-built_in">ReadStringFromFile</span>(<span class="hljs-string">"data.txt"</span>, fileOpenedSuccessfully);    <span class="hljs-keyword">if</span> (fileOpenedSuccessfully)    {        <span class="hljs-comment">//...</span>    }    <span class="hljs-keyword">else</span>    {        <span class="hljs-comment">//...</span>    }        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;}</code></pre></div><p><code>std::optional</code>版本</p><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;fstream&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;optional&gt;</span></span><span class="hljs-function">std::optional&lt;std::string&gt; <span class="hljs-title">ReadStringFromFile</span><span class="hljs-params">(<span class="hljs-type">const</span> std::string&amp; filepath)</span></span><span class="hljs-function"></span>{    <span class="hljs-function">std::ifstream <span class="hljs-title">stream</span><span class="hljs-params">(filepath)</span></span>;    <span class="hljs-keyword">if</span> (stream)    {        std::string result;        <span class="hljs-comment">// read file</span>        stream.<span class="hljs-built_in">close</span>();        <span class="hljs-keyword">return</span> result;    }    <span class="hljs-keyword">return</span> {};}<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span></span><span class="hljs-function"></span>{    std::optional&lt;std::string&gt; data = <span class="hljs-built_in">ReadStringFromFile</span>(<span class="hljs-string">"data.txt"</span>);        std::string value = data.<span class="hljs-built_in">value_or</span>(<span class="hljs-string">"Not present"</span>);<span class="hljs-comment">// 如果数据确实存在std::optional中，它将返回给我们那个字符串。如果不存在，它将返回我们传入的任何值，比如" Not present "</span>    std::cout &lt;&lt; value &lt;&lt; <span class="hljs-string">'\n'</span>;        <span class="hljs-keyword">if</span> (data.<span class="hljs-built_in">has_value</span>())    {        std::cout &lt;&lt; <span class="hljs-string">"File read successfully!\n"</span>;     }    <span class="hljs-keyword">else</span>    {        std::cout &lt;&lt; <span class="hljs-string">"File could not be opend!\n"</span>;     }        std::cin.<span class="hljs-built_in">get</span>();    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;}</code></pre></div>]]></content>
    
    
    
    <tags>
      
      <tag>C++17</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C++元组与对组</title>
    <link href="/2022/01/29/C-%E5%85%83%E7%BB%84%E4%B8%8E%E5%AF%B9%E7%BB%84/"/>
    <url>/2022/01/29/C-%E5%85%83%E7%BB%84%E4%B8%8E%E5%AF%B9%E7%BB%84/</url>
    
    <content type="html"><![CDATA[<div class="toc"><!-- toc --><ul><li><a href="#std-tuple"><code>std::tuple</code></a></li><li><a href="#std-tie"><code>std::tie</code></a></li><li><a href="#std-pair"><code>std::pair</code></a></li></ul><!-- tocstop --></div><p>来自于👉 <a href="http://www.cplusplus.com/reference/tuple/tuple/?kw=tuple">tuple - C++ Reference (cplusplus.com)</a> 并整理</p><blockquote><p>一个元组<code>std::tuple</code>是一个能够容纳 <em><strong>元素集合</strong></em> 的对象。每个元素都可以是 <em><strong>不同的类型</strong></em>。</p></blockquote><blockquote><p><code>std::make_pair()</code>可以<em><strong>构建一个配对对象</strong></em>，其第一个元素设置为x，第二个元素设置为y，并返回。</p></blockquote><blockquote><p><code>std::tie</code>可以绑定<code>std::tuple&lt;T,T,T,...&gt;</code>的实例，并分别给这些元素起别名</p></blockquote><hr><h1><span id="std-tuple"><code>std::tuple</code></span><a href="#std-tuple" class="header-anchor">#</a></h1><p>所在头文件 <code>&lt;tuple&gt;</code></p><p>例子：</p><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-comment">// tuple example</span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span>     <span class="hljs-comment">// std::cout</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;tuple&gt;</span>        <span class="hljs-comment">// std::tuple, std::get, std::tie, std::ignore</span></span><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span> <span class="hljs-params">()</span></span><span class="hljs-function"></span>{    <span class="hljs-function">std::tuple&lt;<span class="hljs-type">int</span>,<span class="hljs-type">char</span>&gt; <span class="hljs-title">foo</span> <span class="hljs-params">(<span class="hljs-number">10</span>,<span class="hljs-string">'x'</span>)</span></span>;    <span class="hljs-keyword">auto</span> bar = std::<span class="hljs-built_in">make_tuple</span> (<span class="hljs-string">"test"</span>, <span class="hljs-number">3.1</span>, <span class="hljs-number">14</span>, <span class="hljs-string">'y'</span>);    std::cout &lt;&lt; <span class="hljs-string">"bar has "</span>&lt;&lt;std::tuple_size&lt;<span class="hljs-keyword">decltype</span>(bar)&gt;::value &lt;&lt; elements&lt;&lt; <span class="hljs-string">'\n'</span>;std::tuple_element&lt;<span class="hljs-number">0</span>,<span class="hljs-keyword">decltype</span>(bar)&gt;::type first = std::<span class="hljs-built_in">get</span>&lt;<span class="hljs-number">0</span>&gt;(bar);    std::cout &lt;&lt; <span class="hljs-string">"bar contains: "</span> &lt;&lt; first &lt;&lt; <span class="hljs-string">'\n'</span>;        std::<span class="hljs-built_in">get</span>&lt;<span class="hljs-number">2</span>&gt;(bar) = <span class="hljs-number">100</span>;                                    <span class="hljs-comment">// access element</span>    <span class="hljs-type">int</span> myint; <span class="hljs-type">char</span> mychar;    std::<span class="hljs-built_in">tie</span> (myint, mychar) = foo;                            <span class="hljs-comment">// unpack elements</span>    std::<span class="hljs-built_in">tie</span> (std::ignore, std::ignore, myint, mychar) = bar;  <span class="hljs-comment">// unpack (with ignore)</span>    mychar = std::<span class="hljs-built_in">get</span>&lt;<span class="hljs-number">3</span>&gt;(bar);    std::<span class="hljs-built_in">get</span>&lt;<span class="hljs-number">0</span>&gt;(foo) = std::<span class="hljs-built_in">get</span>&lt;<span class="hljs-number">2</span>&gt;(bar);    std::<span class="hljs-built_in">get</span>&lt;<span class="hljs-number">1</span>&gt;(foo) = mychar;    std::cout &lt;&lt; <span class="hljs-string">"foo contains: "</span>;    std::cout &lt;&lt; std::<span class="hljs-built_in">get</span>&lt;<span class="hljs-number">0</span>&gt;(foo) &lt;&lt; <span class="hljs-string">' '</span>;    std::cout &lt;&lt; std::<span class="hljs-built_in">get</span>&lt;<span class="hljs-number">1</span>&gt;(foo) &lt;&lt; <span class="hljs-string">'\n'</span>;    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;}</code></pre></div><p>答案：</p><div class="code-wrapper"><pre><code class="hljs bash">bar has 4 elementsbar contains: <span class="hljs-built_in">test</span>foo contains: 100 y</code></pre></div><hr><h1><span id="std-tie"><code>std::tie</code></span><a href="#std-tie" class="header-anchor">#</a></h1><p>所在头文件 <code>&lt;tuple&gt;</code></p><p>例子：</p><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-comment">// packing/unpacking tuples</span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span>     <span class="hljs-comment">// std::cout</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;tuple&gt;</span>        <span class="hljs-comment">// std::tuple, std::make_tuple, std::tie</span></span><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span> <span class="hljs-params">()</span></span><span class="hljs-function"></span>{    std::tuple&lt;<span class="hljs-type">int</span>,<span class="hljs-type">float</span>,<span class="hljs-type">char</span>&gt; mytuple;    mytuple = std::<span class="hljs-built_in">make_tuple</span> (<span class="hljs-number">10</span>, <span class="hljs-number">2.6</span>, <span class="hljs-string">'a'</span>);          <span class="hljs-comment">// packing values into tuple</span>    <span class="hljs-type">int</span> myint;    <span class="hljs-type">char</span> mychar;    std::<span class="hljs-built_in">tie</span> (myint, std::ignore, mychar) = mytuple;   <span class="hljs-comment">// unpacking tuple into variables</span>    std::cout &lt;&lt; <span class="hljs-string">"myint contains: "</span> &lt;&lt; myint &lt;&lt; <span class="hljs-string">'\n'</span>;    std::cout &lt;&lt; <span class="hljs-string">"mychar contains: "</span> &lt;&lt; mychar &lt;&lt; <span class="hljs-string">'\n'</span>;    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;}</code></pre></div><p>结果：</p><div class="code-wrapper"><pre><code class="hljs bash">myint contains: 10mychar contains: a</code></pre></div><hr><h1><span id="std-pair"><code>std::pair</code></span><a href="#std-pair" class="header-anchor">#</a></h1><p>所在头文件 <code>&lt;utility&gt;</code></p><p>例子：</p><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-comment">// make_pair example</span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;utility&gt;</span>      <span class="hljs-comment">// std::pair</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span>     <span class="hljs-comment">// std::cout</span></span><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span> <span class="hljs-params">()</span> </span>{    std::pair &lt;<span class="hljs-type">int</span>,<span class="hljs-type">int</span>&gt; foo;    std::pair &lt;<span class="hljs-type">int</span>,<span class="hljs-type">int</span>&gt; bar;    foo = std::<span class="hljs-built_in">make_pair</span> (<span class="hljs-number">10</span>,<span class="hljs-number">20</span>);    bar = std::<span class="hljs-built_in">make_pair</span> (<span class="hljs-number">10.5</span>,<span class="hljs-string">'A'</span>); <span class="hljs-comment">// ok: implicit conversion from pair&lt;double,char&gt;</span>    std::cout &lt;&lt; <span class="hljs-string">"foo: "</span> &lt;&lt; foo.first &lt;&lt; <span class="hljs-string">", "</span> &lt;&lt; foo.second &lt;&lt; <span class="hljs-string">'\n'</span>;    std::cout &lt;&lt; <span class="hljs-string">"bar: "</span> &lt;&lt; bar.first &lt;&lt; <span class="hljs-string">", "</span> &lt;&lt; bar.second &lt;&lt; <span class="hljs-string">'\n'</span>;std::cout&lt;&lt; <span class="hljs-string">"foo contains: "</span> &lt;&lt; std::<span class="hljs-built_in">get</span>&lt;<span class="hljs-number">0</span>&gt;(foo) &lt;&lt; <span class="hljs-string">" and "</span> &lt;&lt; std::<span class="hljs-built_in">get</span>&lt;<span class="hljs-number">1</span>&gt;(foo) &lt;&lt; <span class="hljs-string">'\n'</span>;        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;}</code></pre></div><p>结果：</p><div class="code-wrapper"><pre><code class="hljs bash">foo: 10, 20bar: 10, 65foo contains: 50 and x</code></pre></div><hr><p>End.</p>]]></content>
    
    
    
    <tags>
      
      <tag>C++11</tag>
      
      <tag>Tuple</tag>
      
      <tag>Pair</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C++结构化绑定</title>
    <link href="/2022/01/29/C-%E7%BB%93%E6%9E%84%E5%8C%96%E7%BB%91%E5%AE%9A/"/>
    <url>/2022/01/29/C-%E7%BB%93%E6%9E%84%E5%8C%96%E7%BB%91%E5%AE%9A/</url>
    
    <content type="html"><![CDATA[<div class="toc"><!-- toc --><!-- tocstop --></div><p>此文总结与👉 <a href="https://space.bilibili.com/364152971">神经元猫的个人空间_哔哩哔哩_bilibili</a> 的 <a href="https://www.bilibili.com/video/BV11F411n7pw">【75】【Cherno C++】【中字】C++的结构化绑定_哔哩哔哩_bilibili</a> </p><ul><li>在如何处理C++多返回值得问题，返回的数据可以是结构体实例，也可以是元组或对组</li></ul><p>从C++17引入的结构化绑定可以改善此项，</p><p>以前忒麻烦的版本</p><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;tuple&gt;</span></span><span class="hljs-function">std::tuple&lt;std::string, <span class="hljs-type">int</span>&gt; <span class="hljs-title">CreatPerson</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>{    <span class="hljs-keyword">return</span> { <span class="hljs-string">"Cherno"</span>, <span class="hljs-number">24</span> };}<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span></span><span class="hljs-function"></span>{    <span class="hljs-keyword">auto</span> person = <span class="hljs-built_in">CreatPerson</span>();    std::string&amp;name = std::<span class="hljs-built_in">get</span>&lt;<span class="hljs-number">0</span>&gt;(person);    <span class="hljs-type">int</span> age = std::<span class="hljs-built_in">get</span>&lt;<span class="hljs-number">1</span>&gt;(person);        std::string name;    <span class="hljs-type">int</span> age;    std::<span class="hljs-built_in">tie</span>(name, age) = <span class="hljs-built_in">CreatPerson</span>();       <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;}</code></pre></div><p>从C++17引入了<em><strong>结构化绑定</strong></em>解决了上诉问题</p><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;tuple&gt;</span></span><span class="hljs-function">std::tuple&lt;std::string, <span class="hljs-type">int</span>&gt; <span class="hljs-title">CreatPerson</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>{    <span class="hljs-keyword">return</span> { <span class="hljs-string">"Cherno"</span>, <span class="hljs-number">24</span> };}<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span></span><span class="hljs-function"></span>{    <span class="hljs-keyword">auto</span>[name, age] = <span class="hljs-built_in">CreatPerson</span>(); <span class="hljs-comment">// 简单，美观</span>    std::cout &lt;&lt; name;       <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;}</code></pre></div>]]></content>
    
    
    
    <tags>
      
      <tag>C++17</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>获取C++中数据的类型的方法</title>
    <link href="/2022/01/28/%E8%8E%B7%E5%8F%96C-%E4%B8%AD%E6%95%B0%E6%8D%AE%E7%9A%84%E7%B1%BB%E5%9E%8B%E7%9A%84%E6%96%B9%E6%B3%95/"/>
    <url>/2022/01/28/%E8%8E%B7%E5%8F%96C-%E4%B8%AD%E6%95%B0%E6%8D%AE%E7%9A%84%E7%B1%BB%E5%9E%8B%E7%9A%84%E6%96%B9%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<div class="toc"><!-- toc --><ul><li><a href="#pan-duan-shu-ju-shi-na-chong-shu-ju-lei-xing">判断数据是哪种数据类型</a><ul><li><a href="#std-type-info-name">std::type_info::name()</a></li></ul></li><li><a href="#pan-duan-shu-ju-shi-fou-shi-dui-ying-de-shu-ju-lei-xing">判断数据是否是对应的数据类型</a></li></ul><!-- tocstop --></div><p>此文来自于👉 <a href="https://devdocs.io/cpp/header/typeinfo">C++ / typeinfo — DevDocs</a> ，并整理</p><h1><span id="pan-duan-shu-ju-shi-na-chong-shu-ju-lei-xing">判断数据是哪种数据类型</span><a href="#pan-duan-shu-ju-shi-na-chong-shu-ju-lei-xing" class="header-anchor">#</a></h1><p>头文件<code>&lt;typeinfo&gt;</code></p><h2><span id="std-type-info-name">std::type_info::name()</span><a href="#std-type-info-name" class="header-anchor">#</a></h2><p>例子：</p><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;typeinfo&gt;</span></span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">Base</span> { <span class="hljs-keyword">virtual</span> ~<span class="hljs-built_in">Base</span>() = <span class="hljs-keyword">default</span>; };<span class="hljs-keyword">struct</span> <span class="hljs-title class_">Derived</span> : Base {}; <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>{    Base b1;    Derived d1;    <span class="hljs-type">const</span> Base *pb = &amp;b1;    std::cout &lt;&lt; <span class="hljs-built_in">typeid</span>(*pb).<span class="hljs-built_in">name</span>() &lt;&lt; <span class="hljs-string">'\n'</span>;    pb = &amp;d1;    std::cout &lt;&lt; <span class="hljs-built_in">typeid</span>(*pb).<span class="hljs-built_in">name</span>() &lt;&lt; <span class="hljs-string">'\n'</span>;    <span class="hljs-type">int</span> i;    <span class="hljs-type">int</span> * pi;    std::cout &lt;&lt; <span class="hljs-string">"int is: "</span> &lt;&lt; <span class="hljs-built_in">typeid</span>(<span class="hljs-type">int</span>).<span class="hljs-built_in">name</span>() &lt;&lt; <span class="hljs-string">'\n'</span>;    std::cout &lt;&lt; <span class="hljs-string">"  i is: "</span> &lt;&lt; <span class="hljs-built_in">typeid</span>(i).<span class="hljs-built_in">name</span>() &lt;&lt; <span class="hljs-string">'\n'</span>;    std::cout &lt;&lt; <span class="hljs-string">" pi is: "</span> &lt;&lt; <span class="hljs-built_in">typeid</span>(pi).<span class="hljs-built_in">name</span>() &lt;&lt; <span class="hljs-string">'\n'</span>;    std::cout &lt;&lt; <span class="hljs-string">"*pi is: "</span> &lt;&lt; <span class="hljs-built_in">typeid</span>(*pi).<span class="hljs-built_in">name</span>() &lt;&lt; <span class="hljs-string">'\n'</span>;    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;}</code></pre></div><p>结果：</p><div class="code-wrapper"><pre><code class="hljs bash">4Base7Derivedint is: int  i is: int pi is: int **pi is: int</code></pre></div><h1><span id="pan-duan-shu-ju-shi-fou-shi-dui-ying-de-shu-ju-lei-xing">判断数据是否是对应的数据类型</span><a href="#pan-duan-shu-ju-shi-fou-shi-dui-ying-de-shu-ju-lei-xing" class="header-anchor">#</a></h1><p>头文件<code>&lt;type_traits&gt;</code></p><h4><span id="zhu-yao-lei-xing-lei-bie-primary-type-categories">主要类型类别 Primary type categories</span><a href="#zhu-yao-lei-xing-lei-bie-primary-type-categories" class="header-anchor">#</a></h4><ul><li><p><a href="https://www.cplusplus.com/reference/type_traits/is_array/"><strong>is_array</strong></a></p><p>Is array (class template )</p><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-comment">// is_array example</span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;array&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;type_traits&gt;</span></span><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>{    std::cout &lt;&lt; std::boolalpha;    std::cout &lt;&lt; <span class="hljs-string">"is_array:"</span> &lt;&lt; std::endl;    std::cout &lt;&lt; <span class="hljs-string">"int: "</span> &lt;&lt; std::is_array&lt;<span class="hljs-type">int</span>&gt;::value &lt;&lt; std::endl;    std::cout &lt;&lt; <span class="hljs-string">"int[3]: "</span> &lt;&lt; std::is_array&lt;<span class="hljs-type">int</span>[<span class="hljs-number">3</span>]&gt;::value &lt;&lt; std::endl;    std::cout &lt;&lt; <span class="hljs-string">"array&lt;int,3&gt;: "</span> &lt;&lt; std::is_array&lt;std::array&lt;<span class="hljs-type">int</span>,3&gt;&gt;::value &lt;&lt; std::endl;    std::cout &lt;&lt; <span class="hljs-string">"string: "</span> &lt;&lt; std::is_array&lt;std::string&gt;::value &lt;&lt; std::endl;    std::cout &lt;&lt; <span class="hljs-string">"string[3]: "</span> &lt;&lt; std::is_array&lt;std::string[<span class="hljs-number">3</span>]&gt;::value &lt;&lt; std::endl;    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;}</code></pre></div><p>结果：</p><div class="code-wrapper"><pre><code class="hljs bash">is_array:int: <span class="hljs-literal">false</span>int[3]: <span class="hljs-literal">true</span>array&lt;int,3&gt;: <span class="hljs-literal">false</span>string: <span class="hljs-literal">false</span>string[3]: <span class="hljs-literal">true</span></code></pre></div></li><li><p><a href="https://www.cplusplus.com/reference/type_traits/is_class/"><strong>is_class</strong></a></p><p>Is non-union class (class template )</p></li><li><p><a href="https://www.cplusplus.com/reference/type_traits/is_enum/"><strong>is_enum</strong></a></p><p>Is enum (class template )</p></li><li><p><a href="https://www.cplusplus.com/reference/type_traits/is_floating_point/"><strong>is_floating_point</strong></a></p><p>Is floating point (class template )</p></li><li><p><a href="https://www.cplusplus.com/reference/type_traits/is_function/"><strong>is_function</strong></a></p><p>Is function (class template )</p></li><li><p><a href="https://www.cplusplus.com/reference/type_traits/is_integral/"><strong>is_integral</strong></a></p><p>Is integral (class template )</p></li><li><p><a href="https://www.cplusplus.com/reference/type_traits/is_lvalue_reference/"><strong>is_lvalue_reference</strong></a></p><p>Is lvalue reference (class template )</p></li><li><p><a href="https://www.cplusplus.com/reference/type_traits/is_member_function_pointer/"><strong>is_member_function_pointer</strong></a></p><p>Is member function pointer (class template )</p></li><li><p><a href="https://www.cplusplus.com/reference/type_traits/is_member_object_pointer/"><strong>is_member_object_pointer</strong></a></p><p>Is member object pointer (class template )</p></li><li><p><a href="https://www.cplusplus.com/reference/type_traits/is_pointer/"><strong>is_pointer</strong></a></p><p>Is pointer (class template )</p></li><li><p><a href="https://www.cplusplus.com/reference/type_traits/is_rvalue_reference/"><strong>is_rvalue_reference</strong></a></p><p>Is rvalue reference (class template )</p></li><li><p><a href="https://www.cplusplus.com/reference/type_traits/is_union/"><strong>is_union</strong></a></p><p>Is union (class template )</p></li><li><p><a href="https://www.cplusplus.com/reference/type_traits/is_void/"><strong>is_void</strong></a></p><p>Is void (class template )</p></li></ul><h4><span id="fu-he-lei-xing-fan-chou-composite-type-categories">复合类型范畴 Composite type categories</span><a href="#fu-he-lei-xing-fan-chou-composite-type-categories" class="header-anchor">#</a></h4><ul><li><p><a href="https://www.cplusplus.com/reference/type_traits/is_arithmetic/"><strong>is_arithmetic</strong></a></p><p>Is arithmetic type (class template )</p><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-comment">// is_arithmetic example</span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;type_traits&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;complex&gt;</span></span><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>{    std::cout &lt;&lt; std::boolalpha;    std::cout &lt;&lt; <span class="hljs-string">"is_arithmetic:"</span> &lt;&lt; std::endl;    std::cout &lt;&lt; <span class="hljs-string">"char: "</span> &lt;&lt; std::is_arithmetic&lt;<span class="hljs-type">char</span>&gt;::value &lt;&lt; std::endl;    std::cout &lt;&lt; <span class="hljs-string">"float: "</span> &lt;&lt; std::is_arithmetic&lt;<span class="hljs-type">float</span>&gt;::value &lt;&lt; std::endl;    std::cout &lt;&lt; <span class="hljs-string">"float*: "</span> &lt;&lt; std::is_arithmetic&lt;<span class="hljs-type">float</span>*&gt;::value &lt;&lt; std::endl;    std::cout &lt;&lt; <span class="hljs-string">"complex&lt;double&gt;: "</span> &lt;&lt; std::is_arithmetic&lt;std::complex&lt;<span class="hljs-type">double</span>&gt;&gt;::value &lt;&lt; std::endl;    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;}</code></pre></div></li></ul><p>Output:<br>    </p><div class="code-wrapper"><pre><code class="hljs bash">is_arithmetic:char: <span class="hljs-literal">true</span><span class="hljs-built_in">float</span>: <span class="hljs-literal">true</span><span class="hljs-built_in">float</span>*: <span class="hljs-literal">false</span>complex&lt;double&gt;: <span class="hljs-literal">false</span></code></pre></div><p></p><ul><li><p><a href="https://www.cplusplus.com/reference/type_traits/is_compound/"><strong>is_compound</strong></a></p><p>Is compound type (class template )</p></li><li><p><a href="https://www.cplusplus.com/reference/type_traits/is_fundamental/"><strong>is_fundamental</strong></a></p><p>Is fundamental type (class template )</p></li><li><p><a href="https://www.cplusplus.com/reference/type_traits/is_member_pointer/"><strong>is_member_pointer</strong></a></p><p>Is member pointer type (class template )</p></li><li><p><a href="https://www.cplusplus.com/reference/type_traits/is_object/"><strong>is_object</strong></a></p><p>Is object type (class template )</p></li><li><p><a href="https://www.cplusplus.com/reference/type_traits/is_reference/"><strong>is_reference</strong></a></p><p>Is reference type (class template )</p></li><li><p><a href="https://www.cplusplus.com/reference/type_traits/is_scalar/"><strong>is_scalar</strong></a></p><p>Is scalar type (class template )</p></li></ul><h4><span id="lei-xing-shu-xing-type-properties">类型属性 Type properties</span><a href="#lei-xing-shu-xing-type-properties" class="header-anchor">#</a></h4><ul><li><p><a href="https://www.cplusplus.com/reference/type_traits/is_abstract/"><strong>is_abstract</strong></a></p><p>Is abstract class (class template )</p><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-comment">// is_abstract example</span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;type_traits&gt;</span></span><span class="hljs-keyword">struct</span> <span class="hljs-title class_">A</span> { };<span class="hljs-keyword">struct</span> <span class="hljs-title class_">B</span> {  <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">fn</span><span class="hljs-params">()</span> </span>= <span class="hljs-number">0</span>;  <span class="hljs-comment">// pure virtual function</span>};<span class="hljs-keyword">struct</span> <span class="hljs-title class_">C</span> : B { };<span class="hljs-keyword">struct</span> <span class="hljs-title class_">D</span> : C { <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">fn</span><span class="hljs-params">()</span></span>{} };<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>{    std::cout &lt;&lt; std::boolalpha;    std::cout &lt;&lt; <span class="hljs-string">"is_abstract:"</span> &lt;&lt; std::endl;    std::cout &lt;&lt; <span class="hljs-string">"A: "</span> &lt;&lt; std::is_abstract&lt;A&gt;::value &lt;&lt; std::endl;    std::cout &lt;&lt; <span class="hljs-string">"B: "</span> &lt;&lt; std::is_abstract&lt;B&gt;::value &lt;&lt; std::endl;    std::cout &lt;&lt; <span class="hljs-string">"C: "</span> &lt;&lt; std::is_abstract&lt;C&gt;::value &lt;&lt; std::endl;    std::cout &lt;&lt; <span class="hljs-string">"D: "</span> &lt;&lt; std::is_abstract&lt;D&gt;::value &lt;&lt; std::endl;    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;}</code></pre></div></li></ul><p>结果：</p><div class="code-wrapper"><pre><code class="hljs bash">is_abstract:A: <span class="hljs-literal">false</span>B: <span class="hljs-literal">true</span>C: <span class="hljs-literal">true</span>D: <span class="hljs-literal">false</span></code></pre></div><ul><li><p><a href="https://www.cplusplus.com/reference/type_traits/is_const/"><strong>is_const</strong></a></p><p>Is const-qualified (class template )</p></li><li><p><a href="https://www.cplusplus.com/reference/type_traits/is_empty/"><strong>is_empty</strong></a></p><p>Is empty class (class template )</p></li><li><p><a href="https://www.cplusplus.com/reference/type_traits/is_literal_type/"><strong>is_literal_type</strong></a></p><p>Is literal type (class template )</p></li><li><p><a href="https://www.cplusplus.com/reference/type_traits/is_pod/"><strong>is_pod</strong></a></p><p>Is POD type (class template )</p></li><li><p><a href="https://www.cplusplus.com/reference/type_traits/is_polymorphic/"><strong>is_polymorphic</strong></a></p><p>Is polymorphic (class template )</p></li><li><p><a href="https://www.cplusplus.com/reference/type_traits/is_signed/"><strong>is_signed</strong></a></p><p>Is signed type (class template )</p></li><li><p><a href="https://www.cplusplus.com/reference/type_traits/is_standard_layout/"><strong>is_standard_layout</strong></a></p><p>Is standard-layout type (class template )</p></li><li><p><a href="https://www.cplusplus.com/reference/type_traits/is_trivial/"><strong>is_trivial</strong></a></p><p>Is trivial type (class template )</p></li><li><p><a href="https://www.cplusplus.com/reference/type_traits/is_trivially_copyable/"><strong>is_trivially_copyable</strong></a></p><p>Is trivially copyable (class template )</p></li><li><p><a href="https://www.cplusplus.com/reference/type_traits/is_unsigned/"><strong>is_unsigned</strong></a></p><p>Is unsigned type (class template )</p></li><li><p><a href="https://www.cplusplus.com/reference/type_traits/is_volatile/"><strong>is_volatile</strong></a></p><p>Is volatile-qualified (class template )</p></li></ul><h4><span id="lei-xing-te-zheng-type-features">类型特征 Type features</span><a href="#lei-xing-te-zheng-type-features" class="header-anchor">#</a></h4><ul><li><p><a href="https://www.cplusplus.com/reference/type_traits/has_virtual_destructor/"><strong>has_virtual_destructor</strong></a></p><p>Has virtual destructor (class template )</p><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-comment">// has_virtual_destructor example</span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;type_traits&gt;</span></span><span class="hljs-keyword">struct</span> <span class="hljs-title class_">A</span> { };<span class="hljs-keyword">struct</span> <span class="hljs-title class_">B</span> { <span class="hljs-keyword">virtual</span> ~<span class="hljs-built_in">B</span>(){} };<span class="hljs-keyword">struct</span> <span class="hljs-title class_">C</span> : B { };<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>{    std::cout &lt;&lt; std::boolalpha;    std::cout &lt;&lt; <span class="hljs-string">"has_virtual_destructor:"</span> &lt;&lt; std::endl;    std::cout &lt;&lt; <span class="hljs-string">"int: "</span> &lt;&lt; std::has_virtual_destructor&lt;<span class="hljs-type">int</span>&gt;::value &lt;&lt; std::endl;    std::cout &lt;&lt; <span class="hljs-string">"A: "</span> &lt;&lt; std::has_virtual_destructor&lt;A&gt;::value &lt;&lt; std::endl;    std::cout &lt;&lt; <span class="hljs-string">"B: "</span> &lt;&lt; std::has_virtual_destructor&lt;B&gt;::value &lt;&lt; std::endl;    std::cout &lt;&lt; <span class="hljs-string">"C: "</span> &lt;&lt; std::has_virtual_destructor&lt;C&gt;::value &lt;&lt; std::endl;    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;}</code></pre></div></li></ul><p>Output:</p><div class="code-wrapper"><pre><code class="hljs bash">has_virtual_destructor:int: <span class="hljs-literal">false</span>A: <span class="hljs-literal">false</span>B: <span class="hljs-literal">true</span>C: <span class="hljs-literal">true</span></code></pre></div><ul><li><p><a href="https://www.cplusplus.com/reference/type_traits/is_assignable/"><strong>is_assignable</strong></a></p><p>Is assignable (class template )</p></li><li><p><a href="https://www.cplusplus.com/reference/type_traits/is_constructible/"><strong>is_constructible</strong></a></p><p>Is constructible (class template )</p></li><li><p><a href="https://www.cplusplus.com/reference/type_traits/is_copy_assignable/"><strong>is_copy_assignable</strong></a></p><p>Is copy assignable (class template )</p></li><li><p><a href="https://www.cplusplus.com/reference/type_traits/is_copy_constructible/"><strong>is_copy_constructible</strong></a></p><p>Is copy constructible (class template )</p></li><li><p><a href="https://www.cplusplus.com/reference/type_traits/is_destructible/"><strong>is_destructible</strong></a></p><p>Is destructible (class template )</p></li><li><p><a href="https://www.cplusplus.com/reference/type_traits/is_default_constructible/"><strong>is_default_constructible</strong></a></p><p>Is default constructible (class template )</p></li><li><p><a href="https://www.cplusplus.com/reference/type_traits/is_move_assignable/"><strong>is_move_assignable</strong></a></p><p>Is move assignable (class template )</p></li><li><p><a href="https://www.cplusplus.com/reference/type_traits/is_move_constructible/"><strong>is_move_constructible</strong></a></p><p>Is move constructible (class template )</p></li><li><p><a href="https://www.cplusplus.com/reference/type_traits/is_trivially_assignable/"><strong>is_trivially_assignable</strong></a></p><p>Is trivially assignable (class template )</p></li><li><p><a href="https://www.cplusplus.com/reference/type_traits/is_trivially_constructible/"><strong>is_trivially_constructible</strong></a></p><p>Is trivially constructible (class template )</p></li><li><p><a href="https://www.cplusplus.com/reference/type_traits/is_trivially_copy_assignable/"><strong>is_trivially_copy_assignable</strong></a></p><p>Is trivially copy assignable (class template )</p></li><li><p><a href="https://www.cplusplus.com/reference/type_traits/is_trivially_copy_constructible/"><strong>is_trivially_copy_constructible</strong></a></p><p>Is trivially copy constructible (class template )</p></li><li><p><a href="https://www.cplusplus.com/reference/type_traits/is_trivially_destructible/"><strong>is_trivially_destructible</strong></a></p><p>Is trivially destructible (class template )</p></li><li><p><a href="https://www.cplusplus.com/reference/type_traits/is_trivially_default_constructible/"><strong>is_trivially_default_constructible</strong></a></p><p>Is trivially default constructible (class template )</p></li><li><p><a href="https://www.cplusplus.com/reference/type_traits/is_trivially_move_assignable/"><strong>is_trivially_move_assignable</strong></a></p><p>Is trivially move assignable (class template )</p></li><li><p><a href="https://www.cplusplus.com/reference/type_traits/is_trivially_move_constructible/"><strong>is_trivially_move_constructible</strong></a></p><p>Is trivially move constructible (class template )</p></li><li><p><a href="https://www.cplusplus.com/reference/type_traits/is_nothrow_assignable/"><strong>is_nothrow_assignable</strong></a></p><p>Is assignable throwing no exceptions (class template )</p></li><li><p><a href="https://www.cplusplus.com/reference/type_traits/is_nothrow_constructible/"><strong>is_nothrow_constructible</strong></a></p><p>Is constructible throwing no exceptions (class template )</p></li><li><p><a href="https://www.cplusplus.com/reference/type_traits/is_nothrow_copy_assignable/"><strong>is_nothrow_copy_assignable</strong></a></p><p>Is copy assignable throwing no exceptions (class template )</p></li><li><p><a href="https://www.cplusplus.com/reference/type_traits/is_nothrow_copy_constructible/"><strong>is_nothrow_copy_constructible</strong></a></p><p>Is copy constructible throwing no exceptions (class template )</p></li><li><p><a href="https://www.cplusplus.com/reference/type_traits/is_nothrow_destructible/"><strong>is_nothrow_destructible</strong></a></p><p>Is nothrow destructible (class template )</p></li><li><p><a href="https://www.cplusplus.com/reference/type_traits/is_nothrow_default_constructible/"><strong>is_nothrow_default_constructible</strong></a></p><p>Is default constructible throwing no exceptions (class template )</p></li><li><p><a href="https://www.cplusplus.com/reference/type_traits/is_nothrow_move_assignable/"><strong>is_nothrow_move_assignable</strong></a></p><p>Is move assignable throwing no exception (class template )</p></li><li><p><a href="https://www.cplusplus.com/reference/type_traits/is_nothrow_move_constructible/"><strong>is_nothrow_move_constructible</strong></a></p><p>Is move constructible throwing no exceptions (class template )</p></li></ul><h4><span id="lei-xing-guan-xi-type-relationships">类型关系 Type relationships</span><a href="#lei-xing-guan-xi-type-relationships" class="header-anchor">#</a></h4><ul><li><p><a href="https://www.cplusplus.com/reference/type_traits/is_base_of/"><strong>is_base_of</strong></a></p><p>Is base class of (class template )</p><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-comment">// is_base_of example</span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;type_traits&gt;</span></span><span class="hljs-keyword">struct</span> <span class="hljs-title class_">A</span> {};<span class="hljs-keyword">struct</span> <span class="hljs-title class_">B</span> : A {};<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>{    std::cout &lt;&lt; std::boolalpha;    std::cout &lt;&lt; <span class="hljs-string">"is_base_of:"</span> &lt;&lt; std::endl;    std::cout &lt;&lt; <span class="hljs-string">"int, int: "</span> &lt;&lt; std::is_base_of&lt;<span class="hljs-type">int</span>,<span class="hljs-type">int</span>&gt;::value &lt;&lt; std::endl;    std::cout &lt;&lt; <span class="hljs-string">"A, A: "</span> &lt;&lt; std::is_base_of&lt;A,A&gt;::value &lt;&lt; std::endl;    std::cout &lt;&lt; <span class="hljs-string">"A, B: "</span> &lt;&lt; std::is_base_of&lt;A,B&gt;::value &lt;&lt; std::endl;    std::cout &lt;&lt; <span class="hljs-string">"A, const B: "</span> &lt;&lt; std::is_base_of&lt;A,<span class="hljs-type">const</span> B&gt;::value &lt;&lt; std::endl;    std::cout &lt;&lt; <span class="hljs-string">"A&amp;, B&amp;: "</span> &lt;&lt; std::is_base_of&lt;A&amp;,B&amp;&gt;::value &lt;&lt; std::endl;    std::cout &lt;&lt; <span class="hljs-string">"B, A: "</span> &lt;&lt; std::is_base_of&lt;B,A&gt;::value &lt;&lt; std::endl;    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;}</code></pre></div></li></ul><p>Output:</p><div class="code-wrapper"><pre><code class="hljs bash">is_base_of:int, int: <span class="hljs-literal">false</span>A, A: <span class="hljs-literal">true</span>A, B: <span class="hljs-literal">true</span>A, const B: <span class="hljs-literal">true</span>A&amp;, B&amp;: <span class="hljs-literal">false</span>B, A: <span class="hljs-literal">false</span></code></pre></div><ul><li><p><a href="https://www.cplusplus.com/reference/type_traits/is_convertible/"><strong>is_convertible</strong></a></p><p>Is convertible (class template )</p></li><li><p><a href="https://www.cplusplus.com/reference/type_traits/is_same/"><strong>is_same</strong></a></p><p>Is same type (class template )</p></li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>C++</tag>
      
      <tag>Type</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>本人使用的hexo插件列表</title>
    <link href="/2022/01/28/%E6%9C%AC%E4%BA%BA%E4%BD%BF%E7%94%A8%E7%9A%84hexo%E6%8F%92%E4%BB%B6%E5%88%97%E8%A1%A8/"/>
    <url>/2022/01/28/%E6%9C%AC%E4%BA%BA%E4%BD%BF%E7%94%A8%E7%9A%84hexo%E6%8F%92%E4%BB%B6%E5%88%97%E8%A1%A8/</url>
    
    <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="抱歉, 这个密码看着不太对, 请再试试." data-whm="抱歉, 这个文章不能被校验, 不过您还是能看看解密后的内容.">  <script id="hbeData" type="hbeData" data-hmacdigest="9a84215c1b35482d03c9f83ff9b2ade238ba81de0effb4c1dcc933553e11dfe8">10d79030e8222445804370796b90fca13d0e91ddbfe90aeab5b3b0f5b0a8d5411b795be55d52a34b96986f15b78e9fe3958899ace1474bd822c9fe38aa14e7f8ea5bd8bac98a77bb63d279174bf7db16417e4e7c59095986a11490784d9c8c3a4556cfc8f4f23006e4a6cca07cc7c744b86fc1f5652751fad21a3d62542d148964dd9972b9ca0215c059f6169dd1877e1c51b74ee4504c6e9b9a8481b4bec1bae017e2901d74c4220ec39db4c4b589ecdacfbf1a69efd085e60e867cef27db2fac8dc1acbfedb04b0d57493c1b38b49deb466a128772cbeb4df24d447a8431c03c07057029aba9ee60b24e4af19e7a08e5357521d827a27f6c15302f742f9156053a5f4f43e85802fad27b5be7f8785049c275ac6bb419b9a366618d7c4446ee960678718aa6be90b764493913eaab87613b186de86d65852101cccb65fe406e0e59dac8aef6986c3b182b30ea4a2b8b171bbbbb17dd1105493a8d58bd27944af0a489513a6fd885e5785eaf884e8d7f44301a0f1b38628ce9fffdd465e6fcb5b352aa5a73f32ad73f3c9def174c9f1b6b5df2325c08ff08b122b06e7e71a7b7c0420abaceaec1b50cc0b564b22bbb647967df326c919f5f63d128f0d406e63f5edcabdc7a23397b2d218f95e01bcef49641668f00c1f83b7f4d8a9d1f4afe92870a7937cc61d44e3610dbaaac49b99b24cea3f6bfd9f33bd2c2cef0f95f4aa75229a576e5d80fc648a5cc6fb0ea13b561ede58f224b86acc82de0bae14ce06c3016a1b01513e28390deb4a4b122a30d2fd99724d4710c1b15c0fdae8b19f6af7177b8b8258ab0cfb5d570fdfd9331938db3986e68eb3a81886e893fcc20b2a076fdf00d6b5eef273ed32d895734f84541c5670bbd7df248d0deffb6c115d86820d3c084a84ec91a48f7224118ce69614b6a116f6204ad48efc6fd7d1c56d423656cf503f3bcbc56d051557cb811d3b885257f3606222852012f652373baff1c2c383376c5dedffead5daade0c6528825925423c5a756df79ffd40e9c8da14d9a725848623582980c1c19b16f76044176a72c267054ad54b6aa27462a68b4d49542915c034858695fffe2f4a14b4f6d9de224189f8d84de187029d1f372b540034bdb1a3f39fe05bcbb1debd96f7e2fadccdc9a00b43011d9996cd6b54442ed7982539900d571d6782eefd002dd4a37c63047825ffa960588146339ca56bc6c041390faca29caa5f69dbe43f62ee6d5df017e0a47fe73ec76cdd2a4221e719e70824f194b7c490e5a16a668b090c0530391fd5f3f82f9e362a70401f3235d9ed14d58cafbbc867f6e6fb3e5063ee56e31c24cda4f55130f0430758230186a85c311d6708a8aa4b767516bbd6ae54ad53e7eda92170cf1b4707dbdbdc0ef907f870dc7cf966264e979428eaf2db4899a5e5bcccb79f2b6a72d0bdb8b2d6d3fe09ca9ff9ba10522d2c9be15fa822c70feb4a54c9ba2bc97c16dc451ef8a14761feecad7de5c824574a1d904ae94a00bc96220983d91987fcb9682c860cddca35f404c4ceacf75f231af6b4c37e5071e5e6ade9ad8447fbea008261c7c2729563b9cfe86212cd299d022227d723d345df13bfb7f1a6e89da04b61673eef635be9da86c742ed9eeffe7ad94e8341f541bc9599b34921b84e40fb19d2ab94e74f1d91368989f11324cf8c62e2098fe3548ae116683cb4ca77e0d2a51a516399c1a81ea4c0435d4d94ef2c82a973f8083fe127f7acd988c6dba52e37bdee1129e7238d579199a56a47fdb291db1d67646a39e0721191df25407f1040c1a3e7392e5882eee053bbd46528f4ab58ef3a1e05d791f62226545849273888083f42924cadb92e705ca01b05ffd6f9e6365ed0d1902176229ce77c98ef6e7b13c4c4f06dd5915c246d341cb10c7119c4e1d0ec5896b429308fab1a75245e719c4ff0d985b319ae39840b716f4676f94d81cea28908237bcd75765fab434aa114ed17ee1e50210ea8409635c3c20bed78e6b36a7b08b142eecde35f1442da398ce7853b2807f9a7e955334a67c8fa5eb15d63c2b18df0e96ed1abf4cde9daf97b2e6fc2df030e090bee8122998dd833f1c5f70fbd045cc08301ed98f02c7a6e50ca2dccf03a2c7c0bbd682b3692af29ac2d19b08bece7d2ba6d026d3d6fa23fb8b82e641657eb9124f8d4c9442ebcc3286e747090350003d4e83a6a26a93d23267bad293d269c41d040d861a4e0945efae65eabfc2d259858a408cb11ee5642084c5887dba49fffa9a96d83996534ff31d0e7e5c7c32b99e32a4553f2775cfcd56b5ea4ac6b267957311145d7f6fa2b02b09bbaeece98fa3892160a597cfdc5a76589ea6892b1b08b358cf9d5c17c1e967616d492c2af2588cee4c8e6c17a7dee96898a23f3ed</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-default">      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-default">您好, 这里需要密码, 请点击本文字.</span>      </label>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
    
    
    
    <tags>
      
      <tag>Plugins</tag>
      
      <tag>Hexo</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C++新特性</title>
    <link href="/2022/01/24/C-%E6%96%B0%E7%89%B9%E6%80%A7/"/>
    <url>/2022/01/24/C-%E6%96%B0%E7%89%B9%E6%80%A7/</url>
    
    <content type="html"><![CDATA[<div class="toc"><!-- toc --><ul><li><a href="#1-variadic-templates">1. Variadic Templates</a></li><li><a href="#2-nullptr-and-nullptr-t-and-auto">2. nullptr and nullptr_t and auto</a><ul><li><a href="#nullptr">nullptr</a></li><li><a href="#auto">auto</a></li></ul></li><li><a href="#3-uniform-initialization">3. Uniform Initialization</a></li><li><a href="#4-bind-he-function">4. bind()和function&lt;&gt;</a><ul><li><a href="#std-function"><strong>std::function&lt;&gt;</strong></a></li><li><a href="#std-bind"><strong>std::bind()</strong></a></li></ul></li></ul><!-- tocstop --></div><h2><span id="1-variadic-templates">1. Variadic Templates</span><a href="#1-variadic-templates" class="header-anchor">#</a></h2><blockquote><p>数量不定的模板参数</p></blockquote><p><code>...</code>代表任意个数据</p><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">print</span><span class="hljs-params">()</span></span>{}<span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T, <span class="hljs-keyword">typename</span>... Types&gt;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">print</span><span class="hljs-params">(<span class="hljs-type">const</span> T&amp; firstArg, <span class="hljs-type">const</span> Types&amp;...args)</span> </span>{    std::cout &lt;&lt; firstArg &lt;&lt; <span class="hljs-string">'\n'</span>;    <span class="hljs-built_in">print</span>(args...);}</code></pre></div><p><code>void print(const T&amp; firstArg, const Types&amp;...args){}</code>中<code>...</code>代表任意个数据，<code>Types</code>任意类型的数据,</p><p>表示接受任意个任意类型的数据</p><p><strong>例子：</strong></p><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bitset&gt;</span></span><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">print</span><span class="hljs-params">()</span> </span>{}<span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T, <span class="hljs-keyword">typename</span>... Types&gt;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">print</span><span class="hljs-params">(<span class="hljs-type">const</span> T &amp;firstArg, <span class="hljs-type">const</span> Types &amp;...args)</span></span><span class="hljs-function"></span>{    std::cout &lt;&lt; firstArg &lt;&lt; <span class="hljs-string">'\n'</span>;    <span class="hljs-built_in">print</span>(args...);}<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> *argv[])</span></span><span class="hljs-function"></span>{    <span class="hljs-built_in">print</span>(<span class="hljs-number">7.5</span>, <span class="hljs-string">"hello"</span>, std::<span class="hljs-built_in">bitset</span>&lt;<span class="hljs-number">16</span>&gt;(<span class="hljs-number">377</span>), <span class="hljs-number">42</span>);    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;}</code></pre></div><p>结果：</p><div class="code-wrapper"><pre><code class="hljs bash">7.5hello000000010111100142</code></pre></div><p>解释：<code>print(7.5, "hello", bitset&lt;16&gt;(377), 42);</code>, </p><p>分解方式为<strong>递归</strong></p><ol><li><p>第一次7.5和它右边会分成两部分放进<code>void print(const T&amp; firstArg, const Types&amp;...args)</code>, 第一部分的是<code>firstArg</code>，第二部分会放进<code>...args</code>;</p></li><li><p>第二次<code>hello</code>和它右边两部分放进<code>firstArg</code>,<code>...args</code>;</p></li><li><p>特化比泛化权值更高，也即是更加倾向于选择特化</p><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T, <span class="hljs-keyword">typename</span>... Types&gt;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">print</span><span class="hljs-params">(<span class="hljs-type">const</span> T &amp;firstArg, <span class="hljs-type">const</span> Types &amp;...args)</span></span><span class="hljs-function"></span>{    std::cout &lt;&lt; firstArg &lt;&lt; <span class="hljs-string">'\n'</span>;    <span class="hljs-built_in">print</span>(args...);}<span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span>... Types&gt;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">print</span><span class="hljs-params">(<span class="hljs-type">const</span> Types &amp;...args)</span></span><span class="hljs-function"></span>{    std::cout &lt;&lt; firstArg &lt;&lt; <span class="hljs-string">'\n'</span>;    <span class="hljs-built_in">print</span>(args...);}<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> *argv[])</span></span><span class="hljs-function"></span>{    <span class="hljs-built_in">print</span>(<span class="hljs-number">7.5</span>, <span class="hljs-string">"hello"</span>, std::<span class="hljs-built_in">bitset</span>&lt;<span class="hljs-number">16</span>&gt;(<span class="hljs-number">377</span>), <span class="hljs-number">42</span>); <span class="hljs-comment">// 倾向于选择print(const T &amp;firstArg, const Types &amp;...args)</span>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;}</code></pre></div></li></ol><h2><span id="2-nullptr-and-nullptr-t-and-auto">2. nullptr and nullptr_t and auto</span><a href="#2-nullptr-and-nullptr-t-and-auto" class="header-anchor">#</a></h2><h3><span id="nullptr">nullptr</span><a href="#nullptr" class="header-anchor">#</a></h3><p>C++改为使用<code>nullptr</code>为空指针，代替<code>NULL</code>或<code>0</code>;</p><p>例子：</p><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">f</span><span class="hljs-params">(<span class="hljs-type">int</span>)</span></span>;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">f</span><span class="hljs-params">(<span class="hljs-type">void</span>*)</span></span>;<span class="hljs-built_in">f</span>(<span class="hljs-number">0</span>);<span class="hljs-comment">// 选择f(int)</span><span class="hljs-built_in">f</span>(<span class="hljs-literal">NULL</span>);<span class="hljs-comment">// 选择f(int)</span><span class="hljs-built_in">f</span>(<span class="hljs-literal">nullptr</span>);<span class="hljs-comment">// 选择f(void*)</span></code></pre></div><h3><span id="auto">auto</span><a href="#auto" class="header-anchor">#</a></h3><blockquote><p>数据类型自动推导</p></blockquote><p>auto是根据=右边的数据推导出变量的数据类型</p><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">auto</span> i = <span class="hljs-number">42</span>;  <span class="hljs-comment">// i has type int</span><span class="hljs-function"><span class="hljs-type">double</span> <span class="hljs-title">f</span><span class="hljs-params">()</span></span>;<span class="hljs-keyword">auto</span> d = <span class="hljs-built_in">f</span>(); <span class="hljs-comment">// d has type double</span></code></pre></div><p>auto 用在容器中比较多</p><div class="code-wrapper"><pre><code class="hljs c++">list&lt;string&gt; c;...list&lt;string&gt;::iterator ite;ite = <span class="hljs-built_in">find</span>(c.begin, c.<span class="hljs-built_in">end</span>(), target);</code></pre></div><p>变为</p><div class="code-wrapper"><pre><code class="hljs c++">list&lt;string&gt; c;...<span class="hljs-keyword">auto</span> ite = <span class="hljs-built_in">find</span>(c.begin, c.<span class="hljs-built_in">end</span>(), target);</code></pre></div><p>用在for循环中</p><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span></span><span class="hljs-function"></span>{    std::vector&lt;<span class="hljs-type">int</span>&gt; vec{<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>,<span class="hljs-number">7</span>,<span class="hljs-number">8</span>,<span class="hljs-number">9</span>};        <span class="hljs-keyword">for</span> (<span class="hljs-type">const</span> <span class="hljs-keyword">auto</span>&amp;it : vec)    {        std::cout &lt;&lt; it &lt;&lt; <span class="hljs-string">" "</span>;    }    std::cout &lt;&lt; <span class="hljs-string">'\n'</span>;    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;}</code></pre></div><h2><span id="3-uniform-initialization">3. Uniform Initialization</span><a href="#3-uniform-initialization" class="header-anchor">#</a></h2><blockquote><p>统一的初始化{}</p></blockquote><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-type">int</span> i; <span class="hljs-comment">// 初始值未定</span><span class="hljs-type">int</span> j{}; <span class="hljs-comment">// 初始值为0</span><span class="hljs-type">int</span>* p;<span class="hljs-comment">// 初始值未定义</span><span class="hljs-type">int</span>* q{};<span class="hljs-comment">// 初始值为 nullptr</span><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">x1</span><span class="hljs-params">(<span class="hljs-number">5.3</span>)</span></span>; <span class="hljs-comment">// OK, 但初始值被设为5；</span><span class="hljs-type">int</span> x2 = <span class="hljs-number">5.3</span>;<span class="hljs-comment">// OK, 但初始值被设为5；</span><span class="hljs-type">int</span> x3{<span class="hljs-number">5.0</span>};<span class="hljs-comment">// ERROR</span><span class="hljs-type">int</span> values[] {<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>};std::vector&lt;<span class="hljs-type">int</span>&gt; v{<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>,<span class="hljs-number">7</span>,<span class="hljs-number">8</span>,<span class="hljs-number">9</span>};std::vector&lt;string&gt; cities{    <span class="hljs-string">"Beijing"</span>, <span class="hljs-string">"xinjiang"</span>, <span class="hljs-string">"henan"</span>, <span class="hljs-string">"London"</span>};complex&lt;<span class="hljs-type">double</span>&gt; c{<span class="hljs-number">4.0</span>, <span class="hljs-number">3.0</span>};</code></pre></div><p>都是用<code>{}</code>来初始化；</p><h2><span id="4-bind-he-function-lt-gt">4. bind()和function&lt;&gt;</span><a href="#4-bind-he-function-lt-gt" class="header-anchor">#</a></h2><blockquote><p>函数模板 <code>bind</code> 生成 <code>f</code> 的转发调用包装器。调用此包装器等价于以一些绑定到 <code>args</code> 的参数调用 <code>f</code> 。</p></blockquote><blockquote><p>类模板 <code>std::function</code> 是通用多态函数封装器。 <code>std::function</code> 的实例能存储、复制及调用任何<a href="mk:@MSITStore:C:\Users\txt1994\Downloads\cppreference-zh-20210212-dev.chm::/chmhelp/cpp-named_req-Callable.html"><em>可调用</em> <em>(Callable)</em></a> <em>目标</em>——函数、 <a href="mk:@MSITStore:C:\Users\txt1994\Downloads\cppreference-zh-20210212-dev.chm::/chmhelp/cpp-language-lambda.html">lambda 表达式</a>、 <a href="mk:@MSITStore:C:\Users\txt1994\Downloads\cppreference-zh-20210212-dev.chm::/chmhelp/cpp-utility-functional-bind.html">bind 表达式</a>或其他函数对象，还有指向成员函数指针和指向数据成员指针。</p></blockquote><h3><span id="std-function-lt-gt"><strong>std::function&lt;&gt;</strong></span><a href="#std-function-lt-gt" class="header-anchor">#</a></h3><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;functional&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">Foo</span> {    <span class="hljs-built_in">Foo</span>(<span class="hljs-type">int</span> num) : <span class="hljs-built_in">num_</span>(num) {}    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">print_add</span><span class="hljs-params">(<span class="hljs-type">int</span> i)</span> <span class="hljs-type">const</span> </span>{ std::cout &lt;&lt; num_+i &lt;&lt; <span class="hljs-string">'\n'</span>; }    <span class="hljs-type">int</span> num_;}; <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">print_num</span><span class="hljs-params">(<span class="hljs-type">int</span> i)</span></span><span class="hljs-function"></span>{    std::cout &lt;&lt; i &lt;&lt; <span class="hljs-string">'\n'</span>;} <span class="hljs-keyword">struct</span> <span class="hljs-title class_">PrintNum</span> {    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">operator</span><span class="hljs-params">()</span><span class="hljs-params">(<span class="hljs-type">int</span> i)</span> <span class="hljs-type">const</span></span><span class="hljs-function">    </span>{        std::cout &lt;&lt; i &lt;&lt; <span class="hljs-string">'\n'</span>;    }}; <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>{    <span class="hljs-comment">// 存储自由函数</span>    std::function&lt;<span class="hljs-type">void</span>(<span class="hljs-type">int</span>)&gt; f_display = print_num;    <span class="hljs-built_in">f_display</span>(<span class="hljs-number">-9</span>);     <span class="hljs-comment">// 存储 lambda</span>    std::function&lt;<span class="hljs-type">void</span>()&gt; f_display_42 = []() { <span class="hljs-built_in">print_num</span>(<span class="hljs-number">42</span>); };    <span class="hljs-built_in">f_display_42</span>();     <span class="hljs-comment">// 存储到 std::bind 调用的结果</span>    std::function&lt;<span class="hljs-type">void</span>()&gt; f_display_31337 = std::<span class="hljs-built_in">bind</span>(print_num, <span class="hljs-number">31337</span>);    <span class="hljs-built_in">f_display_31337</span>();     <span class="hljs-comment">// 存储到成员函数的调用</span>    std::function&lt;<span class="hljs-type">void</span>(<span class="hljs-type">const</span> Foo&amp;, <span class="hljs-type">int</span>)&gt; f_add_display = &amp;Foo::print_add;    <span class="hljs-function"><span class="hljs-type">const</span> Foo <span class="hljs-title">foo</span><span class="hljs-params">(<span class="hljs-number">314159</span>)</span></span>;    <span class="hljs-built_in">f_add_display</span>(foo, <span class="hljs-number">1</span>);    <span class="hljs-built_in">f_add_display</span>(<span class="hljs-number">314159</span>, <span class="hljs-number">1</span>);     <span class="hljs-comment">// 存储到数据成员访问器的调用</span>    std::function&lt;<span class="hljs-type">int</span>(Foo <span class="hljs-type">const</span>&amp;)&gt; f_num = &amp;Foo::num_;    std::cout &lt;&lt; <span class="hljs-string">"num_: "</span> &lt;&lt; <span class="hljs-built_in">f_num</span>(foo) &lt;&lt; <span class="hljs-string">'\n'</span>;     <span class="hljs-comment">// 存储到成员函数及对象的调用</span>    <span class="hljs-keyword">using</span> std::placeholders::_1;    std::function&lt;<span class="hljs-type">void</span>(<span class="hljs-type">int</span>)&gt; f_add_display2 = std::<span class="hljs-built_in">bind</span>( &amp;Foo::print_add, foo, _1 );    <span class="hljs-built_in">f_add_display2</span>(<span class="hljs-number">2</span>);     <span class="hljs-comment">// 存储到成员函数和对象指针的调用</span>    std::function&lt;<span class="hljs-type">void</span>(<span class="hljs-type">int</span>)&gt; f_add_display3 = std::<span class="hljs-built_in">bind</span>( &amp;Foo::print_add, &amp;foo, _1 );    <span class="hljs-built_in">f_add_display3</span>(<span class="hljs-number">3</span>);     <span class="hljs-comment">// 存储到函数对象的调用</span>    std::function&lt;<span class="hljs-type">void</span>(<span class="hljs-type">int</span>)&gt; f_display_obj = <span class="hljs-built_in">PrintNum</span>();    <span class="hljs-built_in">f_display_obj</span>(<span class="hljs-number">18</span>);}</code></pre></div><h3><span id="std-bind"><strong>std::bind()</strong></span><a href="#std-bind" class="header-anchor">#</a></h3><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;random&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;memory&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;functional&gt;</span></span> <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">f</span><span class="hljs-params">(<span class="hljs-type">int</span> n1, <span class="hljs-type">int</span> n2, <span class="hljs-type">int</span> n3, <span class="hljs-type">const</span> <span class="hljs-type">int</span>&amp; n4, <span class="hljs-type">int</span> n5)</span></span><span class="hljs-function"></span>{    std::cout &lt;&lt; n1 &lt;&lt; <span class="hljs-string">' '</span> &lt;&lt; n2 &lt;&lt; <span class="hljs-string">' '</span> &lt;&lt; n3 &lt;&lt; <span class="hljs-string">' '</span> &lt;&lt; n4 &lt;&lt; <span class="hljs-string">' '</span> &lt;&lt; n5 &lt;&lt; <span class="hljs-string">'\n'</span>;} <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">g</span><span class="hljs-params">(<span class="hljs-type">int</span> n1)</span></span><span class="hljs-function"></span>{    <span class="hljs-keyword">return</span> n1;} <span class="hljs-keyword">struct</span> <span class="hljs-title class_">Foo</span> {    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">print_sum</span><span class="hljs-params">(<span class="hljs-type">int</span> n1, <span class="hljs-type">int</span> n2)</span></span><span class="hljs-function">    </span>{        std::cout &lt;&lt; n1+n2 &lt;&lt; <span class="hljs-string">'\n'</span>;    }    <span class="hljs-type">int</span> data = <span class="hljs-number">10</span>;}; <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>{    <span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std::placeholders;  <span class="hljs-comment">// 对于 _1, _2, _3...</span>     <span class="hljs-comment">// 演示参数重排序和按引用传递</span>    <span class="hljs-type">int</span> n = <span class="hljs-number">7</span>;    <span class="hljs-comment">// （ _1 与 _2 来自 std::placeholders ，并表示将来会传递给 f1 的参数）</span>    <span class="hljs-keyword">auto</span> f1 = std::<span class="hljs-built_in">bind</span>(f, _2, <span class="hljs-number">42</span>, _1, std::<span class="hljs-built_in">cref</span>(n), n);    n = <span class="hljs-number">10</span>;    <span class="hljs-built_in">f1</span>(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">1001</span>); <span class="hljs-comment">// 1 为 _1 所绑定， 2 为 _2 所绑定，不使用 1001</span>                    <span class="hljs-comment">// 进行到 f(2, 42, 1, n, 7) 的调用</span>     <span class="hljs-comment">// 嵌套 bind 子表达式共享占位符</span>    <span class="hljs-keyword">auto</span> f2 = std::<span class="hljs-built_in">bind</span>(f, _3, std::<span class="hljs-built_in">bind</span>(g, _3), _3, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>);    <span class="hljs-built_in">f2</span>(<span class="hljs-number">10</span>, <span class="hljs-number">11</span>, <span class="hljs-number">12</span>); <span class="hljs-comment">// 进行到 f(12, g(12), 12, 4, 5); 的调用</span>     <span class="hljs-comment">// 常见使用情况：以分布绑定 RNG</span>    std::default_random_engine e;    std::uniform_int_distribution&lt;&gt; <span class="hljs-built_in">d</span>(<span class="hljs-number">0</span>, <span class="hljs-number">10</span>);    std::function&lt;<span class="hljs-type">int</span>()&gt; rnd = std::<span class="hljs-built_in">bind</span>(d, e); <span class="hljs-comment">// e 的一个副本存储于 rnd</span>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> n=<span class="hljs-number">0</span>; n&lt;<span class="hljs-number">10</span>; ++n)        std::cout &lt;&lt; <span class="hljs-built_in">rnd</span>() &lt;&lt; <span class="hljs-string">' '</span>;    std::cout &lt;&lt; <span class="hljs-string">'\n'</span>;     <span class="hljs-comment">// 绑定指向成员函数指针</span>    Foo foo;    <span class="hljs-keyword">auto</span> f3 = std::<span class="hljs-built_in">bind</span>(&amp;Foo::print_sum, &amp;foo, <span class="hljs-number">95</span>, _1);    <span class="hljs-built_in">f3</span>(<span class="hljs-number">5</span>);     <span class="hljs-comment">// 绑定指向数据成员指针</span>    <span class="hljs-keyword">auto</span> f4 = std::<span class="hljs-built_in">bind</span>(&amp;Foo::data, _1);    std::cout &lt;&lt; <span class="hljs-built_in">f4</span>(foo) &lt;&lt; <span class="hljs-string">'\n'</span>;     <span class="hljs-comment">// 智能指针亦能用于调用被引用对象的成员</span>    std::cout &lt;&lt; <span class="hljs-built_in">f4</span>(std::<span class="hljs-built_in">make_shared</span>&lt;Foo&gt;(foo)) &lt;&lt; <span class="hljs-string">'\n'</span>              &lt;&lt; <span class="hljs-built_in">f4</span>(std::<span class="hljs-built_in">make_unique</span>&lt;Foo&gt;(foo)) &lt;&lt; <span class="hljs-string">'\n'</span>;}</code></pre></div>]]></content>
    
    
    
    <tags>
      
      <tag>C++11</tag>
      
      <tag>C++17</tag>
      
      <tag>C++14</tag>
      
      <tag>C++20</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>QT_UI组件库</title>
    <link href="/2022/01/24/QT-UI%E7%BB%84%E4%BB%B6%E5%BA%93/"/>
    <url>/2022/01/24/QT-UI%E7%BB%84%E4%BB%B6%E5%BA%93/</url>
    
    <content type="html"><![CDATA[<div class="toc"><!-- toc --><ul><li><a href="#qt-zu-jian-ku-di-1-31">QT组件库第1-31</a></li><li><a href="#qt-zu-jian-ku-di-32-56">QT组件库第32-56</a></li><li><a href="#layouts-bu-ju-zu-jian-ku">Layouts 布局组件库</a><ul><li><a href="#1-hao-vertical-layout">1号 Vertical Layout</a></li><li><a href="#2-hao-horizontal-layout">2号 Horizontal Layout</a></li><li><a href="#3-hao-grid-layout">3号 Grid Layout</a></li><li><a href="#4-hao-form-layout">4号 Form Layout</a></li></ul></li><li><a href="#spacers-kong-jian-jian-ge-zu-dan-huang">Spacers 空间间隔组(弹簧)</a><ul><li><a href="#5-hao-horizontal-spacer">5号 Horizontal Spacer</a></li><li><a href="#6-hao-vertical-spacer">6号 Vertical Spacer</a></li></ul></li><li><a href="#buttons-an-niu">Buttons 按钮</a><ul><li><a href="#7-hao-push-button">7号 Push Button</a></li><li><a href="#8-hao-tool-button">8号 Tool Button</a></li><li><a href="#9-hao-radio-button">9号 Radio Button</a></li><li><a href="#10-hao-check-box">10号 Check Box</a></li><li><a href="#11-hao-command-link-button">11号 Command Link Button</a></li><li><a href="#12-hao-dialog-button-box">12号 Dialog Button Box</a></li></ul></li><li><a href="#item-views-model-based-qing-dan-shi-tu-zu">Item Views (Model-Based) 清单视图组</a><ul><li><a href="#13-hao-list-view">13号 List View</a></li><li><a href="#14-hao-tree-view">14号 Tree View</a></li><li><a href="#15-hao-table-view">15号 Table View</a></li><li><a href="#16-hao-column-view">16号 Column View</a></li><li><a href="#17-hao-undo-view">17号 Undo View</a></li></ul></li><li><a href="#item-widgets-item-based-qing-dan-kong-jian-zu">Item Widgets (Item-Based) 清单控件组</a><ul><li><a href="#18-hao-list-widget">18号 List Widget</a></li><li><a href="#19-hao-tree-widget">19号 Tree Widget</a></li><li><a href="#20-hao-table-widget">20号 Table Widget</a></li></ul></li><li><a href="#containers-rong-qi-zu">Containers 容器组</a><ul><li><a href="#21-hao-group-box">21号 Group Box</a></li><li><a href="#22-hao-scroll-area">22号 Scroll Area</a></li><li><a href="#23-hao-tool-box">23号 Tool Box</a></li><li><a href="#24-hao-tab-widget">24号 Tab Widget</a></li><li><a href="#25-hao-stacked-widget">25号 Stacked Widget</a></li><li><a href="#26-hao-frame">26号 Frame</a></li><li><a href="#27-hao-widget">27号 Widget</a></li><li><a href="#28-hao-mdi-area">28号 MDI Area</a></li><li><a href="#29-hao-dock-widget">29号 Dock Widget</a></li><li><a href="#30-hao-qax-widget">30号 QAx Widget</a></li></ul></li><li><a href="#input-widgets-shu-ru-bu-jian-zu">Input Widgets 输入部件组</a><ul><li><a href="#31-hao-combo-box">31号 Combo Box</a></li><li><a href="#32-hao-font-combo-box">32号 Font Combo Box</a></li><li><a href="#33-hao-line-edit">33号 Line Edit</a></li><li><a href="#34-hao-text-edit">34号 Text Edit</a></li><li><a href="#35-hao-plain-text-edit">35号 Plain Text Edit</a></li><li><a href="#36-hao-spin-box">36号 Spin Box</a></li><li><a href="#37-hao-double-spin-box">37号 Double Spin Box</a></li><li><a href="#38-hao-time-edit">38号 Time Edit</a></li><li><a href="#39-hao-date-edit">39号 Date Edit</a></li><li><a href="#40-hao-date-time-edit">40号 Date/Time Edit</a></li><li><a href="#41-hao-dial">41号 Dial</a></li><li><a href="#42-hao-horizontal-scroll-bar">42号 Horizontal Scroll Bar</a></li><li><a href="#43-hao-vertical-scroll-bar">43号 Vertical Scroll Bar</a></li><li><a href="#44-hao-horizontal-slider">44号 Horizontal Slider</a></li><li><a href="#45-hao-vertical-slider">45号 Vertical Slider</a></li><li><a href="#46-hao-key-sequence-edit">46号 Key Sequence Edit</a></li></ul></li><li><a href="#display-widgets-xian-shi-kong-jian-zu">Display Widgets 显示控件组</a><ul><li><a href="#47-hao-label">47号 Label</a></li><li><a href="#48-hao-text-browser">48号 text Browser</a></li><li><a href="#49-hao-graphics-view">49号 Graphics View</a></li><li><a href="#50-hao-calendar-widget">50号 Calendar Widget</a></li><li><a href="#51-hao-lcd-number">51号 Lcd Number</a></li><li><a href="#52-hao-progress-bar">52号 Progress Bar</a></li><li><a href="#53-hao-horizontal-line">53号 Horizontal Line</a></li><li><a href="#54-hao-vertical-line">54号 Vertical Line</a></li><li><a href="#55-hao-opengl-widget">55号 OpenGL Widget</a></li><li><a href="#56-hao-qquick-widget">56号 QQuick Widget</a></li></ul></li></ul><!-- tocstop --></div><h2><span id="qt-zu-jian-ku-di-1-31">QT组件库第1-31</span><a href="#qt-zu-jian-ku-di-1-31" class="header-anchor">#</a></h2><img src="https://gitee.com/txt1994/images/raw/master/img/QT/qtcreator_7pbSsW5UeS.png" style="zoom:110%;"><h2><span id="qt-zu-jian-ku-di-32-56">QT组件库第32-56</span><a href="#qt-zu-jian-ku-di-32-56" class="header-anchor">#</a></h2><img src="https://gitee.com/txt1994/images/raw/master/img/QT/qtcreator_PLS87txx9E.png" style="zoom:130%;"><hr><h2><span id="layouts-bu-ju-zu-jian-ku">Layouts 布局组件库</span><a href="#layouts-bu-ju-zu-jian-ku" class="header-anchor">#</a></h2><h3><span id="1-hao-vertical-layout">1号 Vertical Layout</span><a href="#1-hao-vertical-layout" class="header-anchor">#</a></h3><blockquote><p>垂直布局</p></blockquote><h3><span id="2-hao-horizontal-layout">2号 Horizontal Layout</span><a href="#2-hao-horizontal-layout" class="header-anchor">#</a></h3><blockquote><p>水平布局</p></blockquote><h3><span id="3-hao-grid-layout">3号 Grid Layout</span><a href="#3-hao-grid-layout" class="header-anchor">#</a></h3><blockquote><p>网格布局</p></blockquote><h3><span id="4-hao-form-layout">4号 Form Layout</span><a href="#4-hao-form-layout" class="header-anchor">#</a></h3><blockquote><p>表单布局</p></blockquote><hr><h2><span id="spacers-kong-jian-jian-ge-zu-dan-huang">Spacers 空间间隔组(弹簧)</span><a href="#spacers-kong-jian-jian-ge-zu-dan-huang" class="header-anchor">#</a></h2><h3><span id="5-hao-horizontal-spacer">5号 Horizontal Spacer</span><a href="#5-hao-horizontal-spacer" class="header-anchor">#</a></h3><blockquote><p>水平间隔</p></blockquote><h3><span id="6-hao-vertical-spacer">6号 Vertical Spacer</span><a href="#6-hao-vertical-spacer" class="header-anchor">#</a></h3><blockquote><p>垂直间隔</p></blockquote><hr><h2><span id="buttons-an-niu">Buttons 按钮</span><a href="#buttons-an-niu" class="header-anchor">#</a></h2><h3><span id="7-hao-push-button">7号 Push Button</span><a href="#7-hao-push-button" class="header-anchor">#</a></h3><blockquote></blockquote><h3><span id="8-hao-tool-button">8号 Tool Button</span><a href="#8-hao-tool-button" class="header-anchor">#</a></h3><blockquote></blockquote><h3><span id="9-hao-radio-button">9号 Radio Button</span><a href="#9-hao-radio-button" class="header-anchor">#</a></h3><blockquote></blockquote><h3><span id="10-hao-check-box">10号 Check Box</span><a href="#10-hao-check-box" class="header-anchor">#</a></h3><blockquote></blockquote><h3><span id="11-hao-command-link-button">11号 Command Link Button</span><a href="#11-hao-command-link-button" class="header-anchor">#</a></h3><blockquote></blockquote><h3><span id="12-hao-dialog-button-box">12号 Dialog Button Box</span><a href="#12-hao-dialog-button-box" class="header-anchor">#</a></h3><blockquote></blockquote><hr><h2><span id="item-views-model-based-qing-dan-shi-tu-zu">Item Views (Model-Based) 清单视图组</span><a href="#item-views-model-based-qing-dan-shi-tu-zu" class="header-anchor">#</a></h2><h3><span id="13-hao-list-view">13号 List View</span><a href="#13-hao-list-view" class="header-anchor">#</a></h3><blockquote><p>清单视图</p></blockquote><h3><span id="14-hao-tree-view">14号 Tree View</span><a href="#14-hao-tree-view" class="header-anchor">#</a></h3><blockquote><p>树视图</p></blockquote><h3><span id="15-hao-table-view">15号 Table View</span><a href="#15-hao-table-view" class="header-anchor">#</a></h3><blockquote><p>表视图</p></blockquote><h3><span id="16-hao-column-view">16号 Column View</span><a href="#16-hao-column-view" class="header-anchor">#</a></h3><blockquote><p>列视图</p></blockquote><h3><span id="17-hao-undo-view">17号 Undo View</span><a href="#17-hao-undo-view" class="header-anchor">#</a></h3><blockquote><p>撤消视图</p></blockquote><h2><span id="item-widgets-item-based-qing-dan-kong-jian-zu">Item Widgets (Item-Based) 清单控件组</span><a href="#item-widgets-item-based-qing-dan-kong-jian-zu" class="header-anchor">#</a></h2><h3><span id="18-hao-list-widget">18号 List Widget</span><a href="#18-hao-list-widget" class="header-anchor">#</a></h3><blockquote><p>清单控件</p></blockquote><h3><span id="19-hao-tree-widget">19号 Tree Widget</span><a href="#19-hao-tree-widget" class="header-anchor">#</a></h3><blockquote><p>树控件</p></blockquote><h3><span id="20-hao-table-widget">20号 Table Widget</span><a href="#20-hao-table-widget" class="header-anchor">#</a></h3><blockquote><p>表控件</p></blockquote><h2><span id="containers-rong-qi-zu">Containers 容器组</span><a href="#containers-rong-qi-zu" class="header-anchor">#</a></h2><h3><span id="21-hao-group-box">21号 Group Box</span><a href="#21-hao-group-box" class="header-anchor">#</a></h3><blockquote><p>组框</p></blockquote><h3><span id="22-hao-scroll-area">22号 Scroll Area</span><a href="#22-hao-scroll-area" class="header-anchor">#</a></h3><blockquote><p>滚动区域</p></blockquote><h3><span id="23-hao-tool-box">23号 Tool Box</span><a href="#23-hao-tool-box" class="header-anchor">#</a></h3><blockquote><p>工具箱</p></blockquote><h3><span id="24-hao-tab-widget">24号 Tab Widget</span><a href="#24-hao-tab-widget" class="header-anchor">#</a></h3><blockquote><p>标签小部件</p></blockquote><h3><span id="25-hao-stacked-widget">25号 Stacked Widget</span><a href="#25-hao-stacked-widget" class="header-anchor">#</a></h3><blockquote><p>堆叠部件</p></blockquote><h3><span id="26-hao-frame">26号 Frame</span><a href="#26-hao-frame" class="header-anchor">#</a></h3><blockquote><p>帧</p></blockquote><h3><span id="27-hao-widget">27号 Widget</span><a href="#27-hao-widget" class="header-anchor">#</a></h3><blockquote><p>小部件</p></blockquote><h3><span id="28-hao-mdi-area">28号 MDI Area</span><a href="#28-hao-mdi-area" class="header-anchor">#</a></h3><blockquote><p>MDI区域</p></blockquote><h3><span id="29-hao-dock-widget">29号 Dock Widget</span><a href="#29-hao-dock-widget" class="header-anchor">#</a></h3><blockquote><p>停靠窗口不见</p></blockquote><h3><span id="30-hao-qax-widget">30号 QAx Widget</span><a href="#30-hao-qax-widget" class="header-anchor">#</a></h3><blockquote><p>封装Flash的AciveX控件</p></blockquote><h2><span id="input-widgets-shu-ru-bu-jian-zu">Input Widgets 输入部件组</span><a href="#input-widgets-shu-ru-bu-jian-zu" class="header-anchor">#</a></h2><h3><span id="31-hao-combo-box">31号 Combo Box</span><a href="#31-hao-combo-box" class="header-anchor">#</a></h3><blockquote><p>组合框</p></blockquote><h3><span id="32-hao-font-combo-box">32号 Font Combo Box</span><a href="#32-hao-font-combo-box" class="header-anchor">#</a></h3><blockquote><p>字体组合框</p></blockquote><h3><span id="33-hao-line-edit">33号 Line Edit</span><a href="#33-hao-line-edit" class="header-anchor">#</a></h3><blockquote><p>行编辑</p></blockquote><h3><span id="34-hao-text-edit">34号 Text Edit</span><a href="#34-hao-text-edit" class="header-anchor">#</a></h3><blockquote><p>文本编辑</p></blockquote><h3><span id="35-hao-plain-text-edit">35号 Plain Text Edit</span><a href="#35-hao-plain-text-edit" class="header-anchor">#</a></h3><blockquote><p>纯文本编辑</p></blockquote><h3><span id="36-hao-spin-box">36号 Spin Box</span><a href="#36-hao-spin-box" class="header-anchor">#</a></h3><blockquote><p>数字显示框</p></blockquote><h3><span id="37-hao-double-spin-box">37号 Double Spin Box</span><a href="#37-hao-double-spin-box" class="header-anchor">#</a></h3><blockquote><p>双数字显示框</p></blockquote><h3><span id="38-hao-time-edit">38号 Time Edit</span><a href="#38-hao-time-edit" class="header-anchor">#</a></h3><blockquote><p>时间编辑</p></blockquote><h3><span id="39-hao-date-edit">39号 Date Edit</span><a href="#39-hao-date-edit" class="header-anchor">#</a></h3><blockquote><p>日期编辑</p></blockquote><h3><span id="40-hao-date-time-edit">40号 Date/Time Edit</span><a href="#40-hao-date-time-edit" class="header-anchor">#</a></h3><blockquote><p>日期或时间编辑</p></blockquote><h3><span id="41-hao-dial">41号 Dial</span><a href="#41-hao-dial" class="header-anchor">#</a></h3><blockquote><p>拨号</p></blockquote><h3><span id="42-hao-horizontal-scroll-bar">42号 Horizontal Scroll Bar</span><a href="#42-hao-horizontal-scroll-bar" class="header-anchor">#</a></h3><blockquote><p>水平滚动条</p></blockquote><h3><span id="43-hao-vertical-scroll-bar">43号 Vertical Scroll Bar</span><a href="#43-hao-vertical-scroll-bar" class="header-anchor">#</a></h3><blockquote><p>垂直滚动条</p></blockquote><h3><span id="44-hao-horizontal-slider">44号 Horizontal Slider</span><a href="#44-hao-horizontal-slider" class="header-anchor">#</a></h3><blockquote><p>水平滑块</p></blockquote><h3><span id="45-hao-vertical-slider">45号 Vertical Slider</span><a href="#45-hao-vertical-slider" class="header-anchor">#</a></h3><blockquote><p>垂直滑块</p></blockquote><h3><span id="46-hao-key-sequence-edit">46号 Key Sequence Edit</span><a href="#46-hao-key-sequence-edit" class="header-anchor">#</a></h3><blockquote><p>按键序列编辑</p></blockquote><h2><span id="display-widgets-xian-shi-kong-jian-zu">Display Widgets 显示控件组</span><a href="#display-widgets-xian-shi-kong-jian-zu" class="header-anchor">#</a></h2><h3><span id="47-hao-label">47号 Label</span><a href="#47-hao-label" class="header-anchor">#</a></h3><blockquote><p>标签</p></blockquote><h3><span id="48-hao-text-browser">48号 text Browser</span><a href="#48-hao-text-browser" class="header-anchor">#</a></h3><blockquote><p>文本浏览器</p></blockquote><h3><span id="49-hao-graphics-view">49号 Graphics View</span><a href="#49-hao-graphics-view" class="header-anchor">#</a></h3><blockquote><p>图形视图</p></blockquote><h3><span id="50-hao-calendar-widget">50号 Calendar Widget</span><a href="#50-hao-calendar-widget" class="header-anchor">#</a></h3><blockquote><p>日历</p></blockquote><h3><span id="51-hao-lcd-number">51号 Lcd Number</span><a href="#51-hao-lcd-number" class="header-anchor">#</a></h3><blockquote><p>液晶数字</p></blockquote><h3><span id="52-hao-progress-bar">52号 Progress Bar</span><a href="#52-hao-progress-bar" class="header-anchor">#</a></h3><blockquote><p>进度条</p></blockquote><h3><span id="53-hao-horizontal-line">53号 Horizontal Line</span><a href="#53-hao-horizontal-line" class="header-anchor">#</a></h3><blockquote><p>水平线</p></blockquote><h3><span id="54-hao-vertical-line">54号 Vertical Line</span><a href="#54-hao-vertical-line" class="header-anchor">#</a></h3><blockquote><p>垂直线</p></blockquote><h3><span id="55-hao-opengl-widget">55号 OpenGL Widget</span><a href="#55-hao-opengl-widget" class="header-anchor">#</a></h3><blockquote><p>开放式图形工具</p></blockquote><h3><span id="56-hao-qquick-widget">56号 QQuick Widget</span><a href="#56-hao-qquick-widget" class="header-anchor">#</a></h3><blockquote><p>嵌入QML工具</p></blockquote>]]></content>
    
    
    
    <tags>
      
      <tag>C++</tag>
      
      <tag>QT</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Me</title>
    <link href="/2022/01/24/Me/"/>
    <url>/2022/01/24/Me/</url>
    
    <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="抱歉, 这个密码看着不太对, 请再试试." data-whm="抱歉, 这个文章不能被校验, 不过您还是能看看解密后的内容.">  <script id="hbeData" type="hbeData" data-hmacdigest="7ec3de609d56565bc8c21c66e0f2769850c520884cc3e17af93c762cb1c3f349">10d79030e8222445804370796b90fca13d0e91ddbfe90aeab5b3b0f5b0a8d5411b795be55d52a34b96986f15b78e9fe3958899ace1474bd822c9fe38aa14e7f8ea5bd8bac98a77bb63d279174bf7db16d47811bc7b34d1497f4074e1f449fb1bb7a9ed5fb3a7d90e2acddae124f1457aa4dbf50f7d161a7f51be99c340786dc1d40e39fff97dffb07de008089f80d3490f6b0a5b6d815c55b33ba82a452e9b843d8a02b101a34873e514d09c568af5dcced13321aec29f97e6aba14361679bca9050f10260bc62ce59b0dbaee6977ad5965576588e0f053f0333118ea1623e69062f1067b8aa532811e351b9a999138c98d4dace8c29c2fe523a8a0f9780935fbd688f9767b6d5fc7c5e84a5a1f1970b456051d4d68da983c814c19ad1e205da2598f89a88381daacc5aefdd70efa4359b806b99ec63f97b0b4445baba8f6907516b188240594c9304c7f922ed84bdc1</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-default">      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-default">您好, 这里需要密码, 请点击本文字.</span>      </label>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>模板</title>
    <link href="/2022/01/23/%E6%A8%A1%E6%9D%BF/"/>
    <url>/2022/01/23/%E6%A8%A1%E6%9D%BF/</url>
    
    <content type="html"><![CDATA[<div class="toc"><!-- toc --><ul><li><a href="#1-mo-ban">1 模板</a><ul><li><a href="#1-1-mo-ban-de-gai-nian">1.1 模板的概念</a></li><li><a href="#1-2-han-shu-mo-ban">1.2 函数模板</a></li><li><a href="#1-3-lei-mo-ban">1.3 类模板</a></li></ul></li><li><a href="#2-stl-chu-shi">2 STL初识</a><ul><li><a href="#2-1-stl-de-dan-sheng">2.1 STL的诞生</a></li><li><a href="#2-2-stl-ji-ben-gai-nian">2.2 STL基本概念</a></li><li><a href="#2-3-stl-liu-da-zu-jian">2.3 STL六大组件</a></li><li><a href="#2-4-stl-zhong-rong-qi-suan-fa-die-dai-qi">2.4 STL中容器、算法、迭代器</a></li><li><a href="#2-5-rong-qi-suan-fa-die-dai-qi-chu-shi">2.5 容器算法迭代器初识</a></li></ul></li><li><a href="#3-stl-chang-yong-rong-qi">3 STL- 常用容器</a><ul><li><a href="#3-1-string-rong-qi">3.1 string容器</a></li><li><a href="#3-2-vector-rong-qi">3.2 vector容器</a></li><li><a href="#3-3-deque-rong-qi">3.3 deque容器</a></li><li><a href="#3-4-an-li-ping-wei-da-fen">3.4 案例-评委打分</a></li><li><a href="#3-5-stack-rong-qi">3.5 stack容器</a></li><li><a href="#3-6-queue-rong-qi">3.6 queue 容器</a></li><li><a href="#3-7-list-rong-qi">3.7 list容器</a></li><li><a href="#3-8-set-multiset-rong-qi">3.8 set/ multiset 容器</a></li><li><a href="#3-9-map-multimap-rong-qi">3.9 map/ multimap容器</a></li><li><a href="#3-10-an-li-yuan-gong-fen-zu">3.10 案例-员工分组</a></li><li><a href="#3-11-unordered-map-unordered-multimap-rong-qi">3.11 unordered_map/unordered_multimap容器</a></li><li><a href="#3-12-unordered-set-unordered-multiset-rong-qi">3.12 unordered_set/unordered_multiset容器</a></li></ul></li><li><a href="#4-stl-han-shu-dui-xiang">4 STL- 函数对象</a><ul><li><a href="#4-1-han-shu-dui-xiang">4.1 函数对象</a></li><li><a href="#4-2-wei-ci">4.2 谓词</a></li><li><a href="#4-3-nei-jian-han-shu-dui-xiang">4.3 内建函数对象</a></li></ul></li><li><a href="#5-stl-chang-yong-suan-fa">5 STL- 常用算法</a><ul><li><a href="#5-1-chang-yong-bian-li-suan-fa">5.1 常用遍历算法</a></li><li><a href="#5-2-chang-yong-cha-zhao-suan-fa">5.2 常用查找算法</a></li><li><a href="#5-3-chang-yong-pai-xu-suan-fa">5.3 常用排序算法</a></li><li><a href="#5-4-chang-yong-kao-bei-he-ti-huan-suan-fa">5.4 常用拷贝和替换算法</a></li><li><a href="#5-5-chang-yong-suan-zhu-sheng-cheng-suan-fa">5.5 常用算术生成算法</a></li><li><a href="#5-6-chang-yong-ji-he-suan-fa">5.6 常用集合算法</a></li><li><a href="#5-7-chang-yong-bi-jiao-suan-fa">5.7 常用比较算法</a></li></ul></li></ul><!-- tocstop --></div><p>本阶段主要针对C++<strong>泛型编程</strong>和<strong>STL</strong>技术做详细讲解，探讨C++更深层的使用</p><h2><span id="1-mo-ban">1 模板</span><a href="#1-mo-ban" class="header-anchor">#</a></h2><h3><span id="1-1-mo-ban-de-gai-nian">1.1 模板的概念</span><a href="#1-1-mo-ban-de-gai-nian" class="header-anchor">#</a></h3><p>模板就是建立<strong>通用的模具</strong>，大大<strong>提高复用性</strong></p><p>模板的特点：</p><ul><li>模板不可以直接使用，它只是一个框架</li><li>模板的通用并不是万能的</li></ul><h3><span id="1-2-han-shu-mo-ban">1.2 函数模板</span><a href="#1-2-han-shu-mo-ban" class="header-anchor">#</a></h3><ul><li><p>C++另一种编程思想称为 <strong>泛型编程</strong> ，主要利用的技术就是模板</p></li><li><p>C++提供两种模板机制:<strong>函数模板</strong>和<strong>类模板</strong></p></li></ul><h4><span id="1-2-1-han-shu-mo-ban-yu-fa">1.2.1 函数模板语法</span><a href="#1-2-1-han-shu-mo-ban-yu-fa" class="header-anchor">#</a></h4><p>函数模板作用：</p><p>建立一个通用函数，其函数返回值类型和形参类型可以不具体制定，用一个<strong>虚拟的类型</strong>来代表。</p><p><strong>语法：</strong></p><div class="code-wrapper"><pre><code class="hljs C++"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;函数声明或定义</code></pre></div><p><strong>解释：</strong></p><p>template — 声明创建模板</p><p>typename — 表面其后面的符号是一种数据类型，可以用class代替</p><p>T — 通用的数据类型，名称可以替换，通常为大写字母</p><p><strong>示例：</strong></p><div class="code-wrapper"><pre><code class="hljs C++"><span class="hljs-comment">//交换整型函数</span><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">swapInt</span><span class="hljs-params">(<span class="hljs-type">int</span>&amp; a, <span class="hljs-type">int</span>&amp; b)</span> </span>{    <span class="hljs-type">int</span> temp = a;    a = b;    b = temp;} <span class="hljs-comment">//交换浮点型函数</span><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">swapDouble</span><span class="hljs-params">(<span class="hljs-type">double</span>&amp; a, <span class="hljs-type">double</span>&amp; b)</span> </span>{    <span class="hljs-type">double</span> temp = a;    a = b;    b = temp;} <span class="hljs-comment">//利用模板提供通用的交换函数</span><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;</span><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">mySwap</span><span class="hljs-params">(T&amp; a, T&amp; b)</span></span><span class="hljs-function"></span>{    T temp = a;    a = b;    b = temp;} <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test01</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>{    <span class="hljs-type">int</span> a = <span class="hljs-number">10</span>;    <span class="hljs-type">int</span> b = <span class="hljs-number">20</span>;        <span class="hljs-comment">//swapInt(a, b);</span>     <span class="hljs-comment">//利用模板实现交换</span>    <span class="hljs-comment">//1、自动类型推导</span>    <span class="hljs-built_in">mySwap</span>(a, b);     <span class="hljs-comment">//2、显示指定类型</span>    <span class="hljs-built_in">mySwap</span>&lt;<span class="hljs-type">int</span>&gt;(a, b);     cout &lt;&lt; <span class="hljs-string">"a = "</span> &lt;&lt; a &lt;&lt; endl;    cout &lt;&lt; <span class="hljs-string">"b = "</span> &lt;&lt; b &lt;&lt; endl; } <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>{     <span class="hljs-built_in">test01</span>();     <span class="hljs-built_in">system</span>(<span class="hljs-string">"pause"</span>);     <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;}</code></pre></div><p>总结：</p><ul><li>函数模板利用关键字 template</li><li>使用函数模板有两种方式：自动类型推导、显示指定类型</li><li>模板的目的是为了提高复用性，将类型参数化</li></ul><h4><span id="1-2-2-han-shu-mo-ban-zhu-yi-shi-xiang">1.2.2 函数模板注意事项</span><a href="#1-2-2-han-shu-mo-ban-zhu-yi-shi-xiang" class="header-anchor">#</a></h4><p>注意事项：</p><ul><li><p>自动类型推导，必须推导出一致的数据类型T,才可以使用</p></li><li><p>模板必须要确定出T的数据类型，才可以使用</p></li></ul><p><strong>示例：</strong></p><div class="code-wrapper"><pre><code class="hljs C++"><span class="hljs-comment">//利用模板提供通用的交换函数</span><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span> T&gt;</span><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">mySwap</span><span class="hljs-params">(T&amp; a, T&amp; b)</span></span><span class="hljs-function"></span>{    T temp = a;    a = b;    b = temp;}  <span class="hljs-comment">// 1、自动类型推导，必须推导出一致的数据类型T,才可以使用</span><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test01</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>{    <span class="hljs-type">int</span> a = <span class="hljs-number">10</span>;    <span class="hljs-type">int</span> b = <span class="hljs-number">20</span>;    <span class="hljs-type">char</span> c = <span class="hljs-string">'c'</span>;     <span class="hljs-built_in">mySwap</span>(a, b); <span class="hljs-comment">// 正确，可以推导出一致的T</span>    <span class="hljs-comment">//mySwap(a, c); // 错误，推导不出一致的T类型</span>}  <span class="hljs-comment">// 2、模板必须要确定出T的数据类型，才可以使用</span><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span> T&gt;</span><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">func</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>{    cout &lt;&lt; <span class="hljs-string">"func 调用"</span> &lt;&lt; endl;} <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test02</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>{    <span class="hljs-comment">//func(); //错误，模板不能独立使用，必须确定出T的类型</span>    <span class="hljs-built_in">func</span>&lt;<span class="hljs-type">int</span>&gt;(); <span class="hljs-comment">//利用显示指定类型的方式，给T一个类型，才可以使用该模板</span>} <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>{     <span class="hljs-built_in">test01</span>();    <span class="hljs-built_in">test02</span>();     <span class="hljs-built_in">system</span>(<span class="hljs-string">"pause"</span>);     <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;}</code></pre></div><p>总结：</p><ul><li>使用模板时必须确定出通用数据类型T，并且能够推导出一致的类型</li></ul><h4><span id="1-2-3-han-shu-mo-ban-an-li">1.2.3 函数模板案例</span><a href="#1-2-3-han-shu-mo-ban-an-li" class="header-anchor">#</a></h4><p>案例描述：</p><ul><li>利用函数模板封装一个排序的函数，可以对<strong>不同数据类型数组</strong>进行排序</li><li>排序规则从大到小，排序算法为<strong>选择排序</strong></li><li>分别利用<strong>char数组</strong>和<strong>int数组</strong>进行测试</li></ul><p>示例：</p><div class="code-wrapper"><pre><code class="hljs C++"><span class="hljs-comment">//交换的函数模板</span><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;</span><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">mySwap</span><span class="hljs-params">(T &amp;a, T&amp;b)</span></span><span class="hljs-function"></span>{    T temp = a;    a = b;    b = temp;}  <span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">T</span>&gt; <span class="hljs-comment">// 也可以替换成typename</span><span class="hljs-comment">//利用选择排序，进行对数组从大到小的排序</span><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">mySort</span><span class="hljs-params">(T arr[], <span class="hljs-type">int</span> len)</span></span><span class="hljs-function"></span>{    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; len; i++)    {        <span class="hljs-type">int</span> max = i; <span class="hljs-comment">//最大数的下标</span>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = i + <span class="hljs-number">1</span>; j &lt; len; j++)        {            <span class="hljs-keyword">if</span> (arr[max] &lt; arr[j])            {                max = j;            }        }        <span class="hljs-keyword">if</span> (max != i) <span class="hljs-comment">//如果最大数的下标不是i，交换两者</span>        {            <span class="hljs-built_in">mySwap</span>(arr[max], arr[i]);        }    }}<span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;</span><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">printArray</span><span class="hljs-params">(T arr[], <span class="hljs-type">int</span> len)</span> </span>{     <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; len; i++) {        cout &lt;&lt; arr[i] &lt;&lt; <span class="hljs-string">" "</span>;    }    cout &lt;&lt; endl;}<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test01</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>{    <span class="hljs-comment">//测试char数组</span>    <span class="hljs-type">char</span> charArr[] = <span class="hljs-string">"bdcfeagh"</span>;    <span class="hljs-type">int</span> num = <span class="hljs-built_in">sizeof</span>(charArr) / <span class="hljs-built_in">sizeof</span>(<span class="hljs-type">char</span>);    <span class="hljs-built_in">mySort</span>(charArr, num);    <span class="hljs-built_in">printArray</span>(charArr, num);} <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test02</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>{    <span class="hljs-comment">//测试int数组</span>    <span class="hljs-type">int</span> intArr[] = { <span class="hljs-number">7</span>, <span class="hljs-number">5</span>, <span class="hljs-number">8</span>, <span class="hljs-number">1</span>, <span class="hljs-number">3</span>, <span class="hljs-number">9</span>, <span class="hljs-number">2</span>, <span class="hljs-number">4</span>, <span class="hljs-number">6</span> };    <span class="hljs-type">int</span> num = <span class="hljs-built_in">sizeof</span>(intArr) / <span class="hljs-built_in">sizeof</span>(<span class="hljs-type">int</span>);    <span class="hljs-built_in">mySort</span>(intArr, num);    <span class="hljs-built_in">printArray</span>(intArr, num);} <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>{     <span class="hljs-built_in">test01</span>();    <span class="hljs-built_in">test02</span>();     <span class="hljs-built_in">system</span>(<span class="hljs-string">"pause"</span>);     <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;}</code></pre></div><p>总结：模板可以提高代码复用，需要熟练掌握</p><h4><span id="1-2-4-pu-tong-han-shu-yu-han-shu-mo-ban-de-qu-bie">1.2.4 普通函数与函数模板的区别</span><a href="#1-2-4-pu-tong-han-shu-yu-han-shu-mo-ban-de-qu-bie" class="header-anchor">#</a></h4><p><strong>普通函数与函数模板区别：</strong></p><ul><li>普通函数调用时可以发生自动类型转换（隐式类型转换）</li><li>函数模板调用时，如果利用自动类型推导，不会发生隐式类型转换</li><li>如果利用显示指定类型的方式，可以发生隐式类型转换</li></ul><p><strong>示例：</strong></p><div class="code-wrapper"><pre><code class="hljs C++"><span class="hljs-comment">//普通函数</span><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">myAdd01</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span></span><span class="hljs-function"></span>{    <span class="hljs-keyword">return</span> a + b;} <span class="hljs-comment">//函数模板</span><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span> T&gt;</span><span class="hljs-function">T <span class="hljs-title">myAdd02</span><span class="hljs-params">(T a, T b)</span>  </span><span class="hljs-function"> </span>{    <span class="hljs-keyword">return</span> a + b;} <span class="hljs-comment">//使用函数模板时，如果用自动类型推导，不会发生自动类型转换,即隐式类型转换</span><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test01</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>{    <span class="hljs-type">int</span> a = <span class="hljs-number">10</span>;    <span class="hljs-type">int</span> b = <span class="hljs-number">20</span>;    <span class="hljs-type">char</span> c = <span class="hljs-string">'c'</span>;        cout &lt;&lt; <span class="hljs-built_in">myAdd01</span>(a, c) &lt;&lt; endl; <span class="hljs-comment">//正确，将char类型的'c'隐式转换为int类型  'c' 对应 ASCII码 99</span>     <span class="hljs-comment">//myAdd02(a, c); // 报错，使用自动类型推导时，不会发生隐式类型转换</span>     <span class="hljs-built_in">myAdd02</span>&lt;<span class="hljs-type">int</span>&gt;(a, c); <span class="hljs-comment">//正确，如果用显示指定类型，可以发生隐式类型转换</span>} <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>{     <span class="hljs-built_in">test01</span>();     <span class="hljs-built_in">system</span>(<span class="hljs-string">"pause"</span>);     <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;}</code></pre></div><p>总结：建议使用显示指定类型的方式，调用函数模板，因为可以自己确定通用类型T</p><h4><span id="1-2-5-pu-tong-han-shu-yu-han-shu-mo-ban-de-diao-yong-gui-ze">1.2.5 普通函数与函数模板的调用规则</span><a href="#1-2-5-pu-tong-han-shu-yu-han-shu-mo-ban-de-diao-yong-gui-ze" class="header-anchor">#</a></h4><p>调用规则如下：</p><ol><li>如果函数模板和普通函数都可以实现，优先调用普通函数</li><li>可以通过空模板参数列表来强制调用函数模板</li><li>函数模板也可以发生重载</li><li>如果函数模板可以产生更好的匹配,优先调用函数模板</li></ol><p><strong>示例：</strong></p><div class="code-wrapper"><pre><code class="hljs C++"><span class="hljs-comment">//普通函数与函数模板调用规则</span><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">myPrint</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span></span><span class="hljs-function"></span>{    cout &lt;&lt; <span class="hljs-string">"调用的普通函数"</span> &lt;&lt; endl;} <span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;</span><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">myPrint</span><span class="hljs-params">(T a, T b)</span> </span><span class="hljs-function"></span>{     cout &lt;&lt; <span class="hljs-string">"调用的模板"</span> &lt;&lt; endl;} <span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;</span><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">myPrint</span><span class="hljs-params">(T a, T b, T c)</span> </span><span class="hljs-function"></span>{     cout &lt;&lt; <span class="hljs-string">"调用重载的模板"</span> &lt;&lt; endl; } <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test01</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>{    <span class="hljs-comment">//1、如果函数模板和普通函数都可以实现，优先调用普通函数</span>    <span class="hljs-comment">// 注意 如果告诉编译器  普通函数是有的，但只是声明没有实现，或者不在当前文件内实现，就会报错找不到</span>    <span class="hljs-type">int</span> a = <span class="hljs-number">10</span>;    <span class="hljs-type">int</span> b = <span class="hljs-number">20</span>;    <span class="hljs-built_in">myPrint</span>(a, b); <span class="hljs-comment">//调用普通函数</span>     <span class="hljs-comment">//2、可以通过空模板参数列表来强制调用函数模板</span>    myPrint&lt;&gt;(a, b); <span class="hljs-comment">//调用函数模板</span>     <span class="hljs-comment">//3、函数模板也可以发生重载</span>    <span class="hljs-type">int</span> c = <span class="hljs-number">30</span>;    <span class="hljs-built_in">myPrint</span>(a, b, c); <span class="hljs-comment">//调用重载的函数模板</span>     <span class="hljs-comment">//4、 如果函数模板可以产生更好的匹配,优先调用函数模板</span>    <span class="hljs-type">char</span> c1 = <span class="hljs-string">'a'</span>;    <span class="hljs-type">char</span> c2 = <span class="hljs-string">'b'</span>;    <span class="hljs-built_in">myPrint</span>(c1, c2); <span class="hljs-comment">//调用函数模板</span>} <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>{     <span class="hljs-built_in">test01</span>();     <span class="hljs-built_in">system</span>(<span class="hljs-string">"pause"</span>);     <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;}</code></pre></div><p>总结：既然提供了函数模板，最好就不要提供普通函数，否则容易出现二义性</p><h4><span id="1-2-6-mo-ban-de-ju-xian-xing">1.2.6 模板的局限性</span><a href="#1-2-6-mo-ban-de-ju-xian-xing" class="header-anchor">#</a></h4><p><strong>局限性：</strong></p><ul><li>模板的通用性并不是万能的</li></ul><p><strong>例如：</strong></p><div class="code-wrapper"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span> T&gt;</span><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">f</span><span class="hljs-params">(T a, T b)</span></span><span class="hljs-function"></span>{     a = b;}</code></pre></div><p>在上述代码中提供的赋值操作，如果传入的a和b是一个数组，就无法实现了</p><p>再例如：</p><div class="code-wrapper"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span> T&gt;</span><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">f</span><span class="hljs-params">(T a, T b)</span></span><span class="hljs-function"></span>{     <span class="hljs-keyword">if</span>(a &gt; b) { ... }}</code></pre></div><p>在上述代码中，如果T的数据类型传入的是像Person这样的自定义数据类型，也无法正常运行</p><p>因此C++为了解决这种问题，提供模板的重载，可以为这些<strong>特定的类型</strong>提供<strong>具体化的模板</strong></p><p><strong>示例：</strong></p><div class="code-wrapper"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std; <span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span>{<span class="hljs-keyword">public</span>:    <span class="hljs-built_in">Person</span>(string name, <span class="hljs-type">int</span> age)    {        <span class="hljs-keyword">this</span>-&gt;m_Name = name;        <span class="hljs-keyword">this</span>-&gt;m_Age = age;    }    string m_Name;    <span class="hljs-type">int</span> m_Age;}; <span class="hljs-comment">//普通函数模板</span><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span> T&gt;</span><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">myCompare</span><span class="hljs-params">(T&amp; a, T&amp; b)</span></span><span class="hljs-function"></span>{    <span class="hljs-keyword">if</span> (a == b)    {        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;    }    <span class="hljs-keyword">else</span>    {        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;    }}  <span class="hljs-comment">//具体化，显示具体化的原型和定意思以template&lt;&gt;开头，并通过名称来指出类型</span><span class="hljs-comment">//具体化优先于常规模板</span><span class="hljs-keyword">template</span>&lt;&gt; <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">myCompare</span><span class="hljs-params">(Person &amp;p1, Person &amp;p2)</span></span><span class="hljs-function"></span>{    <span class="hljs-keyword">if</span> ( p1.m_Name  == p2.m_Name &amp;&amp; p1.m_Age == p2.m_Age)    {        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;    }    <span class="hljs-keyword">else</span>    {        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;    }} <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test01</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>{    <span class="hljs-type">int</span> a = <span class="hljs-number">10</span>;    <span class="hljs-type">int</span> b = <span class="hljs-number">20</span>;    <span class="hljs-comment">//内置数据类型可以直接使用通用的函数模板</span>    <span class="hljs-type">bool</span> ret = <span class="hljs-built_in">myCompare</span>(a, b);    <span class="hljs-keyword">if</span> (ret)    {        cout &lt;&lt; <span class="hljs-string">"a == b "</span> &lt;&lt; endl;    }    <span class="hljs-keyword">else</span>    {        cout &lt;&lt; <span class="hljs-string">"a != b "</span> &lt;&lt; endl;    }} <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test02</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>{    <span class="hljs-function">Person <span class="hljs-title">p1</span><span class="hljs-params">(<span class="hljs-string">"Tom"</span>, <span class="hljs-number">10</span>)</span></span>;    <span class="hljs-function">Person <span class="hljs-title">p2</span><span class="hljs-params">(<span class="hljs-string">"Tom"</span>, <span class="hljs-number">10</span>)</span></span>;    <span class="hljs-comment">//自定义数据类型，不会调用普通的函数模板</span>    <span class="hljs-comment">//可以创建具体化的Person数据类型的模板，用于特殊处理这个类型</span>    <span class="hljs-type">bool</span> ret = <span class="hljs-built_in">myCompare</span>(p1, p2);    <span class="hljs-keyword">if</span> (ret)    {        cout &lt;&lt; <span class="hljs-string">"p1 == p2 "</span> &lt;&lt; endl;    }    <span class="hljs-keyword">else</span>    {        cout &lt;&lt; <span class="hljs-string">"p1 != p2 "</span> &lt;&lt; endl;    }} <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>{     <span class="hljs-built_in">test01</span>();     <span class="hljs-built_in">test02</span>();     <span class="hljs-built_in">system</span>(<span class="hljs-string">"pause"</span>);     <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;}</code></pre></div><p>总结：</p><ul><li>利用具体化的模板，可以解决自定义类型的通用化</li><li>学习模板并不是为了写模板，而是在STL能够运用系统提供的模板</li></ul><h3><span id="1-3-lei-mo-ban">1.3 类模板</span><a href="#1-3-lei-mo-ban" class="header-anchor">#</a></h3><h4><span id="1-3-1-lei-mo-ban-yu-fa">1.3.1 类模板语法</span><a href="#1-3-1-lei-mo-ban-yu-fa" class="header-anchor">#</a></h4><p>类模板作用：</p><ul><li>建立一个通用类，类中的成员 数据类型可以不具体制定，用一个<strong>虚拟的类型</strong>来代表。</li></ul><p><strong>语法：</strong></p><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;类</code></pre></div><p><strong>解释：</strong></p><p>template — 声明创建模板</p><p>typename — 表面其后面的符号是一种数据类型，可以用class代替</p><p>T — 通用的数据类型，名称可以替换，通常为大写字母</p><p><strong>示例：</strong></p><div class="code-wrapper"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span><span class="hljs-comment">//类模板</span><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">NameType</span>, <span class="hljs-keyword">class</span> <span class="hljs-title class_">AgeType</span>&gt; <span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span>{<span class="hljs-keyword">public</span>:    <span class="hljs-built_in">Person</span>(NameType name, AgeType age)    {        <span class="hljs-keyword">this</span>-&gt;mName = name;        <span class="hljs-keyword">this</span>-&gt;mAge = age;    }    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">showPerson</span><span class="hljs-params">()</span></span><span class="hljs-function">    </span>{        cout &lt;&lt; <span class="hljs-string">"name: "</span> &lt;&lt; <span class="hljs-keyword">this</span>-&gt;mName &lt;&lt; <span class="hljs-string">" age: "</span> &lt;&lt; <span class="hljs-keyword">this</span>-&gt;mAge &lt;&lt; endl;    }<span class="hljs-keyword">public</span>:    NameType mName;    AgeType mAge;}; <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test01</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>{    <span class="hljs-comment">// 指定NameType 为string类型，AgeType 为 int类型</span>    Person&lt;string, <span class="hljs-type">int</span>&gt;<span class="hljs-built_in">P1</span>(<span class="hljs-string">"孙悟空"</span>, <span class="hljs-number">999</span>);    P1.<span class="hljs-built_in">showPerson</span>();} <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>{     <span class="hljs-built_in">test01</span>();     <span class="hljs-built_in">system</span>(<span class="hljs-string">"pause"</span>);     <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;}</code></pre></div><p>总结：类模板和函数模板语法相似，在声明模板template后面加类，此类称为类模板</p><h4><span id="1-3-2-lei-mo-ban-yu-han-shu-mo-ban-qu-bie">1.3.2 类模板与函数模板区别</span><a href="#1-3-2-lei-mo-ban-yu-han-shu-mo-ban-qu-bie" class="header-anchor">#</a></h4><p>类模板与函数模板区别主要有两点：</p><ol><li>类模板没有自动类型推导的使用方式</li><li>类模板在模板参数列表中可以有默认参数</li></ol><p><strong>示例：</strong></p><div class="code-wrapper"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span><span class="hljs-comment">//类模板</span><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">NameType</span>, <span class="hljs-keyword">class</span> <span class="hljs-title class_">AgeType</span> = <span class="hljs-type">int</span>&gt; <span class="hljs-keyword">class</span> Person{<span class="hljs-keyword">public</span>:    <span class="hljs-built_in">Person</span>(NameType name, AgeType age)    {        <span class="hljs-keyword">this</span>-&gt;mName = name;        <span class="hljs-keyword">this</span>-&gt;mAge = age;    }    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">showPerson</span><span class="hljs-params">()</span></span><span class="hljs-function">    </span>{        cout &lt;&lt; <span class="hljs-string">"name: "</span> &lt;&lt; <span class="hljs-keyword">this</span>-&gt;mName &lt;&lt; <span class="hljs-string">" age: "</span> &lt;&lt; <span class="hljs-keyword">this</span>-&gt;mAge &lt;&lt; endl;    }<span class="hljs-keyword">public</span>:    NameType mName;    AgeType mAge;}; <span class="hljs-comment">//1、类模板没有自动类型推导的使用方式</span><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test01</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>{    <span class="hljs-comment">// Person p("孙悟空", 1000); // 错误 类模板使用时候，不可以用自动类型推导</span>    Person &lt;string ,<span class="hljs-type">int</span>&gt;<span class="hljs-built_in">p</span>(<span class="hljs-string">"孙悟空"</span>, <span class="hljs-number">1000</span>); <span class="hljs-comment">//必须使用显示指定类型的方式，使用类模板</span>    p.<span class="hljs-built_in">showPerson</span>();} <span class="hljs-comment">//2、类模板在模板参数列表中可以有默认参数</span><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test02</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>{    Person &lt;string&gt; <span class="hljs-built_in">p</span>(<span class="hljs-string">"猪八戒"</span>, <span class="hljs-number">999</span>); <span class="hljs-comment">//类模板中的模板参数列表 可以指定默认参数</span>    p.<span class="hljs-built_in">showPerson</span>();} <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>{     <span class="hljs-built_in">test01</span>();     <span class="hljs-built_in">test02</span>();     <span class="hljs-built_in">system</span>(<span class="hljs-string">"pause"</span>);     <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;}</code></pre></div><p>总结：</p><ul><li>类模板使用只能用显示指定类型方式</li><li>类模板中的模板参数列表可以有默认参数</li></ul><h4><span id="1-3-3-lei-mo-ban-zhong-cheng-yuan-han-shu-chuang-jian-shi-ji">1.3.3 类模板中成员函数创建时机</span><a href="#1-3-3-lei-mo-ban-zhong-cheng-yuan-han-shu-chuang-jian-shi-ji" class="header-anchor">#</a></h4><p>类模板中成员函数和普通类中成员函数创建时机是有区别的：</p><ul><li>普通类中的成员函数一开始就可以创建</li><li>类模板中的成员函数在调用时才创建</li></ul><p><strong>示例：</strong></p><div class="code-wrapper"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person1</span>{<span class="hljs-keyword">public</span>:    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">showPerson1</span><span class="hljs-params">()</span></span><span class="hljs-function">    </span>{        cout &lt;&lt; <span class="hljs-string">"Person1 show"</span> &lt;&lt; endl;    }}; <span class="hljs-keyword">class</span> <span class="hljs-title class_">Person2</span>{<span class="hljs-keyword">public</span>:    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">showPerson2</span><span class="hljs-params">()</span></span><span class="hljs-function">    </span>{        cout &lt;&lt; <span class="hljs-string">"Person2 show"</span> &lt;&lt; endl;    }}; <span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">T</span>&gt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">MyClass</span>{<span class="hljs-keyword">public</span>:    T obj;     <span class="hljs-comment">//类模板中的成员函数，并不是一开始就创建的，而是在模板调用时再生成</span>     <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">fun1</span><span class="hljs-params">()</span> </span>{ obj.<span class="hljs-built_in">showPerson1</span>(); }    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">fun2</span><span class="hljs-params">()</span> </span>{ obj.<span class="hljs-built_in">showPerson2</span>(); } }; <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test01</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>{    MyClass&lt;Person1&gt; m;        m.<span class="hljs-built_in">fun1</span>();     <span class="hljs-comment">//m.fun2();//编译会出错，说明函数调用才会去创建成员函数</span>} <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>{     <span class="hljs-built_in">test01</span>();     <span class="hljs-built_in">system</span>(<span class="hljs-string">"pause"</span>);     <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;}</code></pre></div><p>总结：类模板中的成员函数并不是一开始就创建的，在调用时才去创建</p><h4><span id="1-3-4-lei-mo-ban-dui-xiang-zuo-han-shu-can-shu">1.3.4 类模板对象做函数参数</span><a href="#1-3-4-lei-mo-ban-dui-xiang-zuo-han-shu-can-shu" class="header-anchor">#</a></h4><p>学习目标：</p><ul><li>类模板实例化出的对象，向函数传参的方式</li></ul><p>一共有三种传入方式：</p><ol><li>指定传入的类型 — 直接显示对象的数据类型</li><li>参数模板化 — 将对象中的参数变为模板进行传递</li><li>整个类模板化 — 将这个对象类型模板化进行传递</li></ol><p><strong>示例：</strong></p><div class="code-wrapper"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span><span class="hljs-comment">//类模板</span><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">NameType</span>, <span class="hljs-keyword">class</span> <span class="hljs-title class_">AgeType</span> = <span class="hljs-type">int</span>&gt; <span class="hljs-keyword">class</span> Person{<span class="hljs-keyword">public</span>:    <span class="hljs-built_in">Person</span>(NameType name, AgeType age)    {        <span class="hljs-keyword">this</span>-&gt;mName = name;        <span class="hljs-keyword">this</span>-&gt;mAge = age;    }    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">showPerson</span><span class="hljs-params">()</span></span><span class="hljs-function">    </span>{        cout &lt;&lt; <span class="hljs-string">"name: "</span> &lt;&lt; <span class="hljs-keyword">this</span>-&gt;mName &lt;&lt; <span class="hljs-string">" age: "</span> &lt;&lt; <span class="hljs-keyword">this</span>-&gt;mAge &lt;&lt; endl;    }<span class="hljs-keyword">public</span>:    NameType mName;    AgeType mAge;}; <span class="hljs-comment">//1、指定传入的类型</span><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">printPerson1</span><span class="hljs-params">(Person&lt;string, <span class="hljs-type">int</span>&gt; &amp;p)</span> </span><span class="hljs-function"></span>{    p.<span class="hljs-built_in">showPerson</span>();}<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test01</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>{    Person &lt;string, <span class="hljs-type">int</span> &gt;<span class="hljs-built_in">p</span>(<span class="hljs-string">"孙悟空"</span>, <span class="hljs-number">100</span>);    <span class="hljs-built_in">printPerson1</span>(p);} <span class="hljs-comment">//2、参数模板化</span><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">T1</span>, <span class="hljs-keyword">class</span> <span class="hljs-title class_">T2</span>&gt;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">printPerson2</span><span class="hljs-params">(Person&lt;T1, T2&gt;&amp;p)</span></span><span class="hljs-function"></span>{    p.<span class="hljs-built_in">showPerson</span>();    cout &lt;&lt; <span class="hljs-string">"T1的类型为： "</span> &lt;&lt; <span class="hljs-built_in">typeid</span>(T1).<span class="hljs-built_in">name</span>() &lt;&lt; endl;    cout &lt;&lt; <span class="hljs-string">"T2的类型为： "</span> &lt;&lt; <span class="hljs-built_in">typeid</span>(T2).<span class="hljs-built_in">name</span>() &lt;&lt; endl;}<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test02</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>{    Person &lt;string, <span class="hljs-type">int</span> &gt;<span class="hljs-built_in">p</span>(<span class="hljs-string">"猪八戒"</span>, <span class="hljs-number">90</span>);    <span class="hljs-built_in">printPerson2</span>(p);} <span class="hljs-comment">//3、整个类模板化</span><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span> T&gt;</span><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">printPerson3</span><span class="hljs-params">(T &amp; p)</span></span><span class="hljs-function"></span>{    cout &lt;&lt; <span class="hljs-string">"T的类型为： "</span> &lt;&lt; <span class="hljs-built_in">typeid</span>(T).<span class="hljs-built_in">name</span>() &lt;&lt; endl;    p.<span class="hljs-built_in">showPerson</span>(); }<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test03</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>{    Person &lt;string, <span class="hljs-type">int</span> &gt;<span class="hljs-built_in">p</span>(<span class="hljs-string">"唐僧"</span>, <span class="hljs-number">30</span>);    <span class="hljs-built_in">printPerson3</span>(p);} <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>{     <span class="hljs-built_in">test01</span>();    <span class="hljs-built_in">test02</span>();    <span class="hljs-built_in">test03</span>();     <span class="hljs-built_in">system</span>(<span class="hljs-string">"pause"</span>);     <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;}</code></pre></div><p>总结：</p><ul><li>通过类模板创建的对象，可以有三种方式向函数中进行传参</li><li>使用比较广泛是第一种：指定传入的类型</li></ul><h4><span id="1-3-5-lei-mo-ban-yu-ji-cheng">1.3.5 类模板与继承</span><a href="#1-3-5-lei-mo-ban-yu-ji-cheng" class="header-anchor">#</a></h4><p>当类模板碰到继承时，需要注意一下几点：</p><ul><li>当子类继承的父类是一个类模板时，子类在声明的时候，要指定出父类中T的类型</li><li>如果不指定，编译器无法给子类分配内存</li><li>如果想灵活指定出父类中T的类型，子类也需变为类模板</li></ul><p><strong>示例：</strong></p><div class="code-wrapper"><pre><code class="hljs C++"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">T</span>&gt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">Base</span>{    T m;}; <span class="hljs-comment">//class Son:public Base  //错误，c++编译需要给子类分配内存，必须知道父类中T的类型才可以向下继承</span><span class="hljs-keyword">class</span> <span class="hljs-title class_">Son</span> :<span class="hljs-keyword">public</span> Base&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-comment">//必须指定一个类型</span>{};<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test01</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>{    Son c;} <span class="hljs-comment">//类模板继承类模板 ,可以用T2指定父类中的T类型</span><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">T1</span>, <span class="hljs-keyword">class</span> <span class="hljs-title class_">T2</span>&gt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">Son2</span> :<span class="hljs-keyword">public</span> Base&lt;T2&gt;{<span class="hljs-keyword">public</span>:    <span class="hljs-built_in">Son2</span>()    {        cout &lt;&lt; <span class="hljs-built_in">typeid</span>(T1).<span class="hljs-built_in">name</span>() &lt;&lt; endl;        cout &lt;&lt; <span class="hljs-built_in">typeid</span>(T2).<span class="hljs-built_in">name</span>() &lt;&lt; endl;    }}; <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test02</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>{    Son2&lt;<span class="hljs-type">int</span>, <span class="hljs-type">char</span>&gt; child1;}  <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>{     <span class="hljs-built_in">test01</span>();     <span class="hljs-built_in">test02</span>();     <span class="hljs-built_in">system</span>(<span class="hljs-string">"pause"</span>);     <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;}</code></pre></div><p>总结：如果父类是类模板，子类需要指定出父类中T的数据类型</p><h4><span id="1-3-6-lei-mo-ban-cheng-yuan-han-shu-lei-wai-shi-xian">1.3.6 类模板成员函数类外实现</span><a href="#1-3-6-lei-mo-ban-cheng-yuan-han-shu-lei-wai-shi-xian" class="header-anchor">#</a></h4><p>学习目标：能够掌握类模板中的成员函数类外实现</p><p><strong>示例：</strong></p><div class="code-wrapper"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span> <span class="hljs-comment">//类模板中成员函数类外实现</span><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">T1</span>, <span class="hljs-keyword">class</span> <span class="hljs-title class_">T2</span>&gt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span> {<span class="hljs-keyword">public</span>:    <span class="hljs-comment">//成员函数类内声明</span>    <span class="hljs-built_in">Person</span>(T1 name, T2 age);    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">showPerson</span><span class="hljs-params">()</span></span>; <span class="hljs-keyword">public</span>:    T1 m_Name;    T2 m_Age;}; <span class="hljs-comment">//构造函数 类外实现</span><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">T1</span>, <span class="hljs-keyword">class</span> <span class="hljs-title class_">T2</span>&gt;Person&lt;T1, T2&gt;::<span class="hljs-built_in">Person</span>(T1 name, T2 age) {    <span class="hljs-keyword">this</span>-&gt;m_Name = name;    <span class="hljs-keyword">this</span>-&gt;m_Age = age;} <span class="hljs-comment">//成员函数 类外实现</span><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">T1</span>, <span class="hljs-keyword">class</span> <span class="hljs-title class_">T2</span>&gt;<span class="hljs-type">void</span> Person&lt;T1, T2&gt;::<span class="hljs-built_in">showPerson</span>() {    cout &lt;&lt; <span class="hljs-string">"姓名: "</span> &lt;&lt; <span class="hljs-keyword">this</span>-&gt;m_Name &lt;&lt; <span class="hljs-string">" 年龄:"</span> &lt;&lt; <span class="hljs-keyword">this</span>-&gt;m_Age &lt;&lt; endl;} <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test01</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>{    <span class="hljs-function">Person&lt;string, <span class="hljs-type">int</span>&gt; <span class="hljs-title">p</span><span class="hljs-params">(<span class="hljs-string">"Tom"</span>, <span class="hljs-number">20</span>)</span></span>;    p.<span class="hljs-built_in">showPerson</span>();} <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>{     <span class="hljs-built_in">test01</span>();     <span class="hljs-built_in">system</span>(<span class="hljs-string">"pause"</span>);     <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;}</code></pre></div><p>总结：类模板中成员函数类外实现时，需要加上模板参数列表</p><h4><span id="1-3-7-lei-mo-ban-fen-wen-jian-bian-xie">1.3.7 类模板分文件编写</span><a href="#1-3-7-lei-mo-ban-fen-wen-jian-bian-xie" class="header-anchor">#</a></h4><p>学习目标：</p><ul><li>掌握类模板成员函数分文件编写产生的问题以及解决方式</li></ul><p>问题：</p><ul><li>类模板中成员函数创建时机是在调用阶段，导致分文件编写时链接不到</li></ul><p>解决：</p><ul><li>解决方式1：直接包含.cpp源文件</li><li>解决方式2：将声明和实现写到同一个文件中，并更改后缀名为.hpp，hpp是约定的名称，并不是强制</li></ul><p><strong>示例：</strong></p><p>person.hpp中代码：</p><div class="code-wrapper"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">pragma</span> once</span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span> <span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">T1</span>, <span class="hljs-keyword">class</span> <span class="hljs-title class_">T2</span>&gt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span> {<span class="hljs-keyword">public</span>:    <span class="hljs-built_in">Person</span>(T1 name, T2 age);    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">showPerson</span><span class="hljs-params">()</span></span>;<span class="hljs-keyword">public</span>:    T1 m_Name;    T2 m_Age;}; <span class="hljs-comment">//构造函数 类外实现</span><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">T1</span>, <span class="hljs-keyword">class</span> <span class="hljs-title class_">T2</span>&gt;Person&lt;T1, T2&gt;::<span class="hljs-built_in">Person</span>(T1 name, T2 age) {    <span class="hljs-keyword">this</span>-&gt;m_Name = name;    <span class="hljs-keyword">this</span>-&gt;m_Age = age;} <span class="hljs-comment">//成员函数 类外实现</span><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">T1</span>, <span class="hljs-keyword">class</span> <span class="hljs-title class_">T2</span>&gt;<span class="hljs-type">void</span> Person&lt;T1, T2&gt;::<span class="hljs-built_in">showPerson</span>() {    cout &lt;&lt; <span class="hljs-string">"姓名: "</span> &lt;&lt; <span class="hljs-keyword">this</span>-&gt;m_Name &lt;&lt; <span class="hljs-string">" 年龄:"</span> &lt;&lt; <span class="hljs-keyword">this</span>-&gt;m_Age &lt;&lt; endl;}</code></pre></div><p>类模板分文件编写.cpp中代码</p><div class="code-wrapper"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std; <span class="hljs-comment">//#include "person.h"</span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">"person.cpp"</span> <span class="hljs-comment">//解决方式1，包含cpp源文件</span></span> <span class="hljs-comment">//解决方式2，将声明和实现写到一起，文件后缀名改为.hpp</span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">"person.hpp"</span></span><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test01</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>{    <span class="hljs-function">Person&lt;string, <span class="hljs-type">int</span>&gt; <span class="hljs-title">p</span><span class="hljs-params">(<span class="hljs-string">"Tom"</span>, <span class="hljs-number">10</span>)</span></span>;    p.<span class="hljs-built_in">showPerson</span>();} <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>{     <span class="hljs-built_in">test01</span>();     <span class="hljs-built_in">system</span>(<span class="hljs-string">"pause"</span>);     <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;}</code></pre></div><p>总结：主流的解决方式是第二种，将类模板成员函数写到一起，并将后缀名改为.hpp</p><h4><span id="1-3-8-lei-mo-ban-yu-you-yuan">1.3.8 类模板与友元</span><a href="#1-3-8-lei-mo-ban-yu-you-yuan" class="header-anchor">#</a></h4><p>学习目标：</p><ul><li>掌握类模板配合友元函数的类内和类外实现</li></ul><p>全局函数类内实现 - 直接在类内声明友元即可</p><p>全局函数类外实现 - 需要提前让编译器知道全局函数的存在</p><p><strong>示例：</strong></p><div class="code-wrapper"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span> <span class="hljs-comment">//2、全局函数配合友元  类外实现 - 先做函数模板声明，下方在做函数模板定义，在做友元</span><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">T1</span>, <span class="hljs-keyword">class</span> <span class="hljs-title class_">T2</span>&gt; <span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span>; <span class="hljs-comment">//如果声明了函数模板，可以将实现写到后面，否则需要将实现体写到类的前面让编译器提前看到</span><span class="hljs-comment">//template&lt;class T1, class T2&gt; void printPerson2(Person&lt;T1, T2&gt; &amp; p); </span> <span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span> T1, <span class="hljs-keyword">class</span> T2&gt;</span><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">printPerson2</span><span class="hljs-params">(Person&lt;T1, T2&gt; &amp; p)</span></span><span class="hljs-function"></span>{    cout &lt;&lt; <span class="hljs-string">"类外实现 ---- 姓名： "</span> &lt;&lt; p.m_Name &lt;&lt; <span class="hljs-string">" 年龄："</span> &lt;&lt; p.m_Age &lt;&lt; endl;} <span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">T1</span>, <span class="hljs-keyword">class</span> <span class="hljs-title class_">T2</span>&gt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span>{    <span class="hljs-comment">//1、全局函数配合友元   类内实现</span>    <span class="hljs-function"><span class="hljs-keyword">friend</span> <span class="hljs-type">void</span> <span class="hljs-title">printPerson</span><span class="hljs-params">(Person&lt;T1, T2&gt; &amp; p)</span></span><span class="hljs-function">    </span>{        cout &lt;&lt; <span class="hljs-string">"姓名： "</span> &lt;&lt; p.m_Name &lt;&lt; <span class="hljs-string">" 年龄："</span> &lt;&lt; p.m_Age &lt;&lt; endl;    }      <span class="hljs-comment">//全局函数配合友元  类外实现</span>    <span class="hljs-keyword">friend</span> <span class="hljs-type">void</span> printPerson2&lt;&gt;(Person&lt;T1, T2&gt; &amp; p); <span class="hljs-keyword">public</span>:     <span class="hljs-built_in">Person</span>(T1 name, T2 age)    {        <span class="hljs-keyword">this</span>-&gt;m_Name = name;        <span class="hljs-keyword">this</span>-&gt;m_Age = age;    }  <span class="hljs-keyword">private</span>:    T1 m_Name;    T2 m_Age; }; <span class="hljs-comment">//1、全局函数在类内实现</span><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test01</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>{    Person &lt;string, <span class="hljs-type">int</span> &gt;<span class="hljs-built_in">p</span>(<span class="hljs-string">"Tom"</span>, <span class="hljs-number">20</span>);    <span class="hljs-built_in">printPerson</span>(p);}  <span class="hljs-comment">//2、全局函数在类外实现</span><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test02</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>{    Person &lt;string, <span class="hljs-type">int</span> &gt;<span class="hljs-built_in">p</span>(<span class="hljs-string">"Jerry"</span>, <span class="hljs-number">30</span>);    <span class="hljs-built_in">printPerson2</span>(p);} <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>{     <span class="hljs-comment">//test01();</span>     <span class="hljs-built_in">test02</span>();     <span class="hljs-built_in">system</span>(<span class="hljs-string">"pause"</span>);     <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;}</code></pre></div><p>总结：建议全局函数做类内实现，用法简单，而且编译器可以直接识别</p><h4><span id="1-3-9-lei-mo-ban-an-li">1.3.9 类模板案例</span><a href="#1-3-9-lei-mo-ban-an-li" class="header-anchor">#</a></h4><p>案例描述: 实现一个通用的数组类，要求如下：</p><ul><li>可以对内置数据类型以及自定义数据类型的数据进行存储</li><li>将数组中的数据存储到堆区</li><li>构造函数中可以传入数组的容量</li><li>提供对应的拷贝构造函数以及operator=防止浅拷贝问题</li><li>提供尾插法和尾删法对数组中的数据进行增加和删除</li><li>可以通过下标的方式访问数组中的元素</li><li>可以获取数组中当前元素个数和数组的容量</li></ul><p><strong>示例：</strong></p><p>myArray.hpp中代码</p><div class="code-wrapper"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">pragma</span> once</span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std; <span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">T</span>&gt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">MyArray</span>{<span class="hljs-keyword">public</span>:        <span class="hljs-comment">//构造函数</span>    <span class="hljs-built_in">MyArray</span>(<span class="hljs-type">int</span> capacity)    {        <span class="hljs-keyword">this</span>-&gt;m_Capacity = capacity;        <span class="hljs-keyword">this</span>-&gt;m_Size = <span class="hljs-number">0</span>;        pAddress = <span class="hljs-keyword">new</span> T[<span class="hljs-keyword">this</span>-&gt;m_Capacity];    }     <span class="hljs-comment">//拷贝构造</span>    <span class="hljs-built_in">MyArray</span>(<span class="hljs-type">const</span> MyArray &amp; arr)    {        <span class="hljs-keyword">this</span>-&gt;m_Capacity = arr.m_Capacity;        <span class="hljs-keyword">this</span>-&gt;m_Size = arr.m_Size;        <span class="hljs-keyword">this</span>-&gt;pAddress = <span class="hljs-keyword">new</span> T[<span class="hljs-keyword">this</span>-&gt;m_Capacity];        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-keyword">this</span>-&gt;m_Size; i++)        {            <span class="hljs-comment">//如果T为对象，而且还包含指针，必须需要重载 = 操作符，因为这个等号不是 构造 而是赋值，</span>            <span class="hljs-comment">// 普通类型可以直接= 但是指针类型需要深拷贝</span>            <span class="hljs-keyword">this</span>-&gt;pAddress[i] = arr.pAddress[i];        }    }     <span class="hljs-comment">//重载= 操作符  防止浅拷贝问题</span>    MyArray&amp; <span class="hljs-keyword">operator</span>=(<span class="hljs-type">const</span> MyArray&amp; myarray) {         <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>-&gt;pAddress != <span class="hljs-literal">NULL</span>) {            <span class="hljs-keyword">delete</span>[] <span class="hljs-keyword">this</span>-&gt;pAddress;            <span class="hljs-keyword">this</span>-&gt;m_Capacity = <span class="hljs-number">0</span>;            <span class="hljs-keyword">this</span>-&gt;m_Size = <span class="hljs-number">0</span>;        }         <span class="hljs-keyword">this</span>-&gt;m_Capacity = myarray.m_Capacity;        <span class="hljs-keyword">this</span>-&gt;m_Size = myarray.m_Size;        <span class="hljs-keyword">this</span>-&gt;pAddress = <span class="hljs-keyword">new</span> T[<span class="hljs-keyword">this</span>-&gt;m_Capacity];        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-keyword">this</span>-&gt;m_Size; i++) {            <span class="hljs-keyword">this</span>-&gt;pAddress[i] = myarray[i];        }        <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;    }     <span class="hljs-comment">//重载[] 操作符  arr[0]</span>    T&amp; <span class="hljs-keyword">operator</span> [](<span class="hljs-type">int</span> index)    {        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>-&gt;pAddress[index]; <span class="hljs-comment">//不考虑越界，用户自己去处理</span>    }     <span class="hljs-comment">//尾插法</span>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Push_back</span><span class="hljs-params">(<span class="hljs-type">const</span> T &amp; val)</span></span><span class="hljs-function">    </span>{        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>-&gt;m_Capacity == <span class="hljs-keyword">this</span>-&gt;m_Size)        {            <span class="hljs-keyword">return</span>;        }        <span class="hljs-keyword">this</span>-&gt;pAddress[<span class="hljs-keyword">this</span>-&gt;m_Size] = val;        <span class="hljs-keyword">this</span>-&gt;m_Size++;    }     <span class="hljs-comment">//尾删法</span>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Pop_back</span><span class="hljs-params">()</span></span><span class="hljs-function">    </span>{        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>-&gt;m_Size == <span class="hljs-number">0</span>)        {            <span class="hljs-keyword">return</span>;        }        <span class="hljs-keyword">this</span>-&gt;m_Size--;    }     <span class="hljs-comment">//获取数组容量</span>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">getCapacity</span><span class="hljs-params">()</span></span><span class="hljs-function">    </span>{        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>-&gt;m_Capacity;    }     <span class="hljs-comment">//获取数组大小</span>    <span class="hljs-function"><span class="hljs-type">int</span>    <span class="hljs-title">getSize</span><span class="hljs-params">()</span></span><span class="hljs-function">    </span>{        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>-&gt;m_Size;    }      <span class="hljs-comment">//析构</span>    ~<span class="hljs-built_in">MyArray</span>()    {        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>-&gt;pAddress != <span class="hljs-literal">NULL</span>)        {            <span class="hljs-keyword">delete</span>[] <span class="hljs-keyword">this</span>-&gt;pAddress;            <span class="hljs-keyword">this</span>-&gt;pAddress = <span class="hljs-literal">NULL</span>;            <span class="hljs-keyword">this</span>-&gt;m_Capacity = <span class="hljs-number">0</span>;            <span class="hljs-keyword">this</span>-&gt;m_Size = <span class="hljs-number">0</span>;        }    } <span class="hljs-keyword">private</span>:    T * pAddress;  <span class="hljs-comment">//指向一个堆空间，这个空间存储真正的数据</span>    <span class="hljs-type">int</span> m_Capacity; <span class="hljs-comment">//容量</span>    <span class="hljs-type">int</span> m_Size;   <span class="hljs-comment">// 大小</span>};</code></pre></div><p>类模板案例—数组类封装.cpp中</p><div class="code-wrapper"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">"myArray.hpp"</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span> <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">printIntArray</span><span class="hljs-params">(MyArray&lt;<span class="hljs-type">int</span>&gt;&amp; arr)</span> </span>{    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; arr.<span class="hljs-built_in">getSize</span>(); i++) {        cout &lt;&lt; arr[i] &lt;&lt; <span class="hljs-string">" "</span>;    }    cout &lt;&lt; endl;} <span class="hljs-comment">//测试内置数据类型</span><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test01</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>{    <span class="hljs-function">MyArray&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">array1</span><span class="hljs-params">(<span class="hljs-number">10</span>)</span></span>;    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++)    {        array1.<span class="hljs-built_in">Push_back</span>(i);    }    cout &lt;&lt; <span class="hljs-string">"array1打印输出："</span> &lt;&lt; endl;    <span class="hljs-built_in">printIntArray</span>(array1);    cout &lt;&lt; <span class="hljs-string">"array1的大小："</span> &lt;&lt; array1.<span class="hljs-built_in">getSize</span>() &lt;&lt; endl;    cout &lt;&lt; <span class="hljs-string">"array1的容量："</span> &lt;&lt; array1.<span class="hljs-built_in">getCapacity</span>() &lt;&lt; endl;     cout &lt;&lt; <span class="hljs-string">"--------------------------"</span> &lt;&lt; endl;     <span class="hljs-function">MyArray&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">array2</span><span class="hljs-params">(array1)</span></span>;    array2.<span class="hljs-built_in">Pop_back</span>();    cout &lt;&lt; <span class="hljs-string">"array2打印输出："</span> &lt;&lt; endl;    <span class="hljs-built_in">printIntArray</span>(array2);    cout &lt;&lt; <span class="hljs-string">"array2的大小："</span> &lt;&lt; array2.<span class="hljs-built_in">getSize</span>() &lt;&lt; endl;    cout &lt;&lt; <span class="hljs-string">"array2的容量："</span> &lt;&lt; array2.<span class="hljs-built_in">getCapacity</span>() &lt;&lt; endl;} <span class="hljs-comment">//测试自定义数据类型</span><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span> {<span class="hljs-keyword">public</span>:    <span class="hljs-built_in">Person</span>() {}         <span class="hljs-built_in">Person</span>(string name, <span class="hljs-type">int</span> age) {        <span class="hljs-keyword">this</span>-&gt;m_Name = name;        <span class="hljs-keyword">this</span>-&gt;m_Age = age;    }<span class="hljs-keyword">public</span>:    string m_Name;    <span class="hljs-type">int</span> m_Age;}; <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">printPersonArray</span><span class="hljs-params">(MyArray&lt;Person&gt;&amp; personArr)</span></span><span class="hljs-function"></span>{    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; personArr.<span class="hljs-built_in">getSize</span>(); i++) {        cout &lt;&lt; <span class="hljs-string">"姓名："</span> &lt;&lt; personArr[i].m_Name &lt;&lt; <span class="hljs-string">" 年龄： "</span> &lt;&lt; personArr[i].m_Age &lt;&lt; endl;    } } <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test02</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>{    <span class="hljs-comment">//创建数组</span>    <span class="hljs-function">MyArray&lt;Person&gt; <span class="hljs-title">pArray</span><span class="hljs-params">(<span class="hljs-number">10</span>)</span></span>;    <span class="hljs-function">Person <span class="hljs-title">p1</span><span class="hljs-params">(<span class="hljs-string">"孙悟空"</span>, <span class="hljs-number">30</span>)</span></span>;    <span class="hljs-function">Person <span class="hljs-title">p2</span><span class="hljs-params">(<span class="hljs-string">"韩信"</span>, <span class="hljs-number">20</span>)</span></span>;    <span class="hljs-function">Person <span class="hljs-title">p3</span><span class="hljs-params">(<span class="hljs-string">"妲己"</span>, <span class="hljs-number">18</span>)</span></span>;    <span class="hljs-function">Person <span class="hljs-title">p4</span><span class="hljs-params">(<span class="hljs-string">"王昭君"</span>, <span class="hljs-number">15</span>)</span></span>;    <span class="hljs-function">Person <span class="hljs-title">p5</span><span class="hljs-params">(<span class="hljs-string">"赵云"</span>, <span class="hljs-number">24</span>)</span></span>;     <span class="hljs-comment">//插入数据</span>    pArray.<span class="hljs-built_in">Push_back</span>(p1);    pArray.<span class="hljs-built_in">Push_back</span>(p2);    pArray.<span class="hljs-built_in">Push_back</span>(p3);    pArray.<span class="hljs-built_in">Push_back</span>(p4);    pArray.<span class="hljs-built_in">Push_back</span>(p5);     <span class="hljs-built_in">printPersonArray</span>(pArray);     cout &lt;&lt; <span class="hljs-string">"pArray的大小："</span> &lt;&lt; pArray.<span class="hljs-built_in">getSize</span>() &lt;&lt; endl;    cout &lt;&lt; <span class="hljs-string">"pArray的容量："</span> &lt;&lt; pArray.<span class="hljs-built_in">getCapacity</span>() &lt;&lt; endl; } <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>{     <span class="hljs-comment">//test01();</span>     <span class="hljs-built_in">test02</span>();     <span class="hljs-built_in">system</span>(<span class="hljs-string">"pause"</span>);     <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;}</code></pre></div><p>总结：</p><p>能够利用所学知识点实现通用的数组</p><h2><span id="2-stl-chu-shi">2 STL初识</span><a href="#2-stl-chu-shi" class="header-anchor">#</a></h2><h3><span id="2-1-stl-de-dan-sheng">2.1 STL的诞生</span><a href="#2-1-stl-de-dan-sheng" class="header-anchor">#</a></h3><ul><li>长久以来，软件界一直希望建立一种可重复利用的东西</li><li>C++的<strong>面向对象</strong>和<strong>泛型编程</strong>思想，目的就是<strong>复用性的提升</strong></li><li>大多情况下，数据结构和算法都未能有一套标准,导致被迫从事大量重复工作</li><li>为了建立数据结构和算法的一套标准,诞生了<strong>STL</strong></li></ul><h3><span id="2-2-stl-ji-ben-gai-nian">2.2 STL基本概念</span><a href="#2-2-stl-ji-ben-gai-nian" class="header-anchor">#</a></h3><ul><li>STL(Standard Template Library,<strong>标准模板库</strong>)</li><li>STL 从广义上分为: <strong>容器(container) 算法(algorithm) 迭代器(iterator)</strong></li><li><strong>容器</strong>和<strong>算法</strong>之间通过<strong>迭代器</strong>进行无缝连接。</li><li>STL 几乎所有的代码都采用了模板类或者模板函数</li></ul><h3><span id="2-3-stl-liu-da-zu-jian">2.3 STL六大组件</span><a href="#2-3-stl-liu-da-zu-jian" class="header-anchor">#</a></h3><p>STL大体分为六大组件，分别是:<strong>容器、算法、迭代器、仿函数、适配器（配接器）、空间配置器</strong></p><ol><li>容器：各种数据结构，如vector、list、deque、set、map等,用来存放数据。</li><li>算法：各种常用的算法，如sort、find、copy、for_each等</li><li>迭代器：扮演了容器与算法之间的胶合剂。</li><li>仿函数：行为类似函数，可作为算法的某种策略。</li><li>适配器：一种用来修饰容器或者仿函数或迭代器接口的东西。</li><li>空间配置器：负责空间的配置与管理。</li></ol><h3><span id="2-4-stl-zhong-rong-qi-suan-fa-die-dai-qi">2.4 STL中容器、算法、迭代器</span><a href="#2-4-stl-zhong-rong-qi-suan-fa-die-dai-qi" class="header-anchor">#</a></h3><p><strong>容器：</strong>置物之所也</p><p>STL<strong>容器</strong>就是将运用<strong>最广泛的一些数据结构</strong>实现出来</p><p>常用的数据结构：数组, 链表,树, 栈, 队列, 集合, 映射表 等</p><p>这些容器分为<strong>序列式容器</strong>和<strong>关联式容器</strong>两种:</p><p> <strong>序列式容器</strong>:强调值的排序，序列式容器中的每个元素均有固定的位置。 <strong>关联式容器</strong>:二叉树结构，各元素之间没有严格的物理上的顺序关系</p><p><strong>算法：</strong>问题之解法也</p><p>有限的步骤，解决逻辑或数学上的问题，这一门学科我们叫做算法(Algorithms)</p><p>算法分为:<strong>质变算法</strong>和<strong>非质变算法</strong>。</p><p>质变算法：是指运算过程中会更改区间内的元素的内容。例如拷贝，替换，删除等等</p><p>非质变算法：是指运算过程中不会更改区间内的元素内容，例如查找、计数、遍历、寻找极值等等</p><p><strong>迭代器：</strong>容器和算法之间粘合剂</p><p>提供一种方法，使之能够依序寻访某个容器所含的各个元素，而又无需暴露该容器的内部表示方式。</p><p>每个容器都有自己专属的迭代器</p><p>迭代器使用非常类似于指针，初学阶段我们可以先理解迭代器为指针</p><p>迭代器种类：</p><table><thead><tr><th>种类</th><th>功能</th><th>支持运算</th></tr></thead><tbody><tr><td>输入迭代器</td><td>对数据的只读访问</td><td>只读，支持++、==、！=</td></tr><tr><td>输出迭代器</td><td>对数据的只写访问</td><td>只写，支持++</td></tr><tr><td>前向迭代器</td><td>读写操作，并能向前推进迭代器</td><td>读写，支持++、==、！=</td></tr><tr><td>双向迭代器</td><td>读写操作，并能向前和向后操作</td><td>读写，支持++、–，</td></tr><tr><td>随机访问迭代器</td><td>读写操作，可以以跳跃的方式访问任意数据，功能最强的迭代器</td><td>读写，支持++、–、[n]、-n、&lt;、&lt;=、&gt;、&gt;=</td></tr></tbody></table><p>常用的容器中迭代器种类为双向迭代器，和随机访问迭代器</p><h3><span id="2-5-rong-qi-suan-fa-die-dai-qi-chu-shi">2.5 容器算法迭代器初识</span><a href="#2-5-rong-qi-suan-fa-die-dai-qi-chu-shi" class="header-anchor">#</a></h3><p>了解STL中容器、算法、迭代器概念之后，我们利用代码感受STL的魅力</p><p>STL中最常用的容器为Vector，可以理解为数组，下面我们将学习如何向这个容器中插入数据、并遍历这个容器</p><h4><span id="2-5-1-vector-cun-fang-nei-zhi-shu-ju-lei-xing">2.5.1 vector存放内置数据类型</span><a href="#2-5-1-vector-cun-fang-nei-zhi-shu-ju-lei-xing" class="header-anchor">#</a></h4><p>容器： <code>vector</code></p><p>算法： <code>for_each</code></p><p>迭代器： <code>vector::iterator</code></p><p><strong>示例：</strong></p><div class="code-wrapper"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span> <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">MyPrint</span><span class="hljs-params">(<span class="hljs-type">int</span> val)</span></span><span class="hljs-function"></span>{    cout &lt;&lt; val &lt;&lt; endl;} <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test01</span><span class="hljs-params">()</span> </span>{     <span class="hljs-comment">//创建vector容器对象，并且通过模板参数指定容器中存放的数据的类型</span>    vector&lt;<span class="hljs-type">int</span>&gt; v;    <span class="hljs-comment">//向容器中放数据</span>    v.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">10</span>);    v.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">20</span>);    v.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">30</span>);    v.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">40</span>);     <span class="hljs-comment">//每一个容器都有自己的迭代器，迭代器是用来遍历容器中的元素</span>    <span class="hljs-comment">//v.begin()返回迭代器，这个迭代器指向容器中第一个数据</span>    <span class="hljs-comment">//v.end()返回迭代器，这个迭代器指向容器元素的最后一个元素的下一个位置</span>    <span class="hljs-comment">//vector&lt;int&gt;::iterator 拿到vector&lt;int&gt;这种容器的迭代器类型</span>     vector&lt;<span class="hljs-type">int</span>&gt;::iterator pBegin = v.<span class="hljs-built_in">begin</span>();    vector&lt;<span class="hljs-type">int</span>&gt;::iterator pEnd = v.<span class="hljs-built_in">end</span>();     <span class="hljs-comment">//第一种遍历方式：</span>    <span class="hljs-keyword">while</span> (pBegin != pEnd) {        cout &lt;&lt; *pBegin &lt;&lt; endl;        pBegin++;    }         <span class="hljs-comment">//第二种遍历方式：</span>    <span class="hljs-keyword">for</span> (vector&lt;<span class="hljs-type">int</span>&gt;::iterator it = v.<span class="hljs-built_in">begin</span>(); it != v.<span class="hljs-built_in">end</span>(); it++) {        cout &lt;&lt; *it &lt;&lt; endl;    }    cout &lt;&lt; endl;     <span class="hljs-comment">//第三种遍历方式：</span>    <span class="hljs-comment">//使用STL提供标准遍历算法  头文件 algorithm</span>    for_each(v.<span class="hljs-built_in">begin</span>(), v.<span class="hljs-built_in">end</span>(), MyPrint);} <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>{     <span class="hljs-built_in">test01</span>();     <span class="hljs-built_in">system</span>(<span class="hljs-string">"pause"</span>);     <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;}</code></pre></div><h4><span id="2-5-2-vector-cun-fang-zi-ding-yi-shu-ju-lei-xing">2.5.2 Vector存放自定义数据类型</span><a href="#2-5-2-vector-cun-fang-zi-ding-yi-shu-ju-lei-xing" class="header-anchor">#</a></h4><p>学习目标：vector中存放自定义数据类型，并打印输出</p><p><strong>示例：</strong></p><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span> <span class="hljs-comment">//自定义数据类型</span><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span> {<span class="hljs-keyword">public</span>:    <span class="hljs-built_in">Person</span>(string name, <span class="hljs-type">int</span> age) {        mName = name;        mAge = age;    }<span class="hljs-keyword">public</span>:    string mName;    <span class="hljs-type">int</span> mAge;};<span class="hljs-comment">//存放对象</span><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test01</span><span class="hljs-params">()</span> </span>{     vector&lt;Person&gt; v;     <span class="hljs-comment">//创建数据</span>    <span class="hljs-function">Person <span class="hljs-title">p1</span><span class="hljs-params">(<span class="hljs-string">"aaa"</span>, <span class="hljs-number">10</span>)</span></span>;    <span class="hljs-function">Person <span class="hljs-title">p2</span><span class="hljs-params">(<span class="hljs-string">"bbb"</span>, <span class="hljs-number">20</span>)</span></span>;    <span class="hljs-function">Person <span class="hljs-title">p3</span><span class="hljs-params">(<span class="hljs-string">"ccc"</span>, <span class="hljs-number">30</span>)</span></span>;    <span class="hljs-function">Person <span class="hljs-title">p4</span><span class="hljs-params">(<span class="hljs-string">"ddd"</span>, <span class="hljs-number">40</span>)</span></span>;    <span class="hljs-function">Person <span class="hljs-title">p5</span><span class="hljs-params">(<span class="hljs-string">"eee"</span>, <span class="hljs-number">50</span>)</span></span>;     v.<span class="hljs-built_in">push_back</span>(p1);    v.<span class="hljs-built_in">push_back</span>(p2);    v.<span class="hljs-built_in">push_back</span>(p3);    v.<span class="hljs-built_in">push_back</span>(p4);    v.<span class="hljs-built_in">push_back</span>(p5);     <span class="hljs-keyword">for</span> (vector&lt;Person&gt;::iterator it = v.<span class="hljs-built_in">begin</span>(); it != v.<span class="hljs-built_in">end</span>(); it++) {        cout &lt;&lt; <span class="hljs-string">"Name:"</span> &lt;&lt; (*it).mName &lt;&lt; <span class="hljs-string">" Age:"</span> &lt;&lt; (*it).mAge &lt;&lt; endl;     }}  <span class="hljs-comment">//放对象指针</span><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test02</span><span class="hljs-params">()</span> </span>{     vector&lt;Person*&gt; v;     <span class="hljs-comment">//创建数据</span>    <span class="hljs-function">Person <span class="hljs-title">p1</span><span class="hljs-params">(<span class="hljs-string">"aaa"</span>, <span class="hljs-number">10</span>)</span></span>;    <span class="hljs-function">Person <span class="hljs-title">p2</span><span class="hljs-params">(<span class="hljs-string">"bbb"</span>, <span class="hljs-number">20</span>)</span></span>;    <span class="hljs-function">Person <span class="hljs-title">p3</span><span class="hljs-params">(<span class="hljs-string">"ccc"</span>, <span class="hljs-number">30</span>)</span></span>;    <span class="hljs-function">Person <span class="hljs-title">p4</span><span class="hljs-params">(<span class="hljs-string">"ddd"</span>, <span class="hljs-number">40</span>)</span></span>;    <span class="hljs-function">Person <span class="hljs-title">p5</span><span class="hljs-params">(<span class="hljs-string">"eee"</span>, <span class="hljs-number">50</span>)</span></span>;     v.<span class="hljs-built_in">push_back</span>(&amp;p1);    v.<span class="hljs-built_in">push_back</span>(&amp;p2);    v.<span class="hljs-built_in">push_back</span>(&amp;p3);    v.<span class="hljs-built_in">push_back</span>(&amp;p4);    v.<span class="hljs-built_in">push_back</span>(&amp;p5);     <span class="hljs-keyword">for</span> (vector&lt;Person*&gt;::iterator it = v.<span class="hljs-built_in">begin</span>(); it != v.<span class="hljs-built_in">end</span>(); it++) {        Person * p = (*it);        cout &lt;&lt; <span class="hljs-string">"Name:"</span> &lt;&lt; p-&gt;mName &lt;&lt; <span class="hljs-string">" Age:"</span> &lt;&lt; (*it)-&gt;mAge &lt;&lt; endl;    }}  <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>{     <span class="hljs-built_in">test01</span>();        <span class="hljs-built_in">test02</span>();     <span class="hljs-built_in">system</span>(<span class="hljs-string">"pause"</span>);     <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;}</code></pre></div><h4><span id="2-5-3-vector-rong-qi-qian-tao-rong-qi">2.5.3 Vector容器嵌套容器</span><a href="#2-5-3-vector-rong-qi-qian-tao-rong-qi" class="header-anchor">#</a></h4><p>学习目标：容器中嵌套容器，我们将所有数据进行遍历输出</p><p><strong>示例：</strong></p><div class="code-wrapper"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span> <span class="hljs-comment">//容器嵌套容器</span><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test01</span><span class="hljs-params">()</span> </span>{     vector&lt; vector&lt;<span class="hljs-type">int</span>&gt; &gt;  v;     vector&lt;<span class="hljs-type">int</span>&gt; v1;    vector&lt;<span class="hljs-type">int</span>&gt; v2;    vector&lt;<span class="hljs-type">int</span>&gt; v3;    vector&lt;<span class="hljs-type">int</span>&gt; v4;     <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">4</span>; i++) {        v1.<span class="hljs-built_in">push_back</span>(i + <span class="hljs-number">1</span>);        v2.<span class="hljs-built_in">push_back</span>(i + <span class="hljs-number">2</span>);        v3.<span class="hljs-built_in">push_back</span>(i + <span class="hljs-number">3</span>);        v4.<span class="hljs-built_in">push_back</span>(i + <span class="hljs-number">4</span>);    }     <span class="hljs-comment">//将容器元素插入到vector v中</span>    v.<span class="hljs-built_in">push_back</span>(v1);    v.<span class="hljs-built_in">push_back</span>(v2);    v.<span class="hljs-built_in">push_back</span>(v3);    v.<span class="hljs-built_in">push_back</span>(v4);      <span class="hljs-keyword">for</span> (vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;::iterator it = v.<span class="hljs-built_in">begin</span>(); it != v.<span class="hljs-built_in">end</span>(); it++) {         <span class="hljs-keyword">for</span> (vector&lt;<span class="hljs-type">int</span>&gt;::iterator vit = (*it).<span class="hljs-built_in">begin</span>(); vit != (*it).<span class="hljs-built_in">end</span>(); vit++) {            cout &lt;&lt; *vit &lt;&lt; <span class="hljs-string">" "</span>;        }        cout &lt;&lt; endl;    } } <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>{     <span class="hljs-built_in">test01</span>();     <span class="hljs-built_in">system</span>(<span class="hljs-string">"pause"</span>);     <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;}</code></pre></div><h2><span id="3-stl-chang-yong-rong-qi">3 STL- 常用容器</span><a href="#3-stl-chang-yong-rong-qi" class="header-anchor">#</a></h2><h3><span id="3-1-string-rong-qi">3.1 string容器</span><a href="#3-1-string-rong-qi" class="header-anchor">#</a></h3><h4><span id="3-1-1-string-ji-ben-gai-nian">3.1.1 string基本概念</span><a href="#3-1-1-string-ji-ben-gai-nian" class="header-anchor">#</a></h4><p><strong>本质：</strong></p><ul><li>string是C++风格的字符串，而string本质上是一个类</li></ul><p><strong>string和char * 区别：</strong></p><ul><li>char * 是一个指针</li><li>string是一个类，类内部封装了char<em>，管理这个字符串，是一个char</em>型的容器。</li></ul><p><strong>特点：</strong></p><p>string 类内部封装了很多成员方法</p><p>例如：查找find，拷贝copy，删除delete 替换replace，插入insert</p><p>string管理char*所分配的内存，不用担心复制越界和取值越界等，由类内部进行负责</p><h4><span id="3-1-2-string-gou-zao-han-shu">3.1.2 string构造函数</span><a href="#3-1-2-string-gou-zao-han-shu" class="header-anchor">#</a></h4><p>构造函数原型：</p><ul><li><code>string();</code> //创建一个空的字符串 例如: string str; <code>string(const char* s);</code> //使用字符串s初始化</li><li><code>string(const string&amp; str);</code> //使用一个string对象初始化另一个string对象</li><li><code>string(int n, char c);</code> //使用n个字符c初始化</li></ul><p><strong>示例：</strong></p><div class="code-wrapper"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span><span class="hljs-comment">//string构造</span><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test01</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>{    string s1; <span class="hljs-comment">//创建空字符串，调用无参构造函数</span>    cout &lt;&lt; <span class="hljs-string">"str1 = "</span> &lt;&lt; s1 &lt;&lt; endl;     <span class="hljs-type">const</span> <span class="hljs-type">char</span>* str = <span class="hljs-string">"hello world"</span>;    <span class="hljs-function">string <span class="hljs-title">s2</span><span class="hljs-params">(str)</span></span>; <span class="hljs-comment">//把c_string转换成了string</span>     cout &lt;&lt; <span class="hljs-string">"str2 = "</span> &lt;&lt; s2 &lt;&lt; endl;     <span class="hljs-function">string <span class="hljs-title">s3</span><span class="hljs-params">(s2)</span></span>; <span class="hljs-comment">//调用拷贝构造函数</span>    cout &lt;&lt; <span class="hljs-string">"str3 = "</span> &lt;&lt; s3 &lt;&lt; endl;     <span class="hljs-function">string <span class="hljs-title">s4</span><span class="hljs-params">(<span class="hljs-number">10</span>, <span class="hljs-string">'a'</span>)</span></span>;    cout &lt;&lt; <span class="hljs-string">"str3 = "</span> &lt;&lt; s3 &lt;&lt; endl;} <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>{     <span class="hljs-built_in">test01</span>();     <span class="hljs-built_in">system</span>(<span class="hljs-string">"pause"</span>);     <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;}</code></pre></div><p>总结：string的多种构造方式没有可比性，灵活使用即可</p><h4><span id="3-1-3-string-fu-zhi-cao-zuo">3.1.3 string赋值操作</span><a href="#3-1-3-string-fu-zhi-cao-zuo" class="header-anchor">#</a></h4><p>功能描述：</p><ul><li>给string字符串进行赋值</li></ul><p>赋值的函数原型：</p><ul><li><code>string&amp; operator=(const char* s);</code> //char*类型字符串 赋值给当前的字符串</li><li><code>string&amp; operator=(const string &amp;s);</code> //把字符串s赋给当前的字符串</li><li><code>string&amp; operator=(char c);</code> //字符赋值给当前的字符串</li><li><code>string&amp; assign(const char *s);</code> //把字符串s赋给当前的字符串</li><li><code>string&amp; assign(const char *s, int n);</code> //把字符串s的前n个字符赋给当前的字符串</li><li><code>string&amp; assign(const string &amp;s);</code> //把字符串s赋给当前字符串</li><li><code>string&amp; assign(int n, char c);</code> //用n个字符c赋给当前字符串</li></ul><p><strong>示例：</strong></p><div class="code-wrapper"><pre><code class="hljs C++"><span class="hljs-comment">//赋值</span><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test01</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>{    string str1;    str1 = <span class="hljs-string">"hello world"</span>;    cout &lt;&lt; <span class="hljs-string">"str1 = "</span> &lt;&lt; str1 &lt;&lt; endl;     string str2;    str2 = str1;    cout &lt;&lt; <span class="hljs-string">"str2 = "</span> &lt;&lt; str2 &lt;&lt; endl;     string str3;    str3 = <span class="hljs-string">'a'</span>;    cout &lt;&lt; <span class="hljs-string">"str3 = "</span> &lt;&lt; str3 &lt;&lt; endl;     string str4;    str4.<span class="hljs-built_in">assign</span>(<span class="hljs-string">"hello c++"</span>);    cout &lt;&lt; <span class="hljs-string">"str4 = "</span> &lt;&lt; str4 &lt;&lt; endl;     string str5;    str5.<span class="hljs-built_in">assign</span>(<span class="hljs-string">"hello c++"</span>,<span class="hljs-number">5</span>);    cout &lt;&lt; <span class="hljs-string">"str5 = "</span> &lt;&lt; str5 &lt;&lt; endl;      string str6;    str6.<span class="hljs-built_in">assign</span>(str5);    cout &lt;&lt; <span class="hljs-string">"str6 = "</span> &lt;&lt; str6 &lt;&lt; endl;     string str7;    str7.<span class="hljs-built_in">assign</span>(<span class="hljs-number">5</span>, <span class="hljs-string">'x'</span>);    cout &lt;&lt; <span class="hljs-string">"str7 = "</span> &lt;&lt; str7 &lt;&lt; endl;} <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>{     <span class="hljs-built_in">test01</span>();     <span class="hljs-built_in">system</span>(<span class="hljs-string">"pause"</span>);     <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;}</code></pre></div><p>总结：</p><p> string的赋值方式很多，<code>operator=</code> 这种方式是比较实用的</p><h4><span id="3-1-4-string-zi-fu-chuan-pin-jie">3.1.4 string字符串拼接</span><a href="#3-1-4-string-zi-fu-chuan-pin-jie" class="header-anchor">#</a></h4><p><strong>功能描述：</strong></p><ul><li>实现在字符串末尾拼接字符串</li></ul><p><strong>函数原型：</strong></p><ul><li><code>string&amp; operator+=(const char* str);</code> //重载+=操作符</li><li><code>string&amp; operator+=(const char c);</code> //重载+=操作符</li><li><code>string&amp; operator+=(const string&amp; str);</code> //重载+=操作符</li><li><code>string&amp; append(const char *s); </code>//把字符串s连接到当前字符串结尾</li><li><code>string&amp; append(const char *s, int n);</code> //把字符串s的前n个字符连接到当前字符串结尾</li><li><code>string&amp; append(const string &amp;s);</code> //同operator+=(const string&amp; str)</li><li><code>string&amp; append(const string &amp;s, int pos, int n);</code>//字符串s中从pos开始的n个字符连接到字符串结尾</li></ul><p><strong>示例：</strong></p><div class="code-wrapper"><pre><code class="hljs C++"><span class="hljs-comment">//字符串拼接</span><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test01</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>{    string str1 = <span class="hljs-string">"我"</span>;     str1 += <span class="hljs-string">"爱玩游戏"</span>;     cout &lt;&lt; <span class="hljs-string">"str1 = "</span> &lt;&lt; str1 &lt;&lt; endl;        str1 += <span class="hljs-string">':'</span>;     cout &lt;&lt; <span class="hljs-string">"str1 = "</span> &lt;&lt; str1 &lt;&lt; endl;     string str2 = <span class="hljs-string">"LOL DNF"</span>;     str1 += str2;     cout &lt;&lt; <span class="hljs-string">"str1 = "</span> &lt;&lt; str1 &lt;&lt; endl;     string str3 = <span class="hljs-string">"I"</span>;    str3.<span class="hljs-built_in">append</span>(<span class="hljs-string">" love "</span>);    str3.<span class="hljs-built_in">append</span>(<span class="hljs-string">"game abcde"</span>, <span class="hljs-number">4</span>);    <span class="hljs-comment">//str3.append(str2);</span>    str3.<span class="hljs-built_in">append</span>(str2, <span class="hljs-number">4</span>, <span class="hljs-number">3</span>); <span class="hljs-comment">// 从下标4位置开始 ，截取3个字符，拼接到字符串末尾</span>    cout &lt;&lt; <span class="hljs-string">"str3 = "</span> &lt;&lt; str3 &lt;&lt; endl;}<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>{     <span class="hljs-built_in">test01</span>();     <span class="hljs-built_in">system</span>(<span class="hljs-string">"pause"</span>);     <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;}</code></pre></div><p>总结：字符串拼接的重载版本很多，初学阶段记住几种即可</p><h4><span id="3-1-5-string-cha-zhao-he-ti-huan">3.1.5 string查找和替换</span><a href="#3-1-5-string-cha-zhao-he-ti-huan" class="header-anchor">#</a></h4><p><strong>功能描述：</strong></p><ul><li>查找：查找指定字符串是否存在</li><li>替换：在指定的位置替换字符串</li></ul><p><strong>函数原型：</strong></p><ul><li><code>int find(const string&amp; str, int pos = 0) const;</code> //查找str第一次出现位置,从pos开始查找</li><li><code>int find(const char* s, int pos = 0) const; </code>//查找s第一次出现位置,从pos开始查找</li><li><code>int find(const char* s, int pos, int n) const; </code>//从pos位置查找s的前n个字符第一次位置</li><li><code>int find(const char c, int pos = 0) const; </code>//查找字符c第一次出现位置</li><li><code>int rfind(const string&amp; str, int pos = npos) const;</code> //查找str最后一次位置,从pos开始查找</li><li><code>int rfind(const char* s, int pos = npos) const;</code> //查找s最后一次出现位置,从pos开始查找</li><li><code>int rfind(const char* s, int pos, int n) const;</code> //从pos查找s的前n个字符最后一次位置</li><li><code>int rfind(const char c, int pos = 0) const; </code>//查找字符c最后一次出现位置</li><li><code>string&amp; replace(int pos, int n, const string&amp; str); </code>//替换从pos开始n个字符为字符串str</li><li><code>string&amp; replace(int pos, int n,const char* s); </code>//替换从pos开始的n个字符为字符串s</li></ul><p><strong>示例：</strong></p><div class="code-wrapper"><pre><code class="hljs C++"><span class="hljs-comment">//查找和替换</span><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test01</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>{    <span class="hljs-comment">//查找</span>    string str1 = <span class="hljs-string">"abcdefgde"</span>;     <span class="hljs-type">int</span> pos = str1.<span class="hljs-built_in">find</span>(<span class="hljs-string">"de"</span>);     <span class="hljs-keyword">if</span> (pos == <span class="hljs-number">-1</span>)    {        cout &lt;&lt; <span class="hljs-string">"未找到"</span> &lt;&lt; endl;    }    <span class="hljs-keyword">else</span>    {        cout &lt;&lt; <span class="hljs-string">"pos = "</span> &lt;&lt; pos &lt;&lt; endl;    }         pos = str1.<span class="hljs-built_in">rfind</span>(<span class="hljs-string">"de"</span>);     cout &lt;&lt; <span class="hljs-string">"pos = "</span> &lt;&lt; pos &lt;&lt; endl; } <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test02</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>{    <span class="hljs-comment">//替换</span>    string str1 = <span class="hljs-string">"abcdefgde"</span>;    str1.<span class="hljs-built_in">replace</span>(<span class="hljs-number">1</span>, <span class="hljs-number">3</span>, <span class="hljs-string">"1111"</span>);     cout &lt;&lt; <span class="hljs-string">"str1 = "</span> &lt;&lt; str1 &lt;&lt; endl;} <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>{     <span class="hljs-comment">//test01();</span>    <span class="hljs-comment">//test02();</span>     <span class="hljs-built_in">system</span>(<span class="hljs-string">"pause"</span>);     <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;}</code></pre></div><p>总结：</p><ul><li>find查找是从左往后，rfind从右往左</li><li>find找到字符串后返回查找的第一个字符位置，找不到返回-1</li><li>replace在替换时，要指定从哪个位置起，多少个字符，替换成什么样的字符串</li></ul><h4><span id="3-1-6-string-zi-fu-chuan-bi-jiao">3.1.6 string字符串比较</span><a href="#3-1-6-string-zi-fu-chuan-bi-jiao" class="header-anchor">#</a></h4><p><strong>功能描述：</strong></p><ul><li>字符串之间的比较</li></ul><p><strong>比较方式：</strong></p><ul><li>字符串比较是按字符的ASCII码进行对比</li></ul><p>= 返回 0</p><p>&gt; 返回 1</p><p>&lt; 返回 -1</p><p><strong>函数原型：</strong></p><ul><li><code>int compare(const string &amp;s) const; </code>//与字符串s比较</li><li><code>int compare(const char *s) const;</code> //与字符串s比较</li></ul><p><strong>示例：</strong></p><div class="code-wrapper"><pre><code class="hljs C++"><span class="hljs-comment">//字符串比较</span><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test01</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>{     string s1 = <span class="hljs-string">"hello"</span>;    string s2 = <span class="hljs-string">"aello"</span>;     <span class="hljs-type">int</span> ret = s1.<span class="hljs-built_in">compare</span>(s2);     <span class="hljs-keyword">if</span> (ret == <span class="hljs-number">0</span>) {        cout &lt;&lt; <span class="hljs-string">"s1 等于 s2"</span> &lt;&lt; endl;    }    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (ret &gt; <span class="hljs-number">0</span>)    {        cout &lt;&lt; <span class="hljs-string">"s1 大于 s2"</span> &lt;&lt; endl;    }    <span class="hljs-keyword">else</span>    {        cout &lt;&lt; <span class="hljs-string">"s1 小于 s2"</span> &lt;&lt; endl;    } } <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>{     <span class="hljs-built_in">test01</span>();     <span class="hljs-built_in">system</span>(<span class="hljs-string">"pause"</span>);     <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;}</code></pre></div><p>总结：字符串对比主要是用于比较两个字符串是否相等，判断谁大谁小的意义并不是很大</p><h4><span id="3-1-7-string-zi-fu-cun-qu">3.1.7 string字符存取</span><a href="#3-1-7-string-zi-fu-cun-qu" class="header-anchor">#</a></h4><p>string中单个字符存取方式有两种</p><ul><li><code>char&amp; operator[](int n); </code>//通过[]方式取字符</li><li><code>char&amp; at(int n); </code>//通过at方法获取字符</li></ul><p><strong>示例：</strong></p><div class="code-wrapper"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test01</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>{    string str = <span class="hljs-string">"hello world"</span>;     <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; str.<span class="hljs-built_in">size</span>(); i++)    {        cout &lt;&lt; str[i] &lt;&lt; <span class="hljs-string">" "</span>;    }    cout &lt;&lt; endl;     <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; str.<span class="hljs-built_in">size</span>(); i++)    {        cout &lt;&lt; str.<span class="hljs-built_in">at</span>(i) &lt;&lt; <span class="hljs-string">" "</span>;    }    cout &lt;&lt; endl;      <span class="hljs-comment">//字符修改</span>    str[<span class="hljs-number">0</span>] = <span class="hljs-string">'x'</span>;    str.<span class="hljs-built_in">at</span>(<span class="hljs-number">1</span>) = <span class="hljs-string">'x'</span>;    cout &lt;&lt; str &lt;&lt; endl;    } <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>{     <span class="hljs-built_in">test01</span>();     <span class="hljs-built_in">system</span>(<span class="hljs-string">"pause"</span>);     <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;}</code></pre></div><p>总结：string字符串中单个字符存取有两种方式，利用 [ ] 或 at</p><h4><span id="3-1-8-string-cha-ru-he-shan-chu">3.1.8 string插入和删除</span><a href="#3-1-8-string-cha-ru-he-shan-chu" class="header-anchor">#</a></h4><p><strong>功能描述：</strong></p><ul><li>对string字符串进行插入和删除字符操作</li></ul><p><strong>函数原型：</strong></p><ul><li><code>string&amp; insert(int pos, const char* s); </code>//插入字符串</li><li><code>string&amp; insert(int pos, const string&amp; str); </code>//插入字符串</li><li><code>string&amp; insert(int pos, int n, char c);</code> //在指定位置插入n个字符c</li><li><code>string&amp; erase(int pos, int n = npos);</code> //删除从Pos开始的n个字符</li></ul><p><strong>示例：</strong></p><div class="code-wrapper"><pre><code class="hljs C++"><span class="hljs-comment">//字符串插入和删除</span><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test01</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>{    string str = <span class="hljs-string">"hello"</span>;    str.<span class="hljs-built_in">insert</span>(<span class="hljs-number">1</span>, <span class="hljs-string">"111"</span>);    cout &lt;&lt; str &lt;&lt; endl;     str.<span class="hljs-built_in">erase</span>(<span class="hljs-number">1</span>, <span class="hljs-number">3</span>);  <span class="hljs-comment">//从1号位置开始3个字符</span>    cout &lt;&lt; str &lt;&lt; endl;} <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>{     <span class="hljs-built_in">test01</span>();     <span class="hljs-built_in">system</span>(<span class="hljs-string">"pause"</span>);     <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;}</code></pre></div><p><strong>总结：</strong>插入和删除的起始下标都是从0开始</p><h4><span id="3-1-9-string-zi-chuan">3.1.9 string子串</span><a href="#3-1-9-string-zi-chuan" class="header-anchor">#</a></h4><p><strong>功能描述：</strong></p><ul><li>从字符串中获取想要的子串</li></ul><p><strong>函数原型：</strong></p><ul><li><code>string substr(int pos = 0, int n = npos) const;</code> //返回由pos开始的n个字符组成的字符串</li></ul><p><strong>示例：</strong></p><div class="code-wrapper"><pre><code class="hljs C++"><span class="hljs-comment">//子串</span><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test01</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>{     string str = <span class="hljs-string">"abcdefg"</span>;    string subStr = str.<span class="hljs-built_in">substr</span>(<span class="hljs-number">1</span>, <span class="hljs-number">3</span>);    cout &lt;&lt; <span class="hljs-string">"subStr = "</span> &lt;&lt; subStr &lt;&lt; endl;     string email = <span class="hljs-string">"hello@sina.com"</span>;    <span class="hljs-type">int</span> pos = email.<span class="hljs-built_in">find</span>(<span class="hljs-string">"@"</span>);    string username = email.<span class="hljs-built_in">substr</span>(<span class="hljs-number">0</span>, pos);    cout &lt;&lt; <span class="hljs-string">"username: "</span> &lt;&lt; username &lt;&lt; endl; } <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>{     <span class="hljs-built_in">test01</span>();     <span class="hljs-built_in">system</span>(<span class="hljs-string">"pause"</span>);     <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;}</code></pre></div><p><strong>总结：</strong>灵活的运用求子串功能，可以在实际开发中获取有效的信息</p><h3><span id="3-2-vector-rong-qi">3.2 vector容器</span><a href="#3-2-vector-rong-qi" class="header-anchor">#</a></h3><h4><span id="3-2-1-vector-ji-ben-gai-nian">3.2.1 vector基本概念</span><a href="#3-2-1-vector-ji-ben-gai-nian" class="header-anchor">#</a></h4><p><strong>功能：</strong></p><ul><li>vector数据结构和<strong>数组非常相似</strong>，也称为<strong>单端数组</strong></li></ul><p><strong>vector与普通数组区别：</strong></p><ul><li>不同之处在于数组是静态空间，而vector可以<strong>动态扩展</strong></li></ul><p><strong>动态扩展：</strong></p><ul><li>并不是在原空间之后续接新空间，而是找更大的内存空间，然后将原数据拷贝新空间，释放原空间</li></ul><p><img src="https://gitee.com/txt1994/images/raw/master/img/2021/08/clip_image002-0722912cd174422d9f0d1ee32ac38e05.jpg" alt="clip_image002"></p><ul><li>vector容器的迭代器是支持随机访问的迭代器</li></ul><h4><span id="3-2-2-vector-gou-zao-han-shu">3.2.2 vector构造函数</span><a href="#3-2-2-vector-gou-zao-han-shu" class="header-anchor">#</a></h4><p><strong>功能描述：</strong></p><ul><li>创建vector容器</li></ul><p><strong>函数原型：</strong></p><ul><li><code>vector v; </code>//采用模板实现类实现，默认构造函数</li><li><code>vector(v.begin(), v.end()); </code>//将v[begin(), end())区间中的元素拷贝给本身。</li><li><code>vector(n, elem);</code> //构造函数将n个elem拷贝给本身。</li><li><code>vector(const vector &amp;vec);</code> //拷贝构造函数。</li></ul><p><strong>示例：</strong></p><div class="code-wrapper"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span> <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">printVector</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; v)</span> </span>{     <span class="hljs-keyword">for</span> (vector&lt;<span class="hljs-type">int</span>&gt;::iterator it = v.<span class="hljs-built_in">begin</span>(); it != v.<span class="hljs-built_in">end</span>(); it++) {        cout &lt;&lt; *it &lt;&lt; <span class="hljs-string">" "</span>;    }    cout &lt;&lt; endl;} <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test01</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>{    vector&lt;<span class="hljs-type">int</span>&gt; v1; <span class="hljs-comment">//无参构造</span>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++)    {        v1.<span class="hljs-built_in">push_back</span>(i);    }    <span class="hljs-built_in">printVector</span>(v1);     <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">v2</span><span class="hljs-params">(v1.begin(), v1.end())</span></span>;    <span class="hljs-built_in">printVector</span>(v2);     <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">v3</span><span class="hljs-params">(<span class="hljs-number">10</span>, <span class="hljs-number">100</span>)</span></span>;    <span class="hljs-built_in">printVector</span>(v3);        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">v4</span><span class="hljs-params">(v3)</span></span>;    <span class="hljs-built_in">printVector</span>(v4);} <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>{     <span class="hljs-built_in">test01</span>();     <span class="hljs-built_in">system</span>(<span class="hljs-string">"pause"</span>);     <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;}</code></pre></div><p><strong>总结：</strong>vector的多种构造方式没有可比性，灵活使用即可</p><h4><span id="3-2-3-vector-fu-zhi-cao-zuo">3.2.3 vector赋值操作</span><a href="#3-2-3-vector-fu-zhi-cao-zuo" class="header-anchor">#</a></h4><p><strong>功能描述：</strong></p><ul><li>给vector容器进行赋值</li></ul><p><strong>函数原型：</strong></p><ul><li><p><code>vector&amp; operator=(const vector &amp;vec);</code>//重载等号操作符</p></li><li><p><code>assign(beg, end);</code> //将[beg, end)区间中的数据拷贝赋值给本身。</p></li><li><p><code>assign(n, elem);</code> //将n个elem拷贝赋值给本身。</p></li></ul><p><strong>示例：</strong></p><div class="code-wrapper"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span> <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">printVector</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; v)</span> </span>{     <span class="hljs-keyword">for</span> (vector&lt;<span class="hljs-type">int</span>&gt;::iterator it = v.<span class="hljs-built_in">begin</span>(); it != v.<span class="hljs-built_in">end</span>(); it++) {        cout &lt;&lt; *it &lt;&lt; <span class="hljs-string">" "</span>;    }    cout &lt;&lt; endl;} <span class="hljs-comment">//赋值操作</span><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test01</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>{    vector&lt;<span class="hljs-type">int</span>&gt; v1; <span class="hljs-comment">//无参构造</span>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++)    {        v1.<span class="hljs-built_in">push_back</span>(i);    }    <span class="hljs-built_in">printVector</span>(v1);     vector&lt;<span class="hljs-type">int</span>&gt;v2;    v2 = v1;    <span class="hljs-built_in">printVector</span>(v2);     vector&lt;<span class="hljs-type">int</span>&gt;v3;    v3.<span class="hljs-built_in">assign</span>(v1.<span class="hljs-built_in">begin</span>(), v1.<span class="hljs-built_in">end</span>());    <span class="hljs-built_in">printVector</span>(v3);     vector&lt;<span class="hljs-type">int</span>&gt;v4;    v4.<span class="hljs-built_in">assign</span>(<span class="hljs-number">10</span>, <span class="hljs-number">100</span>);    <span class="hljs-built_in">printVector</span>(v4);} <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>{     <span class="hljs-built_in">test01</span>();     <span class="hljs-built_in">system</span>(<span class="hljs-string">"pause"</span>);     <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;}</code></pre></div><p>总结： vector赋值方式比较简单，使用operator=，或者assign都可以</p><h4><span id="3-2-4-vector-rong-liang-he-da-xiao">3.2.4 vector容量和大小</span><a href="#3-2-4-vector-rong-liang-he-da-xiao" class="header-anchor">#</a></h4><p><strong>功能描述：</strong></p><ul><li>对vector容器的容量和大小操作</li></ul><p><strong>函数原型：</strong></p><ul><li><p><code>empty(); </code>//判断容器是否为空</p></li><li><p><code>capacity();</code> //容器的容量</p></li><li><p><code>size();</code> //返回容器中元素的个数</p></li><li><p><code>resize(int num);</code> //重新指定容器的长度为num，若容器变长，则以默认值填充新位置。</p><p> //如果容器变短，则末尾超出容器长度的元素被删除。</p></li><li><p><code>resize(int num, elem);</code> //重新指定容器的长度为num，若容器变长，则以elem值填充新位置。</p><p> //如果容器变短，则末尾超出容器长度的元素被删除</p></li></ul><p><strong>示例：</strong></p><div class="code-wrapper"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span> <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">printVector</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; v)</span> </span>{     <span class="hljs-keyword">for</span> (vector&lt;<span class="hljs-type">int</span>&gt;::iterator it = v.<span class="hljs-built_in">begin</span>(); it != v.<span class="hljs-built_in">end</span>(); it++) {        cout &lt;&lt; *it &lt;&lt; <span class="hljs-string">" "</span>;    }    cout &lt;&lt; endl;} <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test01</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>{    vector&lt;<span class="hljs-type">int</span>&gt; v1;    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++)    {        v1.<span class="hljs-built_in">push_back</span>(i);    }    <span class="hljs-built_in">printVector</span>(v1);    <span class="hljs-keyword">if</span> (v1.<span class="hljs-built_in">empty</span>())    {        cout &lt;&lt; <span class="hljs-string">"v1为空"</span> &lt;&lt; endl;    }    <span class="hljs-keyword">else</span>    {        cout &lt;&lt; <span class="hljs-string">"v1不为空"</span> &lt;&lt; endl;        cout &lt;&lt; <span class="hljs-string">"v1的容量 = "</span> &lt;&lt; v1.<span class="hljs-built_in">capacity</span>() &lt;&lt; endl;        cout &lt;&lt; <span class="hljs-string">"v1的大小 = "</span> &lt;&lt; v1.<span class="hljs-built_in">size</span>() &lt;&lt; endl;    }     <span class="hljs-comment">//resize 重新指定大小 ，若指定的更大，默认用0填充新位置，可以利用重载版本替换默认填充</span>    v1.<span class="hljs-built_in">resize</span>(<span class="hljs-number">15</span>,<span class="hljs-number">10</span>);    <span class="hljs-built_in">printVector</span>(v1);     <span class="hljs-comment">//resize 重新指定大小 ，若指定的更小，超出部分元素被删除</span>    v1.<span class="hljs-built_in">resize</span>(<span class="hljs-number">5</span>);    <span class="hljs-built_in">printVector</span>(v1);} <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>{     <span class="hljs-built_in">test01</span>();     <span class="hljs-built_in">system</span>(<span class="hljs-string">"pause"</span>);     <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;}</code></pre></div><p>总结：</p><ul><li>判断是否为空 — empty</li><li>返回元素个数 — size</li><li>返回容器容量 — capacity</li><li>重新指定大小 — resize</li></ul><h4><span id="3-2-5-vector-cha-ru-he-shan-chu">3.2.5 vector插入和删除</span><a href="#3-2-5-vector-cha-ru-he-shan-chu" class="header-anchor">#</a></h4><p><strong>功能描述：</strong></p><ul><li>对vector容器进行插入、删除操作</li></ul><p><strong>函数原型：</strong></p><ul><li><code>push_back(ele);</code> //尾部插入元素ele</li><li><code>pop_back();</code> //删除最后一个元素</li><li><code>insert(const_iterator pos, ele);</code> //迭代器指向位置pos插入元素ele</li><li><code>insert(const_iterator pos, int count,ele);</code>//迭代器指向位置pos插入count个元素ele</li><li><code>erase(const_iterator pos);</code> //删除迭代器指向的元素</li><li><code>erase(const_iterator start, const_iterator end);</code>//删除迭代器从start到end之间的元素</li><li><code>clear();</code> //删除容器中所有元素</li></ul><p><strong>示例：</strong></p><div class="code-wrapper"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span> <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">printVector</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; v)</span> </span>{     <span class="hljs-keyword">for</span> (vector&lt;<span class="hljs-type">int</span>&gt;::iterator it = v.<span class="hljs-built_in">begin</span>(); it != v.<span class="hljs-built_in">end</span>(); it++) {        cout &lt;&lt; *it &lt;&lt; <span class="hljs-string">" "</span>;    }    cout &lt;&lt; endl;} <span class="hljs-comment">//插入和删除</span><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test01</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>{    vector&lt;<span class="hljs-type">int</span>&gt; v1;    <span class="hljs-comment">//尾插</span>    v1.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">10</span>);    v1.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">20</span>);    v1.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">30</span>);    v1.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">40</span>);    v1.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">50</span>);    <span class="hljs-built_in">printVector</span>(v1);    <span class="hljs-comment">//尾删</span>    v1.<span class="hljs-built_in">pop_back</span>();    <span class="hljs-built_in">printVector</span>(v1);    <span class="hljs-comment">//插入</span>    v1.<span class="hljs-built_in">insert</span>(v1.<span class="hljs-built_in">begin</span>(), <span class="hljs-number">100</span>);    <span class="hljs-built_in">printVector</span>(v1);     v1.<span class="hljs-built_in">insert</span>(v1.<span class="hljs-built_in">begin</span>(), <span class="hljs-number">2</span>, <span class="hljs-number">1000</span>);    <span class="hljs-built_in">printVector</span>(v1);     <span class="hljs-comment">//删除</span>    v1.<span class="hljs-built_in">erase</span>(v1.<span class="hljs-built_in">begin</span>());    <span class="hljs-built_in">printVector</span>(v1);     <span class="hljs-comment">//清空</span>    v1.<span class="hljs-built_in">erase</span>(v1.<span class="hljs-built_in">begin</span>(), v1.<span class="hljs-built_in">end</span>());    v1.<span class="hljs-built_in">clear</span>();    <span class="hljs-built_in">printVector</span>(v1);} <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>{     <span class="hljs-built_in">test01</span>();     <span class="hljs-built_in">system</span>(<span class="hljs-string">"pause"</span>);     <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;}</code></pre></div><p>总结：</p><ul><li>尾插 — push_back</li><li>尾删 — pop_back</li><li>插入 — insert (位置迭代器)</li><li>删除 — erase （位置迭代器）</li><li>清空 — clear</li></ul><h4><span id="3-2-6-vector-shu-ju-cun-qu">3.2.6 vector数据存取</span><a href="#3-2-6-vector-shu-ju-cun-qu" class="header-anchor">#</a></h4><p><strong>功能描述：</strong></p><ul><li>对vector中的数据的存取操作</li></ul><p><strong>函数原型：</strong></p><ul><li><code>at(int idx); </code>//返回索引idx所指的数据</li><li><code>operator[]; </code>//返回索引idx所指的数据</li><li><code>front(); </code>//返回容器中第一个数据元素</li><li><code>back();</code> //返回容器中最后一个数据元素</li></ul><p><strong>示例：</strong></p><div class="code-wrapper"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span> <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test01</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>{    vector&lt;<span class="hljs-type">int</span>&gt;v1;    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++)    {        v1.<span class="hljs-built_in">push_back</span>(i);    }     <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; v1.<span class="hljs-built_in">size</span>(); i++)    {        cout &lt;&lt; v1[i] &lt;&lt; <span class="hljs-string">" "</span>;    }    cout &lt;&lt; endl;     <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; v1.<span class="hljs-built_in">size</span>(); i++)    {        cout &lt;&lt; v1.<span class="hljs-built_in">at</span>(i) &lt;&lt; <span class="hljs-string">" "</span>;    }    cout &lt;&lt; endl;     cout &lt;&lt; <span class="hljs-string">"v1的第一个元素为： "</span> &lt;&lt; v1.<span class="hljs-built_in">front</span>() &lt;&lt; endl;    cout &lt;&lt; <span class="hljs-string">"v1的最后一个元素为： "</span> &lt;&lt; v1.<span class="hljs-built_in">back</span>() &lt;&lt; endl;} <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>{     <span class="hljs-built_in">test01</span>();     <span class="hljs-built_in">system</span>(<span class="hljs-string">"pause"</span>);     <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;}</code></pre></div><p>总结：</p><ul><li>除了用迭代器获取vector容器中元素，[ ]和at也可以</li><li>front返回容器第一个元素</li><li>back返回容器最后一个元素</li></ul><h4><span id="3-2-7-vector-hu-huan-rong-qi">3.2.7 vector互换容器</span><a href="#3-2-7-vector-hu-huan-rong-qi" class="header-anchor">#</a></h4><p><strong>功能描述：</strong></p><ul><li>实现两个容器内元素进行互换</li></ul><p><strong>函数原型：</strong></p><ul><li><code>swap(vec);</code> // 将vec与本身的元素互换</li></ul><p><strong>示例：</strong></p><div class="code-wrapper"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span> <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">printVector</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; v)</span> </span>{     <span class="hljs-keyword">for</span> (vector&lt;<span class="hljs-type">int</span>&gt;::iterator it = v.<span class="hljs-built_in">begin</span>(); it != v.<span class="hljs-built_in">end</span>(); it++) {        cout &lt;&lt; *it &lt;&lt; <span class="hljs-string">" "</span>;    }    cout &lt;&lt; endl;} <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test01</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>{    vector&lt;<span class="hljs-type">int</span>&gt;v1;    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++)    {        v1.<span class="hljs-built_in">push_back</span>(i);    }    <span class="hljs-built_in">printVector</span>(v1);     vector&lt;<span class="hljs-type">int</span>&gt;v2;    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">10</span>; i &gt; <span class="hljs-number">0</span>; i--)    {        v2.<span class="hljs-built_in">push_back</span>(i);    }    <span class="hljs-built_in">printVector</span>(v2);     <span class="hljs-comment">//互换容器</span>    cout &lt;&lt; <span class="hljs-string">"互换后"</span> &lt;&lt; endl;    v1.<span class="hljs-built_in">swap</span>(v2);    <span class="hljs-built_in">printVector</span>(v1);    <span class="hljs-built_in">printVector</span>(v2);} <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test02</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>{    vector&lt;<span class="hljs-type">int</span>&gt; v;    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">100000</span>; i++) {        v.<span class="hljs-built_in">push_back</span>(i);    }     cout &lt;&lt; <span class="hljs-string">"v的容量为："</span> &lt;&lt; v.<span class="hljs-built_in">capacity</span>() &lt;&lt; endl;    cout &lt;&lt; <span class="hljs-string">"v的大小为："</span> &lt;&lt; v.<span class="hljs-built_in">size</span>() &lt;&lt; endl;     v.<span class="hljs-built_in">resize</span>(<span class="hljs-number">3</span>);     cout &lt;&lt; <span class="hljs-string">"v的容量为："</span> &lt;&lt; v.<span class="hljs-built_in">capacity</span>() &lt;&lt; endl;    cout &lt;&lt; <span class="hljs-string">"v的大小为："</span> &lt;&lt; v.<span class="hljs-built_in">size</span>() &lt;&lt; endl;     <span class="hljs-comment">//收缩内存</span>    <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;(v).<span class="hljs-built_in">swap</span>(v); <span class="hljs-comment">//匿名对象</span>     cout &lt;&lt; <span class="hljs-string">"v的容量为："</span> &lt;&lt; v.<span class="hljs-built_in">capacity</span>() &lt;&lt; endl;    cout &lt;&lt; <span class="hljs-string">"v的大小为："</span> &lt;&lt; v.<span class="hljs-built_in">size</span>() &lt;&lt; endl;} <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>{     <span class="hljs-built_in">test01</span>();     <span class="hljs-built_in">test02</span>();     <span class="hljs-built_in">system</span>(<span class="hljs-string">"pause"</span>);     <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;}</code></pre></div><p>总结：swap可以使两个容器互换，可以达到实用的收缩内存效果</p><h4><span id="3-2-8-vector-yu-liu-kong-jian">3.2.8 vector预留空间</span><a href="#3-2-8-vector-yu-liu-kong-jian" class="header-anchor">#</a></h4><p><strong>功能描述：</strong></p><ul><li>减少vector在动态扩展容量时的扩展次数</li></ul><p><strong>函数原型：</strong></p><ul><li><code>reserve(int len);</code>//容器预留len个元素长度，预留位置不初始化，元素不可访问。</li></ul><p><strong>示例：</strong></p><div class="code-wrapper"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span> <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test01</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>{    vector&lt;<span class="hljs-type">int</span>&gt; v;     <span class="hljs-comment">//预留空间</span>    v.<span class="hljs-built_in">reserve</span>(<span class="hljs-number">100000</span>);     <span class="hljs-type">int</span> num = <span class="hljs-number">0</span>;    <span class="hljs-type">int</span>* p = <span class="hljs-literal">NULL</span>;    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">100000</span>; i++) {        v.<span class="hljs-built_in">push_back</span>(i);        <span class="hljs-keyword">if</span> (p != &amp;v[<span class="hljs-number">0</span>]) {            p = &amp;v[<span class="hljs-number">0</span>];            num++;        }    }     cout &lt;&lt; <span class="hljs-string">"num:"</span> &lt;&lt; num &lt;&lt; endl;} <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>{     <span class="hljs-built_in">test01</span>();        <span class="hljs-built_in">system</span>(<span class="hljs-string">"pause"</span>);     <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;}</code></pre></div><p>总结：如果数据量较大，可以一开始利用reserve预留空间</p><h3><span id="3-3-deque-rong-qi">3.3 deque容器</span><a href="#3-3-deque-rong-qi" class="header-anchor">#</a></h3><h4><span id="3-3-1-deque-rong-qi-ji-ben-gai-nian">3.3.1 deque容器基本概念</span><a href="#3-3-1-deque-rong-qi-ji-ben-gai-nian" class="header-anchor">#</a></h4><p><strong>功能：</strong></p><ul><li>双端数组，可以对头端进行插入删除操作</li></ul><p><strong>deque与vector区别：</strong></p><ul><li>vector对于头部的插入删除效率低，数据量越大，效率越低</li><li>deque相对而言，对头部的插入删除速度回比vector快</li><li>vector访问元素时的速度会比deque快,这和两者内部实现有关</li></ul><p><img src="https://gitee.com/txt1994/images/raw/master/img/2021/08/clip_image002-1547547642923-dfa3a67b49d24fbcbd9068ea1c0ab6c6.jpg" alt="clip_image002-1547547642923"></p><p>deque内部工作原理:</p><p>deque内部有个<strong>中控器</strong>，维护每段缓冲区中的内容，缓冲区中存放真实数据</p><p>中控器维护的是每个缓冲区的地址，使得使用deque时像一片连续的内存空间</p><p><img src="https://gitee.com/txt1994/images/raw/master/img/2021/08/clip_image002-1547547896341-bd419e02441d42bf8be3362090722eb6.jpg" alt="clip_image002-1547547896341"></p><ul><li>deque容器的迭代器也是支持随机访问的</li></ul><h4><span id="3-3-2-deque-gou-zao-han-shu">3.3.2 deque构造函数</span><a href="#3-3-2-deque-gou-zao-han-shu" class="header-anchor">#</a></h4><p><strong>功能描述：</strong></p><ul><li>deque容器构造</li></ul><p><strong>函数原型：</strong></p><ul><li><code>deque</code> deqT; //默认构造形式</li><li><code>deque(beg, end);</code> //构造函数将[beg, end)区间中的元素拷贝给本身。</li><li><code>deque(n, elem);</code> //构造函数将n个elem拷贝给本身。</li><li><code>deque(const deque &amp;deq);</code> //拷贝构造函数</li></ul><p><strong>示例：</strong></p><div class="code-wrapper"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;deque&gt;</span></span> <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">printDeque</span><span class="hljs-params">(<span class="hljs-type">const</span> deque&lt;<span class="hljs-type">int</span>&gt;&amp; d)</span> </span><span class="hljs-function"></span>{    <span class="hljs-keyword">for</span> (deque&lt;<span class="hljs-type">int</span>&gt;::const_iterator it = d.<span class="hljs-built_in">begin</span>(); it != d.<span class="hljs-built_in">end</span>(); it++) {        cout &lt;&lt; *it &lt;&lt; <span class="hljs-string">" "</span>;     }    cout &lt;&lt; endl;}<span class="hljs-comment">//deque构造</span><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test01</span><span class="hljs-params">()</span> </span>{     deque&lt;<span class="hljs-type">int</span>&gt; d1; <span class="hljs-comment">//无参构造函数</span>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++)    {        d1.<span class="hljs-built_in">push_back</span>(i);    }    <span class="hljs-built_in">printDeque</span>(d1);    <span class="hljs-function">deque&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">d2</span><span class="hljs-params">(d1.begin(),d1.end())</span></span>;    <span class="hljs-built_in">printDeque</span>(d2);     deque&lt;<span class="hljs-type">int</span>&gt;<span class="hljs-built_in">d3</span>(<span class="hljs-number">10</span>,<span class="hljs-number">100</span>);    <span class="hljs-built_in">printDeque</span>(d3);     deque&lt;<span class="hljs-type">int</span>&gt;d4 = d3;    <span class="hljs-built_in">printDeque</span>(d4);} <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>{     <span class="hljs-built_in">test01</span>();     <span class="hljs-built_in">system</span>(<span class="hljs-string">"pause"</span>);     <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;}</code></pre></div><p><strong>总结：</strong>deque容器和vector容器的构造方式几乎一致，灵活使用即可</p><h4><span id="3-3-3-deque-fu-zhi-cao-zuo">3.3.3 deque赋值操作</span><a href="#3-3-3-deque-fu-zhi-cao-zuo" class="header-anchor">#</a></h4><p><strong>功能描述：</strong></p><ul><li>给deque容器进行赋值</li></ul><p><strong>函数原型：</strong></p><ul><li><p><code>deque&amp; operator=(const deque &amp;deq); </code>//重载等号操作符</p></li><li><p><code>assign(beg, end);</code> //将[beg, end)区间中的数据拷贝赋值给本身。</p></li><li><p><code>assign(n, elem);</code> //将n个elem拷贝赋值给本身。</p></li></ul><p><strong>示例：</strong></p><div class="code-wrapper"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;deque&gt;</span></span> <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">printDeque</span><span class="hljs-params">(<span class="hljs-type">const</span> deque&lt;<span class="hljs-type">int</span>&gt;&amp; d)</span> </span><span class="hljs-function"></span>{    <span class="hljs-keyword">for</span> (deque&lt;<span class="hljs-type">int</span>&gt;::const_iterator it = d.<span class="hljs-built_in">begin</span>(); it != d.<span class="hljs-built_in">end</span>(); it++) {        cout &lt;&lt; *it &lt;&lt; <span class="hljs-string">" "</span>;     }    cout &lt;&lt; endl;}<span class="hljs-comment">//赋值操作</span><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test01</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>{    deque&lt;<span class="hljs-type">int</span>&gt; d1;    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++)    {        d1.<span class="hljs-built_in">push_back</span>(i);    }    <span class="hljs-built_in">printDeque</span>(d1);     deque&lt;<span class="hljs-type">int</span>&gt;d2;    d2 = d1;    <span class="hljs-built_in">printDeque</span>(d2);     deque&lt;<span class="hljs-type">int</span>&gt;d3;    d3.<span class="hljs-built_in">assign</span>(d1.<span class="hljs-built_in">begin</span>(), d1.<span class="hljs-built_in">end</span>());    <span class="hljs-built_in">printDeque</span>(d3);     deque&lt;<span class="hljs-type">int</span>&gt;d4;    d4.<span class="hljs-built_in">assign</span>(<span class="hljs-number">10</span>, <span class="hljs-number">100</span>);    <span class="hljs-built_in">printDeque</span>(d4); } <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>{     <span class="hljs-built_in">test01</span>();     <span class="hljs-built_in">system</span>(<span class="hljs-string">"pause"</span>);     <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;}</code></pre></div><p>总结：deque赋值操作也与vector相同，需熟练掌握</p><h4><span id="3-3-4-deque-da-xiao-cao-zuo">3.3.4 deque大小操作</span><a href="#3-3-4-deque-da-xiao-cao-zuo" class="header-anchor">#</a></h4><p><strong>功能描述：</strong></p><ul><li>对deque容器的大小进行操作</li></ul><p><strong>函数原型：</strong></p><ul><li><p><code>deque.empty();</code> //判断容器是否为空</p></li><li><p><code>deque.size();</code> //返回容器中元素的个数</p></li><li><p><code>deque.resize(num);</code> //重新指定容器的长度为num,若容器变长，则以默认值填充新位置。</p><p> //如果容器变短，则末尾超出容器长度的元素被删除。</p></li><li><p><code>deque.resize(num, elem);</code> //重新指定容器的长度为num,若容器变长，则以elem值填充新位置。</p><p> //如果容器变短，则末尾超出容器长度的元素被删除。</p></li></ul><p><strong>示例：</strong></p><div class="code-wrapper"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;deque&gt;</span></span> <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">printDeque</span><span class="hljs-params">(<span class="hljs-type">const</span> deque&lt;<span class="hljs-type">int</span>&gt;&amp; d)</span> </span><span class="hljs-function"></span>{    <span class="hljs-keyword">for</span> (deque&lt;<span class="hljs-type">int</span>&gt;::const_iterator it = d.<span class="hljs-built_in">begin</span>(); it != d.<span class="hljs-built_in">end</span>(); it++) {        cout &lt;&lt; *it &lt;&lt; <span class="hljs-string">" "</span>;     }    cout &lt;&lt; endl;} <span class="hljs-comment">//大小操作</span><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test01</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>{    deque&lt;<span class="hljs-type">int</span>&gt; d1;    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++)    {        d1.<span class="hljs-built_in">push_back</span>(i);    }    <span class="hljs-built_in">printDeque</span>(d1);     <span class="hljs-comment">//判断容器是否为空</span>    <span class="hljs-keyword">if</span> (d1.<span class="hljs-built_in">empty</span>()) {        cout &lt;&lt; <span class="hljs-string">"d1为空!"</span> &lt;&lt; endl;    }    <span class="hljs-keyword">else</span> {        cout &lt;&lt; <span class="hljs-string">"d1不为空!"</span> &lt;&lt; endl;        <span class="hljs-comment">//统计大小</span>        cout &lt;&lt; <span class="hljs-string">"d1的大小为："</span> &lt;&lt; d1.<span class="hljs-built_in">size</span>() &lt;&lt; endl;    }     <span class="hljs-comment">//重新指定大小</span>    d1.<span class="hljs-built_in">resize</span>(<span class="hljs-number">15</span>, <span class="hljs-number">1</span>);    <span class="hljs-built_in">printDeque</span>(d1);     d1.<span class="hljs-built_in">resize</span>(<span class="hljs-number">5</span>);    <span class="hljs-built_in">printDeque</span>(d1);} <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>{     <span class="hljs-built_in">test01</span>();     <span class="hljs-built_in">system</span>(<span class="hljs-string">"pause"</span>);     <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;}</code></pre></div><p>总结：</p><ul><li>deque没有容量的概念</li><li>判断是否为空 — empty</li><li>返回元素个数 — size</li><li>重新指定个数 — resize</li></ul><h4><span id="3-3-5-deque-cha-ru-he-shan-chu">3.3.5 deque 插入和删除</span><a href="#3-3-5-deque-cha-ru-he-shan-chu" class="header-anchor">#</a></h4><p><strong>功能描述：</strong></p><ul><li>向deque容器中插入和删除数据</li></ul><p><strong>函数原型：</strong></p><p>两端插入操作：</p><ul><li><code>push_back(elem);</code> //在容器尾部添加一个数据</li><li><code>push_front(elem);</code> //在容器头部插入一个数据</li><li><code>pop_back();</code> //删除容器最后一个数据</li><li><code>pop_front();</code> //删除容器第一个数据</li></ul><p>指定位置操作：</p><ul><li><code>insert(pos,elem);</code> //在pos位置插入一个elem元素的拷贝，返回新数据的位置。</li><li><code>insert(pos,n,elem);</code> //在pos位置插入n个elem数据，无返回值。</li><li><code>insert(pos,beg,end);</code> //在pos位置插入[beg,end)区间的数据，无返回值。</li><li><code>clear();</code> //清空容器的所有数据</li><li><code>erase(beg,end);</code> //删除[beg,end)区间的数据，返回下一个数据的位置。</li><li><code>erase(pos);</code> //删除pos位置的数据，返回下一个数据的位置。</li></ul><p><strong>示例：</strong></p><div class="code-wrapper"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;deque&gt;</span></span> <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">printDeque</span><span class="hljs-params">(<span class="hljs-type">const</span> deque&lt;<span class="hljs-type">int</span>&gt;&amp; d)</span> </span><span class="hljs-function"></span>{    <span class="hljs-keyword">for</span> (deque&lt;<span class="hljs-type">int</span>&gt;::const_iterator it = d.<span class="hljs-built_in">begin</span>(); it != d.<span class="hljs-built_in">end</span>(); it++) {        cout &lt;&lt; *it &lt;&lt; <span class="hljs-string">" "</span>;     }    cout &lt;&lt; endl;}<span class="hljs-comment">//两端操作</span><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test01</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>{    deque&lt;<span class="hljs-type">int</span>&gt; d;    <span class="hljs-comment">//尾插</span>    d.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">10</span>);    d.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">20</span>);    <span class="hljs-comment">//头插</span>    d.<span class="hljs-built_in">push_front</span>(<span class="hljs-number">100</span>);    d.<span class="hljs-built_in">push_front</span>(<span class="hljs-number">200</span>);     <span class="hljs-built_in">printDeque</span>(d);     <span class="hljs-comment">//尾删</span>    d.<span class="hljs-built_in">pop_back</span>();    <span class="hljs-comment">//头删</span>    d.<span class="hljs-built_in">pop_front</span>();    <span class="hljs-built_in">printDeque</span>(d);} <span class="hljs-comment">//插入</span><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test02</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>{    deque&lt;<span class="hljs-type">int</span>&gt; d;    d.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">10</span>);    d.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">20</span>);    d.<span class="hljs-built_in">push_front</span>(<span class="hljs-number">100</span>);    d.<span class="hljs-built_in">push_front</span>(<span class="hljs-number">200</span>);    <span class="hljs-built_in">printDeque</span>(d);     d.<span class="hljs-built_in">insert</span>(d.<span class="hljs-built_in">begin</span>(), <span class="hljs-number">1000</span>);    <span class="hljs-built_in">printDeque</span>(d);     d.<span class="hljs-built_in">insert</span>(d.<span class="hljs-built_in">begin</span>(), <span class="hljs-number">2</span>,<span class="hljs-number">10000</span>);    <span class="hljs-built_in">printDeque</span>(d);     deque&lt;<span class="hljs-type">int</span>&gt;d2;    d2.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">1</span>);    d2.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">2</span>);    d2.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">3</span>);     d.<span class="hljs-built_in">insert</span>(d.<span class="hljs-built_in">begin</span>(), d2.<span class="hljs-built_in">begin</span>(), d2.<span class="hljs-built_in">end</span>());    <span class="hljs-built_in">printDeque</span>(d); } <span class="hljs-comment">//删除</span><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test03</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>{    deque&lt;<span class="hljs-type">int</span>&gt; d;    d.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">10</span>);    d.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">20</span>);    d.<span class="hljs-built_in">push_front</span>(<span class="hljs-number">100</span>);    d.<span class="hljs-built_in">push_front</span>(<span class="hljs-number">200</span>);    <span class="hljs-built_in">printDeque</span>(d);     d.<span class="hljs-built_in">erase</span>(d.<span class="hljs-built_in">begin</span>());    <span class="hljs-built_in">printDeque</span>(d);     d.<span class="hljs-built_in">erase</span>(d.<span class="hljs-built_in">begin</span>(), d.<span class="hljs-built_in">end</span>());    d.<span class="hljs-built_in">clear</span>();    <span class="hljs-built_in">printDeque</span>(d);} <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>{     <span class="hljs-comment">//test01();</span>     <span class="hljs-comment">//test02();</span>     <span class="hljs-built_in">test03</span>();        <span class="hljs-built_in">system</span>(<span class="hljs-string">"pause"</span>);     <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;}</code></pre></div><p>总结：</p><ul><li>插入和删除提供的位置是迭代器！</li><li>尾插 — push_back</li><li>尾删 — pop_back</li><li>头插 — push_front</li><li>头删 — pop_front</li></ul><h4><span id="3-3-6-deque-shu-ju-cun-qu">3.3.6 deque 数据存取</span><a href="#3-3-6-deque-shu-ju-cun-qu" class="header-anchor">#</a></h4><p><strong>功能描述：</strong></p><ul><li>对deque 中的数据的存取操作</li></ul><p><strong>函数原型：</strong></p><ul><li><code>at(int idx); </code>//返回索引idx所指的数据</li><li><code>operator[]; </code>//返回索引idx所指的数据</li><li><code>front(); </code>//返回容器中第一个数据元素</li><li><code>back();</code> //返回容器中最后一个数据元素</li></ul><p><strong>示例：</strong></p><div class="code-wrapper"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;deque&gt;</span></span> <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">printDeque</span><span class="hljs-params">(<span class="hljs-type">const</span> deque&lt;<span class="hljs-type">int</span>&gt;&amp; d)</span> </span><span class="hljs-function"></span>{    <span class="hljs-keyword">for</span> (deque&lt;<span class="hljs-type">int</span>&gt;::const_iterator it = d.<span class="hljs-built_in">begin</span>(); it != d.<span class="hljs-built_in">end</span>(); it++) {        cout &lt;&lt; *it &lt;&lt; <span class="hljs-string">" "</span>;     }    cout &lt;&lt; endl;} <span class="hljs-comment">//数据存取</span><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test01</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>{     deque&lt;<span class="hljs-type">int</span>&gt; d;    d.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">10</span>);    d.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">20</span>);    d.<span class="hljs-built_in">push_front</span>(<span class="hljs-number">100</span>);    d.<span class="hljs-built_in">push_front</span>(<span class="hljs-number">200</span>);     <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; d.<span class="hljs-built_in">size</span>(); i++) {        cout &lt;&lt; d[i] &lt;&lt; <span class="hljs-string">" "</span>;    }    cout &lt;&lt; endl;      <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; d.<span class="hljs-built_in">size</span>(); i++) {        cout &lt;&lt; d.<span class="hljs-built_in">at</span>(i) &lt;&lt; <span class="hljs-string">" "</span>;    }    cout &lt;&lt; endl;     cout &lt;&lt; <span class="hljs-string">"front:"</span> &lt;&lt; d.<span class="hljs-built_in">front</span>() &lt;&lt; endl;     cout &lt;&lt; <span class="hljs-string">"back:"</span> &lt;&lt; d.<span class="hljs-built_in">back</span>() &lt;&lt; endl; } <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>{     <span class="hljs-built_in">test01</span>();     <span class="hljs-built_in">system</span>(<span class="hljs-string">"pause"</span>);     <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;}</code></pre></div><p>总结：</p><ul><li>除了用迭代器获取deque容器中元素，[ ]和at也可以</li><li>front返回容器第一个元素</li><li>back返回容器最后一个元素</li></ul><h4><span id="3-3-7-deque-pai-xu">3.3.7 deque 排序</span><a href="#3-3-7-deque-pai-xu" class="header-anchor">#</a></h4><p><strong>功能描述：</strong></p><ul><li>利用算法实现对deque容器进行排序</li></ul><p><strong>算法：</strong></p><ul><li><code>sort(iterator beg, iterator end)</code> //对beg和end区间内元素进行排序</li></ul><p><strong>示例：</strong></p><div class="code-wrapper"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;deque&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span> <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">printDeque</span><span class="hljs-params">(<span class="hljs-type">const</span> deque&lt;<span class="hljs-type">int</span>&gt;&amp; d)</span> </span><span class="hljs-function"></span>{    <span class="hljs-keyword">for</span> (deque&lt;<span class="hljs-type">int</span>&gt;::const_iterator it = d.<span class="hljs-built_in">begin</span>(); it != d.<span class="hljs-built_in">end</span>(); it++) {        cout &lt;&lt; *it &lt;&lt; <span class="hljs-string">" "</span>;     }    cout &lt;&lt; endl;} <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test01</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>{     deque&lt;<span class="hljs-type">int</span>&gt; d;    d.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">10</span>);    d.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">20</span>);    d.<span class="hljs-built_in">push_front</span>(<span class="hljs-number">100</span>);    d.<span class="hljs-built_in">push_front</span>(<span class="hljs-number">200</span>);     <span class="hljs-built_in">printDeque</span>(d);    <span class="hljs-built_in">sort</span>(d.<span class="hljs-built_in">begin</span>(), d.<span class="hljs-built_in">end</span>());    <span class="hljs-built_in">printDeque</span>(d); } <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>{     <span class="hljs-built_in">test01</span>();     <span class="hljs-built_in">system</span>(<span class="hljs-string">"pause"</span>);     <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;}</code></pre></div><p>总结：sort算法非常实用，使用时包含头文件 algorithm即可</p><h3><span id="3-4-an-li-ping-wei-da-fen">3.4 案例-评委打分</span><a href="#3-4-an-li-ping-wei-da-fen" class="header-anchor">#</a></h3><h4><span id="3-4-1-an-li-miao-shu">3.4.1 案例描述</span><a href="#3-4-1-an-li-miao-shu" class="header-anchor">#</a></h4><p>有5名选手：选手ABCDE，10个评委分别对每一名选手打分，去除最高分，去除评委中最低分，取平均分。</p><h4><span id="3-4-2-shi-xian-bu-zou">3.4.2 实现步骤</span><a href="#3-4-2-shi-xian-bu-zou" class="header-anchor">#</a></h4><ol><li>创建五名选手，放到vector中</li><li>遍历vector容器，取出来每一个选手，执行for循环，可以把10个评分打分存到deque容器中</li><li>sort算法对deque容器中分数排序，去除最高和最低分</li><li>deque容器遍历一遍，累加总分</li><li>获取平均分</li></ol><p><strong>示例代码：</strong></p><div class="code-wrapper"><pre><code class="hljs C++"><span class="hljs-comment">//选手类</span><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span>{<span class="hljs-keyword">public</span>:    <span class="hljs-built_in">Person</span>(string name, <span class="hljs-type">int</span> score)    {        <span class="hljs-keyword">this</span>-&gt;m_Name = name;        <span class="hljs-keyword">this</span>-&gt;m_Score = score;    }     string m_Name; <span class="hljs-comment">//姓名</span>    <span class="hljs-type">int</span> m_Score;  <span class="hljs-comment">//平均分</span>}; <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">createPerson</span><span class="hljs-params">(vector&lt;Person&gt;&amp;v)</span></span><span class="hljs-function"></span>{    string nameSeed = <span class="hljs-string">"ABCDE"</span>;    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5</span>; i++)    {        string name = <span class="hljs-string">"选手"</span>;        name += nameSeed[i];         <span class="hljs-type">int</span> score = <span class="hljs-number">0</span>;         <span class="hljs-function">Person <span class="hljs-title">p</span><span class="hljs-params">(name, score)</span></span>;         <span class="hljs-comment">//将创建的person对象 放入到容器中</span>        v.<span class="hljs-built_in">push_back</span>(p);    }} <span class="hljs-comment">//打分</span><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">setScore</span><span class="hljs-params">(vector&lt;Person&gt;&amp;v)</span></span><span class="hljs-function"></span>{    <span class="hljs-keyword">for</span> (vector&lt;Person&gt;::iterator it = v.<span class="hljs-built_in">begin</span>(); it != v.<span class="hljs-built_in">end</span>(); it++)    {        <span class="hljs-comment">//将评委的分数 放入到deque容器中</span>        deque&lt;<span class="hljs-type">int</span>&gt;d;        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++)        {            <span class="hljs-type">int</span> score = <span class="hljs-built_in">rand</span>() % <span class="hljs-number">41</span> + <span class="hljs-number">60</span>;  <span class="hljs-comment">// 60 ~ 100</span>            d.<span class="hljs-built_in">push_back</span>(score);        }         <span class="hljs-comment">//cout &lt;&lt; "选手： " &lt;&lt; it-&gt;m_Name &lt;&lt; " 打分： " &lt;&lt; endl;</span>        <span class="hljs-comment">//for (deque&lt;int&gt;::iterator dit = d.begin(); dit != d.end(); dit++)</span>        <span class="hljs-comment">//{</span>        <span class="hljs-comment">//    cout &lt;&lt; *dit &lt;&lt; " ";</span>        <span class="hljs-comment">//}</span>        <span class="hljs-comment">//cout &lt;&lt; endl;</span>         <span class="hljs-comment">//排序</span>        <span class="hljs-built_in">sort</span>(d.<span class="hljs-built_in">begin</span>(), d.<span class="hljs-built_in">end</span>());         <span class="hljs-comment">//去除最高和最低分</span>        d.<span class="hljs-built_in">pop_back</span>();        d.<span class="hljs-built_in">pop_front</span>();         <span class="hljs-comment">//取平均分</span>        <span class="hljs-type">int</span> sum = <span class="hljs-number">0</span>;        <span class="hljs-keyword">for</span> (deque&lt;<span class="hljs-type">int</span>&gt;::iterator dit = d.<span class="hljs-built_in">begin</span>(); dit != d.<span class="hljs-built_in">end</span>(); dit++)        {            sum += *dit; <span class="hljs-comment">//累加每个评委的分数</span>        }         <span class="hljs-type">int</span> avg = sum / d.<span class="hljs-built_in">size</span>();         <span class="hljs-comment">//将平均分 赋值给选手身上</span>        it-&gt;m_Score = avg;    } } <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">showScore</span><span class="hljs-params">(vector&lt;Person&gt;&amp;v)</span></span><span class="hljs-function"></span>{    <span class="hljs-keyword">for</span> (vector&lt;Person&gt;::iterator it = v.<span class="hljs-built_in">begin</span>(); it != v.<span class="hljs-built_in">end</span>(); it++)    {        cout &lt;&lt; <span class="hljs-string">"姓名： "</span> &lt;&lt; it-&gt;m_Name &lt;&lt; <span class="hljs-string">" 平均分： "</span> &lt;&lt; it-&gt;m_Score &lt;&lt; endl;    }} <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>{     <span class="hljs-comment">//随机数种子</span>    <span class="hljs-built_in">srand</span>((<span class="hljs-type">unsigned</span> <span class="hljs-type">int</span>)<span class="hljs-built_in">time</span>(<span class="hljs-literal">NULL</span>));     <span class="hljs-comment">//1、创建5名选手</span>    vector&lt;Person&gt;v;  <span class="hljs-comment">//存放选手容器</span>    <span class="hljs-built_in">createPerson</span>(v);     <span class="hljs-comment">//测试</span>    <span class="hljs-comment">//for (vector&lt;Person&gt;::iterator it = v.begin(); it != v.end(); it++)</span>    <span class="hljs-comment">//{</span>    <span class="hljs-comment">//    cout &lt;&lt; "姓名： " &lt;&lt; (*it).m_Name &lt;&lt; " 分数： " &lt;&lt; (*it).m_Score &lt;&lt; endl;</span>    <span class="hljs-comment">//}</span>     <span class="hljs-comment">//2、给5名选手打分</span>    <span class="hljs-built_in">setScore</span>(v);     <span class="hljs-comment">//3、显示最后得分</span>    <span class="hljs-built_in">showScore</span>(v);     <span class="hljs-built_in">system</span>(<span class="hljs-string">"pause"</span>);     <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;}</code></pre></div><p><strong>总结：</strong> 选取不同的容器操作数据，可以提升代码的效率</p><h3><span id="3-5-stack-rong-qi">3.5 stack容器</span><a href="#3-5-stack-rong-qi" class="header-anchor">#</a></h3><h4><span id="3-5-1-stack-ji-ben-gai-nian">3.5.1 stack 基本概念</span><a href="#3-5-1-stack-ji-ben-gai-nian" class="header-anchor">#</a></h4><p><strong>概念：</strong>stack是一种<strong>先进后出</strong>(First In Last Out,FILO)的数据结构，它只有一个出口</p><p><img src="http://192.168.1.105:8082/wp-content/uploads/2021/08/clip_image002-1547604555425-54a4443b79cd4f9ca5fde8c8f870e09c.jpg" alt="clip_image002-1547604555425"></p><p>栈中只有顶端的元素才可以被外界使用，因此栈不允许有遍历行为</p><p>栈中进入数据称为 — <strong>入栈</strong> <code>push</code></p><p>栈中弹出数据称为 — <strong>出栈</strong> <code>pop</code></p><h4><span id="3-5-2-stack-chang-yong-jie-kou">3.5.2 stack 常用接口</span><a href="#3-5-2-stack-chang-yong-jie-kou" class="header-anchor">#</a></h4><p>功能描述：栈容器常用的对外接口</p><p>构造函数：</p><ul><li><code>stack stk;</code> //stack采用模板类实现， stack对象的默认构造形式</li><li><code>stack(const stack &amp;stk);</code> //拷贝构造函数</li></ul><p>赋值操作：</p><ul><li><code>stack&amp; operator=(const stack &amp;stk);</code> //重载等号操作符</li></ul><p>数据存取：</p><ul><li><code>push(elem);</code> //向栈顶添加元素</li><li><code>pop();</code> //从栈顶移除第一个元素</li><li><code>top(); </code>//返回栈顶元素</li></ul><p>大小操作：</p><ul><li><code>empty();</code> //判断堆栈是否为空</li><li><code>size(); </code>//返回栈的大小</li></ul><p><strong>示例：</strong></p><div class="code-wrapper"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stack&gt;</span></span> <span class="hljs-comment">//栈容器常用接口</span><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test01</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>{    <span class="hljs-comment">//创建栈容器 栈容器必须符合先进后出</span>    stack&lt;<span class="hljs-type">int</span>&gt; s;     <span class="hljs-comment">//向栈中添加元素，叫做 压栈 入栈</span>    s.<span class="hljs-built_in">push</span>(<span class="hljs-number">10</span>);    s.<span class="hljs-built_in">push</span>(<span class="hljs-number">20</span>);    s.<span class="hljs-built_in">push</span>(<span class="hljs-number">30</span>);     <span class="hljs-keyword">while</span> (!s.<span class="hljs-built_in">empty</span>()) {        <span class="hljs-comment">//输出栈顶元素</span>        cout &lt;&lt; <span class="hljs-string">"栈顶元素为： "</span> &lt;&lt; s.<span class="hljs-built_in">top</span>() &lt;&lt; endl;        <span class="hljs-comment">//弹出栈顶元素</span>        s.<span class="hljs-built_in">pop</span>();    }    cout &lt;&lt; <span class="hljs-string">"栈的大小为："</span> &lt;&lt; s.<span class="hljs-built_in">size</span>() &lt;&lt; endl; } <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>{     <span class="hljs-built_in">test01</span>();     <span class="hljs-built_in">system</span>(<span class="hljs-string">"pause"</span>);     <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;}</code></pre></div><p>总结：</p><ul><li>入栈 — push</li><li>出栈 — pop</li><li>返回栈顶 — top</li><li>判断栈是否为空 — empty</li><li>返回栈大小 — size</li></ul><h3><span id="3-6-queue-rong-qi">3.6 queue 容器</span><a href="#3-6-queue-rong-qi" class="header-anchor">#</a></h3><h4><span id="3-6-1-queue-ji-ben-gai-nian">3.6.1 queue 基本概念</span><a href="#3-6-1-queue-ji-ben-gai-nian" class="header-anchor">#</a></h4><p><strong>概念：</strong>Queue是一种<strong>先进先出</strong>(First In First Out,FIFO)的数据结构，它有两个出口</p><p><img src="https://gitee.com/txt1994/images/raw/master/img/2021/08/clip_image002-1547606475892-451e2844b00246ab87797f7996d13f59.jpg" alt="clip_image002-1547606475892"></p><p>队列容器允许从一端新增元素，从另一端移除元素</p><p>队列中只有队头和队尾才可以被外界使用，因此队列不允许有遍历行为</p><p>队列中进数据称为 — <strong>入队</strong> <code>push</code></p><p>队列中出数据称为 — <strong>出队</strong> <code>pop</code></p><h4><span id="3-6-2-queue-chang-yong-jie-kou">3.6.2 queue 常用接口</span><a href="#3-6-2-queue-chang-yong-jie-kou" class="header-anchor">#</a></h4><p>功能描述：栈容器常用的对外接口</p><p>构造函数：</p><ul><li><code>queue que;</code> //queue采用模板类实现，queue对象的默认构造形式</li><li><code>queue(const queue &amp;que);</code> //拷贝构造函数</li></ul><p>赋值操作：</p><ul><li><code>queue&amp; operator=(const queue &amp;que);</code> //重载等号操作符</li></ul><p>数据存取：</p><ul><li><code>push(elem);</code> //往队尾添加元素</li><li><code>pop();</code> //从队头移除第一个元素</li><li><code>back();</code> //返回最后一个元素</li><li><code>front(); </code>//返回第一个元素</li></ul><p>大小操作：</p><ul><li><code>empty();</code> //判断堆栈是否为空</li><li><code>size(); </code>//返回栈的大小</li></ul><p><strong>示例：</strong></p><div class="code-wrapper"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;queue&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span>{<span class="hljs-keyword">public</span>:    <span class="hljs-built_in">Person</span>(string name, <span class="hljs-type">int</span> age)    {        <span class="hljs-keyword">this</span>-&gt;m_Name = name;        <span class="hljs-keyword">this</span>-&gt;m_Age = age;    }     string m_Name;    <span class="hljs-type">int</span> m_Age;}; <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test01</span><span class="hljs-params">()</span> </span>{     <span class="hljs-comment">//创建队列</span>    queue&lt;Person&gt; q;     <span class="hljs-comment">//准备数据</span>    <span class="hljs-function">Person <span class="hljs-title">p1</span><span class="hljs-params">(<span class="hljs-string">"唐僧"</span>, <span class="hljs-number">30</span>)</span></span>;    <span class="hljs-function">Person <span class="hljs-title">p2</span><span class="hljs-params">(<span class="hljs-string">"孙悟空"</span>, <span class="hljs-number">1000</span>)</span></span>;    <span class="hljs-function">Person <span class="hljs-title">p3</span><span class="hljs-params">(<span class="hljs-string">"猪八戒"</span>, <span class="hljs-number">900</span>)</span></span>;    <span class="hljs-function">Person <span class="hljs-title">p4</span><span class="hljs-params">(<span class="hljs-string">"沙僧"</span>, <span class="hljs-number">800</span>)</span></span>;     <span class="hljs-comment">//向队列中添加元素  入队操作</span>    q.<span class="hljs-built_in">push</span>(p1);    q.<span class="hljs-built_in">push</span>(p2);    q.<span class="hljs-built_in">push</span>(p3);    q.<span class="hljs-built_in">push</span>(p4);     <span class="hljs-comment">//队列不提供迭代器，更不支持随机访问    </span>    <span class="hljs-keyword">while</span> (!q.<span class="hljs-built_in">empty</span>()) {        <span class="hljs-comment">//输出队头元素</span>        cout &lt;&lt; <span class="hljs-string">"队头元素-- 姓名： "</span> &lt;&lt; q.<span class="hljs-built_in">front</span>().m_Name               &lt;&lt; <span class="hljs-string">" 年龄： "</span>&lt;&lt; q.<span class="hljs-built_in">front</span>().m_Age &lt;&lt; endl;                cout &lt;&lt; <span class="hljs-string">"队尾元素-- 姓名： "</span> &lt;&lt; q.<span class="hljs-built_in">back</span>().m_Name                &lt;&lt; <span class="hljs-string">" 年龄： "</span> &lt;&lt; q.<span class="hljs-built_in">back</span>().m_Age &lt;&lt; endl;                cout &lt;&lt; endl;        <span class="hljs-comment">//弹出队头元素</span>        q.<span class="hljs-built_in">pop</span>();    }     cout &lt;&lt; <span class="hljs-string">"队列大小为："</span> &lt;&lt; q.<span class="hljs-built_in">size</span>() &lt;&lt; endl;} <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>{     <span class="hljs-built_in">test01</span>();     <span class="hljs-built_in">system</span>(<span class="hljs-string">"pause"</span>);     <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;}</code></pre></div><p>总结：</p><ul><li>入队 — push</li><li>出队 — pop</li><li>返回队头元素 — front</li><li>返回队尾元素 — back</li><li>判断队是否为空 — empty</li><li>返回队列大小 — size</li></ul><h3><span id="3-7-list-rong-qi">3.7 list容器</span><a href="#3-7-list-rong-qi" class="header-anchor">#</a></h3><h4><span id="3-7-1-list-ji-ben-gai-nian">3.7.1 list基本概念</span><a href="#3-7-1-list-ji-ben-gai-nian" class="header-anchor">#</a></h4><p><strong>功能：</strong>将数据进行链式存储</p><p><strong>链表</strong>（list）是一种物理存储单元上非连续的存储结构，数据元素的逻辑顺序是通过链表中的指针链接实现的</p><p>链表的组成：链表由一系列<strong>结点</strong>组成</p><p>结点的组成：一个是存储数据元素的<strong>数据域</strong>，另一个是存储下一个结点地址的<strong>指针域</strong></p><p>STL中的链表是一个双向循环链表</p><p><img src="https://gitee.com/txt1994/images/raw/master/img/2021/08/clip_image002-1547608564071-ae8640f75c264b0b8994e8c3f3aa76dc.jpg" alt="clip_image002-1547608564071"></p><p>由于链表的存储方式并不是连续的内存空间，因此链表list中的迭代器只支持前移和后移，属于<strong>双向迭代器</strong></p><p>list的优点：</p><ul><li>采用动态存储分配，不会造成内存浪费和溢出</li><li>链表执行插入和删除操作十分方便，修改指针即可，不需要移动大量元素</li></ul><p>list的缺点：</p><ul><li>链表灵活，但是空间(指针域) 和 时间（遍历）额外耗费较大</li></ul><p>List有一个重要的性质，插入操作和删除操作都不会造成原有list迭代器的失效，这在vector是不成立的。</p><p>总结：STL中<strong>List和vector是两个最常被使用的容器</strong>，各有优缺点</p><h4><span id="3-7-2-list-gou-zao-han-shu">3.7.2 list构造函数</span><a href="#3-7-2-list-gou-zao-han-shu" class="header-anchor">#</a></h4><p><strong>功能描述：</strong></p><ul><li>创建list容器</li></ul><p><strong>函数原型：</strong></p><ul><li><code>list lst;</code> //list采用采用模板类实现,对象的默认构造形式：</li><li><code>list(beg,end);</code> //构造函数将[beg, end)区间中的元素拷贝给本身。</li><li><code>list(n,elem);</code> //构造函数将n个elem拷贝给本身。</li><li><code>list(const list &amp;lst);</code> //拷贝构造函数。</li></ul><p><strong>示例：</strong></p><div class="code-wrapper"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;list&gt;</span></span> <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">printList</span><span class="hljs-params">(<span class="hljs-type">const</span> list&lt;<span class="hljs-type">int</span>&gt;&amp; L)</span> </span>{     <span class="hljs-keyword">for</span> (list&lt;<span class="hljs-type">int</span>&gt;::const_iterator it = L.<span class="hljs-built_in">begin</span>(); it != L.<span class="hljs-built_in">end</span>(); it++) {        cout &lt;&lt; *it &lt;&lt; <span class="hljs-string">" "</span>;    }    cout &lt;&lt; endl;} <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test01</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>{    list&lt;<span class="hljs-type">int</span>&gt;L1;    L1.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">10</span>);    L1.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">20</span>);    L1.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">30</span>);    L1.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">40</span>);     <span class="hljs-built_in">printList</span>(L1);     list&lt;<span class="hljs-type">int</span>&gt;<span class="hljs-built_in">L2</span>(L1.<span class="hljs-built_in">begin</span>(),L1.<span class="hljs-built_in">end</span>());    <span class="hljs-built_in">printList</span>(L2);     list&lt;<span class="hljs-type">int</span>&gt;<span class="hljs-built_in">L3</span>(L2);    <span class="hljs-built_in">printList</span>(L3);     list&lt;<span class="hljs-type">int</span>&gt;<span class="hljs-built_in">L4</span>(<span class="hljs-number">10</span>, <span class="hljs-number">1000</span>);    <span class="hljs-built_in">printList</span>(L4);} <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>{     <span class="hljs-built_in">test01</span>();     <span class="hljs-built_in">system</span>(<span class="hljs-string">"pause"</span>);     <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;}</code></pre></div><p>总结：list构造方式同其他几个STL常用容器，熟练掌握即可</p><h4><span id="3-7-3-list-fu-zhi-he-jiao-huan">3.7.3 list 赋值和交换</span><a href="#3-7-3-list-fu-zhi-he-jiao-huan" class="header-anchor">#</a></h4><p><strong>功能描述：</strong></p><ul><li>给list容器进行赋值，以及交换list容器</li></ul><p><strong>函数原型：</strong></p><ul><li><code>assign(beg, end);</code> //将[beg, end)区间中的数据拷贝赋值给本身。</li><li><code>assign(n, elem);</code> //将n个elem拷贝赋值给本身。</li><li><code>list&amp; operator=(const list &amp;lst);</code> //重载等号操作符</li><li><code>swap(lst);</code> //将lst与本身的元素互换。</li></ul><p><strong>示例：</strong></p><div class="code-wrapper"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;list&gt;</span></span> <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">printList</span><span class="hljs-params">(<span class="hljs-type">const</span> list&lt;<span class="hljs-type">int</span>&gt;&amp; L)</span> </span>{     <span class="hljs-keyword">for</span> (list&lt;<span class="hljs-type">int</span>&gt;::const_iterator it = L.<span class="hljs-built_in">begin</span>(); it != L.<span class="hljs-built_in">end</span>(); it++) {        cout &lt;&lt; *it &lt;&lt; <span class="hljs-string">" "</span>;    }    cout &lt;&lt; endl;} <span class="hljs-comment">//赋值和交换</span><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test01</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>{    list&lt;<span class="hljs-type">int</span>&gt;L1;    L1.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">10</span>);    L1.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">20</span>);    L1.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">30</span>);    L1.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">40</span>);    <span class="hljs-built_in">printList</span>(L1);     <span class="hljs-comment">//赋值</span>    list&lt;<span class="hljs-type">int</span>&gt;L2;    L2 = L1;    <span class="hljs-built_in">printList</span>(L2);     list&lt;<span class="hljs-type">int</span>&gt;L3;    L3.<span class="hljs-built_in">assign</span>(L2.<span class="hljs-built_in">begin</span>(), L2.<span class="hljs-built_in">end</span>());    <span class="hljs-built_in">printList</span>(L3);     list&lt;<span class="hljs-type">int</span>&gt;L4;    L4.<span class="hljs-built_in">assign</span>(<span class="hljs-number">10</span>, <span class="hljs-number">100</span>);    <span class="hljs-built_in">printList</span>(L4); } <span class="hljs-comment">//交换</span><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test02</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>{     list&lt;<span class="hljs-type">int</span>&gt;L1;    L1.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">10</span>);    L1.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">20</span>);    L1.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">30</span>);    L1.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">40</span>);     list&lt;<span class="hljs-type">int</span>&gt;L2;    L2.<span class="hljs-built_in">assign</span>(<span class="hljs-number">10</span>, <span class="hljs-number">100</span>);     cout &lt;&lt; <span class="hljs-string">"交换前： "</span> &lt;&lt; endl;    <span class="hljs-built_in">printList</span>(L1);    <span class="hljs-built_in">printList</span>(L2);     cout &lt;&lt; endl;     L1.<span class="hljs-built_in">swap</span>(L2);     cout &lt;&lt; <span class="hljs-string">"交换后： "</span> &lt;&lt; endl;    <span class="hljs-built_in">printList</span>(L1);    <span class="hljs-built_in">printList</span>(L2); } <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>{     <span class="hljs-comment">//test01();</span>     <span class="hljs-built_in">test02</span>();     <span class="hljs-built_in">system</span>(<span class="hljs-string">"pause"</span>);     <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;}</code></pre></div><p>总结：list赋值和交换操作能够灵活运用即可</p><h4><span id="3-7-4-list-da-xiao-cao-zuo">3.7.4 list 大小操作</span><a href="#3-7-4-list-da-xiao-cao-zuo" class="header-anchor">#</a></h4><p><strong>功能描述：</strong></p><ul><li>对list容器的大小进行操作</li></ul><p><strong>函数原型：</strong></p><ul><li><p><code>size(); </code>//返回容器中元素的个数</p></li><li><p><code>empty(); </code>//判断容器是否为空</p></li><li><p><code>resize(num);</code> //重新指定容器的长度为num，若容器变长，则以默认值填充新位置。</p><p> //如果容器变短，则末尾超出容器长度的元素被删除。</p></li><li><p><code>resize(num, elem); </code>//重新指定容器的长度为num，若容器变长，则以elem值填充新位置。</p><div class="code-wrapper"><pre><code class="hljs awk"><span class="hljs-regexp">//</span>如果容器变短，则末尾超出容器长度的元素被删除。</code></pre></div></li></ul><p><strong>示例：</strong></p><div class="code-wrapper"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;list&gt;</span></span> <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">printList</span><span class="hljs-params">(<span class="hljs-type">const</span> list&lt;<span class="hljs-type">int</span>&gt;&amp; L)</span> </span>{     <span class="hljs-keyword">for</span> (list&lt;<span class="hljs-type">int</span>&gt;::const_iterator it = L.<span class="hljs-built_in">begin</span>(); it != L.<span class="hljs-built_in">end</span>(); it++) {        cout &lt;&lt; *it &lt;&lt; <span class="hljs-string">" "</span>;    }    cout &lt;&lt; endl;} <span class="hljs-comment">//大小操作</span><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test01</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>{    list&lt;<span class="hljs-type">int</span>&gt;L1;    L1.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">10</span>);    L1.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">20</span>);    L1.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">30</span>);    L1.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">40</span>);     <span class="hljs-keyword">if</span> (L1.<span class="hljs-built_in">empty</span>())    {        cout &lt;&lt; <span class="hljs-string">"L1为空"</span> &lt;&lt; endl;    }    <span class="hljs-keyword">else</span>    {        cout &lt;&lt; <span class="hljs-string">"L1不为空"</span> &lt;&lt; endl;        cout &lt;&lt; <span class="hljs-string">"L1的大小为： "</span> &lt;&lt; L1.<span class="hljs-built_in">size</span>() &lt;&lt; endl;    }     <span class="hljs-comment">//重新指定大小</span>    L1.<span class="hljs-built_in">resize</span>(<span class="hljs-number">10</span>);    <span class="hljs-built_in">printList</span>(L1);     L1.<span class="hljs-built_in">resize</span>(<span class="hljs-number">2</span>);    <span class="hljs-built_in">printList</span>(L1);} <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>{     <span class="hljs-built_in">test01</span>();     <span class="hljs-built_in">system</span>(<span class="hljs-string">"pause"</span>);     <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;}</code></pre></div><p>总结：</p><ul><li>判断是否为空 — empty</li><li>返回元素个数 — size</li><li>重新指定个数 — resize</li></ul><h4><span id="3-7-5-list-cha-ru-he-shan-chu">3.7.5 list 插入和删除</span><a href="#3-7-5-list-cha-ru-he-shan-chu" class="header-anchor">#</a></h4><p><strong>功能描述：</strong></p><ul><li>对list容器进行数据的插入和删除</li></ul><p><strong>函数原型：</strong></p><ul><li>push_back(elem);//在容器尾部加入一个元素</li><li>pop_back();//删除容器中最后一个元素</li><li>push_front(elem);//在容器开头插入一个元素</li><li>pop_front();//从容器开头移除第一个元素</li><li>insert(pos,elem);//在pos位置插elem元素的拷贝，返回新数据的位置。</li><li>insert(pos,n,elem);//在pos位置插入n个elem数据，无返回值。</li><li>insert(pos,beg,end);//在pos位置插入[beg,end)区间的数据，无返回值。</li><li>clear();//移除容器的所有数据</li><li>erase(beg,end);//删除[beg,end)区间的数据，返回下一个数据的位置。</li><li>erase(pos);//删除pos位置的数据，返回下一个数据的位置。</li><li>remove(elem);//删除容器中所有与elem值匹配的元素。</li></ul><p><strong>示例：</strong></p><div class="code-wrapper"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;list&gt;</span></span> <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">printList</span><span class="hljs-params">(<span class="hljs-type">const</span> list&lt;<span class="hljs-type">int</span>&gt;&amp; L)</span> </span>{     <span class="hljs-keyword">for</span> (<span class="hljs-type">const</span> <span class="hljs-keyword">auto</span>&amp;it : L) {        std::cout &lt;&lt; it &lt;&lt; <span class="hljs-string">" "</span>;    }    cout &lt;&lt; endl;} <span class="hljs-comment">//插入和删除</span><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test01</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>{    list&lt;<span class="hljs-type">int</span>&gt; L;    <span class="hljs-comment">//尾插</span>    L.<span class="hljs-built_in">emplace_back</span>(<span class="hljs-number">10</span>);    L.<span class="hljs-built_in">emplace_back</span>(<span class="hljs-number">20</span>);    L.<span class="hljs-built_in">emplace_back</span>(<span class="hljs-number">30</span>);    <span class="hljs-comment">//头插</span>    L.<span class="hljs-built_in">emplace_front</span>(<span class="hljs-number">100</span>);    L.<span class="hljs-built_in">emplace_front</span>(<span class="hljs-number">200</span>);    L.<span class="hljs-built_in">emplace_front</span>(<span class="hljs-number">300</span>);     <span class="hljs-built_in">printList</span>(L);     <span class="hljs-comment">//尾删</span>    L.<span class="hljs-built_in">pop_back</span>();    <span class="hljs-built_in">printList</span>(L);     <span class="hljs-comment">//头删</span>    L.<span class="hljs-built_in">pop_front</span>();    <span class="hljs-built_in">printList</span>(L);     <span class="hljs-comment">//插入</span>    list&lt;<span class="hljs-type">int</span>&gt;::iterator it = L.<span class="hljs-built_in">begin</span>();    L.<span class="hljs-built_in">insert</span>(++it, <span class="hljs-number">1000</span>);    <span class="hljs-built_in">printList</span>(L);     <span class="hljs-comment">//删除</span>    it = L.<span class="hljs-built_in">begin</span>();    L.<span class="hljs-built_in">erase</span>(++it);    <span class="hljs-built_in">printList</span>(L);     <span class="hljs-comment">//移除</span>    L.<span class="hljs-built_in">pop_back</span>();    L.<span class="hljs-built_in">pop_back</span>();    L.<span class="hljs-built_in">pop_back</span>();    <span class="hljs-built_in">printList</span>(L);    L.<span class="hljs-built_in">remove</span>(<span class="hljs-number">10000</span>);    <span class="hljs-built_in">printList</span>(L);        <span class="hljs-comment">//清空</span>    L.<span class="hljs-built_in">clear</span>();    <span class="hljs-built_in">printList</span>(L);} <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>{     <span class="hljs-built_in">test01</span>();     <span class="hljs-built_in">system</span>(<span class="hljs-string">"pause"</span>);     <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;}</code></pre></div><p>总结：</p><ul><li>尾插 — push_back</li><li>尾部原位创造 — emplace_back</li><li>尾删 — pop_back</li><li>头插 — push_front</li><li>头删 — pop_front</li><li>插入 — insert</li><li>删除 — erase</li><li>移除 — remove</li><li>清空 — clear</li></ul><h4><span id="3-7-6-list-shu-ju-cun-qu">3.7.6 list 数据存取</span><a href="#3-7-6-list-shu-ju-cun-qu" class="header-anchor">#</a></h4><p><strong>功能描述：</strong></p><ul><li>对list容器中数据进行存取</li></ul><p><strong>函数原型：</strong></p><ul><li><code>front();</code> //返回第一个元素。</li><li><code>back();</code> //返回最后一个元素。</li></ul><p><strong>示例：</strong></p><div class="code-wrapper"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;list&gt;</span></span> <span class="hljs-comment">//数据存取</span><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test01</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>{    list&lt;<span class="hljs-type">int</span>&gt;L1;    L1.<span class="hljs-built_in">emplace_back</span>(<span class="hljs-number">10</span>);    L1.<span class="hljs-built_in">emplace_back</span>(<span class="hljs-number">20</span>);    L1.<span class="hljs-built_in">emplace_back</span>(<span class="hljs-number">30</span>);    L1.<span class="hljs-built_in">emplace_back</span>(<span class="hljs-number">40</span>);         <span class="hljs-comment">//cout &lt;&lt; L1.at(0) &lt;&lt; endl;//错误 不支持at访问数据</span>    <span class="hljs-comment">//cout &lt;&lt; L1[0] &lt;&lt; endl; //错误  不支持[]方式访问数据</span>    cout &lt;&lt; <span class="hljs-string">"第一个元素为： "</span> &lt;&lt; L1.<span class="hljs-built_in">front</span>() &lt;&lt; endl;    cout &lt;&lt; <span class="hljs-string">"最后一个元素为： "</span> &lt;&lt; L1.<span class="hljs-built_in">back</span>() &lt;&lt; endl;     <span class="hljs-comment">//list容器的迭代器是双向迭代器，不支持随机访问</span>    list&lt;<span class="hljs-type">int</span>&gt;::iterator it = L1.<span class="hljs-built_in">begin</span>();    <span class="hljs-comment">//it = it + 1;//错误，不可以跳跃访问，即使是+1</span>} <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>{     <span class="hljs-built_in">test01</span>();     <span class="hljs-built_in">system</span>(<span class="hljs-string">"pause"</span>);     <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;}</code></pre></div><p>总结：</p><ul><li>list容器中不可以通过[]或者at方式访问数据</li><li>返回第一个元素 — front</li><li>返回最后一个元素 — back</li></ul><h4><span id="3-7-7-list-fan-zhuan-he-pai-xu">3.7.7 list 反转和排序</span><a href="#3-7-7-list-fan-zhuan-he-pai-xu" class="header-anchor">#</a></h4><p><strong>功能描述：</strong></p><ul><li>将容器中的元素反转，以及将容器中的数据进行排序</li></ul><p><strong>函数原型：</strong></p><ul><li><code>reverse();</code> //反转链表</li><li><code>sort();</code> //链表排序</li></ul><p><strong>示例：</strong></p><div class="code-wrapper"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">printList</span><span class="hljs-params">(<span class="hljs-type">const</span> list&lt;<span class="hljs-type">int</span>&gt;&amp; L)</span> </span>{     <span class="hljs-keyword">for</span> (list&lt;<span class="hljs-type">int</span>&gt;::const_iterator it = L.<span class="hljs-built_in">begin</span>(); it != L.<span class="hljs-built_in">end</span>(); it++) {        cout &lt;&lt; *it &lt;&lt; <span class="hljs-string">" "</span>;    }    cout &lt;&lt; endl;} <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">myCompare</span><span class="hljs-params">(<span class="hljs-type">int</span> val1 , <span class="hljs-type">int</span> val2)</span></span><span class="hljs-function"></span>{    <span class="hljs-keyword">return</span> val1 &gt; val2;} <span class="hljs-comment">//反转和排序</span><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test01</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>{    list&lt;<span class="hljs-type">int</span>&gt; L;    L.<span class="hljs-built_in">emplace_back</span>(<span class="hljs-number">90</span>);    L.<span class="hljs-built_in">emplace_back</span>(<span class="hljs-number">30</span>);    L.<span class="hljs-built_in">emplace_back</span>(<span class="hljs-number">20</span>);    L.<span class="hljs-built_in">emplace_back</span>(<span class="hljs-number">70</span>);    <span class="hljs-built_in">printList</span>(L);     <span class="hljs-comment">//反转容器的元素</span>    L.<span class="hljs-built_in">reverse</span>();    <span class="hljs-built_in">printList</span>(L);     <span class="hljs-comment">//排序</span>    L.<span class="hljs-built_in">sort</span>(); <span class="hljs-comment">//默认的排序规则 从小到大</span>    <span class="hljs-built_in">printList</span>(L);     L.<span class="hljs-built_in">sort</span>(myCompare); <span class="hljs-comment">//指定规则，从大到小</span>    <span class="hljs-built_in">printList</span>(L);} <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>{     <span class="hljs-built_in">test01</span>();     <span class="hljs-built_in">system</span>(<span class="hljs-string">"pause"</span>);     <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;}</code></pre></div><p>总结：</p><ul><li>反转 — reverse</li><li>排序 — sort （成员函数）</li></ul><h4><span id="3-7-8-pai-xu-an-li">3.7.8 排序案例</span><a href="#3-7-8-pai-xu-an-li" class="header-anchor">#</a></h4><p>案例描述：将Person自定义数据类型进行排序，Person中属性有姓名、年龄、身高</p><p>排序规则：按照年龄进行升序，如果年龄相同按照身高进行降序</p><p><strong>示例：</strong></p><div class="code-wrapper"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;list&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span> {<span class="hljs-keyword">public</span>:    <span class="hljs-built_in">Person</span>(string name, <span class="hljs-type">int</span> age , <span class="hljs-type">int</span> height) {        m_Name = name;        m_Age = age;        m_Height = height;    } <span class="hljs-keyword">public</span>:    string m_Name;  <span class="hljs-comment">//姓名</span>    <span class="hljs-type">int</span> m_Age;      <span class="hljs-comment">//年龄</span>    <span class="hljs-type">int</span> m_Height;   <span class="hljs-comment">//身高</span>};  <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">ComparePerson</span><span class="hljs-params">(Person&amp; p1, Person&amp; p2)</span> </span>{     <span class="hljs-keyword">if</span> (p1.m_Age == p2.m_Age) {        <span class="hljs-keyword">return</span> p1.m_Height  &gt; p2.m_Height;    }    <span class="hljs-keyword">else</span>    {        <span class="hljs-keyword">return</span>  p1.m_Age &lt; p2.m_Age;    } } <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test01</span><span class="hljs-params">()</span> </span>{     list&lt;Person&gt; L;     <span class="hljs-function">Person <span class="hljs-title">p1</span><span class="hljs-params">(<span class="hljs-string">"刘备"</span>, <span class="hljs-number">35</span> , <span class="hljs-number">175</span>)</span></span>;    <span class="hljs-function">Person <span class="hljs-title">p2</span><span class="hljs-params">(<span class="hljs-string">"曹操"</span>, <span class="hljs-number">45</span> , <span class="hljs-number">180</span>)</span></span>;    <span class="hljs-function">Person <span class="hljs-title">p3</span><span class="hljs-params">(<span class="hljs-string">"孙权"</span>, <span class="hljs-number">40</span> , <span class="hljs-number">170</span>)</span></span>;    <span class="hljs-function">Person <span class="hljs-title">p4</span><span class="hljs-params">(<span class="hljs-string">"赵云"</span>, <span class="hljs-number">25</span> , <span class="hljs-number">190</span>)</span></span>;    <span class="hljs-function">Person <span class="hljs-title">p5</span><span class="hljs-params">(<span class="hljs-string">"张飞"</span>, <span class="hljs-number">35</span> , <span class="hljs-number">160</span>)</span></span>;    <span class="hljs-function">Person <span class="hljs-title">p6</span><span class="hljs-params">(<span class="hljs-string">"关羽"</span>, <span class="hljs-number">35</span> , <span class="hljs-number">200</span>)</span></span>;     L.<span class="hljs-built_in">emplace_back</span>(<span class="hljs-built_in">move</span>(p1));    L.<span class="hljs-built_in">emplace_back</span>(<span class="hljs-built_in">move</span>(p2));    L.<span class="hljs-built_in">emplace_back</span>(<span class="hljs-built_in">move</span>(p3));    L.<span class="hljs-built_in">emplace_back</span>(<span class="hljs-built_in">move</span>(p4));    L.<span class="hljs-built_in">emplace_back</span>(<span class="hljs-built_in">move</span>(p5));    L.<span class="hljs-built_in">emplace_back</span>(<span class="hljs-built_in">move</span>(p6));     <span class="hljs-keyword">for</span> (list&lt;Person&gt;::iterator it = L.<span class="hljs-built_in">begin</span>(); it != L.<span class="hljs-built_in">end</span>(); it++) {        cout &lt;&lt; <span class="hljs-string">"姓名： "</span> &lt;&lt; it-&gt;m_Name &lt;&lt; <span class="hljs-string">" 年龄： "</span> &lt;&lt; it-&gt;m_Age               &lt;&lt; <span class="hljs-string">" 身高： "</span> &lt;&lt; it-&gt;m_Height &lt;&lt; endl;    }     cout &lt;&lt; <span class="hljs-string">"---------------------------------"</span> &lt;&lt; endl;    L.<span class="hljs-built_in">sort</span>(ComparePerson); <span class="hljs-comment">//排序</span>     <span class="hljs-keyword">for</span> (list&lt;Person&gt;::iterator it = L.<span class="hljs-built_in">begin</span>(); it != L.<span class="hljs-built_in">end</span>(); it++) {        cout &lt;&lt; <span class="hljs-string">"姓名： "</span> &lt;&lt; it-&gt;m_Name &lt;&lt; <span class="hljs-string">" 年龄： "</span> &lt;&lt; it-&gt;m_Age               &lt;&lt; <span class="hljs-string">" 身高： "</span> &lt;&lt; it-&gt;m_Height &lt;&lt; endl;    }} <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>{     <span class="hljs-built_in">test01</span>();     <span class="hljs-built_in">system</span>(<span class="hljs-string">"pause"</span>);     <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;}</code></pre></div><p>总结：</p><ul><li><p>对于自定义数据类型，必须要指定排序规则，否则编译器不知道如何进行排序</p></li><li><p>高级排序只是在排序规则上再进行一次逻辑规则制定，并不复杂</p></li></ul><h3><span id="3-8-set-multiset-rong-qi">3.8 set/ multiset 容器</span><a href="#3-8-set-multiset-rong-qi" class="header-anchor">#</a></h3><h4><span id="3-8-1-set-ji-ben-gai-nian">3.8.1 set基本概念</span><a href="#3-8-1-set-ji-ben-gai-nian" class="header-anchor">#</a></h4><p><strong>简介：</strong></p><ul><li>所有元素都会在插入时自动被排序</li></ul><p><strong>本质：</strong></p><ul><li>set/multiset属于<strong>关联式容器</strong>，底层结构是用<strong>二叉树</strong>实现。</li></ul><p><strong>set和multiset区别</strong>：</p><ul><li>set不允许容器中有重复的元素</li><li>multiset允许容器中有重复的元素</li></ul><h4><span id="3-8-2-set-gou-zao-he-fu-zhi">3.8.2 set构造和赋值</span><a href="#3-8-2-set-gou-zao-he-fu-zhi" class="header-anchor">#</a></h4><p>功能描述：创建set容器以及赋值</p><p>构造：</p><ul><li><code>set st;</code> //默认构造函数：</li><li><code>set(const set &amp;st);</code> //拷贝构造函数</li></ul><p>赋值：</p><ul><li><code>set&amp; operator=(const set &amp;st);</code> //重载等号操作符</li></ul><p><strong>示例：</strong></p><div class="code-wrapper"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;set&gt;</span></span> <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">printSet</span><span class="hljs-params">(set&lt;<span class="hljs-type">int</span>&gt; &amp; s)</span></span><span class="hljs-function"></span>{    <span class="hljs-keyword">for</span> (set&lt;<span class="hljs-type">int</span>&gt;::iterator it = s.<span class="hljs-built_in">begin</span>(); it != s.<span class="hljs-built_in">end</span>(); it++)    {        cout &lt;&lt; *it &lt;&lt; <span class="hljs-string">" "</span>;    }    cout &lt;&lt; endl;} <span class="hljs-comment">//构造和赋值</span><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test01</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>{    set&lt;<span class="hljs-type">int</span>&gt; s1;     s1.<span class="hljs-built_in">insert</span>(<span class="hljs-number">10</span>);    s1.<span class="hljs-built_in">insert</span>(<span class="hljs-number">30</span>);    s1.<span class="hljs-built_in">insert</span>(<span class="hljs-number">20</span>);    s1.<span class="hljs-built_in">insert</span>(<span class="hljs-number">40</span>);    s1.<span class="hljs-built_in">emplace</span>(<span class="hljs-number">50</span>);    <span class="hljs-built_in">printSet</span>(s1);     <span class="hljs-comment">//拷贝构造</span>    set&lt;<span class="hljs-type">int</span>&gt;<span class="hljs-built_in">s2</span>(s1);    <span class="hljs-built_in">printSet</span>(s2);     <span class="hljs-comment">//赋值</span>    set&lt;<span class="hljs-type">int</span>&gt;s3;    s3 = s2;    <span class="hljs-built_in">printSet</span>(s3);} <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>{     <span class="hljs-built_in">test01</span>();     <span class="hljs-built_in">system</span>(<span class="hljs-string">"pause"</span>);     <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;}</code></pre></div><p>总结：</p><ul><li>set容器插入数据时用insert</li><li>set容器插入数据的数据会自动排序</li></ul><h4><span id="3-8-3-set-da-xiao-he-jiao-huan">3.8.3 set大小和交换</span><a href="#3-8-3-set-da-xiao-he-jiao-huan" class="header-anchor">#</a></h4><p><strong>功能描述：</strong></p><ul><li>统计set容器大小以及交换set容器</li></ul><p><strong>函数原型：</strong></p><ul><li><code>size();</code> //返回容器中元素的数目</li><li><code>empty();</code> //判断容器是否为空</li><li><code>swap(st);</code> //交换两个集合容器</li></ul><p><strong>示例：</strong></p><div class="code-wrapper"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;set&gt;</span></span> <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">printSet</span><span class="hljs-params">(set&lt;<span class="hljs-type">int</span>&gt; &amp; s)</span></span><span class="hljs-function"></span>{    <span class="hljs-keyword">for</span> (set&lt;<span class="hljs-type">int</span>&gt;::iterator it = s.<span class="hljs-built_in">begin</span>(); it != s.<span class="hljs-built_in">end</span>(); it++)    {        cout &lt;&lt; *it &lt;&lt; <span class="hljs-string">" "</span>;    }    cout &lt;&lt; endl;} <span class="hljs-comment">//大小</span><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test01</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>{     set&lt;<span class="hljs-type">int</span>&gt; s1;        s1.<span class="hljs-built_in">insert</span>(<span class="hljs-number">10</span>);    s1.<span class="hljs-built_in">insert</span>(<span class="hljs-number">30</span>);    s1.<span class="hljs-built_in">insert</span>(<span class="hljs-number">20</span>);    s1.<span class="hljs-built_in">insert</span>(<span class="hljs-number">40</span>); s1.<span class="hljs-built_in">emplace</span>(<span class="hljs-number">50</span>);    <span class="hljs-keyword">if</span> (s1.<span class="hljs-built_in">empty</span>())    {        cout &lt;&lt; <span class="hljs-string">"s1为空"</span> &lt;&lt; endl;    }    <span class="hljs-keyword">else</span>    {        cout &lt;&lt; <span class="hljs-string">"s1不为空"</span> &lt;&lt; endl;        cout &lt;&lt; <span class="hljs-string">"s1的大小为： "</span> &lt;&lt; s1.<span class="hljs-built_in">size</span>() &lt;&lt; endl;    } } <span class="hljs-comment">//交换</span><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test02</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>{    set&lt;<span class="hljs-type">int</span>&gt; s1;     s1.<span class="hljs-built_in">insert</span>(<span class="hljs-number">10</span>);    s1.<span class="hljs-built_in">insert</span>(<span class="hljs-number">30</span>);    s1.<span class="hljs-built_in">insert</span>(<span class="hljs-number">20</span>);    s1.<span class="hljs-built_in">insert</span>(<span class="hljs-number">40</span>);    s1.<span class="hljs-built_in">emplace</span>(<span class="hljs-number">50</span>);     set&lt;<span class="hljs-type">int</span>&gt; s2;     s2.<span class="hljs-built_in">insert</span>(<span class="hljs-number">100</span>);    s2.<span class="hljs-built_in">insert</span>(<span class="hljs-number">300</span>);    s2.<span class="hljs-built_in">insert</span>(<span class="hljs-number">200</span>);    s2.<span class="hljs-built_in">insert</span>(<span class="hljs-number">400</span>);    s2.<span class="hljs-built_in">emplace</span>(<span class="hljs-number">500</span>);     cout &lt;&lt; <span class="hljs-string">"交换前"</span> &lt;&lt; endl;    <span class="hljs-built_in">printSet</span>(s1);    <span class="hljs-built_in">printSet</span>(s2);    cout &lt;&lt; endl;     cout &lt;&lt; <span class="hljs-string">"交换后"</span> &lt;&lt; endl;    s1.<span class="hljs-built_in">swap</span>(s2);    <span class="hljs-built_in">printSet</span>(s1);    <span class="hljs-built_in">printSet</span>(s2);} <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>{     <span class="hljs-comment">//test01();</span>     <span class="hljs-built_in">test02</span>();     <span class="hljs-built_in">system</span>(<span class="hljs-string">"pause"</span>);     <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;}</code></pre></div><p>总结：</p><ul><li>统计大小 — size</li><li>判断是否为空 — empty</li><li>交换容器 — swap</li></ul><h4><span id="3-8-4-set-cha-ru-he-shan-chu">3.8.4 set插入和删除</span><a href="#3-8-4-set-cha-ru-he-shan-chu" class="header-anchor">#</a></h4><p><strong>功能描述：</strong></p><ul><li>set容器进行插入数据和删除数据</li></ul><p><strong>函数原型：</strong></p><ul><li><code>insert(elem);</code> //在容器中插入元素。</li><li><code>clear();</code> //清除所有元素</li><li><code>erase(pos);</code> //删除pos迭代器所指的元素，返回下一个元素的迭代器。</li><li><code>erase(beg, end);</code> //删除区间[beg,end)的所有元素 ，返回下一个元素的迭代器。</li><li><code>erase(elem);</code> //删除容器中值为elem的元素。</li></ul><p><strong>示例：</strong></p><div class="code-wrapper"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;set&gt;</span></span> <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">printSet</span><span class="hljs-params">(set&lt;<span class="hljs-type">int</span>&gt; &amp; s)</span></span><span class="hljs-function"></span>{    <span class="hljs-keyword">for</span> (set&lt;<span class="hljs-type">int</span>&gt;::iterator it = s.<span class="hljs-built_in">begin</span>(); it != s.<span class="hljs-built_in">end</span>(); it++)    {        cout &lt;&lt; *it &lt;&lt; <span class="hljs-string">" "</span>;    }    cout &lt;&lt; endl;} <span class="hljs-comment">//插入和删除</span><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test01</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>{    set&lt;<span class="hljs-type">int</span>&gt; s1;    <span class="hljs-comment">//插入</span>    s1.<span class="hljs-built_in">insert</span>(<span class="hljs-number">10</span>);    s1.<span class="hljs-built_in">insert</span>(<span class="hljs-number">30</span>);    s1.<span class="hljs-built_in">insert</span>(<span class="hljs-number">20</span>);    s1.<span class="hljs-built_in">insert</span>(<span class="hljs-number">40</span>);    s1.<span class="hljs-built_in">emplace</span>(<span class="hljs-number">50</span>);    <span class="hljs-built_in">printSet</span>(s1);     <span class="hljs-comment">//删除</span>    s1.<span class="hljs-built_in">erase</span>(s1.<span class="hljs-built_in">begin</span>());    <span class="hljs-built_in">printSet</span>(s1);     s1.<span class="hljs-built_in">erase</span>(<span class="hljs-number">30</span>);    <span class="hljs-built_in">printSet</span>(s1);     <span class="hljs-comment">//清空</span>    <span class="hljs-comment">//s1.erase(s1.begin(), s1.end());</span>    s1.<span class="hljs-built_in">clear</span>();    <span class="hljs-built_in">printSet</span>(s1);} <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>{     <span class="hljs-built_in">test01</span>();     <span class="hljs-built_in">system</span>(<span class="hljs-string">"pause"</span>);     <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;}</code></pre></div><p>总结：</p><ul><li>插入 — insert</li><li>删除 — erase</li><li>清空 — clear</li></ul><h4><span id="3-8-5-set-cha-zhao-he-tong-ji">3.8.5 set查找和统计</span><a href="#3-8-5-set-cha-zhao-he-tong-ji" class="header-anchor">#</a></h4><p><strong>功能描述：</strong></p><ul><li>对set容器进行查找数据以及统计数据</li></ul><p><strong>函数原型：</strong></p><ul><li><code>find(key);</code> //查找key是否存在,若存在，返回该键的元素的迭代器；若不存在，返回set.end();</li><li><code>count(key);</code> //统计key的元素个数</li></ul><p><strong>示例：</strong></p><div class="code-wrapper"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;set&gt;</span></span> <span class="hljs-comment">//查找和统计</span><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test01</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>{    set&lt;<span class="hljs-type">int</span>&gt; s1;    <span class="hljs-comment">//插入</span>    s1.<span class="hljs-built_in">insert</span>(<span class="hljs-number">10</span>);    s1.<span class="hljs-built_in">insert</span>(<span class="hljs-number">30</span>);    s1.<span class="hljs-built_in">insert</span>(<span class="hljs-number">20</span>);    s1.<span class="hljs-built_in">insert</span>(<span class="hljs-number">40</span>);    s1.<span class="hljs-built_in">emplace</span>(<span class="hljs-number">50</span>);        <span class="hljs-comment">//查找</span>    set&lt;<span class="hljs-type">int</span>&gt;::iterator pos = s1.<span class="hljs-built_in">find</span>(<span class="hljs-number">30</span>);     <span class="hljs-keyword">if</span> (pos != s1.<span class="hljs-built_in">end</span>())    {        cout &lt;&lt; <span class="hljs-string">"找到了元素 ： "</span> &lt;&lt; *pos &lt;&lt; endl;    }    <span class="hljs-keyword">else</span>    {        cout &lt;&lt; <span class="hljs-string">"未找到元素"</span> &lt;&lt; endl;    }     <span class="hljs-comment">//统计</span>    <span class="hljs-type">int</span> num = s1.<span class="hljs-built_in">count</span>(<span class="hljs-number">30</span>);    cout &lt;&lt; <span class="hljs-string">"num = "</span> &lt;&lt; num &lt;&lt; endl;} <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>{     <span class="hljs-built_in">test01</span>();     <span class="hljs-built_in">system</span>(<span class="hljs-string">"pause"</span>);     <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;}</code></pre></div><p>总结：</p><ul><li>查找 — find （返回的是迭代器）</li><li>统计 — count （对于set，结果为0或者1）</li></ul><h4><span id="3-8-6-set-he-multiset-qu-bie">3.8.6 set和multiset区别</span><a href="#3-8-6-set-he-multiset-qu-bie" class="header-anchor">#</a></h4><p><strong>学习目标：</strong></p><ul><li>掌握set和multiset的区别</li></ul><p><strong>区别：</strong></p><ul><li>set不可以插入重复数据，而multiset可以</li><li>set插入数据的同时会返回插入结果，表示插入是否成功</li><li>multiset不会检测数据，因此可以插入重复数据</li></ul><p><strong>示例：</strong></p><div class="code-wrapper"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;set&gt;</span></span> <span class="hljs-comment">//set和multiset区别</span><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test01</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>{    set&lt;<span class="hljs-type">int</span>&gt; s;    pair&lt;set&lt;<span class="hljs-type">int</span>&gt;::iterator, <span class="hljs-type">bool</span>&gt;  ret = s.<span class="hljs-built_in">insert</span>(<span class="hljs-number">10</span>);    <span class="hljs-keyword">if</span> (ret.second) {        cout &lt;&lt; <span class="hljs-string">"第一次插入成功!"</span> &lt;&lt; endl;    }    <span class="hljs-keyword">else</span> {        cout &lt;&lt; <span class="hljs-string">"第一次插入失败!"</span> &lt;&lt; endl;    }     ret = s.<span class="hljs-built_in">insert</span>(<span class="hljs-number">10</span>);    <span class="hljs-keyword">if</span> (ret.second) {        cout &lt;&lt; <span class="hljs-string">"第二次插入成功!"</span> &lt;&lt; endl;    }    <span class="hljs-keyword">else</span> {        cout &lt;&lt; <span class="hljs-string">"第二次插入失败!"</span> &lt;&lt; endl;    }        <span class="hljs-comment">//multiset</span>    multiset&lt;<span class="hljs-type">int</span>&gt; ms;    ms.<span class="hljs-built_in">insert</span>(<span class="hljs-number">10</span>);    ms.<span class="hljs-built_in">insert</span>(<span class="hljs-number">10</span>);    ms.<span class="hljs-built_in">emplace</span>(<span class="hljs-number">50</span>);     <span class="hljs-keyword">for</span> (multiset&lt;<span class="hljs-type">int</span>&gt;::iterator it = ms.<span class="hljs-built_in">begin</span>(); it != ms.<span class="hljs-built_in">end</span>(); it++) {        cout &lt;&lt; *it &lt;&lt; <span class="hljs-string">" "</span>;    }    cout &lt;&lt; endl;} <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>{     <span class="hljs-built_in">test01</span>();     <span class="hljs-built_in">system</span>(<span class="hljs-string">"pause"</span>);     <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;}</code></pre></div><p>总结：</p><ul><li>如果不允许插入重复数据可以利用set</li><li>如果需要插入重复数据利用multiset</li></ul><h4><span id="3-8-7-pair-dui-zu-chuang-jian">3.8.7 pair对组创建</span><a href="#3-8-7-pair-dui-zu-chuang-jian" class="header-anchor">#</a></h4><p><strong>功能描述：</strong></p><ul><li>成对出现的数据，利用对组可以返回两个数据</li></ul><p><strong>两种创建方式：</strong></p><ul><li><code>pair p ( value1, value2 );</code></li><li><code>pair p = make_pair( value1, value2 );</code></li></ul><p><strong>示例：</strong></p><div class="code-wrapper"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span> <span class="hljs-comment">//对组创建</span><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test01</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>{    <span class="hljs-function">pair&lt;string, <span class="hljs-type">int</span>&gt; <span class="hljs-title">p</span><span class="hljs-params">(string(<span class="hljs-string">"Tom"</span>), <span class="hljs-number">20</span>)</span></span>;    cout &lt;&lt; <span class="hljs-string">"姓名： "</span> &lt;&lt;  p.first &lt;&lt; <span class="hljs-string">" 年龄： "</span> &lt;&lt; p.second &lt;&lt; endl;     pair&lt;string, <span class="hljs-type">int</span>&gt; p2 = <span class="hljs-built_in">make_pair</span>(<span class="hljs-string">"Jerry"</span>, <span class="hljs-number">10</span>);    cout &lt;&lt; <span class="hljs-string">"姓名： "</span> &lt;&lt; p2.first &lt;&lt; <span class="hljs-string">" 年龄： "</span> &lt;&lt; p2.second &lt;&lt; endl;} <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>{     <span class="hljs-built_in">test01</span>();     <span class="hljs-built_in">system</span>(<span class="hljs-string">"pause"</span>);     <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;}</code></pre></div><p>总结：</p><p>两种方式都可以创建对组，记住一种即可</p><h4><span id="3-8-8-set-rong-qi-pai-xu">3.8.8 set容器排序</span><a href="#3-8-8-set-rong-qi-pai-xu" class="header-anchor">#</a></h4><p>学习目标：</p><ul><li>set容器默认排序规则为从小到大，掌握如何改变排序规则</li></ul><p>主要技术点：</p><ul><li>利用仿函数，可以改变排序规则</li></ul><p><strong>示例一</strong> set存放内置数据类型</p><div class="code-wrapper"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;set&gt;</span></span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyCompare</span> {<span class="hljs-keyword">public</span>:    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">operator</span><span class="hljs-params">()</span><span class="hljs-params">(<span class="hljs-type">int</span> v1, <span class="hljs-type">int</span> v2)</span> </span>{        <span class="hljs-keyword">return</span> v1 &gt; v2;    }};<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test01</span><span class="hljs-params">()</span> </span><span class="hljs-function"></span>{        set&lt;<span class="hljs-type">int</span>&gt; s1;    s1.<span class="hljs-built_in">insert</span>(<span class="hljs-number">10</span>);    s1.<span class="hljs-built_in">insert</span>(<span class="hljs-number">40</span>);    s1.<span class="hljs-built_in">insert</span>(<span class="hljs-number">20</span>);    s1.<span class="hljs-built_in">insert</span>(<span class="hljs-number">30</span>);    s1.<span class="hljs-built_in">insert</span>(<span class="hljs-number">50</span>);    s1.<span class="hljs-built_in">emplace</span>(<span class="hljs-number">60</span>);     <span class="hljs-comment">//默认从小到大</span>    <span class="hljs-keyword">for</span> (set&lt;<span class="hljs-type">int</span>&gt;::iterator it = s1.<span class="hljs-built_in">begin</span>(); it != s1.<span class="hljs-built_in">end</span>(); it++) {        cout &lt;&lt; *it &lt;&lt; <span class="hljs-string">" "</span>;    }    cout &lt;&lt; endl;     <span class="hljs-comment">//指定排序规则</span>    set&lt;<span class="hljs-type">int</span>,MyCompare&gt; s2;    s2.<span class="hljs-built_in">insert</span>(<span class="hljs-number">10</span>);    s2.<span class="hljs-built_in">insert</span>(<span class="hljs-number">40</span>);    s2.<span class="hljs-built_in">insert</span>(<span class="hljs-number">20</span>);    s2.<span class="hljs-built_in">insert</span>(<span class="hljs-number">30</span>);    s2.<span class="hljs-built_in">insert</span>(<span class="hljs-number">50</span>);    s1.<span class="hljs-built_in">emplace</span>(<span class="hljs-number">60</span>);     <span class="hljs-keyword">for</span> (set&lt;<span class="hljs-type">int</span>, MyCompare&gt;::iterator it = s2.<span class="hljs-built_in">begin</span>(); it != s2.<span class="hljs-built_in">end</span>(); it++) {        cout &lt;&lt; *it &lt;&lt; <span class="hljs-string">" "</span>;    }    cout &lt;&lt; endl;} <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>{     <span class="hljs-built_in">test01</span>();     <span class="hljs-built_in">system</span>(<span class="hljs-string">"pause"</span>);     <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;}</code></pre></div><p>总结：利用仿函数可以指定set容器的排序规则</p><p><strong>示例二</strong> set存放自定义数据类型</p><div class="code-wrapper"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;set&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span>{<span class="hljs-keyword">public</span>:    <span class="hljs-built_in">Person</span>(string name, <span class="hljs-type">int</span> age)    {        <span class="hljs-keyword">this</span>-&gt;m_Name = name;        <span class="hljs-keyword">this</span>-&gt;m_Age = age;    }     string m_Name;    <span class="hljs-type">int</span> m_Age; };<span class="hljs-keyword">class</span> <span class="hljs-title class_">comparePerson</span>{<span class="hljs-keyword">public</span>:    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">operator</span><span class="hljs-params">()</span><span class="hljs-params">(<span class="hljs-type">const</span> Person&amp; p1, <span class="hljs-type">const</span> Person &amp;p2)</span></span><span class="hljs-function">    </span>{        <span class="hljs-comment">//按照年龄进行排序  降序</span>        <span class="hljs-keyword">return</span> p1.m_Age &gt; p2.m_Age;    }}; <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test01</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>{    set&lt;Person, comparePerson&gt; s;     <span class="hljs-function">Person <span class="hljs-title">p1</span><span class="hljs-params">(<span class="hljs-string">"刘备"</span>, <span class="hljs-number">23</span>)</span></span>;    <span class="hljs-function">Person <span class="hljs-title">p2</span><span class="hljs-params">(<span class="hljs-string">"关羽"</span>, <span class="hljs-number">27</span>)</span></span>;    <span class="hljs-function">Person <span class="hljs-title">p3</span><span class="hljs-params">(<span class="hljs-string">"张飞"</span>, <span class="hljs-number">25</span>)</span></span>;    <span class="hljs-function">Person <span class="hljs-title">p4</span><span class="hljs-params">(<span class="hljs-string">"赵云"</span>, <span class="hljs-number">21</span>)</span></span>;    <span class="hljs-function">Person <span class="hljs-title">p5</span><span class="hljs-params">(<span class="hljs-string">"刘德华"</span>, <span class="hljs-number">51</span>)</span></span>;     s.<span class="hljs-built_in">insert</span>(p1);    s.<span class="hljs-built_in">insert</span>(p2);    s.<span class="hljs-built_in">insert</span>(p3);    s.<span class="hljs-built_in">insert</span>(p4);    s.<span class="hljs-built_in">emplace</span>(p5);     <span class="hljs-keyword">for</span> (set&lt;Person, comparePerson&gt;::iterator it = s.<span class="hljs-built_in">begin</span>(); it != s.<span class="hljs-built_in">end</span>(); it++)    {        cout &lt;&lt; <span class="hljs-string">"姓名： "</span> &lt;&lt; it-&gt;m_Name &lt;&lt; <span class="hljs-string">" 年龄： "</span> &lt;&lt; it-&gt;m_Age &lt;&lt; endl;    }}<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>{     <span class="hljs-built_in">test01</span>();     <span class="hljs-built_in">system</span>(<span class="hljs-string">"pause"</span>);     <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;}</code></pre></div><p>总结：</p><p>对于自定义数据类型，set必须指定排序规则才可以插入数据</p><h3><span id="3-9-map-multimap-rong-qi">3.9 map/ multimap容器</span><a href="#3-9-map-multimap-rong-qi" class="header-anchor">#</a></h3><h4><span id="3-9-1-map-ji-ben-gai-nian">3.9.1 map基本概念</span><a href="#3-9-1-map-ji-ben-gai-nian" class="header-anchor">#</a></h4><p><strong>简介：</strong></p><ul><li>map中所有元素都是pair</li><li>pair中第一个元素为key（键值），起到索引作用，第二个元素为value（实值）</li><li>所有元素都会根据元素的键值自动排序</li></ul><p><strong>本质：</strong></p><ul><li>map/multimap属于<strong>关联式容器</strong>，底层结构是用二叉树实现。</li></ul><p><strong>优点：</strong></p><ul><li>可以根据key值快速找到value值</li></ul><p>map和multimap<strong>区别</strong>：</p><ul><li>map不允许容器中有重复key值元素</li><li>multimap允许容器中有重复key值元素</li></ul><h4><span id="3-9-2-map-gou-zao-he-fu-zhi">3.9.2 map构造和赋值</span><a href="#3-9-2-map-gou-zao-he-fu-zhi" class="header-anchor">#</a></h4><p><strong>功能描述：</strong></p><ul><li>对map容器进行构造和赋值操作</li></ul><p><strong>函数原型：</strong></p><p><strong>构造：</strong></p><ul><li><code>map mp;</code> //map默认构造函数:</li><li><code>map(const map &amp;mp);</code> //拷贝构造函数</li></ul><p><strong>赋值：</strong></p><ul><li><code>map&amp; operator=(const map &amp;mp);</code> //重载等号操作符</li></ul><p><strong>示例：</strong></p><div class="code-wrapper"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;map&gt;</span></span> <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">printMap</span><span class="hljs-params">(map&lt;<span class="hljs-type">int</span>,<span class="hljs-type">int</span>&gt;&amp;m)</span></span><span class="hljs-function"></span>{    <span class="hljs-keyword">for</span> (map&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;::iterator it = m.<span class="hljs-built_in">begin</span>(); it != m.<span class="hljs-built_in">end</span>(); it++)    {        cout &lt;&lt; <span class="hljs-string">"key = "</span> &lt;&lt; it-&gt;first &lt;&lt; <span class="hljs-string">" value = "</span> &lt;&lt; it-&gt;second &lt;&lt; endl;    }    cout &lt;&lt; endl;} <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test01</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>{    map&lt;<span class="hljs-type">int</span>,<span class="hljs-type">int</span>&gt;m; <span class="hljs-comment">//默认构造</span>    m.<span class="hljs-built_in">insert</span>(<span class="hljs-built_in">pair</span>&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;(<span class="hljs-number">1</span>, <span class="hljs-number">10</span>));    m.<span class="hljs-built_in">insert</span>(<span class="hljs-built_in">pair</span>&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;(<span class="hljs-number">2</span>, <span class="hljs-number">20</span>));    m.<span class="hljs-built_in">insert</span>(<span class="hljs-built_in">pair</span>&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;(<span class="hljs-number">3</span>, <span class="hljs-number">30</span>));    <span class="hljs-built_in">printMap</span>(m);     map&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;<span class="hljs-built_in">m2</span>(m); <span class="hljs-comment">//拷贝构造</span>    <span class="hljs-built_in">printMap</span>(m2);     map&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;m3;    m3 = m2; <span class="hljs-comment">//赋值</span>    <span class="hljs-built_in">printMap</span>(m3);} <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>{           <span class="hljs-built_in">test01</span>();     <span class="hljs-built_in">system</span>(<span class="hljs-string">"pause"</span>);     <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;}</code></pre></div><p>总结：map中所有元素都是成对出现，插入数据时候要使用对组</p><h4><span id="3-9-3-map-da-xiao-he-jiao-huan">3.9.3 map大小和交换</span><a href="#3-9-3-map-da-xiao-he-jiao-huan" class="header-anchor">#</a></h4><p><strong>功能描述：</strong></p><ul><li>统计map容器大小以及交换map容器</li></ul><p>函数原型：</p><ul><li><code>size();</code> //返回容器中元素的数目</li><li><code>empty();</code> //判断容器是否为空</li><li><code>swap(st);</code> //交换两个集合容器</li></ul><p><strong>示例：</strong></p><div class="code-wrapper"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;map&gt;</span></span> <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">printMap</span><span class="hljs-params">(map&lt;<span class="hljs-type">int</span>,<span class="hljs-type">int</span>&gt;&amp;m)</span></span><span class="hljs-function"></span>{    <span class="hljs-keyword">for</span> (map&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;::iterator it = m.<span class="hljs-built_in">begin</span>(); it != m.<span class="hljs-built_in">end</span>(); it++)    {        cout &lt;&lt; <span class="hljs-string">"key = "</span> &lt;&lt; it-&gt;first &lt;&lt; <span class="hljs-string">" value = "</span> &lt;&lt; it-&gt;second &lt;&lt; endl;    }    cout &lt;&lt; endl;} <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test01</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>{    map&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;m;    m.<span class="hljs-built_in">insert</span>(<span class="hljs-built_in">pair</span>&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;(<span class="hljs-number">1</span>, <span class="hljs-number">10</span>));    m.<span class="hljs-built_in">insert</span>(<span class="hljs-built_in">pair</span>&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;(<span class="hljs-number">2</span>, <span class="hljs-number">20</span>));    m.<span class="hljs-built_in">insert</span>(<span class="hljs-built_in">pair</span>&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;(<span class="hljs-number">3</span>, <span class="hljs-number">30</span>));     <span class="hljs-keyword">if</span> (m.<span class="hljs-built_in">empty</span>())    {        cout &lt;&lt; <span class="hljs-string">"m为空"</span> &lt;&lt; endl;    }    <span class="hljs-keyword">else</span>    {        cout &lt;&lt; <span class="hljs-string">"m不为空"</span> &lt;&lt; endl;        cout &lt;&lt; <span class="hljs-string">"m的大小为： "</span> &lt;&lt; m.<span class="hljs-built_in">size</span>() &lt;&lt; endl;    }}  <span class="hljs-comment">//交换</span><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test02</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>{    map&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;m;    m.<span class="hljs-built_in">insert</span>(<span class="hljs-built_in">pair</span>&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;(<span class="hljs-number">1</span>, <span class="hljs-number">10</span>));    m.<span class="hljs-built_in">insert</span>(<span class="hljs-built_in">pair</span>&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;(<span class="hljs-number">2</span>, <span class="hljs-number">20</span>));    m.<span class="hljs-built_in">insert</span>(<span class="hljs-built_in">pair</span>&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;(<span class="hljs-number">3</span>, <span class="hljs-number">30</span>));     map&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;m2;    m2.<span class="hljs-built_in">insert</span>(<span class="hljs-built_in">pair</span>&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;(<span class="hljs-number">4</span>, <span class="hljs-number">100</span>));    m2.<span class="hljs-built_in">insert</span>(<span class="hljs-built_in">pair</span>&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;(<span class="hljs-number">5</span>, <span class="hljs-number">200</span>));    m2.<span class="hljs-built_in">insert</span>(<span class="hljs-built_in">pair</span>&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;(<span class="hljs-number">6</span>, <span class="hljs-number">300</span>));     cout &lt;&lt; <span class="hljs-string">"交换前"</span> &lt;&lt; endl;    <span class="hljs-built_in">printMap</span>(m);    <span class="hljs-built_in">printMap</span>(m2);     cout &lt;&lt; <span class="hljs-string">"交换后"</span> &lt;&lt; endl;    m.<span class="hljs-built_in">swap</span>(m2);    <span class="hljs-built_in">printMap</span>(m);    <span class="hljs-built_in">printMap</span>(m2);} <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>{     <span class="hljs-built_in">test01</span>();     <span class="hljs-built_in">test02</span>();     <span class="hljs-built_in">system</span>(<span class="hljs-string">"pause"</span>);     <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;}</code></pre></div><p>总结：</p><ul><li>统计大小 — size</li><li>判断是否为空 — empty</li><li>交换容器 — swap</li></ul><h4><span id="3-9-4-map-cha-ru-he-shan-chu">3.9.4 map插入和删除</span><a href="#3-9-4-map-cha-ru-he-shan-chu" class="header-anchor">#</a></h4><p><strong>功能描述：</strong></p><ul><li>map容器进行插入数据和删除数据</li></ul><p><strong>函数原型：</strong></p><ul><li><code>insert(elem);</code> //在容器中插入元素。</li><li><code>clear();</code> //清除所有元素</li><li><code>erase(pos);</code> //删除pos迭代器所指的元素，返回下一个元素的迭代器。</li><li><code>erase(beg, end);</code> //删除区间[beg,end)的所有元素 ，返回下一个元素的迭代器。</li><li><code>erase(key);</code> //删除容器中值为key的元素。</li></ul><p><strong>示例：</strong></p><div class="code-wrapper"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;map&gt;</span></span> <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">printMap</span><span class="hljs-params">(map&lt;<span class="hljs-type">int</span>,<span class="hljs-type">int</span>&gt;&amp;m)</span></span><span class="hljs-function"></span>{    <span class="hljs-keyword">for</span> (map&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;::iterator it = m.<span class="hljs-built_in">begin</span>(); it != m.<span class="hljs-built_in">end</span>(); it++)    {        cout &lt;&lt; <span class="hljs-string">"key = "</span> &lt;&lt; it-&gt;first &lt;&lt; <span class="hljs-string">" value = "</span> &lt;&lt; it-&gt;second &lt;&lt; endl;    }    cout &lt;&lt; endl;} <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test01</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>{    <span class="hljs-comment">//插入</span>    map&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt; m;    <span class="hljs-comment">//第一种插入方式</span>    m.<span class="hljs-built_in">insert</span>(<span class="hljs-built_in">pair</span>&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;(<span class="hljs-number">1</span>, <span class="hljs-number">10</span>));    <span class="hljs-comment">//第二种插入方式</span>    m.<span class="hljs-built_in">insert</span>(<span class="hljs-built_in">make_pair</span>(<span class="hljs-number">2</span>, <span class="hljs-number">20</span>));    <span class="hljs-comment">//第三种插入方式</span>    m.<span class="hljs-built_in">insert</span>(map&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;::<span class="hljs-built_in">value_type</span>(<span class="hljs-number">3</span>, <span class="hljs-number">30</span>));    <span class="hljs-comment">//第四种插入方式</span>    m[<span class="hljs-number">4</span>] = <span class="hljs-number">40</span>;     <span class="hljs-built_in">printMap</span>(m);     <span class="hljs-comment">//删除</span>    m.<span class="hljs-built_in">erase</span>(m.<span class="hljs-built_in">begin</span>());    <span class="hljs-built_in">printMap</span>(m);     m.<span class="hljs-built_in">erase</span>(<span class="hljs-number">3</span>);    <span class="hljs-built_in">printMap</span>(m);     <span class="hljs-comment">//清空</span>    m.<span class="hljs-built_in">erase</span>(m.<span class="hljs-built_in">begin</span>(),m.<span class="hljs-built_in">end</span>());    m.<span class="hljs-built_in">clear</span>();    <span class="hljs-built_in">printMap</span>(m);} <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>{     <span class="hljs-built_in">test01</span>();     <span class="hljs-built_in">system</span>(<span class="hljs-string">"pause"</span>);     <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;}</code></pre></div><p>总结：</p><ul><li><p>map插入方式很多，记住其一即可</p></li><li><p>插入 — insert</p></li><li><p>删除 — erase</p></li><li><p>清空 — clear</p></li></ul><h4><span id="3-9-5-map-cha-zhao-he-tong-ji">3.9.5 map查找和统计</span><a href="#3-9-5-map-cha-zhao-he-tong-ji" class="header-anchor">#</a></h4><p><strong>功能描述：</strong></p><ul><li>对map容器进行查找数据以及统计数据</li></ul><p><strong>函数原型：</strong></p><ul><li><code>find(key);</code> //查找key是否存在,若存在，返回该键的元素的迭代器；若不存在，返回set.end();</li><li><code>count(key);</code> //统计key的元素个数</li></ul><p><strong>示例：</strong></p><div class="code-wrapper"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;map&gt;</span></span> <span class="hljs-comment">//查找和统计</span><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test01</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>{    map&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;m;     m.<span class="hljs-built_in">insert</span>(<span class="hljs-built_in">pair</span>&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;(<span class="hljs-number">1</span>, <span class="hljs-number">10</span>));    m.<span class="hljs-built_in">insert</span>(<span class="hljs-built_in">pair</span>&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;(<span class="hljs-number">2</span>, <span class="hljs-number">20</span>));    m.<span class="hljs-built_in">insert</span>(<span class="hljs-built_in">pair</span>&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;(<span class="hljs-number">3</span>, <span class="hljs-number">30</span>));     <span class="hljs-comment">//查找</span>    map&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;::iterator pos = m.<span class="hljs-built_in">find</span>(<span class="hljs-number">3</span>);     <span class="hljs-keyword">if</span> (pos != m.<span class="hljs-built_in">end</span>())    {        cout &lt;&lt; <span class="hljs-string">"找到了元素 key = "</span> &lt;&lt; (*pos).first &lt;&lt; <span class="hljs-string">" value = "</span> &lt;&lt; (*pos).second &lt;&lt; endl;    }    <span class="hljs-keyword">else</span>    {        cout &lt;&lt; <span class="hljs-string">"未找到元素"</span> &lt;&lt; endl;    }     <span class="hljs-comment">//统计</span>    <span class="hljs-type">int</span> num = m.<span class="hljs-built_in">count</span>(<span class="hljs-number">3</span>);    cout &lt;&lt; <span class="hljs-string">"num = "</span> &lt;&lt; num &lt;&lt; endl;} <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>{     <span class="hljs-built_in">test01</span>();     <span class="hljs-built_in">system</span>(<span class="hljs-string">"pause"</span>);     <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;}</code></pre></div><p>总结：</p><ul><li>查找 — find （返回的是迭代器）</li><li>统计 — count （对于map，结果为0或者1）</li></ul><h4><span id="3-9-6-map-rong-qi-pai-xu">3.9.6 map容器排序</span><a href="#3-9-6-map-rong-qi-pai-xu" class="header-anchor">#</a></h4><p><strong>学习目标：</strong></p><ul><li>map容器默认排序规则为 按照key值进行 从小到大排序，掌握如何改变排序规则</li></ul><p><strong>主要技术点:</strong></p><ul><li>利用仿函数，可以改变排序规则</li></ul><p><strong>示例：</strong></p><div class="code-wrapper"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;map&gt;</span></span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyCompare</span> {<span class="hljs-keyword">public</span>:    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">operator</span><span class="hljs-params">()</span><span class="hljs-params">(<span class="hljs-type">int</span> v1, <span class="hljs-type">int</span> v2)</span> </span>{        <span class="hljs-keyword">return</span> v1 &gt; v2;    }}; <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test01</span><span class="hljs-params">()</span> </span><span class="hljs-function"></span>{    <span class="hljs-comment">//默认从小到大排序</span>    <span class="hljs-comment">//利用仿函数实现从大到小排序</span>    map&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>, MyCompare&gt; m;     m.<span class="hljs-built_in">insert</span>(<span class="hljs-built_in">make_pair</span>(<span class="hljs-number">1</span>, <span class="hljs-number">10</span>));    m.<span class="hljs-built_in">insert</span>(<span class="hljs-built_in">make_pair</span>(<span class="hljs-number">2</span>, <span class="hljs-number">20</span>));    m.<span class="hljs-built_in">insert</span>(<span class="hljs-built_in">make_pair</span>(<span class="hljs-number">3</span>, <span class="hljs-number">30</span>));    m.<span class="hljs-built_in">insert</span>(<span class="hljs-built_in">make_pair</span>(<span class="hljs-number">4</span>, <span class="hljs-number">40</span>));    m.<span class="hljs-built_in">insert</span>(<span class="hljs-built_in">make_pair</span>(<span class="hljs-number">5</span>, <span class="hljs-number">50</span>));     <span class="hljs-keyword">for</span> (map&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>, MyCompare&gt;::iterator it = m.<span class="hljs-built_in">begin</span>(); it != m.<span class="hljs-built_in">end</span>(); it++) {        cout &lt;&lt; <span class="hljs-string">"key:"</span> &lt;&lt; it-&gt;first &lt;&lt; <span class="hljs-string">" value:"</span> &lt;&lt; it-&gt;second &lt;&lt; endl;    }}<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>{     <span class="hljs-built_in">test01</span>();     <span class="hljs-built_in">system</span>(<span class="hljs-string">"pause"</span>);     <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;}</code></pre></div><p>总结：</p><ul><li>利用仿函数可以指定map容器的排序规则</li><li>对于自定义数据类型，map必须要指定排序规则,同set容器</li></ul><h3><span id="3-10-an-li-yuan-gong-fen-zu">3.10 案例-员工分组</span><a href="#3-10-an-li-yuan-gong-fen-zu" class="header-anchor">#</a></h3><h4><span id="3-10-1-an-li-miao-shu">3.10.1 案例描述</span><a href="#3-10-1-an-li-miao-shu" class="header-anchor">#</a></h4><ul><li>公司今天招聘了10个员工（ABCDEFGHIJ），10名员工进入公司之后，需要指派员工在那个部门工作</li><li>员工信息有: 姓名 工资组成；部门分为：策划、美术、研发</li><li>随机给10名员工分配部门和工资</li><li>通过multimap进行信息的插入 key(部门编号) value(员工)</li><li>分部门显示员工信息</li></ul><h4><span id="3-10-2-shi-xian-bu-zou">3.10.2 实现步骤</span><a href="#3-10-2-shi-xian-bu-zou" class="header-anchor">#</a></h4><ol><li>创建10名员工，放到vector中</li><li>遍历vector容器，取出每个员工，进行随机分组</li><li>分组后，将员工部门编号作为key，具体员工作为value，放入到multimap容器中</li><li>分部门显示员工信息</li></ol><p><strong>案例代码：</strong></p><div class="code-wrapper"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;map&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;ctime&gt;</span></span> <span class="hljs-comment">/*</span><span class="hljs-comment">- 公司今天招聘了10个员工（ABCDEFGHIJ），10名员工进入公司之后，需要指派员工在那个部门工作</span><span class="hljs-comment">- 员工信息有: 姓名  工资组成；部门分为：策划、美术、研发</span><span class="hljs-comment">- 随机给10名员工分配部门和工资</span><span class="hljs-comment">- 通过multimap进行信息的插入  key(部门编号) value(员工)</span><span class="hljs-comment">- 分部门显示员工信息</span><span class="hljs-comment">*/</span> <span class="hljs-meta">#<span class="hljs-keyword">define</span> CEHUA  0</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> MEISHU 1</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> YANFA  2</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Worker</span>{<span class="hljs-keyword">public</span>:    string m_Name;    <span class="hljs-type">int</span> m_Salary;}; <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">createWorker</span><span class="hljs-params">(vector&lt;Worker&gt;&amp;v)</span></span><span class="hljs-function"></span>{    string nameSeed = <span class="hljs-string">"ABCDEFGHIJ"</span>;    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++)    {        Worker worker;        worker.m_Name = <span class="hljs-string">"员工"</span>;        worker.m_Name += nameSeed[i];         worker.m_Salary = <span class="hljs-built_in">rand</span>() % <span class="hljs-number">10000</span> + <span class="hljs-number">10000</span>; <span class="hljs-comment">// 10000 ~ 19999</span>        <span class="hljs-comment">//将员工放入到容器中</span>        v.<span class="hljs-built_in">push_back</span>(worker);    }} <span class="hljs-comment">//员工分组</span><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">setGroup</span><span class="hljs-params">(vector&lt;Worker&gt;&amp;v,multimap&lt;<span class="hljs-type">int</span>,Worker&gt;&amp;m)</span></span><span class="hljs-function"></span>{    <span class="hljs-keyword">for</span> (vector&lt;Worker&gt;::iterator it = v.<span class="hljs-built_in">begin</span>(); it != v.<span class="hljs-built_in">end</span>(); it++)    {        <span class="hljs-comment">//产生随机部门编号</span>        <span class="hljs-type">int</span> deptId = <span class="hljs-built_in">rand</span>() % <span class="hljs-number">3</span>; <span class="hljs-comment">// 0 1 2 </span>         <span class="hljs-comment">//将员工插入到分组中</span>        <span class="hljs-comment">//key部门编号，value具体员工</span>        m.<span class="hljs-built_in">insert</span>(<span class="hljs-built_in">make_pair</span>(deptId, *it));    }} <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">showWorkerByGourp</span><span class="hljs-params">(multimap&lt;<span class="hljs-type">int</span>,Worker&gt;&amp;m)</span></span><span class="hljs-function"></span>{    <span class="hljs-comment">// 0  A  B  C   1  D  E   2  F G ...</span>    cout &lt;&lt; <span class="hljs-string">"策划部门："</span> &lt;&lt; endl;     multimap&lt;<span class="hljs-type">int</span>,Worker&gt;::iterator pos = m.<span class="hljs-built_in">find</span>(CEHUA);    <span class="hljs-type">int</span> count = m.<span class="hljs-built_in">count</span>(CEHUA); <span class="hljs-comment">// 统计具体人数</span>    <span class="hljs-type">int</span> index = <span class="hljs-number">0</span>;    <span class="hljs-keyword">for</span> (; pos != m.<span class="hljs-built_in">end</span>() &amp;&amp; index &lt; count; pos++ , index++)    {        cout &lt;&lt; <span class="hljs-string">"姓名： "</span> &lt;&lt; pos-&gt;second.m_Name &lt;&lt; <span class="hljs-string">" 工资： "</span> &lt;&lt; pos-&gt;second.m_Salary &lt;&lt; endl;    }     cout &lt;&lt; <span class="hljs-string">"----------------------"</span> &lt;&lt; endl;    cout &lt;&lt; <span class="hljs-string">"美术部门： "</span> &lt;&lt; endl;    pos = m.<span class="hljs-built_in">find</span>(MEISHU);    count = m.<span class="hljs-built_in">count</span>(MEISHU); <span class="hljs-comment">// 统计具体人数</span>    index = <span class="hljs-number">0</span>;    <span class="hljs-keyword">for</span> (; pos != m.<span class="hljs-built_in">end</span>() &amp;&amp; index &lt; count; pos++, index++)    {        cout &lt;&lt; <span class="hljs-string">"姓名： "</span> &lt;&lt; pos-&gt;second.m_Name &lt;&lt; <span class="hljs-string">" 工资： "</span> &lt;&lt; pos-&gt;second.m_Salary &lt;&lt; endl;    }     cout &lt;&lt; <span class="hljs-string">"----------------------"</span> &lt;&lt; endl;    cout &lt;&lt; <span class="hljs-string">"研发部门： "</span> &lt;&lt; endl;    pos = m.<span class="hljs-built_in">find</span>(YANFA);    count = m.<span class="hljs-built_in">count</span>(YANFA); <span class="hljs-comment">// 统计具体人数</span>    index = <span class="hljs-number">0</span>;    <span class="hljs-keyword">for</span> (; pos != m.<span class="hljs-built_in">end</span>() &amp;&amp; index &lt; count; pos++, index++)    {        cout &lt;&lt; <span class="hljs-string">"姓名： "</span> &lt;&lt; pos-&gt;second.m_Name &lt;&lt; <span class="hljs-string">" 工资： "</span> &lt;&lt; pos-&gt;second.m_Salary &lt;&lt; endl;    } } <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>{     <span class="hljs-built_in">srand</span>((<span class="hljs-type">unsigned</span> <span class="hljs-type">int</span>)<span class="hljs-built_in">time</span>(<span class="hljs-literal">NULL</span>));     <span class="hljs-comment">//1、创建员工</span>    vector&lt;Worker&gt;vWorker;    <span class="hljs-built_in">createWorker</span>(vWorker);     <span class="hljs-comment">//2、员工分组</span>    multimap&lt;<span class="hljs-type">int</span>, Worker&gt;mWorker;    <span class="hljs-built_in">setGroup</span>(vWorker, mWorker);      <span class="hljs-comment">//3、分组显示员工</span>    <span class="hljs-built_in">showWorkerByGourp</span>(mWorker);     <span class="hljs-comment">////测试</span>    <span class="hljs-comment">//for (vector&lt;Worker&gt;::iterator it = vWorker.begin(); it != vWorker.end(); it++)</span>    <span class="hljs-comment">//{</span>    <span class="hljs-comment">//    cout &lt;&lt; "姓名： " &lt;&lt; it-&gt;m_Name &lt;&lt; " 工资： " &lt;&lt; it-&gt;m_Salary &lt;&lt; endl;</span>    <span class="hljs-comment">//}</span>     <span class="hljs-built_in">system</span>(<span class="hljs-string">"pause"</span>);     <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;}</code></pre></div><p>总结：</p><ul><li>当数据以键值对形式存在，可以考虑用map 或 multimap</li></ul><h3><span id="3-11-unordered-map-unordered-multimap-rong-qi">3.11 unordered_map/unordered_multimap容器</span><a href="#3-11-unordered-map-unordered-multimap-rong-qi" class="header-anchor">#</a></h3><blockquote><p>unordered_map(C++11 起)  键值对的集合，按照键生成散列，键是唯一的 </p></blockquote><blockquote><p>unordered_multimap(C++11 起)键值对的集合，按照键生成散列 </p></blockquote><p><a href="https://txt1994.github.io/2022/01/18/C-%E6%97%A0%E5%BA%8F%E5%AE%B9%E5%99%A8/">C++无序容器 - txt1994s</a></p><h3><span id="3-12-unordered-set-unordered-multiset-rong-qi">3.12 unordered_set/unordered_multiset容器</span><a href="#3-12-unordered-set-unordered-multiset-rong-qi" class="header-anchor">#</a></h3><blockquote><p>unordered_set(C++11 起) 唯一键的集合，按照键生成散列 </p></blockquote><blockquote><p>unordered_multiset(C++11 起) 键的集合，按照键生成散列</p></blockquote><p><a href="https://txt1994.github.io/2022/01/18/C-%E6%97%A0%E5%BA%8F%E5%AE%B9%E5%99%A8/">C++无序容器 - txt1994s</a></p><h2><span id="4-stl-han-shu-dui-xiang">4 STL- 函数对象</span><a href="#4-stl-han-shu-dui-xiang" class="header-anchor">#</a></h2><h3><span id="4-1-han-shu-dui-xiang">4.1 函数对象</span><a href="#4-1-han-shu-dui-xiang" class="header-anchor">#</a></h3><h4><span id="4-1-1-han-shu-dui-xiang-gai-nian">4.1.1 函数对象概念</span><a href="#4-1-1-han-shu-dui-xiang-gai-nian" class="header-anchor">#</a></h4><p><strong>概念：</strong></p><ul><li>重载<strong>函数调用操作符</strong>的类，其对象常称为<strong>函数对象</strong></li><li><strong>函数对象</strong>使用重载的()时，行为类似函数调用，也叫<strong>仿函数</strong></li></ul><p><strong>本质：</strong></p><p>函数对象(仿函数)是一个<strong>类</strong>，不是一个函数</p><h4><span id="4-1-2-han-shu-dui-xiang-shi-yong">4.1.2 函数对象使用</span><a href="#4-1-2-han-shu-dui-xiang-shi-yong" class="header-anchor">#</a></h4><p><strong>特点：</strong></p><ul><li>函数对象在使用时，可以像普通函数那样调用, 可以有参数，可以有返回值</li><li>函数对象超出普通函数的概念，函数对象可以有自己的状态</li><li>函数对象可以作为参数传递</li></ul><p><strong>示例:</strong></p><div class="code-wrapper"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span> <span class="hljs-comment">//1、函数对象在使用时，可以像普通函数那样调用, 可以有参数，可以有返回值</span><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyAdd</span>{<span class="hljs-keyword">public</span> :    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">operator</span><span class="hljs-params">()</span><span class="hljs-params">(<span class="hljs-type">int</span> v1,<span class="hljs-type">int</span> v2)</span></span><span class="hljs-function">    </span>{        <span class="hljs-keyword">return</span> v1 + v2;    }}; <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test01</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>{    MyAdd myAdd;    cout &lt;&lt; <span class="hljs-built_in">myAdd</span>(<span class="hljs-number">10</span>, <span class="hljs-number">10</span>) &lt;&lt; endl;} <span class="hljs-comment">//2、函数对象可以有自己的状态</span><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyPrint</span>{<span class="hljs-keyword">public</span>:    <span class="hljs-built_in">MyPrint</span>()    {        count = <span class="hljs-number">0</span>;    }    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">operator</span><span class="hljs-params">()</span><span class="hljs-params">(string test)</span></span><span class="hljs-function">    </span>{        cout &lt;&lt; test &lt;&lt; endl;        count++; <span class="hljs-comment">//统计使用次数</span>    }     <span class="hljs-type">int</span> count; <span class="hljs-comment">//内部自己的状态</span>};<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test02</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>{    MyPrint myPrint;    <span class="hljs-built_in">myPrint</span>(<span class="hljs-string">"hello world"</span>);    <span class="hljs-built_in">myPrint</span>(<span class="hljs-string">"hello world"</span>);    <span class="hljs-built_in">myPrint</span>(<span class="hljs-string">"hello world"</span>);    cout &lt;&lt; <span class="hljs-string">"myPrint调用次数为： "</span> &lt;&lt; myPrint.count &lt;&lt; endl;} <span class="hljs-comment">//3、函数对象可以作为参数传递</span><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">doPrint</span><span class="hljs-params">(MyPrint &amp;mp , string test)</span></span><span class="hljs-function"></span>{    <span class="hljs-built_in">mp</span>(test);} <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test03</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>{    MyPrint myPrint;    <span class="hljs-built_in">doPrint</span>(myPrint, <span class="hljs-string">"Hello C++"</span>);} <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>{     <span class="hljs-comment">//test01();</span>    <span class="hljs-comment">//test02();</span>    <span class="hljs-built_in">test03</span>();     <span class="hljs-built_in">system</span>(<span class="hljs-string">"pause"</span>);     <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;}</code></pre></div><p>总结：</p><ul><li>仿函数写法非常灵活，可以作为参数进行传递。</li></ul><h3><span id="4-2-wei-ci">4.2 谓词</span><a href="#4-2-wei-ci" class="header-anchor">#</a></h3><h4><span id="4-2-1-wei-ci-gai-nian">4.2.1 谓词概念</span><a href="#4-2-1-wei-ci-gai-nian" class="header-anchor">#</a></h4><p><strong>概念：</strong></p><ul><li>返回bool类型的仿函数称为<strong>谓词</strong></li><li>如果operator()接受一个参数，那么叫做一元谓词</li><li>如果operator()接受两个参数，那么叫做二元谓词</li></ul><h4><span id="4-2-2-yi-yuan-wei-ci">4.2.2 一元谓词</span><a href="#4-2-2-yi-yuan-wei-ci" class="header-anchor">#</a></h4><p><strong>示例：</strong></p><div class="code-wrapper"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span> <span class="hljs-comment">//1.一元谓词</span><span class="hljs-keyword">struct</span> <span class="hljs-title class_">GreaterFive</span>{    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">operator</span><span class="hljs-params">()</span><span class="hljs-params">(<span class="hljs-type">int</span> val)</span> </span>{        <span class="hljs-keyword">return</span> val &gt; <span class="hljs-number">5</span>;    }}; <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test01</span><span class="hljs-params">()</span> </span>{     vector&lt;<span class="hljs-type">int</span>&gt; v;    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++)    {        v.<span class="hljs-built_in">push_back</span>(i);    }     vector&lt;<span class="hljs-type">int</span>&gt;::iterator it = <span class="hljs-built_in">find_if</span>(v.<span class="hljs-built_in">begin</span>(), v.<span class="hljs-built_in">end</span>(), <span class="hljs-built_in">GreaterFive</span>());    <span class="hljs-keyword">if</span> (it == v.<span class="hljs-built_in">end</span>()) {        cout &lt;&lt; <span class="hljs-string">"没找到!"</span> &lt;&lt; endl;    }    <span class="hljs-keyword">else</span> {        cout &lt;&lt; <span class="hljs-string">"找到:"</span> &lt;&lt; *it &lt;&lt; endl;    } } <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>{     <span class="hljs-built_in">test01</span>();     <span class="hljs-built_in">system</span>(<span class="hljs-string">"pause"</span>);     <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;}</code></pre></div><p>总结：参数只有一个的谓词，称为一元谓词</p><h4><span id="4-2-3-er-yuan-wei-ci">4.2.3 二元谓词</span><a href="#4-2-3-er-yuan-wei-ci" class="header-anchor">#</a></h4><p><strong>示例：</strong></p><div class="code-wrapper"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><span class="hljs-comment">//二元谓词</span><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyCompare</span>{<span class="hljs-keyword">public</span>:    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">operator</span><span class="hljs-params">()</span><span class="hljs-params">(<span class="hljs-type">int</span> num1, <span class="hljs-type">int</span> num2)</span></span><span class="hljs-function">    </span>{        <span class="hljs-keyword">return</span> num1 &gt; num2;    }}; <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test01</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>{    vector&lt;<span class="hljs-type">int</span>&gt; v;    v.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">10</span>);    v.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">40</span>);    v.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">20</span>);    v.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">30</span>);    v.<span class="hljs-built_in">emplace_back</span>(<span class="hljs-number">50</span>);         <span class="hljs-comment">//默认从小到大</span>    <span class="hljs-built_in">sort</span>(v.<span class="hljs-built_in">begin</span>(), v.<span class="hljs-built_in">end</span>());    <span class="hljs-keyword">for</span> (vector&lt;<span class="hljs-type">int</span>&gt;::iterator it = v.<span class="hljs-built_in">begin</span>(); it != v.<span class="hljs-built_in">end</span>(); it++)    {        cout &lt;&lt; *it &lt;&lt; <span class="hljs-string">" "</span>;    }    cout &lt;&lt; endl;    cout &lt;&lt; <span class="hljs-string">"----------------------------"</span> &lt;&lt; endl;     <span class="hljs-comment">//使用函数对象改变算法策略，排序从大到小</span>    <span class="hljs-built_in">sort</span>(v.<span class="hljs-built_in">begin</span>(), v.<span class="hljs-built_in">end</span>(), <span class="hljs-built_in">MyCompare</span>());    <span class="hljs-keyword">for</span> (vector&lt;<span class="hljs-type">int</span>&gt;::iterator it = v.<span class="hljs-built_in">begin</span>(); it != v.<span class="hljs-built_in">end</span>(); it++)    {        cout &lt;&lt; *it &lt;&lt; <span class="hljs-string">" "</span>;    }    cout &lt;&lt; endl;} <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>{     <span class="hljs-built_in">test01</span>();     <span class="hljs-built_in">system</span>(<span class="hljs-string">"pause"</span>);     <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;}</code></pre></div><p>总结：参数只有两个的谓词，称为二元谓词</p><h3><span id="4-3-nei-jian-han-shu-dui-xiang">4.3 内建函数对象</span><a href="#4-3-nei-jian-han-shu-dui-xiang" class="header-anchor">#</a></h3><h4><span id="4-3-1-nei-jian-han-shu-dui-xiang-yi-yi">4.3.1 内建函数对象意义</span><a href="#4-3-1-nei-jian-han-shu-dui-xiang-yi-yi" class="header-anchor">#</a></h4><p><strong>概念：</strong></p><ul><li>STL内建了一些函数对象</li></ul><p><strong>分类:</strong></p><ul><li>算术仿函数</li><li>关系仿函数</li><li>逻辑仿函数</li></ul><p><strong>用法：</strong></p><ul><li>这些仿函数所产生的对象，用法和一般函数完全相同</li><li>使用内建函数对象，需要引入头文件 <code>#include</code></li></ul><h4><span id="4-3-2-suan-zhu-fang-han-shu">4.3.2 算术仿函数</span><a href="#4-3-2-suan-zhu-fang-han-shu" class="header-anchor">#</a></h4><p><strong>功能描述：</strong></p><ul><li>实现四则运算</li><li>其中negate是一元运算，其他都是二元运算</li></ul><p><strong>仿函数原型：</strong></p><ul><li><code>template T plus</code> //加法仿函数</li><li><code>template T minus</code> //减法仿函数</li><li><code>template T multiplies</code> //乘法仿函数</li><li><code>template T divides</code> //除法仿函数</li><li><code>template T modulus</code> //取模仿函数</li><li><code>template T negate</code> //取反仿函数</li></ul><p><strong>示例：</strong></p><div class="code-wrapper"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;functional&gt;</span></span><span class="hljs-comment">//negate</span><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test01</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>{    negate&lt;<span class="hljs-type">int</span>&gt; n;    cout &lt;&lt; <span class="hljs-built_in">n</span>(<span class="hljs-number">50</span>) &lt;&lt; endl;} <span class="hljs-comment">//plus</span><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test02</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>{    plus&lt;<span class="hljs-type">int</span>&gt; p;    cout &lt;&lt; <span class="hljs-built_in">p</span>(<span class="hljs-number">10</span>, <span class="hljs-number">20</span>) &lt;&lt; endl;} <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>{     <span class="hljs-built_in">test01</span>();    <span class="hljs-built_in">test02</span>();     <span class="hljs-built_in">system</span>(<span class="hljs-string">"pause"</span>);     <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;}</code></pre></div><p>总结：使用内建函数对象时，需要引入头文件 <code>#include </code></p><h4><span id="4-3-3-guan-xi-fang-han-shu">4.3.3 关系仿函数</span><a href="#4-3-3-guan-xi-fang-han-shu" class="header-anchor">#</a></h4><p><strong>功能描述：</strong></p><ul><li>实现关系对比</li></ul><p><strong>仿函数原型：</strong></p><ul><li><code>template bool equal_to</code> //等于</li><li><code>template bool not_equal_to</code> //不等于</li><li><code>template bool greater</code> //大于</li><li><code>template bool greater_equal</code> //大于等于</li><li><code>template bool less</code> //小于</li><li><code>template bool less_equal</code> //小于等于</li></ul><p><strong>示例：</strong></p><div class="code-wrapper"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;functional&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyCompare</span>{<span class="hljs-keyword">public</span>:    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">operator</span><span class="hljs-params">()</span><span class="hljs-params">(<span class="hljs-type">int</span> v1,<span class="hljs-type">int</span> v2)</span></span><span class="hljs-function">    </span>{        <span class="hljs-keyword">return</span> v1 &gt; v2;    }};<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test01</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>{    vector&lt;<span class="hljs-type">int</span>&gt; v;     v.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">10</span>);    v.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">30</span>);    v.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">50</span>);    v.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">40</span>);    v.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">20</span>);     <span class="hljs-keyword">for</span> (vector&lt;<span class="hljs-type">int</span>&gt;::iterator it = v.<span class="hljs-built_in">begin</span>(); it != v.<span class="hljs-built_in">end</span>(); it++) {        cout &lt;&lt; *it &lt;&lt; <span class="hljs-string">" "</span>;    }    cout &lt;&lt; endl;     <span class="hljs-comment">//自己实现仿函数</span>    <span class="hljs-comment">//sort(v.begin(), v.end(), MyCompare());</span>    <span class="hljs-comment">//STL内建仿函数  大于仿函数</span>    <span class="hljs-built_in">sort</span>(v.<span class="hljs-built_in">begin</span>(), v.<span class="hljs-built_in">end</span>(), <span class="hljs-built_in">greater</span>&lt;<span class="hljs-type">int</span>&gt;());     <span class="hljs-keyword">for</span> (vector&lt;<span class="hljs-type">int</span>&gt;::iterator it = v.<span class="hljs-built_in">begin</span>(); it != v.<span class="hljs-built_in">end</span>(); it++) {        cout &lt;&lt; *it &lt;&lt; <span class="hljs-string">" "</span>;    }    cout &lt;&lt; endl;} <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>{     <span class="hljs-built_in">test01</span>();     <span class="hljs-built_in">system</span>(<span class="hljs-string">"pause"</span>);     <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;}</code></pre></div><p>总结：关系仿函数中最常用的就是greater&lt;&gt;大于</p><h4><span id="4-3-4-luo-ji-fang-han-shu">4.3.4 逻辑仿函数</span><a href="#4-3-4-luo-ji-fang-han-shu" class="header-anchor">#</a></h4><p><strong>功能描述：</strong></p><ul><li>实现逻辑运算</li></ul><p><strong>函数原型：</strong></p><ul><li><code>template bool logical_and</code> //逻辑与</li><li><code>template bool logical_or</code> //逻辑或</li><li><code>template bool logical_not</code> //逻辑非</li></ul><p><strong>示例：</strong></p><div class="code-wrapper"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;functional&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test01</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>{    vector&lt;<span class="hljs-type">bool</span>&gt; v;    v.<span class="hljs-built_in">push_back</span>(<span class="hljs-literal">true</span>);    v.<span class="hljs-built_in">push_back</span>(<span class="hljs-literal">false</span>);    v.<span class="hljs-built_in">push_back</span>(<span class="hljs-literal">true</span>);    v.<span class="hljs-built_in">push_back</span>(<span class="hljs-literal">false</span>);     <span class="hljs-keyword">for</span> (vector&lt;<span class="hljs-type">bool</span>&gt;::iterator it = v.<span class="hljs-built_in">begin</span>();it!= v.<span class="hljs-built_in">end</span>();it++)    {        cout &lt;&lt; *it &lt;&lt; <span class="hljs-string">" "</span>;    }    cout &lt;&lt; endl;     <span class="hljs-comment">//逻辑非  将v容器搬运到v2中，并执行逻辑非运算</span>    vector&lt;<span class="hljs-type">bool</span>&gt; v2;    v2.<span class="hljs-built_in">resize</span>(v.<span class="hljs-built_in">size</span>());    <span class="hljs-built_in">transform</span>(v.<span class="hljs-built_in">begin</span>(), v.<span class="hljs-built_in">end</span>(),  v2.<span class="hljs-built_in">begin</span>(), <span class="hljs-built_in">logical_not</span>&lt;<span class="hljs-type">bool</span>&gt;());    <span class="hljs-keyword">for</span> (vector&lt;<span class="hljs-type">bool</span>&gt;::iterator it = v2.<span class="hljs-built_in">begin</span>(); it != v2.<span class="hljs-built_in">end</span>(); it++)    {        cout &lt;&lt; *it &lt;&lt; <span class="hljs-string">" "</span>;    }    cout &lt;&lt; endl;} <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>{     <span class="hljs-built_in">test01</span>();     <span class="hljs-built_in">system</span>(<span class="hljs-string">"pause"</span>);     <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;}</code></pre></div><p>总结：逻辑仿函数实际应用较少，了解即可</p><h2><span id="5-stl-chang-yong-suan-fa">5 STL- 常用算法</span><a href="#5-stl-chang-yong-suan-fa" class="header-anchor">#</a></h2><p><strong>概述</strong>:</p><ul><li><p>算法主要是由头文件<code> </code> ``组成。</p></li><li><p>``是所有STL头文件中最大的一个，范围涉及到比较、 交换、查找、遍历操作、复制、修改等等</p></li><li><p>``体积很小，只包括几个在序列上面进行简单数学运算的模板函数</p></li><li><p>``定义了一些模板类,用以声明函数对象。</p></li></ul><h3><span id="5-1-chang-yong-bian-li-suan-fa">5.1 常用遍历算法</span><a href="#5-1-chang-yong-bian-li-suan-fa" class="header-anchor">#</a></h3><p><strong>学习目标：</strong></p><ul><li>掌握常用的遍历算法</li></ul><p><strong>算法简介：</strong></p><ul><li><code>for_each</code> //遍历容器</li><li><code>transform</code> //搬运容器到另一个容器中</li></ul><h4><span id="5-1-1-for-each">5.1.1 for_each</span><a href="#5-1-1-for-each" class="header-anchor">#</a></h4><p><strong>功能描述：</strong></p><ul><li>实现遍历容器</li></ul><p><strong>函数原型：</strong></p><ul><li><p><code>for_each(iterator beg, iterator end, _func);</code></p><p>// 遍历算法 遍历容器元素</p><p>// beg 开始迭代器</p><p>// end 结束迭代器</p><p>// _func 函数或者函数对象</p></li></ul><p><strong>示例：</strong></p><div class="code-wrapper"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span> <span class="hljs-comment">//普通函数</span><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">print01</span><span class="hljs-params">(<span class="hljs-type">int</span> val)</span> </span><span class="hljs-function"></span>{    cout &lt;&lt; val &lt;&lt; <span class="hljs-string">" "</span>;}<span class="hljs-comment">//函数对象</span><span class="hljs-keyword">class</span> <span class="hljs-title class_">print02</span> { <span class="hljs-keyword">public</span>:    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">operator</span><span class="hljs-params">()</span><span class="hljs-params">(<span class="hljs-type">int</span> val)</span> </span><span class="hljs-function">    </span>{        cout &lt;&lt; val &lt;&lt; <span class="hljs-string">" "</span>;    }}; <span class="hljs-comment">//for_each算法基本用法</span><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test01</span><span class="hljs-params">()</span> </span>{     vector&lt;<span class="hljs-type">int</span>&gt; v;    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++)     {        v.<span class="hljs-built_in">push_back</span>(i);    }     <span class="hljs-comment">//遍历算法</span>    for_each(v.<span class="hljs-built_in">begin</span>(), v.<span class="hljs-built_in">end</span>(), print01);    cout &lt;&lt; endl;     for_each(v.<span class="hljs-built_in">begin</span>(), v.<span class="hljs-built_in">end</span>(), <span class="hljs-built_in">print02</span>());    cout &lt;&lt; endl;} <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>{     <span class="hljs-built_in">test01</span>();     <span class="hljs-built_in">system</span>(<span class="hljs-string">"pause"</span>);     <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;}</code></pre></div><p><strong>总结：</strong>for_each在实际开发中是最常用遍历算法，需要熟练掌握</p><h4><span id="5-1-2-transform">5.1.2 transform</span><a href="#5-1-2-transform" class="header-anchor">#</a></h4><p><strong>功能描述：</strong></p><ul><li>搬运容器到另一个容器中</li></ul><p><strong>函数原型：</strong></p><ul><li><code>transform(iterator beg1, iterator end1, iterator beg2, _func);</code></li></ul><p>//beg1 源容器开始迭代器</p><p>//end1 源容器结束迭代器</p><p>//beg2 目标容器开始迭代器</p><p>//_func 函数或者函数对象</p><p><strong>示例：</strong></p><div class="code-wrapper"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;vector&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;algorithm&gt;</span></span> <span class="hljs-comment">//常用遍历算法  搬运 transform</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TransForm</span>{<span class="hljs-keyword">public</span>:    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">operator</span><span class="hljs-params">()</span><span class="hljs-params">(<span class="hljs-type">int</span> val)</span></span><span class="hljs-function">    </span>{        <span class="hljs-keyword">return</span> val;    } }; <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyPrint</span>{<span class="hljs-keyword">public</span>:    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">operator</span><span class="hljs-params">()</span><span class="hljs-params">(<span class="hljs-type">int</span> val)</span></span><span class="hljs-function">    </span>{        cout &lt;&lt; val &lt;&lt; <span class="hljs-string">" "</span>;    }}; <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test01</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>{    vector&lt;<span class="hljs-type">int</span>&gt;v;    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++)    {        v.<span class="hljs-built_in">push_back</span>(i);    }     vector&lt;<span class="hljs-type">int</span>&gt;vTarget; <span class="hljs-comment">//目标容器</span>     vTarget.<span class="hljs-built_in">resize</span>(v.<span class="hljs-built_in">size</span>()); <span class="hljs-comment">// 目标容器需要提前开辟空间</span>     <span class="hljs-built_in">transform</span>(v.<span class="hljs-built_in">begin</span>(), v.<span class="hljs-built_in">end</span>(), vTarget.<span class="hljs-built_in">begin</span>(), <span class="hljs-built_in">TransForm</span>());     for_each(vTarget.<span class="hljs-built_in">begin</span>(), vTarget.<span class="hljs-built_in">end</span>(), <span class="hljs-built_in">MyPrint</span>());} <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>{     <span class="hljs-built_in">test01</span>();     <span class="hljs-built_in">system</span>(<span class="hljs-string">"pause"</span>);     <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;}</code></pre></div><p><strong>总结：</strong> 搬运的目标容器必须要提前开辟空间，否则无法正常搬运</p><h3><span id="5-2-chang-yong-cha-zhao-suan-fa">5.2 常用查找算法</span><a href="#5-2-chang-yong-cha-zhao-suan-fa" class="header-anchor">#</a></h3><p>学习目标：</p><ul><li>掌握常用的查找算法</li></ul><p><strong>算法简介：</strong></p><ul><li><code>find</code> //查找元素</li><li><code>find_if</code> //按条件查找元素</li><li><code>adjacent_find</code> //查找相邻重复元素</li><li><code>binary_search</code> //二分查找法</li><li><code>count</code> //统计元素个数</li><li><code>count_if</code> //按条件统计元素个数</li></ul><h4><span id="5-2-1-find">5.2.1 find</span><a href="#5-2-1-find" class="header-anchor">#</a></h4><p><strong>功能描述：</strong></p><ul><li>查找指定元素，找到返回指定元素的迭代器，找不到返回结束迭代器end()</li></ul><p><strong>函数原型：</strong></p><ul><li><p><code>find(iterator beg, iterator end, value);</code></p><p>// 按值查找元素，找到返回指定位置迭代器，找不到返回结束迭代器位置</p><p>// beg 开始迭代器</p><p>// end 结束迭代器</p><p>// value 查找的元素</p></li></ul><p><strong>示例：</strong></p><div class="code-wrapper"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test01</span><span class="hljs-params">()</span> </span>{     vector&lt;<span class="hljs-type">int</span>&gt; v;    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++) {        v.<span class="hljs-built_in">push_back</span>(i + <span class="hljs-number">1</span>);    }    <span class="hljs-comment">//查找容器中是否有 5 这个元素</span>    vector&lt;<span class="hljs-type">int</span>&gt;::iterator it = <span class="hljs-built_in">find</span>(v.<span class="hljs-built_in">begin</span>(), v.<span class="hljs-built_in">end</span>(), <span class="hljs-number">5</span>);    <span class="hljs-keyword">if</span> (it == v.<span class="hljs-built_in">end</span>())     {        cout &lt;&lt; <span class="hljs-string">"没有找到!"</span> &lt;&lt; endl;    }    <span class="hljs-keyword">else</span>     {        cout &lt;&lt; <span class="hljs-string">"找到:"</span> &lt;&lt; *it &lt;&lt; endl;    }} <span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span> {<span class="hljs-keyword">public</span>:    <span class="hljs-built_in">Person</span>(string name, <span class="hljs-type">int</span> age)     {        <span class="hljs-keyword">this</span>-&gt;m_Name = name;        <span class="hljs-keyword">this</span>-&gt;m_Age = age;    }    <span class="hljs-comment">//重载==</span>    <span class="hljs-type">bool</span> <span class="hljs-keyword">operator</span>==(<span class="hljs-type">const</span> Person&amp; p)     {        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>-&gt;m_Name == p.m_Name &amp;&amp; <span class="hljs-keyword">this</span>-&gt;m_Age == p.m_Age)         {            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;        }        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;    } <span class="hljs-keyword">public</span>:    string m_Name;    <span class="hljs-type">int</span> m_Age;}; <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test02</span><span class="hljs-params">()</span> </span>{     vector&lt;Person&gt; v;     <span class="hljs-comment">//创建数据</span>    <span class="hljs-function">Person <span class="hljs-title">p1</span><span class="hljs-params">(<span class="hljs-string">"aaa"</span>, <span class="hljs-number">10</span>)</span></span>;    <span class="hljs-function">Person <span class="hljs-title">p2</span><span class="hljs-params">(<span class="hljs-string">"bbb"</span>, <span class="hljs-number">20</span>)</span></span>;    <span class="hljs-function">Person <span class="hljs-title">p3</span><span class="hljs-params">(<span class="hljs-string">"ccc"</span>, <span class="hljs-number">30</span>)</span></span>;    <span class="hljs-function">Person <span class="hljs-title">p4</span><span class="hljs-params">(<span class="hljs-string">"ddd"</span>, <span class="hljs-number">40</span>)</span></span>;     v.<span class="hljs-built_in">push_back</span>(p1);    v.<span class="hljs-built_in">push_back</span>(p2);    v.<span class="hljs-built_in">push_back</span>(p3);    v.<span class="hljs-built_in">push_back</span>(p4);     vector&lt;Person&gt;::iterator it = <span class="hljs-built_in">find</span>(v.<span class="hljs-built_in">begin</span>(), v.<span class="hljs-built_in">end</span>(), p2);    <span class="hljs-keyword">if</span> (it == v.<span class="hljs-built_in">end</span>())     {        cout &lt;&lt; <span class="hljs-string">"没有找到!"</span> &lt;&lt; endl;    }    <span class="hljs-keyword">else</span>     {        cout &lt;&lt; <span class="hljs-string">"找到姓名:"</span> &lt;&lt; it-&gt;m_Name &lt;&lt; <span class="hljs-string">" 年龄: "</span> &lt;&lt; it-&gt;m_Age &lt;&lt; endl;    }}</code></pre></div><p>总结： 利用find可以在容器中找指定的元素，返回值是<strong>迭代器</strong></p><h4><span id="5-2-2-find-if">5.2.2 find_if</span><a href="#5-2-2-find-if" class="header-anchor">#</a></h4><p><strong>功能描述：</strong></p><ul><li>按条件查找元素</li></ul><p><strong>函数原型：</strong></p><ul><li><p><code>find_if(iterator beg, iterator end, _Pred);</code></p><p>// 按值查找元素，找到返回指定位置迭代器，找不到返回结束迭代器位置</p><p>// beg 开始迭代器</p><p>// end 结束迭代器</p><p>// _Pred 函数或者谓词（返回bool类型的仿函数）</p></li></ul><p><strong>示例：</strong></p><div class="code-wrapper"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span> <span class="hljs-comment">//内置数据类型</span><span class="hljs-keyword">class</span> <span class="hljs-title class_">GreaterFive</span>{<span class="hljs-keyword">public</span>:    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">operator</span><span class="hljs-params">()</span><span class="hljs-params">(<span class="hljs-type">int</span> val)</span></span><span class="hljs-function">    </span>{        <span class="hljs-keyword">return</span> val &gt; <span class="hljs-number">5</span>;    }}; <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test01</span><span class="hljs-params">()</span> </span>{     vector&lt;<span class="hljs-type">int</span>&gt; v;    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++) {        v.<span class="hljs-built_in">push_back</span>(i + <span class="hljs-number">1</span>);    }     vector&lt;<span class="hljs-type">int</span>&gt;::iterator it = <span class="hljs-built_in">find_if</span>(v.<span class="hljs-built_in">begin</span>(), v.<span class="hljs-built_in">end</span>(), <span class="hljs-built_in">GreaterFive</span>());    <span class="hljs-keyword">if</span> (it == v.<span class="hljs-built_in">end</span>()) {        cout &lt;&lt; <span class="hljs-string">"没有找到!"</span> &lt;&lt; endl;    }    <span class="hljs-keyword">else</span> {        cout &lt;&lt; <span class="hljs-string">"找到大于5的数字:"</span> &lt;&lt; *it &lt;&lt; endl;    }} <span class="hljs-comment">//自定义数据类型</span><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span> {<span class="hljs-keyword">public</span>:    <span class="hljs-built_in">Person</span>(string name, <span class="hljs-type">int</span> age)    {        <span class="hljs-keyword">this</span>-&gt;m_Name = name;        <span class="hljs-keyword">this</span>-&gt;m_Age = age;    }<span class="hljs-keyword">public</span>:    string m_Name;    <span class="hljs-type">int</span> m_Age;}; <span class="hljs-keyword">class</span> <span class="hljs-title class_">Greater20</span>{<span class="hljs-keyword">public</span>:    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">operator</span><span class="hljs-params">()</span><span class="hljs-params">(Person &amp;p)</span></span><span class="hljs-function">    </span>{        <span class="hljs-keyword">return</span> p.m_Age &gt; <span class="hljs-number">20</span>;    } }; <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test02</span><span class="hljs-params">()</span> </span>{     vector&lt;Person&gt; v;     <span class="hljs-comment">//创建数据</span>    <span class="hljs-function">Person <span class="hljs-title">p1</span><span class="hljs-params">(<span class="hljs-string">"aaa"</span>, <span class="hljs-number">10</span>)</span></span>;    <span class="hljs-function">Person <span class="hljs-title">p2</span><span class="hljs-params">(<span class="hljs-string">"bbb"</span>, <span class="hljs-number">20</span>)</span></span>;    <span class="hljs-function">Person <span class="hljs-title">p3</span><span class="hljs-params">(<span class="hljs-string">"ccc"</span>, <span class="hljs-number">30</span>)</span></span>;    <span class="hljs-function">Person <span class="hljs-title">p4</span><span class="hljs-params">(<span class="hljs-string">"ddd"</span>, <span class="hljs-number">40</span>)</span></span>;     v.<span class="hljs-built_in">push_back</span>(p1);    v.<span class="hljs-built_in">push_back</span>(p2);    v.<span class="hljs-built_in">push_back</span>(p3);    v.<span class="hljs-built_in">push_back</span>(p4);     vector&lt;Person&gt;::iterator it = <span class="hljs-built_in">find_if</span>(v.<span class="hljs-built_in">begin</span>(), v.<span class="hljs-built_in">end</span>(), <span class="hljs-built_in">Greater20</span>());    <span class="hljs-keyword">if</span> (it == v.<span class="hljs-built_in">end</span>())    {        cout &lt;&lt; <span class="hljs-string">"没有找到!"</span> &lt;&lt; endl;    }    <span class="hljs-keyword">else</span>    {        cout &lt;&lt; <span class="hljs-string">"找到姓名:"</span> &lt;&lt; it-&gt;m_Name &lt;&lt; <span class="hljs-string">" 年龄: "</span> &lt;&lt; it-&gt;m_Age &lt;&lt; endl;    }} <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>{     <span class="hljs-comment">//test01();</span>     <span class="hljs-built_in">test02</span>();     <span class="hljs-built_in">system</span>(<span class="hljs-string">"pause"</span>);     <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;}</code></pre></div><p>总结：find_if按条件查找使查找更加灵活，提供的仿函数可以改变不同的策略</p><h4><span id="5-2-3-adjacent-find">5.2.3 adjacent_find</span><a href="#5-2-3-adjacent-find" class="header-anchor">#</a></h4><p><strong>功能描述：</strong></p><ul><li>查找相邻重复元素</li></ul><p><strong>函数原型：</strong></p><ul><li><p><code>adjacent_find(iterator beg, iterator end);</code></p><p>// 查找相邻重复元素,返回相邻元素的第一个位置的迭代器</p><p>// beg 开始迭代器</p><p>// end 结束迭代器</p></li></ul><p><strong>示例：</strong></p><div class="code-wrapper"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span> <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test01</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>{    vector&lt;<span class="hljs-type">int</span>&gt; v;    v.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">1</span>);    v.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">2</span>);    v.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">5</span>);    v.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">2</span>);    v.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">4</span>);    v.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">4</span>);    v.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">3</span>);     <span class="hljs-comment">//查找相邻重复元素</span>    vector&lt;<span class="hljs-type">int</span>&gt;::iterator it = <span class="hljs-built_in">adjacent_find</span>(v.<span class="hljs-built_in">begin</span>(), v.<span class="hljs-built_in">end</span>());    <span class="hljs-keyword">if</span> (it == v.<span class="hljs-built_in">end</span>()) {        cout &lt;&lt; <span class="hljs-string">"找不到!"</span> &lt;&lt; endl;    }    <span class="hljs-keyword">else</span> {        cout &lt;&lt; <span class="hljs-string">"找到相邻重复元素为:"</span> &lt;&lt; *it &lt;&lt; endl;    }}</code></pre></div><p>总结：面试题中如果出现查找相邻重复元素，记得用STL中的adjacent_find算法</p><h4><span id="5-2-4-binary-search">5.2.4 binary_search</span><a href="#5-2-4-binary-search" class="header-anchor">#</a></h4><p><strong>功能描述：</strong></p><ul><li>查找指定元素是否存在</li></ul><p><strong>函数原型：</strong></p><ul><li><p><code>bool binary_search(iterator beg, iterator end, value);</code></p><p>// 查找指定的元素，查到 返回true 否则false</p><p>// 注意: 在<strong>无序序列中不可用</strong></p><p>// beg 开始迭代器</p><p>// end 结束迭代器</p><p>// value 查找的元素</p></li></ul><p><strong>示例：</strong></p><div class="code-wrapper"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span> <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test01</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>{    vector&lt;<span class="hljs-type">int</span>&gt;v;     <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++)    {        v.<span class="hljs-built_in">push_back</span>(i);    }    <span class="hljs-comment">//二分查找</span>    <span class="hljs-type">bool</span> ret = <span class="hljs-built_in">binary_search</span>(v.<span class="hljs-built_in">begin</span>(), v.<span class="hljs-built_in">end</span>(),<span class="hljs-number">2</span>);    <span class="hljs-keyword">if</span> (ret)    {        cout &lt;&lt; <span class="hljs-string">"找到了"</span> &lt;&lt; endl;    }    <span class="hljs-keyword">else</span>    {        cout &lt;&lt; <span class="hljs-string">"未找到"</span> &lt;&lt; endl;    }} <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>{     <span class="hljs-built_in">test01</span>();     <span class="hljs-built_in">system</span>(<span class="hljs-string">"pause"</span>);     <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;}</code></pre></div><p><strong>总结：</strong>二分查找法查找效率很高，值得注意的是查找的容器中元素必须的有序序列</p><h4><span id="5-2-5-count">5.2.5 count</span><a href="#5-2-5-count" class="header-anchor">#</a></h4><p><strong>功能描述：</strong></p><ul><li>统计元素个数</li></ul><p><strong>函数原型：</strong></p><ul><li><p><code>count(iterator beg, iterator end, value);</code></p><p>// 统计元素出现次数</p><p>// beg 开始迭代器</p><p>// end 结束迭代器</p><p>// value 统计的元素</p></li></ul><p><strong>示例：</strong></p><div class="code-wrapper"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span> <span class="hljs-comment">//内置数据类型</span><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test01</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>{    vector&lt;<span class="hljs-type">int</span>&gt; v;    v.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">1</span>);    v.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">2</span>);    v.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">4</span>);    v.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">5</span>);    v.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">3</span>);    v.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">4</span>);    v.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">4</span>);     <span class="hljs-type">int</span> num = <span class="hljs-built_in">count</span>(v.<span class="hljs-built_in">begin</span>(), v.<span class="hljs-built_in">end</span>(), <span class="hljs-number">4</span>);     cout &lt;&lt; <span class="hljs-string">"4的个数为： "</span> &lt;&lt; num &lt;&lt; endl;} <span class="hljs-comment">//自定义数据类型</span><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span>{<span class="hljs-keyword">public</span>:    <span class="hljs-built_in">Person</span>(string name, <span class="hljs-type">int</span> age)    {        <span class="hljs-keyword">this</span>-&gt;m_Name = name;        <span class="hljs-keyword">this</span>-&gt;m_Age = age;    }    <span class="hljs-type">bool</span> <span class="hljs-keyword">operator</span>==(<span class="hljs-type">const</span> Person &amp; p)    {        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>-&gt;m_Age == p.m_Age)        {            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;        }        <span class="hljs-keyword">else</span>        {            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;        }    }    string m_Name;    <span class="hljs-type">int</span> m_Age;}; <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test02</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>{    vector&lt;Person&gt; v;     <span class="hljs-function">Person <span class="hljs-title">p1</span><span class="hljs-params">(<span class="hljs-string">"刘备"</span>, <span class="hljs-number">35</span>)</span></span>;    <span class="hljs-function">Person <span class="hljs-title">p2</span><span class="hljs-params">(<span class="hljs-string">"关羽"</span>, <span class="hljs-number">35</span>)</span></span>;    <span class="hljs-function">Person <span class="hljs-title">p3</span><span class="hljs-params">(<span class="hljs-string">"张飞"</span>, <span class="hljs-number">35</span>)</span></span>;    <span class="hljs-function">Person <span class="hljs-title">p4</span><span class="hljs-params">(<span class="hljs-string">"赵云"</span>, <span class="hljs-number">30</span>)</span></span>;    <span class="hljs-function">Person <span class="hljs-title">p5</span><span class="hljs-params">(<span class="hljs-string">"曹操"</span>, <span class="hljs-number">25</span>)</span></span>;     v.<span class="hljs-built_in">push_back</span>(p1);    v.<span class="hljs-built_in">push_back</span>(p2);    v.<span class="hljs-built_in">push_back</span>(p3);    v.<span class="hljs-built_in">push_back</span>(p4);    v.<span class="hljs-built_in">push_back</span>(p5);        <span class="hljs-function">Person <span class="hljs-title">p</span><span class="hljs-params">(<span class="hljs-string">"诸葛亮"</span>,<span class="hljs-number">35</span>)</span></span>;     <span class="hljs-type">int</span> num = <span class="hljs-built_in">count</span>(v.<span class="hljs-built_in">begin</span>(), v.<span class="hljs-built_in">end</span>(), p);    cout &lt;&lt; <span class="hljs-string">"num = "</span> &lt;&lt; num &lt;&lt; endl;}<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>{     <span class="hljs-comment">//test01();</span>     <span class="hljs-built_in">test02</span>();     <span class="hljs-built_in">system</span>(<span class="hljs-string">"pause"</span>);     <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;}</code></pre></div><p><strong>总结：</strong> 统计自定义数据类型时候，需要配合重载 <code>operator==</code></p><h4><span id="5-2-6-count-if">5.2.6 count_if</span><a href="#5-2-6-count-if" class="header-anchor">#</a></h4><p><strong>功能描述：</strong></p><ul><li>按条件统计元素个数</li></ul><p><strong>函数原型：</strong></p><ul><li><p><code>count_if(iterator beg, iterator end, _Pred);</code></p><p>// 按条件统计元素出现次数</p><p>// beg 开始迭代器</p><p>// end 结束迭代器</p><p>// _Pred 谓词</p></li></ul><p><strong>示例：</strong></p><div class="code-wrapper"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Greater4</span>{<span class="hljs-keyword">public</span>:    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">operator</span><span class="hljs-params">()</span><span class="hljs-params">(<span class="hljs-type">int</span> val)</span></span><span class="hljs-function">    </span>{        <span class="hljs-keyword">return</span> val &gt;= <span class="hljs-number">4</span>;    }}; <span class="hljs-comment">//内置数据类型</span><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test01</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>{    vector&lt;<span class="hljs-type">int</span>&gt; v;    v.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">1</span>);    v.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">2</span>);    v.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">4</span>);    v.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">5</span>);    v.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">3</span>);    v.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">4</span>);    v.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">4</span>);     <span class="hljs-type">int</span> num = <span class="hljs-built_in">count_if</span>(v.<span class="hljs-built_in">begin</span>(), v.<span class="hljs-built_in">end</span>(), <span class="hljs-built_in">Greater4</span>());     cout &lt;&lt; <span class="hljs-string">"大于4的个数为： "</span> &lt;&lt; num &lt;&lt; endl;} <span class="hljs-comment">//自定义数据类型</span><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span>{<span class="hljs-keyword">public</span>:    <span class="hljs-built_in">Person</span>(string name, <span class="hljs-type">int</span> age)    {        <span class="hljs-keyword">this</span>-&gt;m_Name = name;        <span class="hljs-keyword">this</span>-&gt;m_Age = age;    }     string m_Name;    <span class="hljs-type">int</span> m_Age;}; <span class="hljs-keyword">class</span> <span class="hljs-title class_">AgeLess35</span>{<span class="hljs-keyword">public</span>:    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">operator</span><span class="hljs-params">()</span><span class="hljs-params">(<span class="hljs-type">const</span> Person &amp;p)</span></span><span class="hljs-function">    </span>{        <span class="hljs-keyword">return</span> p.m_Age &lt; <span class="hljs-number">35</span>;    }};<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test02</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>{    vector&lt;Person&gt; v;     <span class="hljs-function">Person <span class="hljs-title">p1</span><span class="hljs-params">(<span class="hljs-string">"刘备"</span>, <span class="hljs-number">35</span>)</span></span>;    <span class="hljs-function">Person <span class="hljs-title">p2</span><span class="hljs-params">(<span class="hljs-string">"关羽"</span>, <span class="hljs-number">35</span>)</span></span>;    <span class="hljs-function">Person <span class="hljs-title">p3</span><span class="hljs-params">(<span class="hljs-string">"张飞"</span>, <span class="hljs-number">35</span>)</span></span>;    <span class="hljs-function">Person <span class="hljs-title">p4</span><span class="hljs-params">(<span class="hljs-string">"赵云"</span>, <span class="hljs-number">30</span>)</span></span>;    <span class="hljs-function">Person <span class="hljs-title">p5</span><span class="hljs-params">(<span class="hljs-string">"曹操"</span>, <span class="hljs-number">25</span>)</span></span>;     v.<span class="hljs-built_in">push_back</span>(p1);    v.<span class="hljs-built_in">push_back</span>(p2);    v.<span class="hljs-built_in">push_back</span>(p3);    v.<span class="hljs-built_in">push_back</span>(p4);    v.<span class="hljs-built_in">push_back</span>(p5);     <span class="hljs-type">int</span> num = <span class="hljs-built_in">count_if</span>(v.<span class="hljs-built_in">begin</span>(), v.<span class="hljs-built_in">end</span>(), <span class="hljs-built_in">AgeLess35</span>());    cout &lt;&lt; <span class="hljs-string">"小于35岁的个数："</span> &lt;&lt; num &lt;&lt; endl;}  <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>{     <span class="hljs-comment">//test01();</span>     <span class="hljs-built_in">test02</span>();     <span class="hljs-built_in">system</span>(<span class="hljs-string">"pause"</span>);     <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;}</code></pre></div><p><strong>总结：</strong>按值统计用count，按条件统计用count_if</p><h3><span id="5-3-chang-yong-pai-xu-suan-fa">5.3 常用排序算法</span><a href="#5-3-chang-yong-pai-xu-suan-fa" class="header-anchor">#</a></h3><p><strong>学习目标：</strong></p><ul><li>掌握常用的排序算法</li></ul><p><strong>算法简介：</strong></p><ul><li><code>sort</code> //对容器内元素进行排序</li><li><code>random_shuffle</code> //洗牌 指定范围内的元素随机调整次序</li><li><code>merge </code>// 容器元素合并，并存储到另一容器中</li><li><code>reverse</code> // 反转指定范围的元素</li></ul><h4><span id="5-3-1-sort">5.3.1 sort</span><a href="#5-3-1-sort" class="header-anchor">#</a></h4><p><strong>功能描述：</strong></p><ul><li>对容器内元素进行排序</li></ul><p><strong>函数原型：</strong></p><ul><li><p><code>sort(iterator beg, iterator end, _Pred);</code></p><p>// 按值查找元素，找到返回指定位置迭代器，找不到返回结束迭代器位置</p><p>// beg 开始迭代器</p><p>// end 结束迭代器</p><p>// _Pred 谓词</p></li></ul><p><strong>示例：</strong></p><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span> <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">myPrint</span><span class="hljs-params">(<span class="hljs-type">int</span> val)</span></span><span class="hljs-function"></span>{    cout &lt;&lt; val &lt;&lt; <span class="hljs-string">" "</span>;} <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test01</span><span class="hljs-params">()</span> </span>{    vector&lt;<span class="hljs-type">int</span>&gt; v;    v.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">10</span>);    v.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">30</span>);    v.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">50</span>);    v.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">20</span>);    v.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">40</span>);     <span class="hljs-comment">//sort默认从小到大排序</span>    <span class="hljs-built_in">sort</span>(v.<span class="hljs-built_in">begin</span>(), v.<span class="hljs-built_in">end</span>());    for_each(v.<span class="hljs-built_in">begin</span>(), v.<span class="hljs-built_in">end</span>(), myPrint);    cout &lt;&lt; endl;     <span class="hljs-comment">//从大到小排序</span>    <span class="hljs-built_in">sort</span>(v.<span class="hljs-built_in">begin</span>(), v.<span class="hljs-built_in">end</span>(), <span class="hljs-built_in">greater</span>&lt;<span class="hljs-type">int</span>&gt;());    for_each(v.<span class="hljs-built_in">begin</span>(), v.<span class="hljs-built_in">end</span>(), myPrint);    cout &lt;&lt; endl;} <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>{     <span class="hljs-built_in">test01</span>();     <span class="hljs-built_in">system</span>(<span class="hljs-string">"pause"</span>);     <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;}</code></pre></div><p><strong>总结：</strong>sort属于开发中最常用的算法之一，需熟练掌握</p><h4><span id="5-3-2-shuffle">5.3.2 shuffle</span><a href="#5-3-2-shuffle" class="header-anchor">#</a></h4><p><strong>功能描述：</strong></p><ul><li>洗牌 指定范围内的元素随机调整次序</li></ul><p><strong>函数原型：</strong></p><ul><li><p>`shuffle(iterator beg, iterator end, std::mt19937{std::random_device{}()});</p><p>// 指定范围内的元素随机调整次序</p><p>// beg 开始迭代器</p><p>// end 结束迭代器</p><p>// std::mt19937{std::random_device{}()}随机数生成器</p></li></ul><p><strong>示例：</strong></p><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;ctime&gt;</span></span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">myPrint</span>{<span class="hljs-keyword">public</span>:    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">operator</span><span class="hljs-params">()</span><span class="hljs-params">(<span class="hljs-type">int</span> val)</span></span><span class="hljs-function">    </span>{        cout &lt;&lt; val &lt;&lt; <span class="hljs-string">" "</span>;    }}; <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test01</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>{    <span class="hljs-built_in">srand</span>((<span class="hljs-type">unsigned</span> <span class="hljs-type">int</span>)<span class="hljs-built_in">time</span>(<span class="hljs-literal">NULL</span>));    vector&lt;<span class="hljs-type">int</span>&gt; v;    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span> ; i &lt; <span class="hljs-number">10</span>;i++)    {        v.<span class="hljs-built_in">push_back</span>(i);    }    for_each(v.<span class="hljs-built_in">begin</span>(), v.<span class="hljs-built_in">end</span>(), <span class="hljs-built_in">myPrint</span>());    cout &lt;&lt; endl;     <span class="hljs-comment">//打乱顺序</span>    <span class="hljs-built_in">shuffle</span>(v.<span class="hljs-built_in">begin</span>(), v.<span class="hljs-built_in">end</span>(), std::mt19937{std::random_device{}()});    for_each(v.<span class="hljs-built_in">begin</span>(), v.<span class="hljs-built_in">end</span>(), <span class="hljs-built_in">myPrint</span>());    cout &lt;&lt; endl;} <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>{     <span class="hljs-built_in">test01</span>();     <span class="hljs-built_in">system</span>(<span class="hljs-string">"pause"</span>);     <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;}</code></pre></div><p><strong>总结：</strong>shuffle洗牌算法比较实用，使用时记得加随机数种子</p><h4><span id="5-3-3-merge">5.3.3 merge</span><a href="#5-3-3-merge" class="header-anchor">#</a></h4><p><strong>功能描述：</strong></p><ul><li>两个容器元素合并，并存储到另一容器中</li></ul><p><strong>函数原型：</strong></p><ul><li><p><code>merge(iterator beg1, iterator end1, iterator beg2, iterator end2, iterator dest);</code></p><p>// 容器元素合并，并存储到另一容器中</p><p>// 注意: 两个容器必须是<strong>有序的</strong></p><p>// beg1 容器1开始迭代器 // end1 容器1结束迭代器 // beg2 容器2开始迭代器 // end2 容器2结束迭代器 // dest 目标容器开始迭代器</p></li></ul><p><strong>示例：</strong></p><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">myPrint</span>{<span class="hljs-keyword">public</span>:    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">operator</span><span class="hljs-params">()</span><span class="hljs-params">(<span class="hljs-type">int</span> val)</span></span><span class="hljs-function">    </span>{        cout &lt;&lt; val &lt;&lt; <span class="hljs-string">" "</span>;    }}; <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test01</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>{    vector&lt;<span class="hljs-type">int</span>&gt; v1;    vector&lt;<span class="hljs-type">int</span>&gt; v2;    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span> ; i++)     {        v1.<span class="hljs-built_in">push_back</span>(i);        v2.<span class="hljs-built_in">push_back</span>(i + <span class="hljs-number">1</span>);    }     vector&lt;<span class="hljs-type">int</span>&gt; vtarget;    <span class="hljs-comment">//目标容器需要提前开辟空间</span>    vtarget.<span class="hljs-built_in">resize</span>(v1.<span class="hljs-built_in">size</span>() + v2.<span class="hljs-built_in">size</span>());    <span class="hljs-comment">//合并  需要两个有序序列</span>    <span class="hljs-built_in">merge</span>(v1.<span class="hljs-built_in">begin</span>(), v1.<span class="hljs-built_in">end</span>(), v2.<span class="hljs-built_in">begin</span>(), v2.<span class="hljs-built_in">end</span>(), vtarget.<span class="hljs-built_in">begin</span>());    for_each(vtarget.<span class="hljs-built_in">begin</span>(), vtarget.<span class="hljs-built_in">end</span>(), <span class="hljs-built_in">myPrint</span>());    cout &lt;&lt; endl;} <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>{     <span class="hljs-built_in">test01</span>();     <span class="hljs-built_in">system</span>(<span class="hljs-string">"pause"</span>);     <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;}</code></pre></div><p><strong>总结：</strong>merge合并的两个容器必须的有序序列</p><h4><span id="5-3-4-reverse">5.3.4 reverse</span><a href="#5-3-4-reverse" class="header-anchor">#</a></h4><p><strong>功能描述：</strong></p><ul><li>将容器内元素进行反转</li></ul><p><strong>函数原型：</strong></p><ul><li><p><code>reverse(iterator beg, iterator end);</code></p><p>// 反转指定范围的元素</p><p>// beg 开始迭代器</p><p>// end 结束迭代器</p></li></ul><p><strong>示例：</strong></p><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">myPrint</span>{<span class="hljs-keyword">public</span>:    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">operator</span><span class="hljs-params">()</span><span class="hljs-params">(<span class="hljs-type">int</span> val)</span></span><span class="hljs-function">    </span>{        cout &lt;&lt; val &lt;&lt; <span class="hljs-string">" "</span>;    }}; <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test01</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>{    vector&lt;<span class="hljs-type">int</span>&gt; v;    v.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">10</span>);    v.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">30</span>);    v.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">50</span>);    v.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">20</span>);    v.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">40</span>);     cout &lt;&lt; <span class="hljs-string">"反转前： "</span> &lt;&lt; endl;    for_each(v.<span class="hljs-built_in">begin</span>(), v.<span class="hljs-built_in">end</span>(), <span class="hljs-built_in">myPrint</span>());    cout &lt;&lt; endl;     cout &lt;&lt; <span class="hljs-string">"反转后： "</span> &lt;&lt; endl;     <span class="hljs-built_in">reverse</span>(v.<span class="hljs-built_in">begin</span>(), v.<span class="hljs-built_in">end</span>());    for_each(v.<span class="hljs-built_in">begin</span>(), v.<span class="hljs-built_in">end</span>(), <span class="hljs-built_in">myPrint</span>());    cout &lt;&lt; endl;} <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>{     <span class="hljs-built_in">test01</span>();     <span class="hljs-built_in">system</span>(<span class="hljs-string">"pause"</span>);     <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;}</code></pre></div><p><strong>总结：</strong>reverse反转区间内元素，面试题可能涉及到</p><h3><span id="5-4-chang-yong-kao-bei-he-ti-huan-suan-fa">5.4 常用拷贝和替换算法</span><a href="#5-4-chang-yong-kao-bei-he-ti-huan-suan-fa" class="header-anchor">#</a></h3><p><strong>学习目标：</strong></p><ul><li>掌握常用的拷贝和替换算法</li></ul><p><strong>算法简介：</strong></p><ul><li><code>copy</code> // 容器内指定范围的元素拷贝到另一容器中</li><li><code>replace</code> // 将容器内指定范围的旧元素修改为新元素</li><li><code>replace_if </code>// 容器内指定范围满足条件的元素替换为新元素</li><li><code>swap</code> // 互换两个容器的元素</li></ul><h4><span id="5-4-1-copy">5.4.1 copy</span><a href="#5-4-1-copy" class="header-anchor">#</a></h4><p><strong>功能描述：</strong></p><ul><li>容器内指定范围的元素拷贝到另一容器中</li></ul><p><strong>函数原型：</strong></p><ul><li><p><code>copy(iterator beg, iterator end, iterator dest);</code></p><p>// 按值查找元素，找到返回指定位置迭代器，找不到返回结束迭代器位置</p><p>// beg 开始迭代器</p><p>// end 结束迭代器</p><p>// dest 目标起始迭代器</p></li></ul><p><strong>示例：</strong></p><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">myPrint</span>{<span class="hljs-keyword">public</span>:    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">operator</span><span class="hljs-params">()</span><span class="hljs-params">(<span class="hljs-type">int</span> val)</span></span><span class="hljs-function">    </span>{        cout &lt;&lt; val &lt;&lt; <span class="hljs-string">" "</span>;    }}; <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test01</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>{    vector&lt;<span class="hljs-type">int</span>&gt; v1;    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++) {        v1.<span class="hljs-built_in">push_back</span>(i + <span class="hljs-number">1</span>);    }    vector&lt;<span class="hljs-type">int</span>&gt; v2;    v2.<span class="hljs-built_in">resize</span>(v1.<span class="hljs-built_in">size</span>());    <span class="hljs-built_in">copy</span>(v1.<span class="hljs-built_in">begin</span>(), v1.<span class="hljs-built_in">end</span>(), v2.<span class="hljs-built_in">begin</span>());     for_each(v2.<span class="hljs-built_in">begin</span>(), v2.<span class="hljs-built_in">end</span>(), <span class="hljs-built_in">myPrint</span>());    cout &lt;&lt; endl;} <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>{     <span class="hljs-built_in">test01</span>();     <span class="hljs-built_in">system</span>(<span class="hljs-string">"pause"</span>);     <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;}</code></pre></div><p><strong>总结：</strong>利用copy算法在拷贝时，目标容器记得提前开辟空间</p><h4><span id="5-4-2-replace">5.4.2 replace</span><a href="#5-4-2-replace" class="header-anchor">#</a></h4><p><strong>功能描述：</strong></p><ul><li>将容器内指定范围的旧元素修改为新元素</li></ul><p><strong>函数原型：</strong></p><ul><li><p><code>replace(iterator beg, iterator end, oldvalue, newvalue);</code></p><p>// 将区间内旧元素 替换成 新元素</p><p>// beg 开始迭代器</p><p>// end 结束迭代器</p><p>// oldvalue 旧元素</p><p>// newvalue 新元素</p></li></ul><p><strong>示例：</strong></p><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">myPrint</span>{<span class="hljs-keyword">public</span>:    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">operator</span><span class="hljs-params">()</span><span class="hljs-params">(<span class="hljs-type">int</span> val)</span></span><span class="hljs-function">    </span>{        cout &lt;&lt; val &lt;&lt; <span class="hljs-string">" "</span>;    }}; <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test01</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>{    vector&lt;<span class="hljs-type">int</span>&gt; v;    v.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">20</span>);    v.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">30</span>);    v.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">20</span>);    v.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">40</span>);    v.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">50</span>);    v.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">10</span>);    v.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">20</span>);     cout &lt;&lt; <span class="hljs-string">"替换前："</span> &lt;&lt; endl;    for_each(v.<span class="hljs-built_in">begin</span>(), v.<span class="hljs-built_in">end</span>(), <span class="hljs-built_in">myPrint</span>());    cout &lt;&lt; endl;     <span class="hljs-comment">//将容器中的20 替换成 2000</span>    cout &lt;&lt; <span class="hljs-string">"替换后："</span> &lt;&lt; endl;    <span class="hljs-built_in">replace</span>(v.<span class="hljs-built_in">begin</span>(), v.<span class="hljs-built_in">end</span>(), <span class="hljs-number">20</span>,<span class="hljs-number">2000</span>);    for_each(v.<span class="hljs-built_in">begin</span>(), v.<span class="hljs-built_in">end</span>(), <span class="hljs-built_in">myPrint</span>());    cout &lt;&lt; endl;} <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>{     <span class="hljs-built_in">test01</span>();     <span class="hljs-built_in">system</span>(<span class="hljs-string">"pause"</span>);     <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;}</code></pre></div><p><strong>总结：</strong>replace会替换区间内满足条件的元素</p><h4><span id="5-4-3-replace-if">5.4.3 replace_if</span><a href="#5-4-3-replace-if" class="header-anchor">#</a></h4><p><strong>功能描述:</strong></p><ul><li>将区间内满足条件的元素，替换成指定元素</li></ul><p><strong>函数原型：</strong></p><ul><li><p><code>replace_if(iterator beg, iterator end, _pred, newvalue);</code></p><p>// 按条件替换元素，满足条件的替换成指定元素</p><p>// beg 开始迭代器</p><p>// end 结束迭代器</p><p>// _pred 谓词</p><p>// newvalue 替换的新元素</p></li></ul><p><strong>示例：</strong></p><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">myPrint</span>{<span class="hljs-keyword">public</span>:    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">operator</span><span class="hljs-params">()</span><span class="hljs-params">(<span class="hljs-type">int</span> val)</span></span><span class="hljs-function">    </span>{        cout &lt;&lt; val &lt;&lt; <span class="hljs-string">" "</span>;    }}; <span class="hljs-keyword">class</span> <span class="hljs-title class_">ReplaceGreater30</span>{<span class="hljs-keyword">public</span>:    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">operator</span><span class="hljs-params">()</span><span class="hljs-params">(<span class="hljs-type">int</span> val)</span></span><span class="hljs-function">    </span>{        <span class="hljs-keyword">return</span> val &gt;= <span class="hljs-number">30</span>;    } }; <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test01</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>{    vector&lt;<span class="hljs-type">int</span>&gt; v;    v.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">20</span>);    v.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">30</span>);    v.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">20</span>);    v.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">40</span>);    v.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">50</span>);    v.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">10</span>);    v.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">20</span>);     cout &lt;&lt; <span class="hljs-string">"替换前："</span> &lt;&lt; endl;    for_each(v.<span class="hljs-built_in">begin</span>(), v.<span class="hljs-built_in">end</span>(), <span class="hljs-built_in">myPrint</span>());    cout &lt;&lt; endl;     <span class="hljs-comment">//将容器中大于等于的30 替换成 3000</span>    cout &lt;&lt; <span class="hljs-string">"替换后："</span> &lt;&lt; endl;    <span class="hljs-built_in">replace_if</span>(v.<span class="hljs-built_in">begin</span>(), v.<span class="hljs-built_in">end</span>(), <span class="hljs-built_in">ReplaceGreater30</span>(), <span class="hljs-number">3000</span>);    for_each(v.<span class="hljs-built_in">begin</span>(), v.<span class="hljs-built_in">end</span>(), <span class="hljs-built_in">myPrint</span>());    cout &lt;&lt; endl;} <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>{     <span class="hljs-built_in">test01</span>();     <span class="hljs-built_in">system</span>(<span class="hljs-string">"pause"</span>);     <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;}</code></pre></div><p><strong>总结：</strong>replace_if按条件查找，可以利用仿函数灵活筛选满足的条件</p><h4><span id="5-4-4-swap">5.4.4 swap</span><a href="#5-4-4-swap" class="header-anchor">#</a></h4><p><strong>功能描述：</strong></p><ul><li>互换两个容器的元素</li></ul><p><strong>函数原型：</strong></p><ul><li><p><code>swap(container c1, container c2);</code></p><p>// 互换两个容器的元素</p><p>// c1容器1</p><p>// c2容器2</p></li></ul><p><strong>示例：</strong></p><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">myPrint</span>{<span class="hljs-keyword">public</span>:    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">operator</span><span class="hljs-params">()</span><span class="hljs-params">(<span class="hljs-type">int</span> val)</span></span><span class="hljs-function">    </span>{        cout &lt;&lt; val &lt;&lt; <span class="hljs-string">" "</span>;    }}; <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test01</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>{    vector&lt;<span class="hljs-type">int</span>&gt; v1;    vector&lt;<span class="hljs-type">int</span>&gt; v2;    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++) {        v1.<span class="hljs-built_in">push_back</span>(i);        v2.<span class="hljs-built_in">push_back</span>(i+<span class="hljs-number">100</span>);    }     cout &lt;&lt; <span class="hljs-string">"交换前： "</span> &lt;&lt; endl;    for_each(v1.<span class="hljs-built_in">begin</span>(), v1.<span class="hljs-built_in">end</span>(), <span class="hljs-built_in">myPrint</span>());    cout &lt;&lt; endl;    for_each(v2.<span class="hljs-built_in">begin</span>(), v2.<span class="hljs-built_in">end</span>(), <span class="hljs-built_in">myPrint</span>());    cout &lt;&lt; endl;     cout &lt;&lt; <span class="hljs-string">"交换后： "</span> &lt;&lt; endl;    <span class="hljs-built_in">swap</span>(v1, v2);    for_each(v1.<span class="hljs-built_in">begin</span>(), v1.<span class="hljs-built_in">end</span>(), <span class="hljs-built_in">myPrint</span>());    cout &lt;&lt; endl;    for_each(v2.<span class="hljs-built_in">begin</span>(), v2.<span class="hljs-built_in">end</span>(), <span class="hljs-built_in">myPrint</span>());    cout &lt;&lt; endl;} <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>{     <span class="hljs-built_in">test01</span>();     <span class="hljs-built_in">system</span>(<span class="hljs-string">"pause"</span>);     <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;}</code></pre></div><p><strong>总结：</strong>swap交换容器时，注意交换的容器要同种类型</p><h3><span id="5-5-chang-yong-suan-zhu-sheng-cheng-suan-fa">5.5 常用算术生成算法</span><a href="#5-5-chang-yong-suan-zhu-sheng-cheng-suan-fa" class="header-anchor">#</a></h3><p><strong>学习目标：</strong></p><ul><li>掌握常用的算术生成算法</li></ul><p><strong>注意：</strong></p><ul><li>算术生成算法属于小型算法，使用时包含的头文件为 <code>#include </code><numeric></numeric></li></ul><p><strong>算法简介：</strong></p><ul><li><code>accumulate</code> // 计算容器元素累计总和</li><li><code>fill</code> // 向容器中添加元素</li><li>iota // 向容器中填充元素</li></ul><h4><span id="5-5-1-accumulate">5.5.1 accumulate</span><a href="#5-5-1-accumulate" class="header-anchor">#</a></h4><p><strong>功能描述：</strong></p><ul><li>计算区间内 容器元素累计总和</li></ul><p><strong>函数原型：</strong></p><ul><li><p><code>accumulate(iterator beg, iterator end, value);</code></p><p>// 计算容器元素累计总和</p><p>// beg 开始迭代器</p><p>// end 结束迭代器</p><p>// value 起始值</p></li></ul><p><strong>示例：</strong></p><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;numeric&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test01</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>{    vector&lt;<span class="hljs-type">int</span>&gt; v;    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt;= <span class="hljs-number">100</span>; i++) {        v.<span class="hljs-built_in">push_back</span>(i);    }     <span class="hljs-type">int</span> total = <span class="hljs-built_in">accumulate</span>(v.<span class="hljs-built_in">begin</span>(), v.<span class="hljs-built_in">end</span>(), <span class="hljs-number">0</span>);     cout &lt;&lt; <span class="hljs-string">"total = "</span> &lt;&lt; total &lt;&lt; endl;} <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>{     <span class="hljs-built_in">test01</span>();     <span class="hljs-built_in">system</span>(<span class="hljs-string">"pause"</span>);     <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;}</code></pre></div><p><strong>总结：</strong>accumulate使用时头文件注意是 numeric，这个算法很实用</p><h4><span id="5-5-2-fill">5.5.2 fill</span><a href="#5-5-2-fill" class="header-anchor">#</a></h4><p><strong>功能描述：</strong></p><ul><li>向容器中填充指定的元素</li></ul><p><strong>函数原型：</strong></p><ul><li><p><code>fill(iterator beg, iterator end, value);</code></p><p>// 向容器中填充元素</p><p>// beg 开始迭代器</p><p>// end 结束迭代器</p><p>// value 填充的值</p></li></ul><p><strong>示例：</strong></p><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;numeric&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">myPrint</span>{<span class="hljs-keyword">public</span>:    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">operator</span><span class="hljs-params">()</span><span class="hljs-params">(<span class="hljs-type">int</span> val)</span></span><span class="hljs-function">    </span>{        cout &lt;&lt; val &lt;&lt; <span class="hljs-string">" "</span>;    }}; <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test01</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>{     vector&lt;<span class="hljs-type">int</span>&gt; v;    v.<span class="hljs-built_in">resize</span>(<span class="hljs-number">10</span>);    <span class="hljs-comment">//填充</span>    <span class="hljs-built_in">fill</span>(v.<span class="hljs-built_in">begin</span>(), v.<span class="hljs-built_in">end</span>(), <span class="hljs-number">100</span>);     for_each(v.<span class="hljs-built_in">begin</span>(), v.<span class="hljs-built_in">end</span>(), <span class="hljs-built_in">myPrint</span>());    cout &lt;&lt; endl;} <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>{     <span class="hljs-built_in">test01</span>();     <span class="hljs-built_in">system</span>(<span class="hljs-string">"pause"</span>);     <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;}</code></pre></div><p><strong>总结：</strong>利用fill可以将容器区间内元素填充为 指定的值</p><h4><span id="5-5-3-iota">5.5.3 iota</span><a href="#5-5-3-iota" class="header-anchor">#</a></h4><p><strong>功能描述：</strong></p><ul><li>用从起始值开始连续递增的值填充一个范围</li></ul><p><strong>函数原型：</strong></p><ul><li><p>iota(ForwardIterator first, ForwardIterator last, T value) </p><p>// 以value为起始值，填充以[first, last);</p></li></ul><p><strong>示例：</strong></p><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;list&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;numeric&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;random&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span> <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>{    <span class="hljs-function">std::list&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">l</span><span class="hljs-params">(<span class="hljs-number">10</span>)</span></span>;    std::<span class="hljs-built_in">iota</span>(l.<span class="hljs-built_in">begin</span>(), l.<span class="hljs-built_in">end</span>(), <span class="hljs-number">-4</span>);     std::vector&lt;std::list&lt;<span class="hljs-type">int</span>&gt;::iterator&gt; <span class="hljs-built_in">v</span>(l.<span class="hljs-built_in">size</span>());    std::<span class="hljs-built_in">iota</span>(v.<span class="hljs-built_in">begin</span>(), v.<span class="hljs-built_in">end</span>(), l.<span class="hljs-built_in">begin</span>());     std::<span class="hljs-built_in">shuffle</span>(v.<span class="hljs-built_in">begin</span>(), v.<span class="hljs-built_in">end</span>(), std::mt19937{std::random_device{}()});     std::cout &lt;&lt; <span class="hljs-string">"Contents of the list: "</span>;    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> n: l) std::cout &lt;&lt; n &lt;&lt; <span class="hljs-string">' '</span>;    std::cout &lt;&lt; <span class="hljs-string">'\n'</span>;     std::cout &lt;&lt; <span class="hljs-string">"Contents of the list, shuffled: "</span>;    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> i: v) std::cout &lt;&lt; *i &lt;&lt; <span class="hljs-string">' '</span>;    std::cout &lt;&lt; <span class="hljs-string">'\n'</span>;}</code></pre></div><p><strong>总结：</strong></p><ul><li>以value为起始值，填充以[first, last);</li></ul><h3><span id="5-6-chang-yong-ji-he-suan-fa">5.6 常用集合算法</span><a href="#5-6-chang-yong-ji-he-suan-fa" class="header-anchor">#</a></h3><p><strong>学习目标：</strong></p><ul><li>掌握常用的集合算法</li></ul><p><strong>算法简介：</strong></p><ul><li><code>set_intersection</code> // 求两个容器的交集</li><li><code>set_union</code> // 求两个容器的并集</li><li><code>set_difference </code>// 求两个容器的差集</li></ul><h4><span id="5-6-1-set-intersection">5.6.1 set_intersection</span><a href="#5-6-1-set-intersection" class="header-anchor">#</a></h4><p><strong>功能描述：</strong></p><ul><li>求两个容器的交集</li></ul><p><strong>函数原型：</strong></p><ul><li><p><code>set_intersection(iterator beg1, iterator end1, iterator beg2, iterator end2, iterator dest);</code></p><p>// 求两个集合的交集</p><p>// <strong>注意:两个集合必须是有序序列</strong></p><p>// beg1 容器1开始迭代器 // end1 容器1结束迭代器 // beg2 容器2开始迭代器 // end2 容器2结束迭代器 // dest 目标容器开始迭代器</p></li></ul><p><strong>示例：</strong></p><div class="code-wrapper"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">myPrint</span>{<span class="hljs-keyword">public</span>:    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">operator</span><span class="hljs-params">()</span><span class="hljs-params">(<span class="hljs-type">int</span> val)</span></span><span class="hljs-function">    </span>{        cout &lt;&lt; val &lt;&lt; <span class="hljs-string">" "</span>;    }}; <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test01</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>{    vector&lt;<span class="hljs-type">int</span>&gt; v1;    vector&lt;<span class="hljs-type">int</span>&gt; v2;    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++)    {        v1.<span class="hljs-built_in">push_back</span>(i);        v2.<span class="hljs-built_in">push_back</span>(i+<span class="hljs-number">5</span>);    }     vector&lt;<span class="hljs-type">int</span>&gt; vTarget;    <span class="hljs-comment">//取两个里面较小的值给目标容器开辟空间</span>    vTarget.<span class="hljs-built_in">resize</span>(<span class="hljs-built_in">min</span>(v1.<span class="hljs-built_in">size</span>(), v2.<span class="hljs-built_in">size</span>()));     <span class="hljs-comment">//返回目标容器的最后一个元素的迭代器地址</span>    vector&lt;<span class="hljs-type">int</span>&gt;::iterator itEnd =         <span class="hljs-built_in">set_intersection</span>(v1.<span class="hljs-built_in">begin</span>(), v1.<span class="hljs-built_in">end</span>(), v2.<span class="hljs-built_in">begin</span>(), v2.<span class="hljs-built_in">end</span>(), vTarget.<span class="hljs-built_in">begin</span>());     for_each(vTarget.<span class="hljs-built_in">begin</span>(), itEnd, <span class="hljs-built_in">myPrint</span>());    cout &lt;&lt; endl;} <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>{     <span class="hljs-built_in">test01</span>();     <span class="hljs-built_in">system</span>(<span class="hljs-string">"pause"</span>);     <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;}</code></pre></div><p><strong>总结：</strong></p><ul><li>求交集的两个集合必须的有序序列</li><li>目标容器开辟空间需要从<strong>两个容器中取小值</strong></li><li>set_intersection返回值既是交集中最后一个元素的位置</li></ul><h4><span id="5-6-2-set-union">5.6.2 set_union</span><a href="#5-6-2-set-union" class="header-anchor">#</a></h4><p><strong>功能描述：</strong></p><ul><li>求两个集合的并集</li></ul><p><strong>函数原型：</strong></p><ul><li><p><code>set_union(iterator beg1, iterator end1, iterator beg2, iterator end2, iterator dest);</code></p><p>// 求两个集合的并集</p><p>// <strong>注意:两个集合必须是有序序列</strong></p><p>// beg1 容器1开始迭代器 // end1 容器1结束迭代器 // beg2 容器2开始迭代器 // end2 容器2结束迭代器 // dest 目标容器开始迭代器</p></li></ul><p><strong>示例：</strong></p><div class="code-wrapper"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">myPrint</span>{<span class="hljs-keyword">public</span>:    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">operator</span><span class="hljs-params">()</span><span class="hljs-params">(<span class="hljs-type">int</span> val)</span></span><span class="hljs-function">    </span>{        cout &lt;&lt; val &lt;&lt; <span class="hljs-string">" "</span>;    }}; <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test01</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>{    vector&lt;<span class="hljs-type">int</span>&gt; v1;    vector&lt;<span class="hljs-type">int</span>&gt; v2;    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++) {        v1.<span class="hljs-built_in">push_back</span>(i);        v2.<span class="hljs-built_in">push_back</span>(i+<span class="hljs-number">5</span>);    }     vector&lt;<span class="hljs-type">int</span>&gt; vTarget;    <span class="hljs-comment">//取两个容器的和给目标容器开辟空间</span>    vTarget.<span class="hljs-built_in">resize</span>(v1.<span class="hljs-built_in">size</span>() + v2.<span class="hljs-built_in">size</span>());     <span class="hljs-comment">//返回目标容器的最后一个元素的迭代器地址</span>    vector&lt;<span class="hljs-type">int</span>&gt;::iterator itEnd =         <span class="hljs-built_in">set_union</span>(v1.<span class="hljs-built_in">begin</span>(), v1.<span class="hljs-built_in">end</span>(), v2.<span class="hljs-built_in">begin</span>(), v2.<span class="hljs-built_in">end</span>(), vTarget.<span class="hljs-built_in">begin</span>());     for_each(vTarget.<span class="hljs-built_in">begin</span>(), itEnd, <span class="hljs-built_in">myPrint</span>());    cout &lt;&lt; endl;} <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>{     <span class="hljs-built_in">test01</span>();     <span class="hljs-built_in">system</span>(<span class="hljs-string">"pause"</span>);     <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;}</code></pre></div><p><strong>总结：</strong></p><ul><li>求并集的两个集合必须的有序序列</li><li>目标容器开辟空间需要<strong>两个容器相加</strong></li><li>set_union返回值既是并集中最后一个元素的位置</li></ul><h4><span id="5-6-3-set-difference">5.6.3 set_difference</span><a href="#5-6-3-set-difference" class="header-anchor">#</a></h4><p><strong>功能描述：</strong></p><ul><li>求两个集合的差集</li></ul><p><strong>函数原型：</strong></p><ul><li><p><code>set_difference(iterator beg1, iterator end1, iterator beg2, iterator end2, iterator dest);</code></p><p>// 求两个集合的差集</p><p>// <strong>注意:两个集合必须是有序序列</strong></p><p>// beg1 容器1开始迭代器 // end1 容器1结束迭代器 // beg2 容器2开始迭代器 // end2 容器2结束迭代器 // dest 目标容器开始迭代器</p></li></ul><p><strong>示例：</strong></p><div class="code-wrapper"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">myPrint</span>{<span class="hljs-keyword">public</span>:    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">operator</span><span class="hljs-params">()</span><span class="hljs-params">(<span class="hljs-type">int</span> val)</span></span><span class="hljs-function">    </span>{        cout &lt;&lt; val &lt;&lt; <span class="hljs-string">" "</span>;    }}; <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test01</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>{    vector&lt;<span class="hljs-type">int</span>&gt; v1;    vector&lt;<span class="hljs-type">int</span>&gt; v2;    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++) {        v1.<span class="hljs-built_in">push_back</span>(i);        v2.<span class="hljs-built_in">push_back</span>(i+<span class="hljs-number">5</span>);    }     vector&lt;<span class="hljs-type">int</span>&gt; vTarget;    <span class="hljs-comment">//取两个里面较大的值给目标容器开辟空间</span>    vTarget.<span class="hljs-built_in">resize</span>( <span class="hljs-built_in">max</span>(v1.<span class="hljs-built_in">size</span>() , v2.<span class="hljs-built_in">size</span>()));     <span class="hljs-comment">//返回目标容器的最后一个元素的迭代器地址</span>    cout &lt;&lt; <span class="hljs-string">"v1与v2的差集为： "</span> &lt;&lt; endl;    vector&lt;<span class="hljs-type">int</span>&gt;::iterator itEnd =         <span class="hljs-built_in">set_difference</span>(v1.<span class="hljs-built_in">begin</span>(), v1.<span class="hljs-built_in">end</span>(), v2.<span class="hljs-built_in">begin</span>(), v2.<span class="hljs-built_in">end</span>(), vTarget.<span class="hljs-built_in">begin</span>());    for_each(vTarget.<span class="hljs-built_in">begin</span>(), itEnd, <span class="hljs-built_in">myPrint</span>());    cout &lt;&lt; endl;      cout &lt;&lt; <span class="hljs-string">"v2与v1的差集为： "</span> &lt;&lt; endl;    itEnd = <span class="hljs-built_in">set_difference</span>(v2.<span class="hljs-built_in">begin</span>(), v2.<span class="hljs-built_in">end</span>(), v1.<span class="hljs-built_in">begin</span>(), v1.<span class="hljs-built_in">end</span>(), vTarget.<span class="hljs-built_in">begin</span>());    for_each(vTarget.<span class="hljs-built_in">begin</span>(), itEnd, <span class="hljs-built_in">myPrint</span>());    cout &lt;&lt; endl;} <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>{     <span class="hljs-built_in">test01</span>();     <span class="hljs-built_in">system</span>(<span class="hljs-string">"pause"</span>);     <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;}</code></pre></div><p><strong>总结：</strong></p><ul><li>求差集的两个集合必须的有序序列</li><li>目标容器开辟空间需要从<strong>两个容器取较大值</strong></li><li>set_difference返回值既是差集中最后一个元素的位置</li></ul><h3><span id="5-7-chang-yong-bi-jiao-suan-fa">5.7 常用比较算法</span><a href="#5-7-chang-yong-bi-jiao-suan-fa" class="header-anchor">#</a></h3><p><strong>学习目标：</strong></p><ul><li>掌握常用的比较算法</li></ul><p><strong>算法简介：</strong></p><ul><li>max   // 求各给定值中的较大者</li><li>min   // 求范围中的最大元素</li><li>equal // 求两个元素集合是否是相同的</li></ul><h4><span id="5-7-1-max">5.7.1 max</span><a href="#5-7-1-max" class="header-anchor">#</a></h4><p><strong>功能描述：</strong></p><ul><li>求各给定值中的较大者</li></ul><p><strong>函数原型：</strong></p><ul><li>max( const T&amp; a, const T&amp; b );</li></ul><p>// 求各给定值中的较大者</p><p>// a为第一个元素， b为第一个元素</p><p><strong>示例：</strong></p><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>{    std::cout &lt;&lt; <span class="hljs-string">"larger of 1 and 9999: "</span> &lt;&lt; std::<span class="hljs-built_in">max</span>(<span class="hljs-number">1</span>, <span class="hljs-number">9999</span>) &lt;&lt; <span class="hljs-string">'\n'</span>        &lt;&lt; <span class="hljs-string">"larger of 'a', and 'b': "</span> &lt;&lt; std::<span class="hljs-built_in">max</span>(<span class="hljs-string">'a'</span>, <span class="hljs-string">'b'</span>) &lt;&lt; <span class="hljs-string">'\n'</span>        &lt;&lt; <span class="hljs-string">"longest of \"foo\", \"bar\", and \"hello\": "</span> &lt;&lt;        std::<span class="hljs-built_in">max</span>( { <span class="hljs-string">"foo"</span>, <span class="hljs-string">"bar"</span>, <span class="hljs-string">"hello"</span> },                 [](<span class="hljs-type">const</span> std::string&amp; s1, <span class="hljs-type">const</span> std::string&amp; s2) {                     <span class="hljs-keyword">return</span> s1.<span class="hljs-built_in">size</span>() &lt; s2.<span class="hljs-built_in">size</span>();                 }) &lt;&lt; <span class="hljs-string">'\n'</span>;}</code></pre></div><p><strong>总结：</strong></p><ul><li>返回两个元素中最大的那一个</li></ul><h4><span id="5-7-2-min">5.7.2 min</span><a href="#5-7-2-min" class="header-anchor">#</a></h4><p><strong>功能描述：</strong></p><ul><li>求范围中的最小元素</li></ul><p><strong>函数原型：</strong></p><ul><li>min( const T&amp; a, const T&amp; b );</li></ul><p>// 求范围中的最小元素</p><p>// a为第一个元素， b为第一个元素</p><p><strong>示例：</strong></p><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string_view&gt;</span></span><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>{    std::cout &lt;&lt; <span class="hljs-string">"smaller of 1 and 9999 is "</span> &lt;&lt; std::<span class="hljs-built_in">min</span>(<span class="hljs-number">1</span>, <span class="hljs-number">9999</span>) &lt;&lt; <span class="hljs-string">'\n'</span>        &lt;&lt; <span class="hljs-string">"smaller of 'a', and 'b' is '"</span> &lt;&lt; std::<span class="hljs-built_in">min</span>(<span class="hljs-string">'a'</span>, <span class="hljs-string">'b'</span>) &lt;&lt; <span class="hljs-string">"'\n"</span>        &lt;&lt; <span class="hljs-string">"shortest of \"foo\", \"bar\", and \"hello\" is \""</span>        &lt;&lt; std::<span class="hljs-built_in">min</span>({ <span class="hljs-string">"foo"</span>, <span class="hljs-string">"bar"</span>, <span class="hljs-string">"hello"</span> },                    [](<span class="hljs-type">const</span> std::string_view s1, <span class="hljs-type">const</span> std::string_view s2) {                        <span class="hljs-keyword">return</span> s1.<span class="hljs-built_in">size</span>() &lt; s2.<span class="hljs-built_in">size</span>();                    }) &lt;&lt; <span class="hljs-string">"\"\n"</span>;}</code></pre></div><p><strong>总结：</strong></p><ul><li>返回两个元素中最小的那一个</li></ul><h4><span id="5-7-3-equal">5.7.3 equal</span><a href="#5-7-3-equal" class="header-anchor">#</a></h4><p><strong>功能描述：</strong></p><ul><li>求两个容器的元素是否相等</li></ul><p><strong>函数原型：</strong></p><p>-<br>  equal(iterator beg1, iterator end1, iterator beg2, iterator end2);</p><p>// 求两个容器的元素是否相等</p><p>// beg1为第一个迭代器，end2为第一个迭代器， beg2为第一个迭代器， end2为第一个迭代器，</p><p><strong>示例：</strong></p><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test</span><span class="hljs-params">(<span class="hljs-type">const</span> std::string&amp; s)</span></span><span class="hljs-function"></span>{    <span class="hljs-keyword">if</span>(std::<span class="hljs-built_in">equal</span>(s.<span class="hljs-built_in">begin</span>(), s.<span class="hljs-built_in">begin</span>() + s.<span class="hljs-built_in">size</span>()/<span class="hljs-number">2</span>, s.<span class="hljs-built_in">rbegin</span>())) {        std::cout &lt;&lt; <span class="hljs-string">"\""</span> &lt;&lt; s &lt;&lt; <span class="hljs-string">"\" is a palindrome\n"</span>;    } <span class="hljs-keyword">else</span> {        std::cout &lt;&lt; <span class="hljs-string">"\""</span> &lt;&lt; s &lt;&lt; <span class="hljs-string">"\" is not a palindrome\n"</span>;    }}<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>{    <span class="hljs-built_in">test</span>(<span class="hljs-string">"radar"</span>);    <span class="hljs-built_in">test</span>(<span class="hljs-string">"hello"</span>);}</code></pre></div><p><strong>总结：</strong></p><ul><li>求两个容器的元素是否相等</li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>Template</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>github资源资源下载加速</title>
    <link href="/2022/01/19/github%E8%B5%84%E6%BA%90%E8%B5%84%E6%BA%90%E4%B8%8B%E8%BD%BD%E5%8A%A0%E9%80%9F/"/>
    <url>/2022/01/19/github%E8%B5%84%E6%BA%90%E8%B5%84%E6%BA%90%E4%B8%8B%E8%BD%BD%E5%8A%A0%E9%80%9F/</url>
    
    <content type="html"><![CDATA[<div class="toc"><!-- toc --><ul><li><a href="#1-tong-guo-ming-ling-xing-ke-long-yuan-ma">1. 通过命令行克隆源码</a><ul><li><a href="#tong-guo-tian-jia-cnpmjs-org">通过添加<code>.cnpmjs.org</code></a></li><li><a href="#tong-guo-ti-huan-wei-hub-fastgit-org">通过替换为<code>hub.fastgit.org</code></a></li></ul></li><li><a href="#2-tong-guo-liu-lan-qi-xia-zai-zi-yuan">2. 通过浏览器下载资源</a><ul><li><a href="#xia-zai-yuan-ma-zip-bao">下载源码zip包</a></li><li><a href="#xia-zai-er-jin-zhi-releases-wen-jian">下载二进制releases文件</a><ul><li><a href="#tong-guo-tian-jia-https-ghproxy-com">通过添加<code>https://ghproxy.com/</code></a></li></ul></li></ul></li></ul><!-- tocstop --></div><p>由于大家都知道原因，国内使用github下载源码和Releases文件时都慢如龟速<br>下边根据我所使用的方法介绍几种方法</p><h1><span id="1-tong-guo-ming-ling-xing-ke-long-yuan-ma">1. 通过命令行克隆源码</span><a href="#1-tong-guo-ming-ling-xing-ke-long-yuan-ma" class="header-anchor">#</a></h1><h2><span id="tong-guo-tian-jia-cnpmjs-org">通过添加<code>.cnpmjs.org</code></span><a href="#tong-guo-tian-jia-cnpmjs-org" class="header-anchor">#</a></h2><p>在 </p><div class="code-wrapper"><pre><code class="hljs bash">git <span class="hljs-built_in">clone</span> https://github.com/MistEO/MeoAssistantArknights.git</code></pre></div><p>的<code>.com</code>后边添加<code>.cnpmjs.org</code></p><div class="code-wrapper"><pre><code class="hljs bash">git <span class="hljs-built_in">clone</span> https://github.com.cnpmjs.org/MistEO/MeoAssistantArknights.git</code></pre></div><h2><span id="tong-guo-ti-huan-wei-hub-fastgit-org">通过替换为<code>hub.fastgit.org</code></span><a href="#tong-guo-ti-huan-wei-hub-fastgit-org" class="header-anchor">#</a></h2><p>喜欢的话请他喝杯茶<a href="https://doc.fastgit.org/zh-cn/sponsor.html">捐赠相关 | FastGit UK Document</a></p><p>在</p><div class="code-wrapper"><pre><code class="hljs bsah">git clone https://github.com/MistEO/MeoAssistantArknights.git</code></pre></div><p>中把<code>github.com</code>替换为<code>hub.fastgit.org</code></p><div class="code-wrapper"><pre><code class="hljs bash">git <span class="hljs-built_in">clone</span> https://hub.fastgit.org/MistEO/MeoAssistantArknights.git</code></pre></div><h1><span id="2-tong-guo-liu-lan-qi-xia-zai-zi-yuan">2. 通过浏览器下载资源</span><a href="#2-tong-guo-liu-lan-qi-xia-zai-zi-yuan" class="header-anchor">#</a></h1><p>下载例如源码zip包，releases文件。</p><h2><span id="xia-zai-yuan-ma-zip-bao">下载源码zip包</span><a href="#xia-zai-yuan-ma-zip-bao" class="header-anchor">#</a></h2><p>把</p><div class="code-wrapper"><pre><code class="hljs bash">https://github.com/MistEO/MeoAssistantArknights/archive/refs/heads/master.zip</code></pre></div><p>中的<code>github.com</code>替换为<code>download.fastgit.org</code></p><div class="code-wrapper"><pre><code class="hljs bash">https://download.fastgit.org/MistEO/MeoAssistantArknights/archive/refs/heads/master.zip</code></pre></div><h2><span id="xia-zai-er-jin-zhi-releases-wen-jian">下载二进制releases文件</span><a href="#xia-zai-er-jin-zhi-releases-wen-jian" class="header-anchor">#</a></h2><p>此为个人项目喜欢的话请他喝杯茶<a href="https://gh.ghproxy.com/donate.html">GitHub Proxy 代理加速 (ghproxy.com)</a></p><h3><span id="tong-guo-tian-jia-https-ghproxy-com">通过添加<code>https://ghproxy.com/</code></span><a href="#tong-guo-tian-jia-https-ghproxy-com" class="header-anchor">#</a></h3><p>把</p><div class="code-wrapper"><pre><code class="hljs bash">https://github.com//MistEO/MeoAssistantArknights/releases/download/v2.7.9/MeoAssistantArknights_v2.7.9.zip</code></pre></div><p>在<code>https://github</code>添加<code>https://ghproxy.com/</code></p><div class="code-wrapper"><pre><code class="hljs bash">https://ghproxy.com/https://github.com//MistEO/MeoAssistantArknights/releases/download/v2.7.9/MeoAssistantArknights_v2.7.9.zip</code></pre></div>]]></content>
    
    
    
    <tags>
      
      <tag>github</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>容器适配器</title>
    <link href="/2022/01/19/%E5%AE%B9%E5%99%A8%E9%80%82%E9%85%8D%E5%99%A8/"/>
    <url>/2022/01/19/%E5%AE%B9%E5%99%A8%E9%80%82%E9%85%8D%E5%99%A8/</url>
    
    <content type="html"><![CDATA[<div class="toc"><!-- toc --><ul><li><a href="#std-stack">std::stack</a></li><li><a href="#std-queue">std::queue</a></li><li><a href="#std-priority-queue">std::priority_queue</a></li></ul><!-- tocstop --></div><p>容器适配器提供顺序容器的不同接口</p><h2><span id="std-stack">std::stack</span><a href="#std-stack" class="header-anchor">#</a></h2><ul><li>定义于头文件 <code>&lt;stack&gt;</code></li></ul><p><code>std::stack</code> 类是容器适配器，它给予程序员栈的功能——特别是 FILO （先进后出）数据结构。</p><p>该类模板表现为底层容器的包装器——只提供特定函数集合。栈从被称作栈顶的容器尾部推弹元素。</p><table><thead><tr><th>元素访问</th><th></th></tr></thead><tbody><tr><td><a href="https://zh.cppreference.com/w/cpp/container/stack/top">top</a></td><td>访问栈顶元素 (公开成员函数)</td></tr><tr><td>容量</td><td></td></tr><tr><td><a href="https://zh.cppreference.com/w/cpp/container/stack/empty">empty</a></td><td>检查底层容器是否为空 (公开成员函数)</td></tr><tr><td><a href="https://zh.cppreference.com/w/cpp/container/stack/size">size</a></td><td>返回容纳的元素数 (公开成员函数)</td></tr><tr><td>修改器</td><td></td></tr><tr><td><a href="https://zh.cppreference.com/w/cpp/container/stack/push">push</a></td><td>向栈顶插入元素 (公开成员函数)</td></tr><tr><td><a href="https://zh.cppreference.com/w/cpp/container/stack/emplace">emplace</a>(C++11)</td><td>在顶部原位构造元素 (公开成员函数)</td></tr><tr><td><a href="https://zh.cppreference.com/w/cpp/container/stack/pop">pop</a></td><td>删除栈顶元素 (公开成员函数)</td></tr><tr><td><a href="https://zh.cppreference.com/w/cpp/container/stack/swap">swap</a>(C++11)</td><td>交换内容 (公开成员函数)</td></tr></tbody></table><h2><span id="std-queue">std::queue</span><a href="#std-queue" class="header-anchor">#</a></h2><ul><li>适配一个容器以提供队列（FIFO 数据结构）</li></ul><p>定义于头文件 <code>&lt;queue&gt;</code></p><p><code>std::queue</code> 类是容器适配器，它给予程序员队列的功能——尤其是 FIFO （先进先出）数据结构。</p><p>类模板表现为底层容器的包装器——只提供特定的函数集合。 queue 在底层容器尾端推入元素，从首端弹出元素。</p><table><thead><tr><th>元素访问</th><th></th></tr></thead><tbody><tr><td><a href="https://zh.cppreference.com/w/cpp/container/queue/front">front</a></td><td>访问第一个元素 (公开成员函数)</td></tr><tr><td><a href="https://zh.cppreference.com/w/cpp/container/queue/back">back</a></td><td>访问最后一个元素 (公开成员函数)</td></tr><tr><td>容量</td><td></td></tr><tr><td><a href="https://zh.cppreference.com/w/cpp/container/queue/empty">empty</a></td><td>检查底层容器是否为空 (公开成员函数)</td></tr><tr><td><a href="https://zh.cppreference.com/w/cpp/container/queue/size">size</a></td><td>返回容纳的元素数 (公开成员函数)</td></tr><tr><td>修改器</td><td></td></tr><tr><td><a href="https://zh.cppreference.com/w/cpp/container/queue/push">push</a></td><td>向队列尾部插入元素 (公开成员函数)</td></tr><tr><td><a href="https://zh.cppreference.com/w/cpp/container/queue/emplace">emplace</a>(C++11)</td><td>在尾部原位构造元素 (公开成员函数)</td></tr><tr><td><a href="https://zh.cppreference.com/w/cpp/container/queue/pop">pop</a></td><td>删除首个元素 (公开成员函数)</td></tr><tr><td><a href="https://zh.cppreference.com/w/cpp/container/queue/swap">swap</a>(C++11)</td><td>交换内容 (公开成员函数)</td></tr></tbody></table><h2><span id="std-priority-queue">std::priority_queue</span><a href="#std-priority-queue" class="header-anchor">#</a></h2><ul><li>定义于头文件 <code>&lt;queue&gt;</code></li></ul><p>priority_queue 是容器适配器，它提供常数时间的（默认）最大元素查找，对数代价的插入与释出。</p><p>可用用户提供的 <code>Compare</code> 更改顺序，例如，用 std::greater<t> 将导致最小元素作为 <a href="https://zh.cppreference.com/w/cpp/container/priority_queue/top">top()</a> 出现。</t></p><p>用 <code>priority_queue</code> 工作类似管理某些随机访问容器中的<a href="https://zh.cppreference.com/w/cpp/algorithm/make_heap">堆</a>，优势是不可能突然把堆非法化。</p><table><thead><tr><th>元素访问</th><th></th></tr></thead><tbody><tr><td><a href="https://zh.cppreference.com/w/cpp/container/priority_queue/top">top</a></td><td>访问栈顶元素 (公开成员函数)</td></tr><tr><td>容量</td><td></td></tr><tr><td><a href="https://zh.cppreference.com/w/cpp/container/priority_queue/empty">empty</a></td><td>检查底层容器是否为空 (公开成员函数)</td></tr><tr><td><a href="https://zh.cppreference.com/w/cpp/container/priority_queue/size">size</a></td><td>返回容纳的元素数 (公开成员函数)</td></tr><tr><td>修改器</td><td></td></tr><tr><td><a href="https://zh.cppreference.com/w/cpp/container/priority_queue/push">push</a></td><td>插入元素，并对底层容器排序 (公开成员函数)</td></tr><tr><td><a href="https://zh.cppreference.com/w/cpp/container/priority_queue/emplace">emplace</a>(C++11)</td><td>原位构造元素并排序底层容器 (公开成员函数)</td></tr><tr><td><a href="https://zh.cppreference.com/w/cpp/container/priority_queue/pop">pop</a></td><td>删除队首元素 (公开成员函数)</td></tr><tr><td><a href="https://zh.cppreference.com/w/cpp/container/priority_queue/swap">swap</a>(C++11)</td><td>交换内容 (公开成员函数)</td></tr></tbody></table>]]></content>
    
    
    
    <tags>
      
      <tag>Adaptors</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>关联容器</title>
    <link href="/2022/01/19/%E5%85%B3%E8%81%94%E5%AE%B9%E5%99%A8/"/>
    <url>/2022/01/19/%E5%85%B3%E8%81%94%E5%AE%B9%E5%99%A8/</url>
    
    <content type="html"><![CDATA[<div class="toc"><!-- toc --><ul><li><a href="#std-set">std::set</a><ul><li><a href="#std-set-begin-std-set-cbegin">std::set&lt;&gt;::begin,std::set&lt;&gt;::cbegin</a></li><li><a href="#std-set-key-compare-allocator-empty">std::set&lt;Key,Compare,Allocator&gt;::empty</a></li><li><a href="#std-set-key-compare-allocator-size">std::set&lt;Key,Compare,Allocator&gt;::size</a></li><li><a href="#std-set-key-compare-allocator-clear">std::set&lt;Key,Compare,Allocator&gt;::clear</a></li><li><a href="#std-set-key-compare-allocator-insert">std::set&lt;Key,Compare,Allocator&gt;::insert</a></li><li><a href="#std-set-key-compare-allocator-emplace">std::set&lt;Key,Compare,Allocator&gt;::emplace</a></li><li><a href="#std-set-key-compare-allocator-erase">std::set&lt;Key,Compare,Allocator&gt;::erase</a></li><li><a href="#std-set-key-compare-allocator-find">std::set&lt;Key,Compare,Allocator&gt;::find</a></li></ul></li><li><a href="#std-map">std::map</a><ul><li><a href="#std-map-key-t-compare-allocator-at">std::map&lt;Key,T,Compare,Allocator&gt;::at</a></li><li><a href="#std-map-key-t-compare-allocator-empty">std::map&lt;Key,T,Compare,Allocator&gt;::empty</a></li><li><a href="#std-map-key-t-compare-allocator-size">std::map&lt;Key,T,Compare,Allocator&gt;::size</a></li><li><a href="#std-map-key-t-compare-allocator-clear">std::map&lt;Key,T,Compare,Allocator&gt;::clear</a></li><li><a href="#std-map-key-t-compare-allocator-insert">std::map&lt;Key,T,Compare,Allocator&gt;::insert</a></li><li><a href="#std-map-key-t-compare-allocator-insert-or-assign">std::map&lt;Key,T,Compare,Allocator&gt;::insert_or_assign</a></li><li><a href="#std-map-key-t-compare-allocator-emplace">std::map&lt;Key,T,Compare,Allocator&gt;::emplace</a></li><li><a href="#std-map-key-t-compare-allocator-emplace-hint">std::map&lt;Key,T,Compare,Allocator&gt;::emplace_hint</a></li><li><a href="#std-map-key-t-compare-allocator-try-emplace">std::map&lt;Key,T,Compare,Allocator&gt;::try_emplace</a></li><li><a href="#std-map-key-t-compare-allocator-erase">std::map&lt;Key,T,Compare,Allocator&gt;::erase</a></li><li><a href="#std-map-key-t-compare-allocator-find">std::map&lt;Key,T,Compare,Allocator&gt;::find</a></li><li><a href="#std-erase-if-std-map">std::erase_if (std::map)</a></li></ul></li><li><a href="#std-multiset">std::multiset</a></li><li><a href="#std-multimap">std::multimap</a></li></ul><!-- tocstop --></div><p>此文整理与👉<a href="https://zh.cppreference.com/w/cpp/container">容器库 - cppreference.com</a></p><blockquote><p> 关联容器实现能快速查找（ <em>O(log n)</em> 复杂度）的数据结构。</p></blockquote><h2><span id="std-set">std::set</span><a href="#std-set" class="header-anchor">#</a></h2><p><strong>定义于头文件 <code>&lt;set&gt;</code></strong></p><blockquote><p>std::set 是关联容器，含有 Key 类型对象的<strong>已排序集</strong>并<strong>去重</strong>。用比较函数 比较 (Compare) 进行排序。搜索、移除和插入拥有对数复杂度。 set 通常以<strong>红黑树</strong>实现。</p></blockquote><ul><li><p>返回指向 <code>set</code> 首元素的迭代器。</p></li><li><p>若 <code>set</code> 为空，则返回的迭代器将等于 <a href="https://zh.cppreference.com/w/cpp/container/set/end">end()</a> 。</p></li><li><p>返回值</p></li></ul><p>指向首元素的迭代器。</p><ul><li>复杂度</li></ul><p>常数。</p><h3><span id="std-set-lt-gt-begin-std-set-lt-gt-cbegin">std::set&lt;&gt;::begin,std::set&lt;&gt;::cbegin</span><a href="#std-set-lt-gt-begin-std-set-lt-gt-cbegin" class="header-anchor">#</a></h3><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;set&gt;</span></span><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>{    std::set&lt;<span class="hljs-type">int</span>&gt; set = { <span class="hljs-number">3</span>, <span class="hljs-number">1</span>, <span class="hljs-number">4</span>, <span class="hljs-number">1</span>, <span class="hljs-number">5</span>, <span class="hljs-number">9</span>, <span class="hljs-number">2</span>, <span class="hljs-number">6</span>, <span class="hljs-number">5</span> };    std::for_each(set.<span class="hljs-built_in">cbegin</span>(), set.<span class="hljs-built_in">cend</span>(), [](<span class="hljs-type">int</span> x) {        std::cout &lt;&lt; x &lt;&lt; <span class="hljs-string">' '</span>;    });    std::cout &lt;&lt; <span class="hljs-string">'\n'</span>;}</code></pre></div><h3><span id="std-set-lt-key-compare-allocator-gt-empty">std::set&lt;Key,Compare,Allocator&gt;::empty</span><a href="#std-set-lt-key-compare-allocator-gt-empty" class="header-anchor">#</a></h3><blockquote><p>检查容器是否无元素</p></blockquote><h3><span id="std-set-lt-key-compare-allocator-gt-size">std::set&lt;Key,Compare,Allocator&gt;::size</span><a href="#std-set-lt-key-compare-allocator-gt-size" class="header-anchor">#</a></h3><blockquote><p>返回容器中的元素数</p></blockquote><h3><span id="std-set-lt-key-compare-allocator-gt-clear">std::set&lt;Key,Compare,Allocator&gt;::clear</span><a href="#std-set-lt-key-compare-allocator-gt-clear" class="header-anchor">#</a></h3><blockquote><p>从容器擦除所有元素。此调用后 size() 返回零</p></blockquote><h3><span id="std-set-lt-key-compare-allocator-gt-insert">std::set&lt;Key,Compare,Allocator&gt;::insert</span><a href="#std-set-lt-key-compare-allocator-gt-insert" class="header-anchor">#</a></h3><blockquote><p>插入元素到容器，若容器未含拥有等价关键的元素。</p></blockquote><h3><span id="std-set-lt-key-compare-allocator-gt-emplace">std::set&lt;Key,Compare,Allocator&gt;::emplace</span><a href="#std-set-lt-key-compare-allocator-gt-emplace" class="header-anchor">#</a></h3><blockquote><p>若容器中无拥有该关键的元素，则插入以给定的 args 原位构造的新元素到容器。</p></blockquote><blockquote><p>细心地使用 emplace 允许在构造新元素的同时<strong>避免不必要的复制或移动操作</strong></p></blockquote><h3><span id="std-set-lt-key-compare-allocator-gt-erase">std::set&lt;Key,Compare,Allocator&gt;::erase</span><a href="#std-set-lt-key-compare-allocator-gt-erase" class="header-anchor">#</a></h3><blockquote><p>擦除元素</p></blockquote><h3><span id="std-set-lt-key-compare-allocator-gt-find">std::set&lt;Key,Compare,Allocator&gt;::find</span><a href="#std-set-lt-key-compare-allocator-gt-find" class="header-anchor">#</a></h3><blockquote><p>寻找键等于 key 的的元素。</p></blockquote><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;set&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span> <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>{    std::set&lt;<span class="hljs-type">int</span>&gt; numbers;    std::cout &lt;&lt; <span class="hljs-string">"Initially, numbers.empty(): "</span> &lt;&lt; numbers.<span class="hljs-built_in">empty</span>() &lt;&lt; <span class="hljs-string">'\n'</span>;     numbers.<span class="hljs-built_in">insert</span>(<span class="hljs-number">13317</span>);     numbers.<span class="hljs-built_in">insert</span>(<span class="hljs-number">3</span>);    numbers.<span class="hljs-built_in">insert</span>(<span class="hljs-number">2</span>);    std::cout &lt;&lt; <span class="hljs-string">"After adding elements, numbers.empty(): "</span> &lt;&lt; numbers.<span class="hljs-built_in">empty</span>() &lt;&lt; <span class="hljs-string">'\n'</span>;        std::for_each(numbers.<span class="hljs-built_in">cbegin</span>(), numbers.<span class="hljs-built_in">cend</span>(), [](<span class="hljs-type">int</span> x) {    std::cout &lt;&lt; x &lt;&lt; <span class="hljs-string">' '</span>;  });        numbers.<span class="hljs-built_in">emplace</span>(<span class="hljs-number">1</span>);        numbers.<span class="hljs-built_in">erase</span>(<span class="hljs-number">1</span>);        <span class="hljs-type">uint32_t</span> size = numbers.<span class="hljs-built_in">size</span>();    std::cout &lt;&lt; <span class="hljs-string">"nums contains "</span> &lt;&lt; size &lt;&lt; <span class="hljs-string">" elements.\n"</span>;        <span class="hljs-keyword">auto</span> search = numbers.<span class="hljs-built_in">find</span>(<span class="hljs-number">2</span>);    <span class="hljs-keyword">if</span> (search != numbers.<span class="hljs-built_in">end</span>()) {        std::cout &lt;&lt; <span class="hljs-string">"Found "</span> &lt;&lt; (*search) &lt;&lt; <span class="hljs-string">'\n'</span>;    } <span class="hljs-keyword">else</span> {        std::cout &lt;&lt; <span class="hljs-string">"Not found\n"</span>;    }        numbers.<span class="hljs-built_in">clear</span>();<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;}</code></pre></div><h2><span id="std-map">std::map</span><a href="#std-map" class="header-anchor">#</a></h2><blockquote><p>键值对的集合，按照键排序，键是唯一的</p></blockquote><ul><li><p>std::map 是有序键值对容器，它的元素的键是唯一的。</p></li><li><p>用比较函数 Compare 排序键。搜索、移除和插入操作拥有对数复杂度。</p></li><li><p>map 通常实现为红黑树。</p></li></ul><p><strong>元素访问</strong></p><h3><span id="std-map-lt-key-t-compare-allocator-gt-at">std::map&lt;Key,T,Compare,Allocator&gt;::at</span><a href="#std-map-lt-key-t-compare-allocator-gt-at" class="header-anchor">#</a></h3><blockquote><p>返回到拥有等于 key 的关键的元素被映射值的引用。</p></blockquote><h3><span id="std-map-lt-key-t-compare-allocator-gt-empty">std::map&lt;Key,T,Compare,Allocator&gt;::empty</span><a href="#std-map-lt-key-t-compare-allocator-gt-empty" class="header-anchor">#</a></h3><blockquote><p>检查容器是否为空</p></blockquote><h3><span id="std-map-lt-key-t-compare-allocator-gt-size">std::map&lt;Key,T,Compare,Allocator&gt;::size</span><a href="#std-map-lt-key-t-compare-allocator-gt-size" class="header-anchor">#</a></h3><blockquote><p>返回容纳的元素数</p></blockquote><h3><span id="std-map-lt-key-t-compare-allocator-gt-clear">std::map&lt;Key,T,Compare,Allocator&gt;::clear</span><a href="#std-map-lt-key-t-compare-allocator-gt-clear" class="header-anchor">#</a></h3><blockquote><p>清除内容</p></blockquote><h3><span id="std-map-lt-key-t-compare-allocator-gt-insert">std::map&lt;Key,T,Compare,Allocator&gt;::insert</span><a href="#std-map-lt-key-t-compare-allocator-gt-insert" class="header-anchor">#</a></h3><blockquote><p>插入元素或结点 (C++17 起)</p></blockquote><h3><span id="std-map-lt-key-t-compare-allocator-gt-insert-or-assign">std::map&lt;Key,T,Compare,Allocator&gt;::insert_or_assign</span><a href="#std-map-lt-key-t-compare-allocator-gt-insert-or-assign" class="header-anchor">#</a></h3><blockquote><p>插入元素，或若键已存在则赋值给当前元素</p></blockquote><h3><span id="std-map-lt-key-t-compare-allocator-gt-emplace">std::map&lt;Key,T,Compare,Allocator&gt;::emplace</span><a href="#std-map-lt-key-t-compare-allocator-gt-emplace" class="header-anchor">#</a></h3><blockquote><p>原位构造元素</p></blockquote><h3><span id="std-map-lt-key-t-compare-allocator-gt-emplace-hint">std::map&lt;Key,T,Compare,Allocator&gt;::emplace_hint</span><a href="#std-map-lt-key-t-compare-allocator-gt-emplace-hint" class="header-anchor">#</a></h3><blockquote><p>使用提示原位构造元素</p></blockquote><h3><span id="std-map-lt-key-t-compare-allocator-gt-try-emplace">std::map&lt;Key,T,Compare,Allocator&gt;::try_emplace</span><a href="#std-map-lt-key-t-compare-allocator-gt-try-emplace" class="header-anchor">#</a></h3><blockquote><p>若键不存在则原位插入，若键存在则不做任何事</p></blockquote><h3><span id="std-map-lt-key-t-compare-allocator-gt-erase">std::map&lt;Key,T,Compare,Allocator&gt;::erase</span><a href="#std-map-lt-key-t-compare-allocator-gt-erase" class="header-anchor">#</a></h3><blockquote><p>擦除元素</p></blockquote><h3><span id="std-map-lt-key-t-compare-allocator-gt-find">std::map&lt;Key,T,Compare,Allocator&gt;::find</span><a href="#std-map-lt-key-t-compare-allocator-gt-find" class="header-anchor">#</a></h3><blockquote><p>寻找带有特定键的元素</p></blockquote><h3><span id="std-erase-if-std-map">std::erase_if (std::map)</span><a href="#std-erase-if-std-map" class="header-anchor">#</a></h3><blockquote><p>擦除所有满足特定判别标准的元素</p></blockquote><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;map&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;utility&gt;</span></span> <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span></span><span class="hljs-function"></span>{    std::map&lt;<span class="hljs-type">int</span>,<span class="hljs-type">int</span>&gt; numbers;        numbers.<span class="hljs-built_in">emplace</span>(<span class="hljs-number">42</span>, <span class="hljs-number">13</span>);    numbers.<span class="hljs-built_in">emplace_hint</span>(<span class="hljs-number">41</span>, <span class="hljs-number">12</span>);    numbers.<span class="hljs-built_in">insert</span>(std::<span class="hljs-built_in">make_pair</span>(<span class="hljs-number">13317</span>, <span class="hljs-number">123</span>));     std::cout &lt;&lt; <span class="hljs-string">"After adding elements, numbers.empty(): "</span> &lt;&lt; numbers.<span class="hljs-built_in">empty</span>() &lt;&lt; <span class="hljs-string">'\n'</span>;        std::cout &lt;&lt; <span class="hljs-string">"After elements, numbers.size(): "</span> &lt;&lt; numbers.<span class="hljs-built_in">size</span>() &lt;&lt; <span class="hljs-string">'\n'</span>;        numbers.<span class="hljs-built_in">try_emplace</span>(<span class="hljs-number">40</span>, <span class="hljs-number">10</span>);numbers.<span class="hljs-built_in">erase</span>(<span class="hljs-number">40</span>);    <span class="hljs-type">const</span> <span class="hljs-keyword">auto</span> count = std::<span class="hljs-built_in">erase_if</span>(data, [](<span class="hljs-type">const</span> <span class="hljs-keyword">auto</span>&amp; item) {        <span class="hljs-keyword">auto</span> <span class="hljs-type">const</span>&amp; [key, value] = item;        <span class="hljs-built_in">return</span> (key &amp; <span class="hljs-number">1</span>) == <span class="hljs-number">1</span>;    });    std::cout &lt;&lt; <span class="hljs-string">"Erase items with odd keys:\n"</span> &lt;&lt; data &lt;&lt; <span class="hljs-string">'\n'</span>              &lt;&lt; count &lt;&lt; <span class="hljs-string">" items removed.\n"</span>;        myMap.<span class="hljs-built_in">insert_or_assign</span>(<span class="hljs-string">"a"</span>, <span class="hljs-string">"apple"</span>);    numbers.<span class="hljs-built_in">find</span>(<span class="hljs-number">42</span>);std::cout &lt;&lt; <span class="hljs-string">"After elements, numbers.clear(): "</span> &lt;&lt; numbers.<span class="hljs-built_in">clear</span>() &lt;&lt; <span class="hljs-string">'\n'</span>;<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;}</code></pre></div><h2><span id="std-multiset">std::multiset</span><a href="#std-multiset" class="header-anchor">#</a></h2><blockquote><p>键的集合，按照键排序</p></blockquote><table><thead><tr><th>迭代器</th><th></th></tr></thead><tbody><tr><td><a href="https://zh.cppreference.com/w/cpp/container/multiset/begin">begin cbegin</a>(C++11)</td><td>返回指向起始的迭代器 (公开成员函数)</td></tr><tr><td><a href="https://zh.cppreference.com/w/cpp/container/multiset/end">end cend</a>(C++11)</td><td>返回指向末尾的迭代器 (公开成员函数)</td></tr><tr><td><a href="https://zh.cppreference.com/w/cpp/container/multiset/rbegin">rbegin crbegin</a>(C++11)</td><td>返回指向起始的逆向迭代器 (公开成员函数)</td></tr><tr><td><a href="https://zh.cppreference.com/w/cpp/container/multiset/rend">rend crend</a>(C++11)</td><td>返回指向末尾的逆向迭代器 (公开成员函数)</td></tr><tr><td>容量</td><td></td></tr><tr><td><a href="https://zh.cppreference.com/w/cpp/container/multiset/empty">empty</a></td><td>检查容器是否为空 (公开成员函数)</td></tr><tr><td><a href="https://zh.cppreference.com/w/cpp/container/multiset/size">size</a></td><td>返回容纳的元素数 (公开成员函数)</td></tr><tr><td><a href="https://zh.cppreference.com/w/cpp/container/multiset/max_size">max_size</a></td><td>返回可容纳的最大元素数 (公开成员函数)</td></tr><tr><td>修改器</td><td></td></tr><tr><td><a href="https://zh.cppreference.com/w/cpp/container/multiset/clear">clear</a></td><td>清除内容 (公开成员函数)</td></tr><tr><td><a href="https://zh.cppreference.com/w/cpp/container/multiset/insert">insert</a></td><td>插入元素或结点 (C++17 起) (公开成员函数)</td></tr><tr><td><a href="https://zh.cppreference.com/w/cpp/container/multiset/emplace">emplace</a>(C++11)</td><td>原位构造元素 (公开成员函数)</td></tr><tr><td><a href="https://zh.cppreference.com/w/cpp/container/multiset/emplace_hint">emplace_hint</a>(C++11)</td><td>使用提示原位构造元素 (公开成员函数)</td></tr><tr><td><a href="https://zh.cppreference.com/w/cpp/container/multiset/erase">erase</a></td><td>擦除元素 (公开成员函数)</td></tr><tr><td><a href="https://zh.cppreference.com/w/cpp/container/multiset/swap">swap</a></td><td>交换内容 (公开成员函数)</td></tr><tr><td><a href="https://zh.cppreference.com/w/cpp/container/multiset/extract">extract</a>(C++17)</td><td>从另一容器释出结点 (公开成员函数)</td></tr><tr><td><a href="https://zh.cppreference.com/w/cpp/container/multiset/merge">merge</a>(C++17)</td><td>从另一容器接合结点 (公开成员函数)</td></tr><tr><td>查找</td><td></td></tr><tr><td><a href="https://zh.cppreference.com/w/cpp/container/multiset/count">count</a></td><td>返回匹配特定键的元素数量 (公开成员函数)</td></tr><tr><td><a href="https://zh.cppreference.com/w/cpp/container/multiset/find">find</a></td><td>寻找带有特定键的元素 (公开成员函数)</td></tr><tr><td><a href="https://zh.cppreference.com/w/cpp/container/multiset/contains">contains</a>(C++20)</td><td>检查容器是否含有带特定键的元素 (公开成员函数)</td></tr><tr><td><a href="https://zh.cppreference.com/w/cpp/container/multiset/equal_range">equal_range</a></td><td>返回匹配特定键的元素范围 (公开成员函数)</td></tr><tr><td><a href="https://zh.cppreference.com/w/cpp/container/multiset/lower_bound">lower_bound</a></td><td>返回指向首个<em>不小于</em>给定键的元素的迭代器 (公开成员函数)</td></tr><tr><td><a href="https://zh.cppreference.com/w/cpp/container/multiset/upper_bound">upper_bound</a></td><td>返回指向首个<em>大于</em>给定键的元素的迭代器</td></tr><tr><td><a href="https://zh.cppreference.com/w/cpp/container/multiset/erase_if">erase_if(std::multiset)</a>(C++20)</td><td>擦除所有满足特定判别标准的元素</td></tr></tbody></table><h2><span id="std-multimap">std::multimap</span><a href="#std-multimap" class="header-anchor">#</a></h2><blockquote><p>键值对的集合，按照键排序</p></blockquote><table><thead><tr><th>迭代器</th><th></th></tr></thead><tbody><tr><td><a href="https://zh.cppreference.com/w/cpp/container/multimap/begin">begincbegin</a>(C++11)</td><td>返回指向起始的迭代器 (公开成员函数)</td></tr><tr><td><a href="https://zh.cppreference.com/w/cpp/container/multimap/end">endcend</a>(C++11)</td><td>返回指向末尾的迭代器 (公开成员函数)</td></tr><tr><td><a href="https://zh.cppreference.com/w/cpp/container/multimap/rbegin">rbegincrbegin</a>(C++11)</td><td>返回指向起始的逆向迭代器 (公开成员函数)</td></tr><tr><td><a href="https://zh.cppreference.com/w/cpp/container/multimap/rend">rendcrend</a>(C++11)</td><td>返回指向末尾的逆向迭代器 (公开成员函数)</td></tr><tr><td>容量</td><td></td></tr><tr><td><a href="https://zh.cppreference.com/w/cpp/container/multimap/empty">empty</a></td><td>检查容器是否为空 (公开成员函数)</td></tr><tr><td><a href="https://zh.cppreference.com/w/cpp/container/multimap/size">size</a></td><td>返回容纳的元素数 (公开成员函数)</td></tr><tr><td><a href="https://zh.cppreference.com/w/cpp/container/multimap/max_size">max_size</a></td><td>返回可容纳的最大元素数 (公开成员函数)</td></tr><tr><td>修改器</td><td></td></tr><tr><td><a href="https://zh.cppreference.com/w/cpp/container/multimap/clear">clear</a></td><td>清除内容 (公开成员函数)</td></tr><tr><td><a href="https://zh.cppreference.com/w/cpp/container/multimap/insert">insert</a></td><td>插入元素或结点 (C++17 起) (公开成员函数)</td></tr><tr><td><a href="https://zh.cppreference.com/w/cpp/container/multimap/emplace">emplace</a>(C++11)</td><td>原位构造元素 (公开成员函数)</td></tr><tr><td><a href="https://zh.cppreference.com/w/cpp/container/multimap/emplace_hint">emplace_hint</a>(C++11)</td><td>使用提示原位构造元素 (公开成员函数)</td></tr><tr><td><a href="https://zh.cppreference.com/w/cpp/container/multimap/erase">erase</a></td><td>擦除元素 (公开成员函数)</td></tr><tr><td><a href="https://zh.cppreference.com/w/cpp/container/multimap/swap">swap</a></td><td>交换内容 (公开成员函数)</td></tr><tr><td><a href="https://zh.cppreference.com/w/cpp/container/multimap/extract">extract</a>(C++17)</td><td>从另一容器释出结点 (公开成员函数)</td></tr><tr><td><a href="https://zh.cppreference.com/w/cpp/container/multimap/merge">merge</a>(C++17)</td><td>从另一容器接合结点 (公开成员函数)</td></tr><tr><td>查找</td><td></td></tr><tr><td><a href="https://zh.cppreference.com/w/cpp/container/multimap/count">count</a></td><td>返回匹配特定键的元素数量 (公开成员函数)</td></tr><tr><td><a href="https://zh.cppreference.com/w/cpp/container/multimap/find">find</a></td><td>寻找带有特定键的元素 (公开成员函数)</td></tr><tr><td><a href="https://zh.cppreference.com/w/cpp/container/multimap/contains">contains</a>(C++20)</td><td>检查容器是否含有带特定键的元素 (公开成员函数)</td></tr><tr><td><a href="https://zh.cppreference.com/w/cpp/container/multimap/equal_range">equal_range</a></td><td>返回匹配特定键的元素范围 (公开成员函数)</td></tr><tr><td><a href="https://zh.cppreference.com/w/cpp/container/multimap/lower_bound">lower_bound</a></td><td>返回指向首个<em>不小于</em>给定键的元素的迭代器 (公开成员函数)</td></tr><tr><td><a href="https://zh.cppreference.com/w/cpp/container/multimap/upper_bound">upper_bound</a></td><td>返回指向首个<em>大于</em>给定键的元素的迭代器 (公开成员函数)</td></tr><tr><td>观察器</td><td></td></tr><tr><td><a href="https://zh.cppreference.com/w/cpp/container/multimap/key_comp">key_comp</a></td><td>返回用于比较键的函数 (公开成员函数)</td></tr><tr><td><a href="https://zh.cppreference.com/w/cpp/container/multimap/value_comp">value_comp</a></td><td>返回用于在value_type类型的对象中比较键的函数。</td></tr><tr><td><a href="https://zh.cppreference.com/w/cpp/container/multimap/erase_if">erase_if(std::multimap)</a>(C++20)</td><td>擦除所有满足特定判别标准的元素</td></tr></tbody></table>]]></content>
    
    
    
    <tags>
      
      <tag>Associative</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>顺序容器</title>
    <link href="/2022/01/19/%E9%A1%BA%E5%BA%8F%E5%AE%B9%E5%99%A8/"/>
    <url>/2022/01/19/%E9%A1%BA%E5%BA%8F%E5%AE%B9%E5%99%A8/</url>
    
    <content type="html"><![CDATA[<div class="toc"><!-- toc --><ul><li><a href="#std-array">std::array</a></li><li><a href="#std-vector">std::vector</a><ul><li><a href="#fei-cheng-yuan-han-shu">非成员函数</a></li></ul></li><li><a href="#std-deque">std::deque</a></li><li><a href="#std-forward-list">std::forward_list</a></li><li><a href="#std-list">std::list</a></li></ul><!-- tocstop --></div><p>顺序容器实现能按顺序访问的数据结构。</p><h2><span id="std-array">std::array</span><a href="#std-array" class="header-anchor">#</a></h2><p>静态的连续数组</p><blockquote><p>定义于头文件 <code>&lt;array&gt;</code></p></blockquote><ul><li><code>std::array</code> 是封装 <strong>固定大小数组</strong> 的容器。</li></ul><table><thead><tr><th>隐式定义的成员函数</th><th></th></tr></thead><tbody><tr><td>(构造函数)(隐式声明)</td><td>遵循<a href="https://zh.cppreference.com/w/cpp/language/aggregate_initialization">聚合初始化</a>的规则初始化 <code>array</code> （注意默认初始化可以导致非类的 <code>T</code> 的不确定值） (公开成员函数)</td></tr><tr><td>(析构函数)(隐式声明)</td><td>销毁 <code>array</code> 的每个元素 (公开成员函数)</td></tr><tr><td>operator=(隐式声明)</td><td>以来自另一 <code>array</code> 的每个元素重写 <code>array</code> 的对应元素 (公开成员函数)</td></tr><tr><td>元素访问</td><td></td></tr><tr><td><a href="https://zh.cppreference.com/w/cpp/container/array/at">at</a>(C++11)</td><td>访问指定的元素，同时进行越界检查 (公开成员函数)</td></tr><tr><td>[operator<a href="https://zh.cppreference.com/w/cpp/container/array/operator_at">]</a>(C++11)</td><td>访问指定的元素 (公开成员函数)</td></tr><tr><td><a href="https://zh.cppreference.com/w/cpp/container/array/front">front</a>(C++11)</td><td>访问第一个元素 (公开成员函数)</td></tr><tr><td><a href="https://zh.cppreference.com/w/cpp/container/array/back">back</a>(C++11)</td><td>访问最后一个元素 (公开成员函数)</td></tr><tr><td><a href="https://zh.cppreference.com/w/cpp/container/array/data">data</a>(C++11)</td><td>直接访问底层数组 (公开成员函数)</td></tr><tr><td>迭代器</td><td></td></tr><tr><td><a href="https://zh.cppreference.com/w/cpp/container/array/begin">begincbegin</a>(C++11)</td><td>返回指向起始的迭代器 (公开成员函数)</td></tr><tr><td><a href="https://zh.cppreference.com/w/cpp/container/array/end">endcend</a>(C++11)</td><td>返回指向末尾的迭代器 (公开成员函数)</td></tr><tr><td><a href="https://zh.cppreference.com/w/cpp/container/array/rbegin">rbegincrbegin</a>(C++11)</td><td>返回指向起始的逆向迭代器 (公开成员函数)</td></tr><tr><td><a href="https://zh.cppreference.com/w/cpp/container/array/rend">rendcrend</a>(C++11)</td><td>返回指向末尾的逆向迭代器 (公开成员函数)</td></tr><tr><td>容量</td><td></td></tr><tr><td><a href="https://zh.cppreference.com/w/cpp/container/array/empty">empty</a>(C++11)</td><td>检查容器是否为空 (公开成员函数)</td></tr><tr><td><a href="https://zh.cppreference.com/w/cpp/container/array/size">size</a>(C++11)</td><td>返回容纳的元素数 (公开成员函数)</td></tr><tr><td><a href="https://zh.cppreference.com/w/cpp/container/array/max_size">max_size</a>(C++11)</td><td>返回可容纳的最大元素数 (公开成员函数)</td></tr><tr><td>操作</td><td></td></tr><tr><td><a href="https://zh.cppreference.com/w/cpp/container/array/fill">fill</a>(C++11)</td><td>以指定值填充容器 (公开成员函数)</td></tr><tr><td><a href="https://zh.cppreference.com/w/cpp/container/array/swap">swap</a>(C++11)</td><td>交换内容</td></tr></tbody></table><h2><span id="std-vector">std::vector</span><a href="#std-vector" class="header-anchor">#</a></h2><p>定义于头文件 <code>&lt;vector&gt;</code></p><ul><li><code>std::vector</code> 是封装 <strong>动态数组</strong> 的顺序容器。</li></ul><table><thead><tr><th><a href="https://zh.cppreference.com/w/cpp/container/vector/at">at</a></th><th>访问指定的元素，同时进行越界检查 (公开成员函数)</th></tr></thead><tbody><tr><td>[operator<a href="https://zh.cppreference.com/w/cpp/container/vector/operator_at">]</a></td><td>访问指定的元素 (公开成员函数)</td></tr><tr><td><a href="https://zh.cppreference.com/w/cpp/container/vector/front">front</a></td><td>访问第一个元素 (公开成员函数)</td></tr><tr><td><a href="https://zh.cppreference.com/w/cpp/container/vector/back">back</a></td><td>访问最后一个元素 (公开成员函数)</td></tr><tr><td><a href="https://zh.cppreference.com/w/cpp/container/vector/data">data</a></td><td>直接访问底层数组 (公开成员函数)</td></tr><tr><td>迭代器</td><td></td></tr><tr><td><a href="https://zh.cppreference.com/w/cpp/container/vector/begin">begincbegin</a>(C++11)</td><td>返回指向起始的迭代器 (公开成员函数)</td></tr><tr><td><a href="https://zh.cppreference.com/w/cpp/container/vector/end">endcend</a>(C++11)</td><td>返回指向末尾的迭代器 (公开成员函数)</td></tr><tr><td><a href="https://zh.cppreference.com/w/cpp/container/vector/rbegin">rbegincrbegin</a>(C++11)</td><td>返回指向起始的逆向迭代器 (公开成员函数)</td></tr><tr><td><a href="https://zh.cppreference.com/w/cpp/container/vector/rend">rendcrend</a>(C++11)</td><td>返回指向末尾的逆向迭代器 (公开成员函数)</td></tr><tr><td>容量</td><td></td></tr><tr><td><a href="https://zh.cppreference.com/w/cpp/container/vector/empty">empty</a></td><td>检查容器是否为空 (公开成员函数)</td></tr><tr><td><a href="https://zh.cppreference.com/w/cpp/container/vector/size">size</a></td><td>返回容纳的元素数 (公开成员函数)</td></tr><tr><td><a href="https://zh.cppreference.com/w/cpp/container/vector/max_size">max_size</a></td><td>返回可容纳的最大元素数 (公开成员函数)</td></tr><tr><td><a href="https://zh.cppreference.com/w/cpp/container/vector/reserve">reserve</a></td><td>预留存储空间 (公开成员函数)</td></tr><tr><td><a href="https://zh.cppreference.com/w/cpp/container/vector/capacity">capacity</a></td><td>返回当前存储空间能够容纳的元素数 (公开成员函数)</td></tr><tr><td><a href="https://zh.cppreference.com/w/cpp/container/vector/shrink_to_fit">shrink_to_fit</a>(C++11)</td><td>通过释放未使用的内存减少内存的使用 (公开成员函数)</td></tr><tr><td>修改器</td><td></td></tr><tr><td><a href="https://zh.cppreference.com/w/cpp/container/vector/clear">clear</a></td><td>清除内容 (公开成员函数)</td></tr><tr><td><a href="https://zh.cppreference.com/w/cpp/container/vector/insert">insert</a></td><td>插入元素 (公开成员函数)</td></tr><tr><td><a href="https://zh.cppreference.com/w/cpp/container/vector/emplace">emplace</a>(C++11)</td><td>原位构造元素 (公开成员函数)</td></tr><tr><td><a href="https://zh.cppreference.com/w/cpp/container/vector/erase">erase</a></td><td>擦除元素 (公开成员函数)</td></tr><tr><td><a href="https://zh.cppreference.com/w/cpp/container/vector/push_back">push_back</a></td><td>将元素添加到容器末尾 (公开成员函数)</td></tr><tr><td><a href="https://zh.cppreference.com/w/cpp/container/vector/emplace_back">emplace_back</a>(C++11)</td><td>在容器末尾就地构造元素 (公开成员函数)</td></tr><tr><td><a href="https://zh.cppreference.com/w/cpp/container/vector/pop_back">pop_back</a></td><td>移除末元素 (公开成员函数)</td></tr><tr><td><a href="https://zh.cppreference.com/w/cpp/container/vector/resize">resize</a></td><td>改变容器中可存储元素的个数 (公开成员函数)</td></tr><tr><td><a href="https://zh.cppreference.com/w/cpp/container/vector/swap">swap</a></td><td>交换内容 (公开成员函数)</td></tr></tbody></table><h3><span id="fei-cheng-yuan-han-shu">非成员函数</span><a href="#fei-cheng-yuan-han-shu" class="header-anchor">#</a></h3><table><thead><tr><th><a href="https://zh.cppreference.com/w/cpp/container/vector/vector">(构造函数)</a></th><th>构造 <code>vector</code> (公开成员函数)</th></tr></thead><tbody><tr><td><a href="https://zh.cppreference.com/w/cpp/container/vector/~vector">(析构函数)</a></td><td>析构 <code>vector</code> (公开成员函数)</td></tr><tr><td><a href="https://zh.cppreference.com/w/cpp/container/vector/operator%3D">operator=</a></td><td>赋值给容器 (公开成员函数)</td></tr><tr><td><a href="https://zh.cppreference.com/w/cpp/container/vector/assign">assign</a></td><td>将值赋给容器 (公开成员函数)</td></tr><tr><td><a href="https://zh.cppreference.com/w/cpp/container/vector/get_allocator">get_allocator</a></td><td>返回相关的分配器 (公开成员函数)</td></tr><tr><td>元素访问</td><td></td></tr><tr><td><a href="https://zh.cppreference.com/w/cpp/container/vector/at">at</a></td><td>访问指定的元素，同时进行越界检查 (公开成员函数)</td></tr><tr><td><a href="https://zh.cppreference.com/w/cpp/container/vector/operator_at">operator[]</a></td><td>访问指定的元素 (公开成员函数)</td></tr><tr><td><a href="https://zh.cppreference.com/w/cpp/container/vector/front">front</a></td><td>访问第一个元素 (公开成员函数)</td></tr><tr><td><a href="https://zh.cppreference.com/w/cpp/container/vector/back">back</a></td><td>访问最后一个元素 (公开成员函数)</td></tr><tr><td><a href="https://zh.cppreference.com/w/cpp/container/vector/data">data</a></td><td>直接访问底层数组 (公开成员函数)</td></tr><tr><td>迭代器</td><td></td></tr><tr><td><a href="https://zh.cppreference.com/w/cpp/container/vector/begin">begin cbegin</a>(C++11)</td><td>返回指向起始的迭代器 (公开成员函数)</td></tr><tr><td><a href="https://zh.cppreference.com/w/cpp/container/vector/end">end cend</a>(C++11)</td><td>返回指向末尾的迭代器 (公开成员函数)</td></tr><tr><td><a href="https://zh.cppreference.com/w/cpp/container/vector/rbegin">rbegin crbegin</a>(C++11)</td><td>返回指向起始的逆向迭代器 (公开成员函数)</td></tr><tr><td><a href="https://zh.cppreference.com/w/cpp/container/vector/rend">rend crend</a>(C++11)</td><td>返回指向末尾的逆向迭代器 (公开成员函数)</td></tr></tbody></table><table><thead><tr><th>容量</th><th></th></tr></thead><tbody><tr><td><a href="https://zh.cppreference.com/w/cpp/container/vector/empty">empty</a></td><td>检查容器是否为空 (公开成员函数)</td></tr><tr><td><a href="https://zh.cppreference.com/w/cpp/container/vector/size">size</a></td><td>返回容纳的元素数 (公开成员函数)</td></tr><tr><td><a href="https://zh.cppreference.com/w/cpp/container/vector/max_size">max_size</a></td><td>返回可容纳的最大元素数 (公开成员函数)</td></tr><tr><td><a href="https://zh.cppreference.com/w/cpp/container/vector/reserve">reserve</a></td><td>预留存储空间 (公开成员函数)</td></tr><tr><td><a href="https://zh.cppreference.com/w/cpp/container/vector/capacity">capacity</a></td><td>返回当前存储空间能够容纳的元素数 (公开成员函数)</td></tr><tr><td><a href="https://zh.cppreference.com/w/cpp/container/vector/shrink_to_fit">shrink_to_fit</a>(C++11)</td><td>通过释放未使用的内存减少内存的使用 (公开成员函数)</td></tr><tr><td>修改器</td><td></td></tr><tr><td><a href="https://zh.cppreference.com/w/cpp/container/vector/clear">clear</a></td><td>清除内容 (公开成员函数)</td></tr><tr><td><a href="https://zh.cppreference.com/w/cpp/container/vector/insert">insert</a></td><td>插入元素 (公开成员函数)</td></tr><tr><td><a href="https://zh.cppreference.com/w/cpp/container/vector/emplace">emplace</a>(C++11)</td><td>原位构造元素 (公开成员函数)</td></tr><tr><td><a href="https://zh.cppreference.com/w/cpp/container/vector/erase">erase</a></td><td>擦除元素 (公开成员函数)</td></tr><tr><td><a href="https://zh.cppreference.com/w/cpp/container/vector/push_back">push_back</a></td><td>将元素添加到容器末尾 (公开成员函数)</td></tr><tr><td><a href="https://zh.cppreference.com/w/cpp/container/vector/emplace_back">emplace_back</a>(C++11)</td><td>在容器末尾就地构造元素 (公开成员函数)</td></tr><tr><td><a href="https://zh.cppreference.com/w/cpp/container/vector/pop_back">pop_back</a></td><td>移除末元素 (公开成员函数)</td></tr><tr><td><a href="https://zh.cppreference.com/w/cpp/container/vector/resize">resize</a></td><td>改变容器中可存储元素的个数 (公开成员函数)</td></tr><tr><td><a href="https://zh.cppreference.com/w/cpp/container/vector/swap">swap</a></td><td>交换内容 (公开成员函数)</td></tr></tbody></table><p><strong>非成员函数</strong></p><table><thead><tr><th align="left"><a href="https://zh.cppreference.com/w/cpp/container/vector/swap2">std::swap(std::vector)</a>(C++20)</th><th align="left">特化<a href="https://zh.cppreference.com/w/cpp/algorithm/swap">std::swap</a> 算法 (函数模板)</th></tr></thead><tbody><tr><td align="left"><a href="https://zh.cppreference.com/w/cpp/container/vector/erase2">erase(std::vector) erase_if(std::vector)</a>(C++20)</td><td align="left">擦除所有满足特定判别标准的元素 (函数模板)</td></tr></tbody></table><h2><span id="std-deque">std::deque</span><a href="#std-deque" class="header-anchor">#</a></h2><ul><li>定义于头文件 <deque></deque></li></ul><blockquote><p>双端队列</p></blockquote><p><code>std::deque</code> （ double-ended queue ，双端队列）是有 <strong>下标顺序容器</strong>，它允许在其首尾两端快速插入及删除。另外，在 deque 任一端插入或删除不会非法化指向其余元素的指针或引用。</p><p>与 <a href="https://zh.cppreference.com/w/cpp/container/vector">std::vector</a> 相反， deque 的元素不是相接存储的：典型实现用单独分配的固定大小数组的序列，外加额外的登记，这表示下标访问必须进行二次指针解引用，与之相比 vector 的下标访问只进行一次。</p><p>deque <strong>的存储按需自动扩展及收缩</strong>。扩张 deque 比扩张 <a href="https://zh.cppreference.com/w/cpp/container/vector">std::vector</a> 更优，因为它不涉及到复制既存元素到新内存位置。另一方面， deque 典型地拥有较大的最小内存开销；只保有一个元素的 deque 必须分配其整个内部数组（例如 64 位 libstdc++ 上为对象大小 8 倍； 64 位 libc++ 上为对象大小 16 倍或 4096 字节的较大者）。</p><p>deque 上常见操作的复杂度（效率）如下：</p><ul><li>随机访问——常数 <em>O(1)</em></li><li>在结尾或起始插入或移除元素——常数 <em>O(1)</em></li><li>插入或移除元素——线性 <em>O(n)</em></li></ul><table><thead><tr><th>元素访问</th><th></th></tr></thead><tbody><tr><td><a href="https://zh.cppreference.com/w/cpp/container/deque/at">at</a></td><td>访问指定的元素，同时进行越界检查 (公开成员函数)</td></tr><tr><td>[operator<a href="https://zh.cppreference.com/w/cpp/container/deque/operator_at">]</a></td><td>访问指定的元素 (公开成员函数)</td></tr><tr><td><a href="https://zh.cppreference.com/w/cpp/container/deque/front">front</a></td><td>访问第一个元素 (公开成员函数)</td></tr><tr><td><a href="https://zh.cppreference.com/w/cpp/container/deque/back">back</a></td><td>访问最后一个元素 (公开成员函数)</td></tr><tr><td>迭代器</td><td></td></tr><tr><td><a href="https://zh.cppreference.com/w/cpp/container/deque/begin">begincbegin</a>(C++11)</td><td>返回指向起始的迭代器 (公开成员函数)</td></tr><tr><td><a href="https://zh.cppreference.com/w/cpp/container/deque/end">endcend</a>(C++11)</td><td>返回指向末尾的迭代器 (公开成员函数)</td></tr><tr><td><a href="https://zh.cppreference.com/w/cpp/container/deque/rbegin">rbegincrbegin</a>(C++11)</td><td>返回指向起始的逆向迭代器 (公开成员函数)</td></tr><tr><td><a href="https://zh.cppreference.com/w/cpp/container/deque/rend">rendcrend</a>(C++11)</td><td>返回指向末尾的逆向迭代器 (公开成员函数)</td></tr><tr><td>容量</td><td></td></tr><tr><td><a href="https://zh.cppreference.com/w/cpp/container/deque/empty">empty</a></td><td>检查容器是否为空 (公开成员函数)</td></tr><tr><td><a href="https://zh.cppreference.com/w/cpp/container/deque/size">size</a></td><td>返回容纳的元素数 (公开成员函数)</td></tr><tr><td><a href="https://zh.cppreference.com/w/cpp/container/deque/max_size">max_size</a></td><td>返回可容纳的最大元素数 (公开成员函数)</td></tr><tr><td><a href="https://zh.cppreference.com/w/cpp/container/deque/shrink_to_fit">shrink_to_fit</a>(C++11)</td><td>通过释放未使用的内存减少内存的使用 (公开成员函数)</td></tr></tbody></table><table><thead><tr><th>修改器</th><th></th></tr></thead><tbody><tr><td><a href="https://zh.cppreference.com/w/cpp/container/deque/clear">clear</a></td><td>清除内容 (公开成员函数)</td></tr><tr><td><a href="https://zh.cppreference.com/w/cpp/container/deque/insert">insert</a></td><td>插入元素 (公开成员函数)</td></tr><tr><td><a href="https://zh.cppreference.com/w/cpp/container/deque/emplace">emplace</a>(C++11)</td><td>原位构造元素 (公开成员函数)</td></tr><tr><td><a href="https://zh.cppreference.com/w/cpp/container/deque/erase">erase</a></td><td>擦除元素 (公开成员函数)</td></tr><tr><td><a href="https://zh.cppreference.com/w/cpp/container/deque/push_back">push_back</a></td><td>将元素添加到容器末尾 (公开成员函数)</td></tr><tr><td><a href="https://zh.cppreference.com/w/cpp/container/deque/emplace_back">emplace_back</a>(C++11)</td><td>在容器末尾就地构造元素 (公开成员函数)</td></tr><tr><td><a href="https://zh.cppreference.com/w/cpp/container/deque/pop_back">pop_back</a></td><td>移除末元素 (公开成员函数)</td></tr><tr><td><a href="https://zh.cppreference.com/w/cpp/container/deque/push_front">push_front</a></td><td>插入元素到容器起始 (公开成员函数)</td></tr><tr><td><a href="https://zh.cppreference.com/w/cpp/container/deque/emplace_front">emplace_front</a>(C++11)</td><td>在容器头部原位构造元素 (公开成员函数)</td></tr><tr><td><a href="https://zh.cppreference.com/w/cpp/container/deque/pop_front">pop_front</a></td><td>移除首元素 (公开成员函数)</td></tr><tr><td><a href="https://zh.cppreference.com/w/cpp/container/deque/resize">resize</a></td><td>改变容器中可存储元素的个数 (公开成员函数)</td></tr><tr><td><a href="https://zh.cppreference.com/w/cpp/container/deque/swap">swap</a></td><td>交换内容 (公开成员函数)</td></tr></tbody></table><p>非成员函数</p><table><thead><tr><th><a href="https://zh.cppreference.com/w/cpp/container/deque/swap2">std::swap(std::deque)</a></th><th>特化 <a href="https://zh.cppreference.com/w/cpp/algorithm/swap">std::swap</a> 算法 (函数模板)</th></tr></thead><tbody><tr><td><a href="https://zh.cppreference.com/w/cpp/container/deque/erase2">erase(std::deque) erase_if(std::deque)</a>(C++20)</td><td>擦除所有满足特定判别标准的元素 (函数模板)</td></tr></tbody></table><h2><span id="std-forward-list">std::forward_list</span><a href="#std-forward-list" class="header-anchor">#</a></h2><blockquote><p>定义于头文件 <code>&lt;forward_list&gt;</code></p></blockquote><ul><li>单链表</li></ul><p><code>std::forward_list</code> 是支持从容器中的任何位置快速插入和移除元素的容器。<strong>不支持快速随机访问</strong>。它实现为单链表，且实质上与其在 C 中实现相比无任何开销。与 <a href="https://zh.cppreference.com/w/cpp/container/list">std::list</a> 相比，此容器在不需要双向迭代时提供更有效地利用空间的存储。</p><p>在链表内或跨数个链表添加、移除和移动元素，不会非法化当前指代链表中其他元素的迭代器。然而，在从链表移除元素（通过 <a href="https://zh.cppreference.com/w/cpp/container/forward_list/erase_after">erase_after</a> ）时，指代对应元素的迭代器或引用会被非法化。</p><table><thead><tr><th>元素访问</th><th></th></tr></thead><tbody><tr><td><a href="https://zh.cppreference.com/w/cpp/container/forward_list/front">front</a>(C++11)</td><td>访问第一个元素 (公开成员函数)</td></tr><tr><td>迭代器</td><td></td></tr><tr><td><a href="https://zh.cppreference.com/w/cpp/container/forward_list/before_begin">before_begincbefore_begin</a>(C++11)</td><td>返回指向第一个元素之前迭代器 (公开成员函数)</td></tr><tr><td><a href="https://zh.cppreference.com/w/cpp/container/forward_list/begin">begincbegin</a>(C++11)</td><td>返回指向起始的迭代器 (公开成员函数)</td></tr><tr><td><a href="https://zh.cppreference.com/w/cpp/container/forward_list/end">endcend</a>(C++11)</td><td>返回指向末尾的迭代器 (公开成员函数)</td></tr><tr><td>容量</td><td></td></tr><tr><td><a href="https://zh.cppreference.com/w/cpp/container/forward_list/empty">empty</a>(C++11)</td><td>检查容器是否为空 (公开成员函数)</td></tr><tr><td><a href="https://zh.cppreference.com/w/cpp/container/forward_list/max_size">max_size</a>(C++11)</td><td>返回可容纳的最大元素数 (公开成员函数)</td></tr><tr><td>修改器</td><td></td></tr><tr><td><a href="https://zh.cppreference.com/w/cpp/container/forward_list/clear">clear</a>(C++11)</td><td>清除内容 (公开成员函数)</td></tr><tr><td><a href="https://zh.cppreference.com/w/cpp/container/forward_list/insert_after">insert_after</a>(C++11)</td><td>在某个元素后插入新元素 (公开成员函数)</td></tr><tr><td><a href="https://zh.cppreference.com/w/cpp/container/forward_list/emplace_after">emplace_after</a>(C++11)</td><td>在元素后原位构造元素 (公开成员函数)</td></tr><tr><td><a href="https://zh.cppreference.com/w/cpp/container/forward_list/erase_after">erase_after</a>(C++11)</td><td>擦除元素后的元素 (公开成员函数)</td></tr><tr><td><a href="https://zh.cppreference.com/w/cpp/container/forward_list/push_front">push_front</a>(C++11)</td><td>插入元素到容器起始 (公开成员函数)</td></tr><tr><td><a href="https://zh.cppreference.com/w/cpp/container/forward_list/emplace_front">emplace_front</a>(C++11)</td><td>在容器头部原位构造元素 (公开成员函数)</td></tr><tr><td><a href="https://zh.cppreference.com/w/cpp/container/forward_list/pop_front">pop_front</a>(C++11)</td><td>移除首元素 (公开成员函数)</td></tr><tr><td><a href="https://zh.cppreference.com/w/cpp/container/forward_list/resize">resize</a>(C++11)</td><td>改变容器中可存储元素的个数 (公开成员函数)</td></tr><tr><td><a href="https://zh.cppreference.com/w/cpp/container/forward_list/swap">swap</a>(C++11)</td><td>交换内容 (公开成员函数)</td></tr><tr><td>操作</td><td></td></tr><tr><td><a href="https://zh.cppreference.com/w/cpp/container/forward_list/merge">merge</a>(C++11)</td><td>合并二个已排序列表 (公开成员函数)</td></tr><tr><td><a href="https://zh.cppreference.com/w/cpp/container/forward_list/splice_after">splice_after</a>(C++11)</td><td>从另一 <code>forward_list</code> 移动元素 (公开成员函数)</td></tr><tr><td><a href="https://zh.cppreference.com/w/cpp/container/forward_list/remove">removeremove_if</a>(C++11)</td><td>移除满足特定标准的元素 (公开成员函数)</td></tr><tr><td><a href="https://zh.cppreference.com/w/cpp/container/forward_list/reverse">reverse</a>(C++11)</td><td>将该链表的所有元素的顺序反转 (公开成员函数)</td></tr><tr><td><a href="https://zh.cppreference.com/w/cpp/container/forward_list/unique">unique</a>(C++11)</td><td>删除连续的重复元素 (公开成员函数)</td></tr><tr><td><a href="https://zh.cppreference.com/w/cpp/container/forward_list/sort">sort</a>(C++11)</td><td>对元素进行排序 (公开成员函数)</td></tr></tbody></table><table><thead><tr><th><a href="https://zh.cppreference.com/w/cpp/container/forward_list/swap2">std::swap(std::forward_list)</a>(C++11)</th><th>特化 <a href="https://zh.cppreference.com/w/cpp/algorithm/swap">std::swap</a> 算法 (函数模板)</th></tr></thead><tbody><tr><td><a href="https://zh.cppreference.com/w/cpp/container/forward_list/erase2">erase(std::forward_list) erase_if(std::forward_list)</a>(C++20)</td><td>擦除所有满足特定判别标准的元素 (函数模板)</td></tr></tbody></table><h2><span id="std-list">std::list</span><a href="#std-list" class="header-anchor">#</a></h2><blockquote><p> 定义于头文件 <code>&lt;list&gt;</code></p></blockquote><p>双链表</p><p><code>std::list</code> 是支持常数时间从容器任何位置插入和移除元素的容器。<strong>不支持快速随机访问</strong>。它通常实现为双向链表。与 <a href="https://zh.cppreference.com/w/cpp/container/forward_list">std::forward_list</a> 相比，此容器提供双向迭代但在空间上效率稍低。</p><p>在 list 内或在数个 list 间添加、移除和移动元素不会非法化迭代器或引用。迭代器仅在对应元素被删除时非法化。</p><table><thead><tr><th>元素访问</th><th></th></tr></thead><tbody><tr><td><a href="https://zh.cppreference.com/w/cpp/container/list/front">front</a></td><td>访问第一个元素 (公开成员函数)</td></tr><tr><td><a href="https://zh.cppreference.com/w/cpp/container/list/back">back</a></td><td>访问最后一个元素 (公开成员函数)</td></tr><tr><td>迭代器</td><td></td></tr><tr><td><a href="https://zh.cppreference.com/w/cpp/container/list/begin">begincbegin</a>(C++11)</td><td>返回指向起始的迭代器 (公开成员函数)</td></tr><tr><td><a href="https://zh.cppreference.com/w/cpp/container/list/end">endcend</a>(C++11)</td><td>返回指向末尾的迭代器 (公开成员函数)</td></tr><tr><td><a href="https://zh.cppreference.com/w/cpp/container/list/rbegin">rbegincrbegin</a>(C++11)</td><td>返回指向起始的逆向迭代器 (公开成员函数)</td></tr><tr><td><a href="https://zh.cppreference.com/w/cpp/container/list/rend">rendcrend</a>(C++11)</td><td>返回指向末尾的逆向迭代器 (公开成员函数)</td></tr><tr><td>容量</td><td></td></tr><tr><td><a href="https://zh.cppreference.com/w/cpp/container/list/empty">empty</a></td><td>检查容器是否为空 (公开成员函数)</td></tr><tr><td><a href="https://zh.cppreference.com/w/cpp/container/list/size">size</a></td><td>返回容纳的元素数 (公开成员函数)</td></tr><tr><td><a href="https://zh.cppreference.com/w/cpp/container/list/max_size">max_size</a></td><td>返回可容纳的最大元素数 (公开成员函数)</td></tr><tr><td>修改器</td><td></td></tr><tr><td><a href="https://zh.cppreference.com/w/cpp/container/list/clear">clear</a></td><td>清除内容 (公开成员函数)</td></tr><tr><td><a href="https://zh.cppreference.com/w/cpp/container/list/insert">insert</a></td><td>插入元素 (公开成员函数)</td></tr><tr><td><a href="https://zh.cppreference.com/w/cpp/container/list/emplace">emplace</a>(C++11)</td><td>原位构造元素 (公开成员函数)</td></tr><tr><td><a href="https://zh.cppreference.com/w/cpp/container/list/erase">erase</a></td><td>擦除元素 (公开成员函数)</td></tr><tr><td><a href="https://zh.cppreference.com/w/cpp/container/list/push_back">push_back</a></td><td>将元素添加到容器末尾 (公开成员函数)</td></tr><tr><td><a href="https://zh.cppreference.com/w/cpp/container/list/emplace_back">emplace_back</a>(C++11)</td><td>在容器末尾就地构造元素 (公开成员函数)</td></tr><tr><td><a href="https://zh.cppreference.com/w/cpp/container/list/pop_back">pop_back</a></td><td>移除末元素 (公开成员函数)</td></tr><tr><td><a href="https://zh.cppreference.com/w/cpp/container/list/push_front">push_front</a></td><td>插入元素到容器起始 (公开成员函数)</td></tr><tr><td><a href="https://zh.cppreference.com/w/cpp/container/list/emplace_front">emplace_front</a>(C++11)</td><td>在容器头部原位构造元素 (公开成员函数)</td></tr><tr><td><a href="https://zh.cppreference.com/w/cpp/container/list/pop_front">pop_front</a></td><td>移除首元素 (公开成员函数)</td></tr><tr><td><a href="https://zh.cppreference.com/w/cpp/container/list/resize">resize</a></td><td>改变容器中可存储元素的个数 (公开成员函数)</td></tr><tr><td><a href="https://zh.cppreference.com/w/cpp/container/list/swap">swap</a></td><td>交换内容 (公开成员函数)</td></tr><tr><td>操作</td><td></td></tr><tr><td><a href="https://zh.cppreference.com/w/cpp/container/list/merge">merge</a></td><td>合并二个已排序列表 (公开成员函数)</td></tr><tr><td><a href="https://zh.cppreference.com/w/cpp/container/list/splice">splice</a></td><td>从另一个<code>list</code>中移动元素 (公开成员函数)</td></tr><tr><td><a href="https://zh.cppreference.com/w/cpp/container/list/remove">removeremove_if</a></td><td>移除满足特定标准的元素 (公开成员函数)</td></tr><tr><td><a href="https://zh.cppreference.com/w/cpp/container/list/reverse">reverse</a></td><td>将该链表的所有元素的顺序反转 (公开成员函数)</td></tr><tr><td><a href="https://zh.cppreference.com/w/cpp/container/list/unique">unique</a></td><td>删除连续的重复元素 (公开成员函数)</td></tr><tr><td><a href="https://zh.cppreference.com/w/cpp/container/list/sort">sort</a></td><td>对元素进行排序 (公开成员函数)</td></tr></tbody></table><table><thead><tr><th><a href="https://zh.cppreference.com/w/cpp/container/list/swap2">std::swap(std::list)</a></th><th>特化 <a href="https://zh.cppreference.com/w/cpp/algorithm/swap">std::swap</a> 算法 (函数模板)</th></tr></thead><tbody><tr><td><a href="https://zh.cppreference.com/w/cpp/container/list/erase2">erase(std::list)erase_if(std::list)</a>(C++20)</td><td>擦除所有满足特定判别标准的元素 (函数模板)</td></tr></tbody></table>]]></content>
    
    
    
    <tags>
      
      <tag>Sequence</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>日期和时间工具</title>
    <link href="/2022/01/18/%E6%97%A5%E6%9C%9F%E5%92%8C%E6%97%B6%E9%97%B4%E5%B7%A5%E5%85%B7/"/>
    <url>/2022/01/18/%E6%97%A5%E6%9C%9F%E5%92%8C%E6%97%B6%E9%97%B4%E5%B7%A5%E5%85%B7/</url>
    
    <content type="html"><![CDATA[<div class="toc"><!-- toc --><ul><li><a href="#ri-qi-he-shi-jian-gong-ju">日期和时间工具</a><ul><li><a href="#std-chrono-ku-https-zh-cppreference-com-w-cpp-header-chrono"><code>std::chrono</code> 库</a></li></ul><ul><li><a href="#shi-zhong-1">时钟</a><ul><li><a href="#std-chrono-system-clock-now">std::chrono::system_clock::now()</a></li><li><a href="#std-chrono-steady-clock-now">std::chrono::steady_clock::now()</a></li><li><a href="#std-chrono-utc-clock-now">std::chrono::utc_clock::now()</a></li><li><a href="#std-chrono-tai-clock-now">std::chrono::tai_clock::now()</a></li><li><a href="#std-chrono-gps-clock-now">std::chrono::gps_clock::now()</a></li><li><a href="#std-chrono-file-clock-now">std::chrono::file_clock::now()</a></li></ul></li><li><a href="#shi-jian-dian-1">时间点</a><ul><li><a href="#std-chrono-time-point-std-chrono-system-clock"><code>std::chrono::time_point&lt;std::chrono::system_clock</code>&gt;</a></li></ul></li><li><a href="#shi-chang-1">时长</a></li></ul></li></ul><!-- tocstop --></div><p>此文来源于👉<a href="https://zh.cppreference.com/w/cpp/chrono">日期和时间工具 - cppreference.com</a></p><h1><span id="ri-qi-he-shi-jian-gong-ju">日期和时间工具</span><a href="#ri-qi-he-shi-jian-gong-ju" class="header-anchor">#</a></h1><h3><span id="std-chrono-ku"></span><a href="#std-chrono-ku" class="header-anchor">#</a></h3><ul><li>时钟</li><li>时长</li><li>时间点</li></ul><h4><span id="shi-zhong">时钟</span><a href="#shi-zhong" class="header-anchor">#</a></h4><table><thead><tr><th><a href="https://zh.cppreference.com/w/cpp/chrono/system_clock">system_clock</a>(C++11)</th><th>来自系统范畴实时时钟的挂钟时间 (类)</th></tr></thead><tbody><tr><td><a href="https://zh.cppreference.com/w/cpp/chrono/steady_clock">steady_clock</a>(C++11)</td><td>决不会调整的单调时钟 (类)</td></tr><tr><td><a href="https://zh.cppreference.com/w/cpp/chrono/high_resolution_clock">high_resolution_clock</a>(C++11)</td><td>拥有可用的最短嘀嗒周期的时钟 (类)</td></tr><tr><td><a href="https://zh.cppreference.com/w/cpp/chrono/is_clock">is_clockis_clock_v</a>(C++20)</td><td>确定类型是否为<a href="https://zh.cppreference.com/w/cpp/named_req/Clock"><em>时钟</em> <em>(Clock)</em></a> (类模板) (变量模板)</td></tr><tr><td><a href="https://zh.cppreference.com/w/cpp/chrono/utc_clock">utc_clock</a>(C++20)</td><td>协调世界时 (UTC) 的<a href="https://zh.cppreference.com/w/cpp/named_req/Clock"><em>时钟</em> <em>(Clock)</em></a> (类)</td></tr><tr><td><a href="https://zh.cppreference.com/w/cpp/chrono/tai_clock">tai_clock</a>(C++20)</td><td>国际原子时 (TAI) 的<a href="https://zh.cppreference.com/w/cpp/named_req/Clock"><em>时钟</em> <em>(Clock)</em></a> (类)</td></tr><tr><td><a href="https://zh.cppreference.com/w/cpp/chrono/gps_clock">gps_clock</a>(C++20)</td><td>GPS 时间的<a href="https://zh.cppreference.com/w/cpp/named_req/Clock"><em>时钟</em> <em>(Clock)</em></a> (类)</td></tr><tr><td><a href="https://zh.cppreference.com/w/cpp/chrono/file_clock">file_clock</a>(C++20)</td><td>用于<a href="https://zh.cppreference.com/w/cpp/filesystem/file_time_type">文件时间</a>的<a href="https://zh.cppreference.com/w/cpp/named_req/Clock"><em>时钟</em> <em>(Clock)</em></a> (typedef)</td></tr><tr><td><a href="https://zh.cppreference.com/w/cpp/chrono/local_t">local_t</a>(C++20)</td><td>表示本地时间的伪时钟</td></tr></tbody></table><h4><span id="shi-jian-dian">时间点</span><a href="#shi-jian-dian" class="header-anchor">#</a></h4><p>时间点是从特定时钟的纪元开始经过的时间时长。</p><table><thead><tr><th>定义于头文件 <code>&lt;chrono&gt;</code></th><th></th></tr></thead><tbody><tr><td>定义于命名空间 <code>std::chrono</code></td><td></td></tr><tr><td><a href="https://zh.cppreference.com/w/cpp/chrono/time_point">time_point</a>(C++11)</td><td>时间中的点 (类模板)</td></tr><tr><td><a href="https://zh.cppreference.com/w/cpp/chrono/clock_time_conversion">clock_time_conversion</a>(C++20)</td><td>定义如何转换一个时钟的时间点为另一个的特性类 (类模板)</td></tr><tr><td><a href="https://zh.cppreference.com/w/cpp/chrono/clock_cast">clock_cast</a>(C++20)</td><td>转换一个时钟的时间点为另一个 (函数模板)</td></tr></tbody></table><h4><span id="shi-chang">时长</span><a href="#shi-chang" class="header-anchor">#</a></h4><p>时长由时间跨度组成，定义为某时间单位的某个计次数。例如，“ 42 秒”可表示为由 42 个 1 秒时间点位的计次所组成的时长。</p><table><thead><tr><th>定义于头文件 <code>&lt;chrono&gt;</code></th><th></th></tr></thead><tbody><tr><td>定义于命名空间 <code>std::chrono</code></td><td></td></tr><tr><td><a href="https://zh.cppreference.com/w/cpp/chrono/duration">duration</a>(C++11)</td><td>时间区间 (类模板)</td></tr></tbody></table><h4><span id="dang-tian-shi-ke">当天时刻</span><a href="#dang-tian-shi-ke" class="header-anchor">#</a></h4><p><code>hh_mm_ss</code> 只要可能就将表示自午夜起经过时间的时长分割成时、分、秒和秒的小数部分。它主要是格式化工具。</p><table><thead><tr><th>定义于头文件 <code>&lt;chrono&gt;</code></th><th></th></tr></thead><tbody><tr><td>定义于命名空间 <code>std::chrono</code></td><td></td></tr><tr><td><a href="https://zh.cppreference.com/w/cpp/chrono/hh_mm_ss">hh_mm_ss</a>(C++20)</td><td>表示当天时刻 (类模板)</td></tr><tr><td><a href="https://zh.cppreference.com/w/cpp/chrono/hour_fun">is_am is_pm make12 make24</a>(C++20)</td><td>在 12 时和 24 时格式当天时刻之间翻译 (函数)</td></tr></tbody></table><h4><span id="ri-li">日历</span><a href="#ri-li" class="header-anchor">#</a></h4><table><thead><tr><th>定义于头文件 <code>&lt;chrono&gt;</code></th><th></th></tr></thead><tbody><tr><td>定义于命名空间 <code>std::chrono</code></td><td></td></tr><tr><td><a href="https://zh.cppreference.com/w/cpp/chrono/last_spec">last_spec</a>(C++20)</td><td>指示一个月中<em>最后</em>日期或星期的标签类 (类)</td></tr><tr><td><a href="https://zh.cppreference.com/w/cpp/chrono/day">day</a>(C++20)</td><td>表示月之日期 (类)</td></tr><tr><td><a href="https://zh.cppreference.com/w/cpp/chrono/month">month</a>(C++20)</td><td>表示年之月份 (类)</td></tr><tr><td><a href="https://zh.cppreference.com/w/cpp/chrono/year">year</a>(C++20)</td><td>表示格里高利历中的年 (类)</td></tr><tr><td><a href="https://zh.cppreference.com/w/cpp/chrono/weekday">weekday</a>(C++20)</td><td>表示格里高利历中星期之日 (类)</td></tr><tr><td><a href="https://zh.cppreference.com/w/cpp/chrono/weekday_indexed">weekday_indexed</a>(C++20)</td><td>表示月份的第 n 个 <a href="https://zh.cppreference.com/w/cpp/chrono/weekday"><code>weekday</code></a> (类)</td></tr><tr><td><a href="https://zh.cppreference.com/w/cpp/chrono/weekday_last">weekday_last</a>(C++20)</td><td>表示月份的最后一个 <a href="https://zh.cppreference.com/w/cpp/chrono/weekday"><code>weekday</code></a> (类)</td></tr><tr><td><a href="https://zh.cppreference.com/w/cpp/chrono/month_day">month_day</a>(C++20)</td><td>表示特定 <a href="https://zh.cppreference.com/w/cpp/chrono/month"><code>month</code></a> 的特定 <a href="https://zh.cppreference.com/w/cpp/chrono/day"><code>day</code></a> (类)</td></tr><tr><td><a href="https://zh.cppreference.com/w/cpp/chrono/month_day_last">month_day_last</a>(C++20)</td><td>表示特定 <a href="https://zh.cppreference.com/w/cpp/chrono/month"><code>month</code></a> 的最后一日 (类)</td></tr><tr><td><a href="https://zh.cppreference.com/w/cpp/chrono/month_weekday">month_weekday</a>(C++20)</td><td>表示特定 <a href="https://zh.cppreference.com/w/cpp/chrono/month"><code>month</code></a> 的第 n 个 <a href="https://zh.cppreference.com/w/cpp/chrono/weekday"><code>weekday</code></a> (类)</td></tr><tr><td><a href="https://zh.cppreference.com/w/cpp/chrono/month_weekday_last">month_weekday_last</a>(C++20)</td><td>表示特定 <a href="https://zh.cppreference.com/w/cpp/chrono/month"><code>month</code></a> 的最后一个 <a href="https://zh.cppreference.com/w/cpp/chrono/weekday"><code>weekday</code></a> (类)</td></tr><tr><td><a href="https://zh.cppreference.com/w/cpp/chrono/year_month">year_month</a>(C++20)</td><td>表示特定 <a href="https://zh.cppreference.com/w/cpp/chrono/year"><code>year</code></a> 的特定 <a href="https://zh.cppreference.com/w/cpp/chrono/month"><code>month</code></a> (类)</td></tr><tr><td><a href="https://zh.cppreference.com/w/cpp/chrono/year_month_day">year_month_day</a>(C++20)</td><td>表示特定的 <a href="https://zh.cppreference.com/w/cpp/chrono/year"><code>year</code></a> 、 <a href="https://zh.cppreference.com/w/cpp/chrono/month"><code>month</code></a> 和 <a href="https://zh.cppreference.com/w/cpp/chrono/day"><code>day</code></a> (类)</td></tr><tr><td><a href="https://zh.cppreference.com/w/cpp/chrono/year_month_day_last">year_month_day_last</a>(C++20)</td><td>表示特定 <a href="https://zh.cppreference.com/w/cpp/chrono/year"><code>year</code></a> 和 <a href="https://zh.cppreference.com/w/cpp/chrono/month"><code>month</code></a> 的最后一日 (类)</td></tr><tr><td><a href="https://zh.cppreference.com/w/cpp/chrono/year_month_weekday">year_month_weekday</a>(C++20)</td><td>表示特定 <a href="https://zh.cppreference.com/w/cpp/chrono/year"><code>year</code></a> 和 <a href="https://zh.cppreference.com/w/cpp/chrono/month"><code>month</code></a> 的第 n 个 <a href="https://zh.cppreference.com/w/cpp/chrono/weekday"><code>weekday</code></a> (类)</td></tr><tr><td><a href="https://zh.cppreference.com/w/cpp/chrono/year_month_weekday_last">year_month_weekday_last</a>(C++20)</td><td>表示特定 <a href="https://zh.cppreference.com/w/cpp/chrono/year"><code>year</code></a> 和 <a href="https://zh.cppreference.com/w/cpp/chrono/month"><code>month</code></a> 的最后一个 <a href="https://zh.cppreference.com/w/cpp/chrono/weekday"><code>weekday</code></a> (类)</td></tr><tr><td><a href="https://zh.cppreference.com/w/cpp/chrono/operator_slash">operator/</a>(C++20)</td><td>创建格里高利历日期的约定语法 (函数)</td></tr></tbody></table><h4><span id="shi-qu">时区</span><a href="#shi-qu" class="header-anchor">#</a></h4><table><thead><tr><th>定义于头文件 <code>&lt;chrono&gt;</code></th><th></th></tr></thead><tbody><tr><td>定义于命名空间 <code>std::chrono</code></td><td></td></tr><tr><td><a href="https://zh.cppreference.com/w/cpp/chrono/tzdb">tzdb</a>(C++20)</td><td>描述 IANA 时区数据库的副本 (类)</td></tr><tr><td><a href="https://zh.cppreference.com/w/cpp/chrono/tzdb_list">tzdb_list</a>(C++20)</td><td>表示 <a href="https://zh.cppreference.com/w/cpp/chrono/tzdb"><code>tzdb</code></a> 的链表 (类)</td></tr><tr><td><a href="https://zh.cppreference.com/w/cpp/chrono/tzdb_functions">get_tzdbget_tzdb_listreload_tzdbremote_version</a>(C++20)</td><td>访问和控制全球时区数据库信息 (函数)</td></tr><tr><td><a href="https://zh.cppreference.com/w/cpp/chrono/locate_zone">locate_zone</a>(C++20)</td><td>定位基于其名称的 <a href="https://zh.cppreference.com/w/cpp/chrono/time_zone"><code>time_zone</code></a> (函数)</td></tr><tr><td><a href="https://zh.cppreference.com/w/cpp/chrono/current_zone">current_zone</a>(C++20)</td><td>返回当前的 <a href="https://zh.cppreference.com/w/cpp/chrono/time_zone"><code>time_zone</code></a> (函数)</td></tr><tr><td><a href="https://zh.cppreference.com/w/cpp/chrono/time_zone">time_zone</a>(C++20)</td><td>表示时区 (类)</td></tr><tr><td><a href="https://zh.cppreference.com/w/cpp/chrono/sys_info">sys_info</a>(C++20)</td><td>表示在特定时间点的关于时区的信息 (类)</td></tr><tr><td><a href="https://zh.cppreference.com/w/cpp/chrono/local_info">local_info</a>(C++20)</td><td>表示关于从本地时间转换到 UNIX 时间的信息 (类)</td></tr><tr><td><a href="https://zh.cppreference.com/w/cpp/chrono/choose">choose</a>(C++20)</td><td>选择应如何解析歧义的本地时间 (枚举)</td></tr><tr><td><a href="https://zh.cppreference.com/w/cpp/chrono/zoned_traits">zoned_traits</a>(C++20)</td><td><a href="https://zh.cppreference.com/w/cpp/chrono/zoned_time"><code>zoned_time</code></a> 所用的时区指针的特性类 (类模板)</td></tr><tr><td><a href="https://zh.cppreference.com/w/cpp/chrono/zoned_time">zoned_time</a>(C++20)</td><td>表示时区和时间点 (类)</td></tr><tr><td><a href="https://zh.cppreference.com/w/cpp/chrono/leap_second">leap_second</a>(C++20)</td><td>含有关于插入闰秒的信息 (类)</td></tr><tr><td><a href="https://zh.cppreference.com/w/cpp/chrono/time_zone_link">time_zone_link</a>(C++20)</td><td>表示时区的替用名 (类)</td></tr><tr><td><a href="https://zh.cppreference.com/w/cpp/chrono/nonexistent_local_time">nonexistent_local_time</a>(C++20)</td><td>抛出以报告本地时间不存在的异常 (类)</td></tr><tr><td><a href="https://zh.cppreference.com/w/cpp/chrono/ambiguous_local_time">ambiguous_local_time</a>(C++20)</td><td>抛出以报告本地时间有歧义的异常 (类)</td></tr></tbody></table><h2><span id="shi-zhong">时钟</span><a href="#shi-zhong" class="header-anchor">#</a></h2><h3><span id="std-chrono-system-clock-now">std::chrono::system_clock::now()</span><a href="#std-chrono-system-clock-now" class="header-anchor">#</a></h3><blockquote><p>返回表示当前时间的时间点。</p></blockquote><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;numeric&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;chrono&gt;</span></span> <span class="hljs-keyword">volatile</span> <span class="hljs-type">int</span> sink;<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>{    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> size = <span class="hljs-number">1ull</span>; size &lt; <span class="hljs-number">1000000000ull</span>; size *= <span class="hljs-number">100</span>) {        <span class="hljs-comment">// 记录开始时间</span>        <span class="hljs-keyword">auto</span> start = std::chrono::system_clock::<span class="hljs-built_in">now</span>();        <span class="hljs-comment">// 做一些工作</span>        <span class="hljs-function">std::vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">v</span><span class="hljs-params">(size, <span class="hljs-number">42</span>)</span></span>;        sink = std::<span class="hljs-built_in">accumulate</span>(v.<span class="hljs-built_in">begin</span>(), v.<span class="hljs-built_in">end</span>(), <span class="hljs-number">0u</span>); <span class="hljs-comment">// 确保其副效应</span>        <span class="hljs-comment">// 记录结束时间</span>        <span class="hljs-keyword">auto</span> end = std::chrono::system_clock::<span class="hljs-built_in">now</span>();        std::chrono::duration&lt;<span class="hljs-type">double</span>&gt; diff = end-start;        std::cout &lt;&lt; <span class="hljs-string">"Time to fill and iterate a vector of "</span>                   &lt;&lt; size &lt;&lt; <span class="hljs-string">" ints : "</span> &lt;&lt; diff.<span class="hljs-built_in">count</span>() &lt;&lt; <span class="hljs-string">" s\n"</span>;    }}</code></pre></div><h3><span id="std-chrono-steady-clock-now">std::chrono::steady_clock::now()</span><a href="#std-chrono-steady-clock-now" class="header-anchor">#</a></h3><blockquote><p>返回表示当前时间的时间点。</p></blockquote><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;numeric&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;chrono&gt;</span></span> <span class="hljs-keyword">volatile</span> <span class="hljs-type">int</span> sink;<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>{    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> size = <span class="hljs-number">1ull</span>; size &lt; <span class="hljs-number">1000000000ull</span>; size *= <span class="hljs-number">100</span>) {        <span class="hljs-comment">// 记录开始时间</span>        <span class="hljs-keyword">auto</span> start = std::chrono::steady_clock::<span class="hljs-built_in">now</span>();        <span class="hljs-comment">// 做一些工作</span>        <span class="hljs-function">std::vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">v</span><span class="hljs-params">(size, <span class="hljs-number">42</span>)</span></span>;        sink = std::<span class="hljs-built_in">accumulate</span>(v.<span class="hljs-built_in">begin</span>(), v.<span class="hljs-built_in">end</span>(), <span class="hljs-number">0u</span>); <span class="hljs-comment">// 确保其副效应</span>        <span class="hljs-comment">// 记录结束时间</span>        <span class="hljs-keyword">auto</span> end = std::chrono::steady_clock::<span class="hljs-built_in">now</span>();        std::chrono::duration&lt;<span class="hljs-type">double</span>&gt; diff = end-start;        std::cout &lt;&lt; <span class="hljs-string">"Time to fill and iterate a vector of "</span>                   &lt;&lt; size &lt;&lt; <span class="hljs-string">" ints : "</span> &lt;&lt; diff.<span class="hljs-built_in">count</span>() &lt;&lt; <span class="hljs-string">" s\n"</span>;    }}</code></pre></div><blockquote><blockquote><blockquote><p>对时长度量使用 <code>steady_clock</code> ，对壁钟时间使用 <code>system_clock</code> 。</p></blockquote></blockquote></blockquote><h3><span id="std-chrono-utc-clock-now">std::chrono::utc_clock::now()</span><a href="#std-chrono-utc-clock-now" class="header-anchor">#</a></h3><blockquote><p>返回表示当前时间的时间点</p></blockquote><h3><span id="std-chrono-tai-clock-now">std::chrono::tai_clock::now()</span><a href="#std-chrono-tai-clock-now" class="header-anchor">#</a></h3><blockquote><p>返回表示当前时间的时间点。</p></blockquote><h3><span id="std-chrono-gps-clock-now">std::chrono::gps_clock::now()</span><a href="#std-chrono-gps-clock-now" class="header-anchor">#</a></h3><blockquote><p>返回表示当前时间的时间点。</p></blockquote><h3><span id="std-chrono-file-clock-now">std::chrono::file_clock::now()</span><a href="#std-chrono-file-clock-now" class="header-anchor">#</a></h3><blockquote><p>返回表示当前时间的时间点。</p></blockquote><h2><span id="shi-jian-dian">时间点</span><a href="#shi-jian-dian" class="header-anchor">#</a></h2><blockquote><p> 时间点是从特定时钟的纪元开始经过的时间时长。</p></blockquote><h3><span id="std-chrono-time-point-lt-std-chrono-system-clock-gt"><code>std::chrono::time_point&lt;std::chrono::system_clock</code>&gt;</span><a href="#std-chrono-time-point-lt-std-chrono-system-clock-gt" class="header-anchor">#</a></h3><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iomanip&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;ctime&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;chrono&gt;</span></span> <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">slow_motion</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>{    <span class="hljs-type">static</span> <span class="hljs-type">int</span> a[] {<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>,<span class="hljs-number">7</span>,<span class="hljs-number">8</span>,<span class="hljs-number">9</span>,<span class="hljs-number">10</span>,<span class="hljs-number">11</span>,<span class="hljs-number">12</span>};    <span class="hljs-keyword">while</span> (std::ranges::<span class="hljs-built_in">next_permutation</span>(a).found)    { } <span class="hljs-comment">// 生成 12! 个排列</span>} <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>{    <span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std::literals; <span class="hljs-comment">// 允许用 24h 、 1ms 、 1s 代替对应的</span>                                   <span class="hljs-comment">// std::chrono::hours(24) 等待</span>     <span class="hljs-type">const</span> std::chrono::time_point&lt;std::chrono::system_clock&gt; now =        std::chrono::system_clock::<span class="hljs-built_in">now</span>();        <span class="hljs-comment">// “生产代码”可以简化为：</span>        <span class="hljs-comment">// const auto now = std::chrono::system_clock::now();</span>     <span class="hljs-type">const</span> std::<span class="hljs-type">time_t</span> t_c = std::chrono::system_clock::<span class="hljs-built_in">to_time_t</span>(now - <span class="hljs-number">24</span>h);    std::cout &lt;&lt; <span class="hljs-string">"24 hours ago, the time was "</span>              &lt;&lt; std::<span class="hljs-built_in">put_time</span>(std::<span class="hljs-built_in">localtime</span>(&amp;t_c), <span class="hljs-string">"%F %T.\n"</span>) &lt;&lt; std::flush;     <span class="hljs-type">const</span> std::chrono::time_point&lt;std::chrono::steady_clock&gt; start =        std::chrono::steady_clock::<span class="hljs-built_in">now</span>();        <span class="hljs-comment">// “现实生活”的替用写法会是：</span>        <span class="hljs-comment">// const auto start = std::chrono::steady_clock::now();</span>     <span class="hljs-built_in">slow_motion</span>();     <span class="hljs-type">const</span> <span class="hljs-keyword">auto</span> end = std::chrono::steady_clock::<span class="hljs-built_in">now</span>();     std::cout      &lt;&lt; <span class="hljs-string">"Slow calculations took "</span>      &lt;&lt; std::chrono::<span class="hljs-built_in">duration_cast</span>&lt;std::chrono::microseconds&gt;(end - start).<span class="hljs-built_in">count</span>() &lt;&lt; <span class="hljs-string">"µs ≈ "</span>      &lt;&lt; (end - start) / <span class="hljs-number">1</span>ms &lt;&lt; <span class="hljs-string">"ms ≈ "</span> <span class="hljs-comment">// 几乎等价于以上形式，</span>      &lt;&lt; (end - start) / <span class="hljs-number">1</span>s &lt;&lt; <span class="hljs-string">"s.\n"</span>;  <span class="hljs-comment">// 但分别使用毫秒和秒</span>}</code></pre></div><h2><span id="shi-chang">时长</span><a href="#shi-chang" class="header-anchor">#</a></h2><p>摘录自<code>MSVC标准库</code></p><table><thead><tr><th align="left"><em>using</em> <strong>nanoseconds  = duration&lt;long long, nano&gt;</strong></th><th align="left">纳秒 std::chrono::nanoseconds</th></tr></thead><tbody><tr><td align="left"><em>using</em> <strong>microseconds = duration&lt;long long, micro&gt;</strong></td><td align="left">微秒 std::chrono::microseconds</td></tr><tr><td align="left"><em>using</em> <strong>milliseconds = duration&lt;long long, milli&gt;</strong></td><td align="left">毫秒 std::chrono::milliseconds</td></tr><tr><td align="left"><em>using</em> <strong>seconds = duration<long long></long></strong></td><td align="left">秒 std::chrono::seconds</td></tr><tr><td align="left"><em>using</em> <strong>minutes = duration&lt;int, ratio&lt;60&gt;&gt;</strong></td><td align="left">分钟 std::chrono::minutes</td></tr><tr><td align="left"><em>using</em> <strong>hours = duration&lt;int, ratio&lt;3600&gt;&gt;</strong></td><td align="left">小时 std::chrono::hours</td></tr><tr><td align="left"><em>using</em> <strong>days = duration&lt;int, ratio_multiply&lt;ratio&lt;24&gt;, hours::period&gt;&gt;</strong></td><td align="left">天 std::chrono::days</td></tr><tr><td align="left"><em>using</em> <strong>weeks = duration&lt;int, ratio_multiply&lt;ratio&lt;7&gt;, days::period&gt;&gt;</strong></td><td align="left">周 std::chrono::weeks</td></tr><tr><td align="left"><em>using</em> <strong>years = duration&lt;int, ratio_multiply&lt;ratio&lt;146097, 400&gt;, days::period&gt;&gt;</strong></td><td align="left">年 std::chrono::years</td></tr><tr><td align="left"><em>using</em> <strong>months = duration&lt;int, ratio_divide&lt;years::period, ratio&lt;12&gt;&gt;&gt;</strong></td><td align="left">月 std::chrono::months</td></tr></tbody></table><blockquote><p>注意：到 <code>hours</code> 为止的每个预定义时长类型至少涵盖 ±292 年的范围。</p></blockquote><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;chrono&gt;</span></span> <span class="hljs-keyword">constexpr</span> <span class="hljs-keyword">auto</span> year = <span class="hljs-number">31556952ll</span>; <span class="hljs-comment">// 格里高利历年的平均秒数</span> <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>{    <span class="hljs-keyword">using</span> shakes = std::chrono::duration&lt;<span class="hljs-type">int</span>, std::ratio&lt;<span class="hljs-number">1</span>, <span class="hljs-number">100000000</span>&gt;&gt;;    <span class="hljs-keyword">using</span> jiffies = std::chrono::duration&lt;<span class="hljs-type">int</span>, std::centi&gt;;    <span class="hljs-keyword">using</span> microfortnights = std::chrono::duration&lt;<span class="hljs-type">float</span>, std::ratio&lt;<span class="hljs-number">14</span>*<span class="hljs-number">24</span>*<span class="hljs-number">60</span>*<span class="hljs-number">60</span>, <span class="hljs-number">1000000</span>&gt;&gt;;    <span class="hljs-keyword">using</span> nanocenturies = std::chrono::duration&lt;<span class="hljs-type">float</span>, std::ratio&lt;<span class="hljs-number">100</span>*year, <span class="hljs-number">1000000000</span>&gt;&gt;;     std::<span class="hljs-function">chrono::seconds <span class="hljs-title">sec</span><span class="hljs-params">(<span class="hljs-number">1</span>)</span></span>;     std::cout &lt;&lt; <span class="hljs-string">"1 second is:\n"</span>;     <span class="hljs-comment">// 无精度损失的整数尺度转换：无转型</span>    std::cout &lt;&lt; std::chrono::<span class="hljs-built_in">microseconds</span>(sec).<span class="hljs-built_in">count</span>() &lt;&lt; <span class="hljs-string">" microseconds\n"</span>              &lt;&lt; <span class="hljs-built_in">shakes</span>(sec).<span class="hljs-built_in">count</span>() &lt;&lt; <span class="hljs-string">" shakes\n"</span>              &lt;&lt; <span class="hljs-built_in">jiffies</span>(sec).<span class="hljs-built_in">count</span>() &lt;&lt; <span class="hljs-string">" jiffies\n"</span>;     <span class="hljs-comment">// 有精度损失的整数尺度转换：需要转型</span>    std::cout &lt;&lt; std::chrono::<span class="hljs-built_in">duration_cast</span>&lt;std::chrono::minutes&gt;(sec).<span class="hljs-built_in">count</span>()              &lt;&lt; <span class="hljs-string">" minutes\n"</span>;     <span class="hljs-comment">// 浮点尺度转换：无转型</span>    std::cout &lt;&lt; <span class="hljs-built_in">microfortnights</span>(sec).<span class="hljs-built_in">count</span>() &lt;&lt; <span class="hljs-string">" microfortnights\n"</span>              &lt;&lt; <span class="hljs-built_in">nanocenturies</span>(sec).<span class="hljs-built_in">count</span>() &lt;&lt; <span class="hljs-string">" nanocenturies\n"</span>;}</code></pre></div>]]></content>
    
    
    
    <tags>
      
      <tag>Chrono</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C++无序容器</title>
    <link href="/2022/01/18/C-%E6%97%A0%E5%BA%8F%E5%AE%B9%E5%99%A8/"/>
    <url>/2022/01/18/C-%E6%97%A0%E5%BA%8F%E5%AE%B9%E5%99%A8/</url>
    
    <content type="html"><![CDATA[<div class="toc"><!-- toc --><ul><li><a href="#1-std-unordered-set-https-zh-cppreference-com-w-cpp-container-unordered-set">1. </a><a href="https://zh.cppreference.com/w/cpp/container/unordered_set">std::unordered_set</a></li><li><a href="#2-std-unordered-map">2. std::unordered_map</a></li><li><a href="#3-std-unordered-multiset">3. std::unordered_multiset</a></li><li><a href="#4-std-unordered-multimap">4. std::unordered_multimap</a></li></ul><!-- tocstop --></div><p>此文来自👉<a href="https://zh.cppreference.com/w/cpp/container">容器库 - cppreference.com</a></p><blockquote><p>容器库是类模板与算法的汇集，允许程序员简单地访问常见数据结构，例如队列、链表和栈。有三类容器——顺序容器、关联容器和无序关联容器——每种都被设计为支持不同组的操作</p></blockquote><p>无序关联容器提供能快速查找（均摊 <em>O(1)</em> ，最坏情况 <em>O(n)</em> 的复杂度）的无序（<strong>哈希</strong>）数据结构。</p><h3><span id="1-std-unordered-set">1. </span><a href="#1-std-unordered-set" class="header-anchor">#</a></h3><blockquote><p>唯一键的集合，按照键生成散列</p></blockquote><ul><li><p>unordered_set 是含有 Key 类型唯一对象集合的关联容器。<strong>搜索</strong>、<strong>插入</strong>和<strong>移除</strong>拥有<strong>平均常数时间复杂度</strong>。</p></li><li><p>在内部，元素并  <strong>不以任何特别顺序排序</strong>，而是组织进桶中。元素被放进哪个桶完全依赖其值的哈希。这允许对单独元素的快速访问，因为哈希一旦确定，就准确指代元素被放入的桶。</p></li><li><p><strong>不可修改容器元素</strong>（即使通过非 const 迭代器），因为修改可能 <strong>更改元素的哈希</strong>，并破坏容器。</p></li></ul><h4><span id="li-zi">例子</span><a href="#li-zi" class="header-anchor">#</a></h4><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unordered_set&gt;</span></span><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>{    <span class="hljs-comment">// 创建三个 string 的 unordered_set（映射到 string ）</span>    std::unordered_set&lt;std::string&gt; u = {        <span class="hljs-string">"RED"</span>,        <span class="hljs-string">"GREEN"</span>,        <span class="hljs-string">"BLUE"</span>        };    <span class="hljs-comment">// 迭代并打印 unordered_set 的关键和值</span>    <span class="hljs-keyword">for</span> (<span class="hljs-type">const</span> <span class="hljs-keyword">auto</span> &amp;n : u)    {        std::cout &lt;&lt; <span class="hljs-string">"Key:"</span> &lt;&lt; n &lt;&lt; <span class="hljs-string">"\n"</span>;    }    <span class="hljs-comment">// // 添加新入口到 unordered_set</span>    <span class="hljs-comment">// "BLACK";</span>    <span class="hljs-comment">// "WHITE";</span>    u.<span class="hljs-built_in">emplace</span>(<span class="hljs-string">"BLACK"</span>);    u.<span class="hljs-built_in">emplace</span>(<span class="hljs-string">"WHITE"</span>);    std::cout &lt;&lt; <span class="hljs-string">"-----------------------------------------------\n"</span>;    <span class="hljs-keyword">for</span> (<span class="hljs-type">const</span> <span class="hljs-keyword">auto</span> &amp;n : u) {        std::cout &lt;&lt; <span class="hljs-string">"Key:"</span> &lt;&lt; n &lt;&lt; <span class="hljs-string">"\n"</span>;    }    <span class="hljs-comment">// 用关键输出值</span>    <span class="hljs-keyword">for</span> (<span class="hljs-type">const</span> <span class="hljs-keyword">auto</span> &amp;n : {<span class="hljs-string">"BLACK"</span>, <span class="hljs-string">"WHITE"</span>}) {        <span class="hljs-keyword">if</span> (u.<span class="hljs-built_in">find</span>(n) != u.<span class="hljs-built_in">end</span>())         {            std::cout &lt;&lt; n &lt;&lt; <span class="hljs-string">": Found\n"</span>;        }        <span class="hljs-keyword">else</span> {            std::cout &lt;&lt; n &lt;&lt; <span class="hljs-string">"NOT found\n"</span>;         }            }       <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;}</code></pre></div><h3><span id="2-std-unordered-map">2. std::unordered_map</span><a href="#2-std-unordered-map" class="header-anchor">#</a></h3><blockquote><p>键值对的集合，按照键生成散列，键是唯一的</p></blockquote><ul><li><p><strong>unordered_map 是关联容器</strong>，含有带唯一键的<strong>键-值 pair</strong> 。搜索、插入和元素移除拥有平均常数时间复杂度。</p></li><li><p>元素在内部不以任何特定顺序排序，而是组织进桶中。元素放进哪个桶完全依赖于其键的哈希。这允许对单独元素的快速访问，因为一旦计算哈希，则它准确指代元素所放进的桶。</p></li></ul><h4><span id="li-zi">例子</span><a href="#li-zi" class="header-anchor">#</a></h4><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unordered_map&gt;</span></span> <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>{    <span class="hljs-comment">// 创建三个 string 的 unordered_map （映射到 string ）</span>    std::unordered_map&lt;std::string, std::string&gt; u = {        {<span class="hljs-string">"RED"</span>,<span class="hljs-string">"#FF0000"</span>},        {<span class="hljs-string">"GREEN"</span>,<span class="hljs-string">"#00FF00"</span>},        {<span class="hljs-string">"BLUE"</span>,<span class="hljs-string">"#0000FF"</span>}    };     <span class="hljs-comment">// 迭代并打印 unordered_map 的关键和值</span>    <span class="hljs-keyword">for</span>( <span class="hljs-type">const</span> <span class="hljs-keyword">auto</span>&amp; n : u ) {        std::cout &lt;&lt; <span class="hljs-string">"Key:["</span> &lt;&lt; n.first &lt;&lt; <span class="hljs-string">"] Value:["</span> &lt;&lt; n.second &lt;&lt; <span class="hljs-string">"]\n"</span>;    }     <span class="hljs-comment">// 添加新入口到 unordered_map</span>    u[<span class="hljs-string">"BLACK"</span>] = <span class="hljs-string">"#000000"</span>;    u[<span class="hljs-string">"WHITE"</span>] = <span class="hljs-string">"#FFFFFF"</span>;     <span class="hljs-comment">// 用关键输出值</span>    std::cout &lt;&lt; <span class="hljs-string">"The HEX of color RED is:["</span> &lt;&lt; u[<span class="hljs-string">"RED"</span>] &lt;&lt; <span class="hljs-string">"]\n"</span>;    std::cout &lt;&lt; <span class="hljs-string">"The HEX of color BLACK is:["</span> &lt;&lt; u[<span class="hljs-string">"BLACK"</span>] &lt;&lt; <span class="hljs-string">"]\n"</span>;     <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;}</code></pre></div><h3><span id="3-std-unordered-multiset">3. std::unordered_multiset</span><a href="#3-std-unordered-multiset" class="header-anchor">#</a></h3><blockquote><p>键的集合，按照键生成散列</p></blockquote><ul><li><p><strong>unordered_multiset 是关联容器</strong>，含有可能非唯一 <strong>Key 类型对象的集合</strong>。搜索、插入和移除拥有平均常数时间复杂度。</p></li><li><p>元素在内部并不以任何顺序排序，只是被组织到桶中。元素被放入哪个桶完全依赖其值的哈希。这允许快速访问单独的元素，因为一旦计算哈希，它就指代放置该元素的准确的桶。</p></li></ul><h4><span id="li-zi">例子</span><a href="#li-zi" class="header-anchor">#</a></h4><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unordered_set&gt;</span></span> <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>{  <span class="hljs-comment">// 简单比较演示</span>    std::unordered_multiset&lt;<span class="hljs-type">int</span>&gt; example = {<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>};     <span class="hljs-keyword">auto</span> search = example.<span class="hljs-built_in">find</span>(<span class="hljs-number">2</span>);    <span class="hljs-keyword">if</span> (search != example.<span class="hljs-built_in">end</span>()) {        std::cout &lt;&lt; <span class="hljs-string">"Found "</span> &lt;&lt; (*search) &lt;&lt; <span class="hljs-string">'\n'</span>;    } <span class="hljs-keyword">else</span> {        std::cout &lt;&lt; <span class="hljs-string">"Not found\n"</span>;    }  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>; }</code></pre></div><h3><span id="4-std-unordered-multimap">4. std::unordered_multimap</span><a href="#4-std-unordered-multimap" class="header-anchor">#</a></h3><blockquote><p>键值对的集合，按照键生成散列</p></blockquote><ul><li><p><strong>unordered_multimap 是无序关联容器</strong>，支持等价的关键（一个 unordered_multimap 可含有每个关键值的多个副本）和将关键与另一类型的值关联。 unordered_multimap 类支持向前迭代器。搜索、插入和移除拥有平均常数时间复杂度。</p></li><li><p>元素在内部不以任何特定顺序排序，而是组织到桶中。元素被放进哪个桶完全依赖于其关键的哈希。这允许到单独元素的快速访问，因为哈希一旦计算，则它指代元素被放进的准确的桶。</p></li></ul><h4><span id="li-zi">例子</span><a href="#li-zi" class="header-anchor">#</a></h4><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unordered_map&gt;</span></span> <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>{  <span class="hljs-comment">// 简单比较演示</span>    std::unordered_multimap&lt;<span class="hljs-type">int</span>,<span class="hljs-type">char</span>&gt; example = {{<span class="hljs-number">1</span>,<span class="hljs-string">'a'</span>},{<span class="hljs-number">2</span>,<span class="hljs-string">'b'</span>}};     <span class="hljs-keyword">auto</span> search = example.<span class="hljs-built_in">find</span>(<span class="hljs-number">2</span>);    <span class="hljs-keyword">if</span> (search != example.<span class="hljs-built_in">end</span>()) {        std::cout &lt;&lt; <span class="hljs-string">"Found "</span> &lt;&lt; search-&gt;first &lt;&lt; <span class="hljs-string">" "</span> &lt;&lt; search-&gt;second &lt;&lt; <span class="hljs-string">'\n'</span>;    } <span class="hljs-keyword">else</span> {        std::cout &lt;&lt; <span class="hljs-string">"Not found\n"</span>;    }   <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;}</code></pre></div>]]></content>
    
    
    
    <tags>
      
      <tag>C++</tag>
      
      <tag>哈希</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>动态内存管理</title>
    <link href="/2022/01/18/%E5%8A%A8%E6%80%81%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/"/>
    <url>/2022/01/18/%E5%8A%A8%E6%80%81%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/</url>
    
    <content type="html"><![CDATA[<div class="toc"><!-- toc --><ul><li><a href="#std-unique-ptr"><strong>std::unique_ptr</strong></a></li><li><a href="#std-shared-ptr"><strong>std::shared_ptr</strong></a></li><li><a href="#std-weak-ptr"><strong>std::weak_ptr</strong></a></li></ul><!-- tocstop --></div><p>此文取自于👉<a href="https://zh.cppreference.com/w/cpp/memory">动态内存管理 - cppreference.com</a></p><h3><span id="std-unique-ptr"><strong>std::unique_ptr</strong></span><a href="#std-unique-ptr" class="header-anchor">#</a></h3><blockquote><p>拥有独有对象所有权语义的智能指针</p></blockquote><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;memory&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstdio&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;fstream&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cassert&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;functional&gt;</span></span><span class="hljs-keyword">struct</span> <span class="hljs-title class_">B</span> {    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">bar</span><span class="hljs-params">()</span> </span>{ std::cout &lt;&lt; <span class="hljs-string">"B::bar\n"</span>; }    <span class="hljs-keyword">virtual</span> ~<span class="hljs-built_in">B</span>() = <span class="hljs-keyword">default</span>;};<span class="hljs-keyword">struct</span> <span class="hljs-title class_">D</span> : B{    <span class="hljs-built_in">D</span>() { std::cout &lt;&lt; <span class="hljs-string">"D::D\n"</span>;  }    ~<span class="hljs-built_in">D</span>() { std::cout &lt;&lt; <span class="hljs-string">"D::~D\n"</span>;  }    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">bar</span><span class="hljs-params">()</span> <span class="hljs-keyword">override</span> </span>{ std::cout &lt;&lt; <span class="hljs-string">"D::bar\n"</span>;  }};<span class="hljs-comment">// 消费 unique_ptr 的函数能以值或以右值引用接收它</span><span class="hljs-function">std::unique_ptr&lt;D&gt; <span class="hljs-title">pass_through</span><span class="hljs-params">(std::unique_ptr&lt;D&gt; p)</span></span><span class="hljs-function"></span>{    p-&gt;<span class="hljs-built_in">bar</span>();    <span class="hljs-keyword">return</span> p;}<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">close_file</span><span class="hljs-params">(std::FILE* fp)</span> </span>{ std::<span class="hljs-built_in">fclose</span>(fp); }<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>{    std::cout &lt;&lt; <span class="hljs-string">"unique ownership semantics demo\n"</span>;    {        <span class="hljs-keyword">auto</span> p = std::<span class="hljs-built_in">make_unique</span>&lt;D&gt;(); <span class="hljs-comment">// p 是占有 D 的 unique_ptr</span>        <span class="hljs-keyword">auto</span> q = <span class="hljs-built_in">pass_through</span>(std::<span class="hljs-built_in">move</span>(p));         <span class="hljs-built_in">assert</span>(!p); <span class="hljs-comment">// 现在 p 不占有任何内容并保有空指针</span>        q-&gt;<span class="hljs-built_in">bar</span>();   <span class="hljs-comment">// 而 q 占有 D 对象</span>    } <span class="hljs-comment">// ~D 调用于此</span>    std::cout &lt;&lt; <span class="hljs-string">"Runtime polymorphism demo\n"</span>;    {        std::unique_ptr&lt;B&gt; p = std::<span class="hljs-built_in">make_unique</span>&lt;D&gt;(); <span class="hljs-comment">// p 是占有 D 的 unique_ptr</span>        <span class="hljs-comment">// 作为指向基类的指针</span>        p-&gt;<span class="hljs-built_in">bar</span>(); <span class="hljs-comment">// 虚派发</span>        std::vector&lt;std::unique_ptr&lt;B&gt;&gt; v;  <span class="hljs-comment">// unique_ptr 能存储于容器</span>        v.<span class="hljs-built_in">push_back</span>(std::<span class="hljs-built_in">make_unique</span>&lt;D&gt;());        v.<span class="hljs-built_in">push_back</span>(std::<span class="hljs-built_in">move</span>(p));        v.<span class="hljs-built_in">emplace_back</span>(<span class="hljs-keyword">new</span> D);        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span>&amp; p: v) p-&gt;<span class="hljs-built_in">bar</span>(); <span class="hljs-comment">// 虚派发</span>    } <span class="hljs-comment">// ~D called 3 times</span>    std::cout &lt;&lt; <span class="hljs-string">"Custom deleter demo\n"</span>;    std::<span class="hljs-built_in">ofstream</span>(<span class="hljs-string">"demo.txt"</span>) &lt;&lt; <span class="hljs-string">'x'</span>; <span class="hljs-comment">// 准备要读的文件</span>    {        <span class="hljs-function">std::unique_ptr&lt;std::FILE, <span class="hljs-title">void</span> <span class="hljs-params">(*)</span><span class="hljs-params">(std::FILE*)</span> &gt; <span class="hljs-title">fp</span><span class="hljs-params">(std::fopen(<span class="hljs-string">"demo.txt"</span>, <span class="hljs-string">"r"</span>),</span></span><span class="hljs-params"><span class="hljs-function">                                                             close_file)</span></span>;        <span class="hljs-keyword">if</span>(fp) <span class="hljs-comment">// fopen 可以打开失败；该情况下 fp 保有空指针</span>            std::cout &lt;&lt; (<span class="hljs-type">char</span>)std::<span class="hljs-built_in">fgetc</span>(fp.<span class="hljs-built_in">get</span>()) &lt;&lt; <span class="hljs-string">'\n'</span>;    } <span class="hljs-comment">// fclose() 调用于此，但仅若 FILE* 不是空指针</span>    <span class="hljs-comment">// （即 fopen 成功）</span>    std::cout &lt;&lt; <span class="hljs-string">"Custom lambda-expression deleter demo\n"</span>;    {        std::unique_ptr&lt;D, std::function&lt;<span class="hljs-type">void</span>(D*)&gt;&gt; <span class="hljs-built_in">p</span>(<span class="hljs-keyword">new</span> D, [](D* ptr)                                                      {                                                          std::cout &lt;&lt; <span class="hljs-string">"destroying from a custom deleter...\n"</span>;                                                          <span class="hljs-keyword">delete</span> ptr;                                                      });  <span class="hljs-comment">// p 占有 D</span>        p-&gt;<span class="hljs-built_in">bar</span>();    } <span class="hljs-comment">// 调用上述 lambda 并销毁 D</span>    std::cout &lt;&lt; <span class="hljs-string">"Array form of unique_ptr demo\n"</span>;    {        std::unique_ptr&lt;D[]&gt; p{<span class="hljs-keyword">new</span> D[<span class="hljs-number">3</span>]};    } <span class="hljs-comment">// 调用 ~D 3 次</span>}</code></pre></div><h3><span id="std-shared-ptr"><strong>std::shared_ptr</strong></span><a href="#std-shared-ptr" class="header-anchor">#</a></h3><blockquote><p>拥有共享对象所有权语义的智能指针</p></blockquote><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;memory&gt;</span></span><span class="hljs-keyword">class</span> <span class="hljs-title class_">Sample</span>{    <span class="hljs-keyword">public</span>:    <span class="hljs-built_in">Sample</span>() { std::cout &lt;&lt; <span class="hljs-string">"This is Sample."</span> &lt;&lt; std::endl; }    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">smartpointer</span><span class="hljs-params">()</span></span><span class="hljs-function">    </span>{        std::cout &lt;&lt; <span class="hljs-string">"This is smartpointer."</span> &lt;&lt; std::endl;    }    ~<span class="hljs-built_in">Sample</span>() { std::cout &lt;&lt; <span class="hljs-string">"Destory Sample."</span> &lt;&lt; std::endl; }};<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>{    <span class="hljs-keyword">auto</span> pointer = std::<span class="hljs-built_in">make_shared</span>&lt;Sample&gt;();    <span class="hljs-comment">// pointer-&gt;smartpointer();</span>    <span class="hljs-comment">// std::shared_ptr&lt;Sample&gt; sample1(new Sample());</span>    std::shared_ptr&lt;Sample&gt; sample1 = pointer;    sample1-&gt;<span class="hljs-built_in">smartpointer</span>();    <span class="hljs-function">std::shared_ptr&lt;Sample&gt; <span class="hljs-title">sample12</span><span class="hljs-params">(std::make_shared&lt;Sample&gt;())</span></span>;    sample12-&gt;<span class="hljs-built_in">smartpointer</span>();    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;}</code></pre></div><h3><span id="std-weak-ptr"><strong>std::weak_ptr</strong></span><a href="#std-weak-ptr" class="header-anchor">#</a></h3><blockquote><p>到 <code>std::shared_ptr</code> 所管理对象的弱引用   </p></blockquote><p><code>std::weak_ptr</code> 类型指针不会导致堆内存空间的引用计数增加或减少</p><p><code>std::shared_ptr</code>依然存在着资源无法释放的问题，比如class A中有class B成员变量，class B中有class A成员变量，这种情况就存在引用计数不为0的问题。</p><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;memory&gt;</span></span><span class="hljs-keyword">struct</span> <span class="hljs-title class_">A</span>;<span class="hljs-keyword">struct</span> <span class="hljs-title class_">B</span>;<span class="hljs-keyword">struct</span> <span class="hljs-title class_">A</span>{    <span class="hljs-comment">//std::shared_ptr&lt;B&gt; pointer;</span>    std::weak_ptr&lt;B&gt; ptr;    std::shared_ptr&lt;B&gt; ptr_ = ptr.<span class="hljs-built_in">lock</span>();    ~<span class="hljs-built_in">A</span>()    {        std::cout &lt;&lt; <span class="hljs-string">"A 被销毁"</span> &lt;&lt; std::endl;    }};<span class="hljs-keyword">struct</span> <span class="hljs-title class_">B</span>{    <span class="hljs-comment">//std::shared_ptr&lt;A&gt; pointer;</span>    std::weak_ptr&lt;A&gt; ptr;    std::shared_ptr&lt;A&gt; ptr_ = ptr.<span class="hljs-built_in">lock</span>();    ~<span class="hljs-built_in">B</span>()    {        std::cout &lt;&lt; <span class="hljs-string">"B 被销毁"</span> &lt;&lt; std::endl;    }};<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>{    <span class="hljs-keyword">auto</span> a = std::<span class="hljs-built_in">make_shared</span>&lt;A&gt;();    <span class="hljs-comment">//std::weak_ptr&lt;A&gt; ptr_a(a);</span>    <span class="hljs-keyword">auto</span> b = std::<span class="hljs-built_in">make_shared</span>&lt;B&gt;();    <span class="hljs-comment">//std::weak_ptr&lt;B&gt; ptr_b(b);</span>    a-&gt;ptr = b;    <span class="hljs-comment">//a-&gt;pointer = b;</span>    b-&gt;ptr = a;    <span class="hljs-comment">//b-&gt;pointer = a;</span>}</code></pre></div><p>结果：<br><img src="https://gitee.com/txt1994/images/raw/master/img/Smart_Pointers/Code_itYcJGavlE.png"></p><p>End.</p>]]></content>
    
    
    
    <tags>
      
      <tag>Memory</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C++文件系统库</title>
    <link href="/2022/01/16/C-%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E5%BA%93/"/>
    <url>/2022/01/16/C-%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E5%BA%93/</url>
    
    <content type="html"><![CDATA[<div class="toc"><!-- toc --><ul><li><a href="#lei">类</a></li><li><a href="#fei-cheng-yuan-han-shu">非成员函数</a></li><li><a href="#wen-jian-lei-xing"><strong>文件类型</strong></a></li></ul><!-- tocstop --></div><p>此文来源于👉<a href="https://zh.cppreference.com/w/cpp/filesystem">文件系统库 - cppreference.com</a>，并整理。</p><ul><li>库范畴定义<ul><li>文件：持有数据的文件系统对象，能被写入或读取，或二者皆可。文件拥有名称及属性，属性之一是文件类型：<ul><li>目录：表现为目录条目的容器的文件，目录条目标识其他文件（其中一些可以是另外的嵌套的目录）。讨论到具体文件时，包含该文件目录条目的目录是其父目录。父目录能以相对路径名 “..” 表示。</li><li>硬链接：关联一个名字到一个既存文件的目录条目。若支持多重硬链接，则文件在最后一个到它的硬链接被移除后才被移除。</li><li>符号链接：关联一个名词到一个路径的目录条目，路径可以存在亦可不存在。</li><li><em>常规文件</em>：不是其他文件类型的文件。</li></ul></li><li>文件名：命名一个文件的字符串。容许字符、大小写区别、最大长度以及被禁止名称是实现定义的。名称 “.” （点）与 “..” （双点）在库层次拥有特殊含义。</li><li>路径：标识一个文件的元素序列。它以可选的 根名 （例如 Windows 上的 “C:” 或 “//server” ）开始，后随可选的 根目录 （例如 Unix 上的 “/“ ），后随零或更多个文件名（除了最后一个都必须是目录或到目录的链接）的序列。表示路径的字符串（路径名）的原生格式（如哪些字符被用作分隔符）与字符编码是实现定义的，库提供路径的可移植表示。<ul><li>绝对路径：无歧义地标识一个文件位置的路径。</li><li>规范路径：不包含符号链接、 “.” 或 “..” 元素的绝对路径。</li><li>相对路径：标识相对于文件系统中某位置的文件位置的路径。特殊路径名 “.” （点，“当前目录”）和 “..” （双点、“父目录”）是相对路径。</li></ul></li></ul></li></ul><h2><span id="lei">类</span><a href="#lei" class="header-anchor">#</a></h2><table><thead><tr><th align="left">定义于头文件 <code>&lt;filesystem&gt;</code></th><th align="left"></th></tr></thead><tbody><tr><td align="left">定义于命名空间 <code>std::filesystem</code></td><td align="left"></td></tr><tr><td align="left"><a href="https://zh.cppreference.com/w/cpp/filesystem/path">path</a>(C++17)</td><td align="left">表示路径 (类)</td></tr><tr><td align="left"><a href="https://zh.cppreference.com/w/cpp/filesystem/filesystem_error">filesystem_error</a>(C++17)</td><td align="left">文件系统错误时抛出的异常 (类)</td></tr><tr><td align="left"><a href="https://zh.cppreference.com/w/cpp/filesystem/directory_entry">directory_entry</a>(C++17)</td><td align="left">目录条目 (类)</td></tr><tr><td align="left"><a href="https://zh.cppreference.com/w/cpp/filesystem/directory_iterator">directory_iterator</a>(C++17)</td><td align="left">指向目录内容的迭代器 (类)</td></tr><tr><td align="left"><a href="https://zh.cppreference.com/w/cpp/filesystem/recursive_directory_iterator">recursive_directory_iterator</a>(C++17)</td><td align="left">指向一个目录及其子目录的内容的迭代器 (类)</td></tr><tr><td align="left"><a href="https://zh.cppreference.com/w/cpp/filesystem/file_status">file_status</a>(C++17)</td><td align="left">表示文件类型及权限 (类)</td></tr><tr><td align="left"><a href="https://zh.cppreference.com/w/cpp/filesystem/space_info">space_info</a>(C++17)</td><td align="left">关于文件系统上空闲及可用空间的信息 (类)</td></tr><tr><td align="left"><a href="https://zh.cppreference.com/w/cpp/filesystem/file_type">file_type</a>(C++17)</td><td align="left">文件的类型 (枚举)</td></tr><tr><td align="left"><a href="https://zh.cppreference.com/w/cpp/filesystem/perms">perms</a>(C++17)</td><td align="left">标识文件系统权限 (枚举)</td></tr><tr><td align="left"><a href="https://zh.cppreference.com/w/cpp/filesystem/perm_options">perm_options</a>(C++17)</td><td align="left">指定权限操作的语义 (枚举)</td></tr><tr><td align="left"><a href="https://zh.cppreference.com/w/cpp/filesystem/copy_options">copy_options</a>(C++17)</td><td align="left">指定复制操作的语义 (枚举)</td></tr><tr><td align="left"><a href="https://zh.cppreference.com/w/cpp/filesystem/directory_options">directory_options</a>(C++17)</td><td align="left">用于迭代目录内容的选项 (枚举)</td></tr><tr><td align="left"><a href="https://zh.cppreference.com/w/cpp/filesystem/file_time_type">file_time_type</a>(C++17)</td><td align="left">表示文件时间值 (typedef)</td></tr></tbody></table><h2><span id="fei-cheng-yuan-han-shu">非成员函数</span><a href="#fei-cheng-yuan-han-shu" class="header-anchor">#</a></h2><table><thead><tr><th align="left">定义于头文件 <code>&lt;filesystem&gt;</code></th><th align="left"></th></tr></thead><tbody><tr><td align="left">定义于命名空间 <code>std::filesystem</code></td><td align="left"></td></tr><tr><td align="left"><a href="https://zh.cppreference.com/w/cpp/filesystem/absolute">absolute</a>(C++17)</td><td align="left">组成一个绝对路径 (函数)</td></tr><tr><td align="left"><a href="https://zh.cppreference.com/w/cpp/filesystem/canonical">canonicalweakly_canonical</a>(C++17)</td><td align="left">组成一个规范路径 (函数)</td></tr><tr><td align="left"><a href="https://zh.cppreference.com/w/cpp/filesystem/relative">relativeproximate</a>(C++17)</td><td align="left">组成一个相对路径 (函数)</td></tr><tr><td align="left"><a href="https://zh.cppreference.com/w/cpp/filesystem/copy">copy</a>(C++17)</td><td align="left">复制文件或目录 (函数)</td></tr><tr><td align="left"><a href="https://zh.cppreference.com/w/cpp/filesystem/copy_file">copy_file</a>(C++17)</td><td align="left">复制文件内容 (函数)</td></tr><tr><td align="left"><a href="https://zh.cppreference.com/w/cpp/filesystem/copy_symlink">copy_symlink</a>(C++17)</td><td align="left">复制一个符号链接 (函数)</td></tr><tr><td align="left"><a href="https://zh.cppreference.com/w/cpp/filesystem/create_directory">create_directory create_directories</a>(C++17)(C++17)</td><td align="left">创建新目录 (函数)</td></tr><tr><td align="left"><a href="https://zh.cppreference.com/w/cpp/filesystem/create_hard_link">create_hard_link</a>(C++17)</td><td align="left">创建一个硬链接 (函数)</td></tr><tr><td align="left"><a href="https://zh.cppreference.com/w/cpp/filesystem/create_symlink">create_symlink create_directory_symlink</a>(C++17)(C++17)</td><td align="left">创建一个符号链接 (函数)</td></tr><tr><td align="left"><a href="https://zh.cppreference.com/w/cpp/filesystem/current_path">current_path</a>(C++17)</td><td align="left">返回或设置当前工作目录 (函数)</td></tr><tr><td align="left"><a href="https://zh.cppreference.com/w/cpp/filesystem/exists">exists</a>(C++17)</td><td align="left">检查路径是否指代既存的文件系统对象 (函数)</td></tr><tr><td align="left"><a href="https://zh.cppreference.com/w/cpp/filesystem/equivalent">equivalent</a>(C++17)</td><td align="left">检查两个路径是否指代同一文件系统对象 (函数)</td></tr><tr><td align="left"><a href="https://zh.cppreference.com/w/cpp/filesystem/file_size">file_size</a>(C++17)</td><td align="left">返回文件的大小 (函数)</td></tr><tr><td align="left"><a href="https://zh.cppreference.com/w/cpp/filesystem/hard_link_count">hard_link_count</a>(C++17)</td><td align="left">返回指代特定文件的硬链接数 (函数)</td></tr><tr><td align="left"><a href="https://zh.cppreference.com/w/cpp/filesystem/last_write_time">last_write_time</a>(C++17)</td><td align="left">获取或设置最近一次数据修改的时间 (函数)</td></tr><tr><td align="left"><a href="https://zh.cppreference.com/w/cpp/filesystem/permissions">permissions</a>(C++17)</td><td align="left">修改文件访问权限 (函数)</td></tr><tr><td align="left"><a href="https://zh.cppreference.com/w/cpp/filesystem/read_symlink">read_symlink</a>(C++17)</td><td align="left">获得符号链接的目标 (函数)</td></tr><tr><td align="left"><a href="https://zh.cppreference.com/w/cpp/filesystem/remove">remove remove_all</a>(C++17)(C++17)</td><td align="left">移除一个文件或空目录 移除一个文件或递归地移除一个目录及其所有内容 (函数)</td></tr><tr><td align="left"><a href="https://zh.cppreference.com/w/cpp/filesystem/rename">rename</a>(C++17)</td><td align="left">移动或重命名一个文件或目录 (函数)</td></tr><tr><td align="left"><a href="https://zh.cppreference.com/w/cpp/filesystem/resize_file">resize_file</a>(C++17)</td><td align="left">以截断或填充零更改一个常规文件的大小 (函数)</td></tr><tr><td align="left"><a href="https://zh.cppreference.com/w/cpp/filesystem/space">space</a>(C++17)</td><td align="left">确定文件系统上的可用空闲空间 (函数)</td></tr><tr><td align="left"><a href="https://zh.cppreference.com/w/cpp/filesystem/status">status symlink_status</a>(C++17)(C++17)</td><td align="left">确定文件属性 确定文件属性，检查符号链接目标 (函数)</td></tr><tr><td align="left"><a href="https://zh.cppreference.com/w/cpp/filesystem/temp_directory_path">temp_directory_path</a>(C++17)</td><td align="left">返回一个适用于临时文件的目录 (函数)</td></tr></tbody></table><h2><span id="wen-jian-lei-xing"><strong>文件类型</strong></span><a href="#wen-jian-lei-xing" class="header-anchor">#</a></h2><table><thead><tr><th align="left"><a href="https://zh.cppreference.com/w/cpp/filesystem/is_block_file">is_block_file</a>(C++17)</th><th align="left">检查给定的路径是否表示块设备 (函数)</th></tr></thead><tbody><tr><td align="left"><a href="https://zh.cppreference.com/w/cpp/filesystem/is_character_file">is_character_file</a>(C++17)</td><td align="left">检查给定的路径是否表示字符设备 (函数)</td></tr><tr><td align="left"><a href="https://zh.cppreference.com/w/cpp/filesystem/is_directory">is_directory</a>(C++17)</td><td align="left">检查给定的路径是否表示一个目录 (函数)</td></tr><tr><td align="left"><a href="https://zh.cppreference.com/w/cpp/filesystem/is_empty">is_empty</a>(C++17)</td><td align="left">检查给定的路径是否表示一个空文件或空目录 (函数)</td></tr><tr><td align="left"><a href="https://zh.cppreference.com/w/cpp/filesystem/is_fifo">is_fifo</a>(C++17)</td><td align="left">检查给定的路径是否表示一个命名管道 (函数)</td></tr><tr><td align="left"><a href="https://zh.cppreference.com/w/cpp/filesystem/is_other">is_other</a>(C++17)</td><td align="left">检查参数是否表示一个<em>其他</em>文件 (函数)</td></tr><tr><td align="left"><a href="https://zh.cppreference.com/w/cpp/filesystem/is_regular_file">is_regular_file</a>(C++17)</td><td align="left">检查参数是否表示一个常规文件 (函数)</td></tr><tr><td align="left"><a href="https://zh.cppreference.com/w/cpp/filesystem/is_socket">is_socket</a>(C++17)</td><td align="left">检查参数是否表示一个具名 IPC 套接字 (函数)</td></tr><tr><td align="left"><a href="https://zh.cppreference.com/w/cpp/filesystem/is_symlink">is_symlink</a>(C++17)</td><td align="left">检查参数是否表示一个符号链接 (函数)</td></tr><tr><td align="left"><a href="https://zh.cppreference.com/w/cpp/filesystem/status_known">status_known</a>(C++17)</td><td align="left">检查参数是否表示一个符号链接 (函数)</td></tr></tbody></table>]]></content>
    
    
    
    <tags>
      
      <tag>C++</tag>
      
      <tag>FileSystem</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C++正则表达式</title>
    <link href="/2022/01/16/C-%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/"/>
    <url>/2022/01/16/C-%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<div class="toc"><!-- toc --><ul><li><a href="#suan-fa">算法</a><ul><li><a href="#regex-match-https-zh-cppreference-com-w-cpp-regex-regex-match-c-11">regex_match</a></li><li><a href="#regex-search-https-zh-cppreference-com-w-cpp-regex-regex-search-c-11">regex_search</a></li><li><a href="#regex-replace-https-zh-cppreference-com-w-cpp-regex-regex-replace-c-11">regex_replace</a></li></ul></li><li><a href="#die-dai-qi">迭代器</a><ul><li><a href="#regex-iterator-https-zh-cppreference-com-w-cpp-regex-regex-iterator-c-11">regex_iterator</a></li><li><a href="#regex-token-iterator-https-zh-cppreference-com-w-cpp-regex-regex-token-iterator-c-11">regex_token_iterator</a></li></ul></li></ul><!-- tocstop --></div><p>此文章来源于👉<a href="https://zh.cppreference.com/w/cpp/regex">正则表达式库 - cppreference.com</a>,并整理</p><blockquote><p>正则表达式库提供表示正则表达式的类，正则表达式是一种用于在字符串中匹配模式的微型语言。</p></blockquote><p>定义于头文件 <regex></regex></p><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iterator&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;regex&gt;</span></span> <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>{    std::string s = <span class="hljs-string">"Some people, when confronted with a problem, think "</span>        <span class="hljs-string">"\"I know, I'll use regular expressions.\" "</span>        <span class="hljs-string">"Now they have two problems."</span>;     <span class="hljs-function">std::regex <span class="hljs-title">self_regex</span><span class="hljs-params">(<span class="hljs-string">"REGULAR EXPRESSIONS"</span>,</span></span><span class="hljs-params"><span class="hljs-function">            std::regex_constants::ECMAScript | std::regex_constants::icase)</span></span>;    <span class="hljs-keyword">if</span> (std::<span class="hljs-built_in">regex_search</span>(s, self_regex)) {        std::cout &lt;&lt; <span class="hljs-string">"Text contains the phrase 'regular expressions'\n"</span>;    }     <span class="hljs-function">std::regex <span class="hljs-title">word_regex</span><span class="hljs-params">(<span class="hljs-string">"(\\w+)"</span>)</span></span>;    <span class="hljs-keyword">auto</span> words_begin =         std::<span class="hljs-built_in">sregex_iterator</span>(s.<span class="hljs-built_in">begin</span>(), s.<span class="hljs-built_in">end</span>(), word_regex);    <span class="hljs-keyword">auto</span> words_end = std::<span class="hljs-built_in">sregex_iterator</span>();     std::cout &lt;&lt; <span class="hljs-string">"Found "</span>              &lt;&lt; std::<span class="hljs-built_in">distance</span>(words_begin, words_end)              &lt;&lt; <span class="hljs-string">" words\n"</span>;     <span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">6</span>;    std::cout &lt;&lt; <span class="hljs-string">"Words longer than "</span> &lt;&lt; N &lt;&lt; <span class="hljs-string">" characters:\n"</span>;    <span class="hljs-keyword">for</span> (std::sregex_iterator i = words_begin; i != words_end; ++i) {        std::smatch match = *i;        std::string match_str = match.<span class="hljs-built_in">str</span>();        <span class="hljs-keyword">if</span> (match_str.<span class="hljs-built_in">size</span>() &gt; N) {            std::cout &lt;&lt; <span class="hljs-string">"  "</span> &lt;&lt; match_str &lt;&lt; <span class="hljs-string">'\n'</span>;        }    }     <span class="hljs-function">std::regex <span class="hljs-title">long_word_regex</span><span class="hljs-params">(<span class="hljs-string">"(\\w{7,})"</span>)</span></span>;    std::string new_s = std::<span class="hljs-built_in">regex_replace</span>(s, long_word_regex, <span class="hljs-string">"[$&amp;]"</span>);    std::cout &lt;&lt; new_s &lt;&lt; <span class="hljs-string">'\n'</span>;}</code></pre></div><h1><span id="suan-fa">算法</span><a href="#suan-fa" class="header-anchor">#</a></h1><h2><span id="regex-match-c-11">(C++11)</span><a href="#regex-match-c-11" class="header-anchor">#</a></h2><blockquote><p>尝试匹配一个正则表达式到整个字符序列 (函数模板)      </p></blockquote><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;regex&gt;</span></span> <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>{    <span class="hljs-comment">// 简单正则表达式匹配</span>    std::string fnames[] = {<span class="hljs-string">"foo.txt"</span>, <span class="hljs-string">"bar.txt"</span>, <span class="hljs-string">"baz.dat"</span>, <span class="hljs-string">"zoidberg"</span>};    <span class="hljs-function">std::regex <span class="hljs-title">txt_regex</span><span class="hljs-params">(<span class="hljs-string">"[a-z]+\\.txt"</span>)</span></span>;     <span class="hljs-keyword">for</span> (<span class="hljs-type">const</span> <span class="hljs-keyword">auto</span> &amp;fname : fnames) {        std::cout &lt;&lt; fname &lt;&lt; <span class="hljs-string">": "</span> &lt;&lt; std::<span class="hljs-built_in">regex_match</span>(fname, txt_regex) &lt;&lt; <span class="hljs-string">'\n'</span>;    }        <span class="hljs-comment">// 提取子匹配</span>    <span class="hljs-function">std::regex <span class="hljs-title">base_regex</span><span class="hljs-params">(<span class="hljs-string">"([a-z]+)\\.txt"</span>)</span></span>;    std::smatch base_match;     <span class="hljs-keyword">for</span> (<span class="hljs-type">const</span> <span class="hljs-keyword">auto</span> &amp;fname : fnames) {        <span class="hljs-keyword">if</span> (std::<span class="hljs-built_in">regex_match</span>(fname, base_match, base_regex)) {            <span class="hljs-comment">// 首个 sub_match 是整个字符串；下个</span>            <span class="hljs-comment">// sub_match 是首个有括号表达式。</span>            <span class="hljs-keyword">if</span> (base_match.<span class="hljs-built_in">size</span>() == <span class="hljs-number">2</span>) {                std::ssub_match base_sub_match = base_match[<span class="hljs-number">1</span>];                std::string base = base_sub_match.<span class="hljs-built_in">str</span>();                std::cout &lt;&lt; fname &lt;&lt; <span class="hljs-string">" has a base of "</span> &lt;&lt; base &lt;&lt; <span class="hljs-string">'\n'</span>;            }        }    }     <span class="hljs-comment">// 提取几个子匹配</span>    <span class="hljs-function">std::regex <span class="hljs-title">pieces_regex</span><span class="hljs-params">(<span class="hljs-string">"([a-z]+)\\.([a-z]+)"</span>)</span></span>;    std::smatch pieces_match;     <span class="hljs-keyword">for</span> (<span class="hljs-type">const</span> <span class="hljs-keyword">auto</span> &amp;fname : fnames) {        <span class="hljs-keyword">if</span> (std::<span class="hljs-built_in">regex_match</span>(fname, pieces_match, pieces_regex)) {            std::cout &lt;&lt; fname &lt;&lt; <span class="hljs-string">'\n'</span>;            <span class="hljs-keyword">for</span> (<span class="hljs-type">size_t</span> i = <span class="hljs-number">0</span>; i &lt; pieces_match.<span class="hljs-built_in">size</span>(); ++i) {                std::ssub_match sub_match = pieces_match[i];                std::string piece = sub_match.<span class="hljs-built_in">str</span>();                std::cout &lt;&lt; <span class="hljs-string">"  submatch "</span> &lt;&lt; i &lt;&lt; <span class="hljs-string">": "</span> &lt;&lt; piece &lt;&lt; <span class="hljs-string">'\n'</span>;            }           }       }   }</code></pre></div><h2><span id="regex-search-c-11">(C++11)</span><a href="#regex-search-c-11" class="header-anchor">#</a></h2><blockquote><p>尝试匹配一个正则表达式到字符序列的任何部分 (函数模板) </p></blockquote><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;regex&gt;</span></span> <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>{    std::string lines[] = {<span class="hljs-string">"Roses are #ff0000"</span>,                           <span class="hljs-string">"violets are #0000ff"</span>,                           <span class="hljs-string">"all of my base are belong to you"</span>};     <span class="hljs-function">std::regex <span class="hljs-title">color_regex</span><span class="hljs-params">(<span class="hljs-string">"#([a-f0-9]{2})"</span></span></span><span class="hljs-params"><span class="hljs-function">                            <span class="hljs-string">"([a-f0-9]{2})"</span></span></span><span class="hljs-params"><span class="hljs-function">                            <span class="hljs-string">"([a-f0-9]{2})"</span>)</span></span>;     <span class="hljs-comment">// 简单匹配</span>    <span class="hljs-keyword">for</span> (<span class="hljs-type">const</span> <span class="hljs-keyword">auto</span> &amp;line : lines) {        std::cout &lt;&lt; line &lt;&lt; <span class="hljs-string">": "</span> &lt;&lt; std::boolalpha                  &lt;&lt; std::<span class="hljs-built_in">regex_search</span>(line, color_regex) &lt;&lt; <span class="hljs-string">'\n'</span>;    }       std::cout &lt;&lt; <span class="hljs-string">'\n'</span>;     <span class="hljs-comment">// 展示每个匹配中有标记子表达式的内容</span>    std::smatch color_match;    <span class="hljs-keyword">for</span> (<span class="hljs-type">const</span> <span class="hljs-keyword">auto</span>&amp; line : lines) {        <span class="hljs-keyword">if</span>(std::<span class="hljs-built_in">regex_search</span>(line, color_match, color_regex)) {            std::cout &lt;&lt; <span class="hljs-string">"matches for '"</span> &lt;&lt; line &lt;&lt; <span class="hljs-string">"'\n"</span>;            std::cout &lt;&lt; <span class="hljs-string">"Prefix: '"</span> &lt;&lt; color_match.<span class="hljs-built_in">prefix</span>() &lt;&lt; <span class="hljs-string">"'\n"</span>;            <span class="hljs-keyword">for</span> (<span class="hljs-type">size_t</span> i = <span class="hljs-number">0</span>; i &lt; color_match.<span class="hljs-built_in">size</span>(); ++i)                 std::cout &lt;&lt; i &lt;&lt; <span class="hljs-string">": "</span> &lt;&lt; color_match[i] &lt;&lt; <span class="hljs-string">'\n'</span>;            std::cout &lt;&lt; <span class="hljs-string">"Suffix: '"</span> &lt;&lt; color_match.<span class="hljs-built_in">suffix</span>() &lt;&lt; <span class="hljs-string">"\'\n\n"</span>;        }    }     <span class="hljs-comment">// 重复搜索（参阅 std::regex_iterator ）</span>    <span class="hljs-function">std::string <span class="hljs-title">log</span><span class="hljs-params">(<span class="hljs-string">R"(</span></span></span><span class="hljs-string"><span class="hljs-params"><span class="hljs-function">        Speed:366</span></span></span><span class="hljs-string"><span class="hljs-params"><span class="hljs-function">        Mass:35</span></span></span><span class="hljs-string"><span class="hljs-params"><span class="hljs-function">        Speed:378</span></span></span><span class="hljs-string"><span class="hljs-params"><span class="hljs-function">        Mass:32</span></span></span><span class="hljs-string"><span class="hljs-params"><span class="hljs-function">        Speed:400</span></span></span><span class="hljs-string"><span class="hljs-params"><span class="hljs-function">Mass:30)"</span>)</span></span>;    <span class="hljs-function">std::regex <span class="hljs-title">r</span><span class="hljs-params">(<span class="hljs-string">R"(Speed:\t\d*)"</span>)</span></span>;    std::smatch sm;    <span class="hljs-keyword">while</span>(<span class="hljs-built_in">regex_search</span>(log, sm, r))    {        std::cout &lt;&lt; sm.<span class="hljs-built_in">str</span>() &lt;&lt; <span class="hljs-string">'\n'</span>;        log = sm.<span class="hljs-built_in">suffix</span>();    }     <span class="hljs-comment">// C 风格字符串演示</span>    std::cmatch cm;    <span class="hljs-keyword">if</span>(std::<span class="hljs-built_in">regex_search</span>(<span class="hljs-string">"this is a test"</span>, cm, std::<span class="hljs-built_in">regex</span>(<span class="hljs-string">"test"</span>)))         std::cout &lt;&lt; <span class="hljs-string">"\nFound "</span> &lt;&lt; cm[<span class="hljs-number">0</span>] &lt;&lt; <span class="hljs-string">" at position "</span> &lt;&lt; cm.<span class="hljs-built_in">prefix</span>().<span class="hljs-built_in">length</span>();}</code></pre></div><h2><span id="regex-replace-c-11">(C++11)</span><a href="#regex-replace-c-11" class="header-anchor">#</a></h2><blockquote><p>以格式化的替换文本来替换正则表达式匹配的出现位置 (函数模板) </p></blockquote><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iterator&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;regex&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span> <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>{   std::string text = <span class="hljs-string">"Quick brown fox"</span>;   <span class="hljs-function">std::regex <span class="hljs-title">vowel_re</span><span class="hljs-params">(<span class="hljs-string">"a|e|i|o|u"</span>)</span></span>;    <span class="hljs-comment">// 写结果到输出迭代器</span>   std::<span class="hljs-built_in">regex_replace</span>(std::<span class="hljs-built_in">ostreambuf_iterator</span>&lt;<span class="hljs-type">char</span>&gt;(std::cout),                      text.<span class="hljs-built_in">begin</span>(), text.<span class="hljs-built_in">end</span>(), vowel_re, <span class="hljs-string">"*"</span>);    <span class="hljs-comment">// 构造保有结果的字符串</span>   std::cout &lt;&lt; <span class="hljs-string">'\n'</span> &lt;&lt; std::<span class="hljs-built_in">regex_replace</span>(text, vowel_re, <span class="hljs-string">"[$&amp;]"</span>) &lt;&lt; <span class="hljs-string">'\n'</span>;}</code></pre></div><h1><span id="die-dai-qi">迭代器</span><a href="#die-dai-qi" class="header-anchor">#</a></h1><blockquote><p>regex_iterator 用于遍历在序列中找到的匹配正则表达式的整个集合。</p></blockquote><h2><span id="regex-iterator-c-11">(C++11)</span><a href="#regex-iterator-c-11" class="header-anchor">#</a></h2><blockquote><p>迭代一个字符序列中的所有正则表达式匹配 (类模板)    </p></blockquote><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;regex&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iterator&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span> <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>{    <span class="hljs-type">const</span> std::string s = <span class="hljs-string">"Quick brown fox."</span>;     <span class="hljs-function">std::regex <span class="hljs-title">words_regex</span><span class="hljs-params">(<span class="hljs-string">"[^\\s]+"</span>)</span></span>;    <span class="hljs-keyword">auto</span> words_begin =         std::<span class="hljs-built_in">sregex_iterator</span>(s.<span class="hljs-built_in">begin</span>(), s.<span class="hljs-built_in">end</span>(), words_regex);    <span class="hljs-keyword">auto</span> words_end = std::<span class="hljs-built_in">sregex_iterator</span>();     std::cout &lt;&lt; <span class="hljs-string">"Found "</span>               &lt;&lt; std::<span class="hljs-built_in">distance</span>(words_begin, words_end)               &lt;&lt; <span class="hljs-string">" words:\n"</span>;     <span class="hljs-keyword">for</span> (std::sregex_iterator i = words_begin; i != words_end; ++i) {        std::smatch match = *i;                                                         std::string match_str = match.<span class="hljs-built_in">str</span>();         std::cout &lt;&lt; match_str &lt;&lt; <span class="hljs-string">'\n'</span>;    }   }</code></pre></div><h2><span id="regex-token-iterator-c-11">(C++11)</span><a href="#regex-token-iterator-c-11" class="header-anchor">#</a></h2><blockquote><p>迭代给定字符串中的所有正则表达式匹配中的指定子表达式，或迭代未匹配的子字符串 (类模板) </p></blockquote><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;fstream&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iterator&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;regex&gt;</span></span> <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>{   std::string text = <span class="hljs-string">"Quick brown fox."</span>;   <span class="hljs-comment">// 记号化（非匹配碎片）</span>   <span class="hljs-comment">// 注意仅匹配二次 regex ：在获得第三值时迭代器为后缀迭代器。</span>   <span class="hljs-function">std::regex <span class="hljs-title">ws_re</span><span class="hljs-params">(<span class="hljs-string">"\\s+"</span>)</span></span>; <span class="hljs-comment">// 空白符</span>   std::<span class="hljs-built_in">copy</span>( std::<span class="hljs-built_in">sregex_token_iterator</span>(text.<span class="hljs-built_in">begin</span>(), text.<span class="hljs-built_in">end</span>(), ws_re, <span class="hljs-number">-1</span>),              std::<span class="hljs-built_in">sregex_token_iterator</span>(),              std::<span class="hljs-built_in">ostream_iterator</span>&lt;std::string&gt;(std::cout, <span class="hljs-string">"\n"</span>));    <span class="hljs-comment">// 迭代首个子匹配</span>   std::string html = <span class="hljs-string">"&lt;p&gt;&lt;a href=\"http://google.com\"&gt;google&lt;/a&gt; "</span>                      <span class="hljs-string">"&lt; a HREF =\"http://cppreference.com\"&gt;cppreference&lt;/a&gt;\n&lt;/p&gt;"</span>;   <span class="hljs-function">std::regex <span class="hljs-title">url_re</span><span class="hljs-params">(<span class="hljs-string">"&lt;\\s*A\\s+[^&gt;]*href\\s*=\\s*\"([^\"]*)\""</span>, std::regex::icase)</span></span>;   std::<span class="hljs-built_in">copy</span>( std::<span class="hljs-built_in">sregex_token_iterator</span>(html.<span class="hljs-built_in">begin</span>(), html.<span class="hljs-built_in">end</span>(), url_re, <span class="hljs-number">1</span>),              std::<span class="hljs-built_in">sregex_token_iterator</span>(),              std::<span class="hljs-built_in">ostream_iterator</span>&lt;std::string&gt;(std::cout, <span class="hljs-string">"\n"</span>));}</code></pre></div>]]></content>
    
    
    
    <tags>
      
      <tag>C++</tag>
      
      <tag>Regex</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>线程支持库</title>
    <link href="/2022/01/15/%E7%BA%BF%E7%A8%8B%E6%94%AF%E6%8C%81%E5%BA%93/"/>
    <url>/2022/01/15/%E7%BA%BF%E7%A8%8B%E6%94%AF%E6%8C%81%E5%BA%93/</url>
    
    <content type="html"><![CDATA[<div class="toc"><!-- toc --><ul><li><a href="#xian-cheng-zhi-chi-ku">线程支持库</a><ul><li><a href="#include-thread"><strong><code>#include &lt;thread&gt;</code></strong></a><ul><li><a href="#std-thread">std::thread</a></li><li><a href="#std-thread-id"><code>std::thread::id</code></a></li><li><a href="#std-thread-hardware-concurrency"><code>std::thread::hardware_concurrency()</code></a></li><li><a href="#std-thread-native-handle"><code>std::thread::native_handle()</code></a></li><li><a href="#std-thread-join"><code>std::thread::join()</code></a></li><li><a href="#std-thread-detach"><code>std::thread::detach()</code></a></li><li><a href="#std-thread-swap"><code>std::thread::swap</code></a></li><li><a href="#std-this-thread-yield">std::this_thread::yield()</a></li><li><a href="#std-this-thread-get-id">std::this_thread::get_id()</a></li><li><a href="#std-this-thread-sleep-for">std::this_thread::sleep_for()</a></li><li><a href="#std-this-thread-sleep-until">std::this_thread::sleep_until()</a></li></ul></li></ul></li><li><a href="#hu-chi">互斥</a><ul><li><a href="#include-mutex"><strong><code>#include &lt;mutex&gt;</code></strong></a><ul><li><a href="#std-mutex-lock">std::mutex::lock()</a></li><li><a href="#std-mutex-try-lock">std::mutex::try_lock()</a></li><li><a href="#std-mutex-unlock">std::mutex::unlock()</a></li><li><a href="#std-timed-mutex">std::timed_mutex</a></li><li><a href="#std-timed-mutex-lock">std::timed_mutex::lock()</a></li><li><a href="#std-timed-mutex-unlock">std::timed_mutex::unlock()</a></li><li><a href="#std-timed-mutex-try-lock">std::timed_mutex::try_lock()</a></li><li><a href="#std-timed-mutex-try-lock-for">std::timed_mutex::try_lock_for()</a></li><li><a href="#std-timed-mutex-try-lock-until">std::timed_mutex::try_lock_until()</a></li><li><a href="#std-lock-guard-std-mutex">std::lock_guard<code>&lt;std::mutex&gt;</code></a></li><li><a href="#std-unique-lock-mutex-lock">std::unique_lock<code>&lt;Mutex&gt;::lock</code></a></li><li><a href="#std-unique-lock-std-mutex">std::unique_lock<code>&lt;std::mutex&gt;</code></a></li><li><a href="#std-unique-lock-mutex-try-lock">std::unique_lock<code>&lt;Mutex&gt;::try_lock</code></a></li><li><a href="#std-unique-lock-mutex-try-lock-for">std::unique_lock<code>&lt;Mutex&gt;::try_lock_for</code></a></li><li><a href="#std-call-once">std::call_once</a></li></ul></li></ul></li><li><a href="#tiao-jian-bian-liang">条件变量</a><ul><li><a href="#std-condition-variable">std::condition_variable</a></li><li><a href="#std-condition-variable-notify-all">std::condition_variable::notify_all()</a></li><li><a href="#std-condition-variable-notify-one">std::condition_variable::notify_one()</a></li><li><a href="#std-condition-variable-wait">std::condition_variable::wait()</a></li><li><a href="#std-condition-variable-wait-for">std::condition_variable::wait_for()</a></li></ul></li><li><a href="#xin-hao-liang">信号量</a><ul><li><a href="#std-counting-semaphore-std-binary-semaphore">std::counting_semaphore, std::binary_semaphore</a></li></ul></li><li><a href="#future">Future</a><ul><li><a href="#yi-bu-xian-cheng">异步线程</a><ul><li><a href="#classes">Classes</a></li><li><a href="#functions">Functions</a></li></ul></li></ul></li></ul><!-- tocstop --></div><p>此文来自于👉<a href="https://zh.cppreference.com/w/cpp/thread">线程支持库 - cppreference.com</a></p><h1><span id="xian-cheng-zhi-chi-ku">线程支持库</span><a href="#xian-cheng-zhi-chi-ku" class="header-anchor">#</a></h1><table><thead><tr><th><a href="https://zh.cppreference.com/w/cpp/header/thread">thread</a>(C++11)</th><th><a href="https://zh.cppreference.com/w/cpp/thread/thread">std::thread</a> 类与<a href="https://zh.cppreference.com/w/cpp/thread">支持函数</a></th></tr></thead><tbody><tr><td><a href="https://zh.cppreference.com/w/cpp/header/stop_token">stop_token</a>(C++20)</td><td>std::jthread 的停止记号</td></tr><tr><td><a href="https://zh.cppreference.com/w/cpp/header/mutex">mutex</a>(C++11)</td><td><a href="https://zh.cppreference.com/w/cpp/thread">互斥元件</a></td></tr><tr><td><a href="https://zh.cppreference.com/w/cpp/header/shared_mutex">shared_mutex</a>(C++14)</td><td><a href="https://zh.cppreference.com/w/cpp/thread">共享互斥元件</a></td></tr><tr><td><a href="https://zh.cppreference.com/w/cpp/header/future">future</a>(C++11)</td><td><a href="https://zh.cppreference.com/w/cpp/thread">异步计算元件</a></td></tr><tr><td><a href="https://zh.cppreference.com/w/cpp/header/condition_variable">condition_variable</a>(C++11)</td><td><a href="https://zh.cppreference.com/w/cpp/thread">线程等待条件</a></td></tr><tr><td><a href="https://zh.cppreference.com/w/cpp/header/semaphore">semaphore</a>(C++20)</td><td><a href="https://zh.cppreference.com/w/cpp/thread/counting_semaphore">信号量</a></td></tr><tr><td><a href="https://zh.cppreference.com/w/cpp/header/latch">latch</a>(C++20)</td><td><a href="https://zh.cppreference.com/w/cpp/thread/latch">闩</a></td></tr><tr><td><a href="https://zh.cppreference.com/w/cpp/header/barrier">barrier</a>(C++20)</td><td><a href="https://zh.cppreference.com/w/cpp/thread/barrier">屏障</a></td></tr></tbody></table><h2><span id="include-lt-thread-gt"><strong><code>#include &lt;thread&gt;</code></strong></span><a href="#include-lt-thread-gt" class="header-anchor">#</a></h2><h3><span id="std-thread">std::thread</span><a href="#std-thread" class="header-anchor">#</a></h3><blockquote><p>thread类  表示单个执行线程。</p></blockquote><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;thread&gt;</span></span> <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>{    std::thread th1;}</code></pre></div><h3><span id="std-thread-id"><code>std::thread::id</code></span><a href="#std-thread-id" class="header-anchor">#</a></h3><blockquote><p>thread::id类 是轻量的可频繁复制类，它作为 <code>std::thread</code> 对象的<strong>唯一标识符</strong>工作。</p></blockquote><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;thread&gt;</span></span><span class="hljs-keyword">typedef</span> <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> <span class="hljs-type">long</span> ULL;<span class="hljs-function">std::string <span class="hljs-title">getThreadIdOfString</span><span class="hljs-params">(<span class="hljs-type">const</span> std::thread::id &amp; id)</span></span><span class="hljs-function"></span>{    std::stringstream sin;    sin &lt;&lt; id;    <span class="hljs-keyword">return</span> sin.<span class="hljs-built_in">str</span>();}<span class="hljs-function">ULL <span class="hljs-title">getThreadIdOfULL</span><span class="hljs-params">(<span class="hljs-type">const</span> std::thread::id &amp; id)</span></span><span class="hljs-function"></span>{    <span class="hljs-keyword">return</span> std::<span class="hljs-built_in">stoull</span>(<span class="hljs-built_in">getThreadIdOfString</span>(id));}<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>{    std::thread::id id = std::this_thread::<span class="hljs-built_in">get_id</span>();    std::cout &lt;&lt; <span class="hljs-string">"cout ----- id : "</span> &lt;&lt; id &lt;&lt; std::endl;    std::cout &lt;&lt; <span class="hljs-string">"getThreadIdOfString ----- id : "</span> &lt;&lt; <span class="hljs-built_in">getThreadIdOfString</span>(id) &lt;&lt; std::endl;    std::cout &lt;&lt; <span class="hljs-string">"getThreadIdOfULL ----- id : "</span> &lt;&lt; <span class="hljs-built_in">getThreadIdOfULL</span>(id) &lt;&lt; std::endl;        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;}</code></pre></div><h3><span id="std-thread-hardware-concurrency"><code>std::thread::hardware_concurrency()</code></span><a href="#std-thread-hardware-concurrency" class="header-anchor">#</a></h3><blockquote><p>返回处理器支持的并发线程数。</p></blockquote><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;thread&gt;</span></span> <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>{    <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> n = std::thread::<span class="hljs-built_in">hardware_concurrency</span>();    std::cout &lt;&lt; n &lt;&lt; <span class="hljs-string">" concurrent threads are supported.\n"</span>;    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;}</code></pre></div><h3><span id="std-thread-native-handle"><code>std::thread::native_handle()</code></span><a href="#std-thread-native-handle" class="header-anchor">#</a></h3><blockquote><p>返回实现定义的底层线程柄。</p></blockquote><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;thread&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;mutex&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;chrono&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstring&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;pthread.h&gt;</span></span> std::mutex iomutex;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">f</span><span class="hljs-params">(<span class="hljs-type">int</span> num)</span></span><span class="hljs-function"></span>{    std::this_thread::<span class="hljs-built_in">sleep_for</span>(std::chrono::<span class="hljs-built_in">seconds</span>(<span class="hljs-number">1</span>));     sched_param sch;    <span class="hljs-type">int</span> policy;     <span class="hljs-built_in">pthread_getschedparam</span>(<span class="hljs-built_in">pthread_self</span>(), &amp;policy, &amp;sch);    <span class="hljs-function">std::lock_guard&lt;std::mutex&gt; <span class="hljs-title">lk</span><span class="hljs-params">(iomutex)</span></span>;    std::cout &lt;&lt; <span class="hljs-string">"Thread "</span> &lt;&lt; num &lt;&lt; <span class="hljs-string">" is executing at priority "</span>              &lt;&lt; sch.sched_priority &lt;&lt; <span class="hljs-string">'\n'</span>;} <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>{    <span class="hljs-function">std::thread <span class="hljs-title">t1</span><span class="hljs-params">(f, <span class="hljs-number">1</span>)</span>, <span class="hljs-title">t2</span><span class="hljs-params">(f, <span class="hljs-number">2</span>)</span></span>;     sched_param sch;    <span class="hljs-type">int</span> policy;     <span class="hljs-built_in">pthread_getschedparam</span>(t1.<span class="hljs-built_in">native_handle</span>(), &amp;policy, &amp;sch);    sch.sched_priority = <span class="hljs-number">20</span>;    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">pthread_setschedparam</span>(t1.<span class="hljs-built_in">native_handle</span>(), SCHED_FIFO, &amp;sch)) {        std::cout &lt;&lt; <span class="hljs-string">"Failed to setschedparam: "</span> &lt;&lt; std::<span class="hljs-built_in">strerror</span>(errno) &lt;&lt; <span class="hljs-string">'\n'</span>;    }     t1.<span class="hljs-built_in">join</span>(); t2.<span class="hljs-built_in">join</span>();        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;}</code></pre></div><h3><span id="std-thread-join"><code>std::thread::join()</code></span><a href="#std-thread-join" class="header-anchor">#</a></h3><blockquote><p>等待线程完成其执行</p></blockquote><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;thread&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;chrono&gt;</span></span> <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">foo</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>{    <span class="hljs-comment">// 模拟耗费大量资源的操作</span>    std::this_thread::<span class="hljs-built_in">sleep_for</span>(std::chrono::<span class="hljs-built_in">seconds</span>(<span class="hljs-number">1</span>));} <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">bar</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>{    <span class="hljs-comment">// 模拟耗费大量资源的操作</span>    std::this_thread::<span class="hljs-built_in">sleep_for</span>(std::chrono::<span class="hljs-built_in">seconds</span>(<span class="hljs-number">1</span>));} <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>{    std::cout &lt;&lt; <span class="hljs-string">"starting first helper...\n"</span>;    <span class="hljs-function">std::thread <span class="hljs-title">helper1</span><span class="hljs-params">(foo)</span></span>;     std::cout &lt;&lt; <span class="hljs-string">"starting second helper...\n"</span>;    <span class="hljs-function">std::thread <span class="hljs-title">helper2</span><span class="hljs-params">(bar)</span></span>;     std::cout &lt;&lt; <span class="hljs-string">"waiting for helpers to finish..."</span> &lt;&lt; std::endl;    helper1.<span class="hljs-built_in">join</span>();    helper2.<span class="hljs-built_in">join</span>();     std::cout &lt;&lt; <span class="hljs-string">"done!\n"</span>;        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;}</code></pre></div><h3><span id="std-thread-detach"><code>std::thread::detach()</code></span><a href="#std-thread-detach" class="header-anchor">#</a></h3><blockquote><p>容许线程从线程句柄独立开来执行</p><p>从 thread 对象分离执行线程，允许执行独立地持续。一旦该线程退出，则释放任何分配的资源。</p></blockquote><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;chrono&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;thread&gt;</span></span> <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">independentThread</span><span class="hljs-params">()</span> </span><span class="hljs-function"></span>{    std::cout &lt;&lt; <span class="hljs-string">"Starting concurrent thread.\n"</span>;    std::this_thread::<span class="hljs-built_in">sleep_for</span>(std::chrono::<span class="hljs-built_in">seconds</span>(<span class="hljs-number">2</span>));    std::cout &lt;&lt; <span class="hljs-string">"Exiting concurrent thread.\n"</span>;} <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">threadCaller</span><span class="hljs-params">()</span> </span><span class="hljs-function"></span>{    std::cout &lt;&lt; <span class="hljs-string">"Starting thread caller.\n"</span>;    <span class="hljs-function">std::thread <span class="hljs-title">t</span><span class="hljs-params">(independentThread)</span></span>;    t.<span class="hljs-built_in">detach</span>();    std::this_thread::<span class="hljs-built_in">sleep_for</span>(std::chrono::<span class="hljs-built_in">seconds</span>(<span class="hljs-number">1</span>));    std::cout &lt;&lt; <span class="hljs-string">"Exiting thread caller.\n"</span>;} <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span><span class="hljs-function"></span>{    <span class="hljs-built_in">threadCaller</span>();    std::this_thread::<span class="hljs-built_in">sleep_for</span>(std::chrono::<span class="hljs-built_in">seconds</span>(<span class="hljs-number">5</span>));<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;}</code></pre></div><h3><span id="std-thread-swap"><code>std::thread::swap</code></span><a href="#std-thread-swap" class="header-anchor">#</a></h3><blockquote><p>交换二个 thread 对象的底层柄。</p><p>交换二个 <code>thread</code> 对象</p></blockquote><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;thread&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;chrono&gt;</span></span> <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">foo</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>{    std::this_thread::<span class="hljs-built_in">sleep_for</span>(std::chrono::<span class="hljs-built_in">seconds</span>(<span class="hljs-number">1</span>));} <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">bar</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>{    std::this_thread::<span class="hljs-built_in">sleep_for</span>(std::chrono::<span class="hljs-built_in">seconds</span>(<span class="hljs-number">1</span>));} <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>{    <span class="hljs-function">std::thread <span class="hljs-title">t1</span><span class="hljs-params">(foo)</span></span>;    <span class="hljs-function">std::thread <span class="hljs-title">t2</span><span class="hljs-params">(bar)</span></span>;     std::cout &lt;&lt; <span class="hljs-string">"thread 1 id: "</span> &lt;&lt; t1.<span class="hljs-built_in">get_id</span>() &lt;&lt; <span class="hljs-string">'\n'</span>              &lt;&lt; <span class="hljs-string">"thread 2 id: "</span> &lt;&lt; t2.<span class="hljs-built_in">get_id</span>() &lt;&lt; <span class="hljs-string">'\n'</span>;     std::<span class="hljs-built_in">swap</span>(t1, t2);     std::cout &lt;&lt; <span class="hljs-string">"after std::swap(t1, t2):"</span> &lt;&lt; <span class="hljs-string">'\n'</span>              &lt;&lt; <span class="hljs-string">"thread 1 id: "</span> &lt;&lt; t1.<span class="hljs-built_in">get_id</span>() &lt;&lt; <span class="hljs-string">'\n'</span>              &lt;&lt; <span class="hljs-string">"thread 2 id: "</span> &lt;&lt; t2.<span class="hljs-built_in">get_id</span>() &lt;&lt; <span class="hljs-string">'\n'</span>;     t1.<span class="hljs-built_in">swap</span>(t2);     std::cout &lt;&lt; <span class="hljs-string">"after t1.swap(t2):"</span> &lt;&lt; <span class="hljs-string">'\n'</span>              &lt;&lt; <span class="hljs-string">"thread 1 id: "</span> &lt;&lt; t1.<span class="hljs-built_in">get_id</span>() &lt;&lt; <span class="hljs-string">'\n'</span>              &lt;&lt; <span class="hljs-string">"thread 2 id: "</span> &lt;&lt; t2.<span class="hljs-built_in">get_id</span>() &lt;&lt; <span class="hljs-string">'\n'</span>;     t1.<span class="hljs-built_in">join</span>();    t2.<span class="hljs-built_in">join</span>();<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;}</code></pre></div><h3><span id="std-this-thread-yield">std::this_thread::yield()</span><a href="#std-this-thread-yield" class="header-anchor">#</a></h3><p><strong>建议实现重新调度各执行线程</strong></p><blockquote><p> 提供提示给实现，以重调度线程的执行，允许其他线程运行</p></blockquote><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;chrono&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;thread&gt;</span></span> <span class="hljs-comment">// 建议其他线程运行一小段时间的“忙睡眠”</span><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">little_sleep</span><span class="hljs-params">(std::chrono::microseconds us)</span></span><span class="hljs-function"></span>{    <span class="hljs-keyword">auto</span> start = std::chrono::high_resolution_clock::<span class="hljs-built_in">now</span>();    <span class="hljs-keyword">auto</span> end = start + us;    <span class="hljs-keyword">do</span> {        std::this_thread::<span class="hljs-built_in">yield</span>();    } <span class="hljs-keyword">while</span> (std::chrono::high_resolution_clock::<span class="hljs-built_in">now</span>() &lt; end);} <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>{    <span class="hljs-keyword">auto</span> start = std::chrono::high_resolution_clock::<span class="hljs-built_in">now</span>();     <span class="hljs-built_in">little_sleep</span>(std::chrono::<span class="hljs-built_in">microseconds</span>(<span class="hljs-number">100</span>));     <span class="hljs-keyword">auto</span> elapsed = std::chrono::high_resolution_clock::<span class="hljs-built_in">now</span>() - start;    std::cout &lt;&lt; <span class="hljs-string">"waited for "</span>              &lt;&lt; std::chrono::<span class="hljs-built_in">duration_cast</span>&lt;std::chrono::microseconds&gt;(elapsed).<span class="hljs-built_in">count</span>()              &lt;&lt; <span class="hljs-string">" microseconds\n"</span>;<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;}</code></pre></div><h3><span id="std-this-thread-get-id">std::this_thread::get_id()</span><a href="#std-this-thread-get-id" class="header-anchor">#</a></h3><blockquote><p>返回当前线程的线程 id</p></blockquote><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;thread&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;chrono&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;mutex&gt;</span></span> std::mutex g_display_mutex; <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">foo</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>{    std::thread::id this_id = std::this_thread::<span class="hljs-built_in">get_id</span>();     g_display_mutex.<span class="hljs-built_in">lock</span>();    std::cout &lt;&lt; <span class="hljs-string">"thread "</span> &lt;&lt; this_id &lt;&lt; <span class="hljs-string">" sleeping...\n"</span>;    g_display_mutex.<span class="hljs-built_in">unlock</span>();     std::this_thread::<span class="hljs-built_in">sleep_for</span>(std::chrono::<span class="hljs-built_in">seconds</span>(<span class="hljs-number">1</span>));} <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>{    <span class="hljs-function">std::thread <span class="hljs-title">t1</span><span class="hljs-params">(foo)</span></span>;    <span class="hljs-function">std::thread <span class="hljs-title">t2</span><span class="hljs-params">(foo)</span></span>;     t1.<span class="hljs-built_in">join</span>();    t2.<span class="hljs-built_in">join</span>();<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;}</code></pre></div><h3><span id="std-this-thread-sleep-for">std::this_thread::sleep_for()</span><a href="#std-this-thread-sleep-for" class="header-anchor">#</a></h3><blockquote><p>使当前线程的执行停止指定的时间段</p></blockquote><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;chrono&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;thread&gt;</span></span> <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>{    <span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std::chrono_literals;    std::cout &lt;&lt; <span class="hljs-string">"Hello waiter\n"</span> &lt;&lt; std::flush;    <span class="hljs-keyword">auto</span> start = std::chrono::high_resolution_clock::<span class="hljs-built_in">now</span>();    std::this_thread::<span class="hljs-built_in">sleep_for</span>(<span class="hljs-number">2000</span>ms);    <span class="hljs-keyword">auto</span> end = std::chrono::high_resolution_clock::<span class="hljs-built_in">now</span>();    std::chrono::duration&lt;<span class="hljs-type">double</span>, std::milli&gt; elapsed = end-start;    std::cout &lt;&lt; <span class="hljs-string">"Waited "</span> &lt;&lt; elapsed.<span class="hljs-built_in">count</span>() &lt;&lt; <span class="hljs-string">" ms\n"</span>;<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;}</code></pre></div><h3><span id="std-this-thread-sleep-until">std::this_thread::sleep_until()</span><a href="#std-this-thread-sleep-until" class="header-anchor">#</a></h3><blockquote><p>使当前线程的执行停止直到指定的时间点</p></blockquote><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span>  </span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iomanip&gt;</span>  </span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;chrono&gt;</span>  </span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;ctime&gt;</span>  </span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;thread&gt;</span>  </span><span class="hljs-meta">#<span class="hljs-keyword">pragma</span> <span class="hljs-keyword">warning</span>(disable:4996)<span class="hljs-comment">//加上可去掉unsafe 请使用localtime_s的编译报错  </span></span><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span>  </span><span class="hljs-function"></span>{      <span class="hljs-keyword">using</span> std::chrono::system_clock;      std::<span class="hljs-type">time_t</span> tt = system_clock::<span class="hljs-built_in">to_time_t</span>(system_clock::<span class="hljs-built_in">now</span>());      <span class="hljs-keyword">struct</span> <span class="hljs-title class_">std</span>::tm *ptm = std::<span class="hljs-built_in">localtime</span>(&amp;tt);      std::cout &lt;&lt; <span class="hljs-string">"Current time: "</span> &lt;&lt; std::<span class="hljs-built_in">put_time</span>(ptm, <span class="hljs-string">"%X"</span>) &lt;&lt; <span class="hljs-string">'\n'</span>; <span class="hljs-comment">//必须大写X，若小写x，输出的为日期  </span>    std::cout &lt;&lt; <span class="hljs-string">"Waiting for the next minute to begin...\n"</span>;      ++ptm-&gt;tm_min;       ptm-&gt;tm_sec = <span class="hljs-number">0</span>;      std::this_thread::<span class="hljs-built_in">sleep_until</span>(system_clock::<span class="hljs-built_in">from_time_t</span>(<span class="hljs-built_in">mktime</span>(ptm)));      std::cout &lt;&lt; std::<span class="hljs-built_in">put_time</span>(ptm, <span class="hljs-string">"%X"</span>) &lt;&lt; <span class="hljs-string">"reached!\n"</span>;        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;  }</code></pre></div><h1><span id="hu-chi">互斥</span><a href="#hu-chi" class="header-anchor">#</a></h1><h2><span id="include-lt-mutex-gt"><strong><code>#include &lt;mutex&gt;</code></strong></span><a href="#include-lt-mutex-gt" class="header-anchor">#</a></h2><h3><span id="std-mutex-lock">std::mutex::lock()</span><a href="#std-mutex-lock" class="header-anchor">#</a></h3><blockquote><p>锁定互斥。若另一线程已锁定互斥，则到 <code>lock</code> 的调用将阻塞执行，直至获得锁。</p></blockquote><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;chrono&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;thread&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;mutex&gt;</span></span> <span class="hljs-type">int</span> g_num = <span class="hljs-number">0</span>;  <span class="hljs-comment">// 为 g_num_mutex 所保护</span>std::mutex g_num_mutex; <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">slow_increment</span><span class="hljs-params">(<span class="hljs-type">int</span> id)</span> </span><span class="hljs-function"></span>{    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">3</span>; ++i) {        g_num_mutex.<span class="hljs-built_in">lock</span>();        ++g_num;        std::cout &lt;&lt; id &lt;&lt; <span class="hljs-string">" =&gt; "</span> &lt;&lt; g_num &lt;&lt; <span class="hljs-string">'\n'</span>;        g_num_mutex.<span class="hljs-built_in">unlock</span>();         std::this_thread::<span class="hljs-built_in">sleep_for</span>(std::chrono::<span class="hljs-built_in">seconds</span>(<span class="hljs-number">1</span>));    }} <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>{    <span class="hljs-function">std::thread <span class="hljs-title">t1</span><span class="hljs-params">(slow_increment, <span class="hljs-number">0</span>)</span></span>;    <span class="hljs-function">std::thread <span class="hljs-title">t2</span><span class="hljs-params">(slow_increment, <span class="hljs-number">1</span>)</span></span>;    t1.<span class="hljs-built_in">join</span>();    t2.<span class="hljs-built_in">join</span>();}</code></pre></div><h3><span id="std-mutex-try-lock">std::mutex::try_lock()</span><a href="#std-mutex-try-lock" class="header-anchor">#</a></h3><blockquote><p>尝试锁定互斥。立即返回。成功获得锁时返回 true ，否则返回 false 。</p></blockquote><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;chrono&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;mutex&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;thread&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span> <span class="hljs-comment">// std::cout</span></span> std::<span class="hljs-function">chrono::milliseconds <span class="hljs-title">interval</span><span class="hljs-params">(<span class="hljs-number">100</span>)</span></span>; std::mutex mutex;<span class="hljs-type">int</span> job_shared = <span class="hljs-number">0</span>; <span class="hljs-comment">// 两个线程都能修改 'job_shared',</span>    <span class="hljs-comment">// mutex 将保护此变量</span> <span class="hljs-type">int</span> job_exclusive = <span class="hljs-number">0</span>; <span class="hljs-comment">// 只有一个线程能修改 'job_exclusive'</span>    <span class="hljs-comment">// 不需要保护</span> <span class="hljs-comment">// 此线程能修改 'job_shared' 和 'job_exclusive'</span><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">job_1</span><span class="hljs-params">()</span> </span><span class="hljs-function"></span>{    std::this_thread::<span class="hljs-built_in">sleep_for</span>(interval); <span class="hljs-comment">// 令 'job_2' 持锁</span>     <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) {        <span class="hljs-comment">// 尝试锁定 mutex 以修改 'job_shared'</span>        <span class="hljs-keyword">if</span> (mutex.<span class="hljs-built_in">try_lock</span>()) {            std::cout &lt;&lt; <span class="hljs-string">"job shared ("</span> &lt;&lt; job_shared &lt;&lt; <span class="hljs-string">")\n"</span>;            mutex.<span class="hljs-built_in">unlock</span>();            <span class="hljs-keyword">return</span>;        } <span class="hljs-keyword">else</span> {            <span class="hljs-comment">// 不能获取锁以修改 'job_shared'</span>            <span class="hljs-comment">// 但有其他工作可做</span>            ++job_exclusive;            std::cout &lt;&lt; <span class="hljs-string">"job exclusive ("</span> &lt;&lt; job_exclusive &lt;&lt; <span class="hljs-string">")\n"</span>;            std::this_thread::<span class="hljs-built_in">sleep_for</span>(interval);        }    }} <span class="hljs-comment">// 此线程只能修改 'job_shared'</span><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">job_2</span><span class="hljs-params">()</span> </span><span class="hljs-function"></span>{    mutex.<span class="hljs-built_in">lock</span>();    std::this_thread::<span class="hljs-built_in">sleep_for</span>(<span class="hljs-number">5</span> * interval);    ++job_shared;    mutex.<span class="hljs-built_in">unlock</span>();} <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span><span class="hljs-function"></span>{    <span class="hljs-function">std::thread <span class="hljs-title">thread_1</span><span class="hljs-params">(job_1)</span></span>;    <span class="hljs-function">std::thread <span class="hljs-title">thread_2</span><span class="hljs-params">(job_2)</span></span>;     thread_1.<span class="hljs-built_in">join</span>();    thread_2.<span class="hljs-built_in">join</span>();}</code></pre></div><h3><span id="std-mutex-unlock">std::mutex::unlock()</span><a href="#std-mutex-unlock" class="header-anchor">#</a></h3><blockquote><p>解锁互斥</p></blockquote><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;chrono&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;thread&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;mutex&gt;</span></span> <span class="hljs-type">int</span> g_num = <span class="hljs-number">0</span>;  <span class="hljs-comment">// 为 g_num_mutex 所保护</span>std::mutex g_num_mutex; <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">slow_increment</span><span class="hljs-params">(<span class="hljs-type">int</span> id)</span> </span><span class="hljs-function"></span>{    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">3</span>; ++i) {        g_num_mutex.<span class="hljs-built_in">lock</span>();        ++g_num;        std::cout &lt;&lt; id &lt;&lt; <span class="hljs-string">" =&gt; "</span> &lt;&lt; g_num &lt;&lt; <span class="hljs-string">'\n'</span>;        g_num_mutex.<span class="hljs-built_in">unlock</span>();         std::this_thread::<span class="hljs-built_in">sleep_for</span>(std::chrono::<span class="hljs-built_in">seconds</span>(<span class="hljs-number">1</span>));    }} <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>{    <span class="hljs-function">std::thread <span class="hljs-title">t1</span><span class="hljs-params">(slow_increment, <span class="hljs-number">0</span>)</span></span>;    <span class="hljs-function">std::thread <span class="hljs-title">t2</span><span class="hljs-params">(slow_increment, <span class="hljs-number">1</span>)</span></span>;    t1.<span class="hljs-built_in">join</span>();    t2.<span class="hljs-built_in">join</span>();}</code></pre></div><h3><span id="std-timed-mutex">std::timed_mutex</span><a href="#std-timed-mutex" class="header-anchor">#</a></h3><blockquote><p><code>timed_mutex</code> 类是能用于保护数据免受多个线程同时访问的同步原语。</p></blockquote><h3><span id="std-timed-mutex-lock">std::timed_mutex::lock()</span><a href="#std-timed-mutex-lock" class="header-anchor">#</a></h3><blockquote><p>锁定互斥。若另一线程已锁定互斥，则到 <code>lock</code> 的调用将阻塞执行，直至获得锁。</p></blockquote><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;chrono&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;thread&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;mutex&gt;</span></span> <span class="hljs-type">int</span> g_num = <span class="hljs-number">0</span>;  <span class="hljs-comment">// 为 g_num_mutex 所保护</span>std::mutex g_num_mutex; <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">slow_increment</span><span class="hljs-params">(<span class="hljs-type">int</span> id)</span> </span><span class="hljs-function"></span>{    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">3</span>; ++i) {        g_num_mutex.<span class="hljs-built_in">lock</span>();        ++g_num;        std::cout &lt;&lt; id &lt;&lt; <span class="hljs-string">" =&gt; "</span> &lt;&lt; g_num &lt;&lt; <span class="hljs-string">'\n'</span>;        g_num_mutex.<span class="hljs-built_in">unlock</span>();         std::this_thread::<span class="hljs-built_in">sleep_for</span>(std::chrono::<span class="hljs-built_in">seconds</span>(<span class="hljs-number">1</span>));    }} <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>{    <span class="hljs-function">std::thread <span class="hljs-title">t1</span><span class="hljs-params">(slow_increment, <span class="hljs-number">0</span>)</span></span>;    <span class="hljs-function">std::thread <span class="hljs-title">t2</span><span class="hljs-params">(slow_increment, <span class="hljs-number">1</span>)</span></span>;    t1.<span class="hljs-built_in">join</span>();    t2.<span class="hljs-built_in">join</span>();}</code></pre></div><h3><span id="std-timed-mutex-unlock">std::timed_mutex::unlock()</span><a href="#std-timed-mutex-unlock" class="header-anchor">#</a></h3><blockquote><p>解锁互斥。</p></blockquote><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;chrono&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;thread&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;mutex&gt;</span></span> <span class="hljs-type">int</span> g_num = <span class="hljs-number">0</span>;  <span class="hljs-comment">// 为 g_num_mutex 所保护</span>std::mutex g_num_mutex; <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">slow_increment</span><span class="hljs-params">(<span class="hljs-type">int</span> id)</span> </span><span class="hljs-function"></span>{    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">3</span>; ++i) {        g_num_mutex.<span class="hljs-built_in">lock</span>();        ++g_num;        std::cout &lt;&lt; id &lt;&lt; <span class="hljs-string">" =&gt; "</span> &lt;&lt; g_num &lt;&lt; <span class="hljs-string">'\n'</span>;        g_num_mutex.<span class="hljs-built_in">unlock</span>();         std::this_thread::<span class="hljs-built_in">sleep_for</span>(std::chrono::<span class="hljs-built_in">seconds</span>(<span class="hljs-number">1</span>));    }} <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>{    <span class="hljs-function">std::thread <span class="hljs-title">t1</span><span class="hljs-params">(slow_increment, <span class="hljs-number">0</span>)</span></span>;    <span class="hljs-function">std::thread <span class="hljs-title">t2</span><span class="hljs-params">(slow_increment, <span class="hljs-number">1</span>)</span></span>;    t1.<span class="hljs-built_in">join</span>();    t2.<span class="hljs-built_in">join</span>();}</code></pre></div><h3><span id="std-timed-mutex-try-lock">std::timed_mutex::try_lock()</span><a href="#std-timed-mutex-try-lock" class="header-anchor">#</a></h3><blockquote><p>尝试锁定互斥。立即返回。成功获得锁时返回 true ，否则返回 false 。</p></blockquote><h3><span id="std-timed-mutex-try-lock-for">std::timed_mutex::try_lock_for()</span><a href="#std-timed-mutex-try-lock-for" class="header-anchor">#</a></h3><blockquote><p>尝试锁定互斥，若互斥在指定的时限时期中不可用则返回</p></blockquote><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;mutex&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;thread&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sstream&gt;</span></span> std::mutex cout_mutex; <span class="hljs-comment">// 控制到 std::cout 的访问</span>std::timed_mutex mutex; <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">job</span><span class="hljs-params">(<span class="hljs-type">int</span> id)</span> </span><span class="hljs-function"></span>{    <span class="hljs-keyword">using</span> Ms = std::chrono::milliseconds;    std::ostringstream stream;     <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">3</span>; ++i) {        <span class="hljs-keyword">if</span> (mutex.<span class="hljs-built_in">try_lock_for</span>(<span class="hljs-built_in">Ms</span>(<span class="hljs-number">100</span>))) {            stream &lt;&lt; <span class="hljs-string">"success "</span>;            std::this_thread::<span class="hljs-built_in">sleep_for</span>(<span class="hljs-built_in">Ms</span>(<span class="hljs-number">100</span>));            mutex.<span class="hljs-built_in">unlock</span>();        } <span class="hljs-keyword">else</span> {            stream &lt;&lt; <span class="hljs-string">"failed "</span>;        }        std::this_thread::<span class="hljs-built_in">sleep_for</span>(<span class="hljs-built_in">Ms</span>(<span class="hljs-number">100</span>));    }     <span class="hljs-function">std::lock_guard&lt;std::mutex&gt; <span class="hljs-title">lock</span><span class="hljs-params">(cout_mutex)</span></span>;    std::cout &lt;&lt; <span class="hljs-string">"["</span> &lt;&lt; id &lt;&lt; <span class="hljs-string">"] "</span> &lt;&lt; stream.<span class="hljs-built_in">str</span>() &lt;&lt; <span class="hljs-string">"\n"</span>;} <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span><span class="hljs-function"></span>{    std::vector&lt;std::thread&gt; threads;    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">4</span>; ++i) {        threads.<span class="hljs-built_in">emplace_back</span>(job, i);    }     <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span>&amp; i: threads) {        i.<span class="hljs-built_in">join</span>();    }}</code></pre></div><h3><span id="std-timed-mutex-try-lock-until">std::timed_mutex::try_lock_until()</span><a href="#std-timed-mutex-try-lock-until" class="header-anchor">#</a></h3><blockquote><p>尝试锁定互斥，若直至抵达指定时间点互斥不可用则返回</p></blockquote><blockquote><p> 尝试所互斥。阻塞直至抵达指定的 <code>timeout_time</code> 或得到锁，取决于何者先到来。成功获得锁时返回 true ，否则返回 false 。</p></blockquote><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;thread&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;chrono&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;mutex&gt;</span></span> std::timed_mutex test_mutex; <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">f</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>{    <span class="hljs-keyword">auto</span> now=std::chrono::steady_clock::<span class="hljs-built_in">now</span>();    test_mutex.<span class="hljs-built_in">try_lock_until</span>(now + std::chrono::<span class="hljs-built_in">seconds</span>(<span class="hljs-number">10</span>));    std::cout &lt;&lt; <span class="hljs-string">"hello world\n"</span>;} <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>{    <span class="hljs-function">std::lock_guard&lt;std::timed_mutex&gt; <span class="hljs-title">l</span><span class="hljs-params">(test_mutex)</span></span>;    <span class="hljs-function">std::thread <span class="hljs-title">t</span><span class="hljs-params">(f)</span></span>;    t.<span class="hljs-built_in">join</span>();<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;}</code></pre></div><h3><span id="std-lock-guard-lt-std-mutex-gt">std::lock_guard<code>&lt;std::mutex&gt;</code></span><a href="#std-lock-guard-lt-std-mutex-gt" class="header-anchor">#</a></h3><blockquote><p>实现严格基于作用域的互斥体所有权包装器</p><p>创建 <code>lock_guard</code> 对象时，它试图接收给定互斥的所有权。控制<strong>离开</strong>创建 <code>lock_guard</code> 对象的作用域时，<strong>销毁</strong> <code>lock_guard</code> 并释放互斥。</p><p><code>lock_guard</code> 类不可复制。</p></blockquote><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;thread&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;mutex&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span> <span class="hljs-type">int</span> g_i = <span class="hljs-number">0</span>;std::mutex g_i_mutex;  <span class="hljs-comment">// 保护 g_i</span> <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">safe_increment</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>{    <span class="hljs-function">std::lock_guard&lt;std::mutex&gt; <span class="hljs-title">lock</span><span class="hljs-params">(g_i_mutex)</span></span>;    ++g_i;     std::cout &lt;&lt; std::this_thread::<span class="hljs-built_in">get_id</span>() &lt;&lt; <span class="hljs-string">": "</span> &lt;&lt; g_i &lt;&lt; <span class="hljs-string">'\n'</span>;     <span class="hljs-comment">// g_i_mutex 在锁离开作用域时自动释放</span>} <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>{    std::cout &lt;&lt; <span class="hljs-string">"main: "</span> &lt;&lt; g_i &lt;&lt; <span class="hljs-string">'\n'</span>;     <span class="hljs-function">std::thread <span class="hljs-title">t1</span><span class="hljs-params">(safe_increment)</span></span>;    <span class="hljs-function">std::thread <span class="hljs-title">t2</span><span class="hljs-params">(safe_increment)</span></span>;     t1.<span class="hljs-built_in">join</span>();    t2.<span class="hljs-built_in">join</span>();     std::cout &lt;&lt; <span class="hljs-string">"main: "</span> &lt;&lt; g_i &lt;&lt; <span class="hljs-string">'\n'</span>;<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;}</code></pre></div><h3><span id="std-unique-lock-lt-mutex-gt-lock">std::unique_lock<code>&lt;Mutex&gt;::lock</code></span><a href="#std-unique-lock-lt-mutex-gt-lock" class="header-anchor">#</a></h3><blockquote><p>等效地调用 mutex()-&gt;lock()</p></blockquote><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;mutex&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;thread&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;chrono&gt;</span></span> <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>{    <span class="hljs-type">int</span> counter = <span class="hljs-number">0</span>;    std::mutex counter_mutex;    std::vector&lt;std::thread&gt; threads;     <span class="hljs-keyword">auto</span> worker_task = [&amp;](<span class="hljs-type">int</span> id) {        std::unique_lock&lt;std::mutex&gt; <span class="hljs-built_in">lock</span>(counter_mutex);        ++counter;        std::cout &lt;&lt; id &lt;&lt; <span class="hljs-string">", initial counter: "</span> &lt;&lt; counter &lt;&lt; <span class="hljs-string">'\n'</span>;        lock.<span class="hljs-built_in">unlock</span>();         <span class="hljs-comment">// 我们模拟昂贵操作时不保有锁</span>        std::this_thread::<span class="hljs-built_in">sleep_for</span>(std::chrono::<span class="hljs-built_in">seconds</span>(<span class="hljs-number">1</span>));         lock.<span class="hljs-built_in">lock</span>(); <span class="hljs-comment">// 可以不解锁，因为是智能锁</span>        ++counter;        std::cout &lt;&lt; id &lt;&lt; <span class="hljs-string">", final counter: "</span> &lt;&lt; counter &lt;&lt; <span class="hljs-string">'\n'</span>;    };     <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; ++i) threads.<span class="hljs-built_in">emplace_back</span>(worker_task, i);     <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> &amp;thread : threads) thread.<span class="hljs-built_in">join</span>();    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;}</code></pre></div><h3><span id="std-unique-lock-lt-std-mutex-gt">std::unique_lock<code>&lt;std::mutex&gt;</code></span><a href="#std-unique-lock-lt-std-mutex-gt" class="header-anchor">#</a></h3><blockquote><p>类 unique_lock 是通用互斥包装器，允许延迟锁定、锁定的有时限尝试、递归锁定、所有权转移和与条件变量一同使用</p><p>类 unique_lock 可移动，但不可复制</p></blockquote><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;mutex&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;thread&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;chrono&gt;</span></span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">Box</span> {    <span class="hljs-function"><span class="hljs-keyword">explicit</span> <span class="hljs-title">Box</span><span class="hljs-params">(<span class="hljs-type">int</span> num)</span> : num_things{</span>num} {}     <span class="hljs-type">int</span> num_things;    std::mutex m;}; <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">transfer</span><span class="hljs-params">(Box &amp;from, Box &amp;to, <span class="hljs-type">int</span> num)</span></span><span class="hljs-function"></span>{    <span class="hljs-comment">// 仍未实际取锁</span>    <span class="hljs-function">std::unique_lock&lt;std::mutex&gt; <span class="hljs-title">lock1</span><span class="hljs-params">(from.m, std::defer_lock)</span></span>;    <span class="hljs-function">std::unique_lock&lt;std::mutex&gt; <span class="hljs-title">lock2</span><span class="hljs-params">(to.m, std::defer_lock)</span></span>;     <span class="hljs-comment">// 锁两个 unique_lock 而不死锁</span>    std::<span class="hljs-built_in">lock</span>(lock1, lock2);     from.num_things -= num;    to.num_things += num;     <span class="hljs-comment">// 'from.m' 与 'to.m' 互斥解锁于 'unique_lock' 析构函数</span>} <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>{    <span class="hljs-function">Box <span class="hljs-title">acc1</span><span class="hljs-params">(<span class="hljs-number">100</span>)</span></span>;    <span class="hljs-function">Box <span class="hljs-title">acc2</span><span class="hljs-params">(<span class="hljs-number">50</span>)</span></span>;     <span class="hljs-function">std::thread <span class="hljs-title">t1</span><span class="hljs-params">(transfer, std::ref(acc1), std::ref(acc2), <span class="hljs-number">10</span>)</span></span>;    <span class="hljs-function">std::thread <span class="hljs-title">t2</span><span class="hljs-params">(transfer, std::ref(acc2), std::ref(acc1), <span class="hljs-number">5</span>)</span></span>;     t1.<span class="hljs-built_in">join</span>();    t2.<span class="hljs-built_in">join</span>();<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;}</code></pre></div><h3><span id="std-unique-lock-lt-mutex-gt-try-lock">std::unique_lock<code>&lt;Mutex&gt;::try_lock</code></span><a href="#std-unique-lock-lt-mutex-gt-try-lock" class="header-anchor">#</a></h3><blockquote><p>尝试锁定关联互斥，若互斥不可用则返回</p></blockquote><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;chrono&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;mutex&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;thread&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span> <span class="hljs-comment">// std::cout</span></span> std::<span class="hljs-function">chrono::milliseconds <span class="hljs-title">interval</span><span class="hljs-params">(<span class="hljs-number">100</span>)</span></span>; std::mutex mutex;<span class="hljs-type">int</span> job_shared = <span class="hljs-number">0</span>; <span class="hljs-comment">// 两个线程都能修改 'job_shared',</span>    <span class="hljs-comment">// mutex 将保护此变量</span> <span class="hljs-type">int</span> job_exclusive = <span class="hljs-number">0</span>; <span class="hljs-comment">// 只有一个线程能修改 'job_exclusive'</span>    <span class="hljs-comment">// 不需要保护</span> <span class="hljs-comment">// 此线程能修改 'job_shared' 和 'job_exclusive'</span><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">job_1</span><span class="hljs-params">()</span> </span><span class="hljs-function"></span>{    std::this_thread::<span class="hljs-built_in">sleep_for</span>(interval); <span class="hljs-comment">// 令 'job_2' 持锁</span>     <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) {        <span class="hljs-comment">// 尝试锁定 mutex 以修改 'job_shared'</span>        <span class="hljs-keyword">if</span> (std::unique_lock&lt;std::mutex&gt;::try_lock <span class="hljs-built_in">lk</span>(mutex)) {            std::cout &lt;&lt; <span class="hljs-string">"job shared ("</span> &lt;&lt; job_shared &lt;&lt; <span class="hljs-string">")\n"</span>;            lk.<span class="hljs-built_in">unlock</span>();            <span class="hljs-keyword">return</span>;        } <span class="hljs-keyword">else</span> {            <span class="hljs-comment">// 不能获取锁以修改 'job_shared'</span>            <span class="hljs-comment">// 但有其他工作可做</span>            ++job_exclusive;            std::cout &lt;&lt; <span class="hljs-string">"job exclusive ("</span> &lt;&lt; job_exclusive &lt;&lt; <span class="hljs-string">")\n"</span>;            std::this_thread::<span class="hljs-built_in">sleep_for</span>(interval);        }    }} <span class="hljs-comment">// 此线程只能修改 'job_shared'</span><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">job_2</span><span class="hljs-params">()</span> </span><span class="hljs-function"></span>{    mutex.<span class="hljs-built_in">lock</span>();    std::this_thread::<span class="hljs-built_in">sleep_for</span>(<span class="hljs-number">5</span> * interval);    ++job_shared;    mutex.<span class="hljs-built_in">unlock</span>();} <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span><span class="hljs-function"></span>{    <span class="hljs-function">std::thread <span class="hljs-title">thread_1</span><span class="hljs-params">(job_1)</span></span>;    <span class="hljs-function">std::thread <span class="hljs-title">thread_2</span><span class="hljs-params">(job_2)</span></span>;     thread_1.<span class="hljs-built_in">join</span>();    thread_2.<span class="hljs-built_in">join</span>();}</code></pre></div><h3><span id="std-unique-lock-lt-mutex-gt-try-lock-for">std::unique_lock<code>&lt;Mutex&gt;::try_lock_for</code></span><a href="#std-unique-lock-lt-mutex-gt-try-lock-for" class="header-anchor">#</a></h3><blockquote><p>试图锁定关联的<a href="https://zh.cppreference.com/w/cpp/named_req/TimedLockable"><em>可定时锁定</em> <em>(TimedLockable)</em> </a>互斥，若互斥在给定时长中不可用则返回</p><p>bool try_lock_for( const <a href="http://zh.cppreference.com/w/cpp/chrono/duration">std::chrono::duration</a>&lt;Rep,Period&gt;&amp; timeout_duration );</p><p> timeout_duration  -    要阻塞的最大时长 </p></blockquote><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;chrono&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;mutex&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;thread&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span> <span class="hljs-comment">// std::cout</span></span> std::<span class="hljs-function">chrono::milliseconds <span class="hljs-title">interval</span><span class="hljs-params">(<span class="hljs-number">100</span>)</span></span>; std::mutex mutex;<span class="hljs-type">int</span> job_shared = <span class="hljs-number">0</span>; <span class="hljs-comment">// 两个线程都能修改 'job_shared',</span>    <span class="hljs-comment">// mutex 将保护此变量</span> <span class="hljs-type">int</span> job_exclusive = <span class="hljs-number">0</span>; <span class="hljs-comment">// 只有一个线程能修改 'job_exclusive'</span>    <span class="hljs-comment">// 不需要保护</span> <span class="hljs-comment">// 此线程能修改 'job_shared' 和 'job_exclusive'</span><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">job_1</span><span class="hljs-params">()</span> </span><span class="hljs-function"></span>{    std::this_thread::<span class="hljs-built_in">sleep_for</span>(interval); <span class="hljs-comment">// 令 'job_2' 持锁</span>     <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) {        <span class="hljs-comment">// 尝试锁定 mutex 以修改 'job_shared'</span>        <span class="hljs-keyword">if</span> (std::unique_lock&lt;std::mutex&gt;::try_lock_for <span class="hljs-built_in">lk</span>(mutex)) {            std::cout &lt;&lt; <span class="hljs-string">"job shared ("</span> &lt;&lt; job_shared &lt;&lt; <span class="hljs-string">")\n"</span>;            lk.<span class="hljs-built_in">unlock</span>();            <span class="hljs-keyword">return</span>;        } <span class="hljs-keyword">else</span> {            <span class="hljs-comment">// 不能获取锁以修改 'job_shared'</span>            <span class="hljs-comment">// 但有其他工作可做</span>            ++job_exclusive;            std::cout &lt;&lt; <span class="hljs-string">"job exclusive ("</span> &lt;&lt; job_exclusive &lt;&lt; <span class="hljs-string">")\n"</span>;            std::this_thread::<span class="hljs-built_in">sleep_for</span>(interval);        }    }} <span class="hljs-comment">// 此线程只能修改 'job_shared'</span><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">job_2</span><span class="hljs-params">()</span> </span><span class="hljs-function"></span>{    mutex.<span class="hljs-built_in">lock</span>();    std::this_thread::<span class="hljs-built_in">sleep_for</span>(<span class="hljs-number">5</span> * interval);    ++job_shared;    mutex.<span class="hljs-built_in">unlock</span>();} <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span><span class="hljs-function"></span>{    <span class="hljs-function">std::thread <span class="hljs-title">thread_1</span><span class="hljs-params">(job_1)</span></span>;    <span class="hljs-function">std::thread <span class="hljs-title">thread_2</span><span class="hljs-params">(job_2)</span></span>;     thread_1.<span class="hljs-built_in">join</span>();    thread_2.<span class="hljs-built_in">join</span>();}</code></pre></div><h3><span id="std-call-once">std::call_once</span><a href="#std-call-once" class="header-anchor">#</a></h3><blockquote><p>仅调用函数一次，即使从多个线程调用</p></blockquote><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;thread&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;mutex&gt;</span></span>std::once_flag flag1, flag2;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">simple_do_once</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>{    std::<span class="hljs-built_in">call_once</span>(flag1, [](){ std::cout &lt;&lt; <span class="hljs-string">"Simple example: called once\n"</span>; });}<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">may_throw_function</span><span class="hljs-params">(<span class="hljs-type">bool</span> do_throw)</span></span><span class="hljs-function"></span>{    <span class="hljs-keyword">if</span> (do_throw) {        std::cout &lt;&lt; <span class="hljs-string">"throw: call_once will retry\n"</span>; <span class="hljs-comment">// 这会出现多于一次</span>        <span class="hljs-keyword">throw</span> std::<span class="hljs-built_in">exception</span>();    }    std::cout &lt;&lt; <span class="hljs-string">"Didn't throw, call_once will not attempt again\n"</span>; <span class="hljs-comment">// 保证一次</span>}<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">do_once</span><span class="hljs-params">(<span class="hljs-type">bool</span> do_throw)</span></span><span class="hljs-function"></span>{    <span class="hljs-keyword">try</span> {        std::<span class="hljs-built_in">call_once</span>(flag2, may_throw_function, do_throw);    }    <span class="hljs-built_in">catch</span> (...) {    }}<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>{    <span class="hljs-function">std::thread <span class="hljs-title">st1</span><span class="hljs-params">(simple_do_once)</span></span>;    <span class="hljs-function">std::thread <span class="hljs-title">st2</span><span class="hljs-params">(simple_do_once)</span></span>;    <span class="hljs-function">std::thread <span class="hljs-title">st3</span><span class="hljs-params">(simple_do_once)</span></span>;    <span class="hljs-function">std::thread <span class="hljs-title">st4</span><span class="hljs-params">(simple_do_once)</span></span>;    st1.<span class="hljs-built_in">join</span>();    st2.<span class="hljs-built_in">join</span>();    st3.<span class="hljs-built_in">join</span>();    st4.<span class="hljs-built_in">join</span>();    <span class="hljs-function">std::thread <span class="hljs-title">t1</span><span class="hljs-params">(do_once, <span class="hljs-literal">true</span>)</span></span>;    <span class="hljs-function">std::thread <span class="hljs-title">t2</span><span class="hljs-params">(do_once, <span class="hljs-literal">true</span>)</span></span>;    <span class="hljs-function">std::thread <span class="hljs-title">t3</span><span class="hljs-params">(do_once, <span class="hljs-literal">false</span>)</span></span>;    <span class="hljs-function">std::thread <span class="hljs-title">t4</span><span class="hljs-params">(do_once, <span class="hljs-literal">true</span>)</span></span>;    t1.<span class="hljs-built_in">join</span>();    t2.<span class="hljs-built_in">join</span>();    t3.<span class="hljs-built_in">join</span>();    t4.<span class="hljs-built_in">join</span>();    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;}</code></pre></div><p>结果</p><div class="code-wrapper"><pre><code class="hljs shell">Simple example: called oncethrow: call_once will retry</code></pre></div><h1><span id="tiao-jian-bian-liang">条件变量</span><a href="#tiao-jian-bian-liang" class="header-anchor">#</a></h1><blockquote><p>条件变量是允许多个线程相互交流的同步原语。它允许一定量的线程等待（可以定时）另一线程的提醒，然后再继续。条件变量始终关联到一个互斥。</p></blockquote><p>定义于头文件 <code>&lt;condition_variable&gt;</code></p><h3><span id="std-condition-variable">std::condition_variable</span><a href="#std-condition-variable" class="header-anchor">#</a></h3><blockquote><p>提供与 <a href="https://zh.cppreference.com/w/cpp/thread/unique_lock">std::unique_lock</a> 关联的条件变量</p><p><code>condition_variable</code> 类是同步原语，能用于阻塞一个线程，或同时阻塞多个线程，直至另一线程修改共享变量（<em>条件</em>）并通知 <code>condition_variable</code> 。</p></blockquote><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;thread&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;mutex&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;condition_variable&gt;</span></span> std::mutex m;std::condition_variable cv;std::string data;<span class="hljs-type">bool</span> ready = <span class="hljs-literal">false</span>;<span class="hljs-type">bool</span> processed = <span class="hljs-literal">false</span>; <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">worker_thread</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>{    <span class="hljs-comment">// 等待直至 main() 发送数据</span>    <span class="hljs-function">std::unique_lock&lt;std::mutex&gt; <span class="hljs-title">lk</span><span class="hljs-params">(m)</span></span>;    cv.<span class="hljs-built_in">wait</span>(lk, []{<span class="hljs-keyword">return</span> ready;});     <span class="hljs-comment">// 等待后，我们占有锁。</span>    std::cout &lt;&lt; <span class="hljs-string">"Worker thread is processing data\n"</span>;    data += <span class="hljs-string">" after processing"</span>;     <span class="hljs-comment">// 发送数据回 main()</span>    processed = <span class="hljs-literal">true</span>;    std::cout &lt;&lt; <span class="hljs-string">"Worker thread signals data processing completed\n"</span>;     <span class="hljs-comment">// 通知前完成手动解锁，以避免等待线程才被唤醒就阻塞（细节见 notify_one ）</span>    lk.<span class="hljs-built_in">unlock</span>();    cv.<span class="hljs-built_in">notify_one</span>();} <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>{    <span class="hljs-function">std::thread <span class="hljs-title">worker</span><span class="hljs-params">(worker_thread)</span></span>;     data = <span class="hljs-string">"Example data"</span>;    <span class="hljs-comment">// 发送数据到 worker 线程</span>    {        <span class="hljs-function">std::lock_guard&lt;std::mutex&gt; <span class="hljs-title">lk</span><span class="hljs-params">(m)</span></span>;        ready = <span class="hljs-literal">true</span>;        std::cout &lt;&lt; <span class="hljs-string">"main() signals data ready for processing\n"</span>;    }    cv.<span class="hljs-built_in">notify_one</span>();     <span class="hljs-comment">// 等候 worker</span>    {        <span class="hljs-function">std::unique_lock&lt;std::mutex&gt; <span class="hljs-title">lk</span><span class="hljs-params">(m)</span></span>;        cv.<span class="hljs-built_in">wait</span>(lk, []{<span class="hljs-keyword">return</span> processed;});    }    std::cout &lt;&lt; <span class="hljs-string">"Back in main(), data = "</span> &lt;&lt; data &lt;&lt; <span class="hljs-string">'\n'</span>;     worker.<span class="hljs-built_in">join</span>();}</code></pre></div><h3><span id="std-condition-variable-notify-all">std::condition_variable::notify_all()</span><a href="#std-condition-variable-notify-all" class="header-anchor">#</a></h3><blockquote><p>解阻塞全部当前等待于 *this 的线程</p></blockquote><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;condition_variable&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;thread&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;chrono&gt;</span></span> std::condition_variable cv;std::mutex cv_m; <span class="hljs-comment">// 此互斥用于三个目的：</span>                 <span class="hljs-comment">// 1) 同步到 i 的访问</span>                 <span class="hljs-comment">// 2) 同步到 std::cerr 的访问</span>                 <span class="hljs-comment">// 3) 为条件变量 cv</span><span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">waits</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>{    <span class="hljs-function">std::unique_lock&lt;std::mutex&gt; <span class="hljs-title">lk</span><span class="hljs-params">(cv_m)</span></span>;    std::cerr &lt;&lt; <span class="hljs-string">"Waiting... \n"</span>;    cv.<span class="hljs-built_in">wait</span>(lk, []{<span class="hljs-keyword">return</span> i == <span class="hljs-number">1</span>;});    std::cerr &lt;&lt; <span class="hljs-string">"...finished waiting. i == 1\n"</span>;} <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">signals</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>{    std::this_thread::<span class="hljs-built_in">sleep_for</span>(std::chrono::<span class="hljs-built_in">seconds</span>(<span class="hljs-number">1</span>));    {        <span class="hljs-function">std::lock_guard&lt;std::mutex&gt; <span class="hljs-title">lk</span><span class="hljs-params">(cv_m)</span></span>;        std::cerr &lt;&lt; <span class="hljs-string">"Notifying...\n"</span>;    }    cv.<span class="hljs-built_in">notify_all</span>();     std::this_thread::<span class="hljs-built_in">sleep_for</span>(std::chrono::<span class="hljs-built_in">seconds</span>(<span class="hljs-number">1</span>));     {        <span class="hljs-function">std::lock_guard&lt;std::mutex&gt; <span class="hljs-title">lk</span><span class="hljs-params">(cv_m)</span></span>;        i = <span class="hljs-number">1</span>;        std::cerr &lt;&lt; <span class="hljs-string">"Notifying again...\n"</span>;    }    cv.<span class="hljs-built_in">notify_all</span>();} <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>{    <span class="hljs-function">std::thread <span class="hljs-title">t1</span><span class="hljs-params">(waits)</span>, <span class="hljs-title">t2</span><span class="hljs-params">(waits)</span>, <span class="hljs-title">t3</span><span class="hljs-params">(waits)</span>, <span class="hljs-title">t4</span><span class="hljs-params">(signals)</span></span>;    t1.<span class="hljs-built_in">join</span>();     t2.<span class="hljs-built_in">join</span>();     t3.<span class="hljs-built_in">join</span>();    t4.<span class="hljs-built_in">join</span>();}</code></pre></div><h3><span id="std-condition-variable-notify-one">std::condition_variable::notify_one()</span><a href="#std-condition-variable-notify-one" class="header-anchor">#</a></h3><blockquote><p>若任何线程在 *this 上等待，则调用 <code>notify_one</code> 会解除一个阻塞等待线程</p></blockquote><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;condition_variable&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;thread&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;chrono&gt;</span></span> std::condition_variable cv;std::mutex cv_m;<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;<span class="hljs-type">bool</span> done = <span class="hljs-literal">false</span>; <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">waits</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>{    <span class="hljs-function">std::unique_lock&lt;std::mutex&gt; <span class="hljs-title">lk</span><span class="hljs-params">(cv_m)</span></span>;    std::cout &lt;&lt; <span class="hljs-string">"Waiting... \n"</span>;    cv.<span class="hljs-built_in">wait</span>(lk, []{<span class="hljs-keyword">return</span> i == <span class="hljs-number">1</span>;});    std::cout &lt;&lt; <span class="hljs-string">"...finished waiting. i == 1\n"</span>;    done = <span class="hljs-literal">true</span>;} <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">signals</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>{    std::this_thread::<span class="hljs-built_in">sleep_for</span>(std::chrono::<span class="hljs-built_in">seconds</span>(<span class="hljs-number">1</span>));    std::cout &lt;&lt; <span class="hljs-string">"Notifying falsely...\n"</span>;    cv.<span class="hljs-built_in">notify_one</span>(); <span class="hljs-comment">// 等待线程被通知 i == 0.</span>                     <span class="hljs-comment">// cv.wait 唤醒，检查 i ，再回到等待</span>     <span class="hljs-function">std::unique_lock&lt;std::mutex&gt; <span class="hljs-title">lk</span><span class="hljs-params">(cv_m)</span></span>;    i = <span class="hljs-number">1</span>;    <span class="hljs-keyword">while</span> (!done)     {        std::cout &lt;&lt; <span class="hljs-string">"Notifying true change...\n"</span>;        lk.<span class="hljs-built_in">unlock</span>();        cv.<span class="hljs-built_in">notify_one</span>(); <span class="hljs-comment">// 等待线程被通知 i == 1 ， cv.wait 返回</span>        std::this_thread::<span class="hljs-built_in">sleep_for</span>(std::chrono::<span class="hljs-built_in">seconds</span>(<span class="hljs-number">1</span>));        lk.<span class="hljs-built_in">lock</span>();    }} <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>{    <span class="hljs-function">std::thread <span class="hljs-title">t1</span><span class="hljs-params">(waits)</span>, <span class="hljs-title">t2</span><span class="hljs-params">(signals)</span></span>;    t1.<span class="hljs-built_in">join</span>();     t2.<span class="hljs-built_in">join</span>();}</code></pre></div><h3><span id="std-condition-variable-wait">std::condition_variable::wait()</span><a href="#std-condition-variable-wait" class="header-anchor">#</a></h3><blockquote><p>wait 导致当前线程阻塞直至条件变量被通知，或虚假唤醒发生，可选地循环直至满足某谓词。</p></blockquote><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;condition_variable&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;thread&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;chrono&gt;</span></span> std::condition_variable cv;std::mutex cv_m; <span class="hljs-comment">// 此互斥用于三个目的：</span>                 <span class="hljs-comment">// 1) 同步到 i 的访问</span>                 <span class="hljs-comment">// 2) 同步到 std::cerr 的访问</span>                 <span class="hljs-comment">// 3) 为条件变量 cv</span><span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">waits</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>{    <span class="hljs-function">std::unique_lock&lt;std::mutex&gt; <span class="hljs-title">lk</span><span class="hljs-params">(cv_m)</span></span>;    std::cerr &lt;&lt; <span class="hljs-string">"Waiting... \n"</span>;    cv.<span class="hljs-built_in">wait</span>(lk, []{<span class="hljs-keyword">return</span> i == <span class="hljs-number">1</span>;});    std::cerr &lt;&lt; <span class="hljs-string">"...finished waiting. i == 1\n"</span>;} <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">signals</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>{    std::this_thread::<span class="hljs-built_in">sleep_for</span>(std::chrono::<span class="hljs-built_in">seconds</span>(<span class="hljs-number">1</span>));    {        <span class="hljs-function">std::lock_guard&lt;std::mutex&gt; <span class="hljs-title">lk</span><span class="hljs-params">(cv_m)</span></span>;        std::cerr &lt;&lt; <span class="hljs-string">"Notifying...\n"</span>;    }    cv.<span class="hljs-built_in">notify_all</span>();     std::this_thread::<span class="hljs-built_in">sleep_for</span>(std::chrono::<span class="hljs-built_in">seconds</span>(<span class="hljs-number">1</span>));     {        <span class="hljs-function">std::lock_guard&lt;std::mutex&gt; <span class="hljs-title">lk</span><span class="hljs-params">(cv_m)</span></span>;        i = <span class="hljs-number">1</span>;        std::cerr &lt;&lt; <span class="hljs-string">"Notifying again...\n"</span>;    }    cv.<span class="hljs-built_in">notify_all</span>();} <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>{    <span class="hljs-function">std::thread <span class="hljs-title">t1</span><span class="hljs-params">(waits)</span>, <span class="hljs-title">t2</span><span class="hljs-params">(waits)</span>, <span class="hljs-title">t3</span><span class="hljs-params">(waits)</span>, <span class="hljs-title">t4</span><span class="hljs-params">(signals)</span></span>;    t1.<span class="hljs-built_in">join</span>();     t2.<span class="hljs-built_in">join</span>();     t3.<span class="hljs-built_in">join</span>();    t4.<span class="hljs-built_in">join</span>();}</code></pre></div><h3><span id="std-condition-variable-wait-for">std::condition_variable::wait_for()</span><a href="#std-condition-variable-wait-for" class="header-anchor">#</a></h3><blockquote><p>阻塞当前线程，直到条件变量被唤醒，或到指定时限时长后</p></blockquote><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;atomic&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;condition_variable&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;thread&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;chrono&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std::chrono_literals; std::condition_variable cv;std::mutex cv_m;std::atomic&lt;<span class="hljs-type">int</span>&gt; i{<span class="hljs-number">0</span>}; <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">waits</span><span class="hljs-params">(<span class="hljs-type">int</span> idx)</span></span><span class="hljs-function"></span>{    <span class="hljs-function">std::unique_lock&lt;std::mutex&gt; <span class="hljs-title">lk</span><span class="hljs-params">(cv_m)</span></span>;    <span class="hljs-keyword">auto</span> now = std::chrono::system_clock::<span class="hljs-built_in">now</span>();    <span class="hljs-keyword">if</span>(cv.<span class="hljs-built_in">wait_until</span>(lk, now + idx*<span class="hljs-number">100</span>ms, [](){<span class="hljs-keyword">return</span> i == <span class="hljs-number">1</span>;}))        std::cerr &lt;&lt; <span class="hljs-string">"Thread "</span> &lt;&lt; idx &lt;&lt; <span class="hljs-string">" finished waiting. i == "</span> &lt;&lt; i &lt;&lt; <span class="hljs-string">'\n'</span>;    <span class="hljs-keyword">else</span>        std::cerr &lt;&lt; <span class="hljs-string">"Thread "</span> &lt;&lt; idx &lt;&lt; <span class="hljs-string">" timed out. i == "</span> &lt;&lt; i &lt;&lt; <span class="hljs-string">'\n'</span>;} <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">signals</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>{    std::this_thread::<span class="hljs-built_in">sleep_for</span>(<span class="hljs-number">120</span>ms);    std::cerr &lt;&lt; <span class="hljs-string">"Notifying...\n"</span>;    cv.<span class="hljs-built_in">notify_all</span>();    std::this_thread::<span class="hljs-built_in">sleep_for</span>(<span class="hljs-number">100</span>ms);    i = <span class="hljs-number">1</span>;    std::cerr &lt;&lt; <span class="hljs-string">"Notifying again...\n"</span>;    cv.<span class="hljs-built_in">notify_all</span>();} <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>{    <span class="hljs-function">std::thread <span class="hljs-title">t1</span><span class="hljs-params">(waits, <span class="hljs-number">1</span>)</span>, <span class="hljs-title">t2</span><span class="hljs-params">(waits, <span class="hljs-number">2</span>)</span>, <span class="hljs-title">t3</span><span class="hljs-params">(waits, <span class="hljs-number">3</span>)</span>, <span class="hljs-title">t4</span><span class="hljs-params">(signals)</span></span>;    t1.<span class="hljs-built_in">join</span>();     t2.<span class="hljs-built_in">join</span>();    t3.<span class="hljs-built_in">join</span>();    t4.<span class="hljs-built_in">join</span>();}</code></pre></div><h1><span id="xin-hao-liang">信号量</span><a href="#xin-hao-liang" class="header-anchor">#</a></h1><blockquote><p>信号量 (semaphore) 是一种轻量的同步原件，用于制约对共享资源的并发访问。在可以使用两者时，信号量能比条件变量更有效率。</p></blockquote><p>定义于头文件 <code>&lt;semaphore&gt;</code></p><h3><span id="std-counting-semaphore-std-binary-semaphore">std::counting_semaphore, std::binary_semaphore</span><a href="#std-counting-semaphore-std-binary-semaphore" class="header-anchor">#</a></h3><blockquote><p>\1) <code>counting_semaphore</code> 是一个轻量同步元件，能控制对共享资源的访问。</p><p>\2) <code>binary_semaphore</code> 是 std::counting_semaphore 的特化的别名，其 <code>LeastMaxValue</code> 为 1 。实现可能将 <code>binary_semaphore</code> 实现得比 std::counting_semaphore 的默认实现更高效。</p></blockquote><h4><span id="std-counting-semaphore">std::counting_semaphore</span><a href="#std-counting-semaphore" class="header-anchor">#</a></h4><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;thread&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;chrono&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;semaphore&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std::literals;  <span class="hljs-comment">// 全局二元信号量实例</span><span class="hljs-comment">// 设置对象计数为零</span><span class="hljs-comment">// 对象在未被发信状态</span><span class="hljs-function">std::binary_semaphore <span class="hljs-title">smphSignal</span><span class="hljs-params">(<span class="hljs-number">0</span>)</span></span>; <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">ThreadProc</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>{    <span class="hljs-comment">// 通过尝试减少信号量的计数等待来自主程序的信号</span>    smphSignal.<span class="hljs-built_in">acquire</span>();     <span class="hljs-comment">// 此调用阻塞直至信号量的计数被从主程序增加</span>     std::cout &lt;&lt; <span class="hljs-string">"[thread] Got the signal"</span> &lt;&lt; std::endl; <span class="hljs-comment">// 回应消息</span>     <span class="hljs-comment">// 等待 3 秒以模仿某种线程正在进行的工作</span>    std::this_thread::<span class="hljs-built_in">sleep_for</span>(<span class="hljs-number">3</span>s);     std::cout &lt;&lt; <span class="hljs-string">"[thread] Send the signal\n"</span>; <span class="hljs-comment">// 消息</span>     <span class="hljs-comment">// 对主程序回复发信</span>    smphSignal.<span class="hljs-built_in">release</span>();} <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>{    <span class="hljs-comment">// 创建某个背景工作线程，它将长期存在</span>    <span class="hljs-function">std::jthread <span class="hljs-title">thrWorker</span><span class="hljs-params">(ThreadProc)</span></span>;     std::cout &lt;&lt; <span class="hljs-string">"[main] Send the signal\n"</span>; <span class="hljs-comment">// 消息</span>     <span class="hljs-comment">// 通过增加信号量的计数对工作线程发信以开始工作</span>    smphSignal.<span class="hljs-built_in">release</span>();     <span class="hljs-comment">// release() 后随 acquire() 可以阻止工作线程获取信号量，所以添加延迟：</span>    std::this_thread::<span class="hljs-built_in">sleep_for</span>(<span class="hljs-number">50</span>ms);     <span class="hljs-comment">// 通过试图减少信号量的计数等待直至工作线程完成工作</span>    smphSignal.<span class="hljs-built_in">acquire</span>();     std::cout &lt;&lt; <span class="hljs-string">"[main] Got the signal\n"</span>; <span class="hljs-comment">// 回应消息</span>}</code></pre></div><h4><span id="std-binary-semaphore">std::binary_semaphore</span><a href="#std-binary-semaphore" class="header-anchor">#</a></h4><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;thread&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;chrono&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;semaphore&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std::literals;  <span class="hljs-comment">// 全局二元信号量实例</span><span class="hljs-comment">// 设置对象计数为零</span><span class="hljs-comment">// 对象在未被发信状态</span><span class="hljs-function">std::binary_semaphore <span class="hljs-title">smphSignal</span><span class="hljs-params">(<span class="hljs-number">0</span>)</span></span>; <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">ThreadProc</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>{    <span class="hljs-comment">// 通过尝试减少信号量的计数等待来自主程序的信号</span>    smphSignal.<span class="hljs-built_in">acquire</span>();     <span class="hljs-comment">// 此调用阻塞直至信号量的计数被从主程序增加</span>     std::cout &lt;&lt; <span class="hljs-string">"[thread] Got the signal"</span> &lt;&lt; std::endl; <span class="hljs-comment">// 回应消息</span>     <span class="hljs-comment">// 等待 3 秒以模仿某种线程正在进行的工作</span>    std::this_thread::<span class="hljs-built_in">sleep_for</span>(<span class="hljs-number">3</span>s);     std::cout &lt;&lt; <span class="hljs-string">"[thread] Send the signal\n"</span>; <span class="hljs-comment">// 消息</span>     <span class="hljs-comment">// 对主程序回复发信</span>    smphSignal.<span class="hljs-built_in">release</span>();} <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>{    <span class="hljs-comment">// 创建某个背景工作线程，它将长期存在</span>    <span class="hljs-function">std::jthread <span class="hljs-title">thrWorker</span><span class="hljs-params">(ThreadProc)</span></span>;     std::cout &lt;&lt; <span class="hljs-string">"[main] Send the signal\n"</span>; <span class="hljs-comment">// 消息</span>     <span class="hljs-comment">// 通过增加信号量的计数对工作线程发信以开始工作</span>    smphSignal.<span class="hljs-built_in">release</span>();     <span class="hljs-comment">// release() 后随 acquire() 可以阻止工作线程获取信号量，所以添加延迟：</span>    std::this_thread::<span class="hljs-built_in">sleep_for</span>(<span class="hljs-number">50</span>ms);     <span class="hljs-comment">// 通过试图减少信号量的计数等待直至工作线程完成工作</span>    smphSignal.<span class="hljs-built_in">acquire</span>();     std::cout &lt;&lt; <span class="hljs-string">"[main] Got the signal\n"</span>; <span class="hljs-comment">// 回应消息</span>}</code></pre></div><h1><span id="future">Future</span><a href="#future" class="header-anchor">#</a></h1><blockquote><p>标准库提供了一些工具来获取异步任务（即在单独的线程中启动的函数）的返回值，并捕捉其所抛出的异常。这些值在<em>共享状态</em>中传递，其中异步任务可以写入其返回值或存储异常，而且可以由持有该引用该共享态的 <a href="https://zh.cppreference.com/w/cpp/thread/future">std::future</a> 或 <a href="https://zh.cppreference.com/w/cpp/thread/shared_future">std::shared_future</a> 实例的线程检验、等待或是操作这个状态。</p></blockquote><p>定义于头文件 <code>&lt;future&gt;</code></p><h2><span id="yi-bu-xian-cheng">异步线程</span><a href="#yi-bu-xian-cheng" class="header-anchor">#</a></h2><h3><span id="classes">Classes</span><a href="#classes" class="header-anchor">#</a></h3><h4><span id="cheng-nuo">承诺</span><a href="#cheng-nuo" class="header-anchor">#</a></h4><h4><span id="std-promise">std::promise</span><a href="#std-promise" class="header-anchor">#</a></h4><p><strong>允诺结果</strong></p><h5><span id="std-promise-lt-t-gt"><code>std::promise&lt;T&gt; </code></span><a href="#std-promise-lt-t-gt" class="header-anchor">#</a></h5><h6><span id="std-promise-lt-t-gt-set-value"><code>std::promise&lt;T&gt;::set_value()</code></span><a href="#std-promise-lt-t-gt-set-value" class="header-anchor">#</a></h6><h6><span id="std-promise-lt-t-gt-get-future"><code>std::promise&lt;T&gt;::get_future()</code></span><a href="#std-promise-lt-t-gt-get-future" class="header-anchor">#</a></h6><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;thread&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;future&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;numeric&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;chrono&gt;</span></span> <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">accumulate</span><span class="hljs-params">(std::vector&lt;<span class="hljs-type">int</span>&gt;::iterator first,</span></span><span class="hljs-params"><span class="hljs-function">                std::vector&lt;<span class="hljs-type">int</span>&gt;::iterator last,</span></span><span class="hljs-params"><span class="hljs-function">                std::promise&lt;<span class="hljs-type">int</span>&gt; accumulate_promise)</span></span><span class="hljs-function"></span>{    <span class="hljs-type">int</span> sum = std::<span class="hljs-built_in">accumulate</span>(first, last, <span class="hljs-number">0</span>);    accumulate_promise.<span class="hljs-built_in">set_value</span>(sum);  <span class="hljs-comment">// Notify future</span>} <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">do_work</span><span class="hljs-params">(std::promise&lt;<span class="hljs-type">void</span>&gt; barrier)</span></span><span class="hljs-function"></span>{    std::this_thread::<span class="hljs-built_in">sleep_for</span>(std::chrono::<span class="hljs-built_in">seconds</span>(<span class="hljs-number">1</span>));    barrier.<span class="hljs-built_in">set_value</span>();} <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>{    <span class="hljs-comment">// Demonstrate using promise&lt;int&gt; to transmit a result between threads.</span>    std::vector&lt;<span class="hljs-type">int</span>&gt; numbers = { <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span> };    std::promise&lt;<span class="hljs-type">int</span>&gt; accumulate_promise;    std::future&lt;<span class="hljs-type">int</span>&gt; accumulate_future = accumulate_promise.<span class="hljs-built_in">get_future</span>();    <span class="hljs-function">std::thread <span class="hljs-title">work_thread</span><span class="hljs-params">(accumulate, numbers.begin(), numbers.end(),</span></span><span class="hljs-params"><span class="hljs-function">                            std::move(accumulate_promise))</span></span>;    accumulate_future.<span class="hljs-built_in">wait</span>();  <span class="hljs-comment">// wait for result</span>    std::cout &lt;&lt; <span class="hljs-string">"result="</span> &lt;&lt; accumulate_future.<span class="hljs-built_in">get</span>() &lt;&lt; <span class="hljs-string">'\n'</span>;    work_thread.<span class="hljs-built_in">join</span>();  <span class="hljs-comment">// wait for thread completion</span>    <span class="hljs-comment">// Demonstrate using promise&lt;void&gt; to signal state between threads.</span>    std::promise&lt;<span class="hljs-type">void</span>&gt; barrier;    std::future&lt;<span class="hljs-type">void</span>&gt; barrier_future = barrier.<span class="hljs-built_in">get_future</span>();    <span class="hljs-function">std::thread <span class="hljs-title">new_work_thread</span><span class="hljs-params">(do_work, std::move(barrier))</span></span>;    barrier_future.<span class="hljs-built_in">wait</span>();    new_work_thread.<span class="hljs-built_in">join</span>();}</code></pre></div><h4><span id="std-packaged-task">std::packaged_task</span><a href="#std-packaged-task" class="header-anchor">#</a></h4><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">template</span>&lt; <span class="hljs-keyword">class</span> <span class="hljs-title class_">R</span>, <span class="hljs-keyword">class</span> ...Args &gt; <span class="hljs-keyword">class</span> <span class="hljs-title class_">packaged_task</span>&lt;<span class="hljs-built_in">R</span>(Args...)&gt;;</code></pre></div><h5><span id="std-packaged-task-lt-r-args-gt-get-future"><code>std::packaged_task&lt;R(Args...)&gt;::get_future</code></span><a href="#std-packaged-task-lt-r-args-gt-get-future" class="header-anchor">#</a></h5><h5><span id="std-packaged-task-lt-r-args-gt-reset"><code>std::packaged_task&lt;R(Args...)&gt;::reset</code></span><a href="#std-packaged-task-lt-r-args-gt-reset" class="header-anchor">#</a></h5><blockquote><p>类模板包装任何可调用目标（函数、lambda 表达式、绑定表达式或其他函数对象），以便可以异步调用它。其返回值或引发的异常存储在可通过对象访问的共享状态中。</p></blockquote><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cmath&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;thread&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;future&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;functional&gt;</span></span> <span class="hljs-comment">// unique function to avoid disambiguating the std::pow overload set</span><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">f</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y)</span> </span>{ <span class="hljs-keyword">return</span> std::<span class="hljs-built_in">pow</span>(x,y); } <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">task_lambda</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>{    <span class="hljs-function">std::packaged_task&lt;<span class="hljs-title">int</span><span class="hljs-params">(<span class="hljs-type">int</span>,<span class="hljs-type">int</span>)</span>&gt; <span class="hljs-title">task</span><span class="hljs-params">([](<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b) {</span></span><span class="hljs-params"><span class="hljs-function">        <span class="hljs-keyword">return</span> std::pow(a, b); </span></span><span class="hljs-params"><span class="hljs-function">    })</span></span>;    std::future&lt;<span class="hljs-type">int</span>&gt; result = task.<span class="hljs-built_in">get_future</span>();     <span class="hljs-built_in">task</span>(<span class="hljs-number">2</span>, <span class="hljs-number">9</span>);     std::cout &lt;&lt; <span class="hljs-string">"task_lambda:\t"</span> &lt;&lt; result.<span class="hljs-built_in">get</span>() &lt;&lt; <span class="hljs-string">'\n'</span>;} <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">task_bind</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>{    <span class="hljs-function">std::packaged_task&lt;<span class="hljs-title">int</span><span class="hljs-params">()</span>&gt; <span class="hljs-title">task</span><span class="hljs-params">(std::bind(f, <span class="hljs-number">2</span>, <span class="hljs-number">11</span>))</span></span>;    std::future&lt;<span class="hljs-type">int</span>&gt; result = task.<span class="hljs-built_in">get_future</span>();     <span class="hljs-built_in">task</span>();     std::cout &lt;&lt; <span class="hljs-string">"task_bind:\t"</span> &lt;&lt; result.<span class="hljs-built_in">get</span>() &lt;&lt; <span class="hljs-string">'\n'</span>;} <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">task_thread</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>{    <span class="hljs-function">std::packaged_task&lt;<span class="hljs-title">int</span><span class="hljs-params">(<span class="hljs-type">int</span>,<span class="hljs-type">int</span>)</span>&gt; <span class="hljs-title">task</span><span class="hljs-params">(f)</span></span>;    std::future&lt;<span class="hljs-type">int</span>&gt; result = task.<span class="hljs-built_in">get_future</span>();     <span class="hljs-function">std::thread <span class="hljs-title">task_td</span><span class="hljs-params">(std::move(task), <span class="hljs-number">2</span>, <span class="hljs-number">10</span>)</span></span>;    task_td.<span class="hljs-built_in">join</span>();     std::cout &lt;&lt; <span class="hljs-string">"task_thread:\t"</span> &lt;&lt; result.<span class="hljs-built_in">get</span>() &lt;&lt; <span class="hljs-string">'\n'</span>;} <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>{    <span class="hljs-built_in">task_lambda</span>();    <span class="hljs-built_in">task_bind</span>();    <span class="hljs-built_in">task_thread</span>();}</code></pre></div><h4><span id="wei-lai">未来</span><a href="#wei-lai" class="header-anchor">#</a></h4><h4><span id="std-future">std::future</span><a href="#std-future" class="header-anchor">#</a></h4><p><strong>等待一个值</strong></p><h5><span id="std-future-lt-t-amp-gt"><code>std::future&lt;T&amp;&gt;</code></span><a href="#std-future-lt-t-amp-gt" class="header-anchor">#</a></h5><h6><span id="std-future-lt-t-amp-gt-get"><code>std::future&lt;T&amp;&gt;::get()</code></span><a href="#std-future-lt-t-amp-gt-get" class="header-anchor">#</a></h6><h6><span id="std-future-lt-t-amp-gt-wait"><code>std::future&lt;T&amp;&gt;::wait()</code></span><a href="#std-future-lt-t-amp-gt-wait" class="header-anchor">#</a></h6><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;future&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;thread&gt;</span></span> <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>{    <span class="hljs-comment">// future from a packaged_task</span>    <span class="hljs-function">std::packaged_task&lt;<span class="hljs-title">int</span><span class="hljs-params">()</span>&gt; <span class="hljs-title">task</span><span class="hljs-params">([]{ <span class="hljs-keyword">return</span> <span class="hljs-number">7</span>; })</span></span>; <span class="hljs-comment">// wrap the function</span>    std::future&lt;<span class="hljs-type">int</span>&gt; f1 = task.<span class="hljs-built_in">get_future</span>();  <span class="hljs-comment">// get a future</span>    <span class="hljs-function">std::thread <span class="hljs-title">t</span><span class="hljs-params">(std::move(task))</span></span>; <span class="hljs-comment">// launch on a thread</span>     <span class="hljs-comment">// future from an async()</span>    std::future&lt;<span class="hljs-type">int</span>&gt; f2 = std::<span class="hljs-built_in">async</span>(std::launch::async, []{ <span class="hljs-keyword">return</span> <span class="hljs-number">8</span>; });     <span class="hljs-comment">// future from a promise</span>    std::promise&lt;<span class="hljs-type">int</span>&gt; p;    std::future&lt;<span class="hljs-type">int</span>&gt; f3 = p.<span class="hljs-built_in">get_future</span>();    std::<span class="hljs-built_in">thread</span>( [&amp;p]{ p.<span class="hljs-built_in">set_value_at_thread_exit</span>(<span class="hljs-number">9</span>); }).<span class="hljs-built_in">detach</span>();     std::cout &lt;&lt; <span class="hljs-string">"Waiting..."</span> &lt;&lt; std::flush;    f1.<span class="hljs-built_in">wait</span>();    f2.<span class="hljs-built_in">wait</span>();    f3.<span class="hljs-built_in">wait</span>();    std::cout &lt;&lt; <span class="hljs-string">"Done!\nResults are: "</span>              &lt;&lt; f1.<span class="hljs-built_in">get</span>() &lt;&lt; <span class="hljs-string">' '</span> &lt;&lt; f2.<span class="hljs-built_in">get</span>() &lt;&lt; <span class="hljs-string">' '</span> &lt;&lt; f3.<span class="hljs-built_in">get</span>() &lt;&lt; <span class="hljs-string">'\n'</span>;    t.<span class="hljs-built_in">join</span>();}</code></pre></div><h4><span id="std-future-error">std::future_error</span><a href="#std-future-error" class="header-anchor">#</a></h4><p><strong>返回错误代码，和 返回特定于错误代码<br>的解释性字符串</strong> </p><h6><span id="std-future-error-code"><code>std::future_error::code()</code></span><a href="#std-future-error-code" class="header-anchor">#</a></h6><h6><span id="std-future-error-what"><code>std::future_error::what()</code></span><a href="#std-future-error-what" class="header-anchor">#</a></h6><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;future&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span> <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>{    std::future&lt;<span class="hljs-type">int</span>&gt; empty;    <span class="hljs-keyword">try</span> {        <span class="hljs-type">int</span> n = empty.<span class="hljs-built_in">get</span>(); <span class="hljs-comment">// The behavior is undefined, but</span>                             <span class="hljs-comment">// some implementations throw std::future_error</span>    } <span class="hljs-built_in">catch</span> (<span class="hljs-type">const</span> std::future_error&amp; e) {        std::cout &lt;&lt; <span class="hljs-string">"Caught a future_error with code \""</span> &lt;&lt; e.<span class="hljs-built_in">code</span>()                  &lt;&lt; <span class="hljs-string">"\"\nMessage: \""</span> &lt;&lt; e.<span class="hljs-built_in">what</span>() &lt;&lt; <span class="hljs-string">"\"\n"</span>;    }}</code></pre></div><h4><span id="std-shared-future">std::shared_future</span><a href="#std-shared-future" class="header-anchor">#</a></h4><p><strong>等待一个值 (possibly referenced by other futures）</strong></p><h5><span id="std-shared-future-lt-t-amp-gt"><code>std::shared_future&lt;T&amp;&gt;</code></span><a href="#std-shared-future-lt-t-amp-gt" class="header-anchor">#</a></h5><h6><span id="std-shared-future-get"><code>std::shared_future::get()</code></span><a href="#std-shared-future-get" class="header-anchor">#</a></h6><h6><span id="std-shared-future-wait"><code>std::shared_future::wait()</code></span><a href="#std-shared-future-wait" class="header-anchor">#</a></h6><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;future&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;chrono&gt;</span></span> <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>{       std::promise&lt;<span class="hljs-type">void</span>&gt; ready_promise, t1_ready_promise, t2_ready_promise;    <span class="hljs-function">std::shared_future&lt;<span class="hljs-type">void</span>&gt; <span class="hljs-title">ready_future</span><span class="hljs-params">(ready_promise.get_future())</span></span>;     std::chrono::time_point&lt;std::chrono::high_resolution_clock&gt; start;     <span class="hljs-keyword">auto</span> fun1 = [&amp;, ready_future]() -&gt; std::chrono::duration&lt;<span class="hljs-type">double</span>, std::milli&gt;     {        t1_ready_promise.<span class="hljs-built_in">set_value</span>();        ready_future.<span class="hljs-built_in">wait</span>(); <span class="hljs-comment">// waits for the signal from main()</span>        <span class="hljs-keyword">return</span> std::chrono::high_resolution_clock::<span class="hljs-built_in">now</span>() - start;    };      <span class="hljs-keyword">auto</span> fun2 = [&amp;, ready_future]() -&gt; std::chrono::duration&lt;<span class="hljs-type">double</span>, std::milli&gt;     {        t2_ready_promise.<span class="hljs-built_in">set_value</span>();        ready_future.<span class="hljs-built_in">wait</span>(); <span class="hljs-comment">// waits for the signal from main()</span>        <span class="hljs-keyword">return</span> std::chrono::high_resolution_clock::<span class="hljs-built_in">now</span>() - start;    };     <span class="hljs-keyword">auto</span> fut1 = t1_ready_promise.<span class="hljs-built_in">get_future</span>();    <span class="hljs-keyword">auto</span> fut2 = t2_ready_promise.<span class="hljs-built_in">get_future</span>();     <span class="hljs-keyword">auto</span> result1 = std::<span class="hljs-built_in">async</span>(std::launch::async, fun1);    <span class="hljs-keyword">auto</span> result2 = std::<span class="hljs-built_in">async</span>(std::launch::async, fun2);     <span class="hljs-comment">// wait for the threads to become ready</span>    fut1.<span class="hljs-built_in">wait</span>();    fut2.<span class="hljs-built_in">wait</span>();     <span class="hljs-comment">// the threads are ready, start the clock</span>    start = std::chrono::high_resolution_clock::<span class="hljs-built_in">now</span>();     <span class="hljs-comment">// signal the threads to go</span>    ready_promise.<span class="hljs-built_in">set_value</span>();     std::cout &lt;&lt; <span class="hljs-string">"Thread 1 received the signal "</span>              &lt;&lt; result1.<span class="hljs-built_in">get</span>().<span class="hljs-built_in">count</span>() &lt;&lt; <span class="hljs-string">" ms after start\n"</span>              &lt;&lt; <span class="hljs-string">"Thread 2 received the signal "</span>              &lt;&lt; result2.<span class="hljs-built_in">get</span>().<span class="hljs-built_in">count</span>() &lt;&lt; <span class="hljs-string">" ms after start\n"</span>;}</code></pre></div><h3><span id="functions">Functions</span><a href="#functions" class="header-anchor">#</a></h3><h4><span id="yi-bu">异步</span><a href="#yi-bu" class="header-anchor">#</a></h4><h4><span id="std-async">std::async</span><a href="#std-async" class="header-anchor">#</a></h4><h5><span id="async-function-amp-amp-f-args-amp-amp-args"><code>async( Function&amp;&amp; f, Args&amp;&amp;... args )</code></span><a href="#async-function-amp-amp-f-args-amp-amp-args" class="header-anchor">#</a></h5><h5><span id="async-std-launch-policy-function-amp-amp-f-args-amp-amp-args"><code>async( std::launch policy, Function&amp;&amp; f, Args&amp;&amp;... args );</code></span><a href="#async-std-launch-policy-function-amp-amp-f-args-amp-amp-args" class="header-anchor">#</a></h5><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;numeric&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;future&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;mutex&gt;</span></span> std::mutex m;<span class="hljs-keyword">struct</span> <span class="hljs-title class_">X</span> {    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">foo</span><span class="hljs-params">(<span class="hljs-type">int</span> i, <span class="hljs-type">const</span> std::string&amp; str)</span> </span>{        <span class="hljs-function">std::lock_guard&lt;std::mutex&gt; <span class="hljs-title">lk</span><span class="hljs-params">(m)</span></span>;        std::cout &lt;&lt; str &lt;&lt; <span class="hljs-string">' '</span> &lt;&lt; i &lt;&lt; <span class="hljs-string">'\n'</span>;    }    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">bar</span><span class="hljs-params">(<span class="hljs-type">const</span> std::string&amp; str)</span> </span>{        <span class="hljs-function">std::lock_guard&lt;std::mutex&gt; <span class="hljs-title">lk</span><span class="hljs-params">(m)</span></span>;        std::cout &lt;&lt; str &lt;&lt; <span class="hljs-string">'\n'</span>;    }    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">operator</span><span class="hljs-params">()</span><span class="hljs-params">(<span class="hljs-type">int</span> i)</span> </span>{        <span class="hljs-function">std::lock_guard&lt;std::mutex&gt; <span class="hljs-title">lk</span><span class="hljs-params">(m)</span></span>;        std::cout &lt;&lt; i &lt;&lt; <span class="hljs-string">'\n'</span>;        <span class="hljs-keyword">return</span> i + <span class="hljs-number">10</span>;    }}; <span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> RandomIt&gt;<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">parallel_sum</span><span class="hljs-params">(RandomIt beg, RandomIt end)</span></span><span class="hljs-function"></span>{    <span class="hljs-keyword">auto</span> len = end - beg;    <span class="hljs-keyword">if</span> (len &lt; <span class="hljs-number">1000</span>)        <span class="hljs-keyword">return</span> std::<span class="hljs-built_in">accumulate</span>(beg, end, <span class="hljs-number">0</span>);     RandomIt mid = beg + len/<span class="hljs-number">2</span>;    <span class="hljs-keyword">auto</span> handle = std::<span class="hljs-built_in">async</span>(std::launch::async,                             parallel_sum&lt;RandomIt&gt;, mid, end);    <span class="hljs-type">int</span> sum = <span class="hljs-built_in">parallel_sum</span>(beg, mid);    <span class="hljs-keyword">return</span> sum + handle.<span class="hljs-built_in">get</span>();} <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>{    <span class="hljs-function">std::vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">v</span><span class="hljs-params">(<span class="hljs-number">10000</span>, <span class="hljs-number">1</span>)</span></span>;    std::cout &lt;&lt; <span class="hljs-string">"The sum is "</span> &lt;&lt; <span class="hljs-built_in">parallel_sum</span>(v.<span class="hljs-built_in">begin</span>(), v.<span class="hljs-built_in">end</span>()) &lt;&lt; <span class="hljs-string">'\n'</span>;     X x;    <span class="hljs-comment">// Calls (&amp;x)-&gt;foo(42, "Hello") with default policy:</span>    <span class="hljs-comment">// may print "Hello 42" concurrently or defer execution</span>    <span class="hljs-keyword">auto</span> a1 = std::<span class="hljs-built_in">async</span>(&amp;X::foo, &amp;x, <span class="hljs-number">42</span>, <span class="hljs-string">"Hello"</span>);        <span class="hljs-comment">// Calls x.bar("world!") with deferred policy</span>    <span class="hljs-comment">// prints "world!" when a2.get() or a2.wait() is called</span>    <span class="hljs-keyword">auto</span> a2 = std::<span class="hljs-built_in">async</span>(std::launch::deferred, &amp;X::bar, x, <span class="hljs-string">"world!"</span>);        <span class="hljs-comment">// Calls X()(43); with async policy</span>    <span class="hljs-comment">// prints "43" concurrently</span>    <span class="hljs-keyword">auto</span> a3 = std::<span class="hljs-built_in">async</span>(std::launch::async, <span class="hljs-built_in">X</span>(), <span class="hljs-number">43</span>);    a2.<span class="hljs-built_in">wait</span>();                     <span class="hljs-comment">// prints "world!"</span>    std::cout &lt;&lt; a3.<span class="hljs-built_in">get</span>() &lt;&lt; <span class="hljs-string">'\n'</span>; <span class="hljs-comment">// prints "53"</span>} <span class="hljs-comment">// if a1 is not done at this point, destructor of a1 prints "Hello 42" here</span></code></pre></div><p><strong>可能的结果：</strong></p><p>上边程序打印顺序不确定，</p><div class="code-wrapper"><pre><code class="hljs bash">The <span class="hljs-built_in">sum</span> is 1000043world!53Hello 42</code></pre></div>]]></content>
    
    
    
    <tags>
      
      <tag>C++</tag>
      
      <tag>Thread</tag>
      
      <tag>Mutex</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C++关键词</title>
    <link href="/2022/01/15/C++%E5%85%B3%E9%94%AE%E8%AF%8D/"/>
    <url>/2022/01/15/C++%E5%85%B3%E9%94%AE%E8%AF%8D/</url>
    
    <content type="html"><![CDATA[<div class="toc"><!-- toc --><ul><li><a href="#c-guan-jian-ci"><strong>C++关键词</strong>：</a></li></ul><!-- tocstop --></div><p>此文章来自👉<a href="https://zh.cppreference.com/w/%E9%A6%96%E9%A1%B5">C++ 参考手册</a></p><h1><span id="c-guan-jian-ci"><strong>C++关键词</strong>：</span><a href="#c-guan-jian-ci" class="header-anchor">#</a></h1><table><thead><tr><th align="left"><a href="https://zh.cppreference.com/w/cpp/language/alignas"><code>alignas</code></a> (C++11 起)</th><th align="left"><a href="https://zh.cppreference.com/w/cpp/language/default_comparisons"><code>default</code></a>(1)</th><th align="left"><a href="https://zh.cppreference.com/w/cpp/language/storage_duration"><code>register(C++17弃用)</code></a>(2)</th></tr></thead><tbody><tr><td align="left"><a href="https://zh.cppreference.com/w/cpp/language/alignof"><code>alignof</code></a> (C++11 起)</td><td align="left"><a href="https://zh.cppreference.com/w/cpp/keyword/delete"><code>delete</code></a>(1)</td><td align="left"><a href="https://zh.cppreference.com/w/cpp/language/reinterpret_cast"><code>reinterpret_cast</code></a></td></tr><tr><td align="left"><a href="https://zh.cppreference.com/w/cpp/keyword/and"><code>and</code></a></td><td align="left"><a href="https://zh.cppreference.com/w/cpp/language/do"><code>do</code></a></td><td align="left"><a href="https://zh.cppreference.com/w/cpp/experimental/constraints"><code>requires</code></a> (C++20 起)</td></tr><tr><td align="left"><a href="https://zh.cppreference.com/w/cpp/keyword/and_eq"><code>and_eq</code></a></td><td align="left"><a href="https://zh.cppreference.com/w/cpp/language/types"><code>double</code></a></td><td align="left"><a href="https://zh.cppreference.com/w/cpp/language/return"><code>return</code></a></td></tr><tr><td align="left"><a href="https://zh.cppreference.com/w/cpp/language/asm"><code>asm</code></a></td><td align="left"><a href="https://zh.cppreference.com/w/cpp/language/dynamic_cast"><code>dynamic_cast</code></a></td><td align="left"><a href="https://zh.cppreference.com/w/cpp/language/types"><code>short</code></a></td></tr><tr><td align="left"><a href="https://zh.cppreference.com/w/cpp/language/transactional_memory"><code>atomic_cancel</code></a> (TM TS)</td><td align="left"><a href="https://zh.cppreference.com/w/cpp/language/if"><code>else</code></a></td><td align="left"><a href="https://zh.cppreference.com/w/cpp/language/types"><code>signed</code></a></td></tr><tr><td align="left"><a href="https://zh.cppreference.com/w/cpp/language/transactional_memory"><code>atomic_commit</code></a> (TM TS)</td><td align="left"><a href="https://zh.cppreference.com/w/cpp/language/enum"><code>enum</code></a></td><td align="left"><a href="https://zh.cppreference.com/w/cpp/language/sizeof..."><code>sizeof</code></a>(1)</td></tr><tr><td align="left"><a href="https://zh.cppreference.com/w/cpp/language/transactional_memory"><code>atomic_noexcept</code></a> (TM TS)</td><td align="left"><a href="https://zh.cppreference.com/w/cpp/language/explicit"><code>explicit</code></a></td><td align="left"><a href="https://zh.cppreference.com/w/cpp/language/storage_duration"><code>static</code></a></td></tr><tr><td align="left"><a href="https://zh.cppreference.com/w/cpp/language/auto"><code>auto</code></a>(1)</td><td align="left"><a href="https://zh.cppreference.com/w/cpp/language/class_template"><code>export</code></a>(1)(3)</td><td align="left"><a href="https://zh.cppreference.com/w/cpp/language/static_assert"><code>static_assert</code></a> (C++11 起)</td></tr><tr><td align="left"><a href="https://zh.cppreference.com/w/cpp/keyword/bitand"><code>bitand</code></a></td><td align="left"><a href="https://zh.cppreference.com/w/cpp/language/storage_duration"><code>extern</code></a>(1)</td><td align="left"><a href="https://zh.cppreference.com/w/cpp/language/static_cast"><code>static_cast</code></a></td></tr><tr><td align="left"><a href="https://zh.cppreference.com/w/cpp/keyword/bitor"><code>bitor</code></a></td><td align="left"><a href="https://zh.cppreference.com/w/cpp/language/bool_literal"><code>false</code></a></td><td align="left"><a href="https://zh.cppreference.com/w/cpp/language/class"><code>struct</code></a>(1)</td></tr><tr><td align="left"><a href="https://zh.cppreference.com/w/cpp/language/types"><code>bool</code></a></td><td align="left"><a href="https://zh.cppreference.com/w/cpp/language/types"><code>float</code></a></td><td align="left"><a href="https://zh.cppreference.com/w/cpp/language/switch"><code>switch</code></a></td></tr><tr><td align="left"><a href="https://zh.cppreference.com/w/cpp/language/break"><code>break</code></a></td><td align="left"><a href="https://zh.cppreference.com/w/cpp/language/range-for"><code>for</code></a></td><td align="left"><a href="https://zh.cppreference.com/w/cpp/language/transactional_memory"><code>synchronized</code></a> (TM TS)</td></tr><tr><td align="left"><a href="https://zh.cppreference.com/w/cpp/language/switch"><code>case</code></a></td><td align="left"><a href="https://zh.cppreference.com/w/cpp/language/friend"><code>friend</code></a></td><td align="left"><a href="https://zh.cppreference.com/w/cpp/language/templates"><code>template</code></a></td></tr><tr><td align="left"><a href="https://zh.cppreference.com/w/cpp/language/try_catch"><code>catch</code></a></td><td align="left"><a href="https://zh.cppreference.com/w/cpp/language/goto"><code>goto</code></a></td><td align="left"><a href="https://zh.cppreference.com/w/cpp/language/this"><code>this</code></a></td></tr><tr><td align="left"><a href="https://zh.cppreference.com/w/cpp/language/types"><code>char</code></a></td><td align="left"><a href="https://zh.cppreference.com/w/cpp/language/if"><code>if</code></a></td><td align="left"><a href="https://zh.cppreference.com/w/cpp/language/storage_duration"><code>thread_local</code></a> (C++11 起)</td></tr><tr><td align="left"><a href="https://zh.cppreference.com/w/cpp/language/types"><code>char8_t</code></a> (C++20 起)</td><td align="left"><a href="https://zh.cppreference.com/w/cpp/language/inline"><code>inline</code></a>(1)</td><td align="left"><a href="https://zh.cppreference.com/w/cpp/language/except_spec"><code>throw(C++17中移除)</code></a></td></tr><tr><td align="left"><a href="https://zh.cppreference.com/w/cpp/language/types"><code>char16_t</code></a> (C++11 起)</td><td align="left"><a href="https://zh.cppreference.com/w/cpp/language/types"><code>int</code></a></td><td align="left"><a href="https://zh.cppreference.com/w/cpp/language/bool_literal"><code>true</code></a></td></tr><tr><td align="left"><a href="https://zh.cppreference.com/w/cpp/language/types"><code>char32_t</code></a> (C++11 起)</td><td align="left"><a href="https://zh.cppreference.com/w/cpp/language/types"><code>long</code></a></td><td align="left"><a href="https://zh.cppreference.com/w/cpp/language/try_catch"><code>try</code></a></td></tr><tr><td align="left"><a href="https://zh.cppreference.com/w/cpp/keyword/class"><code>class</code></a>(1)</td><td align="left"><a href="https://zh.cppreference.com/w/cpp/language/cv"><code>mutable</code></a>(1)</td><td align="left"><a href="https://zh.cppreference.com/w/cpp/language/typedef"><code>typedef</code></a></td></tr><tr><td align="left"><a href="https://zh.cppreference.com/w/cpp/language/operator_alternative"><code>compl</code></a></td><td align="left"><a href="https://zh.cppreference.com/w/cpp/keyword/namespace"><code>namespace</code></a></td><td align="left"><a href="https://zh.cppreference.com/w/cpp/language/typeid"><code>typeid</code></a></td></tr><tr><td align="left"><a href="https://zh.cppreference.com/w/cpp/language/constraints"><code>concept</code></a> (C++20 起)</td><td align="left"><a href="https://zh.cppreference.com/w/cpp/language/new"><code>new</code></a></td><td align="left"><a href="https://zh.cppreference.com/w/cpp/language/template_parameters#.E7.B1.BB.E5.9E.8B.E6.A8.A1.E6.9D.BF.E5.BD.A2.E5.8F.82"><code>typename</code></a></td></tr><tr><td align="left"><a href="https://zh.cppreference.com/w/cpp/language/cv"><code>const</code></a></td><td align="left"><a href="https://zh.cppreference.com/w/cpp/language/noexcept"><code>noexcept</code></a> (C++11 起)</td><td align="left"><a href="https://zh.cppreference.com/w/cpp/language/union"><code>union</code></a></td></tr><tr><td align="left"><a href="https://zh.cppreference.com/w/cpp/language/consteval"><code>consteval</code></a> (C++20 起)</td><td align="left"><a href="https://zh.cppreference.com/w/cpp/keyword/not"><code>not</code></a></td><td align="left"><a href="https://zh.cppreference.com/w/cpp/language/types"><code>unsigned</code></a></td></tr><tr><td align="left"><a href="https://zh.cppreference.com/w/cpp/language/constexpr"><code>constexpr</code></a> (C++11 起)</td><td align="left"><a href="https://zh.cppreference.com/w/cpp/keyword/not_eq"><code>not_eq</code></a></td><td align="left"><a href="https://zh.cppreference.com/w/cpp/language/using_declaration"><code>using</code></a>(1)</td></tr><tr><td align="left"><a href="https://zh.cppreference.com/w/cpp/language/constinit"><code>constinit</code></a> (C++20 起)</td><td align="left"><a href="https://zh.cppreference.com/w/cpp/language/nullptr"><code>nullptr</code></a> (C++11 起)</td><td align="left"><a href="https://zh.cppreference.com/w/cpp/language/virtual"><code>virtual</code></a></td></tr><tr><td align="left"><a href="https://zh.cppreference.com/w/cpp/language/const_cast"><code>const_cast</code></a></td><td align="left"><a href="https://zh.cppreference.com/w/cpp/language/operators"><code>operator</code></a></td><td align="left"><a href="https://zh.cppreference.com/w/cpp/language/types#void_.E7.B1.BB.E5.9E.8B"><code>void</code></a></td></tr><tr><td align="left"><a href="https://zh.cppreference.com/w/cpp/language/continue"><code>continue</code></a></td><td align="left"><a href="https://zh.cppreference.com/w/cpp/keyword/or"><code>or</code></a></td><td align="left"><a href="https://zh.cppreference.com/w/cpp/language/cv"><code>volatile</code></a></td></tr><tr><td align="left"><a href="https://zh.cppreference.com/w/cpp/language/coroutines"><code>co_await</code></a> (C++20 起)</td><td align="left"><a href="https://zh.cppreference.com/w/cpp/keyword/or_eq"><code>or_eq</code></a></td><td align="left"><a href="https://zh.cppreference.com/w/cpp/language/types"><code>wchar_t</code></a></td></tr><tr><td align="left"><a href="https://zh.cppreference.com/w/cpp/language/coroutines"><code>co_return</code></a> (C++20 起)</td><td align="left"><a href="https://zh.cppreference.com/w/cpp/language/access"><code>private</code></a></td><td align="left"><a href="https://zh.cppreference.com/w/cpp/language/while"><code>while</code></a></td></tr><tr><td align="left"><a href="https://zh.cppreference.com/w/cpp/language/coroutines"><code>co_yield</code></a> (C++20 起)</td><td align="left"><a href="https://zh.cppreference.com/w/cpp/language/access"><code>protected</code></a></td><td align="left"><a href="https://zh.cppreference.com/w/cpp/keyword/xor"><code>xor</code></a></td></tr><tr><td align="left"><a href="https://zh.cppreference.com/w/cpp/language/auto"><code>decltype</code></a> (C++11 起)</td><td align="left"><a href="https://zh.cppreference.com/w/cpp/language/access"><code>public</code></a></td><td align="left"><a href="https://zh.cppreference.com/w/cpp/keyword/xor_eq"><code>xor_eq</code></a></td></tr><tr><td align="left"></td><td align="left"><a href="https://zh.cppreference.com/mwiki/index.php?title=cpp/keyword/reflexpr&amp;action=edit&amp;redlink=1"><code>reflexpr</code></a> (反射 TS)</td><td align="left"></td></tr></tbody></table><table><thead><tr><th align="left"><a href="https://zh.cppreference.com/w/cpp/language/override"><code>override</code></a> (C++11)</th></tr></thead><tbody><tr><td align="left"><a href="https://zh.cppreference.com/w/cpp/language/final"><code>final</code></a> (C++11)</td></tr><tr><td align="left"><a href="https://zh.cppreference.com/w/cpp/keyword/import"><code>import</code></a> (C++20)</td></tr><tr><td align="left"><a href="https://zh.cppreference.com/mwiki/index.php?title=cpp/keyword/module&amp;action=edit&amp;redlink=1"><code>module</code></a> (C++20)</td></tr><tr><td align="left"><a href="https://zh.cppreference.com/w/cpp/language/transactional_memory"><code>transaction_safe</code></a> (TM TS)</td></tr><tr><td align="left"><a href="https://zh.cppreference.com/w/cpp/language/transactional_memory"><code>transaction_safe_dynamic</code></a> (TM TS)</td></tr></tbody></table>]]></content>
    
    
    
    <tags>
      
      <tag>C++关键词</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>cpr请求库</title>
    <link href="/2022/01/13/cpr%20HTTP%E8%AF%B7%E6%B1%82%E5%BA%93/"/>
    <url>/2022/01/13/cpr%20HTTP%E8%AF%B7%E6%B1%82%E5%BA%93/</url>
    
    <content type="html"><![CDATA[<div class="toc"><!-- toc --><ul><li><a href="#httpserver"><strong>HttpServer</strong></a><ul><li><a href="#url">Url</a></li><li><a href="#get">Get</a></li><li><a href="#cpr-post">cpr::Post</a></li><li><a href="#std-string-expected-text"><strong>std</strong>::<strong>string</strong> expected_text{“”};</a></li><li><a href="#expect-eq">EXPECT_EQ()</a></li></ul></li></ul><!-- tocstop --></div><p>本文介绍的HTTP库👉<a href="https://github.com/libcpr/cpr">libcpr/cpr: C++ Requests: Curl for People, a spiritual port of Python Requests. (github.com)</a></p><h2><span id="httpserver"><strong>HttpServer</strong></span><a href="#httpserver" class="header-anchor">#</a></h2><h3><span id="url">Url</span><a href="#url" class="header-anchor">#</a></h3><div class="code-wrapper"><pre><code class="hljs c++">Url url{server-&gt;<span class="hljs-built_in">GetBaseUrl</span>() + <span class="hljs-string">"/hello.html"</span>};Url url{server-&gt;<span class="hljs-built_in">GetBaseUrl</span>() + <span class="hljs-string">"/basic.json"</span>};Url url{server-&gt;<span class="hljs-built_in">GetBaseUrl</span>() + <span class="hljs-string">"/error.html"</span>};Url url{<span class="hljs-string">"http://bad_host/"</span>};Url url{server-&gt;<span class="hljs-built_in">GetBaseUrl</span>() + <span class="hljs-string">"/basic_cookies.html"</span>};Url url{server-&gt;<span class="hljs-built_in">GetBaseUrl</span>() + <span class="hljs-string">"/empty_cookies.html"</span>};Url url{server-&gt;<span class="hljs-built_in">GetBaseUrl</span>() + <span class="hljs-string">"/check_cookies.html"</span>};Url url{server-&gt;<span class="hljs-built_in">GetBaseUrl</span>() + <span class="hljs-string">"/v1_cookies.html"</span>};Url url{server-&gt;<span class="hljs-built_in">GetBaseUrl</span>() + <span class="hljs-string">"/check_v1_cookies.html"</span>};Url url{server-&gt;<span class="hljs-built_in">GetBaseUrl</span>() + <span class="hljs-string">"/basic_auth.html"</span>};Url url{server-&gt;<span class="hljs-built_in">GetBaseUrl</span>() + <span class="hljs-string">"/bearer_token.html"</span>};Url url{server-&gt;<span class="hljs-built_in">GetBaseUrl</span>() + <span class="hljs-string">"/digest_auth.html"</span>};Url url{server-&gt;<span class="hljs-built_in">GetBaseUrl</span>() + <span class="hljs-string">"/header_reflect.html"</span>};Url url{server-&gt;<span class="hljs-built_in">GetBaseUrl</span>() + <span class="hljs-string">"/temporary_redirect.html"</span>};Url url{server-&gt;<span class="hljs-built_in">GetBaseUrl</span>() + <span class="hljs-string">"/permanent_redirect.html"</span>};Url url{server-&gt;<span class="hljs-built_in">GetBaseUrl</span>() + <span class="hljs-string">"/body_get.html"</span>};</code></pre></div><h3><span id="get">Get</span><a href="#get" class="header-anchor">#</a></h3><h4><span id="response-response-cpr-get-url">Response response = cpr::Get(url)</span><a href="#response-response-cpr-get-url" class="header-anchor">#</a></h4><h4><span id="response-response-cpr-get-url-iface">Response response = cpr::Get(url, iface);</span><a href="#response-response-cpr-get-url-iface" class="header-anchor">#</a></h4><h4><span id="response-response-cpr-get-url-timeout-0l">Response response = cpr::Get(url, Timeout{0L});</span><a href="#response-response-cpr-get-url-timeout-0l" class="header-anchor">#</a></h4><h4><span id="response-response-cpr-get-url-cookies">Response response = cpr::Get(url, cookies);</span><a href="#response-response-cpr-get-url-cookies" class="header-anchor">#</a></h4><h4><span id="response-response-cpr-get-url-parameters">Response response = cpr::Get(url, parameters{});</span><a href="#response-response-cpr-get-url-parameters" class="header-anchor">#</a></h4><h4><span id="response-response-cpr-get-url-authentication">Response response = cpr::Get(url, Authentication{});</span><a href="#response-response-cpr-get-url-authentication" class="header-anchor">#</a></h4><h4><span id="response-response-cpr-get-url-header">Response response = cpr::Get(url, Header{});</span><a href="#response-response-cpr-get-url-header" class="header-anchor">#</a></h4><h4><span id="response-response-cpr-get-url-bearer">Response response = cpr::Get(url, Bearer{});</span><a href="#response-response-cpr-get-url-bearer" class="header-anchor">#</a></h4><h4><span id="response-response-cpr-get-url-digest">Response response = cpr::Get(url, Digest{});</span><a href="#response-response-cpr-get-url-digest" class="header-anchor">#</a></h4><h4><span id="response-response-cpr-get-url-authentication-parameters">Response response = cpr::Get(url, Authentication{}, Parameters{});</span><a href="#response-response-cpr-get-url-authentication-parameters" class="header-anchor">#</a></h4><h4><span id="response-response-cpr-get-url-parameters-authentication">Response response = cpr::Get(url, Parameters{}, Authentication{});</span><a href="#response-response-cpr-get-url-parameters-authentication" class="header-anchor">#</a></h4><h4><span id="response-response-cpr-get-url-authentication-header">Response response = cpr::Get(url, Authentication{}, Header{});</span><a href="#response-response-cpr-get-url-authentication-header" class="header-anchor">#</a></h4><h4><span id="response-response-cpr-get-url-authentication-header">Response response = cpr::Get(url, Authentication{}, Header{});</span><a href="#response-response-cpr-get-url-authentication-header" class="header-anchor">#</a></h4><h4><span id="response-response-cpr-get-url-header-authentication">Response response = cpr::Get(url, Header{}, Authentication{});</span><a href="#response-response-cpr-get-url-header-authentication" class="header-anchor">#</a></h4><h4><span id="response-response-cpr-get-url-header-parameters">Response response = cpr::Get(url, Header{}, Parameters{});</span><a href="#response-response-cpr-get-url-header-parameters" class="header-anchor">#</a></h4><h4><span id="response-response-cpr-get-url-parameters-header">Response response = cpr::Get(url, Parameters{}, Header{});</span><a href="#response-response-cpr-get-url-parameters-header" class="header-anchor">#</a></h4><h4><span id="response-response-cpr-get-url-authentication-parameters-header">Response response = cpr::Get(url, Authentication{}, Parameters{}, Header{});</span><a href="#response-response-cpr-get-url-authentication-parameters-header" class="header-anchor">#</a></h4><h4><span id="response-response-cpr-get-url-parameters-header-authentication">Response response = cpr::Get(url, Parameters{}, Header{}, Authentication{});</span><a href="#response-response-cpr-get-url-parameters-header-authentication" class="header-anchor">#</a></h4><h4><span id="response-response-cpr-get-url-header-authentication-parameters">Response response = cpr::Get(url, Header{}, Authentication{}, Parameters{});</span><a href="#response-response-cpr-get-url-header-authentication-parameters" class="header-anchor">#</a></h4><h4><span id="response-response-cpr-get-url-authentication-header-parameters">Response response = cpr::Get(url, Authentication{}, Header{}, Parameters{});</span><a href="#response-response-cpr-get-url-authentication-header-parameters" class="header-anchor">#</a></h4><h4><span id="response-response-cpr-get-url-parameters-authentication-header">Response response = cpr::Get(url, Parameters{}, Authentication{}, Header{});</span><a href="#response-response-cpr-get-url-parameters-authentication-header" class="header-anchor">#</a></h4><h4><span id="response-response-cpr-get-url-redirect-false">Response response = cpr::Get(url, Redirect(false));</span><a href="#response-response-cpr-get-url-redirect-false" class="header-anchor">#</a></h4><h4><span id="response-response-cpr-get-url-redirect-0l">Response response = cpr::Get(url, Redirect(0L));</span><a href="#response-response-cpr-get-url-redirect-0l" class="header-anchor">#</a></h4><h4><span id="response-response-cpr-get-url-authentication-header-redirect-true-true">Response response = cpr::Get(url, Authentication{}, Header{}, Redirect(true, true));</span><a href="#response-response-cpr-get-url-authentication-header-redirect-true-true" class="header-anchor">#</a></h4><h4><span id="response-response-cpr-get-url-body">Response response = cpr::Get(url, body);</span><a href="#response-response-cpr-get-url-body" class="header-anchor">#</a></h4><h4><span id="response-response-cpr-get-url-limitrate-1024-1024">Response response = cpr::Get(url, LimitRate(1024, 1024));</span><a href="#response-response-cpr-get-url-limitrate-1024-1024" class="header-anchor">#</a></h4><div class="code-wrapper"><pre><code class="hljs c++">Response response = cpr::<span class="hljs-built_in">Get</span>(url);Response response = cpr::<span class="hljs-built_in">Get</span>(url, iface);Response response = cpr::<span class="hljs-built_in">Get</span>(url, Timeout{<span class="hljs-number">0L</span>});Response response = cpr::<span class="hljs-built_in">Get</span>(url, cookies);Response response = cpr::<span class="hljs-built_in">Get</span>(url, parameters);Response response = cpr::<span class="hljs-built_in">Get</span>(url, Parameters{{<span class="hljs-string">"key"</span>, <span class="hljs-string">"value"</span>}, {<span class="hljs-string">"hello"</span>, <span class="hljs-string">"world"</span>}, {<span class="hljs-string">"test"</span>, <span class="hljs-string">"case"</span>}});Response response = cpr::<span class="hljs-built_in">Get</span>(url, Authentication{<span class="hljs-string">"user"</span>, <span class="hljs-string">"password"</span>});Response response = cpr::<span class="hljs-built_in">Get</span>(url, Header{{<span class="hljs-string">"Authorization"</span>, <span class="hljs-string">"Bearer the_token"</span>}});Response response = cpr::<span class="hljs-built_in">Get</span>(url, Bearer{<span class="hljs-string">"the_token"</span>});Response response = cpr::<span class="hljs-built_in">Get</span>(url, Digest{<span class="hljs-string">"user"</span>, <span class="hljs-string">"password"</span>});Response response = cpr::<span class="hljs-built_in">Get</span>(url, Authentication{<span class="hljs-string">"user"</span>, <span class="hljs-string">"password"</span>}, Parameters{{<span class="hljs-string">"hello"</span>, <span class="hljs-string">"world"</span>}});Response response = cpr::<span class="hljs-built_in">Get</span>(url, Authentication{<span class="hljs-string">"user"</span>, <span class="hljs-string">"password"</span>}, Parameters{{<span class="hljs-string">"key"</span>, <span class="hljs-string">"value"</span>}, {<span class="hljs-string">"hello"</span>, <span class="hljs-string">"world"</span>}, {<span class="hljs-string">"test"</span>, <span class="hljs-string">"case"</span>}});Response response = cpr::<span class="hljs-built_in">Get</span>(url, Parameters{{<span class="hljs-string">"hello"</span>, <span class="hljs-string">"world"</span>}}, Authentication{<span class="hljs-string">"user"</span>, <span class="hljs-string">"password"</span>});Response response = cpr::<span class="hljs-built_in">Get</span>(url, Parameters{{<span class="hljs-string">"key"</span>, <span class="hljs-string">"value"</span>}, {<span class="hljs-string">"hello"</span>, <span class="hljs-string">"world"</span>}, {<span class="hljs-string">"test"</span>, <span class="hljs-string">"case"</span>}}, Authentication{<span class="hljs-string">"user"</span>, <span class="hljs-string">"password"</span>});Response response = cpr::<span class="hljs-built_in">Get</span>(url, Authentication{<span class="hljs-string">"user"</span>, <span class="hljs-string">"password"</span>}, Header{{<span class="hljs-string">"hello"</span>, <span class="hljs-string">"world"</span>}});Response response = cpr::<span class="hljs-built_in">Get</span>(url, Authentication{<span class="hljs-string">"user"</span>, <span class="hljs-string">"password"</span>}, Header{{<span class="hljs-string">"key"</span>, <span class="hljs-string">"value"</span>}, {<span class="hljs-string">"hello"</span>, <span class="hljs-string">"world"</span>}, {<span class="hljs-string">"test"</span>, <span class="hljs-string">"case"</span>}});Response response = cpr::<span class="hljs-built_in">Get</span>(url, Header{{<span class="hljs-string">"hello"</span>, <span class="hljs-string">"world"</span>}}, Authentication{<span class="hljs-string">"user"</span>, <span class="hljs-string">"password"</span>});Response response = cpr::<span class="hljs-built_in">Get</span>(url, Header{{<span class="hljs-string">"key"</span>, <span class="hljs-string">"value"</span>}, {<span class="hljs-string">"hello"</span>, <span class="hljs-string">"world"</span>}, {<span class="hljs-string">"test"</span>, <span class="hljs-string">"case"</span>}}, Authentication{<span class="hljs-string">"user"</span>, <span class="hljs-string">"password"</span>});Response response = cpr::<span class="hljs-built_in">Get</span>(url, Authentication{<span class="hljs-string">"user"</span>, <span class="hljs-string">"bad_password"</span>});Response response = cpr::<span class="hljs-built_in">Get</span>(url, Authentication{<span class="hljs-string">"user"</span>, <span class="hljs-string">"bad_password"</span>}, Parameters{{<span class="hljs-string">"hello"</span>, <span class="hljs-string">"world"</span>}});Response response = cpr::<span class="hljs-built_in">Get</span>(url, Authentication{<span class="hljs-string">"user"</span>, <span class="hljs-string">"bad_password"</span>}, Parameters{{<span class="hljs-string">"key"</span>, <span class="hljs-string">"value"</span>}, {<span class="hljs-string">"hello"</span>, <span class="hljs-string">"world"</span>}, {<span class="hljs-string">"test"</span>, <span class="hljs-string">"case"</span>}});Response response = cpr::<span class="hljs-built_in">Get</span>(url, Header{{<span class="hljs-string">"content-type"</span>, <span class="hljs-string">"application/json"</span>}});Response = session.<span class="hljs-built_in">Get</span>();cpr::Response response = session-&gt;<span class="hljs-built_in">Post</span>();Response response = session.<span class="hljs-built_in">Get</span>();Response response = cpr::<span class="hljs-built_in">Get</span>(url, Header{});Response response = cpr::<span class="hljs-built_in">Get</span>(url, Header{{<span class="hljs-string">"hello"</span>, <span class="hljs-string">"world"</span>}});Response response = cpr::<span class="hljs-built_in">Get</span>(url, Header{{<span class="hljs-string">"hello"</span>, <span class="hljs-string">"world"</span>}, {<span class="hljs-string">"key"</span>, <span class="hljs-string">"value"</span>}, {<span class="hljs-string">"test"</span>, <span class="hljs-string">"case"</span>}});Response response = cpr::<span class="hljs-built_in">Get</span>(url, Header{{<span class="hljs-string">"HeLlO"</span>, <span class="hljs-string">"wOrLd"</span>}});Response response = cpr::<span class="hljs-built_in">Get</span>(url, Header{{<span class="hljs-string">"hello"</span>, <span class="hljs-string">""</span>}});Response response = cpr::<span class="hljs-built_in">Get</span>(url, Parameters{{<span class="hljs-string">"one"</span>, <span class="hljs-string">"two"</span>}, {<span class="hljs-string">"three"</span>, <span class="hljs-string">"four"</span>}, {<span class="hljs-string">"five"</span>, <span class="hljs-string">"six"</span>}});Response response = cpr::<span class="hljs-built_in">Get</span>(url, Header{}, Parameters{{<span class="hljs-string">"one"</span>, <span class="hljs-string">"two"</span>}, {<span class="hljs-string">"three"</span>, <span class="hljs-string">"four"</span>}, {<span class="hljs-string">"five"</span>, <span class="hljs-string">"six"</span>}});Response response = cpr::<span class="hljs-built_in">Get</span>(url, Header{{<span class="hljs-string">"hello"</span>, <span class="hljs-string">"world"</span>}}, Parameters{{<span class="hljs-string">"one"</span>, <span class="hljs-string">"two"</span>}, {<span class="hljs-string">"three"</span>, <span class="hljs-string">"four"</span>}, {<span class="hljs-string">"five"</span>, <span class="hljs-string">"six"</span>}});Response response = cpr::<span class="hljs-built_in">Get</span>(url, Header{{<span class="hljs-string">"hello"</span>, <span class="hljs-string">"world"</span>}, {<span class="hljs-string">"key"</span>, <span class="hljs-string">"value"</span>}, {<span class="hljs-string">"test"</span>, <span class="hljs-string">"case"</span>}}, Parameters{{<span class="hljs-string">"one"</span>, <span class="hljs-string">"two"</span>}, {<span class="hljs-string">"three"</span>, <span class="hljs-string">"four"</span>}, {<span class="hljs-string">"five"</span>, <span class="hljs-string">"six"</span>}});Response response = cpr::<span class="hljs-built_in">Get</span>(url, Parameters{{<span class="hljs-string">"one"</span>, <span class="hljs-string">"two"</span>}, {<span class="hljs-string">"three"</span>, <span class="hljs-string">"four"</span>}, {<span class="hljs-string">"five"</span>, <span class="hljs-string">"six"</span>}}, Header{});Response response = cpr::<span class="hljs-built_in">Get</span>(url, Parameters{{<span class="hljs-string">"one"</span>, <span class="hljs-string">"two"</span>}, {<span class="hljs-string">"three"</span>, <span class="hljs-string">"four"</span>}, {<span class="hljs-string">"five"</span>, <span class="hljs-string">"six"</span>}}, Header{{<span class="hljs-string">"hello"</span>, <span class="hljs-string">"world"</span>}});Response response = cpr::<span class="hljs-built_in">Get</span>(url, Parameters{{<span class="hljs-string">"one"</span>, <span class="hljs-string">"two"</span>}, {<span class="hljs-string">"three"</span>, <span class="hljs-string">"four"</span>}, {<span class="hljs-string">"five"</span>, <span class="hljs-string">"six"</span>}}, Header{{<span class="hljs-string">"hello"</span>, <span class="hljs-string">"world"</span>}, {<span class="hljs-string">"key"</span>, <span class="hljs-string">"value"</span>}, {<span class="hljs-string">"test"</span>, <span class="hljs-string">"case"</span>}});Response response = cpr::<span class="hljs-built_in">Get</span>(url, Parameters{{<span class="hljs-string">"one"</span>, <span class="hljs-string">"two"</span>}, {<span class="hljs-string">"three"</span>, <span class="hljs-string">"four"</span>}, {<span class="hljs-string">"five"</span>, <span class="hljs-string">"six"</span>}}, Header{{<span class="hljs-string">"HeLlO"</span>, <span class="hljs-string">"wOrLd"</span>}});Response response = cpr::<span class="hljs-built_in">Get</span>(url, Authentication{<span class="hljs-string">"user"</span>, <span class="hljs-string">"password"</span>}, Parameters{}, Header{});Response response = cpr::<span class="hljs-built_in">Get</span>(url, Authentication{<span class="hljs-string">"user"</span>, <span class="hljs-string">"bad_password"</span>}, Parameters{}, Header{});Response response = cpr::<span class="hljs-built_in">Get</span>(url, Authentication{<span class="hljs-string">"user"</span>, <span class="hljs-string">"password"</span>}, Parameters{{<span class="hljs-string">"one"</span>, <span class="hljs-string">"two"</span>}}, Header{});Response response = cpr::<span class="hljs-built_in">Get</span>(url, Authentication{<span class="hljs-string">"user"</span>, <span class="hljs-string">"bad_password"</span>}, Parameters{{<span class="hljs-string">"one"</span>, <span class="hljs-string">"two"</span>}}, Header{});Response response = cpr::<span class="hljs-built_in">Get</span>(url, Authentication{<span class="hljs-string">"user"</span>, <span class="hljs-string">"password"</span>}, Parameters{}, Header{{<span class="hljs-string">"hello"</span>, <span class="hljs-string">"world"</span>}});Response response = cpr::<span class="hljs-built_in">Get</span>(url, Authentication{<span class="hljs-string">"user"</span>, <span class="hljs-string">"bad_password"</span>}, Parameters{}, Header{{<span class="hljs-string">"hello"</span>, <span class="hljs-string">"world"</span>}});Response response = cpr::<span class="hljs-built_in">Get</span>(url, Authentication{<span class="hljs-string">"user"</span>, <span class="hljs-string">"password"</span>}, Parameters{{<span class="hljs-string">"one"</span>, <span class="hljs-string">"two"</span>}}, Header{{<span class="hljs-string">"hello"</span>, <span class="hljs-string">"world"</span>}});Response response = cpr::<span class="hljs-built_in">Get</span>(url, Authentication{<span class="hljs-string">"user"</span>, <span class="hljs-string">"bad_password"</span>}, Parameters{{<span class="hljs-string">"one"</span>, <span class="hljs-string">"two"</span>}}, Header{{<span class="hljs-string">"hello"</span>, <span class="hljs-string">"world"</span>}});Response response = cpr::<span class="hljs-built_in">Get</span>(url, Parameters{}, Header{}, Authentication{<span class="hljs-string">"user"</span>, <span class="hljs-string">"password"</span>});Response response = cpr::<span class="hljs-built_in">Get</span>(url, Parameters{}, Header{}, Authentication{<span class="hljs-string">"user"</span>, <span class="hljs-string">"bad_password"</span>});Response response = cpr::<span class="hljs-built_in">Get</span>(url, Parameters{{<span class="hljs-string">"one"</span>, <span class="hljs-string">"two"</span>}}, Header{}, Authentication{<span class="hljs-string">"user"</span>, <span class="hljs-string">"password"</span>});Response response = cpr::<span class="hljs-built_in">Get</span>(url, Parameters{{<span class="hljs-string">"one"</span>, <span class="hljs-string">"two"</span>}}, Header{}, Authentication{<span class="hljs-string">"user"</span>, <span class="hljs-string">"bad_password"</span>});Response response = cpr::<span class="hljs-built_in">Get</span>(url, Parameters{}, Header{{<span class="hljs-string">"hello"</span>, <span class="hljs-string">"world"</span>}}, Authentication{<span class="hljs-string">"user"</span>, <span class="hljs-string">"password"</span>});Response response = cpr::<span class="hljs-built_in">Get</span>(url, Parameters{}, Header{{<span class="hljs-string">"hello"</span>, <span class="hljs-string">"world"</span>}}, Authentication{<span class="hljs-string">"user"</span>, <span class="hljs-string">"bad_password"</span>});Response response = cpr::<span class="hljs-built_in">Get</span>(url, Parameters{{<span class="hljs-string">"one"</span>, <span class="hljs-string">"two"</span>}}, Header{{<span class="hljs-string">"hello"</span>, <span class="hljs-string">"world"</span>}}, Authentication{<span class="hljs-string">"user"</span>, <span class="hljs-string">"password"</span>});Response response = cpr::<span class="hljs-built_in">Get</span>(url, Parameters{{<span class="hljs-string">"one"</span>, <span class="hljs-string">"two"</span>}}, Header{{<span class="hljs-string">"hello"</span>, <span class="hljs-string">"world"</span>}}, Authentication{<span class="hljs-string">"user"</span>, <span class="hljs-string">"bad_password"</span>});Response response = cpr::<span class="hljs-built_in">Get</span>(url, Header{}, Authentication{<span class="hljs-string">"user"</span>, <span class="hljs-string">"password"</span>}, Parameters{});Response response = cpr::<span class="hljs-built_in">Get</span>(url, Header{}, Authentication{<span class="hljs-string">"user"</span>, <span class="hljs-string">"bad_password"</span>}, Parameters{});Response response = cpr::<span class="hljs-built_in">Get</span>(url, Header{}, Authentication{<span class="hljs-string">"user"</span>, <span class="hljs-string">"password"</span>}, Parameters{{<span class="hljs-string">"one"</span>, <span class="hljs-string">"two"</span>}});Response response = cpr::<span class="hljs-built_in">Get</span>(url, Header{}, Authentication{<span class="hljs-string">"user"</span>, <span class="hljs-string">"bad_password"</span>}, Parameters{{<span class="hljs-string">"one"</span>, <span class="hljs-string">"two"</span>}});Response response = cpr::<span class="hljs-built_in">Get</span>(url, Header{{<span class="hljs-string">"hello"</span>, <span class="hljs-string">"world"</span>}}, Authentication{<span class="hljs-string">"user"</span>, <span class="hljs-string">"password"</span>}, Parameters{});Response response = cpr::<span class="hljs-built_in">Get</span>(url, Header{{<span class="hljs-string">"hello"</span>, <span class="hljs-string">"world"</span>}}, Authentication{<span class="hljs-string">"user"</span>, <span class="hljs-string">"bad_password"</span>}, Parameters{});Response response = cpr::<span class="hljs-built_in">Get</span>(url, Header{{<span class="hljs-string">"hello"</span>, <span class="hljs-string">"world"</span>}}, Authentication{<span class="hljs-string">"user"</span>, <span class="hljs-string">"password"</span>}, Parameters{{<span class="hljs-string">"one"</span>, <span class="hljs-string">"two"</span>}});Response response = cpr::<span class="hljs-built_in">Get</span>(url, Header{{<span class="hljs-string">"hello"</span>, <span class="hljs-string">"world"</span>}}, Authentication{<span class="hljs-string">"user"</span>, <span class="hljs-string">"bad_password"</span>}, Parameters{{<span class="hljs-string">"one"</span>, <span class="hljs-string">"two"</span>}});Response response = cpr::<span class="hljs-built_in">Get</span>(url, Authentication{<span class="hljs-string">"user"</span>, <span class="hljs-string">"password"</span>}, Header{}, Parameters{});Response response = cpr::<span class="hljs-built_in">Get</span>(url, Authentication{<span class="hljs-string">"user"</span>, <span class="hljs-string">"bad_password"</span>}, Header{}, Parameters{});Response response = cpr::<span class="hljs-built_in">Get</span>(url, Authentication{<span class="hljs-string">"user"</span>, <span class="hljs-string">"password"</span>}, Header{}, Parameters{{<span class="hljs-string">"one"</span>, <span class="hljs-string">"two"</span>}});Response response = cpr::<span class="hljs-built_in">Get</span>(url, Authentication{<span class="hljs-string">"user"</span>, <span class="hljs-string">"bad_password"</span>}, Header{}, Parameters{{<span class="hljs-string">"one"</span>, <span class="hljs-string">"two"</span>}});Response response = cpr::<span class="hljs-built_in">Get</span>(url, Authentication{<span class="hljs-string">"user"</span>, <span class="hljs-string">"password"</span>}, Header{{<span class="hljs-string">"hello"</span>, <span class="hljs-string">"world"</span>}}, Parameters{});Response response = cpr::<span class="hljs-built_in">Get</span>(url, Authentication{<span class="hljs-string">"user"</span>, <span class="hljs-string">"bad_password"</span>}, Header{{<span class="hljs-string">"hello"</span>, <span class="hljs-string">"world"</span>}}, Parameters{});Response response = cpr::<span class="hljs-built_in">Get</span>(url, Authentication{<span class="hljs-string">"user"</span>, <span class="hljs-string">"password"</span>}, Header{{<span class="hljs-string">"hello"</span>, <span class="hljs-string">"world"</span>}}, Parameters{{<span class="hljs-string">"one"</span>, <span class="hljs-string">"two"</span>}});Response response = cpr::<span class="hljs-built_in">Get</span>(url, Authentication{<span class="hljs-string">"user"</span>, <span class="hljs-string">"bad_password"</span>}, Header{{<span class="hljs-string">"hello"</span>, <span class="hljs-string">"world"</span>}}, Parameters{{<span class="hljs-string">"one"</span>, <span class="hljs-string">"two"</span>}});Response response = cpr::<span class="hljs-built_in">Get</span>(url, Header{}, Parameters{}, Authentication{<span class="hljs-string">"user"</span>, <span class="hljs-string">"password"</span>});Response response = cpr::<span class="hljs-built_in">Get</span>(url, Header{}, Parameters{}, Authentication{<span class="hljs-string">"user"</span>, <span class="hljs-string">"bad_password"</span>});Response response = cpr::<span class="hljs-built_in">Get</span>(url, Header{}, Parameters{{<span class="hljs-string">"one"</span>, <span class="hljs-string">"two"</span>}}, Authentication{<span class="hljs-string">"user"</span>, <span class="hljs-string">"password"</span>});Response response = cpr::<span class="hljs-built_in">Get</span>(url, Header{}, Parameters{{<span class="hljs-string">"one"</span>, <span class="hljs-string">"two"</span>}}, Authentication{<span class="hljs-string">"user"</span>, <span class="hljs-string">"bad_password"</span>});Response response = cpr::<span class="hljs-built_in">Get</span>(url, Header{{<span class="hljs-string">"hello"</span>, <span class="hljs-string">"world"</span>}}, Parameters{}, Authentication{<span class="hljs-string">"user"</span>, <span class="hljs-string">"password"</span>});Response response = cpr::<span class="hljs-built_in">Get</span>(url, Header{{<span class="hljs-string">"hello"</span>, <span class="hljs-string">"world"</span>}}, Parameters{}, Authentication{<span class="hljs-string">"user"</span>, <span class="hljs-string">"bad_password"</span>});Response response = cpr::<span class="hljs-built_in">Get</span>(url, Header{{<span class="hljs-string">"hello"</span>, <span class="hljs-string">"world"</span>}}, Parameters{{<span class="hljs-string">"one"</span>, <span class="hljs-string">"two"</span>}}, Authentication{<span class="hljs-string">"user"</span>, <span class="hljs-string">"password"</span>});Response response = cpr::<span class="hljs-built_in">Get</span>(url, Header{{<span class="hljs-string">"hello"</span>, <span class="hljs-string">"world"</span>}}, Parameters{{<span class="hljs-string">"one"</span>, <span class="hljs-string">"two"</span>}}, Authentication{<span class="hljs-string">"user"</span>, <span class="hljs-string">"bad_password"</span>});Response response = cpr::<span class="hljs-built_in">Get</span>(url, Parameters{}, Authentication{<span class="hljs-string">"user"</span>, <span class="hljs-string">"password"</span>}, Header{});Response response = cpr::<span class="hljs-built_in">Get</span>(url, Parameters{}, Authentication{<span class="hljs-string">"user"</span>, <span class="hljs-string">"bad_password"</span>}, Header{});Response response = cpr::<span class="hljs-built_in">Get</span>(url, Parameters{{<span class="hljs-string">"one"</span>, <span class="hljs-string">"two"</span>}}, Authentication{<span class="hljs-string">"user"</span>, <span class="hljs-string">"password"</span>}, Header{});Response response = cpr::<span class="hljs-built_in">Get</span>(url, Parameters{{<span class="hljs-string">"one"</span>, <span class="hljs-string">"two"</span>}}, Authentication{<span class="hljs-string">"user"</span>, <span class="hljs-string">"bad_password"</span>}, Header{});Response response = cpr::<span class="hljs-built_in">Get</span>(url, Parameters{}, Authentication{<span class="hljs-string">"user"</span>, <span class="hljs-string">"password"</span>}, Header{{<span class="hljs-string">"hello"</span>, <span class="hljs-string">"world"</span>}});Response response = cpr::<span class="hljs-built_in">Get</span>(url, Parameters{}, Authentication{<span class="hljs-string">"user"</span>, <span class="hljs-string">"bad_password"</span>}, Header{{<span class="hljs-string">"hello"</span>, <span class="hljs-string">"world"</span>}});Response response = cpr::<span class="hljs-built_in">Get</span>(url, Parameters{{<span class="hljs-string">"one"</span>, <span class="hljs-string">"two"</span>}}, Authentication{<span class="hljs-string">"user"</span>, <span class="hljs-string">"password"</span>}, Header{{<span class="hljs-string">"hello"</span>, <span class="hljs-string">"world"</span>}});Response response = cpr::<span class="hljs-built_in">Get</span>(url, Parameters{{<span class="hljs-string">"one"</span>, <span class="hljs-string">"two"</span>}}, Authentication{<span class="hljs-string">"user"</span>, <span class="hljs-string">"bad_password"</span>}, Header{{<span class="hljs-string">"hello"</span>, <span class="hljs-string">"world"</span>}});Response response = cpr::<span class="hljs-built_in">Get</span>(url, <span class="hljs-built_in">Redirect</span>(<span class="hljs-literal">false</span>));Response response = cpr::<span class="hljs-built_in">Get</span>(url, <span class="hljs-built_in">Redirect</span>(<span class="hljs-number">0L</span>));Response response = cpr::<span class="hljs-built_in">Get</span>(url, Authentication{<span class="hljs-string">"user"</span>, <span class="hljs-string">"password"</span>}, Header{{<span class="hljs-string">"RedirectLocation"</span>, <span class="hljs-string">"basic_auth.html"</span>}}, <span class="hljs-built_in">Redirect</span>(<span class="hljs-literal">true</span>, <span class="hljs-literal">true</span>));Response response = cpr::<span class="hljs-built_in">Get</span>(url, body);Response response = cpr::<span class="hljs-built_in">Get</span>(url, <span class="hljs-built_in">LimitRate</span>(<span class="hljs-number">1024</span>, <span class="hljs-number">1024</span>));</code></pre></div><h3><span id="cpr-post">cpr::Post</span><a href="#cpr-post" class="header-anchor">#</a></h3><div class="code-wrapper"><pre><code class="hljs c++">Response response = cpr::<span class="hljs-built_in">Post</span>(url, Payload{{<span class="hljs-string">"x"</span>, <span class="hljs-string">"5"</span>}});Payload payload{{<span class="hljs-string">"x"</span>, <span class="hljs-string">"1"</span>}};    payload.<span class="hljs-built_in">Add</span>({<span class="hljs-string">"y"</span>, <span class="hljs-string">"2"</span>});    Response response = cpr::<span class="hljs-built_in">Post</span>(url, payload);std::vector&lt;Pair&gt; payloadData;    payloadData.<span class="hljs-built_in">emplace_back</span>(<span class="hljs-string">"x"</span>, <span class="hljs-string">"1"</span>);    payloadData.<span class="hljs-built_in">emplace_back</span>(<span class="hljs-string">"y"</span>, <span class="hljs-string">"2"</span>);    Response response = cpr::<span class="hljs-built_in">Post</span>(url, <span class="hljs-built_in">Payload</span>(payloadData.<span class="hljs-built_in">begin</span>(), payloadData.<span class="hljs-built_in">end</span>()));    Response response = cpr::<span class="hljs-built_in">Post</span>(url, Payload{{<span class="hljs-string">"x"</span>, <span class="hljs-string">"hello world!!~"</span>}});Response response = cpr::<span class="hljs-built_in">Post</span>(url, Payload{{<span class="hljs-string">"x"</span>, <span class="hljs-string">"5"</span>}, {<span class="hljs-string">"y"</span>, <span class="hljs-string">"13"</span>}});Url url{<span class="hljs-string">"http://bad_host/"</span>};    Response response = cpr::<span class="hljs-built_in">Post</span>(url, Payload{{<span class="hljs-string">"hello"</span>, <span class="hljs-string">"world"</span>}});    Response response = cpr::<span class="hljs-built_in">Post</span>(url, Multipart{{<span class="hljs-string">"x"</span>, <span class="hljs-number">5</span>}});Response response = cpr::<span class="hljs-built_in">Post</span>(url, Multipart{{<span class="hljs-string">"x"</span>, File{filename}}});Multipart multipart{{<span class="hljs-string">"x"</span>, File{filename}}};Response response = cpr::<span class="hljs-built_in">Post</span>(url, multipart);cpr::Response response = cpr::<span class="hljs-built_in">Post</span>(url, cpr::Header{{<span class="hljs-string">"Content-Type"</span>, <span class="hljs-string">"application/json"</span>}}, cpr::Body{body}, cpr::ConnectTimeout{<span class="hljs-number">3000</span>}, cpr::Timeout{<span class="hljs-number">3000</span>});Response response = cpr::<span class="hljs-built_in">Post</span>(url, Multipart{{<span class="hljs-string">"x"</span>, Buffer{content.<span class="hljs-built_in">begin</span>(), content.<span class="hljs-built_in">end</span>(), <span class="hljs-string">"test_file"</span>}}});Multipart multipart{{<span class="hljs-string">"x"</span>, Buffer{content.<span class="hljs-built_in">begin</span>(), content.<span class="hljs-built_in">end</span>(), <span class="hljs-string">"test_file"</span>}}};Response response = cpr::<span class="hljs-built_in">Post</span>(url, multipart);Response response = cpr::<span class="hljs-built_in">Post</span>(url, Multipart{{<span class="hljs-string">"x"</span>, Buffer{content, <span class="hljs-number">11</span> + content, <span class="hljs-string">"test_file"</span>}}});Response response = cpr::<span class="hljs-built_in">Post</span>(url, Multipart{{<span class="hljs-string">"x"</span>, Buffer{std::<span class="hljs-built_in">begin</span>(content), std::<span class="hljs-built_in">end</span>(content) - <span class="hljs-number">1</span>, <span class="hljs-string">"test_file"</span>}}});Response response = cpr::<span class="hljs-built_in">Post</span>(url, Multipart{{<span class="hljs-string">"x"</span>, <span class="hljs-number">5</span>}, {<span class="hljs-string">"y"</span>, <span class="hljs-number">13</span>}});Response response = cpr::<span class="hljs-built_in">Post</span>(url, multipart);Response response = cpr::<span class="hljs-built_in">Post</span>(url, Multipart{{<span class="hljs-string">"x"</span>, <span class="hljs-number">5</span>, <span class="hljs-string">"application/number"</span>}});Multipart multipart{{<span class="hljs-string">"x"</span>, <span class="hljs-number">5</span>, <span class="hljs-string">"application/number"</span>}};Response response = cpr::<span class="hljs-built_in">Post</span>(url, multipart);Response response = cpr::<span class="hljs-built_in">Post</span>(cpr::<span class="hljs-built_in">Url</span>(uri), cpr::Header{{<span class="hljs-string">"content-type"</span>, contentType}, {<span class="hljs-string">"Authorization"</span>, signature}, {<span class="hljs-string">"log-type"</span>, logType}, {<span class="hljs-string">"x-ms-date"</span>, date}, {<span class="hljs-string">"content-length"</span>, std::<span class="hljs-built_in">to_string</span>(body.<span class="hljs-built_in">length</span>())}}, cpr::<span class="hljs-built_in">Body</span>(body));cpr::Payload payload = cpr::Payload{{<span class="hljs-string">"email"</span>, <span class="hljs-string">""</span>}, {<span class="hljs-string">"password"</span>, <span class="hljs-string">""</span>}, {<span class="hljs-string">"devicetoken"</span>, <span class="hljs-string">""</span>}};    cpr::Response response = cpr::<span class="hljs-built_in">Post</span>(cpr::<span class="hljs-built_in">Url</span>(uri), cpr::Timeout{<span class="hljs-number">10000</span>}, payload);Response response = cpr::<span class="hljs-built_in">Post</span>(url, Payload{{<span class="hljs-string">"x"</span>, <span class="hljs-string">"5"</span>}}, Header{{<span class="hljs-string">"RedirectLocation"</span>, <span class="hljs-string">"url_post.html"</span>}});Response response = cpr::<span class="hljs-built_in">Post</span>(url, Payload{{<span class="hljs-string">"x"</span>, <span class="hljs-string">"5"</span>}}, Header{{<span class="hljs-string">"RedirectLocation"</span>, <span class="hljs-string">"url_post.html"</span>}}, <span class="hljs-built_in">Redirect</span>(PostRedirectFlags::NONE));Response response = cpr::<span class="hljs-built_in">Post</span>(url, Payload{{<span class="hljs-string">"x"</span>, <span class="hljs-string">"5"</span>}}, Header{{<span class="hljs-string">"RedirectLocation"</span>, <span class="hljs-string">"url_post.html"</span>}});Response response = cpr::<span class="hljs-built_in">Post</span>(url, Payload{{<span class="hljs-string">"x"</span>, <span class="hljs-string">"5"</span>}}, Header{{<span class="hljs-string">"RedirectLocation"</span>, <span class="hljs-string">"url_post.html"</span>}}, <span class="hljs-built_in">Redirect</span>(PostRedirectFlags::NONE));</code></pre></div><h3><span id="std-string-expected-text"><strong>std</strong>::<strong>string</strong> expected_text{“”};</span><a href="#std-string-expected-text" class="header-anchor">#</a></h3><div class="code-wrapper"><pre><code class="hljs c++">std::string expected_text{<span class="hljs-string">"Hello world!"</span>};std::string expected_text{            <span class="hljs-string">"[\n"</span>            <span class="hljs-string">"  {\n"</span>            <span class="hljs-string">"    \"first_key\": \"first_value\",\n"</span>            <span class="hljs-string">"    \"second_key\": \"second_value\"\n"</span>            <span class="hljs-string">"  }\n"</span>            <span class="hljs-string">"]"</span>};std::string expected_text{<span class="hljs-string">"Not Found"</span>};std::string expected_text{<span class="hljs-string">"Header reflect GET"</span>};</code></pre></div><h3><span id="expect-eq">EXPECT_EQ()</span><a href="#expect-eq" class="header-anchor">#</a></h3><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-built_in">EXPECT_EQ</span>(expected_text, response.text);<span class="hljs-built_in">EXPECT_EQ</span>(std::string{}, response.text);<span class="hljs-built_in">EXPECT_EQ</span>(<span class="hljs-string">"Unauthorized"</span>, response.text);<span class="hljs-built_in">EXPECT_EQ</span>(std::string{<span class="hljs-string">"Header reflect POST"</span>}, response.text);<span class="hljs-built_in">EXPECT_EQ</span>(std::string{<span class="hljs-string">"Header reflect POST"</span>}, response.text);<span class="hljs-built_in">EXPECT_EQ</span>(url, response.url);<span class="hljs-built_in">EXPECT_EQ</span>(<span class="hljs-string">"text/plain"</span>, response.header[<span class="hljs-string">"content-type"</span>]);<span class="hljs-built_in">EXPECT_EQ</span>(std::string{<span class="hljs-string">"text/html"</span>}, response.header[<span class="hljs-string">"content-type"</span>]);<span class="hljs-built_in">EXPECT_EQ</span>(std::string{<span class="hljs-string">"application/json"</span>}, response.header[<span class="hljs-string">"Content-Type"</span>]);<span class="hljs-built_in">EXPECT_EQ</span>(std::string{<span class="hljs-string">"Value1"</span>}, response.header[<span class="hljs-string">"Header1"</span>]);<span class="hljs-built_in">EXPECT_EQ</span>(std::string{<span class="hljs-string">"Value2"</span>}, response.header[<span class="hljs-string">"Header2"</span>]);<span class="hljs-built_in">EXPECT_EQ</span>(std::string{}, response.header[<span class="hljs-string">"Header2"</span>]);cookies = response.cookies;<span class="hljs-built_in">EXPECT_EQ</span>(cookies[<span class="hljs-string">"cookie"</span>], response.cookies[<span class="hljs-string">"cookie"</span>]);<span class="hljs-built_in">EXPECT_EQ</span>(cookies[<span class="hljs-string">"icecream"</span>], response.cookies[<span class="hljs-string">"icecream"</span>]);<span class="hljs-built_in">EXPECT_EQ</span>(cookies[<span class="hljs-string">"expires"</span>], response.cookies[<span class="hljs-string">"expires"</span>]);<span class="hljs-built_in">EXPECT_EQ</span>(<span class="hljs-string">""</span>, response.cookies[<span class="hljs-string">"cookie"</span>]);<span class="hljs-built_in">EXPECT_EQ</span>(<span class="hljs-string">""</span>, response.cookies[<span class="hljs-string">"icecream"</span>]);<span class="hljs-built_in">EXPECT_EQ</span>(<span class="hljs-number">200</span>, response.status_code);<span class="hljs-built_in">EXPECT_EQ</span>(<span class="hljs-number">401</span>, response.status_code);<span class="hljs-built_in">EXPECT_EQ</span>(ErrorCode::OK, response.error.code);</code></pre></div>]]></content>
    
    
    
    <tags>
      
      <tag>C++</tag>
      
      <tag>TCP/IP</tag>
      
      <tag>HTTP</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Socket_Cpp库的使用</title>
    <link href="/2022/01/13/Socket_Cpp%E5%BA%93%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
    <url>/2022/01/13/Socket_Cpp%E5%BA%93%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<div class="toc"><!-- toc --><ul><li><a href="#tcp">TCP</a><ul><li><a href="#tcp-clien">TCP Clien</a></li><li><a href="#tcp-server">TCP Server</a></li></ul></li><li><a href="#udp">UDP</a><ul><li><a href="#udp-clien">UDP Clien</a></li><li><a href="#udp-server">UDP Server</a></li></ul></li><li><a href="#unix">UNIX</a><ul><li><a href="#unix-clien">UNIX Clien</a></li><li><a href="#unix-server">UNIX Server</a></li></ul></li></ul><!-- tocstop --></div><p>传输控制协议（TCP，Transmission Control Protocol）是一种面向连接的、可靠的、基于字节流的<strong>传输层通信协议</strong>。</p><p><img src="https://www.linuxblogs.cn/image/20190623_tcp_termination.png" alt="20190623_tcp_termination.png (925×613) (linuxblogs.cn)"></p><p>此库是一个简单的TCP库👉<a href="https://github.com/fpagliughi/sockpp">sockpp</a></p><h2><span id="tcp">TCP</span><a href="#tcp" class="header-anchor">#</a></h2><h3><span id="tcp-clien">TCP Clien</span><a href="#tcp-clien" class="header-anchor">#</a></h3><h4><span id="ipv4-tcp-clien"><strong>IPV4:tcp_clien</strong></span><a href="#ipv4-tcp-clien" class="header-anchor">#</a></h4><div class="code-wrapper"><pre><code class="hljs c++">sockpp::socket_initializer sockpp环境初始化<span class="hljs-function">sockpp::tcp_connector <span class="hljs-title">conn</span><span class="hljs-params">({host, port})</span> <span class="hljs-comment">// 初始化一个连接器，并尝试连接到{host, port}</span></span><span class="hljs-function">    !conn.<span class="hljs-title">read_timeout</span><span class="hljs-params">(seconds(<span class="hljs-number">5</span>))</span> <span class="hljs-comment">// 读超时</span></span><span class="hljs-function">    conn.<span class="hljs-title">address</span><span class="hljs-params">()</span> <span class="hljs-comment">// 连接成功打印地址</span></span><span class="hljs-function"></span><span class="hljs-function">conn.<span class="hljs-title">connect</span><span class="hljs-params">(sockpp::inet_address(<span class="hljs-string">"localhost"</span>, port))</span> <span class="hljs-comment">// 链接{localhost, port}</span></span><span class="hljs-function"><span class="hljs-title">sockpp::inet_address</span><span class="hljs-params">(host, port)</span> <span class="hljs-comment">// 返回一个默认的端口号和地址</span></span><span class="hljs-function">conn.<span class="hljs-title">clone</span><span class="hljs-params">()</span> <span class="hljs-comment">// clone一个sockpp::tcp_socket</span></span><span class="hljs-function">conn.<span class="hljs-title">last_error_str</span><span class="hljs-params">()</span> <span class="hljs-comment">// 返回根据平台各自的错误字符串</span></span><span class="hljs-function">conn.<span class="hljs-title">last_error</span><span class="hljs-params">()</span></span><span class="hljs-function">conn.<span class="hljs-title">write</span><span class="hljs-params">(s)</span> <span class="hljs-comment">// 通过coon把字符串s写过去</span></span><span class="hljs-function">conn.<span class="hljs-title">write_n</span><span class="hljs-params">(buf, n)</span> <span class="hljs-comment">// 从buf中取n个字节的数据并通过tcp写过去</span></span><span class="hljs-function">conn.<span class="hljs-title">read</span><span class="hljs-params">(buf, <span class="hljs-keyword">sizeof</span>(buf))</span>) <span class="hljs-comment">// 读sizeof(buf)个字节到buf中，并返回读到的字节数</span></span><span class="hljs-function">conn.<span class="hljs-title">read_n</span><span class="hljs-params">()</span> <span class="hljs-comment">// </span></span><span class="hljs-function">conn.<span class="hljs-title">address</span><span class="hljs-params">()</span> <span class="hljs-comment">// 服务器的地址</span></span><span class="hljs-function">conn.<span class="hljs-title">peer_address</span><span class="hljs-params">()</span></span><span class="hljs-function">conn.<span class="hljs-title">shutdown</span><span class="hljs-params">(SHUT_WR)</span></span></code></pre></div><p><strong>例子</strong>- 单线程</p><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">"sockpp/tcp_connector.h"</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">"sockpp/version.h"</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std::chrono;<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span>* argv[])</span></span><span class="hljs-function"></span>{cout &lt;&lt; <span class="hljs-string">"Sample TCP echo client for 'sockpp' "</span>&lt;&lt; sockpp::SOCKPP_VERSION &lt;&lt; <span class="hljs-string">'\n'</span> &lt;&lt; endl;string host = (argc &gt; <span class="hljs-number">1</span>) ? argv[<span class="hljs-number">1</span>] : <span class="hljs-string">"localhost"</span>;<span class="hljs-type">in_port_t</span> port = (argc &gt; <span class="hljs-number">2</span>) ? <span class="hljs-built_in">atoi</span>(argv[<span class="hljs-number">2</span>]) : <span class="hljs-number">12345</span>;sockpp::socket_initializer sockInit;<span class="hljs-comment">// Implicitly creates an inet_address from {host,port}</span><span class="hljs-comment">// and then tries the connection.</span><span class="hljs-function">sockpp::tcp_connector <span class="hljs-title">conn</span><span class="hljs-params">({host, port})</span></span>;<span class="hljs-keyword">if</span> (!conn) {cerr &lt;&lt; <span class="hljs-string">"Error connecting to server at "</span>&lt;&lt; sockpp::<span class="hljs-built_in">inet_address</span>(host, port)&lt;&lt; <span class="hljs-string">"\n\t"</span> &lt;&lt; conn.<span class="hljs-built_in">last_error_str</span>() &lt;&lt; endl;<span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;}cout &lt;&lt; <span class="hljs-string">"Created a connection from "</span> &lt;&lt; conn.<span class="hljs-built_in">address</span>() &lt;&lt; endl;cout &lt;&lt; <span class="hljs-string">"Created a connection to "</span> &lt;&lt; conn.<span class="hljs-built_in">peer_address</span>() &lt;&lt; endl;        <span class="hljs-comment">// Set a timeout for the responses</span>    <span class="hljs-keyword">if</span> (!conn.<span class="hljs-built_in">read_timeout</span>(<span class="hljs-built_in">seconds</span>(<span class="hljs-number">5</span>))) {        cerr &lt;&lt; <span class="hljs-string">"Error setting timeout on TCP stream: "</span>                &lt;&lt; conn.<span class="hljs-built_in">last_error_str</span>() &lt;&lt; endl;    }string s, sret;<span class="hljs-keyword">while</span> (<span class="hljs-built_in">getline</span>(cin, s) &amp;&amp; !s.<span class="hljs-built_in">empty</span>()) {<span class="hljs-keyword">if</span> (conn.<span class="hljs-built_in">write</span>(s) != <span class="hljs-built_in">ssize_t</span>(s.<span class="hljs-built_in">length</span>())) {cerr &lt;&lt; <span class="hljs-string">"Error writing to the TCP stream: "</span>&lt;&lt; conn.<span class="hljs-built_in">last_error_str</span>() &lt;&lt; endl;<span class="hljs-keyword">break</span>;}sret.<span class="hljs-built_in">resize</span>(s.<span class="hljs-built_in">length</span>());<span class="hljs-type">ssize_t</span> n = conn.<span class="hljs-built_in">read_n</span>(&amp;sret[<span class="hljs-number">0</span>], s.<span class="hljs-built_in">length</span>());<span class="hljs-keyword">if</span> (n != <span class="hljs-built_in">ssize_t</span>(s.<span class="hljs-built_in">length</span>())) {cerr &lt;&lt; <span class="hljs-string">"Error reading from TCP stream: "</span>&lt;&lt; conn.<span class="hljs-built_in">last_error_str</span>() &lt;&lt; endl;<span class="hljs-keyword">break</span>;}cout &lt;&lt; sret &lt;&lt; endl;}<span class="hljs-keyword">return</span> (!conn) ? <span class="hljs-number">1</span> : <span class="hljs-number">0</span>;}</code></pre></div><h4><span id="ipv6-tcp6-clien">IPV6:tcp6_clien</span><a href="#ipv6-tcp6-clien" class="header-anchor">#</a></h4><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-function">sockpp::tcp6_connector <span class="hljs-title">conn</span><span class="hljs-params">({host, port})</span></span>;sockpp::<span class="hljs-built_in">inet6_address</span>(host, port);conn.<span class="hljs-built_in">last_error_str</span>();conn.<span class="hljs-built_in">read_timeout</span>(<span class="hljs-built_in">seconds</span>(<span class="hljs-number">5</span>));conn.<span class="hljs-built_in">last_error_str</span>();conn.<span class="hljs-built_in">write</span>(s);</code></pre></div><p><strong>例子</strong></p><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">"sockpp/tcp6_connector.h"</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">"sockpp/version.h"</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std::chrono;<span class="hljs-comment">// --------------------------------------------------------------------------</span><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span>* argv[])</span></span><span class="hljs-function"></span>{cout &lt;&lt; <span class="hljs-string">"Sample IPv6 TCP echo client for 'sockpp' "</span>&lt;&lt; sockpp::SOCKPP_VERSION &lt;&lt; <span class="hljs-string">'\n'</span> &lt;&lt; endl;std::string host = (argc &gt; <span class="hljs-number">1</span>) ? argv[<span class="hljs-number">1</span>] : <span class="hljs-string">"::1"</span>;<span class="hljs-type">in_port_t</span> port = (argc &gt; <span class="hljs-number">2</span>) ? <span class="hljs-built_in">atoi</span>(argv[<span class="hljs-number">2</span>]) : <span class="hljs-number">12345</span>;sockpp::socket_initializer sockInit;<span class="hljs-comment">// Implicitly creates an inet6_address from {host,port}</span><span class="hljs-comment">// and then tries the connection.</span><span class="hljs-function">sockpp::tcp6_connector <span class="hljs-title">conn</span><span class="hljs-params">({host, port})</span></span>;<span class="hljs-keyword">if</span> (!conn) {cerr &lt;&lt; <span class="hljs-string">"Error connecting to server at "</span>&lt;&lt; sockpp::<span class="hljs-built_in">inet6_address</span>(host, port)&lt;&lt; <span class="hljs-string">"\n\t"</span> &lt;&lt; conn.<span class="hljs-built_in">last_error_str</span>() &lt;&lt; endl;<span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;}cout &lt;&lt; <span class="hljs-string">"Created a connection from "</span> &lt;&lt; conn.<span class="hljs-built_in">address</span>() &lt;&lt; endl;cout &lt;&lt; <span class="hljs-string">"Created a connection to "</span> &lt;&lt; conn.<span class="hljs-built_in">peer_address</span>() &lt;&lt; endl;        <span class="hljs-comment">// Set a timeout for the responses</span>    <span class="hljs-keyword">if</span> (!conn.<span class="hljs-built_in">read_timeout</span>(<span class="hljs-built_in">seconds</span>(<span class="hljs-number">5</span>))) {        cerr &lt;&lt; <span class="hljs-string">"Error setting timeout on TCP stream: "</span>                &lt;&lt; conn.<span class="hljs-built_in">last_error_str</span>() &lt;&lt; endl;    }string s, sret;<span class="hljs-keyword">while</span> (<span class="hljs-built_in">getline</span>(cin, s) &amp;&amp; !s.<span class="hljs-built_in">empty</span>()) {<span class="hljs-keyword">if</span> (conn.<span class="hljs-built_in">write</span>(s) != <span class="hljs-built_in">ssize_t</span>(s.<span class="hljs-built_in">length</span>())) {cerr &lt;&lt; <span class="hljs-string">"Error writing to the TCP stream: "</span>&lt;&lt; conn.<span class="hljs-built_in">last_error_str</span>() &lt;&lt; endl;<span class="hljs-keyword">break</span>;}sret.<span class="hljs-built_in">resize</span>(s.<span class="hljs-built_in">length</span>());<span class="hljs-type">ssize_t</span> n = conn.<span class="hljs-built_in">read_n</span>(&amp;sret[<span class="hljs-number">0</span>], s.<span class="hljs-built_in">length</span>());<span class="hljs-keyword">if</span> (n != <span class="hljs-built_in">ssize_t</span>(s.<span class="hljs-built_in">length</span>())) {cerr &lt;&lt; <span class="hljs-string">"Error reading from TCP stream: "</span>&lt;&lt; conn.<span class="hljs-built_in">last_error_str</span>() &lt;&lt; endl;<span class="hljs-keyword">break</span>;}cout &lt;&lt; sret &lt;&lt; endl;}<span class="hljs-keyword">return</span> (!conn) ? <span class="hljs-number">1</span> : <span class="hljs-number">0</span>;}</code></pre></div><h3><span id="tcp-server">TCP Server</span><a href="#tcp-server" class="header-anchor">#</a></h3><h4><span id="ipv4-tcp-server"><strong>IPV4:tcp_server</strong></span><a href="#ipv4-tcp-server" class="header-anchor">#</a></h4><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-function">sockpp::tcp_acceptor <span class="hljs-title">acc</span><span class="hljs-params">(port)</span> <span class="hljs-comment">// 绑定port,并创建一个sockpp::tcp_socket的acc</span></span><span class="hljs-function">sockpp::tcp_socket sock </span>= acc.<span class="hljs-built_in">accept</span>(&amp;peer) <span class="hljs-comment">// 接受一个tcp连接并返回sockpp::tcp_socket</span></code></pre></div><p><strong>例子-多线程</strong></p><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;thread&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">"sockpp/tcp_acceptor.h"</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">"sockpp/version.h"</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-comment">// --------------------------------------------------------------------------</span><span class="hljs-comment">// The thread function. This is run in a separate thread for each socket.</span><span class="hljs-comment">// Ownership of the socket object is transferred to the thread, so when this</span><span class="hljs-comment">// function exits, the socket is automatically closed.</span><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">run_echo</span><span class="hljs-params">(sockpp::tcp_socket sock)</span></span><span class="hljs-function"></span>{<span class="hljs-type">ssize_t</span> n;<span class="hljs-type">char</span> buf[<span class="hljs-number">512</span>];<span class="hljs-keyword">while</span> ((n = sock.<span class="hljs-built_in">read</span>(buf, <span class="hljs-built_in">sizeof</span>(buf))) &gt; <span class="hljs-number">0</span>)sock.<span class="hljs-built_in">write_n</span>(buf, n);cout &lt;&lt; <span class="hljs-string">"Connection closed from "</span> &lt;&lt; sock.<span class="hljs-built_in">peer_address</span>() &lt;&lt; endl;}<span class="hljs-comment">// --------------------------------------------------------------------------</span><span class="hljs-comment">// The main thread runs the TCP port acceptor. Each time a connection is</span><span class="hljs-comment">// made, a new thread is spawned to handle it, leaving this main thread to</span><span class="hljs-comment">// immediately wait for the next connection.</span><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span>* argv[])</span></span><span class="hljs-function"></span>{cout &lt;&lt; <span class="hljs-string">"Sample TCP echo server for 'sockpp' "</span>&lt;&lt; sockpp::SOCKPP_VERSION &lt;&lt; <span class="hljs-string">'\n'</span> &lt;&lt; endl;<span class="hljs-type">in_port_t</span> port = (argc &gt; <span class="hljs-number">1</span>) ? <span class="hljs-built_in">atoi</span>(argv[<span class="hljs-number">1</span>]) : <span class="hljs-number">12345</span>;sockpp::socket_initializer sockInit;<span class="hljs-function">sockpp::tcp_acceptor <span class="hljs-title">acc</span><span class="hljs-params">(port)</span></span>;<span class="hljs-keyword">if</span> (!acc) {cerr &lt;&lt; <span class="hljs-string">"Error creating the acceptor: "</span> &lt;&lt; acc.<span class="hljs-built_in">last_error_str</span>() &lt;&lt; endl;<span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;}    <span class="hljs-comment">//cout &lt;&lt; "Acceptor bound to address: " &lt;&lt; acc.address() &lt;&lt; endl;</span>cout &lt;&lt; <span class="hljs-string">"Awaiting connections on port "</span> &lt;&lt; port &lt;&lt; <span class="hljs-string">"..."</span> &lt;&lt; endl;<span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) {sockpp::inet_address peer;<span class="hljs-comment">// Accept a new client connection</span>sockpp::tcp_socket sock = acc.<span class="hljs-built_in">accept</span>(&amp;peer);cout &lt;&lt; <span class="hljs-string">"Received a connection request from "</span> &lt;&lt; peer &lt;&lt; endl;<span class="hljs-keyword">if</span> (!sock) {cerr &lt;&lt; <span class="hljs-string">"Error accepting incoming connection: "</span> &lt;&lt; acc.<span class="hljs-built_in">last_error_str</span>() &lt;&lt; endl;}<span class="hljs-keyword">else</span> {<span class="hljs-comment">// Create a thread and transfer the new stream to it.</span>thread <span class="hljs-built_in">thr</span>(run_echo, std::<span class="hljs-built_in">move</span>(sock));thr.<span class="hljs-built_in">detach</span>();}}<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;}</code></pre></div><h4><span id="ipv6-tcp6-server"><strong>IPV6:tcp6_server</strong></span><a href="#ipv6-tcp6-server" class="header-anchor">#</a></h4><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-function">sockpp::tcp6_acceptor <span class="hljs-title">acc</span><span class="hljs-params">(port)</span></span>;sockpp::inet6_address peer;acc.<span class="hljs-built_in">accept</span>(&amp;peer);</code></pre></div><p><strong>例子 - 多线程</strong></p><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;thread&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">"sockpp/tcp6_acceptor.h"</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">"sockpp/version.h"</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-comment">// --------------------------------------------------------------------------</span><span class="hljs-comment">// The thread function. This is run in a separate thread for each socket.</span><span class="hljs-comment">// Ownership of the socket object is transferred to the thread, so when this</span><span class="hljs-comment">// function exits, the socket is automatically closed.</span><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">run_echo</span><span class="hljs-params">(sockpp::tcp6_socket sock)</span></span><span class="hljs-function"></span>{<span class="hljs-type">ssize_t</span> n;<span class="hljs-type">char</span> buf[<span class="hljs-number">512</span>];    <span class="hljs-keyword">while</span> ((n = sock.<span class="hljs-built_in">read</span>(buf, <span class="hljs-built_in">sizeof</span>(buf))) &gt; <span class="hljs-number">0</span>)sock.<span class="hljs-built_in">write_n</span>(buf, n);cout &lt;&lt; <span class="hljs-string">"Connection closed from "</span> &lt;&lt; sock.<span class="hljs-built_in">peer_address</span>() &lt;&lt; endl;}<span class="hljs-comment">// --------------------------------------------------------------------------</span><span class="hljs-comment">// The main thread runs the TCP port acceptor. Each time a connection is</span><span class="hljs-comment">// made, a new thread is spawned to handle it, leaving this main thread to</span><span class="hljs-comment">// immediately wait for the next connection.</span><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span>* argv[])</span></span><span class="hljs-function"></span>{cout &lt;&lt; <span class="hljs-string">"Sample IPv6 TCP echo server for 'sockpp' "</span>&lt;&lt; sockpp::SOCKPP_VERSION &lt;&lt; <span class="hljs-string">'\n'</span> &lt;&lt; endl;<span class="hljs-type">in_port_t</span> port = (argc &gt; <span class="hljs-number">1</span>) ? <span class="hljs-built_in">atoi</span>(argv[<span class="hljs-number">1</span>]) : <span class="hljs-number">12345</span>;sockpp::socket_initializer sockInit;<span class="hljs-function">sockpp::tcp6_acceptor <span class="hljs-title">acc</span><span class="hljs-params">(port)</span></span>;<span class="hljs-keyword">if</span> (!acc) {cerr &lt;&lt; <span class="hljs-string">"Error creating the acceptor: "</span> &lt;&lt; acc.<span class="hljs-built_in">last_error_str</span>() &lt;&lt; endl;<span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;}cout &lt;&lt; <span class="hljs-string">"Awaiting connections on port "</span> &lt;&lt; port &lt;&lt; <span class="hljs-string">"..."</span> &lt;&lt; endl;<span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) {sockpp::inet6_address peer;<span class="hljs-comment">// Accept a new client connection</span>sockpp::tcp6_socket sock = acc.<span class="hljs-built_in">accept</span>(&amp;peer);cout &lt;&lt; <span class="hljs-string">"Received a connection request from "</span> &lt;&lt; peer &lt;&lt; endl;<span class="hljs-keyword">if</span> (!sock) {cerr &lt;&lt; <span class="hljs-string">"Error accepting incoming connection: "</span> &lt;&lt; acc.<span class="hljs-built_in">last_error_str</span>() &lt;&lt; endl;}<span class="hljs-keyword">else</span> {<span class="hljs-comment">// Create a thread and transfer the new stream to it.</span>thread <span class="hljs-built_in">thr</span>(run_echo, std::<span class="hljs-built_in">move</span>(sock));thr.<span class="hljs-built_in">detach</span>();}}<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;}</code></pre></div><h2><span id="udp">UDP</span><a href="#udp" class="header-anchor">#</a></h2><h3><span id="udp-clien">UDP Clien</span><a href="#udp-clien" class="header-anchor">#</a></h3><h4><span id="ipv4-udp-clien">IPV4:udp_clien</span><a href="#ipv4-udp-clien" class="header-anchor">#</a></h4><div class="code-wrapper"><pre><code class="hljs c++">sockpp::socket_initializer sockInit;sockpp::udp_socket sock;sock.<span class="hljs-built_in">connect</span>(sockpp::<span class="hljs-built_in">inet_address</span>(host, port));sock.<span class="hljs-built_in">last_error_str</span>();      <span class="hljs-function">sockpp::inet_address <span class="hljs-title">addr</span><span class="hljs-params">(<span class="hljs-string">"localhost"</span>, <span class="hljs-number">12345</span>)</span></span>;sock.<span class="hljs-built_in">send</span>(s);sock.<span class="hljs-built_in">send_to</span>(msg, addr);<span class="hljs-type">char</span> buf[<span class="hljs-number">16</span>];<span class="hljs-type">ssize_t</span> n = sock.<span class="hljs-built_in">recv</span>(buf, <span class="hljs-built_in">sizeof</span>(buf), &amp;srcAddr);</code></pre></div><p>例子：</p><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">"sockpp/udp_socket.h"</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">"sockpp/version.h"</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-comment">// --------------------------------------------------------------------------</span><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span>* argv[])</span></span><span class="hljs-function"></span>{cout &lt;&lt; <span class="hljs-string">"Sample UDP echo client for 'sockpp' "</span>&lt;&lt; sockpp::SOCKPP_VERSION &lt;&lt; <span class="hljs-string">'\n'</span> &lt;&lt; endl;string host = (argc &gt; <span class="hljs-number">1</span>) ? argv[<span class="hljs-number">1</span>] : <span class="hljs-string">"localhost"</span>;<span class="hljs-type">in_port_t</span> port = (argc &gt; <span class="hljs-number">2</span>) ? <span class="hljs-built_in">atoi</span>(argv[<span class="hljs-number">2</span>]) : <span class="hljs-number">12345</span>;sockpp::socket_initializer sockInit;sockpp::udp_socket sock;<span class="hljs-keyword">if</span> (!sock.<span class="hljs-built_in">connect</span>(sockpp::<span class="hljs-built_in">inet_address</span>(host, port))) {cerr &lt;&lt; <span class="hljs-string">"Error connecting to server at "</span> &lt;&lt; host &lt;&lt; <span class="hljs-string">":"</span> &lt;&lt; port &lt;&lt; <span class="hljs-string">"\n\t"</span> &lt;&lt; sock.<span class="hljs-built_in">last_error_str</span>() &lt;&lt; endl;<span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;}cout &lt;&lt; <span class="hljs-string">"Created UDP socket at: "</span> &lt;&lt; sock.<span class="hljs-built_in">address</span>() &lt;&lt; endl;string s, sret;<span class="hljs-keyword">while</span> (<span class="hljs-built_in">getline</span>(cin, s) &amp;&amp; !s.<span class="hljs-built_in">empty</span>()) {<span class="hljs-keyword">if</span> (sock.<span class="hljs-built_in">send</span>(s) != <span class="hljs-built_in">ssize_t</span>(s.<span class="hljs-built_in">length</span>())) {cerr &lt;&lt; <span class="hljs-string">"Error writing to the UDP socket: "</span>&lt;&lt; sock.<span class="hljs-built_in">last_error_str</span>() &lt;&lt; endl;<span class="hljs-keyword">break</span>;}sret.<span class="hljs-built_in">resize</span>(s.<span class="hljs-built_in">length</span>());<span class="hljs-type">ssize_t</span> n = sock.<span class="hljs-built_in">recv</span>(&amp;sret[<span class="hljs-number">0</span>], s.<span class="hljs-built_in">length</span>());<span class="hljs-keyword">if</span> (n != <span class="hljs-built_in">ssize_t</span>(s.<span class="hljs-built_in">length</span>())) {cerr &lt;&lt; <span class="hljs-string">"Error reading from UDP socket: "</span>&lt;&lt; sock.<span class="hljs-built_in">last_error_str</span>() &lt;&lt; endl;<span class="hljs-keyword">break</span>;}cout &lt;&lt; sret &lt;&lt; endl;}<span class="hljs-keyword">return</span> (!sock) ? <span class="hljs-number">1</span> : <span class="hljs-number">0</span>;}</code></pre></div><h4><span id="ipv6-udp6-clien">IPV6:udp6_clien</span><a href="#ipv6-udp6-clien" class="header-anchor">#</a></h4><div class="code-wrapper"><pre><code class="hljs c++">sockpp::socket_initializer sockInit;sockpp::udp6_socket sock;sock.<span class="hljs-built_in">connect</span>(sockpp::<span class="hljs-built_in">inet6_address</span>(host, port));sock.<span class="hljs-built_in">last_error_str</span>();sock.<span class="hljs-built_in">address</span>();sock.<span class="hljs-built_in">send</span>(s);sock.<span class="hljs-built_in">recv</span>(&amp;sret[<span class="hljs-number">0</span>], s.<span class="hljs-built_in">length</span>());</code></pre></div><p>例子</p><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">"sockpp/udp6_socket.h"</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">"sockpp/version.h"</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-comment">// --------------------------------------------------------------------------</span><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span>* argv[])</span></span><span class="hljs-function"></span>{cout &lt;&lt; <span class="hljs-string">"Sample IPv6 UDP echo client for 'sockpp' "</span>&lt;&lt; sockpp::SOCKPP_VERSION &lt;&lt; <span class="hljs-string">'\n'</span> &lt;&lt; endl;string host = (argc &gt; <span class="hljs-number">1</span>) ? argv[<span class="hljs-number">1</span>] : <span class="hljs-string">"localhost"</span>;<span class="hljs-type">in_port_t</span> port = (argc &gt; <span class="hljs-number">2</span>) ? <span class="hljs-built_in">atoi</span>(argv[<span class="hljs-number">2</span>]) : <span class="hljs-number">12345</span>;sockpp::socket_initializer sockInit;sockpp::udp6_socket sock;<span class="hljs-keyword">if</span> (!sock.<span class="hljs-built_in">connect</span>(sockpp::<span class="hljs-built_in">inet6_address</span>(host, port))) {cerr &lt;&lt; <span class="hljs-string">"Error connecting to server at "</span> &lt;&lt; host &lt;&lt; <span class="hljs-string">":"</span> &lt;&lt; port &lt;&lt; <span class="hljs-string">"\n\t"</span> &lt;&lt; sock.<span class="hljs-built_in">last_error_str</span>() &lt;&lt; endl;<span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;}cout &lt;&lt; <span class="hljs-string">"Created UDP socket at: "</span> &lt;&lt; sock.<span class="hljs-built_in">address</span>() &lt;&lt; endl;string s, sret;<span class="hljs-keyword">while</span> (<span class="hljs-built_in">getline</span>(cin, s) &amp;&amp; !s.<span class="hljs-built_in">empty</span>()) {<span class="hljs-keyword">if</span> (sock.<span class="hljs-built_in">send</span>(s) != <span class="hljs-built_in">ssize_t</span>(s.<span class="hljs-built_in">length</span>())) {cerr &lt;&lt; <span class="hljs-string">"Error writing to the UDP socket: "</span>&lt;&lt; sock.<span class="hljs-built_in">last_error_str</span>() &lt;&lt; endl;<span class="hljs-keyword">break</span>;}sret.<span class="hljs-built_in">resize</span>(s.<span class="hljs-built_in">length</span>());<span class="hljs-type">ssize_t</span> n = sock.<span class="hljs-built_in">recv</span>(&amp;sret[<span class="hljs-number">0</span>], s.<span class="hljs-built_in">length</span>());<span class="hljs-keyword">if</span> (n != <span class="hljs-built_in">ssize_t</span>(s.<span class="hljs-built_in">length</span>())) {cerr &lt;&lt; <span class="hljs-string">"Error reading from UDP socket: "</span>&lt;&lt; sock.<span class="hljs-built_in">last_error_str</span>() &lt;&lt; endl;<span class="hljs-keyword">break</span>;}cout &lt;&lt; sret &lt;&lt; endl;}<span class="hljs-keyword">return</span> (!sock) ? <span class="hljs-number">1</span> : <span class="hljs-number">0</span>;}</code></pre></div><h3><span id="udp-server">UDP Server</span><a href="#udp-server" class="header-anchor">#</a></h3><h4><span id="ipv4-udp-server">IPV4:udp_server</span><a href="#ipv4-udp-server" class="header-anchor">#</a></h4><div class="code-wrapper"><pre><code class="hljs c++">sockpp::socket_initializer sockInit;sockpp::udp_socketudpsock;udpsock.<span class="hljs-built_in">bind</span>(sockpp::<span class="hljs-built_in">inet_address</span>(<span class="hljs-string">"localhost"</span>, port));udpsock.<span class="hljs-built_in">last_error_str</span>();</code></pre></div><p>例子：</p><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;thread&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">"sockpp/udp_socket.h"</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">"sockpp/version.h"</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-comment">// --------------------------------------------------------------------------</span><span class="hljs-comment">// The thread function. This is run in a separate thread for each socket.</span><span class="hljs-comment">// Ownership of the socket object is transferred to the thread, so when this</span><span class="hljs-comment">// function exits, the socket is automatically closed.</span><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> UDPSOCK&gt;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">run_echo</span><span class="hljs-params">(UDPSOCK sock)</span></span><span class="hljs-function"></span>{<span class="hljs-type">ssize_t</span> n;<span class="hljs-type">char</span> buf[<span class="hljs-number">512</span>];<span class="hljs-comment">// Each UDP socket type knows its address type as `addr_t`</span><span class="hljs-keyword">typename</span> UDPSOCK::<span class="hljs-type">addr_t</span> srcAddr;<span class="hljs-comment">// Read some data, also getting the address of the sender,</span><span class="hljs-comment">// then just send it back.</span><span class="hljs-keyword">while</span> ((n = sock.<span class="hljs-built_in">recv_from</span>(buf, <span class="hljs-built_in">sizeof</span>(buf), &amp;srcAddr)) &gt; <span class="hljs-number">0</span>)sock.<span class="hljs-built_in">send_to</span>(buf, n, srcAddr);}<span class="hljs-comment">// --------------------------------------------------------------------------</span><span class="hljs-comment">// The main thread creates the two UDP sockets (one each for IPv4 and IPv6),</span><span class="hljs-comment">// and then starts them running the echo function each in a separate thread.</span><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span>* argv[])</span></span><span class="hljs-function"></span>{cout &lt;&lt; <span class="hljs-string">"Sample UDP echo server for 'sockpp' "</span>&lt;&lt; sockpp::SOCKPP_VERSION &lt;&lt; <span class="hljs-string">'\n'</span> &lt;&lt; endl;<span class="hljs-type">in_port_t</span> port = (argc &gt; <span class="hljs-number">1</span>) ? <span class="hljs-built_in">atoi</span>(argv[<span class="hljs-number">1</span>]) : <span class="hljs-number">12345</span>;sockpp::socket_initializer sockInit;sockpp::udp_socketudpsock;<span class="hljs-keyword">if</span> (!udpsock) {cerr &lt;&lt; <span class="hljs-string">"Error creating the UDP v4 socket: "</span> &lt;&lt; udpsock.<span class="hljs-built_in">last_error_str</span>() &lt;&lt; endl;<span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;}<span class="hljs-keyword">if</span> (!udpsock.<span class="hljs-built_in">bind</span>(sockpp::<span class="hljs-built_in">inet_address</span>(<span class="hljs-string">"localhost"</span>, port))) {cerr &lt;&lt; <span class="hljs-string">"Error binding the UDP v4 socket: "</span> &lt;&lt; udpsock.<span class="hljs-built_in">last_error_str</span>() &lt;&lt; endl;<span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;}<span class="hljs-comment">// Spin up a thread to run the IPv4 socket.</span><span class="hljs-function">thread <span class="hljs-title">thr</span><span class="hljs-params">(run_echo&lt;sockpp::udp_socket&gt;, std::move(udpsock))</span></span>;thr.<span class="hljs-built_in">detach</span>();<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;}</code></pre></div><h4><span id="ipv6-udp6-server">IPV6:udp6_server</span><a href="#ipv6-udp6-server" class="header-anchor">#</a></h4><div class="code-wrapper"><pre><code class="hljs c++">sockpp::socket_initializer sockInit;sockpp::udp6_socketudp6sock;udp6sock.<span class="hljs-built_in">last_error_str</span>();udp6sock.<span class="hljs-built_in">bind</span>(sockpp::<span class="hljs-built_in">inet6_address</span>(<span class="hljs-string">"localhost"</span>, port));</code></pre></div><p>例子：</p><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;thread&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">"sockpp/udp6_socket.h"</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">"sockpp/version.h"</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-comment">// --------------------------------------------------------------------------</span><span class="hljs-comment">// The thread function. This is run in a separate thread for each socket.</span><span class="hljs-comment">// Ownership of the socket object is transferred to the thread, so when this</span><span class="hljs-comment">// function exits, the socket is automatically closed.</span><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> UDPSOCK&gt;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">run_echo</span><span class="hljs-params">(UDPSOCK sock)</span></span><span class="hljs-function"></span>{<span class="hljs-type">ssize_t</span> n;<span class="hljs-type">char</span> buf[<span class="hljs-number">512</span>];<span class="hljs-comment">// Each UDP socket type knows its address type as `addr_t`</span><span class="hljs-keyword">typename</span> UDPSOCK::<span class="hljs-type">addr_t</span> srcAddr;<span class="hljs-comment">// Read some data, also getting the address of the sender,</span><span class="hljs-comment">// then just send it back.</span><span class="hljs-keyword">while</span> ((n = sock.<span class="hljs-built_in">recv_from</span>(buf, <span class="hljs-built_in">sizeof</span>(buf), &amp;srcAddr)) &gt; <span class="hljs-number">0</span>)sock.<span class="hljs-built_in">send_to</span>(buf, n, srcAddr);}<span class="hljs-comment">// --------------------------------------------------------------------------</span><span class="hljs-comment">// The main thread creates the two UDP sockets (one each for IPv4 and IPv6),</span><span class="hljs-comment">// and then starts them running the echo function each in a separate thread.</span><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span>* argv[])</span></span><span class="hljs-function"></span>{cout &lt;&lt; <span class="hljs-string">"Sample UDP echo server for 'sockpp' "</span>&lt;&lt; sockpp::SOCKPP_VERSION &lt;&lt; <span class="hljs-string">'\n'</span> &lt;&lt; endl;<span class="hljs-type">in_port_t</span> port = (argc &gt; <span class="hljs-number">1</span>) ? <span class="hljs-built_in">atoi</span>(argv[<span class="hljs-number">1</span>]) : <span class="hljs-number">12345</span>;sockpp::socket_initializer sockInit;sockpp::udp6_socketudp6sock;<span class="hljs-keyword">if</span> (!udp6sock) {cerr &lt;&lt; <span class="hljs-string">"Error creating the UDP v6 socket: "</span> &lt;&lt; udp6sock.<span class="hljs-built_in">last_error_str</span>() &lt;&lt; endl;<span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;}<span class="hljs-keyword">if</span> (!udp6sock.<span class="hljs-built_in">bind</span>(sockpp::<span class="hljs-built_in">inet6_address</span>(<span class="hljs-string">"localhost"</span>, port))) {cerr &lt;&lt; <span class="hljs-string">"Error binding the UDP v6 socket: "</span> &lt;&lt; udp6sock.<span class="hljs-built_in">last_error_str</span>() &lt;&lt; endl;<span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;}<span class="hljs-comment">// Spin up a thread to run the IPv4 socket.</span><span class="hljs-function">thread <span class="hljs-title">thr</span><span class="hljs-params">(run_echo&lt;sockpp::udp6_socket&gt;, std::move(udp6sock))</span></span>;thr.<span class="hljs-built_in">detach</span>();<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;}</code></pre></div><h2><span id="unix">UNIX</span><a href="#unix" class="header-anchor">#</a></h2><h3><span id="unix-clien">UNIX Clien</span><a href="#unix-clien" class="header-anchor">#</a></h3><div class="code-wrapper"><pre><code class="hljs c++">sockpp::socket_initializer sockInit;sockpp::unix_connector conn;conn.<span class="hljs-built_in">connect</span>(sockpp::<span class="hljs-built_in">unix_address</span>(path));conn.<span class="hljs-built_in">last_error_str</span>();conn.<span class="hljs-built_in">peer_address</span>();</code></pre></div><p>例子：</p><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">"sockpp/unix_connector.h"</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">"sockpp/version.h"</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-comment">// --------------------------------------------------------------------------</span><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span>* argv[])</span></span><span class="hljs-function"></span>{cout &lt;&lt; <span class="hljs-string">"Sample Unix-domain echo client for 'sockpp' "</span>&lt;&lt; sockpp::SOCKPP_VERSION &lt;&lt; <span class="hljs-string">'\n'</span> &lt;&lt; endl;string path = (argc &gt; <span class="hljs-number">1</span>) ? argv[<span class="hljs-number">1</span>] : <span class="hljs-string">"/tmp/unechosvr.sock"</span>;sockpp::socket_initializer sockInit;sockpp::unix_connector conn;    <span class="hljs-type">bool</span> ok = conn.<span class="hljs-built_in">connect</span>(sockpp::<span class="hljs-built_in">unix_address</span>(path));<span class="hljs-keyword">if</span> (!ok) {cerr &lt;&lt; <span class="hljs-string">"Error connecting to UNIX socket at "</span> &lt;&lt; path&lt;&lt; <span class="hljs-string">"\n\t"</span> &lt;&lt; conn.<span class="hljs-built_in">last_error_str</span>() &lt;&lt; endl;<span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;}cout &lt;&lt; <span class="hljs-string">"Created a connection to '"</span> &lt;&lt; conn.<span class="hljs-built_in">peer_address</span>() &lt;&lt; <span class="hljs-string">"'"</span> &lt;&lt; endl;string s, sret;<span class="hljs-keyword">while</span> (<span class="hljs-built_in">getline</span>(cin, s) &amp;&amp; !s.<span class="hljs-built_in">empty</span>()) {<span class="hljs-keyword">if</span> (conn.<span class="hljs-built_in">write</span>(s) != (<span class="hljs-type">int</span>) s.<span class="hljs-built_in">length</span>()) {cerr &lt;&lt; <span class="hljs-string">"Error writing to the UNIX stream"</span> &lt;&lt; endl;<span class="hljs-keyword">break</span>;}sret.<span class="hljs-built_in">resize</span>(s.<span class="hljs-built_in">length</span>());<span class="hljs-type">int</span> n = conn.<span class="hljs-built_in">read_n</span>(&amp;sret[<span class="hljs-number">0</span>], s.<span class="hljs-built_in">length</span>());<span class="hljs-keyword">if</span> (n != (<span class="hljs-type">int</span>) s.<span class="hljs-built_in">length</span>()) {cerr &lt;&lt; <span class="hljs-string">"Error reading from UNIX stream"</span> &lt;&lt; endl;<span class="hljs-keyword">break</span>;}cout &lt;&lt; sret &lt;&lt; endl;}<span class="hljs-keyword">return</span> (!conn) ? <span class="hljs-number">1</span> : <span class="hljs-number">0</span>;}</code></pre></div><h3><span id="unix-server">UNIX Server</span><a href="#unix-server" class="header-anchor">#</a></h3><div class="code-wrapper"><pre><code class="hljs c++">sockpp::socket_initializer sockInit;sockpp::unix_acceptor acc;acc.<span class="hljs-built_in">open</span>(sockpp::<span class="hljs-built_in">unix_address</span>(path));acc.<span class="hljs-built_in">last_error_str</span>();acc.<span class="hljs-built_in">address</span>();acc.<span class="hljs-built_in">accept</span>();</code></pre></div><p>例子 - 多线程</p><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;thread&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">"sockpp/unix_acceptor.h"</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">"sockpp/version.h"</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-comment">// --------------------------------------------------------------------------</span><span class="hljs-comment">// The thread function. This is run in a separate thread for each socket.</span><span class="hljs-comment">// Ownership of the socket object is transferred to the thread, so when this</span><span class="hljs-comment">// function exits, the socket is automatically closed.</span><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">run_echo</span><span class="hljs-params">(sockpp::unix_socket sock)</span></span><span class="hljs-function"></span>{<span class="hljs-type">int</span> n;<span class="hljs-type">char</span> buf[<span class="hljs-number">512</span>];<span class="hljs-keyword">while</span> ((n = sock.<span class="hljs-built_in">read</span>(buf, <span class="hljs-built_in">sizeof</span>(buf))) &gt; <span class="hljs-number">0</span>)sock.<span class="hljs-built_in">write_n</span>(buf, n);cout &lt;&lt; <span class="hljs-string">"Connection closed"</span> &lt;&lt; endl;}<span class="hljs-comment">// --------------------------------------------------------------------------</span><span class="hljs-comment">// The main thread runs the UNIX acceptor.</span><span class="hljs-comment">// Each time a connection is made, a new thread is spawned to handle it,</span><span class="hljs-comment">// leaving this main thread to immediately wait for the next connection.</span><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span>* argv[])</span></span><span class="hljs-function"></span>{cout &lt;&lt; <span class="hljs-string">"Sample Unix-domain echo server for 'sockpp' "</span>&lt;&lt; sockpp::SOCKPP_VERSION &lt;&lt; <span class="hljs-string">'\n'</span> &lt;&lt; endl;string path = <span class="hljs-string">"/tmp/unechosvr.sock"</span>;<span class="hljs-keyword">if</span> (argc &gt; <span class="hljs-number">1</span>) {path = argv[<span class="hljs-number">1</span>];}sockpp::socket_initializer sockInit;sockpp::unix_acceptor acc;<span class="hljs-type">bool</span> ok = acc.<span class="hljs-built_in">open</span>(sockpp::<span class="hljs-built_in">unix_address</span>(path));<span class="hljs-keyword">if</span> (!ok) {cerr &lt;&lt; <span class="hljs-string">"Error creating the acceptor: "</span> &lt;&lt; acc.<span class="hljs-built_in">last_error_str</span>() &lt;&lt; endl;<span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;}    cout &lt;&lt; <span class="hljs-string">"Acceptor bound to address: '"</span> &lt;&lt; acc.<span class="hljs-built_in">address</span>() &lt;&lt; <span class="hljs-string">"'..."</span> &lt;&lt; endl;<span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) {<span class="hljs-comment">// Accept a new client connection</span><span class="hljs-keyword">auto</span> sock = acc.<span class="hljs-built_in">accept</span>();cout &lt;&lt; <span class="hljs-string">"Received a connection"</span> &lt;&lt; endl;<span class="hljs-keyword">if</span> (!sock) {cerr &lt;&lt; <span class="hljs-string">"Error accepting incoming connection: "</span> &lt;&lt; acc.<span class="hljs-built_in">last_error_str</span>() &lt;&lt; endl;}<span class="hljs-keyword">else</span> {<span class="hljs-comment">// Create a thread and transfer the new stream to it.</span>thread <span class="hljs-built_in">thr</span>(run_echo, std::<span class="hljs-built_in">move</span>(sock));thr.<span class="hljs-built_in">detach</span>();}}<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;}</code></pre></div>]]></content>
    
    
    
    <tags>
      
      <tag>C++</tag>
      
      <tag>TCP/IP</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Oracle数据库介绍</title>
    <link href="/2022/01/09/%E6%95%B0%E6%8D%AE%E5%BA%93%E4%BB%8B%E7%BB%8D/"/>
    <url>/2022/01/09/%E6%95%B0%E6%8D%AE%E5%BA%93%E4%BB%8B%E7%BB%8D/</url>
    
    <content type="html"><![CDATA[<div class="toc"><!-- toc --><ul><li><a href="#shu-ju-ku-jie-shao">数据库介绍</a></li><li><a href="#1-oracle-de-ti-xi-jie-gou">1 Oracle的体系结构</a><ul><li><a href="#1-1-biao-kong-jian-he-shu-ju-wen-jian">1.1 表空间和数据文件</a></li><li><a href="#1-2-duan-qu-kuai">1.2 段、区、块</a></li><li><a href="#1-3-dba">1.3 DBA</a></li><li><a href="#1-4-ru-he-qi-dong-shu-ju-ku-fu-wu">1.4 如何启动数据库服务</a></li><li><a href="#1-5-ru-he-deng-lu-shu-ju-ku-fu-wu">1.5 如何登陆数据库服务</a></li><li><a href="#1-6-guan-chuan-zhe-men-ke-cheng-de-fang-an">1.6 贯穿这门课程的方案</a></li></ul></li><li><a href="#2-ji-ben-de-sql-select-yu-ju">2基本的SQL select语句</a><ul><li><a href="#2-1-sqlplus-de-ji-ben-cao-zuo">2.1 sqlplus的基本操作</a></li><li><a href="#2-2-ji-ben-de-select-yu-ju">2.2 基本的select语句</a></li><li><a href="#2-3-sql-yu-ju-shi-yong-zhu-yi-shi-xiang">2.3 SQL语句使用注意事项</a></li><li><a href="#2-4-suan-shu-yun-suan">2.4 算数运算 + - * /</a></li><li><a href="#2-5-null-zhi">2.5 NULL值</a></li><li><a href="#2-6-lian-jie-fu">2.6 连接符</a></li><li><a href="#2-7-sql-he-sqlplus">2.7 SQL和sqlplus</a></li></ul></li><li><a href="#3-guo-lu-he-pai-xu-shu-ju">3 过滤和排序数据</a><ul><li><a href="#3-1-where-tiao-jian-guo-lu">3.1 where条件过滤</a></li></ul></li><li><a href="#4-dan-xing-han-shu">4 单行函数</a><ul><li><a href="#4-1-zi-fu-han-shu">4.1 字符函数</a></li><li><a href="#4-2-shu-zhi-han-shu">4.2 数值函数</a></li><li><a href="#4-3-shi-jian-han-shu">4.3 时间函数</a></li><li><a href="#4-4-ri-qi-han-shu">4.4 日期函数</a></li><li><a href="#4-5-zhuan-huan-han-shu">4.5 转换函数</a></li><li><a href="#4-6-tong-yong-han-shu-liao-jie">4.6 通用函数(了解)</a></li><li><a href="#4-7-tiao-jian-biao-da-shi">4.7 条件表达式</a></li></ul></li><li><a href="#5-fen-zu-han-shu">5 分组函数</a><ul><li><a href="#5-1-fen-zu-han-shu">5.1分组函数</a></li><li><a href="#5-2-fen-zu-shu-ju">5.2 分组数据</a></li><li><a href="#5-3-having">5.3 Having</a></li></ul></li><li><a href="#6-duo-biao-cha-xun">6 多表查询</a><ul><li><a href="#6-1-deng-zhi-lian-jie">6.1 等值连接：</a></li><li><a href="#6-2-bu-deng-zhi-lian-jie">6.2 不等值连接：</a></li><li><a href="#6-3-wai-lian-jie">6.3 外链接：</a></li><li><a href="#6-4-zi-lian-jie">6.4 自连接：</a></li></ul></li><li><a href="#7-zi-cha-xun">7 子查询</a><ul><li><a href="#7-1-ding-yi-zi-cha-xun-xu-yao-zhu-yi-de-wen-ti">7.1 定义子查询 需要注意的问题</a></li><li><a href="#7-2-zhu-zi-cha-xun-zai-bu-tong-biao-jian-jin-xing">7.2 主、子查询在不同表间进行。</a></li><li><a href="#7-3-zai-zhu-cha-xun-de-where-select-having-from-fang-zhi-zi-cha-xun">7.3 在主查询的where select having from 放置子查询</a></li><li><a href="#7-4-zai-from-hou-mian-fang-zhi-de-zi-cha-xun">7.4 在from后面放置的子查询(***)</a></li><li><a href="#7-5-dan-xing-zi-cha-xun-zhi-neng-shi-yong-dan-xing-cao-zuo-fu-duo-xing-zi-cha-xun-zhi-neng-shi-yong-duo-xing-cao-zuo-fu">7.5 单行子查询只能使用单行操作符；多行子查询只能使用多行操作符</a></li><li><a href="#zi-cha-xun-zhong-null">子查询中null</a></li></ul></li></ul><ul><li><a href="#deng-jie-yu">等价于</a><ul><li><a href="#yi-ban-bu-zai-zi-cha-xun-zhong-shi-yong-order-by">一般不在子查询中使用order by</a></li><li><a href="#yi-ban-xian-zhi-xing-zi-cha-xun-zai-zhi-xing-zhu-cha-xun">一般先执行子查询，再执行主查询</a></li></ul><ul><li><a href="#8-ji-he-yun-suan">8 集合运算</a></li></ul></li><li><a href="#jia-shang">加上</a><ul><li><a href="#8-1-ji-he-yun-suan-fu">8.1 集合运算符</a></li><li><a href="#8-2-ji-he-yun-suan-xu-yao-zhu-yi-de-wen-ti">8.2 集合运算需要注意的问题：</a></li></ul></li><li><a href="#9-shu-ju-chu-li">9 数据处理</a><ul><li><a href="#sql-yu-yan-de-lei-xing">SQL语言的类型：</a></li><li><a href="#cha-ru-shu-ju-insert">插入数据insert：</a></li></ul><ul><li><a href="#10-shan-chu-shu-ju-delete">10 删除数据delete</a><ul><li><a href="#delete-he-truncate-de-qu-bie">delete 和 truncate的区别：</a></li><li><a href="#delete-he-truncate-de-shi-xiao-xing">delete和truncate的时效性</a></li><li><a href="#shi-wu">事务</a></li></ul></li><li><a href="#11-chuang-jian-he-guan-li-biao">11 创建和管理表</a><ul><li><a href="#chang-jian-de-shu-ju-ku-dui-xiang">常见的数据库对象</a></li><li><a href="#biao-de-ji-ben-cao-zuo">表的基本操作</a></li><li><a href="#yue-shu">约束：</a></li></ul></li><li><a href="#12-qi-ta-shu-ju-ku-dui-xiang">12 其它数据库对象</a><ul><li><a href="#shi-tu">视图：</a></li><li><a href="#xu-lie">序列：</a></li><li><a href="#suo-yin">索引：</a></li><li><a href="#synonym-tong-yi-ci">synonym同义词：</a></li></ul></li></ul></li></ul><!-- tocstop --></div><h2><span id="shu-ju-ku-jie-shao">数据库介绍</span><a href="#shu-ju-ku-jie-shao" class="header-anchor">#</a></h2><p>什么是数据库?</p><p>​    数据库是为了实现一定的目的按某种规则组织起来的数据的集合, 简单的说,数据库就是存储数据的库.</p><p>​    举个例子来说明这个问题：每个人都有很多亲戚和朋友，为了保持与他们的联系，</p><p>​    我们常常用一个笔记本将他们的姓名、地址、电话等信息都记录下来，</p><p>​    这样要査谁的电话或地址就很方便了。</p><p>​    这个“通讯录”就是一个最简单的“数据库”，每个人的姓名、地址、电话等信息就是这个数据库中的“数据”。</p><p>​    我们可以在笔记本这个“数据库”中添加新朋友的个人信息，也可以由于某个朋友的电话变动而修改他的电话号码这个“数据”。</p><p>​    不过说到底，我们使用笔记本这个“数据库”还是为了能随时査到某位亲戚或朋友的地址、邮编或电话号码这些“数据”。</p><p>数据库是干什么用的? </p><p>  存储和管理数据,便于程序开发.</p><p>oracle简介:</p><p>Oracle是殷墟（yīn Xu）出土的甲骨文（oracle bone inscriptions）的英文翻译的第一个单词。</p><p>Oracle公司成立与1977年，总部位于美国加州；</p><p>Oracle数据库是Oracle（中文名称叫甲骨文）公司的核心产品，Oracle数据库是一个适合于大中型企业的数据库管理系统。在所有的数据库管理系统中（比如：微软的SQL Server，IBM的DB2等），Oracle的主要用户涉及面非常广, 包括: 银行、电信、移动通信、航空、保险、金融、电子商务和跨国公司等。</p><p>Oracle数据库的一些版本有：Oracle7、Oracle8i、Oracle9i，Oracle10g到Oracle11g，Oracle12c， 各个版本之间的操作存在一定的差别，但是操作oracle数据库都使用的是标准的SQL语句，因此对于各个版本的差别不大。</p><p>2008年1月16日 收购bea，目的是为了得到weblogic（web服务器的框架，免费的对应的tomcat）。</p><p>2008年1月16日 sun公司收购了mysql 。</p><p>2009年4月20日 oracle收购了sun 。</p><p>常见的数据库有哪些？</p><ol><li><p>oracle公司的oracle数据库</p></li><li><p>IBM公司的DB2数据库</p></li><li><p>Informix公司的Informix数据库</p></li><li><p>sysbase公司的sysbase数据库</p></li><li><p>Microsoft公司的SQL Server</p></li><li><p>oracle的MySQL数据库（开始属于mysql公司，后来mysql被sun收购，sun又被oracle收购）</p></li><li><p><a href="https://baike.baidu.com/item/MongoDB%E6%9D%83%E5%A8%81%E6%8C%87%E5%8D%97/7338398">MongoDB</a>数据库</p></li><li><p>Mariadb数据库 (由MySQL的创始人Michael Widenius（英语：Michael Widenius）主导开发,MariaDB名称来自Michael Widenius的女儿Maria的名字)</p></li><li><p>SQLite (设计目标是<a href="https://baike.baidu.com/item/%E5%B5%8C%E5%85%A5%E5%BC%8F/575465">嵌入式</a>)</p></li></ol><h2><span id="1-oracle-de-ti-xi-jie-gou">1 Oracle的体系结构</span><a href="#1-oracle-de-ti-xi-jie-gou" class="header-anchor">#</a></h2><p>Oracle服务器：是一个数据管理系统(RDBMS)，它提供开放的, 全面的, 近乎完整的信息管理。由1个数据库和一个（或多个）实例组成。数据库位于硬盘上，实例位于内存中。</p><p><img src="https://gitee.com/txt1994/images/raw/master/img/Oracle/wps1.jpg" alt="img"> </p><h3><span id="1-1-biao-kong-jian-he-shu-ju-wen-jian">1.1 表空间和数据文件</span><a href="#1-1-biao-kong-jian-he-shu-ju-wen-jian" class="header-anchor">#</a></h3><p>逻辑概念：表空间是由数据文件组成，位于实例上，在内存中。</p><p>物理概念：数据文件，在磁盘上（<code>/home/oracle_11/app/oradata/orcl</code>目录中的<code>.DBF</code>文件）；</p><p>​     一个表空间包含一个或者多个数据文件。</p><h3><span id="1-2-duan-qu-kuai">1.2 段、区、块</span><a href="#1-2-duan-qu-kuai" class="header-anchor">#</a></h3><p><img src="https://gitee.com/txt1994/images/raw/master/img/Oracle/wps2.jpg" alt="img"> </p><p>段存在于表空间中，段是区的集合，区是数据块的集合，数据块会被映射到磁盘块。</p><p>图请看讲义部分。</p><h3><span id="1-3-dba">1.3 DBA</span><a href="#1-3-dba" class="header-anchor">#</a></h3><p>数据库管理员（Database Administrator，简称DBA），是从事管理和维护<a href="https://baike.baidu.com/item/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F">数据库管理系统</a>(DBMS)的相关工作人员的统称，属于<a href="https://baike.baidu.com/item/%E8%BF%90%E7%BB%B4%E5%B7%A5%E7%A8%8B%E5%B8%88">运维工程师</a>的一个分支，主要负责业务数据库从设计、测试到部署交付的全生命周期管理。DBA的核心目标是保证数据库管理系统的稳定性、安全性、完整性和高性能。从时间开销上看：安装占用6%，创建和配置占用12%，装载和存档数据占6%, 软件维护占6%，管理数据库系统占55%，可见，管理数据库系统占用了大部分的时间开销。</p><h3><span id="1-4-ru-he-qi-dong-shu-ju-ku-fu-wu">1.4 如何启动数据库服务</span><a href="#1-4-ru-he-qi-dong-shu-ju-ku-fu-wu" class="header-anchor">#</a></h3><p>Windows启动oracle数据库服务：</p><p>启动服务：<code>services.msc</code>，找到下列两个服务，并启动。</p><p><code>OracleServiceORCL： oracle</code>数据库服务系统</p><p>home1TNSListene： 监听服务，用于远程连接的侦听</p><p>注意：若把数据库默认设置为自启动，则开机时间会延长。</p><p>Linux启动oracle数据库服务步骤(oracle数据库系统安装到linux系统上)</p><p>​    1.  执行<code>sqlplus / as sysdba</code>或<code>sqlplus sys/sys as sysdba</code>进入到命令行界面</p><p>​    2. 执行startup启动数据库服务</p><p>​    3. 执行exit退出sqlplus命令行界面</p><p>​    4. 执行<code>lsnrctl start</code>启动监听服务</p><p>注意：通过远程客户端连接oracle服务端必须要启动监听服务，否则客户端连接不上。</p><h3><span id="1-5-ru-he-deng-lu-shu-ju-ku-fu-wu">1.5 如何登陆数据库服务</span><a href="#1-5-ru-he-deng-lu-shu-ju-ku-fu-wu" class="header-anchor">#</a></h3><p>在本机登陆：</p><p>普通用户身份登陆</p><p>sqlplus  ↙ 用户名 ↙    密码 ↙</p><p>sqlplus 用户名/密码，如<code>sqlplus scott/tiger</code></p><ol><li>以管理员身份登陆</li></ol><div class="code-wrapper"><pre><code class="hljs sql">sqlplus  <span class="hljs-operator">/</span>  <span class="hljs-keyword">as</span>  sysdba（此处不用输入密码，在安装的时候已经输入密码）sqlplus sys<span class="hljs-operator">/</span>sys <span class="hljs-keyword">as</span> sysdba</code></pre></div><ol start="2"><li>通过网络使用客户端远程登陆</li></ol><p>  远程通过网络登陆数据库需要安装oracle客户端软件，并进行配置才能使用，可通过使用net manager进行配置，配置完成之后可以使用连接字符串进行登陆，连接字符串中包含了数据库服务的IP地址和端口，以及实例名。</p><p>注意：安装oracle客户端的时候，安装路径中不能出现中文和空格，安装的时候选择管理员模式。</p><p><code>D:\oracle\app\HGUANG\product\11.2.0\client_1\network\admin\tnsnames.ora</code>，下面是经过<code>Net Manager</code>进行配置后得到的一个文件内容：</p><p><img src="https://gitee.com/txt1994/images/raw/master/img/Oracle/wps3.jpg" alt="img"> </p><p>客户端安装完成之后进行远程登陆之前最好先进行测试：</p><p>首先测试网络是否是通的： ping  IP ， 然后tnsping  IP  或者 tnsping oracle_orcl。</p><p>普通用户登陆</p><p>sqlplus 用户名/密码@连接字符串，如<code>sqlplus scott/tiger@oracle_orcl</code></p><p>管理员用户登陆</p><div class="code-wrapper"><pre><code class="hljs shell">sqlplus sys/sys@oracle_orcl as sysdba</code></pre></div><p>  此外：还可以执行： <code>sqlplus scott/tiger@//IP地址/实例名</code>     进行登陆。</p><p>  使用scott用户或者sys用户登陆完之后，可以使用<code>show user</code>测试一下，如果显示用户名就表明已经登陆成功了，或者是执行<code>select * from tab;</code>进行一次查询, 有结果显示就表名已经登陆成功了.</p><p>解锁用户：<code>alter user scott account unlock</code> (管理员身份登陆，给scott用户解锁。用户默认锁定)</p><p>锁定用户：<code>alter user scott account lock</code>，（必须用管理员用户登陆）</p><p>修改用户密码：<code>alter user scott identified by 新密码</code>   (管理员身份登陆，给scott用户修改密码)</p><p>查看当前语言环境：<code>select userenv('language') from dual</code>;</p><h3><span id="1-6-guan-chuan-zhe-men-ke-cheng-de-fang-an">1.6 贯穿这门课程的方案</span><a href="#1-6-guan-chuan-zhe-men-ke-cheng-de-fang-an" class="header-anchor">#</a></h3><p>请看oracle讲义。</p><p><code>scott用户</code>的<code>emp表</code>, <code>dept表</code>和<code>salgrade表</code>.</p><p><img src="https://gitee.com/txt1994/images/raw/master/img/Oracle/wps4.jpg" alt="img"> </p><h2><span id="2-ji-ben-de-sql-select-yu-ju">2基本的SQL select语句</span><a href="#2-ji-ben-de-sql-select-yu-ju" class="header-anchor">#</a></h2><h3><span id="2-1-sqlplus-de-ji-ben-cao-zuo">2.1 sqlplus的基本操作</span><a href="#2-1-sqlplus-de-ji-ben-cao-zuo" class="header-anchor">#</a></h3><p>显示当前用户： <code>show user</code>;</p><p>查看当前用户下的表：<code>select * from tab</code>;        </p><p>​    tab:    数据字典（记录<a href="http://baike.baidu.com/view/1088.htm">数据库</a>和<a href="http://baike.baidu.com/view/330120.htm">应用程序</a>源数据的目录），包含当前用户下的表。</p><p>查看员工表的结构：<code>desc emp</code>;    </p><p>设置行宽：<code>set linesize 120</code>;</p><p>设置页面：<code>set pagesize 100</code>;</p><p>​    或者将上述两行写入如下两个配置文件，可永久设置：</p><p><code>C:\app\Administrator\product\11.2.0\client_1\sqlplus\admin\glogin.sql</code></p><p><code>C:\app\Administrator\product\11.2.0\dbhome_1\sqlplus\admin\glogin.sql</code></p><p>设置员工名列宽：<code>col ename for a20</code>            (a表示字符串)</p><p>设置薪水列为4位数子：<code>col sal for 9999</code>        (一个9表示一位数字)</p><h3><span id="2-2-ji-ben-de-select-yu-ju">2.2 基本的select语句</span><a href="#2-2-ji-ben-de-select-yu-ju" class="header-anchor">#</a></h3><p><code>Select语句</code>的整体形式：</p><div class="code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> col1,         col2…<span class="hljs-keyword">FROM</span> table_name<span class="hljs-keyword">WHERE</span> <span class="hljs-keyword">condition</span><span class="hljs-keyword">GROUP</span> <span class="hljs-keyword">BY</span>  col…<span class="hljs-keyword">HAVING</span> condtion<span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span>  col…</code></pre></div><p>其语法格式为：</p><p>SELECT  *|{[DISTINCT] *column|*expression [*alias],…} FROM *table;</p><p>案例</p><p> 1查询所有员工的所有记录</p><div class="code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span><span class="hljs-keyword">FROM</span> emp;<span class="hljs-keyword">SELECT</span> empno,         ename,         job,         mgr,         hiredate,         sal,         comm,         deptno<span class="hljs-keyword">FROM</span> emp;</code></pre></div><p>   说明：尽量使用列名，用列名代替* (oracle 9i之前不同， 之后一样)</p><p> 2 查询员工号、姓名、薪水</p><div class="code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> empno,         ename,         sal<span class="hljs-keyword">FROM</span> emp;</code></pre></div><p>3 查询员工号、姓名、薪水和年薪</p><div class="code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> empno,         ename,         sal,         sal<span class="hljs-operator">*</span><span class="hljs-number">12</span><span class="hljs-keyword">FROM</span> emp;</code></pre></div><p>   说明：select语句中可以使用表达式</p><p>   注意：在执行sql语句的时候，执行 / 会执行上一次执行的语句。</p><p>若在写sql语句的时候, 写错了, 可以使用c（change）命令来修改. 默认, 光标闪烁位置指向上一条SQL语句的第一行。输入 2 则定位到第二行。</p><p>c  /错误关键字/正确关键字 ↙ </p><p>使用“/”来执行修改过的SQL语句</p><p>例如：错误输入: </p><p>`select empno, ename, sal, sal * 12 </p><p>​                          form emp`;  （“from”书写错误，该错误位于整条SQL语句的第二行）</p><p>（1） 输入：2↙  终端提示：2* from emp</p><p>（2） 输入：c  /form/from ↙        终端提示：2* from emp (意为改正后的sql语句样子)</p><p>（3） 输入：/↙ </p><p>也可以使用ed(或者edit)命令来修改</p><p>ed ↙弹出系统默认的文本编辑器，(如记事本)</p><p>修改、保存、退出、执行“/”。</p><p>使用edit打开文件编辑sql语句:</p><p>如果sql语句很长, 可以分行编写或者用ed命令打开一个文件, </p><p>然后在文件中编写sql语句, 注意, sql语句末尾不要加;  , 然后换行加上/表示结束.</p><p>若想将显示结果保存到文件中:</p><p>spool命令:</p><div class="code-wrapper"><pre><code class="hljs shell">spool d:\result.txt;select * from emp;spool off;</code></pre></div><p>使用别名：</p><p>别名：as</p><p>案例：查询员工号，姓名，月薪，年薪 </p><div class="code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> empno <span class="hljs-keyword">AS</span> "员工号",         ename "姓名",         sal 月薪,         sal<span class="hljs-operator">*</span><span class="hljs-number">12</span> 年薪<span class="hljs-keyword">FROM</span> emp;</code></pre></div><p>说明：关键字as写与不写没有区别； “”有与没有取决于别名中是否有空格，建议在用别名的时候加上””。</p><p><code>DISTINCT</code>—à重复记录只取一次</p><p>案例：    </p><div class="code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> deptno<span class="hljs-keyword">FROM</span> emp;<span class="hljs-keyword">SELECT</span> <span class="hljs-keyword">DISTINCT</span> deptno<span class="hljs-keyword">FROM</span> emp;<span class="hljs-keyword">SELECT</span> job<span class="hljs-keyword">FROM</span> emp;<span class="hljs-keyword">SELECT</span> <span class="hljs-keyword">DISTINCT</span> job<span class="hljs-keyword">FROM</span> emp;<span class="hljs-keyword">SELECT</span> <span class="hljs-keyword">DISTINCT</span> deptno,         job<span class="hljs-keyword">FROM</span> emp;</code></pre></div><p>说明: <code>DISTINCT</code>的作用范围不是距离它最近的列, 而是后面的所有的列。</p><h3><span id="2-3-sql-yu-ju-shi-yong-zhu-yi-shi-xiang">2.3 SQL语句使用注意事项</span><a href="#2-3-sql-yu-ju-shi-yong-zhu-yi-shi-xiang" class="header-anchor">#</a></h3><ul><li><p>SQL 语言大小写不敏感。</p></li><li><p>sql语句对关键字的大小写不敏感, 如SELECT和select一样, 但是对于内容敏感。 </p></li><li><p>SQL可以写在一行或者多行</p></li><li><p>关键字不能被缩写也不能分行</p></li><li><p>各子句一般要分行写。</p></li><li><p>使用缩进提高语句的可读性</p></li></ul><h3><span id="2-4-suan-shu-yun-suan">2.4 算数运算 + - * /</span><a href="#2-4-suan-shu-yun-suan" class="header-anchor">#</a></h3><p>乘除的优先级高于加减</p><p>优先级相同时, 按照从左至右运算</p><p>可以使用括号改变优先级</p><p>查询: 员工号、姓名、月薪、年薪、奖金、年收入。</p><div class="code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> deptno,         ename,         sal,         sal<span class="hljs-operator">*</span><span class="hljs-number">12</span>,         comm,         comm<span class="hljs-operator">+</span>sal<span class="hljs-operator">*</span><span class="hljs-number">12</span><span class="hljs-keyword">FROM</span> emp;</code></pre></div><p>​    结果不正确, 没有奖金的员工, 年收入不正确。</p><p>说明： 在程序开发过程中, 数据是核心. 程序再正确也没有用, 必须保证数据不能丢, 且正确, 对于上面的结果, 有对有错的情况是最危险的.</p><p>解决这个问题需要正确认识NULL值。</p><h3><span id="2-5-null-zhi">2.5 NULL值</span><a href="#2-5-null-zhi" class="header-anchor">#</a></h3><p>NULL值问题：</p><ol><li><p>包含NULL值的表达式都为空.</p></li><li><p>NULL不等于NULL</p></li></ol><p><code>select * from emp where NULL=NULL</code>; 查不到任何记录。</p><p>解决：滤空函数：nvl(a, b)  如果a为NULL，返回b；</p><p>所以：使用sal * 12 + nvl(comm, 0) 表示年收入。</p><ol start="3"><li>在SQL中, 判断一值是否等于NULL不用“=” 和“!=”而使用is和is not</li></ol><p>查询奖金为NULL的员工信息：</p><p><code>select * from emp where comm = NULL</code>; (SQL中不使用==)</p><p>​        应该使用：<code>select * from emp where comm is NULL</code>;    </p><p>查询奖金不为NULL的员工信息：      </p><p><code>select * from emp where comm is not NULL</code>;</p><p>总结: 空值是无效的, 未指定的, 未知的或不可预知的值, 空值不是空格或者0.</p><h3><span id="2-6-lian-jie-fu">2.6 连接符</span><a href="#2-6-lian-jie-fu" class="header-anchor">#</a></h3><p>​    在oracle中使用 || 连接字符串</p><p>例如： </p> <div class="code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> ename <span class="hljs-operator">||</span> <span class="hljs-string">' is a '</span> <span class="hljs-operator">||</span> job<span class="hljs-keyword">FROM</span> emp;</code></pre></div><p>若要显示hello world字符串应该怎么办呢?</p><p>oracle中语法规定：select后面必须接from关键字，所有需要有一个表名用来满足oracle的SQL99语法规定，为此定义了一个伪表dual。</p><div class="code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> concat(<span class="hljs-string">'hello '</span>, <span class="hljs-string">'world'</span>)<span class="hljs-keyword">FROM</span> dual;</code></pre></div><p>若要连接三个字符串呢？</p><div class="code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> concat(concat(<span class="hljs-string">'hello '</span>, <span class="hljs-string">'world'</span>), <span class="hljs-string">' i love you'</span>)<span class="hljs-keyword">FROM</span> dual;</code></pre></div><p>注意：concat函数只支持两个参数，不支持三个参数形式。</p><p>​    也可以使用||连接三个以上的字符串：</p><div class="code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-string">'hello '</span> <span class="hljs-operator">||</span> <span class="hljs-string">'world '</span> <span class="hljs-operator">||</span> <span class="hljs-string">'i love you'</span><span class="hljs-keyword">FROM</span> dual;</code></pre></div><p>说明：使用||比concat函数要灵活，其实||就是用来替换concat函数的。</p><h3><span id="2-7-sql-he-sqlplus">2.7 SQL和sqlplus</span><a href="#2-7-sql-he-sqlplus" class="header-anchor">#</a></h3><p>我们已经学习使用了<code>select</code>，应该知道还有update、delete、insert、create…</p><p>同时，我们学习了ed、c、set、col、desc….</p><p>SQL是语言，关键字不能缩写。</p><p>sqlplus是oracle提供的工具，可在里面执行SQL语句，它配有自己的命令(ed、c、set、col) 特点是缩写关键字。                                                    </p><p>SQL </p><ul><li><p>一种语言</p></li><li><p>ANSI 标准</p></li><li><p>关键字不能缩写</p></li><li><p>使用语句控制数据库中的表的定义信息和表中的数据</p></li></ul><p>SQL*Plus</p><ul><li><p>一种环境</p></li><li><p>Oracle 的特性之一</p></li><li><p>关键字可以缩写</p></li><li><p>命令不能改变数据库中的数据的值</p></li><li><p>集中运行</p></li></ul><h2><span id="3-guo-lu-he-pai-xu-shu-ju">3 过滤和排序数据</span><a href="#3-guo-lu-he-pai-xu-shu-ju" class="header-anchor">#</a></h2><h3><span id="3-1-where-tiao-jian-guo-lu">3.1 where条件过滤</span><a href="#3-1-where-tiao-jian-guo-lu" class="header-anchor">#</a></h3><p>在where条件中使用的列的值对大小写是敏感的, 如是字符串需要用单引号引起来, 如KING和king是不同的字符串。</p><p>如<code>select * from emp where ename= 'KiNg '</code>；未选定行</p><p><code> select * from emp where ename= 'KING '</code>； 正确</p><p>说明： 对于列的值来说，大小写是敏感的。</p><p>​    [未选定行]不是发生了错误，而是查不到记录。</p><h4><span id="3-1-1-ri-qi-ge-shi"><strong>3.1.1</strong> 日期格式</span><a href="#3-1-1-ri-qi-ge-shi" class="header-anchor">#</a></h4><p>查询入职日期为1981年11月17日的员工</p><div class="code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span><span class="hljs-keyword">FROM</span> emp<span class="hljs-keyword">WHERE</span> hiredate<span class="hljs-operator">=</span> <span class="hljs-string">'1981-11-17 '</span>;</code></pre></div><p>会报错，ORA-01861: 文字与格式字符串不匹配。</p><p>首先查询一下emp使用的日期格式：</p><div class="code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span><span class="hljs-keyword">FROM</span> emp;</code></pre></div><p>使用sysdate函数获取当前系统的日期：</p><div class="code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> sysdate<span class="hljs-keyword">FROM</span> dual;</code></pre></div><p>  查询得出格式为： <code>DD-MON-RR</code></p><p>应该使用当前系统指定的日期格式来查询：</p><div class="code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span><span class="hljs-keyword">FROM</span> emp<span class="hljs-keyword">WHERE</span> hiredate <span class="hljs-operator">=</span> <span class="hljs-string">'17-11月-81'</span>;</code></pre></div><p> 如何获取当前系统的日期格式?</p><div class="code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span><span class="hljs-keyword">FROM</span> v$nls_parameters;</code></pre></div><p>若格式不太好看，可以执行col parameter for a30设置列的宽度。</p><p>如何修改日期格式?</p><div class="code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">alter</span> session <span class="hljs-keyword">SET</span> NLS_DATE_FORMAT <span class="hljs-operator">=</span> <span class="hljs-string">'yyyy-mm-dd '</span>;</code></pre></div><p>  查看修改结果：</p><div class="code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span><span class="hljs-keyword">FROM</span> v$nls_parameters;</code></pre></div><p>  验证：再次查询emp表：</p><div class="code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span><span class="hljs-keyword">FROM</span> emp<span class="hljs-keyword">WHERE</span> hiredate<span class="hljs-operator">=</span> <span class="hljs-string">'1981-11-17 '</span>;</code></pre></div><p>修改日期格式到秒</p><div class="code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">alter</span> session <span class="hljs-keyword">SET</span> NLS_DATE_FORMAT <span class="hljs-operator">=</span> <span class="hljs-string">'yyyy-mm-dd hh24:mi:ss'</span>;</code></pre></div><p>  执行<code>select sysdate from dual;</code>验证修改结果.</p><p>将日期格式改回默认设置</p><div class="code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">alter</span> session <span class="hljs-keyword">SET</span> NLS_DATE_FORMAT <span class="hljs-operator">=</span> <span class="hljs-string">'DD-MON-RR'</span>;</code></pre></div><p> 说明:</p><ul><li><p>字符和日期要包含在单引号中。</p></li><li><p>字符大小写敏感, 日期格式敏感。</p></li><li><p>默认的日期格式是<code>DD-MON-RR</code></p></li></ul><h4><span id="3-1-2-bi-jiao-yun-suan"><strong>3.1.2</strong> 比较运算</span><a href="#3-1-2-bi-jiao-yun-suan" class="header-anchor">#</a></h4><p>l 普通比较运算符：                                                        </p><p>=     等于(不是==)        &gt;     大于</p><p>&gt;= 大于等于          &lt;     小于</p><p>&lt;= 小于等于            &lt;&gt;    不等于(也可以是!=)</p><p>案例:</p><p>1 查询薪水不等于1250的员工信息</p><div class="code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span><span class="hljs-keyword">FROM</span> emp<span class="hljs-keyword">WHERE</span> sal <span class="hljs-operator">&lt;&gt;</span> <span class="hljs-number">1250</span>;<span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span><span class="hljs-keyword">FROM</span> emp<span class="hljs-keyword">WHERE</span> sal <span class="hljs-operator">!=</span> <span class="hljs-number">1250</span>;</code></pre></div><p>between…and:介于两值之间,闭区间,包含两边的值.</p><p>案例:</p><p>查询工资在1000-2000之间的员工：</p><div class="code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span><span class="hljs-keyword">FROM</span> emp<span class="hljs-keyword">WHERE</span> sal <span class="hljs-operator">&gt;=</span><span class="hljs-number">1000</span>        <span class="hljs-keyword">AND</span> sal<span class="hljs-operator">&lt;=</span><span class="hljs-number">2000</span>;<span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span><span class="hljs-keyword">FROM</span> emp<span class="hljs-keyword">WHERE</span> sal    <span class="hljs-keyword">BETWEEN</span> <span class="hljs-number">1000</span>        <span class="hljs-keyword">AND</span> <span class="hljs-number">2000</span>;</code></pre></div><p>​    注意：1.包含边界  2. 小值在前，大值在后。 (对于日期也是如此)</p><p>2 查询81年2月至82年2月(不含2月)入职的员工信息：</p><div class="code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span><span class="hljs-keyword">FROM</span> emp<span class="hljs-keyword">WHERE</span> hiredate    <span class="hljs-keyword">BETWEEN</span> <span class="hljs-string">'1-2月-81'</span>        <span class="hljs-keyword">AND</span> <span class="hljs-string">'30-1月-82'</span>;</code></pre></div><p>in：在集合中, not in 不在集合中</p><p>案例</p><ol><li>查询部门号为10和20的员工信息：</li></ol><div class="code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span><span class="hljs-keyword">FROM</span> emp<span class="hljs-keyword">WHERE</span> deptno<span class="hljs-operator">=</span><span class="hljs-number">10</span>        <span class="hljs-keyword">OR</span> deptno<span class="hljs-operator">=</span><span class="hljs-number">20</span>; <span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span><span class="hljs-keyword">FROM</span> emp<span class="hljs-keyword">WHERE</span> deptno <span class="hljs-keyword">IN</span> (<span class="hljs-number">10</span>, <span class="hljs-number">20</span>);</code></pre></div><ol start="2"><li>查询部门号不是10和20的员工(除了10和20以外的部门)</li></ol><div class="code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span><span class="hljs-keyword">FROM</span> emp<span class="hljs-keyword">WHERE</span> deptno <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">IN</span> (<span class="hljs-number">10</span>, <span class="hljs-number">20</span>);</code></pre></div><div class="code-wrapper"><pre><code class="hljs">使用比较运算符该怎么写呢？</code></pre></div><div class="code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span><span class="hljs-keyword">FROM</span> emp<span class="hljs-keyword">WHERE</span> deptno<span class="hljs-operator">!=</span><span class="hljs-number">10</span>        <span class="hljs-keyword">AND</span> deptno<span class="hljs-operator">!=</span><span class="hljs-number">20</span>;</code></pre></div><p>如果是 ….. not in (10, 20, NULL) 可不可以呢?</p><div class="code-wrapper"><pre><code class="hljs">☆NULL空值:如果结果中含有NULL,不能使用not in 操作符,但可以使用in操作符。课后思考为什么???</code></pre></div><p>  因为: not in (10, 20, NULL)相当于:</p><p><code>deptno!=10 and deptno!=20 and deptno!=NULL</code>包含<code>NULL</code>的表达式都为空.</p><p>like：模糊查询</p><p>%匹配任意多个字符,  _匹配一个字符, 使用escape表示转义字符</p><p>案例:</p><ol><li><p>查询名字以S开头的员工</p><div class="code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span><span class="hljs-keyword">FROM</span> emp<span class="hljs-keyword">WHERE</span> ename <span class="hljs-keyword">LIKE</span> <span class="hljs-string">'S% '</span>;</code></pre></div><p>(注意：S小写、大写不同)</p></li><li><p>查询名字是4个字的员工</p><div class="code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span><span class="hljs-keyword">FROM</span> emp<span class="hljs-keyword">WHERE</span> ename <span class="hljs-keyword">LIKE</span> <span class="hljs-string">'_ _ _ _'</span>;</code></pre></div></li><li><p>增加测试例子：向表中插入员工：</p><div class="code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> emp(empno, ename, sal, deptno) <span class="hljs-keyword">values</span>(<span class="hljs-number">1001</span>, <span class="hljs-string">' TOM_ABC '</span>, <span class="hljs-number">3000</span>, <span class="hljs-number">10</span>);</code></pre></div></li><li><p>查询名字中包含_的员工：</p></li></ol><div class="code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span><span class="hljs-keyword">FROM</span> emp<span class="hljs-keyword">WHERE</span> ename <span class="hljs-keyword">LIKE</span> <span class="hljs-string">'% _ % '</span>;</code></pre></div><p> 查不到记录.</p><p>转义字符：</p><div class="code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span><span class="hljs-keyword">FROM</span> emp<span class="hljs-keyword">WHERE</span> ename <span class="hljs-keyword">LIKE</span> <span class="hljs-string">'%\_% '</span> <span class="hljs-keyword">escape</span> <span class="hljs-string">'\'</span>;</code></pre></div><p>转义单引号本身使用两个单引号来完成转义</p><div class="code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-string">'hello '' world'</span><span class="hljs-keyword">FROM</span> dual;</code></pre></div><h4><span id="3-1-3-luo-ji-yun-suan"><strong>3.1.3</strong> 逻辑运算</span><a href="#3-1-3-luo-ji-yun-suan" class="header-anchor">#</a></h4><p>逻辑运算符</p><p>AND     逻辑并</p><p>OR         逻辑或</p><p>NOT     逻辑非</p><p>如果…..where 表达式1 and/or 表达式2;            </p><div class="code-wrapper"><pre><code class="hljs">…..where 表达式2 and/or 表达式1;            </code></pre></div><p>这两句SQL语句功能一样吗？效率一样吗？</p><p>※SQL优化：</p><p>SQL在解析where的时候，是从右至左解析的。</p><p>所以： and时应该将易假的值放在右侧;</p><div class="code-wrapper"><pre><code class="hljs">  or时应该将易真的值放在右侧.</code></pre></div><p>这样的话可以提高效率.</p><p>案例: </p><ol><li><p>查询部门为30且工种为SALESMAN的员工</p><div class="code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span><span class="hljs-keyword">FROM</span> emp<span class="hljs-keyword">WHERE</span> deptno<span class="hljs-operator">=</span><span class="hljs-number">30</span>        <span class="hljs-keyword">AND</span> job<span class="hljs-operator">=</span><span class="hljs-string">'SALESMAN'</span>;</code></pre></div></li><li><p>查询部门为10或者工资大于2000的员工</p></li></ol> <div class="code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span><span class="hljs-keyword">FROM</span> emp<span class="hljs-keyword">WHERE</span> deptno<span class="hljs-operator">=</span><span class="hljs-number">10</span>        <span class="hljs-keyword">OR</span> sal<span class="hljs-operator">&gt;</span><span class="hljs-number">2000</span>;</code></pre></div><ol start="3"><li>查询工种不是MANAGER或者PRISIDENT的员工</li></ol><div class="code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span><span class="hljs-keyword">FROM</span> emp<span class="hljs-keyword">WHERE</span> job<span class="hljs-operator">!=</span><span class="hljs-string">'MANAGER'</span>        <span class="hljs-keyword">AND</span> job<span class="hljs-operator">!=</span><span class="hljs-string">'PRISIDENT'</span>; <span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span><span class="hljs-keyword">FROM</span> emp<span class="hljs-keyword">WHERE</span> job <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">IN</span> (<span class="hljs-string">'MANAGER'</span>, <span class="hljs-string">'PRESIDENT'</span>);</code></pre></div><h4><span id="3-1-4-order-by-pai-xu"><strong>3.1.4</strong> order by 排序</span><a href="#3-1-4-order-by-pai-xu" class="header-anchor">#</a></h4><p>使用 ORDER BY 子句排序</p><ul><li><p>ASC（ascend）: 升序。默认采用升序方式。</p></li><li><p>DESC（descend）: 降序</p></li></ul><p>ORDER BY子句在SELECT语句的最末尾, 是对select查询的最后的结果进行排序.</p><p>案例:</p><ol><li>查询emp表, 按照入职日期先后排序</li></ol><div class="code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span><span class="hljs-keyword">FROM</span> emp<span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span>  hiredate;</code></pre></div><ol start="2"><li>查询员工信息, 按月薪排序</li></ol><div class="code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span><span class="hljs-keyword">FROM</span> emp<span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span>  sal;   # <span class="hljs-comment">---从小到大排序, 默认方式.</span><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span><span class="hljs-keyword">FROM</span> emp<span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span>  sal <span class="hljs-keyword">desc</span>;  # <span class="hljs-comment">---从大到小排序</span></code></pre></div><p>order by 之后可以跟那些内容呢？</p><p>order by + 列名, 序号, 表达式, 别名, </p><p>注意：语法要求order by子句应放在select的结尾。</p><p>案例:</p><ol><li><p>查询员工信息, 按月薪排序—-à使用列名排序的情况</p><div class="code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span><span class="hljs-keyword">FROM</span> emp<span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span>  sal;</code></pre></div></li><li><p>按照工资进行排序–à使用序号进行排序的情况</p></li></ol><div class="code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> ename,         sal,         sal<span class="hljs-operator">*</span><span class="hljs-number">12</span>,        <span class="hljs-keyword">FROM</span> emp<span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span>  <span class="hljs-number">2</span> <span class="hljs-keyword">desc</span>;</code></pre></div><p>序号: 按照select后面列名出现的先后顺序, ename→1, sal→2, sal*12→3</p><ol start="3"><li>按照员工的年薪进行排序—-à使用表达式排序的情况</li></ol><div class="code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> ename,         sal,         sal<span class="hljs-operator">*</span><span class="hljs-number">12</span><span class="hljs-keyword">FROM</span> emp<span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span>  sal <span class="hljs-operator">*</span> <span class="hljs-number">12</span> <span class="hljs-keyword">desc</span>;</code></pre></div><ol start="4"><li>按照员工的年薪进行排序—-à使用别名进行排序的情况<div class="code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> ename,         sal,         sal<span class="hljs-operator">*</span><span class="hljs-number">12</span> "年薪"<span class="hljs-keyword">FROM</span> emp<span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span>  "年薪" <span class="hljs-keyword">desc</span>;</code></pre></div></li></ol><p><strong>按照两列或者多列进行排序</strong></p><p>案例:</p><ol><li>按照部门和工资进行排序<div class="code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span><span class="hljs-keyword">FROM</span> emp<span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span>  deptno, sal;</code></pre></div></li></ol><p>order by后有多列时, 列名之间用逗号隔分, order by会同时作用于多列。上例的运行结果会在同一部门内升序, 部门间再升序。</p><div class="code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span><span class="hljs-keyword">FROM</span> emp<span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span>  deptno, sal <span class="hljs-keyword">desc</span>;</code></pre></div><p>注意: desc只作用于最近的一列, 两列都要降序排, 则需要两个desc。即：</p><div class="code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span><span class="hljs-keyword">FROM</span> emp<span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span>  deptno <span class="hljs-keyword">desc</span>, sal <span class="hljs-keyword">desc</span>;</code></pre></div><ol start="2"><li>查询员工信息, 按奖金由高到低排序：</li></ol><div class="code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span><span class="hljs-keyword">FROM</span> emp<span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span>  comm <span class="hljs-keyword">desc</span>;</code></pre></div><p>结果前面的值为NULL, 数据在后面, 如果是一个100页的报表，这样显示肯定不</p><p>正确。较为人性化的显示应该将空值放在最后, 即：</p><div class="code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span><span class="hljs-keyword">FROM</span> emp<span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span>  comm <span class="hljs-keyword">DESC</span> nulls <span class="hljs-keyword">last</span>;</code></pre></div><p>(注意：是 <code>nulls</code> 而不是null)</p><p><strong>排序的规则</strong></p><ul><li><p>可以按照select语句中的列名排序</p></li><li><p>可以按照别名排序</p></li><li><p>可以按照表达式排序,如order by sal*12+nvl(comm, 0)</p></li><li><p>可以按照select语句中的列名的顺序值(序号)排序</p></li><li><p>如果要按照多列进行排序，则规则是先按照第一列排序，如果相同，则按照第二列排序；以此类推</p></li><li><p>desc和asc只作用于最近的一列.</p></li></ul><h2><span id="4-dan-xing-han-shu">4 单行函数</span><a href="#4-dan-xing-han-shu" class="header-anchor">#</a></h2><p>单行函数:只对一行进行变换, 产生一个结果。函数可以没有参数, 但必须要有返回值。如：concat、nvl</p><ul><li><p>操作数据对象</p></li><li><p>接受参数返回一个结果</p></li><li><p>只对一行进行变换</p></li><li><p>每行返回一个结果</p></li><li><p>可以转换数据类型</p></li><li><p>可以嵌套</p></li><li><p>参数可以是一列或一个值</p></li></ul><h3><span id="4-1-zi-fu-han-shu">4.1 字符函数</span><a href="#4-1-zi-fu-han-shu" class="header-anchor">#</a></h3><p>操作对象是字符串。</p><p>大致可分为两大类: 一类是大小写控制函数, 主要有lower、upper、initcap:</p><p>案例:</p><p>大小写转换lower和upper, 首字母大写initcap函数测试</p><div class="code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-built_in">lower</span>(<span class="hljs-string">'HeLlo, WORld'</span>) 转小写, <span class="hljs-built_in">upper</span>(<span class="hljs-string">'HellO, woRld'</span>) 转大写, initcap(<span class="hljs-string">'hello, world'</span>) 首字母大写<span class="hljs-keyword">FROM</span> dual;</code></pre></div><p>另一类是字符控制函数: 有CONCAT、SUBSTR、LENGTH/LENGTHB、INSTR、LPAD | RPAD、TRIM、REPLACE</p><p>substr(a, b)：在字符串a中，从第b位开始取(计数从1开始)，取到结尾</p><p>案例:</p><p>从helloworld字符串中的第3位开始后面的所有字符</p><p><code>select substr('helloworld', 3) from dual;</code> —à得到lloworld</p><p>substr(a, b, c)：从a中，第b位开始，向右取c位。  </p><p>案例:</p><p>从hello world字符串中, 从第3位开始取连续取5个字符</p><div class="code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> substr(<span class="hljs-string">'helloworld'</span>, <span class="hljs-number">3</span>, <span class="hljs-number">5</span>)<span class="hljs-keyword">FROM</span> dual;</code></pre></div><p>length:字符数, lengthb:字节数：</p><p>  案例:</p><div class="code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> length(<span class="hljs-string">'hello world'</span>) 字符数, lengthb(<span class="hljs-string">'hello world'</span>) 字节数<span class="hljs-keyword">FROM</span> dual;<span class="hljs-keyword">SELECT</span> length(<span class="hljs-string">'哈喽我的'</span>) 字符数, lengthb(<span class="hljs-string">'哈喽我的'</span>) 字节数<span class="hljs-keyword">FROM</span> dual;</code></pre></div><p>注意:对于length函数一个汉字是一个字符, 对于lengthb函数,一个汉字占两个,</p><p>   这两个函数对于普通字符串没有什么区别.</p><p> instr: 在母串中查找子串, 找到返回下标, 计数从1开始, 没有返回0</p><p>案例</p><p>查找hello world字符串中, llo子串首次出现的下标位置</p><div class="code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> instr(<span class="hljs-string">'hello world'</span>, <span class="hljs-string">'llo'</span>), instr(<span class="hljs-string">'hello world'</span>, <span class="hljs-string">'www'</span>)<span class="hljs-keyword">FROM</span> dual;</code></pre></div><p>  注意: 下标是从1开始的.</p><p>lpad：左填充，</p><p>参1: 待填充的字符串，</p><p>参2: 填充后字符串的总长度(字节)，</p><p> 参3: 填充什么  </p><p>rpad: 右填充, 参数同lpad.</p><p>案例</p><ol><li><code>select lpad('abcd', 10, '*') 左, rpad('abcd', 10, '#') 右 from dual;</code></li></ol><p> 结果显示: ******abcd abcd######</p><ol start="2"><li><code>select lpad('abcd', 15, '你')左填充, rpad('abcd', 16, '我') 右填充 from dual;   </code></li></ol><p> 结果显示:  你你你你你abcd abcd我我我我我我</p><p> 注意: lpad(‘abcd’, 15, ‘你’)由于abcd本身占4个字节, 需要填充11个字节才能</p><p>够15个字节, 但是一个汉字占两个字节, 所以填充了1个空格+5个汉字.</p><p>trim:去掉前后指定的字符(不去掉中间的) </p><p>案例</p><ol><li><p>去掉’  hello world  ‘两端的空格</p><div class="code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-built_in">trim</span>(<span class="hljs-string">' hello world '</span>)<span class="hljs-keyword">FROM</span> dual;</code></pre></div></li><li><p>去掉Hello worldH字符串前后的H字符</p><div class="code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-built_in">trim</span>(<span class="hljs-string">'H'</span><span class="hljs-keyword">FROM</span> <span class="hljs-string">'Hello worldH'</span>)<span class="hljs-keyword">FROM</span> dual;</code></pre></div></li></ol><p> replace:替换</p><p>案例</p><ol><li><p>将hello world字符串中的l替换成*</p><div class="code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> replace(<span class="hljs-string">'hello world'</span>, <span class="hljs-string">'l'</span>, <span class="hljs-string">'*'</span>)<span class="hljs-keyword">FROM</span> dual;</code></pre></div></li><li><p>删除字符串’hello world’中的字符’l’</p><div class="code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> replace(<span class="hljs-string">'hello world'</span>, <span class="hljs-string">'l'</span>, <span class="hljs-string">''</span>)<span class="hljs-keyword">FROM</span> dual;</code></pre></div></li></ol><h3><span id="4-2-shu-zhi-han-shu">4.2 数值函数</span><a href="#4-2-shu-zhi-han-shu" class="header-anchor">#</a></h3><p>ROUND: 四舍五入</p><p>ROUND(45.926, 2)    45.93</p><p>TRUNC:     截断</p><p>TRUNC(45.926, 2)    45.92</p><p>MOD: 求余</p><p>MOD(1600, 300)      100</p><ol><li>案例:</li></ol><p>round(45.926, 2) :2表达的含义是小数点向右保留两位并四舍五入，第二个参数如果是0可以省略.</p><div class="code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> round(<span class="hljs-number">45.926</span>,         <span class="hljs-number">2</span>),         round(<span class="hljs-number">45.926</span>,         <span class="hljs-number">1</span>),         round(<span class="hljs-number">45.926</span>,         <span class="hljs-number">0</span>) ,         round(<span class="hljs-number">45.926</span>),         round(<span class="hljs-number">45.926</span>,         <span class="hljs-number">-1</span>) ,         round(<span class="hljs-number">45.926</span>,         <span class="hljs-number">-2</span>)<span class="hljs-keyword">FROM</span> dual;</code></pre></div><ol start="2"><li>trunc函数, 正数表示小数点之后, 负数表示小数点之前的位数, 0可以不写.</li></ol><div class="code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> trunc(<span class="hljs-number">45.926</span>,         <span class="hljs-number">2</span>),         trunc(<span class="hljs-number">45.926</span>,         <span class="hljs-number">1</span>),         trunc(<span class="hljs-number">45.926</span>,         <span class="hljs-number">0</span>),         trunc(<span class="hljs-number">45.926</span>),         trunc(<span class="hljs-number">45.926</span>,         <span class="hljs-number">-1</span>) ,         trunc(<span class="hljs-number">45.926</span>,         <span class="hljs-number">-2</span>)<span class="hljs-keyword">FROM</span> dual;</code></pre></div><ol start="3"><li>mod函数: 求余数</li></ol><p><code>select mod(1600, 600) from dual;</code>  –à结果为100 </p><ol start="4"><li>ceil函数:向上取整</li></ol><p> floor函数:向下取整</p><p> <code>select ceil(19.23), floor(19.23) from dual;</code></p><h3><span id="4-3-shi-jian-han-shu">4.3 时间函数</span><a href="#4-3-shi-jian-han-shu" class="header-anchor">#</a></h3><p>在Oracle中日期型的数据，既有日期部分，也有时间部分.</p><p>案例:</p><ol><li><code>select sysdate from dual;</code></li></ol><p>这里没有时间部分，因为系统默认的格式中不显示时间</p><ol start="2"><li><code>select to_char(sysdate, 'yyyy-mm-dd hh24:mi:ss') from dual;</code></li></ol><p>显示日期到秒 </p><ol start="3"><li><code>select to_char(sysdate, 'day') from dual ;</code></li></ol><p>可以显示当前日期星期几</p><p>日期加、减数字得到的结果仍为日期。单位：天</p><p>显示 昨天、今天、明天</p><div class="code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> (sysdate<span class="hljs-number">-1</span>) 昨天,         (sysdate) 今天,         (sysdate <span class="hljs-operator">+</span> <span class="hljs-number">1</span>) 明天<span class="hljs-keyword">FROM</span> dual;<span class="hljs-keyword">SELECT</span> to_char(sysdate<span class="hljs-number">-1</span>,         <span class="hljs-string">'yyyy-mm-dd'</span>) 昨天, to_char(sysdate, <span class="hljs-string">'yyyy-mm-dd'</span>) 今天, to_char(sysdate<span class="hljs-operator">+</span><span class="hljs-number">1</span>, <span class="hljs-string">'yyyy-mm-dd'</span>) 明天<span class="hljs-keyword">FROM</span> dual; à转换日期格式;</code></pre></div><p>既然一个日期型的数据加上或者减去一个数字得到的结果仍为日期，两个日期相减，得到的就是相差的天数。</p><p>计算员工的工龄, 显示从入职以来的总天数, 星期数, 总月数, 总年数</p><div class="code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> ename,         hiredate,         (sysdate <span class="hljs-operator">-</span> hiredate) 天,         (sysdate <span class="hljs-operator">-</span> hiredate)<span class="hljs-operator">/</span><span class="hljs-number">7</span> 星期,         (sysdate <span class="hljs-operator">-</span> hiredate)<span class="hljs-operator">/</span><span class="hljs-number">30</span> 月,         (sysdate <span class="hljs-operator">-</span> hiredate)<span class="hljs-operator">/</span><span class="hljs-number">365</span> 年<span class="hljs-keyword">FROM</span> emp;</code></pre></div><p>日期和日期可以相减表示相隔多少天, 但是不允许相加, 两个日期相加没有意义, 日期只能和数字相加—-à类似于两个指针相加没有意义一样.</p><p>​    <code>select sysdate+hiredate from emp; </code></p><p>  报错: ORA-00975: 不允许日期 + 日期</p><h3><span id="4-4-ri-qi-han-shu">4.4 日期函数</span><a href="#4-4-ri-qi-han-shu" class="header-anchor">#</a></h3><p>上面求取员工工龄的结果不精确，如果想将其算准确，可以使用日期函数来做。</p><p><strong>months_between</strong></p><p>两个日期值相差的月数(精确值)</p><div class="code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> ename,         hiredate,         (sysdate<span class="hljs-operator">-</span>hiredate)<span class="hljs-operator">/</span><span class="hljs-number">30</span> 一,         months_between(sysdate,         hiredate) 二<span class="hljs-keyword">FROM</span> emp;</code></pre></div><p>months_between函数更精确, 在表示月份差的时候要使用months_between函数.</p><p><strong>add_months</strong></p><p>在某个日期值上，加上多少的月，正数向后计算，负数向前计算。</p><p>计算95个月以后是哪年、哪月、那天：</p><p><code>select add_months(sysdate, 95) 哪一天 from dual;</code></p><p>结果是: 2025/10/11 </p><p><strong>last_day</strong></p><p>日期所在月的最后一天, 要么30, 31或者28</p><div class="code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> last_day(sysdate)<span class="hljs-keyword">FROM</span> dual;</code></pre></div><p>上个月的最后一天</p><div class="code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> last_day(add_months(sysdate,         <span class="hljs-number">-1</span>))<span class="hljs-keyword">FROM</span> dual;</code></pre></div><p> 下一个月的最后一天</p><div class="code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> last_day(add_months(sysdate,         <span class="hljs-number">1</span>))<span class="hljs-keyword">FROM</span> dual;</code></pre></div><p> <strong>next_day</strong>:指定日期的下一个日期</p><p>从当前时间算起, 下一个星期一的日期</p><div class="code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> next_day(sysdate,         <span class="hljs-string">'星期一'</span>)<span class="hljs-keyword">FROM</span> dual;</code></pre></div><p>从特定日期得到之后的第一个星期几的日期</p><div class="code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> next_day(to_date(<span class="hljs-string">'2017-11-11'</span>, <span class="hljs-string">'yyyy-mm-dd'</span>), <span class="hljs-string">'星期三'</span>)<span class="hljs-keyword">FROM</span> dual;</code></pre></div><p>round、trunc 对日期型数据进行四舍五入和截断    </p><div class="code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> round(sysdate,         <span class="hljs-string">'month'</span>), round(sysdate, <span class="hljs-string">'year'</span>)<span class="hljs-keyword">FROM</span> dual;<span class="hljs-keyword">SELECT</span> trunc (sysdate,         <span class="hljs-string">'month'</span>), trunc(sysdate, <span class="hljs-string">'year'</span>)<span class="hljs-keyword">FROM</span> dual;</code></pre></div><h3><span id="4-5-zhuan-huan-han-shu">4.5 转换函数</span><a href="#4-5-zhuan-huan-han-shu" class="header-anchor">#</a></h3><p>在不同的数据类型之间完成转换, 如将”123”转换为123, 有隐式转换和显示转换之分。                    </p><p>隐式转换(由oracle数据库来完成)</p><div class="code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span><span class="hljs-keyword">FROM</span> emp<span class="hljs-keyword">WHERE</span> hiredate <span class="hljs-operator">=</span> <span class="hljs-string">'17-11月-81'</span>;</code></pre></div><p>若是显示转换:</p><div class="code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span><span class="hljs-keyword">FROM</span> emp<span class="hljs-keyword">WHERE</span> to_char(hiredate, <span class="hljs-string">'DD-MON-RR'</span>) <span class="hljs-operator">=</span> <span class="hljs-string">'17-11月-81'</span>;</code></pre></div><p>或者</p><div class="code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span><span class="hljs-keyword">FROM</span> emp<span class="hljs-keyword">WHERE</span> hiredate <span class="hljs-operator">=</span> to_date(<span class="hljs-string">'17-11月-81'</span>, <span class="hljs-string">'DD-MON-RR'</span>);</code></pre></div><p>显示转换(通过转换函数来完成)</p><div class="code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> to_char(sysdate,         <span class="hljs-string">'yyyy-mm-dd hh24:mi:ss'</span>)<span class="hljs-keyword">FROM</span> dual;</code></pre></div><p>注意: 隐式转换，前提条件是：被转换的对象是可以转换的。（ABC→625 可以吗？）</p><p><img src="https://gitee.com/txt1994/images/raw/master/img/Oracle/wps5.jpg" alt="img"> </p><p>显示转换：借助to_char(数据，格式)、to_number、to_date函数来完成转换。</p><p><img src="https://gitee.com/txt1994/images/raw/master/img/Oracle/wps6.jpg" alt="img"> </p><p>​                        </p><table><thead><tr><th>格式</th><th>说明</th><th>举例</th></tr></thead><tbody><tr><td>YYYY</td><td>Full year in numbers</td><td>2011</td></tr><tr><td>YEAR</td><td>Year spelled out(年的英文全称)</td><td>twenty eleven</td></tr><tr><td>MM</td><td>Two-digit value of month 月份（两位数字）</td><td>04</td></tr><tr><td>MONTH</td><td>Full name of the month（月的全称）</td><td>4月</td></tr><tr><td>DY</td><td>Three-letter abbreviation of the day of the week(星期几)</td><td>星期一</td></tr><tr><td>DAY</td><td>Full name of the day of the week</td><td>星期一</td></tr><tr><td>DD</td><td>Numeric day of the month</td><td>02</td></tr></tbody></table><p>如果隐式转换和显示转换都可以使用，应该首选哪个呢？</p><p>注意：如果隐式、显示都可以使用，应该首选显示，这样可以省去oracle的解析过程。</p><p>练习：在屏幕上显示如下字符串：</p><p>2015-05-11 16:17:06 今天是 星期一</p><div class="code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> to_char(sysdate,         <span class="hljs-string">'yyyy-mm-dd hh24:mi:ss "今天是" day'</span>)<span class="hljs-keyword">FROM</span> dual;</code></pre></div><p>说明: 在固定的格式里加入自定义的格式，是可以的，必须要加””。</p><p>反向操作：已知字符串’2015-05-11 15:17:06 今天是 星期一’转化成日期.</p><p>使用<code>to_date</code>函数将字符串转换成date类型</p><div class="code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> to_date(<span class="hljs-string">'2015-05-11 15:17:06 今天是 星期一'</span>, <span class="hljs-string">'yyyy-mm-dd hh24:mi:ss "今天是" day'</span>)<span class="hljs-keyword">FROM</span> dual;</code></pre></div><p><img src="https://gitee.com/txt1994/images/raw/master/img/Oracle/wps7.jpg" alt="img"> </p><p>案例:</p><ol><li>查询员工的薪水: 使用2位小数, 本地货币代码, 千位符</li></ol><div class="code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> to_char(sal,         <span class="hljs-string">'L9,999.99'</span>)<span class="hljs-keyword">FROM</span> emp;</code></pre></div><p>特别注意:’L9,999.99’之间没有空格</p><ol start="2"><li>将￥2,975.00转化成数字：</li></ol><div class="code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> to_number(<span class="hljs-string">'￥2,975.00'</span>, <span class="hljs-string">'L9,999.99'</span>) 转成数字<span class="hljs-keyword">FROM</span> dual;</code></pre></div><h3><span id="4-6-tong-yong-han-shu-liao-jie">4.6 通用函数(了解)</span><a href="#4-6-tong-yong-han-shu-liao-jie" class="header-anchor">#</a></h3><p>这些函数适用于任何数据类型，同时也适用于空值：</p><p>NVL (expr1, expr2)</p><p>NVL2 (expr1, expr2, expr3)</p><p>NULLIF (expr1, expr2)</p><p>COALESCE (expr1, expr2, …, expr<strong>n</strong>)</p><p> nvl2:是nvl函数的增强版。    nvl2(a, b, c)  当a = null 返回 c, 否则返回b</p><p>使用nvl2求员工的年收入：</p><div class="code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> empno,         ename,         sal,         sal<span class="hljs-operator">*</span><span class="hljs-number">12</span>,         sal <span class="hljs-operator">*</span> <span class="hljs-number">12</span> <span class="hljs-operator">+</span> nvl2(comm,         comm,         <span class="hljs-number">0</span>) 年薪<span class="hljs-keyword">FROM</span> emp;</code></pre></div><p>nullif: nullif(a, b) 当 a = b 时返回null, 不相等的时候返回a值。</p><p><code>select nullif('hello', 'hello') from dual; </code> 返回空</p><p><code>select nullif('hello', 'world') from dual;</code> 返回hello</p><p><code>select ename, nullif(comm, null) from emp;</code></p><p>coalesce:coalesce(a, b, c, …, n) 从左向右找参数中第一个不为空的值。</p><div class="code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> comm,         sal,         <span class="hljs-built_in">coalesce</span>(comm,         sal) 结果值<span class="hljs-keyword">FROM</span> emp;</code></pre></div><h3><span id="4-7-tiao-jian-biao-da-shi">4.7 条件表达式</span><a href="#4-7-tiao-jian-biao-da-shi" class="header-anchor">#</a></h3><p>例子：老板打算给员工涨工资, 要求：</p><p>总裁(PRESIDENT)涨1000, 经理(MANAGER)涨800, 其他人涨400. 请将涨前, 涨后的薪水列出。</p><p>涨后的薪水是根据job来判断的</p><p>思路：    if 是总裁(‘PRESIDENT’)  then + 1000</p><div class="code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">else</span> if 是经理(<span class="hljs-string">'MANAGER'</span>)  <span class="hljs-keyword">then</span> <span class="hljs-operator">+</span> <span class="hljs-number">800</span><span class="hljs-keyword">else</span> <span class="hljs-operator">+</span> <span class="hljs-number">400</span></code></pre></div><p>但是在SQL中无法实现if else 逻辑。当有这种需求的时候，可以使用case 或者 decode        </p><p>case:是一个表达式，其语法为：</p><div class="code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">CASE</span> <span class="hljs-operator">*</span>expr    <span class="hljs-keyword">WHEN</span> <span class="hljs-operator">*</span>comparison_expr1 <span class="hljs-keyword">THEN</span>    <span class="hljs-operator">*</span>return_expr1 [<span class="hljs-keyword">WHEN</span> <span class="hljs-operator">*</span>comparison_expr2 <span class="hljs-keyword">THEN</span>    <span class="hljs-operator">*</span>return_expr2    <span class="hljs-keyword">WHEN</span> <span class="hljs-operator">*</span>comparison_exprn <span class="hljs-keyword">THEN</span>    <span class="hljs-operator">*</span>return_exprn    <span class="hljs-keyword">ELSE</span> <span class="hljs-operator">*</span>else_expr]    <span class="hljs-keyword">END</span> <span class="hljs-keyword">SQL</span><span class="hljs-operator">&gt;</span><span class="hljs-keyword">SELECT</span> ename,         job,         sal 涨前薪水,            <span class="hljs-keyword">CASE</span> job    <span class="hljs-keyword">WHEN</span> <span class="hljs-string">'PRESIDENT'</span> <span class="hljs-keyword">THEN</span>    sal<span class="hljs-operator">+</span><span class="hljs-number">1000</span>    <span class="hljs-keyword">WHEN</span> <span class="hljs-string">'MANAGER'</span> <span class="hljs-keyword">THEN</span>    sal<span class="hljs-operator">+</span><span class="hljs-number">800</span>    <span class="hljs-keyword">ELSE</span> sal <span class="hljs-operator">+</span> <span class="hljs-number">400</span>    <span class="hljs-keyword">END</span> 涨后薪水<span class="hljs-keyword">FROM</span> emp;</code></pre></div><p>注意语法：when then 与下一个when then以及end之间没有“,”分割符, 可以将when当成if.</p><p>decode：是一个函数，其语法为：</p><p>DECODE(*col|expression, search1, result1 </p><div class="code-wrapper"><pre><code class="hljs">   [*, search2, result2,...,]      [*, default])</code></pre></div><p>除第一个和最后一个参数之外，中间的参数都是成对呈现的 (参1, 条件, 值, 条件, 值, …, 条件, 值, 尾参)</p><div class="code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> ename,         job,         sal 涨前薪水,         decode(job,         <span class="hljs-string">'PRESIDENT'</span>, sal <span class="hljs-operator">+</span> <span class="hljs-number">1000</span>, <span class="hljs-string">'MANAGER'</span>, sal <span class="hljs-operator">+</span> <span class="hljs-number">800</span>, sal <span class="hljs-operator">+</span> <span class="hljs-number">400</span>) <span class="hljs-keyword">AS</span> 涨后薪水<span class="hljs-keyword">FROM</span> emp;</code></pre></div><h2><span id="5-fen-zu-han-shu">5 分组函数</span><a href="#5-fen-zu-han-shu" class="header-anchor">#</a></h2><h3><span id="5-1-fen-zu-han-shu">5.1分组函数</span><a href="#5-1-fen-zu-han-shu" class="header-anchor">#</a></h3><p>多行函数也叫组函数，本章学习目标:</p><ul><li><p>了解组函数。</p></li><li><p>描述组函数的用途。</p></li><li><p>使用GROUP BY 子句数据分组。</p></li><li><p>使用HAVING 子句过滤分组结果集。</p></li></ul><p>分组函数作用于一组数据，并对一组数据返回一个值</p><p>常用的有5个函数: avg、count、max、min、sum操作的是一组数据，返回一个结果。</p><p>案例</p><ol><li>求员工的工资总额</li></ol><div class="code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-built_in">sum</span>(sal)<span class="hljs-keyword">FROM</span> emp;</code></pre></div><ol start="2"><li>求员工人数</li></ol><div class="code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-built_in">count</span>(<span class="hljs-operator">*</span>)<span class="hljs-keyword">FROM</span> emp;</code></pre></div><ol start="3"><li>平均工资</li></ol><div class="code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-built_in">sum</span>(sal)<span class="hljs-operator">/</span><span class="hljs-built_in">count</span>(<span class="hljs-operator">*</span>) 方式一,         <span class="hljs-built_in">avg</span>(sal) 方式二<span class="hljs-keyword">FROM</span> emp;</code></pre></div><p>方式一和方式二结果一样, 当有空值得时候结果有可能不一样。如：奖金。</p><ol start="4"><li>求员工的平均奖金</li></ol><div class="code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-built_in">sum</span>(comm)<span class="hljs-operator">/</span><span class="hljs-built_in">count</span>(<span class="hljs-operator">*</span>) 方式一,         <span class="hljs-built_in">sum</span>(comm)<span class="hljs-operator">/</span><span class="hljs-built_in">count</span>(comm) 方式二,         <span class="hljs-built_in">avg</span>(comm) 方式三<span class="hljs-keyword">FROM</span> emp;</code></pre></div><p>结果：方式一结果不同，方式二 和 方式三结果一样。</p><p>说明: avg(comm)是求comm有值的几个的平均值, 跟方式二是相同的.</p><p>NULL空值：组函数都有自动滤空功能(忽略空值)，所以：        </p><p><code>select count(*), count(comm) from emp;</code> 执行结果不相同。</p><p>说明: count(comm)返回不为空的comm的总个数</p><p>如何屏蔽组函数的滤空功能?            </p><div class="code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-built_in">count</span>(<span class="hljs-operator">*</span>),         <span class="hljs-built_in">count</span>(nvl(comm,        <span class="hljs-number">0</span>))<span class="hljs-keyword">FROM</span> emp;</code></pre></div><p>但是实际应用中, 结果为14和结果为4都有可能对，看问题本身是否要求统计空值。</p><p>5 count函数</p><p>求emp表的部门总个数, 如果要求不重复的个数, 使用distinct。    </p><div class="code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-built_in">count</span>(<span class="hljs-keyword">distinct</span> deptno)<span class="hljs-keyword">FROM</span> emp;</code></pre></div><p>求emp表中的工种的总个数</p><div class="code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-built_in">count</span>(<span class="hljs-keyword">distinct</span> job)<span class="hljs-keyword">FROM</span> emp;</code></pre></div><h3><span id="5-2-fen-zu-shu-ju">5.2 分组数据</span><a href="#5-2-fen-zu-shu-ju" class="header-anchor">#</a></h3><p>分组数据使用<strong>group by</strong>关键字.    </p><p>按照<code>group by</code> 后给定的表达式，将from后面的table进行分组。针对每一组，使用组函数, 即先分组, 再分组统计.</p><p>案例</p><ol><li>查询“部门”的平均工资：</li></ol><p>分析: 结合<code>select * from emp order by deptno; </code> 结果分析分组</p><div class="code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> deptno,         <span class="hljs-built_in">avg</span>(sal)<span class="hljs-keyword">FROM</span> emp<span class="hljs-keyword">GROUP</span> <span class="hljs-keyword">BY</span>  deptno;</code></pre></div><div class="code-wrapper"><pre><code class="hljs">上SQL语句可以抽象成：select a, 组函数(x) from 表 group by a;  这样的格式。</code></pre></div><p>如果select a, b, 组函数(x) …… group by 应该怎么写？                        </p><p>注意: 在select列表中所有没有包含在组函数中的列, 都必须在group by的后面出现.所以上面的问题应该写成group by a, b; 没有b就会出错, 不会执行sql语句。但, 反之可以。group by a，b，c;  c可以不出现在select语句中。   </p><p>group by后面有多列的情况：</p><ol start="2"><li>查询部门内部不同职位的平均工资:</li></ol><div class="code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> deptno,         job,         <span class="hljs-built_in">avg</span>(sal)<span class="hljs-keyword">FROM</span> emp<span class="hljs-keyword">GROUP</span> <span class="hljs-keyword">BY</span>  deptno, job<span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span>  <span class="hljs-number">1</span>;</code></pre></div><p>分析该SQL的作用：</p><div class="code-wrapper"><pre><code class="hljs">因为`deptno, job` 两列没有在组函数里面，所以必须同时在group by后面。</code></pre></div><p>该SQL的语义:按部门, 不同的职位统计平均工资。先按第一列分组, 如果第一列相同, 再按第二列分组, 所以查询结果中，同一部门中没有重复的职位。</p><p>关于分组函数常见的问题:</p><ol><li>在select后面出现的列, 该列没有出现在分组函数中, 但是未出现在<code>group by</code>子句中.</li></ol><p>如: <code>select deptno, job, avg(sal) from emp group by deptno;</code></p><p>—-job未出现在group by子句中</p><p>报错: ORA-00979: 不是 GROUP BY 表达式.</p><ol start="2"><li><code>select count(*) from emp;</code></li></ol><p>分析: count是分组函数, 但是select后面没有其他列, 所以不必非出现group by子句,</p><p>该sql语句意思是统计emp表中员工总数;</p><p>当然: `select count(*) from emp group by deptno; 也对, 但是查询出来的结果并不知道是</p><p>哪个组的总数.</p><h3><span id="5-3-having">5.3 Having</span><a href="#5-3-having" class="header-anchor">#</a></h3><p>使用 HAVING 过滤分组:</p><ol><li><p>行已经被分组。</p></li><li><p>使用了组函数。</p></li><li><p>满足HAVING 子句中条件的分组将被显示。</p></li></ol><p>其语法：</p><p><strong>SELECT    column, group_function</strong></p><p><strong>FROM        table</strong></p><p><strong>[WHERE    condition]</strong></p><p><strong>[GROUP BY    group_by_expression]</strong></p><p><strong>[HAVING    group_condition]</strong></p><p><strong>[ORDER BY    column]</strong>;</p><p>查询平均薪水大于2000的部门 ：        </p><p>分析：该问题实际上是在分组的基础上过滤分组。</p><div class="code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> deptno,         <span class="hljs-built_in">avg</span>(sal)<span class="hljs-keyword">FROM</span> emp<span class="hljs-keyword">GROUP</span> <span class="hljs-keyword">BY</span>  deptno<span class="hljs-keyword">HAVING</span> <span class="hljs-built_in">avg</span>(sal)<span class="hljs-operator">&gt;</span><span class="hljs-number">2000</span>;</code></pre></div><p>注意：<code>having</code>后面不能使用别名, 可以使用函数</p><p>​                            </p><p>特别注意: 不能在 <code>WHERE</code> 子句中使用组函数.</p><p>可以在 HAVING 子句中使用组函数。</p><div class="code-wrapper"><pre><code class="hljs">从功能上讲，where和having都是将满足条件的结果进行过滤。但是差别是where子句中不能使用组函数, 所以上句中的having不可以使用where代替。</code></pre></div><p>求10号部门的平均工资：        </p><p>分析：在上一条的基础上，<code>having deptno=10;</code></p><div class="code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> deptno,         <span class="hljs-built_in">avg</span>(sal)<span class="hljs-keyword">FROM</span> emp<span class="hljs-keyword">GROUP</span> <span class="hljs-keyword">BY</span>  deptno<span class="hljs-keyword">HAVING</span> deptno<span class="hljs-operator">=</span><span class="hljs-number">10</span>;</code></pre></div><p>使用where也可以做这件事</p><div class="code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> deptno,         <span class="hljs-built_in">avg</span>(sal)<span class="hljs-keyword">FROM</span> emp<span class="hljs-keyword">WHERE</span> deptno<span class="hljs-operator">=</span><span class="hljs-number">10</span><span class="hljs-keyword">GROUP</span> <span class="hljs-keyword">BY</span>  deptno;</code></pre></div><p>在子句中没有使用组函数的情况下，where、having都可以，应该怎么选择？    </p><p>SQL优化： 尽量采用where。</p><p>如果有分组的话，where是先过滤再分组，而having是先分组再过滤。当数据量庞大如1亿条，where优势明显。</p><h2><span id="6-duo-biao-cha-xun">6 多表查询</span><a href="#6-duo-biao-cha-xun" class="header-anchor">#</a></h2><p>理论基础：——笛卡尔集                                                               </p><ul><li><p>笛卡尔集的行数 = table1的行数 x table2的行数</p></li><li><p>笛卡尔集的列数 = table1的列数 + table2的列数</p></li></ul><p><img src="https://gitee.com/txt1994/images/raw/master/img/Oracle/wps8.jpg"></p><p>在操作笛卡尔集的时候，应该避免使用“笛卡尔全集”，因为里面含有大量错误信息。</p><p>多表查询就是按照给定条件(连接条件)，从笛卡尔全集中选出正确的结果。</p><p>根据连接条件的不同可以划分为：等值链接、不等值链接、外链接、自连接    </p><p>Oracle 连接:</p><p> Equijoin：等值连接</p><p>Non-equijoin：不等值连接</p><p>Outer join：外连接</p><p> Self join：自连接</p><p>SQL: 1999</p><p>Cross joins</p><p>Natural joins</p><p>Using clause</p><p>Full or two sided outer joins</p><h3><span id="6-1-deng-zhi-lian-jie">6.1 等值连接：</span><a href="#6-1-deng-zhi-lian-jie" class="header-anchor">#</a></h3><p>​    从概念上，区分等值连接和不等值连接非常简单，只需要辨别where子句后面的条件，是“=”为等值连接。不是“=”为不等值连接。</p><p>查询员工信息：员工号 姓名 月薪和部门名称        </p><p>​    分析：这个问题涉及emp(员工号，姓名，月薪) 和dept(部门名称)两张表  ——即为多表查询。</p><p>​    通常在进行多表查询的时，会给表起一个别名，使用“别名.列名”的方式来获取数据，直接使用“表名.列名”语法上是允许的，但是实际很少这样用。</p><p>如果：<code>select e.empno, e.ename, e.sal, e.deptno, d.dname, d.deptno  from emp e, dept d; </code> </p><p>直接得到的是笛卡尔全集。其中有错误结果。所以应该加 where 条件进行过滤.</p><div class="code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> e.empno,         e.ename,         e.sal,         d.dname<span class="hljs-keyword">FROM</span> emp e, dept d<span class="hljs-keyword">WHERE</span> e.deptno<span class="hljs-operator">=</span>d.deptno;</code></pre></div><p>如果有N个表，where后面的条件至少应该有N-1个, 才会不产生笛卡尔积.</p><h3><span id="6-2-bu-deng-zhi-lian-jie">6.2 不等值连接：</span><a href="#6-2-bu-deng-zhi-lian-jie" class="header-anchor">#</a></h3><p>将上面的问题稍微调整下，查询员工信息：员工号 姓名 月薪 和 薪水级别(salgrade表)</p><div class="code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span><span class="hljs-keyword">FROM</span> salgrade;</code></pre></div><p>看到员工总的薪水级别，共有5级，员工的薪水级别应该满足 &gt;=当前级别的下限，&lt;=该级别的上限：</p><p>过滤子句应该：    <code>where e.sal &gt;= s.losal and e.sal &lt;= s.hisal;</code></p><div class="code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> e.empno,         e.ename,         e.sal,         s.grade<span class="hljs-keyword">FROM</span> emp e, salgrade s<span class="hljs-keyword">WHERE</span> e.sal <span class="hljs-operator">&gt;=</span> s.losal        <span class="hljs-keyword">AND</span> e.sal <span class="hljs-operator">&lt;=</span> s.hisal;</code></pre></div><p>更好的写法应该使用between…and:</p><div class="code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> s.grade,         e.empno,         e.ename,         e.sal,         e.job<span class="hljs-keyword">FROM</span> emp e, salgrade s<span class="hljs-keyword">WHERE</span> e.sal    <span class="hljs-keyword">BETWEEN</span> s.losal        <span class="hljs-keyword">AND</span> s.hisal<span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span>  <span class="hljs-number">1</span>;</code></pre></div><h3><span id="6-3-wai-lian-jie">6.3 外链接：</span><a href="#6-3-wai-lian-jie" class="header-anchor">#</a></h3><p><strong>l</strong> 按部门统计员工人数，显示： 部门号 部门名称 人数</p><p>分析:</p><p>​    人数：一定是在emp表中，使用count()函数统计emp表中任一非空列均可。</p><p>​        部门名称：在dept表dname中, 直接读取即可。</p><p>​        部门号：任意，两张表都有, 两个表的联系是deptno.</p><p>所以: </p><div class="code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> d.deptno 部门号,         d.dname 部门名称,         <span class="hljs-built_in">count</span>(e.empno) 人数<span class="hljs-keyword">FROM</span> emp e, dept d<span class="hljs-keyword">WHERE</span> e.deptno<span class="hljs-operator">=</span>d.deptno<span class="hljs-keyword">GROUP</span> <span class="hljs-keyword">BY</span>  d.deptno, d.dname;</code></pre></div><p>注意：由于使用了组函数count()，所以组函数外的<code>d.deptno</code>和<code>d.dname</code>必须放到group by后。</p><p>得到查询结果，但是<code>select * from dept</code>发现40号部门没有显示出来，原因是40号部门没有员工，where没满足。结果不对，40号部门没有员工，应该在40号部门位置显示0。</p><p>我们希望： 在最后的结果中，包含某些对于where条件来说不成立的记录 （外链接的作用）</p><p>l 左外链接：当 <code>where e.deptno=d.deptno</code> 不成立的时候，=左边所表示的信息，仍然被包含。</p><p>​    写法：与叫法相反：<code>where e.deptno=d.deptno(+)</code>  </p><p>l 右外链接：当 <code>where e.deptno=d.deptno</code> 不成立的时候，=右边所表示的信息，仍然被包含。</p><p>​    写法：依然与叫法相反：<code>where e.deptno(+)=d.deptno</code></p><p>以上我们希望将没有员工的部门仍然包含到查询的结果当中。因此应该使用外链接的语法。</p><p>写法1:</p><div class="code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> d.deptno 部门号,         d.dname 部门名称,         <span class="hljs-built_in">count</span>(e.empno) 人数<span class="hljs-keyword">FROM</span> emp e, dept d<span class="hljs-keyword">WHERE</span> e.deptno(<span class="hljs-operator">+</span>)<span class="hljs-operator">=</span>d.deptno<span class="hljs-keyword">GROUP</span> <span class="hljs-keyword">BY</span>  d.deptno, d.dname;</code></pre></div><p>写法2:</p><div class="code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> d.deptno 部门号,         d.dname 部门名称,         <span class="hljs-built_in">count</span>(e.empno) 人数<span class="hljs-keyword">FROM</span> emp e, dept d<span class="hljs-keyword">WHERE</span> d.deptno <span class="hljs-operator">=</span> e.deptno(<span class="hljs-operator">+</span>)<span class="hljs-keyword">GROUP</span> <span class="hljs-keyword">BY</span>  d.deptno, d.dname;</code></pre></div><p>这样就可以将40号部门包含到整个查询结果中。人数是0</p><p>注意：不能使用count(e.*), 应该是某个表的具体的列.</p><p>思考: 能否使用count(<em>), count(</em>)与count(e.empno)有什么不同???</p><h3><span id="6-4-zi-lian-jie">6.4 自连接：</span><a href="#6-4-zi-lian-jie" class="header-anchor">#</a></h3><p>核心，通过表的别名，将同一张表视为多张表。 </p><p>例如: 查询员工信息：xxx的老板是 yyy </p><p>分析：执行<code>select * from emp;</code> 发现，员工的老板也在员工表之中，是一张表。要完成多表查询我们可以假设，有两张表，一张表e(emp)只存员工、另一张表b(boss)只存员工的老板。—— from e, b;</p><p>老板和员工之间的关系应该是：<code>where e.mgr=b.empno</code> (即:员工表的老板 = 老板表的员工)</p><div class="code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> e.ename <span class="hljs-operator">||</span> <span class="hljs-string">' 的老板是 '</span> <span class="hljs-operator">||</span> b.ename<span class="hljs-keyword">FROM</span> emp e, emp b<span class="hljs-keyword">WHERE</span> e.mgr<span class="hljs-operator">=</span>b.empno;</code></pre></div><p>执行, 发现结果正确了, 但是KING没有显示出来. KING的老板是他自己. 应该怎么显示呢?</p><p>使用外连接:</p><div class="code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> e.ename <span class="hljs-operator">||</span> <span class="hljs-string">' 的老板是 '</span> <span class="hljs-operator">||</span> nvl(b.ename, <span class="hljs-string">'他自己'</span> )<span class="hljs-keyword">FROM</span> emp e, emp b<span class="hljs-keyword">WHERE</span> e.mgr<span class="hljs-operator">=</span>b.empno(<span class="hljs-operator">+</span>);</code></pre></div><p>使用concat函数应该怎么做呢??</p><div class="code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> concat(e.ename,         concat(<span class="hljs-string">' 的老板是 '</span>, nvl(b.ename, <span class="hljs-string">'他自己'</span> )))<span class="hljs-keyword">FROM</span> emp e, emp b<span class="hljs-keyword">WHERE</span> e.mgr <span class="hljs-operator">=</span> b.empno(<span class="hljs-operator">+</span>);</code></pre></div><h2><span id="7-zi-cha-xun">7 子查询</span><a href="#7-zi-cha-xun" class="header-anchor">#</a></h2><p>子查询语法很简单，就是select 语句的嵌套使用, 即sql嵌套sql。</p><p>查询工资比SCOTT高的员工信息.</p><div class="code-wrapper"><pre><code class="hljs">分析：两步即可完成</code></pre></div><ol><li>查出SCOTT的工资</li></ol><div class="code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> ename,         sal<span class="hljs-keyword">FROM</span> emp<span class="hljs-keyword">WHERE</span> ename<span class="hljs-operator">=</span><span class="hljs-string">'SCOTT'</span>; # 结果为<span class="hljs-number">3000</span></code></pre></div><ol start="2"><li>查询比3000高的员工</li></ol><div class="code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span><span class="hljs-keyword">FROM</span> emp<span class="hljs-keyword">WHERE</span> sal<span class="hljs-operator">&gt;</span><span class="hljs-number">3000</span>;</code></pre></div><p>通过两步可以将问题结果得到。子查询，可以将两步合成一步。</p><p>——子查询解决的问题：问题本身不能一步求解的情况。                                    </p><div class="code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span><span class="hljs-keyword">FROM</span> emp<span class="hljs-keyword">WHERE</span> sal <span class="hljs-operator">&gt;</span>     (<span class="hljs-keyword">SELECT</span> sal    <span class="hljs-keyword">FROM</span> emp    <span class="hljs-keyword">WHERE</span> ename<span class="hljs-operator">=</span><span class="hljs-string">'SCOTT'</span>);</code></pre></div><p>子查询语法格式：</p><div class="code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span>select_list<span class="hljs-keyword">FROM</span> <span class="hljs-operator">*</span><span class="hljs-keyword">table</span><span class="hljs-keyword">WHERE</span> <span class="hljs-operator">*</span>expr operator     (<span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span>select_list    <span class="hljs-keyword">FROM</span> <span class="hljs-operator">*</span><span class="hljs-keyword">table</span>);</code></pre></div><p>本章学习目标: </p><p>描述子查询可以解决的问题</p><p>定义子查询(子查询的语法)</p><p>列出子查询的类型。</p><p>书写单行子查询和多行子查询。</p><h3><span id="7-1-ding-yi-zi-cha-xun-xu-yao-zhu-yi-de-wen-ti">7.1 定义子查询 需要注意的问题</span><a href="#7-1-ding-yi-zi-cha-xun-xu-yao-zhu-yi-de-wen-ti" class="header-anchor">#</a></h3><ol><li>合理的书写风格 (如上例，当写一个较复杂的子查询的时候，要合理的添加换行、缩</li></ol><p>进) </p><ol start="2"><li><p>小括号( ) </p></li><li><p>主查询和子查询可以是不同表，只要子查询返回的结果主查询可以使用即可</p></li><li><p>可以在主查询的<code>where</code>、<code>select</code>、<code>having</code>、<code>from</code>后都可以放置子查询</p></li><li><p>不可以在主查询的<code>group by</code>后面放置子查询 (SQL语句的语法规范)</p></li><li><p>强调：在from后面放置的子查询(***), from后面放置是一个集合(表、查询结果)</p></li><li><p>一般先执行子查询(内查询)，再执行主查询(外查询)；但是相关子查询除外     </p></li><li><p>一般不在子查询中使用<code>order by</code>, 但在Top-N分析问题中，必须使用order by  </p></li><li><p>单行子查询只能使用单行操作符；多行子查询只能使用多行操作符</p></li><li><p>子查询中的null值</p></li></ol><h3><span id="7-2-zhu-zi-cha-xun-zai-bu-tong-biao-jian-jin-xing">7.2 主、子查询在不同表间进行。</span><a href="#7-2-zhu-zi-cha-xun-zai-bu-tong-biao-jian-jin-xing" class="header-anchor">#</a></h3><p>查询部门名称是“SALES”的员工信息 </p><p>主查询：查询员工信息。<code>select * from emp;</code>    </p><p>子查询：负责根据部门名称(在dept表中)得到部门号。</p><div class="code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> deptno<span class="hljs-keyword">FROM</span> dept<span class="hljs-keyword">WHERE</span> dname<span class="hljs-operator">=</span><span class="hljs-string">'SALES'</span>;</code></pre></div><div class="code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span><span class="hljs-keyword">FROM</span> emp<span class="hljs-keyword">WHERE</span> deptno<span class="hljs-operator">=</span>     (<span class="hljs-keyword">SELECT</span> deptno    <span class="hljs-keyword">FROM</span> dept    <span class="hljs-keyword">WHERE</span> dname<span class="hljs-operator">=</span><span class="hljs-string">'SALES'</span>);</code></pre></div><div class="code-wrapper"><pre><code class="hljs">主查询, 查询的是员工表emp, 子查询, 查询的是部门表dept。是两张不同的表。</code></pre></div><p>将该问题使用“多表查询”解决</p><div class="code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> e.<span class="hljs-operator">*</span><span class="hljs-keyword">FROM</span> emp e, dept d<span class="hljs-keyword">WHERE</span> e.deptno<span class="hljs-operator">=</span>d.deptno        <span class="hljs-keyword">AND</span> d.dname<span class="hljs-operator">=</span><span class="hljs-string">'SALES'</span>;</code></pre></div><p>两种方式哪种好呢？</p><p>SQL优化: 理论上，既可以使用子查询，也可以使用多表查询，尽量使用“多表查询”。子查询有2次from, 与数据库服务的交互多.</p><p>不同数据库处理数据的方式不尽相同，如Oracle数据库中，子查询地位比较重要，做了深入的优化。有可能实际看到结果是子查询快于多表查询。</p><h3><span id="7-3-zai-zhu-cha-xun-de-where-select-having-from-fang-zhi-zi-cha-xun">7.3 在主查询的where select having from 放置子查询</span><a href="#7-3-zai-zhu-cha-xun-de-where-select-having-from-fang-zhi-zi-cha-xun" class="header-anchor">#</a></h3><p>子查询可以放在select后，但，要求该子查询必须是单行子查询：(该子查询本身只返回一条记录，2+叫多行子查询)</p> <div class="code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> empno,         ename,             (<span class="hljs-keyword">SELECT</span> dname    <span class="hljs-keyword">FROM</span> dept) 部门<span class="hljs-keyword">FROM</span> emp;</code></pre></div><p>注意：SQL中没有where是不可以的，那样是多行子查询。–但这是不符合实际情况的.</p><p>  应该: </p><div class="code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> empno,         ename,             (<span class="hljs-keyword">SELECT</span> dname    <span class="hljs-keyword">FROM</span> dept    <span class="hljs-keyword">WHERE</span> deptno <span class="hljs-operator">=</span> <span class="hljs-number">10</span>) 部门<span class="hljs-keyword">FROM</span> emp<span class="hljs-keyword">WHERE</span> deptno <span class="hljs-operator">=</span> <span class="hljs-number">10</span>;</code></pre></div><p>进一步理解查询语句，实际上是在表或集合中通过列名来得到行数据，子查询如果是多行，select无法做到这一点。</p><p>在 having 后 和 where 类似。但需注意在where后面不能使用组函数。 </p><p>在having后面使用子查询的例子: </p><p>查询部门平均工资高于30号部门平均工资的部门和平均工资</p><div class="code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> deptno,         <span class="hljs-built_in">avg</span>(sal)<span class="hljs-keyword">FROM</span> emp<span class="hljs-keyword">GROUP</span> <span class="hljs-keyword">BY</span>  deptno<span class="hljs-keyword">HAVING</span> <span class="hljs-built_in">avg</span>(sal) <span class="hljs-operator">&gt;</span>     (<span class="hljs-keyword">SELECT</span> <span class="hljs-built_in">avg</span>(sal)    <span class="hljs-keyword">FROM</span> emp    <span class="hljs-keyword">WHERE</span> deptno <span class="hljs-operator">=</span> <span class="hljs-number">30</span>);</code></pre></div><h3><span id="7-4-zai-from-hou-mian-fang-zhi-de-zi-cha-xun">7.4 在from后面放置的子查询(***)</span><a href="#7-4-zai-from-hou-mian-fang-zhi-de-zi-cha-xun" class="header-anchor">#</a></h3><p>表, 代表一个数据集合、查询结果(SQL)语句本身也代表一个集合, 把查询结果看成一个表.</p><p>查询员工的姓名、薪水和年薪：</p><div class="code-wrapper"><pre><code class="hljs">说明：该问题不用子查询也可以完成。但如果是一道填空题：</code></pre></div><p>select * from ___________________</p><p>因为显示的告诉了，要使用select *, 所以只能:</p><div class="code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span><span class="hljs-keyword">FROM</span>     (<span class="hljs-keyword">SELECT</span> ename,         sal,         sal<span class="hljs-operator">*</span><span class="hljs-number">12</span> 年薪    <span class="hljs-keyword">FROM</span> emp);</code></pre></div><p>将select 语句放置到from后面，表示将select语句的结果，当成表来看待. 这种查询方式在Oracle语句中使用比较频繁.</p><h3><span id="7-5-dan-xing-zi-cha-xun-zhi-neng-shi-yong-dan-xing-cao-zuo-fu-duo-xing-zi-cha-xun-zhi-neng-shi-yong-duo-xing-cao-zuo-fu">7.5 单行子查询只能使用单行操作符；多行子查询只能使用多行操作符</span><a href="#7-5-dan-xing-zi-cha-xun-zhi-neng-shi-yong-dan-xing-cao-zuo-fu-duo-xing-zi-cha-xun-zhi-neng-shi-yong-duo-xing-cao-zuo-fu" class="header-anchor">#</a></h3><h4><span id="7-5-1-dan-xing-zi-cha-xun">7.5.1单行子查询：</span><a href="#7-5-1-dan-xing-zi-cha-xun" class="header-anchor">#</a></h4><p>单行子查询就是该条子查询执行结束时, 只返回一条记录(一行数据)。</p><p>使用单行操作符:</p><p>=、&gt;、&gt;=、&lt;、&lt;=、&lt;&gt;或者!=                                            </p><p>单行子查询:     </p><ol><li><p>单行子查询, 只能使用单行操作符</p></li><li><p>在一个主查询中可以有多个子查询。</p></li><li><p>子查询里面可以嵌套多层子查询。</p></li><li><p>子查询也可以使用组函数。子查询也是查询语句，适用于前面所有知识。</p></li></ol><p>案例:</p><ol><li>查询emp表部门编号为10且高于本部门的平均工资的员工信息</li></ol><div class="code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span><span class="hljs-keyword">FROM</span> emp<span class="hljs-keyword">WHERE</span> sal<span class="hljs-operator">&gt;</span>    (<span class="hljs-keyword">SELECT</span> <span class="hljs-built_in">avg</span>(sal)    <span class="hljs-keyword">FROM</span> emp    <span class="hljs-keyword">WHERE</span> deptno<span class="hljs-operator">=</span><span class="hljs-number">10</span>)        <span class="hljs-keyword">AND</span> deptno<span class="hljs-operator">=</span><span class="hljs-number">10</span>;</code></pre></div><ol start="2"><li>查询emp表中与SMITH职位相同的员工信息</li></ol><div class="code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span><span class="hljs-keyword">FROM</span> emp<span class="hljs-keyword">WHERE</span> job <span class="hljs-operator">=</span>     (<span class="hljs-keyword">SELECT</span> job    <span class="hljs-keyword">FROM</span> emp    <span class="hljs-keyword">WHERE</span> ename<span class="hljs-operator">=</span><span class="hljs-string">'SMITH'</span>);</code></pre></div><ol start="3"><li>查询薪水低于本公司的平均薪水且职位与SMITH职位相同的所有员工信息</li></ol><div class="code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span><span class="hljs-keyword">FROM</span> emp<span class="hljs-keyword">WHERE</span> sal<span class="hljs-operator">&lt;</span>    (<span class="hljs-keyword">SELECT</span> <span class="hljs-built_in">avg</span>(sal)    <span class="hljs-keyword">FROM</span> emp)        <span class="hljs-keyword">AND</span> job<span class="hljs-operator">=</span>    (<span class="hljs-keyword">SELECT</span> job    <span class="hljs-keyword">FROM</span> emp    <span class="hljs-keyword">WHERE</span> ename<span class="hljs-operator">=</span><span class="hljs-string">'SMITH'</span>);</code></pre></div><ol start="4"><li>查询emp表中最低工资员工和最高工资员工的信息</li></ol><div class="code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span><span class="hljs-keyword">FROM</span> emp<span class="hljs-keyword">WHERE</span> sal<span class="hljs-operator">=</span>    (<span class="hljs-keyword">SELECT</span> <span class="hljs-built_in">max</span>(sal)    <span class="hljs-keyword">FROM</span> emp)        <span class="hljs-keyword">OR</span> sal<span class="hljs-operator">=</span>    (<span class="hljs-keyword">SELECT</span> <span class="hljs-built_in">min</span>(sal)    <span class="hljs-keyword">FROM</span> emp);</code></pre></div><p>5 思考??,下列sql语句正确吗? </p><div class="code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span><span class="hljs-keyword">FROM</span> emp<span class="hljs-keyword">WHERE</span> sal<span class="hljs-operator">=</span>    (<span class="hljs-keyword">SELECT</span> <span class="hljs-built_in">min</span>(sal)    <span class="hljs-keyword">FROM</span> emp    <span class="hljs-keyword">GROUP</span> <span class="hljs-keyword">BY</span>  deptno);</code></pre></div><p>注意: =、&gt;、&gt;=、&lt;、&lt;=、&lt;&gt;或者!=是单行操作符, 而后面的子查询会返回多条记录,所以会报错, 要解决这个问题要使用多行子查询.</p><h4><span id="7-5-2-duo-xing-zi-cha-xun">7.5.2多行子查询：</span><a href="#7-5-2-duo-xing-zi-cha-xun" class="header-anchor">#</a></h4><p>子查询返回2条记录以上就叫多行。</p><p>多行操作符有：                                            </p><p>IN        等于列表中的任意一个</p><p>ANY    和子查询返回的任意一个值比较</p><p>ALL        和子查询返回的所有值比较</p><p>IN(表示在集合中)：</p><p>解决上面的那个问题?</p><div class="code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span><span class="hljs-keyword">FROM</span> emp<span class="hljs-keyword">WHERE</span> sal <span class="hljs-keyword">IN</span>     (<span class="hljs-keyword">SELECT</span> <span class="hljs-built_in">min</span>(sal)    <span class="hljs-keyword">FROM</span> emp    <span class="hljs-keyword">GROUP</span> <span class="hljs-keyword">BY</span>  deptno);</code></pre></div><p>查询部门名称为SALES和ACCOUNTING的员工信息。</p><p>分析：部门名称在dept表中，员工信息在emp表中,子查询应先去dept表中将SALES和ACCOUNTING的部门号得到，交给主查询得员工信息.</p><div class="code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span><span class="hljs-keyword">FROM</span> emp<span class="hljs-keyword">WHERE</span> deptno <span class="hljs-keyword">IN</span>     (<span class="hljs-keyword">SELECT</span> deptno    <span class="hljs-keyword">FROM</span> dept    <span class="hljs-keyword">WHERE</span> dname <span class="hljs-keyword">IN</span> (<span class="hljs-string">'SALES'</span>, <span class="hljs-string">'ACCOUNTING'</span>));</code></pre></div><div class="code-wrapper"><pre><code class="hljs">也可以使用多表查询来解决该问题：</code></pre></div><div class="code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> e.<span class="hljs-operator">*</span><span class="hljs-keyword">FROM</span> emp e, dept d<span class="hljs-keyword">WHERE</span> e.deptno <span class="hljs-operator">=</span> d.deptno        <span class="hljs-keyword">AND</span> (d.dname <span class="hljs-operator">=</span> <span class="hljs-string">'SALES'</span>        <span class="hljs-keyword">OR</span> d.dname <span class="hljs-operator">=</span> <span class="hljs-string">'ACCOUNTING'</span>);</code></pre></div><p>红色语句也可以用 <code>d.dname in ('SALES ', 'ACCOUNTING ')</code></p><div class="code-wrapper"><pre><code class="hljs">这种解决方式，注意使用()来控制优先级。 </code></pre></div><p>如果查询不是这两个部门的员工，只要把in → not in就可以了，注意不能含有空值。</p><p>ANY(表示和集合中的任意一个值比较)：</p><p>查询薪水比30号部门任意一个员工高的员工信息：</p><p>分析：首先查出30号部门的员工薪水的集合，然后&gt;它就得到了该员工信息。</p><div class="code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span><span class="hljs-keyword">FROM</span> emp<span class="hljs-keyword">WHERE</span> sal <span class="hljs-operator">&gt;</span>     (<span class="hljs-keyword">SELECT</span> sal    <span class="hljs-keyword">FROM</span> emp    <span class="hljs-keyword">WHERE</span> deptno<span class="hljs-operator">=</span><span class="hljs-number">30</span>); # 正确吗？</code></pre></div><p>这样是错的，子句返回多行结果。而‘&gt;’是单行操作符。——应该将‘&gt;’替换成‘&gt; any’</p><p>实际上&gt;集合的任意一个值，就是大于集合的最小值。</p><div class="code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span><span class="hljs-keyword">FROM</span> emp<span class="hljs-keyword">WHERE</span> sal <span class="hljs-operator">&gt;</span> <span class="hljs-keyword">any</span>    (<span class="hljs-keyword">SELECT</span> sal    <span class="hljs-keyword">FROM</span> emp    <span class="hljs-keyword">WHERE</span> deptno<span class="hljs-operator">=</span><span class="hljs-number">30</span>);</code></pre></div><p>若将这条语句改写成单行子查询应该怎么写呢？</p><div class="code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span><span class="hljs-keyword">FROM</span> emp<span class="hljs-keyword">WHERE</span> sal <span class="hljs-operator">&gt;</span>     (<span class="hljs-keyword">SELECT</span> <span class="hljs-built_in">min</span>(sal)    <span class="hljs-keyword">FROM</span> emp    <span class="hljs-keyword">WHERE</span> deptno<span class="hljs-operator">=</span><span class="hljs-number">30</span>);</code></pre></div><p>ALL(表示和集合中的所有值比较)：        </p><p>查询薪水比30号部门所有员工高的员工信息。</p><div class="code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span><span class="hljs-keyword">FROM</span> emp<span class="hljs-keyword">WHERE</span> sal <span class="hljs-operator">&gt;</span> <span class="hljs-keyword">ALL</span>     (<span class="hljs-keyword">SELECT</span> sal    <span class="hljs-keyword">FROM</span> emp    <span class="hljs-keyword">WHERE</span> deptno<span class="hljs-operator">=</span><span class="hljs-number">30</span>);</code></pre></div><p>同样，将该题改写成单行子句查询：</p><div class="code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span><span class="hljs-keyword">FROM</span> emp<span class="hljs-keyword">WHERE</span> sal <span class="hljs-operator">&gt;</span>     (<span class="hljs-keyword">SELECT</span> <span class="hljs-built_in">max</span>(sal)    <span class="hljs-keyword">FROM</span> emp    <span class="hljs-keyword">WHERE</span> deptno<span class="hljs-operator">=</span><span class="hljs-number">30</span>);</code></pre></div><p>对于any 和 all 来说，究竟取最大值还是取最小值，不一定。将上面的两个例子中的“高”换成“低”，any和all就各自取相反的值了。</p><h3><span id="zi-cha-xun-zhong-null">子查询中null</span><a href="#zi-cha-xun-zhong-null" class="header-anchor">#</a></h3><p>判断一个值等于、不等于空，不能使用=和!=号，而应该使用is 和 not。</p><p>如果集合中有NULL值，不能使用not in。如： not in (10， 20， NULL)，但是可以使用in。为什么呢？</p><p>先看一个例子：</p><p>查询不是老板的员工信息：</p><p>分析：不是老板就是树上的叶子节点。在emp表中有列mgr，该列表示该员工的老板的员工号是多少。那么，如果一个员工的员工号在这列中，那么说明这员工是老板，如果不在，说明他不是老板。</p> <div class="code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span><span class="hljs-keyword">FROM</span> emp<span class="hljs-keyword">WHERE</span> empno <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">IN</span>     (<span class="hljs-keyword">SELECT</span> mgr    <span class="hljs-keyword">FROM</span> emp);</code></pre></div><p>但是运行没有结果，因为有NULL </p><p>查询是老板的员工信息：只需要将not去掉。</p><div class="code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span><span class="hljs-keyword">FROM</span> emp<span class="hljs-keyword">WHERE</span> empno <span class="hljs-keyword">IN</span>     (<span class="hljs-keyword">SELECT</span> mgr    <span class="hljs-keyword">FROM</span> emp );</code></pre></div><p>还是我们之前null的结论：in (10, 20, null) 可以，not in (10, 20, null) 不可以</p><p><code>select * from emp where deptno in (10, 20, null);</code>—–可以</p><div class="code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span><span class="hljs-keyword">FROM</span> emp<span class="hljs-keyword">WHERE</span> deptno <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">IN</span> (<span class="hljs-number">10</span>, <span class="hljs-number">20</span>, <span class="hljs-keyword">null</span>);# <span class="hljs-comment">-----不可以</span></code></pre></div><p>例如：a not in(10, 20, NULL) 等价于 (a != 10) and (a != 20) and (a != NULL) </p><p>因为, not in操作符等价于 !=All，最后一个表达式为假，整体假;</p><p>而a in (10, 20, NULL)等价于(a = 10) or (a = 20) or (a = null)只要有一个为真即为真。</p><div class="code-wrapper"><pre><code class="hljs">     in 操作符等价于 = Any </code></pre></div><div class="code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span><span class="hljs-keyword">FROM</span> emp<span class="hljs-keyword">WHERE</span> deptno <span class="hljs-operator">=</span> <span class="hljs-keyword">any</span>(<span class="hljs-number">10</span>, <span class="hljs-number">20</span>, <span class="hljs-keyword">null</span>);# 等价于<span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span><span class="hljs-keyword">FROM</span> emp<span class="hljs-keyword">WHERE</span> deptno <span class="hljs-keyword">IN</span> (<span class="hljs-number">10</span>, <span class="hljs-number">20</span>, <span class="hljs-keyword">null</span>);</code></pre></div><p>继续，查询不是老板的员工信息, 只要将空值去掉即可。</p><div class="code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span><span class="hljs-keyword">FROM</span> emp<span class="hljs-keyword">WHERE</span> empno <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">IN</span>     (<span class="hljs-keyword">SELECT</span> mgr    <span class="hljs-keyword">FROM</span> emp    <span class="hljs-keyword">WHERE</span> mgr <span class="hljs-keyword">is</span> <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">null</span>);</code></pre></div><p>注意: not in 后面的结合中不能有null</p><h3><span id="yi-ban-bu-zai-zi-cha-xun-zhong-shi-yong-order-by">一般不在子查询中使用order by</span><a href="#yi-ban-bu-zai-zi-cha-xun-zhong-shi-yong-order-by" class="header-anchor">#</a></h3><p>一般情况下，子查询使用<code>order by</code>或是不使用<code>order by</code>对主查询来说没有什么意义。子查询的结果给主查询当成集合来使用，所以没有必要将子查询<code>order by</code>。</p><p>但，在Top-N分析问题中，必须使用<code>order by</code></p><h3><span id="yi-ban-xian-zhi-xing-zi-cha-xun-zai-zhi-xing-zhu-cha-xun">一般先执行子查询，再执行主查询</span><a href="#yi-ban-xian-zhi-xing-zi-cha-xun-zai-zhi-xing-zhu-cha-xun" class="header-anchor">#</a></h3><p>含有子查询的SQL语句执行的顺序是，先子后主。</p><p>但，相关子查询例外.</p><h2><span id="8-ji-he-yun-suan">8 集合运算</span><a href="#8-ji-he-yun-suan" class="header-anchor">#</a></h2><p>l 查询部门号是10和20的员工信息?    有三种方法</p><div class="code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span><span class="hljs-keyword">FROM</span> emp<span class="hljs-keyword">WHERE</span> deptno <span class="hljs-keyword">in</span>(<span class="hljs-number">10</span>, <span class="hljs-number">20</span>);<span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span><span class="hljs-keyword">FROM</span> emp<span class="hljs-keyword">WHERE</span> deptno<span class="hljs-operator">=</span><span class="hljs-number">10</span>        <span class="hljs-keyword">OR</span> deptno<span class="hljs-operator">=</span><span class="hljs-number">20</span>;</code></pre></div><p>n 集合运算：</p><div class="code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span><span class="hljs-keyword">FROM</span> emp<span class="hljs-keyword">WHERE</span> deptno<span class="hljs-operator">=</span><span class="hljs-number">10</span>;# 加上<span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span><span class="hljs-keyword">FROM</span> emp<span class="hljs-keyword">WHERE</span> deptno<span class="hljs-operator">=</span><span class="hljs-number">20</span>;</code></pre></div><p>集合运算所操作的对象是两个或者多个集合，而不再是表中的列(select一直在操作表中的列)</p><h3><span id="8-1-ji-he-yun-suan-fu">8.1 集合运算符</span><a href="#8-1-ji-he-yun-suan-fu" class="header-anchor">#</a></h3><p>集合运算的操作符。A∩B、A∪ B、A - B                                   </p><p><img src="https://gitee.com/txt1994/images/raw/master/img/Oracle/wps9.jpg" alt="img"> </p><div class="code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span><span class="hljs-keyword">FROM</span> emp<span class="hljs-keyword">WHERE</span> deptno<span class="hljs-operator">=</span><span class="hljs-number">10</span><span class="hljs-keyword">UNION</span><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span><span class="hljs-keyword">FROM</span> emp<span class="hljs-keyword">WHERE</span> deptno<span class="hljs-operator">=</span><span class="hljs-number">20</span>;</code></pre></div><p>union和union all的区别: union会去掉重复的, 而union all会全部显示</p><p>注意：这是一条SQL语句。</p><h3><span id="8-2-ji-he-yun-suan-xu-yao-zhu-yi-de-wen-ti">8.2 集合运算需要注意的问题：</span><a href="#8-2-ji-he-yun-suan-xu-yao-zhu-yi-de-wen-ti" class="header-anchor">#</a></h3><p>参与运算的各个集合必须列数相同，且对应每个列的类型一致。        </p><p>采用第一个集合的表头作为最终使用的表头.</p><p>可以使用括号()先执行后面的语句。</p><p>问题：按照部门统计各部门不同工种的工资情况，要求按如下格式输出：</p><p><img src="https://gitee.com/txt1994/images/raw/master/img/Oracle/wps10.jpg" alt="img"> </p><p>分析SQL执行结果。                                     </p><p>第一部分数据是按照<code>deptno</code>和job进行分组；select 查询deptno、job、sum(sal)</p><p>第二部分数据是直接按照deptno分组即可，与job无关；select 只需要查询deptno，sum(sal)</p><p>第三部分数据不按照任何条件分组，即<code>group by null</code>；select 查询sum(sal)</p><p>所以，整体查询结果应该= <code>group by deptno,job + group by deptno + group by null</code></p><p>按照集合的要求,必须列数相同,类型一致,所以写法如下,使用null强行占位!</p> <div class="code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> deptno,        job,        <span class="hljs-built_in">sum</span>(sal)<span class="hljs-keyword">FROM</span> emp<span class="hljs-keyword">GROUP</span> <span class="hljs-keyword">BY</span>  deptno,job<span class="hljs-keyword">UNION</span><span class="hljs-keyword">SELECT</span> deptno,        to_char(<span class="hljs-keyword">null</span>),        <span class="hljs-built_in">sum</span>(sal)<span class="hljs-keyword">FROM</span> emp<span class="hljs-keyword">GROUP</span> <span class="hljs-keyword">BY</span>  deptno<span class="hljs-keyword">UNION</span><span class="hljs-keyword">SELECT</span> to_number(<span class="hljs-keyword">null</span>),        to_char(<span class="hljs-keyword">null</span>),        <span class="hljs-built_in">sum</span>(sal)<span class="hljs-keyword">FROM</span> emp;</code></pre></div><p>交集和差集与并集类似，也要注意以上三点。只不过算法不同而已。</p><p>需要注意:集合运算的性能一般较差.</p><p>SQL的执行时间：</p><div class="code-wrapper"><pre><code class="hljs">`set timing on/off`        默认是off </code></pre></div><h1><span id="9-shu-ju-chu-li">9 数据处理</span><a href="#9-shu-ju-chu-li" class="header-anchor">#</a></h1><h3><span id="sql-yu-yan-de-lei-xing">SQL语言的类型：</span><a href="#sql-yu-yan-de-lei-xing" class="header-anchor">#</a></h3><ol><li>数据库中，称呼增删改查，为DML语句。(Data Manipulation Language 数据操纵</li></ol><p>语言)，就是指代：insert、update、delete、select这四个操作。</p><ol start="2"><li>DDL语句。(Data Definition Language 数据定义语言)。</li></ol><p>如：truncate table(截断/清空 一张表)</p><div class="code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">create</span> <span class="hljs-keyword">table</span>(表)、<span class="hljs-keyword">create</span> <span class="hljs-keyword">view</span>(视图)、<span class="hljs-keyword">create</span> index(索引)、<span class="hljs-keyword">create</span> sequence(序列)、<span class="hljs-keyword">create</span> synonym(同义词)、<span class="hljs-keyword">alter</span> <span class="hljs-keyword">table</span>、<span class="hljs-keyword">drop</span> <span class="hljs-keyword">table</span>。</code></pre></div><ol start="3"><li>DCL语句。DCL（Data Control Language数据控制语言）如：</li></ol><div class="code-wrapper"><pre><code class="hljs">commit(提交)、rollback(回滚) </code></pre></div><h3><span id="cha-ru-shu-ju-insert">插入数据insert：</span><a href="#cha-ru-shu-ju-insert" class="header-anchor">#</a></h3><p>l 使用 INSERT 语句向表中插入数据。其语法为：</p><p>INSERT INTO    *table [(<em>column [</em>, column…])]</p><p>VALUES            <em>(value [</em>, value…]);</p><p>l 如果：values后面的值，涵盖了表中的所有列，那么table的列名可以省略不写。</p><p>desc emp;      查看员工表的结构，得到所有的列名。</p><div class="code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> emp <span class="hljs-keyword">values</span> (<span class="hljs-number">1001</span>, <span class="hljs-string">'Tom'</span>, <span class="hljs-string">'Engineer'</span>, <span class="hljs-number">7839</span>, sysdate, <span class="hljs-number">5000</span>, <span class="hljs-number">200</span>, <span class="hljs-number">10</span> );   <span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> emp <span class="hljs-keyword">values</span> (<span class="hljs-number">1005</span>, <span class="hljs-string">'Bone'</span>, <span class="hljs-string">'Raphealy'</span>, <span class="hljs-number">7829</span>, to_date(<span class="hljs-string">'17-12月-82'</span>, <span class="hljs-string">'DD-MON-RR'</span>), <span class="hljs-keyword">NULL</span>, <span class="hljs-number">300</span>, <span class="hljs-number">20</span>);</code></pre></div><p>l 如果:插入的时候没有插入所有的列, 就必须显式的写出这些列的名字。</p><div class="code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> emp(empno, ename, sal, deptno) <span class="hljs-keyword">values</span>(<span class="hljs-number">1002</span>, <span class="hljs-string">'Marry'</span>, <span class="hljs-number">6000</span>, <span class="hljs-number">20</span>);</code></pre></div><p>注意：字符串和日期都应该使用 ‘ ‘号引用起来.</p><p>l 没有写出的列自动填NULL, 这种方式称之为“隐式插入空值”。</p><p>l 显示插入空值: insert into emp(empno, ename, sal) values(1003, ‘Jim’, null);  </p><h4><span id="amp-di-zhi-fu">“&amp;” 地址符：</span><a href="#amp-di-zhi-fu" class="header-anchor">#</a></h4><p>l 在insert语句中使用&amp;可以让用户输入值:</p><div class="code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> emp(empno, ename, sal, deptno) <span class="hljs-keyword">values</span>(<span class="hljs-operator">&amp;</span>empno, <span class="hljs-operator">&amp;</span>ename, <span class="hljs-operator">&amp;</span>sal, <span class="hljs-operator">&amp;</span>deptno);</code></pre></div><p>理论上“&amp;”后面的变量名任意，习惯上一般与前面的列名相同，赋值的时候清楚在给谁赋值。</p><p>当再次需要插入新员工的时候直接输入“/”就可以继续输入新员工的值, /表示重复刚刚执行过的sql语句.</p><p>l 可以在DML的任意一个语句中输入“&amp;”, </p><div class="code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> empno,         ename,         sal,         <span class="hljs-operator">&amp;</span>t<span class="hljs-keyword">FROM</span> emp ;</code></pre></div><p>执行时，会提示你输入要查询的列名。当输入不同的列名时，显示不同的执行结果。</p><p><code>select * from &amp;t;</code>  修改t的值，可以查看不同表。</p><p>总结: &amp;类似于c语言中的宏替换, 只是进行简单的字符串替换操作, 但是select关键字不能用&amp;指代. 如 &amp;t * from emp; 而from, 表名, where 是可以用&amp;指代的, 如: <code>select * &amp;t emp; select * from &amp;t; select * from emp &amp;t sal&gt;2000;</code>但是通常情况都是替换值.</p><h4><span id="pi-chu-li">批处理：</span><a href="#pi-chu-li" class="header-anchor">#</a></h4><p>一次插入多条数据, 使用一个新创建的表用来测试.</p><p>创建一张与emp完全相同的表，用于测试。</p><div class="code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">create</span> <span class="hljs-keyword">table</span> emp10 ASSELECT <span class="hljs-operator">*</span><span class="hljs-keyword">FROM</span> emp<span class="hljs-keyword">WHERE</span> <span class="hljs-number">1</span><span class="hljs-operator">=</span><span class="hljs-number">2</span>; <span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span><span class="hljs-keyword">FROM</span> tab;<span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span><span class="hljs-keyword">FROM</span> emp10;<span class="hljs-keyword">desc</span> emp10;</code></pre></div><p>一次性将emp表中所有10号部门的员工, 放到新表emp10中来。</p><div class="code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> emp10SELECT <span class="hljs-operator">*</span><span class="hljs-keyword">FROM</span> emp<span class="hljs-keyword">WHERE</span> deptno<span class="hljs-operator">=</span><span class="hljs-number">10</span>;</code></pre></div><p>一次性将emp表中的指定列插入到表emp10中。        </p><div class="code-wrapper"><pre><code class="hljs">注意：insert的列名, 要和select的列名一致</code></pre></div><div class="code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> emp10(empno, ename, sal, deptno); <span class="hljs-keyword">SELECT</span> empno,         ename,         sal,         deptno<span class="hljs-keyword">FROM</span> emp<span class="hljs-keyword">WHERE</span> deptno<span class="hljs-operator">=</span><span class="hljs-number">10</span>;</code></pre></div><p>注意没有values关键字了, 但列名必须一一对应.    </p><p>总结: 子查询可以出现在DML的任何语句中.</p><h4><span id="geng-xin-shu-ju-update">更新数据update</span><a href="#geng-xin-shu-ju-update" class="header-anchor">#</a></h4><p>格式: update 表名 set col=值 where condtion</p><p>对于更新操作来说，一般会有一个“where”条件，如果没有这限制条件，更新的就是整张表。</p><div class="code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">UPDATE</span> emp10 <span class="hljs-keyword">SET</span> sal<span class="hljs-operator">=</span><span class="hljs-number">4000</span>,         comm<span class="hljs-operator">=</span><span class="hljs-number">300</span><span class="hljs-keyword">WHERE</span> ename <span class="hljs-operator">=</span> <span class="hljs-string">'CLARK'</span>;</code></pre></div><p>注意：若没有where限定，会将所有的员工的sal都设置成4000，comm设置成300；</p><p> 能否将某一列的值设置为null呢?</p><div class="code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">UPDATE</span> emp10 <span class="hljs-keyword">SET</span> comm <span class="hljs-operator">=</span> <span class="hljs-keyword">null</span><span class="hljs-keyword">WHERE</span> empno<span class="hljs-operator">=</span><span class="hljs-number">1000</span>; # <span class="hljs-comment">----可以</span></code></pre></div><p> 能否在查询的时候where条件中指定列的值为null吗?</p><div class="code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span><span class="hljs-keyword">FROM</span> emp<span class="hljs-keyword">WHERE</span> comm <span class="hljs-operator">=</span> <span class="hljs-keyword">null</span>; # <span class="hljs-comment">----不可以</span></code></pre></div><h2><span id="10-shan-chu-shu-ju-delete">10 删除数据delete</span><a href="#10-shan-chu-shu-ju-delete" class="header-anchor">#</a></h2><p>格式: delete from 表名 where condtion</p><div class="code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">delete</span><span class="hljs-keyword">FROM</span> emp10<span class="hljs-keyword">WHERE</span> empno<span class="hljs-operator">=</span><span class="hljs-number">7782</span>;</code></pre></div><p>注意: 如不加”where”会将整张表的数据删除。</p><div class="code-wrapper"><pre><code class="hljs"> “from”关键字在Oracle中可以省略不写，但MySQL中不可以;</code></pre></div><p>   但在使用的时候建议还是加上from. </p><h3><span id="delete-he-truncate-de-qu-bie">delete 和 truncate的区别：</span><a href="#delete-he-truncate-de-qu-bie" class="header-anchor">#</a></h3><ol><li>delete 逐条删除表“内容”，<code>truncate</code> 先摧毁表再重建。</li></ol><div class="code-wrapper"><pre><code class="hljs">(由于delete使用频繁，Oracle对delete优化后delete快于truncate)</code></pre></div><ol start="2"><li>delete 是DML语句，truncate 是DDL语句。</li></ol><div class="code-wrapper"><pre><code class="hljs">DML语句可以闪回(flashback)，DDL语句不可以闪回。</code></pre></div><p>（闪回： 做错了一个操作并且commit了，对应的撤销行为。了解）</p><ol start="3"><li>由于delete是逐条操作数据，所以delete会产生碎片，truncate不会产生碎片。</li></ol><div class="code-wrapper"><pre><code class="hljs">（同样是由于Oracle对delete进行了优化，让delete不产生碎片）。两个数据之间的数据被删除，删除的数据——碎片，整理碎片，数据连续，行移动</code></pre></div><ol start="4"><li>delete不会释放空间，truncate 会释放空间</li></ol><div class="code-wrapper"><pre><code class="hljs">用delete删除一张10M的表，空间不会释放。而truncate会。所以当确定表不再</code></pre></div><p>使用，应truncate</p><ol start="5"><li>delete可以回滚rollback, truncate不可以回滚rollback。</li></ol><h3><span id="delete-he-truncate-de-shi-xiao-xing">delete和truncate的时效性</span><a href="#delete-he-truncate-de-shi-xiao-xing" class="header-anchor">#</a></h3><p>【做实验sql.sql】：验证delete和truncate的时效性。    终端里@c:\sql.sql    可以执行脚本sql.sql  </p><div class="code-wrapper"><pre><code class="hljs">语句执行时间记录开关：set timing on/off            回显开关：set feedback on/off【测试步骤】：                    1. 关闭开关：                    SQL&gt; set timing off;                                                            SQL&gt; set feedback off;                  2. 使用脚本创建表：            SQL&gt; @c:\sql.sql                  3. 打开时间开关：            SQL&gt; `set timing on; `                 4. 使用delete删除表内容：    SQL&gt; `delete from testdelete; `                 5. 删除表：               SQL&gt;`drop table testdelete purge;`                  6. 关闭时间开关：            SQL&gt; `set timing off;`                  7. 使用脚本创建表：            SQL&gt; `@c:\sql.sql `                 8. 打开时间开关：            SQL&gt; `set timing on;  `                9. 使用truncate删除表内容：    SQL&gt; `truncate table testdelete;`  </code></pre></div><h3><span id="shi-wu">事务</span><a href="#shi-wu" class="header-anchor">#</a></h3><p>联想现实生活中的银行转账业务, 从A账户把钱转给B账户.</p><p>数据库事务，是由有限的数据库操作序列组成的逻辑执行单元，这一系列操作要么全部执行，要么全部放弃执行。</p><p>n 数据库事务由以下的部分组成:</p><p><strong>Ø</strong> 一个或多个DML 语句</p><p>Ø 一个 DDL(Data Definition Language – 数据定义语言) 语句</p><p>Ø 一个 DCL(Data Control Language – 数据控制语言) 语句</p><p> 事务的特点：要么都成功，要么都失败。</p><h4><span id="shi-wu-de-te-xing">事务的特性</span><a href="#shi-wu-de-te-xing" class="header-anchor">#</a></h4><p>l 事务4大特性(ACID) ：原子性、一致性、隔离性、持久性。</p><p>原子性 (Atomicity)：事务中的全部操作在数据库中是不可分割的，要么全部完成，要么均不执行。</p><p>一致性 (Consistency)：几个并行执行的事务, 其执行结果必须与按某一顺序串行执行的结果相一致。</p><p>隔离性 (Isolation)：事务的执行不受其他事务的干扰，当数据库被多个客户端并发访问时，隔离它们的操作，防止出现：脏读、幻读、不可重复读。</p><p>持久性 (Durability)：对于任意已提交事务，系统必须保证该事务对数据库的改变不被丢失，即使数据库出现故障。 </p><p>事务的起始标志：oracle中自动开启事务，以DML语句为开启标志。</p><p>执行一个增删改查语句, 只要没有提交commit和回滚rollback, 操作都在一个事务中.</p><p>事务的结束标志: 提交、回滚都是事务的结束标志。</p><p>提交:</p><p>Ø 显示提交: commit </p><p>Ø 隐式提交</p><ol><li>有DDL语句，如：create table除了创建表之外还会隐式提交Create</li></ol><p>之前所有没有提交的DML语句。 </p><ol start="2"><li>正常退出(exit / quit)</li></ol><p>u 回滚:    </p><p>Ø 显示回滚: <code>rollback</code> </p><p>Ø 隐式回滚: 掉电、宕机、非正常退出。</p><h4><span id="kong-zhi-shi-wu">控制事务</span><a href="#kong-zhi-shi-wu" class="header-anchor">#</a></h4><p>l 保存点（savepoint）可以防止错误操作影响整个事务，方便进行事务控制。</p><p><img src="https://gitee.com/txt1994/images/raw/master/img/Oracle/wps11.jpg" alt="img"> </p><p>【示例】：1. <code>create table testsp ( tid number, tname varchar2(20)); </code></p><p> DDL语句会隐式commit之前操作.</p><div class="code-wrapper"><pre><code class="hljs">     2. `set feedback on; `       打开回显     3. `insert into testsp values(1, 'Tom');`     4. `insert into testsp values(2, 'Mary');`     5. `savepoint aaa;`     6. `insert into testsp values(3, 'Moke');`        故意将“Mike”错写成“Moke”。     7. `select * from testsp; `                三条数据都显示出来。     8.` rollback to savepoint aaa;`                回滚到保存点aaa     9. `select * from testsp;`                     发现表中的数据保存到第二条操作结束的位置</code></pre></div><p>需要注意，前两次的操作仍然没有提交。如操作完成应该显示的执行 commit 提交。</p><p>savepoint主要用于在事务上下文中声明一个中间标记, 将一个长事务分隔为多个较小的部分, 和我们编写文档时, 习惯性保存一下一样, 都是为了防止出错和丢失。如果保存点设置名称重复，则会删除之前的那个保存点。一但commit之后，所有的savepoint将失效。</p><h4><span id="ge-chi-ji-bie">隔离级别</span><a href="#ge-chi-ji-bie" class="header-anchor">#</a></h4><p>对于同时运行的多个事务, 当这些事务访问数据库中相同的数据时, 如果没有采取必要的隔离机制, 就会导致各种并发问题:</p><p>脏读: 对于两个事物T1, T2, T1读取了已经被T2更新但还没有被提交的字段. 之后, 若 T2 回滚, T1读取的内容就是临时且无效的</p><p>不可重复读: 对于两个事物 T1, T2, T1 读取了一个字段, 然后 T2 更新了该字段. 之后, T1再次读取同一个字段, 值就不同了.</p><p>幻读: 对于两个事物 T1, T2, T1 从一个表中读取了一个字段, 然后 T2 在该表中插入了一些新的行. 之后, 如果 T1 再次读取同一个表, 就会多出几行.</p><p>数据库事务的隔离性: 数据库系统必须具有隔离并发运行各个事务的能力, 使它们不会相互影响, 避免各种并发问题. </p><p>一个事务与其他事务隔离的程度称为隔离级别. 数据库规定了多种事务隔离级别, 不同隔离级别对应不同的干扰程度, 隔离级别越高, 数据一致性就越好, 但并发性越弱.</p><p>​                                                                                    </p><p>SQL99定义4中隔离级别：     </p><ol><li><p><code>Read Uncommitted</code>     读未提交数据。</p></li><li><p><code>Read Commited</code>     读已提交数据。    （Oracle默认）</p></li><li><p><code>Repeatable Read</code>     可重复读。        （MySQL默认）</p></li><li><p><code>Serializable</code>         序列化、串行化。 （查询也要等前一个事务结束）</p></li></ol><p>Oracle支持的隔离级别： Read Commited（默认）和 Serializable，以及Oracle自定义的Read Only三种。</p><p>Read Only：由于大多数情况下，在事务操作的过程中，不希望别人也来操作，但是如果将别人的隔离级别设置为Serializable（串行），但是单线程会导致数据库的性能太差。是应该允许别人来进行read操作的。</p><h2><span id="11-chuang-jian-he-guan-li-biao">11 创建和管理表</span><a href="#11-chuang-jian-he-guan-li-biao" class="header-anchor">#</a></h2><h3><span id="chang-jian-de-shu-ju-ku-dui-xiang">常见的数据库对象</span><a href="#chang-jian-de-shu-ju-ku-dui-xiang" class="header-anchor">#</a></h3><p>数据库的对象: 经常使用的数据库对象有 表、视图、索引、序列、同义词等.</p><p> 表        基本的数据存储集合，由行和列组成。</p><p>视图        从表中抽出的逻辑上相关的数据集合。</p><p>序列        提供有规律的数值。</p><p>索引        提高查询的效率</p><p>同义词    给对象起别名</p><h3><span id="biao-de-ji-ben-cao-zuo">表的基本操作</span><a href="#biao-de-ji-ben-cao-zuo" class="header-anchor">#</a></h3><p>基本的数据存储集合，由行和列组成。表名和列名遵循如下命名规则：</p><p>必须以字母开头</p><p>必须在 1–30 个字符之间</p><p>必须只能包含 A–Z, a–z, 0–9, _, $, 和 #</p><p>必须不能和用户定义的其他对象重名</p><p>必须不能是Oracle 的保留字</p><p>Oracle默认存储是都存为大写</p><p>数据库名只能是1~8位, datalink可以是128位, 和其他一些特殊字符</p><h4><span id="chuang-jian-biao">创建表</span><a href="#chuang-jian-biao" class="header-anchor">#</a></h4><p>创建一张表必须具备：1. Create Table的权限 2. 存储空间。我们使用的scott/hr用户都具备这两点。</p><div class="code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">create</span> <span class="hljs-keyword">table</span> test1 (tid number, tname varchar2(<span class="hljs-number">20</span>), hiredate <span class="hljs-type">date</span> <span class="hljs-keyword">default</span> sysdate);</code></pre></div><p>default的作用是, 当向表中插入数据的时候, 没有指定时间的时候, 使用默认值<code>sysdate</code>。<code>insert into test1(tid, tname) values(11, 'wangwu');</code></p><p>插入时没有指定Hiredate列，取当前时间。</p><p>创建表时， 列所使用的数据类型：                                                   </p><p><img src="https://gitee.com/txt1994/images/raw/master/img/Oracle/wps12.png"></p><p>rowid：行地址 ——伪列</p><div class="code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> rowid,         empno,         deptno<span class="hljs-keyword">FROM</span> emp;</code></pre></div><p>看到该列存储的是一系列的地址(指针), 创建索引用.</p><p>分析，之前我们使用过的创建表的语句：</p><div class="code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">create</span> <span class="hljs-keyword">table</span> emp10 ASSELECT <span class="hljs-operator">*</span><span class="hljs-keyword">FROM</span> emp<span class="hljs-keyword">WHERE</span> <span class="hljs-number">1</span><span class="hljs-operator">=</span><span class="hljs-number">2</span>;</code></pre></div><p>在这条语句中，“where 1=2”一定为假。所以是不能select到结果的，但是将这条子查询放到Create语句中，可以完成拷贝表结构的效果。最终emp10和emp有相同的结构。</p><p>如果, “where”给定的是一个有效的条件, 就会在创建表的同时拷贝数据。如:</p><div class="code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">create</span> <span class="hljs-keyword">table</span> emp20 ASSELECT <span class="hljs-operator">*</span><span class="hljs-keyword">FROM</span> emp<span class="hljs-keyword">WHERE</span> deptno<span class="hljs-operator">=</span><span class="hljs-number">20</span>;</code></pre></div><p>这样emp20在创建之初就有5条数据。</p><p>创建一张表，要求包含：员工号 姓名 月薪 年薪 年收入 部门名称</p><p>分析：[员工号 姓名 月薪 年薪 年收入]在emp表中, 部门名称在dept表中, 两个表是通过deptno部门编号联系起来的. </p><p>根据要求，涉及emp和dept两张表(至少有一个where条件)，并且要使用表达式来计算年收入和年薪。</p><div class="code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">create</span> <span class="hljs-keyword">table</span> empincome <span class="hljs-keyword">AS</span> ↓<span class="hljs-keyword">SELECT</span> e.empno,         e.ename,         e.sal,         e.sal<span class="hljs-operator">*</span><span class="hljs-number">12</span> annualsal,         e.sal<span class="hljs-operator">*</span><span class="hljs-number">12</span><span class="hljs-operator">+</span>nvl(comm,         <span class="hljs-number">0</span>) income,         d.dname<span class="hljs-keyword">FROM</span> emp e, dept d<span class="hljs-keyword">WHERE</span> e.deptno <span class="hljs-operator">=</span> d.deptno;</code></pre></div><div class="code-wrapper"><pre><code class="hljs">必须要给表达式取别名(语法要求) </code></pre></div><p>由于此时的“where”条件是有效的条件，就会在创建表的同时拷贝数据。</p><p>创建“视图”的语法与上边表的语法、顺序几乎完全一样，只是将“table”→“view”即可。</p><h4><span id="xiu-gai-biao">修改表</span><a href="#xiu-gai-biao" class="header-anchor">#</a></h4><p>ALTER TABLE                                                                         </p><p> 追加一列: 向test1表中加入新列 image 类型是blob</p><div class="code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">alter</span> <span class="hljs-keyword">table</span> test1 <span class="hljs-keyword">add</span> image <span class="hljs-type">blob</span>;   <span class="hljs-keyword">desc</span> test1;</code></pre></div><p>修改一列: 将tname列的大小有20→40.</p><div class="code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">alter</span> <span class="hljs-keyword">table</span> test1 modify tname varchar2(<span class="hljs-number">40</span>);</code></pre></div><p> 删除一列: 将刚加入的新列image删除.</p><div class="code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">alter</span> <span class="hljs-keyword">table</span> test1 <span class="hljs-keyword">drop</span> <span class="hljs-keyword">column</span> image;</code></pre></div><p> 重命名一列: 将列tname重命名为username.</p><div class="code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">alter</span> <span class="hljs-keyword">table</span> test1 rename <span class="hljs-keyword">column</span> tname <span class="hljs-keyword">to</span> username;</code></pre></div><p>注意: 若是修改表的字段的长度, 若是增加长度没有问题, 若是减少字段的长度, 有可能会报错.     </p><h4><span id="shan-chu-biao">删除表</span><a href="#shan-chu-biao" class="header-anchor">#</a></h4><p>当表被删除：</p><p>数据和结构都被删除</p><p>所有正在运行的相关事物被提交</p><p>所有相关索引被删除</p><p><code>DROP TABLE</code> 语句不能回滚，但是可以闪回</p><p><code>select * from tab;</code>      查看当前用户下有哪些表, 拷贝保存表名。</p><p><code>drop table testsp; </code>     将测试保存点的表删除。    </p><p><code>select * from tab;</code>      再次查询跟刚刚保存的表名比对，少了testsp，但多了另外一张命名复杂的表。 </p><p>Oracle的回收站：</p><ol><li>查看回收站：show recyclebin (sqlplus 命令)那个复杂的命名即是testsp在回收站中的名字。</li></ol><p><code>select * from testsp;</code> 这样是不能访问的。</p><p>select * from “BIN$+vu2thd8TiaX5pA3GKHsng==$0”  要使用“回收站中的名字”</p><ol start="2"><li>清空回收站：<code>purge recyclebin</code></li></ol><div class="code-wrapper"><pre><code class="hljs">`drop table test1 purge`         表示直接删除表，不经过回收站。将表从回收站里恢复，涉及“闪回”的知识，作为了解性知识点。</code></pre></div><p>将表从回收站闪回</p><div class="code-wrapper"><pre><code class="hljs sql">flashback <span class="hljs-keyword">table</span> t2 <span class="hljs-keyword">to</span> before <span class="hljs-keyword">drop</span>;</code></pre></div><p>清空回收站</p><div class="code-wrapper"><pre><code class="hljs sql">purge recyclebin;</code></pre></div><p>注意：并不是所有的用户都有“回收站”，对于没有回收站的用户（管理员）来说，删除操作是不可逆的.</p><h4><span id="chong-ming-ming-biao">重命名表</span><a href="#chong-ming-ming-biao" class="header-anchor">#</a></h4><div class="code-wrapper"><pre><code class="hljs sql">rename test1 <span class="hljs-keyword">to</span> test8;</code></pre></div><p>Truncate Table：DDL语句        ——注意：不能回滚(rollback)                    </p><h3><span id="yue-shu">约束：</span><a href="#yue-shu" class="header-anchor">#</a></h3><h4><span id="yue-shu-de-chong-lei">约束的种类</span><a href="#yue-shu-de-chong-lei" class="header-anchor">#</a></h4><ol><li><p><code>Not Null</code>        非空约束</p><p>  例如：人的名字，不允许为空。</p></li><li><p><code>Unique</code>        唯一性约束</p><p>  例如：电子邮件地址，不可以重复。</p></li><li><p><code>Primary Key</code>    主键约束</p><p>  通过这个列的值可以唯一的确认一行记录，主键约束隐含Not null + Unique</p></li><li><p><code>Foreign Key</code>    外键约束</p></li></ol><div class="code-wrapper"><pre><code class="hljs">​    </code></pre></div><p>例如：部门表dept和员工表emp，不应该存在不属于任何一个部门的员工。用来约束两张表的关系。</p><p>注意：如果父表的记录被子表引用的话，父表的记录默认不能删除。解决方法：</p><div class="code-wrapper"><pre><code class="hljs">1）    先将子表的内容删除，然后在删除父表。2）    将子表外键一列设置为NULL值，断开引用关系，然后删除父表。</code></pre></div><p>无论哪种方法，都要在两个表进行操作。所以定义外键时，可以通过references指定如下参数：</p><p>ON DELETE CASCADE：当删除父表时，如发现父表内容被子表引用，级联删除子表引用记录。</p><p>ON DELETE SET NULL：当发现上述情况，先把子表中对应外键值置空，再删除父表。</p><p>多数情况下，使用SET NULL方法，防止子表列被删除，数据出错。</p><ol start="5"><li><p>Check检查性约束</p><p>  如：教室中所有人的性别；工作后薪水满足的条件。</p></li></ol><p>  新建一个测试表: test7</p><div class="code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">create</span> <span class="hljs-keyword">table</span> test7   (tid number,  tname varchar2(<span class="hljs-number">20</span>),  gender <span class="hljs-type">varchar</span>(<span class="hljs-number">6</span>) <span class="hljs-keyword">check</span> (gender <span class="hljs-keyword">in</span> (<span class="hljs-string">'男'</span>, <span class="hljs-string">'女'</span>)),sal number <span class="hljs-keyword">check</span> (sal <span class="hljs-operator">&gt;</span> <span class="hljs-number">0</span>)  );</code></pre></div><p>说明:</p><p>check (gender in (‘男’, ‘女’)) 检查插入的性别是不是‘男’或‘女’（单引号）。</p><div class="code-wrapper"><pre><code class="hljs">     check (sal &gt; 0)    检查薪水必须是一个正数。</code></pre></div><p>测试: <code>insert into test7 values(1, 'Tom', '男', 1000); </code> 没有问题.</p><p>如果插入: insert into test7 values(2, ‘Mary’, ‘啊’, 2000);  会报错.</p><p>ORA-02290：违反检查约束条件SCOTT.SYS_C005523,  gender的值只能取’男’或者’女’.</p><p>其中的“SYS_C005523”是约束的名字，由于在定义约束时没有显式指定，系统默认给起了这样一个名称。所以我们建议，创建约束的时候，自定义一个见名知意的约束名。</p><p>constraint: 使用该关键字，来给约束起别名。</p><h4><span id="yue-shu-ju-li">约束举例</span><a href="#yue-shu-ju-li" class="header-anchor">#</a></h4><p>【约束举例】：</p><div class="code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">create</span> <span class="hljs-keyword">table</span> student (sid number <span class="hljs-keyword">constraint</span> student_PK <span class="hljs-keyword">primary</span> key,     # <span class="hljs-comment">--学生Id主键约束</span>sname varchar2(<span class="hljs-number">20</span>) <span class="hljs-keyword">constraint</span> student_name_notnull <span class="hljs-keyword">not</span> <span class="hljs-keyword">null</span>, # <span class="hljs-comment">--学生姓名非空约束</span>email varchar2(<span class="hljs-number">20</span>) <span class="hljs-keyword">constraint</span> student_email_unique <span class="hljs-keyword">unique</span># <span class="hljs-comment">--学生邮件唯一约束</span> <span class="hljs-keyword">constraint</span> student_email_notnull <span class="hljs-keyword">not</span> <span class="hljs-keyword">null</span>,   # <span class="hljs-comment">--同时邮件可再设非空，没有,</span>age number <span class="hljs-keyword">constraint</span> student_age_min <span class="hljs-keyword">check</span>(age <span class="hljs-operator">&gt;</span> <span class="hljs-number">10</span>),   # <span class="hljs-comment">--学生年龄设置check约束</span>gender varchar2(<span class="hljs-number">6</span>) <span class="hljs-keyword">constraint</span> gender_female_or_male <span class="hljs-keyword">check</span>(gender <span class="hljs-keyword">in</span> (<span class="hljs-string">'男'</span>, <span class="hljs-string">'女'</span>)),deptno number <span class="hljs-keyword">constraint</span> student_FK <span class="hljs-keyword">references</span> dept (deptno) <span class="hljs-keyword">ON</span> <span class="hljs-keyword">DELETE</span> <span class="hljs-keyword">SET</span> <span class="hljs-keyword">NULL</span> );</code></pre></div><p>在定义学生deptno列的时候，引用部门表的部门号一列作为外键，同时使用references设置级联操作</p><div class="code-wrapper"><pre><code class="hljs">——当删除dept表的deptno的时候，将student表的deptno置空。</code></pre></div><p>查看student表各列的约束</p><div class="code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">desc</span> student;</code></pre></div><p>student的建表语句:</p><div class="code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> dbms_metadata.get_ddl(<span class="hljs-string">'TABLE'</span>, <span class="hljs-string">'STUDENT'</span>)<span class="hljs-keyword">FROM</span> dual;</code></pre></div><p>测试用例：</p><div class="code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> student <span class="hljs-keyword">values</span>(<span class="hljs-number">1</span>, <span class="hljs-string">'Tom'</span>, <span class="hljs-string">'tom@126.com'</span>, <span class="hljs-number">20</span>, <span class="hljs-string">'男'</span>, <span class="hljs-number">10</span>);  # 正确插入表数据。<span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> student <span class="hljs-keyword">values</span>(<span class="hljs-number">2</span>, <span class="hljs-string">'Tom'</span>, <span class="hljs-string">'tom@126.com'</span>, <span class="hljs-number">15</span>, <span class="hljs-string">'男'</span>, <span class="hljs-number">10</span>);</code></pre></div><div class="code-wrapper"><pre><code class="hljs">    违反student_email_unique约束。</code></pre></div><div class="code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> student <span class="hljs-keyword">values</span>(<span class="hljs-number">3</span>, <span class="hljs-string">'Tom3'</span>, <span class="hljs-string">'tom3@126.com'</span>, <span class="hljs-number">14</span>, <span class="hljs-string">'男'</span>,<span class="hljs-number">100</span> );</code></pre></div><div class="code-wrapper"><pre><code class="hljs">    违反完整约束条件 (SCOTT.STUDENT_FK) - 未找到父项关键字</code></pre></div><p>问题：是不是父表的所有列，都可以设置为子表的外键？作外键有要求吗？</p><div class="code-wrapper"><pre><code class="hljs">外键：必须是父表的主键.</code></pre></div><p>查看指定表（如student）的约束, 注意表名必须大写。</p><div class="code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> constraint_name,         constraint_Type,         search_condition<span class="hljs-keyword">FROM</span> user_constraints<span class="hljs-keyword">WHERE</span> table_name<span class="hljs-operator">=</span><span class="hljs-string">'STUDENT'</span>;</code></pre></div><h2><span id="12-qi-ta-shu-ju-ku-dui-xiang">12 其它数据库对象</span><a href="#12-qi-ta-shu-ju-ku-dui-xiang" class="header-anchor">#</a></h2><h3><span id="shi-tu">视图：</span><a href="#shi-tu" class="header-anchor">#</a></h3><p>视图是一种常见数据库对象, 它是从表中抽出的逻辑上相关的数据集合。</p><p>所以：1. 视图基于表。2. 视图是逻辑概念。3. 视图本身没有数据。</p><h4><span id="chuang-jian-shi-tu">创建视图</span><a href="#chuang-jian-shi-tu" class="header-anchor">#</a></h4><p>创建语法与创建表类似，只需要将table → view即可:</p><div class="code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">create</span> <span class="hljs-keyword">view</span> empincomeview ASSELECT e.empno,         e.ename,         e.sal,         e.sal<span class="hljs-operator">*</span><span class="hljs-number">12</span> annualsal,         e.sal<span class="hljs-operator">*</span><span class="hljs-number">12</span><span class="hljs-operator">+</span>nvl(comm,         <span class="hljs-number">0</span>) income,         d.dname<span class="hljs-keyword">FROM</span> emp e, dept d<span class="hljs-keyword">WHERE</span> e.deptno <span class="hljs-operator">=</span> d.deptno;</code></pre></div><div class="code-wrapper"><pre><code class="hljs">出错提示：权限不足。因为创建视图需要“create view”的权限。默认scott用户没有该种权限。加之！</code></pre></div><p>添加步骤：</p><ol><li><p>使用管理员登陆：<code>sqlplus / as sysdba</code></p></li><li><p>给scott用户增加权限</p><div class="code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">grant</span> <span class="hljs-keyword">create</span> <span class="hljs-keyword">view</span> <span class="hljs-keyword">to</span> scott;</code></pre></div></li><li><p>执行“/”可成功创建视图empincomeview. </p></li><li><p>视图的操作和表的操作完全一样.</p></li></ol><div class="code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span><span class="hljs-keyword">FROM</span> empincomeview;</code></pre></div><h4><span id="shi-tu-de-you-dian">视图的优点：</span><a href="#shi-tu-de-you-dian" class="header-anchor">#</a></h4><p>视图的优点                                                                                 </p><ol><li><p>简化复杂查询: 原来分组、多表、子查询等可以用一条select * from xxxview代替,视图可以看做是表的复杂的SQL一种封装。</p></li><li><p>限制数据访问: 只看视图的结构和数据是无法清楚视图是怎样得来的。可以限制数据的访问。例如：银行项目，所谓的各个“表”都是“视图”，并有可能只是“只读视图”</p></li></ol><p>注意：1. 视图不能提高性能         2. 不建议通过视图对表进行修改。</p><p><img src="https://gitee.com/txt1994/images/raw/master/img/Oracle/wps13.jpg" alt="img"> </p><h4><span id="chuang-jian-shi-tu-xi-jie">创建视图细节：</span><a href="#chuang-jian-shi-tu-xi-jie" class="header-anchor">#</a></h4><p>使用下面的语法格式创建视图：</p><p><strong>CREATE [OR REPLACE] [FORCE|NOFORCE] VIEW view</strong></p><hr><p><strong>[(alias[, alias]…)]</strong></p><p> <strong>AS subquery</strong></p><p><strong>[WITH CHECK OPTION [CONSTRAINT constraint]]</strong></p><p><strong>[WITH READ ONLY [CONSTRAINT constraint]];</strong></p><ol><li>视图只能创建、删除、替换。（不能修改，修改即替换replace）</li></ol><div class="code-wrapper"><pre><code class="hljs">如：刚刚创建的**empincomeview**，其他语句不变，将create一行改写成：</code></pre></div><div class="code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">create</span> # 视图不存在则创建、存在则替换。        <span class="hljs-keyword">OR</span> replace <span class="hljs-keyword">view</span> empincomeview <span class="hljs-keyword">AS</span> <span class="hljs-keyword">select</span>…… <span class="hljs-keyword">from</span>…..<span class="hljs-keyword">where</span>…..<span class="hljs-keyword">WITH</span> read <span class="hljs-keyword">only</span>; # 可以将视图设为只读视图。</code></pre></div><ol start="2"><li><p>别名: 可以写在子查询select各个列的后面，也可以写在视图的名字后面。</p></li><li><p><code>with read only</code>  表示该视图为只读视图。</p></li><li><p><code>with check option</code>    了解即可， 举例：</p></li></ol><div class="code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">create</span> <span class="hljs-keyword">view</span> testview ASSELECT <span class="hljs-operator">*</span><span class="hljs-keyword">FROM</span> emp<span class="hljs-keyword">WHERE</span> deptno<span class="hljs-operator">=</span><span class="hljs-number">10</span><span class="hljs-keyword">WITH</span> <span class="hljs-keyword">check</span> option;</code></pre></div><div class="code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> testview <span class="hljs-keyword">values</span>(<span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span>, <span class="hljs-number">10</span>);</code></pre></div><p>不建议向视图插入，但可以做。向视图插入10号员工。</p><div class="code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> testview <span class="hljs-keyword">values</span>(<span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span>, <span class="hljs-number">20</span>);</code></pre></div><p>因为创建视图时加了“with check option”，所以失败。</p><p>视图中使用DML的规定：                                                          </p><p>一：</p><p>当视图定义中包含以下元素之一时不能使用delete:</p><ul><li><p>组函数</p></li><li><p>GROUP BY 子句</p></li><li><p>DISTINCT 关键字</p></li><li><p>ROWNUM 伪列</p></li></ul><p>二：</p><div class="code-wrapper"><pre><code class="hljs">当视图定义中包含以下元素之一时不能使用update :</code></pre></div><ul><li><p>组函数</p></li><li><p>GROUP BY子句</p></li><li><p>DISTINCT 关键字</p></li><li><p>ROWNUM 伪列</p></li><li><p>列的定义为表达式</p></li></ul><p>三：</p><div class="code-wrapper"><pre><code class="hljs">当视图定义中包含以下元素之一时不能使用insert :</code></pre></div><ul><li><p>组函数</p></li><li><p>GROUP BY 子句</p></li><li><p>DISTINCT 关键字</p></li><li><p>ROWNUM 伪列</p></li><li><p>列的定义为表达式</p></li><li><p>表中非空的列在视图定义中未包括</p></li></ul><p>总结一句话：<strong>不通过视图做insert、update、delete操作。因为视图提供的目的就是为了简化查询。</strong></p><p>删除视图: </p><p><code>drop view testview;</code> ——à不加“purge”关键字。</p><h3><span id="xu-lie">序列：</span><a href="#xu-lie" class="header-anchor">#</a></h3><p>可以理解成数组：默认，从[1]开始，长度[20]        [1, 2, 3, 4, 5, 6, …, 20]        在内存中。</p><p>由于序列是被保存在内存中，访问内存的速率要高于访问硬盘的速率。所以序列可以提高效率。</p><h4><span id="xu-lie-de-shi-yong">序列的使用：</span><a href="#xu-lie-de-shi-yong" class="header-anchor">#</a></h4><ol><li><p>初始状态下：指针<em>指向1前面的位置。欲取出第一个值，应该将</em>向后移动。每取出一个值指针都向后移。</p></li><li><p>常常用序列来指定表中的主键。</p></li><li><p>创建序列：create sequence myseq  来创建一个序列。</p></li></ol><div class="code-wrapper"><pre><code class="hljs">​                    </code></pre></div><p>创建序列：</p><div class="code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span> SEQUENCE sequence    [INCREMENT <span class="hljs-keyword">BY</span> n]    [<span class="hljs-keyword">START</span> <span class="hljs-keyword">WITH</span> n]    [{MAXVALUE n <span class="hljs-operator">|</span> NOMAXVALUE}]    [{MINVALUE n <span class="hljs-operator">|</span> NOMINVALUE}]    [{<span class="hljs-keyword">CYCLE</span> <span class="hljs-operator">|</span> NOCYCLE}]    [{CACHE n <span class="hljs-operator">|</span> NOCACHE}];</code></pre></div><p>NOCACHE表示没有缓存，一次不产生20个，而只产生一个。</p><h4><span id="chuang-jian-xu-lie">创建序列</span><a href="#chuang-jian-xu-lie" class="header-anchor">#</a></h4><p>创建序列、表，以备后续测试使用：</p><div class="code-wrapper"><pre><code class="hljs">`create sequence myseq;`                 按默认属性创建一个序列。</code></pre></div><div class="code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">create</span> <span class="hljs-keyword">table</span> tableA (tid number, tname varchar2(<span class="hljs-number">20</span>));</code></pre></div><p>tid作为主键，准备使用序列来向表中插入值。</p><h4><span id="xu-lie-de-shu-xing">序列的属性：</span><a href="#xu-lie-de-shu-xing" class="header-anchor">#</a></h4><p>每个序列都有两个属性, nextval和currval.                                                             </p><p><strong>NextVal 必须在CurrVal之前被指定</strong>。因为初始状态下，CurrVal指向1前面的位置，无值</p><p>对于新创建的序列使用<code>select myseq.currval from dual; </code>         得到出错。</p><p>但<code>select myseq.nextval from dual;</code>          可以得到序列的第一值1.</p><p>此时再执行<code>select myseq.currval from dual;</code>        currval的值也得到1</p><p>使用序列给tableA表创建主键tid：</p><div class="code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> tableA <span class="hljs-keyword">values</span>(myseq.nextval, ‘aaa’)</code></pre></div><div class="code-wrapper"><pre><code class="hljs">只有nextval取完会向后移动，使用currval不会移动。</code></pre></div> <div class="code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> tableA <span class="hljs-keyword">values</span>(myseq.nextval, ‘bbb’)</code></pre></div><div class="code-wrapper"><pre><code class="hljs">继续使用nextval向表中添加主键tid</code></pre></div><div class="code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> tableA <span class="hljs-keyword">values</span>(myseq.nextval, <span class="hljs-operator">&amp;</span>name)</code></pre></div><div class="code-wrapper"><pre><code class="hljs">可以使用“&amp;”和“/”来指定名字。</code></pre></div> <div class="code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span><span class="hljs-keyword">FROM</span> tableA;</code></pre></div><p>由于前面测试currval和nextval关系时调用过nextval，所以tableA的tid起始从2开始。</p><p>查询序列的属性：``select * from user_sequences;<code>  </code>user_sequences`为数据字典视图。</p><p>修改序列：                                                            </p><ul><li><p>必须是序列的拥有者或对序列有 ALTER 权限</p></li><li><p>只有将来的序列值会被改变</p></li><li><p>改变序列的初始值只能通过删除序列之后重建序列的方法实现</p></li></ul><p>删除序列：<code>drop sequence myseq;  </code></p><p><strong>使用序列需要注意的地方: 应首先执行nextval, 之后才能使用currval的值, 刚刚创建的序列不能直接使用currval的值.</strong>    </p><h4><span id="shi-yong-xu-lie-xu-yao-zhu-yi-de-wen-ti">使用序列需要注意的问题：</span><a href="#shi-yong-xu-lie-xu-yao-zhu-yi-de-wen-ti" class="header-anchor">#</a></h4><ul><li>序列是公有对象，所以多张表同时使用序列，会造成主键不连续。    如：[1, 2, 3, 4, 5, …, 20]</li></ul><p>tableA:    1    2    4</p><p>tableB:    3    5                A、B表有可能主键不连续。</p><ul><li><p>回滚也可能造成主键不连续。    如：多次调用insert操作使用序列创建主键。但是当执行了rollback后再次使用insert借助序列创建主键的时候，nextval不会随着回滚操作回退。</p></li><li><p>掉电等原因，也可能造成不连续。由于代表序列的数组保存在内存中，断电的时候内存的内容丢失。恢复供电时候，序列直接从21开始。</p></li></ul><h3><span id="suo-yin">索引：</span><a href="#suo-yin" class="header-anchor">#</a></h3><p>索引，相当于书的目录，提高数据检索速度。提高效率（视图不可以提高效率）            </p><ul><li><p><strong>一种独立于表的模式对象, 可以存储在与表不同的磁盘或表空间中</strong></p></li><li><p><strong>索引被删除或损坏, 不会对表产生影响, 其影响的只是查询的速度</strong></p></li><li><p>索引一旦建立, Oracle 管理系统会对其进行自动维护, 而且由 Oracle 管理系统决定何时使用索引. 用户不用在查询语句中指定使用哪个索引</p></li><li><p>在删除一个表时, 所有基于该表的索引会自动被删除</p></li><li><p>通过指针<strong>加速 Oracle 服务器的查询速度</strong></p></li><li><p>通过快速定位数据的方法，减少磁盘 I/O</p></li></ul><p><img src="https://gitee.com/txt1994/images/raw/master/img/Oracle/wps14.jpg" alt="img"> </p><p>上图中：</p><ol><li><p>emp表中保存数据，其中包含部门号列。有10号部门，有20部门员工</p></li><li><p>当 <code>select * from emp where deptno=10</code> 的时候。由于10号部门员工不连续，没规律。</p></li></ol><div class="code-wrapper"><pre><code class="hljs">为了提高访问速度，可以在数据库中，依照rowid给deptno列建立索引</code></pre></div><div class="code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">create</span> index myindex    <span class="hljs-keyword">ON</span> emp(deptno);</code></pre></div><div class="code-wrapper"><pre><code class="hljs">    这样就建立了“索引表”可以通过rowid保存的行地址快速的找到表中数据。即使表中数据不连续。</code></pre></div><ol start="3"><li><p>建立了索引以后，如果再执行select语句的时候，会先检查表上是否有索引表。如果有，可以通过有规律的rowid找到连续的数据。</p></li><li><p>Oracle的数据库中，索引有 B树索引（默认）和 位图索引两种。</p></li><li><p>使用<code>create index 索引表名 on 表名（列名1， 列名2…）;</code>来创建索引表。由数据库自动进行维护。</p></li></ol><p><strong>使用主键查询数据最快速，因为主键本身就是“索引”，所以检索比较快。</strong>      </p><p>索引使用的场景：</p><p>以下情况可以创建索引:</p><ul><li><p>列中数据值分布范围很广</p></li><li><p>列经常在 WHERE 子句或连接条件中出现</p></li><li><p>表经常被访问而且数据量很大, 访问的数据大概占数据总量的2%到4%</p></li></ul><p>下列情况不要创建索引:</p><ul><li><p>表很小</p></li><li><p>列不经常作为连接条件或出现在WHERE子句中</p></li><li><p>查询的数据大于2%到4%</p></li><li><p>表经常更新</p></li></ul><p>删除索引:  <code>drop index myindex;</code>        </p><h3><span id="synonym-tong-yi-ci">synonym同义词：</span><a href="#synonym-tong-yi-ci" class="header-anchor">#</a></h3><p>就是指表的别名。</p><p>如：scott用户想访问hr用户下的表employees。默认是不能访问的。需要hr用户为scott用户授权.</p><div class="code-wrapper"><pre><code class="hljs">`sqplus hr/11        或         conn hr/11`（已登录界面， 切换登陆）</code></pre></div><div class="code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">grant</span> <span class="hljs-keyword">select</span>    <span class="hljs-keyword">ON</span> employees <span class="hljs-keyword">to</span> scott;</code></pre></div><p> hr用户为scott用户开放了employees表的查询权限。</p><p>这时scott用户就可以使用select语句，来查询hr用户下的employees表的信息了。</p><div class="code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-built_in">count</span>(<span class="hljs-operator">*</span>)<span class="hljs-keyword">FROM</span> hr.employees;</code></pre></div><p>​    若用户名叫zhangsanfeng则zhangsanfeng.employees</p><p>hr.employees名字过长，为了方便操作，scott用户为它重设别名:</p><div class="code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">create</span> synonym hremp <span class="hljs-keyword">for</span> hr.employees;  # 为hr.employees创建了同义词。</code></pre></div><p>如有权限限制，那么切换管理员登录，给scott用户添加设置同义词权限。</p><div class="code-wrapper"><pre><code class="hljs bash">conn / as sysdba;grant create synonym to scott;</code></pre></div><div class="code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-built_in">count</span>(<span class="hljs-operator">*</span>)<span class="hljs-keyword">FROM</span> hremp;  # 使用同义词进行表查询操作。</code></pre></div><p>同义词、视图 等用法在数据保密要求较高的机构使用广泛，如银行机构。好处是既不影响对数据的操作，同时又能保证数据的安全。</p><p>OCA </p><p>OCP </p><p>OCM    认证 </p><div class="code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> rownum,         empno,         ename,         sal<span class="hljs-keyword">FROM</span>     (<span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span>    <span class="hljs-keyword">FROM</span> emp    <span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span>  sal <span class="hljs-keyword">desc</span>)<span class="hljs-keyword">WHERE</span> rownum <span class="hljs-operator">&lt;=</span><span class="hljs-number">3</span>;</code></pre></div> <div class="code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span><span class="hljs-keyword">FROM</span>     (<span class="hljs-keyword">SELECT</span> rownum rn,         empno,         ename,         sal    <span class="hljs-keyword">FROM</span>         (<span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span>        <span class="hljs-keyword">FROM</span> emp        <span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span>  sal <span class="hljs-keyword">desc</span>) )    <span class="hljs-keyword">WHERE</span> rn<span class="hljs-operator">&gt;=</span><span class="hljs-number">4</span>        <span class="hljs-keyword">AND</span> rn<span class="hljs-operator">&lt;=</span><span class="hljs-number">7</span>;</code></pre></div><div class="code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> d.deptno,         e.empno,         e.ename,         d.avgsal,         e.sal<span class="hljs-keyword">FROM</span> emp e,     (<span class="hljs-keyword">SELECT</span> deptno,         <span class="hljs-built_in">avg</span>(sal) avgsal    <span class="hljs-keyword">FROM</span> emp    <span class="hljs-keyword">GROUP</span> <span class="hljs-keyword">BY</span>  deptno) d<span class="hljs-keyword">WHERE</span> e.deptno<span class="hljs-operator">=</span>d.deptno        <span class="hljs-keyword">AND</span> e.sal<span class="hljs-operator">&gt;</span>d.avgsal;</code></pre></div>]]></content>
    
    
    
    <tags>
      
      <tag>Oracle</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>nginx安装</title>
    <link href="/2022/01/08/nginx%E5%AE%89%E8%A3%85/"/>
    <url>/2022/01/08/nginx%E5%AE%89%E8%A3%85/</url>
    
    <content type="html"><![CDATA[<div class="toc"><!-- toc --><ul><li><a href="#1-yi-xie-ji-ben-gai-nian">1. 一些基本概念</a><ul><li><a href="#1-2-zheng-xiang-fan-xiang-dai-li">1.2 正向/反向代理</a></li><li><a href="#1-3-yu-ming-he-ip">1.3 域名和IP</a></li></ul></li><li><a href="#2-nginx-an-zhuang-he-pei-zhi">2. Nginx 安装和配置</a><ul><li><a href="#2-1-an-zhuang">2.1 安装</a></li><li><a href="#2-2-pei-zhi">2.2 配置</a></li></ul></li><li><a href="#3-nginx-de-shi-yong">3. Nginx的使用</a><ul><li><a href="#3-1-bu-shu-jing-tai-wang-ye">3.1 部署静态网页</a></li><li><a href="#3-2-fan-xiang-dai-li-he-fu-zai-jun-heng">3.2 反向代理和负载均衡</a></li></ul></li><li><a href="#ke-wai-zhi-shi-dao-du">课外知识导读</a><ul><li><a href="#1-url-he-uri">1. URL和URI</a></li><li><a href="#2-dns-jie-xi-guo-cheng">2. DNS解析过程</a></li></ul></li><li><a href="#fu-xi">复习</a></li></ul><!-- tocstop --></div><h2><span id="1-yi-xie-ji-ben-gai-nian">1. 一些基本概念</span><a href="#1-yi-xie-ji-ben-gai-nian" class="header-anchor">#</a></h2><p>###1.1 Nginx初步认识</p><ol><li><p>Nginx介绍</p><ul><li><p>engine x</p></li><li><p>俄罗斯</p></li><li><p>开源的框架</p></li><li><p>c语言</p></li><li><p>Tengine - 淘宝基于nginx修改的</p></li></ul></li><li><p>Nginx能干什么?</p><ul><li>作为web服务器<ul><li>解析http协议</li></ul></li><li>反向代理服务器<ul><li>了解反向代理的概念</li></ul></li><li>邮件服务器<ul><li>解析邮件相关的协议: pop3/smtp/imap</li></ul></li></ul></li><li><p>Nginx的优势?</p><blockquote><ul><li><p>更快</p><ul><li>高峰期(数以万计的并发时)nginx可以比其它web服务器更快的响应请求</li></ul></li><li><p>高扩展</p><ul><li><strong>低耦合</strong>设计的模块组成,丰富的第三方模块支持</li></ul></li><li><p>高可靠</p><ul><li>经过大批网站检验<ul><li><a href="http://www.sina.com.cn/">www.sina.com.cn</a></li><li><a href="http://www.xunlei.com/">www.xunlei.com</a></li><li><a href="http://www.163.com/">www.163.com</a></li></ul></li><li>每个worker进程相对独立, 出错之后可以快速开启新的worker<ul><li>worker进程的个数是可以控制的</li><li>在后台干活的进程</li></ul></li></ul></li><li><p>低内存消耗</p><ul><li>一般情况下,10000个非活跃的HTTP  Keep-Alive连接在nginx中仅消耗 2.5M内存</li></ul></li><li><p>单机支持10万以上的并发连接</p><ul><li>取决于内存,10万远未封顶</li></ul></li><li><p>热部署</p><ul><li>master和worker的分离设计,可实现7x24小时不间断服务的前提下升级nginx可执行文件</li></ul></li><li><p>最自由的BSD许可协议</p><ul><li>BSD许可协议允许用户免费使用nginx, 修改nginx源码,然后再发布<ul><li>淘宝: tengine</li></ul></li></ul></li></ul></blockquote></li></ol><h3><span id="1-2-zheng-xiang-fan-xiang-dai-li">1.2 正向/反向代理</span><a href="#1-2-zheng-xiang-fan-xiang-dai-li" class="header-anchor">#</a></h3><ol><li><p>正向代理</p><blockquote><p>正向代理是位于客户端和原始服务器之间的服务器，为了能够从原始服务器获取请求的内容，客户端需要将请求发送给代理服务器，然后再由代理服务器将请求转发给原始服务器，原始服务器接受到代理服务器的请求并处理，然后将处理好的数据转发给代理服务器，之后再由代理服务器转发发给客户端，完成整个请求过程。 </p><p><strong>正向代理的典型用途就是为在防火墙内的局域网客户端提供访问Internet的途径</strong>, 比如: </p><ul><li><p>学校的局域网</p></li><li><p>单位局域网访问外部资源</p></li></ul></blockquote></li></ol><p><img src="https://gitee.com/txt1994/images/raw/master/img/nginx/051157002507977.jpg"></p><p>正向代理服务器是为用户服务的</p><ol start="2"><li><p>反向代理</p><blockquote><p>反向代理方式是指代理原始服务器来接受来自Internet的链接请求，然后将请求转发给内部网络上的原始服务器，并将从原始服务器上得到的结果转发给Internet上请求数据的客户端。那么顾名思义，反向代理就是位于Internet和原始服务器之间的服务器，对于客户端来说就表现为一台服务器，客户端所发送的请求都是直接发送给反向代理服务器，然后由反向代理服务器统一调配。 </p></blockquote><p><img src="https://gitee.com/txt1994/images/raw/master/img/nginx/1.png"></p><p><img src="https://gitee.com/txt1994/images/raw/master/img/nginx/2.png"></p><p><img src="https://gitee.com/txt1994/images/raw/master/img/nginx/3.png"></p><p><img src="https://gitee.com/txt1994/images/raw/master/img/nginx/4.png"></p></li><li><p>客户端给服务器发送请求, 连接服务器, 用户不知道服务器地址, 只有反向代理服务器的地址是公开的</p></li><li><p>请求直接发给反向代理服务器</p></li><li><p>反向代理服务器将请求转发给后边的web服务器</p><ul><li>web服务器 N 台</li><li>反向代理服务器转发请求会轮询进行</li></ul></li><li><p>web服务器收到请求进行处理, 得到结果</p></li><li><p>web服务器将处理结果发送给反向代理服务器</p></li><li><p>反向代理服务器将拿到的结果转发给客户端</p></li></ol><h3><span id="1-3-yu-ming-he-ip">1.3 域名和IP</span><a href="#1-3-yu-ming-he-ip" class="header-anchor">#</a></h3><ol><li>什么是域名？<ul><li><a href="https://www.baidu.com/">https://www.baidu.com</a></li><li><a href="https://www.jd.com/">https://www.jd.com</a></li><li><a href="https://taobao.com/">https://taobao.com</a></li></ul></li><li>什么是IP地址？<ul><li>点分十进制的字符串<ul><li>11.22.34.45</li></ul></li></ul></li><li>域名和IP地址的关系？<ul><li>域名绑定IP<ul><li>一个域名只能绑定一个IP</li><li>一个IP地址被多个域名绑定</li></ul></li></ul></li></ol><h2><span id="2-nginx-an-zhuang-he-pei-zhi">2. Nginx 安装和配置</span><a href="#2-nginx-an-zhuang-he-pei-zhi" class="header-anchor">#</a></h2><h3><span id="2-1-an-zhuang">2.1 安装</span><a href="#2-1-an-zhuang" class="header-anchor">#</a></h3><p>切换到<code>/usr/local/src</code>目录</p><ol><li><p>下载</p><blockquote><ol><li>官方地址: <a href="http://nginx.org/en/download.html">nginx: download</a><ul><li>下载<ul><li><code>wget http://nginx.org/download/nginx-1.19.9.tar.gz</code></li></ul></li><li>解压<ul><li><code>tar -zxvf nginx-1.19.9.tar.gz</code></li></ul></li></ul></li><li>Nginx相关依赖:<ul><li><code>OpenSSL</code>: <a href="http://www.openssl.org/">http://www.openssl.org/</a> <ul><li>密码库</li><li>使用https进行通信的时候使用</li><li>下载<ul><li><code>git clone https://github.com.cnpmjs.org/openssl/openssl.git</code></li></ul></li><li>安装<ul><li><code>cd openssl</code></li><li>./Configure</li><li>make</li><li>make install</li></ul></li></ul></li><li><code>ZLib</code>下载: <a href="http://www.zlib.net/">http://www.zlib.net/</a> <ul><li>数据压缩</li><li>下载<ul><li><code>wget http://zlib.net/zlib-1.2.11.tar.gz</code></li></ul></li><li>安装:<ul><li><code>tar -zxvf zlib-1.2.11.tar.gz</code></li><li><code>cd zlib-1.2.11 </code></li><li>./configure</li><li>make</li><li>sudo make install</li></ul></li></ul></li><li><code>PCRE</code>下载:  <a href="http://www.pcre.org/">http://www.pcre.org/</a> <ul><li>解析正则表达式</li><li>下载<ul><li><code>wget https://ftp.pcre.org/pub/pcre/pcre-8.45.tar.gz</code></li></ul></li><li>安装<ul><li><code>tar -zxvf pcre-8.45.tar.gz</code></li><li><code>cd pcre-8.45</code></li><li>./configure</li><li>make</li><li>sudo make install</li></ul></li></ul></li></ul></li></ol></blockquote></li><li><p>安装</p><ul><li><p>nginx的安装</p><p>进入nginx目录<code>cd nginx-1.19.9</code></p><div class="code-wrapper"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">nginx工作时候需要依赖三个库</span><span class="hljs-meta prompt_"># </span><span class="language-bash">三个参数=这三个库对应的源码安装目录</span><span class="hljs-meta prompt_"># </span><span class="language-bash">根据自己的电脑的库安装包的位置进行指定</span>./configure --with-openssl=/usr/local/src/openssl \--sbin-path=/usr/local/nginx/sbin/nginx \--with-pcre=/usr/local/src/pcre-8.45 \--with-zlib=/usr/local/src/zlib-1.2.11 \--conf-path=/usr/local/nginx/conf/nginx.conf \--pid-path=/usr/local/nginx/conf/nginx.pid \--lock-path=/usr/local/nginx/conf/nginx.lock \--with-http_gzip_static_module \--with-http_stub_status_module \--with-file-aio \--with-http_realip_module \--with-http_ssl_module \--with-ipv6make -j2sudo make install</code></pre></div></li></ul></li></ol><p><img src="https://gitee.com/txt1994/images/raw/master/img/nginx/assets/1539658551107.png"></p><ol start="3"><li><p>Nginx 相关的指令</p><ul><li><p>Nginx的默认安装目录</p><div class="code-wrapper"><pre><code class="hljs shell">/usr/local/nginx conf -&gt; 存储配置文件的目录 html -&gt; 默认的存储网站(服务器)静态资源的目录 [图片, html, js, css] logs -&gt; 存储log日志 sbin -&gt; 启动nginx的可执行程序</code></pre></div></li><li><p>Nginx可执行程序的路径</p><div class="code-wrapper"><pre><code class="hljs shell">/usr/local/nginx/sbin/nginx<span class="hljs-meta prompt_"># </span><span class="language-bash">快速启动的方式</span><span class="hljs-meta prompt_"># </span><span class="language-bash">1. 将/usr/local/nginx/sbin/添加到环境变量PATH中</span><span class="hljs-meta prompt_"># </span><span class="language-bash">2. /usr/local/nginx/sbin/nginx创建软连接, 放到PATH对应的路径中, 比如: /usr/bin</span>ln -s /usr/local/nginx/sbin/nginx /usr/bin/nginx</code></pre></div></li><li><p>启动Nginx - 需要管理器权限</p><div class="code-wrapper"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">假设软连接已经创建完毕</span>sudo nginx # 启动</code></pre></div></li><li><p>关闭Nginx</p><div class="code-wrapper"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">第一种, 马上关闭</span>sudo nginx -s stop<span class="hljs-meta prompt_"># </span><span class="language-bash">第二种, 等nginx作为当前操作之后关闭</span>sudo nginx -s quit</code></pre></div></li><li><p>重新加载Nginx</p><div class="code-wrapper"><pre><code class="hljs shell">sudo nginx -s reload  # 修改了nginx的配置文件之后, 需要执行该命令</code></pre></div></li><li><p>测试是否安装成功</p><ul><li>知道nginx对应的主机的IP地址 - &gt; 192.168.1.100</li><li>在浏览器中访问该IP地址<ul><li>看到一个welcom nginx的欢迎界面</li></ul></li></ul></li></ul></li></ol><h3><span id="2-2-pei-zhi">2.2 配置</span><a href="#2-2-pei-zhi" class="header-anchor">#</a></h3><ol><li><p>Nginx配置文件的位置</p><div class="code-wrapper"><pre><code class="hljs shell">/usr/local/nginx/conf/nginx.conf</code></pre></div></li><li><p>Nginx配置文件的组织格式</p><p><img src="https://gitee.com/txt1994/images/raw/master/img/nginx/5.png"></p><ul><li>http -&gt; 模块, http相关的通信设置<ul><li>server模块 -&gt; 每个server对应的是一台web服务器<ul><li>location 模块<ul><li>处理的是客户端的请求</li></ul></li></ul></li></ul></li><li>mail -&gt; 模块, 处理邮件相关的动作</li></ul></li><li><p>常用配置项介绍</p><div class="code-wrapper"><pre><code class="hljs nginx"><span class="hljs-attribute">user</span>  nobody; <span class="hljs-comment"># 启动之后的worker进程属于谁</span>- 错误提示: nginx操作xxx文件时候失败, 原因: <span class="hljs-attribute">Permission</span> denied  - 将nobody -&gt; rootworker_processes  <span class="hljs-number">1</span>; <span class="hljs-comment"># 设置worker进程的个数, 最大 == cpu的核数 (推荐)</span><span class="hljs-attribute">error_log</span>  logs/<span class="hljs-literal">error</span>.log; <span class="hljs-comment"># 错误日志, /usr/local/nginx</span><span class="hljs-attribute">pid</span>        logs/nginx.pid; <span class="hljs-comment"># pid文件, 里边是nginx的进程ID</span><span class="hljs-comment"># nginx的事件处理</span><span class="hljs-section">events</span> { <span class="hljs-attribute">use</span> <span class="hljs-literal">epoll</span>;<span class="hljs-comment"># 多路IO转接模型使用epoll</span> <span class="hljs-attribute">worker_connections</span>  <span class="hljs-number">1024</span>;// 每个工作的进程的最大连接数}http-&gt;<span class="hljs-attribute">server</span> -&gt; 每个server模块可以看做一台web服务器server{<span class="hljs-attribute">listen</span>       <span class="hljs-number">80</span>;  <span class="hljs-comment"># web服务器监听的端口, http协议的默认端口</span>    <span class="hljs-attribute">server_name</span>  localhost; <span class="hljs-comment"># 对应一个域名, 客户端通过该域名访问服务器</span>    <span class="hljs-attribute">charset</span> utf8; <span class="hljs-comment"># 字符串编码</span>    <span class="hljs-section">location</span> {// 模块, 处理客户端的请求}<span class="hljs-comment"># 客户端 (浏览器), 请求:</span>  http://192.168.10.100:80/login.<span class="hljs-attribute">html</span><span class="hljs-comment"># 服务器处理客户端的请求</span>  服务器要处理的指令如何从url中提取?  - 去掉协议: http  - 去掉IP/域名+端口: <span class="hljs-number">192.168.10.100:80</span>  - 最后如果是文件名, 去掉该名字: login.html  - 剩下的: /  服务器要处理的location指令:   location /  {        处理动作  }</code></pre></div></li></ol><h2><span id="3-nginx-de-shi-yong">3. Nginx的使用</span><a href="#3-nginx-de-shi-yong" class="header-anchor">#</a></h2><h3><span id="3-1-bu-shu-jing-tai-wang-ye">3.1 部署静态网页</span><a href="#3-1-bu-shu-jing-tai-wang-ye" class="header-anchor">#</a></h3><ol><li><p>静态网页存储目录</p><ul><li><p>默认的存储目录: </p><div class="code-wrapper"><pre><code class="hljs shell">/usr/local/nginx/html</code></pre></div></li><li><p>自己创建新的目录:</p><div class="code-wrapper"><pre><code class="hljs shell">应该在 /usr/local/nginx/mkdir /usr/local/nginx/mydir</code></pre></div></li></ul></li><li><p>练习</p><blockquote><p>在Nginx服务器上进行网页部署, 实现如下访问:</p><p>在/usr/local/nginx/创建新的目录, yundisk用来存储静态网页</p></blockquote><ul><li><p>访问地址: <a href="http://192.168.80.254/login.html">http://192.168.80.254/login.html</a> </p><ul><li><p>login.html放到什么位置?</p><div class="code-wrapper"><pre><code class="hljs shell">/ -&gt; 服务器的资源根目录, /usr/local/nginx/yundisklogin.htm-&gt; 放到yundisk中</code></pre></div></li><li><p>服务器要处理的动作</p><div class="code-wrapper"><pre><code class="hljs nginx"><span class="hljs-comment"># 对应这个请求服务器要添加一个location</span><span class="hljs-section">location</span> 指令(/){    <span class="hljs-comment"># 找一个静态网页</span>    <span class="hljs-attribute">root</span> yundisk;  <span class="hljs-comment"># 相对于/usr/local/nginx/来找</span>    <span class="hljs-comment"># 客户端的请求是一个目录, nginx需要找一默认显示的网页</span>    <span class="hljs-attribute">index</span> index.html index.htm;}<span class="hljs-comment"># 配置之后重启nginx</span><span class="hljs-attribute">sudo</span> nginx -s reload</code></pre></div></li></ul></li><li><p>访问地址: <a href="http://192.168.80.254/hello/reg.html">http://192.168.80.254/hello/reg.html</a> </p><ul><li><p>hello是什么?</p><ul><li>目录</li></ul></li><li><p>reg.html放到哪儿?</p><ul><li>hello目录中</li></ul></li><li><p>如何添加location</p><div class="code-wrapper"><pre><code class="hljs nginx"><span class="hljs-section">location</span> /hello/{    <span class="hljs-attribute">root</span> yundisk;    <span class="hljs-attribute">index</span> xx.html;}</code></pre></div></li></ul></li><li><p>访问地址: <a href="http://192.168.80.254/upload/">http://192.168.80.254/upload/</a> 浏览器显示upload.html </p><ul><li><p>直接访问一个目录, 得到一默认网页</p><ul><li><p>upload是一个目录, uplaod.html应该再upload目录中</p><div class="code-wrapper"><pre><code class="hljs nginx"><span class="hljs-section">location</span> /upload/{    <span class="hljs-attribute">root</span> yundisk;    <span class="hljs-attribute">index</span> upload.html;}</code></pre></div></li></ul></li></ul></li></ul></li></ol><h3><span id="3-2-fan-xiang-dai-li-he-fu-zai-jun-heng">3.2 反向代理和负载均衡</span><a href="#3-2-fan-xiang-dai-li-he-fu-zai-jun-heng" class="header-anchor">#</a></h3><blockquote><p>反向代理和负载均衡是两码事儿</p></blockquote><p><img src="https://gitee.com/txt1994/images/raw/master/img/nginx/8.png" alt="1527415078314"></p><p>准备工作:</p><blockquote><ol><li>需要客户端 - 1个<ul><li>Window中的浏览器作为客户端</li></ul></li><li>反向代理服务器 -&gt; 1个<ul><li>window作为反向代理服务器</li></ul></li><li>web服务器 -&gt; 2个<ul><li>ubuntu - robin: 192.168.247.135</li><li>ubuntu - luffy : 192.168.26.250</li></ul></li></ol></blockquote><ol><li><p>反向代理设置</p><p><img src="https://gitee.com/txt1994/images/raw/master/img/nginx/assets/1539680213601.png" alt="1539680213601"></p><div class="code-wrapper"><pre><code class="hljs nginx">找window上对应的nginx的配置文件- conf/nginx.<span class="hljs-attribute">conf</span><span class="hljs-comment"># 代理几台服务器就需要几个server模块</span>    <span class="hljs-comment"># 客户端访问的url: http://192.168.1.100/login.html</span>    server {        <span class="hljs-attribute">listen</span>       <span class="hljs-number">80</span>;        <span class="hljs-comment"># 客户端访问反向代理服务器, 代理服务器监听的端口</span>        <span class="hljs-attribute">server_name</span>  ubuntu.com; <span class="hljs-comment"># 客户端访问反向代理服务器, 需要一个域名</span>        <span class="hljs-section">location</span> / {            <span class="hljs-comment"># 反向代理服务器转发指令, http:// 固定</span>            <span class="hljs-attribute">proxy_pass</span> http://robin.test.com;        }    }    <span class="hljs-comment"># 添加一个代理模块</span>    <span class="hljs-section">upstream</span> robin.test.com    {        <span class="hljs-attribute">server</span> <span class="hljs-number">192.168.247.135:80</span>;    }    <span class="hljs-comment"># luffy</span>    <span class="hljs-section">server</span> {        <span class="hljs-attribute">listen</span>       <span class="hljs-number">80</span>;        <span class="hljs-comment"># 客户端访问反向代理服务器, 代理服务器监听的端口</span>        <span class="hljs-attribute">server_name</span>  hello.com; <span class="hljs-comment"># 客户端访问反向代理服务器, 需要一个域名</span>        <span class="hljs-section">location</span> / {            <span class="hljs-comment"># 反向代理服务器转发指令, http:// 固定</span>            <span class="hljs-attribute">proxy_pass</span> http://luffy.test.com;        }    }    <span class="hljs-comment"># 添加一个代理模块</span>    <span class="hljs-section">upstream</span> luffy.test.com    {        <span class="hljs-attribute">server</span> <span class="hljs-number">192.168.26.250:80</span>;    }}</code></pre></div></li><li><p>负载均衡设置</p><p><img src="https://gitee.com/txt1994/images/raw/master/img/nginx/assets/1539681085862.png" alt="1539681085862"></p><div class="code-wrapper"><pre><code class="hljs nginx">    <span class="hljs-section">server</span> {        <span class="hljs-attribute">listen</span>       <span class="hljs-number">80</span>;         <span class="hljs-comment"># 客户端访问反向代理服务器, 代理服务器监听的端口</span>        <span class="hljs-attribute">server_name</span>  localhost; <span class="hljs-comment"># 客户端访问反向代理服务器, 需要一个域名</span>        <span class="hljs-section">location</span> / {            <span class="hljs-comment"># 反向代理服务器转发指令, http:// 固定的头</span>            <span class="hljs-attribute">proxy_pass</span> http://linux.com;        }        <span class="hljs-section">location</span> /hello/ {            <span class="hljs-comment"># 反向代理服务器转发指令, http:// 固定的头</span>            <span class="hljs-attribute">proxy_pass</span> http://linux.com;        }    <span class="hljs-section">location</span> /upload/ {            <span class="hljs-comment"># 反向代理服务器转发指令, http:// 固定的头</span>            <span class="hljs-attribute">proxy_pass</span> http://linux.com;        }    }    <span class="hljs-comment"># 添加一个代理模块</span>    <span class="hljs-section">upstream</span> linux.com    {        <span class="hljs-attribute">server</span> <span class="hljs-number">192.168.247.135:80</span> weight=<span class="hljs-number">1</span>;        <span class="hljs-attribute">server</span> <span class="hljs-number">192.168.26.250:80</span> weight=<span class="hljs-number">3</span>;    }<span class="hljs-comment">## =====================================</span>web服务器需要做什么?<span class="hljs-comment"># 192.168.247.135</span><span class="hljs-section">location</span> /{    <span class="hljs-attribute">root</span> xxx;    <span class="hljs-attribute">index</span> xxx;}<span class="hljs-section">location</span> /hello/ {    <span class="hljs-attribute">root</span> xx;    <span class="hljs-attribute">index</span> xxx;}<span class="hljs-section">location</span> /upload/ {    <span class="hljs-attribute">root</span> xxx;    <span class="hljs-attribute">index</span> xx;}<span class="hljs-comment"># 192.168.26.250</span><span class="hljs-section">location</span> /{    <span class="hljs-attribute">root</span> xxx;    <span class="hljs-attribute">index</span> xxx;}<span class="hljs-section">location</span> /hello/ {    <span class="hljs-attribute">root</span> xx;    <span class="hljs-attribute">index</span> xxx;}<span class="hljs-section">location</span> /upload/ {    <span class="hljs-attribute">root</span> xxx;    <span class="hljs-attribute">index</span> xx;}</code></pre></div></li></ol><h2><span id="ke-wai-zhi-shi-dao-du">课外知识导读</span><a href="#ke-wai-zhi-shi-dao-du" class="header-anchor">#</a></h2><h3><span id="1-url-he-uri">1. URL和URI</span><a href="#1-url-he-uri" class="header-anchor">#</a></h3><img src="https://gitee.com/txt1994/images/raw/master/img/nginx/6.png" style="zoom:50%;"><ol><li><p>概念:</p><blockquote><ul><li><p>URL（Uniform Resource  Locator）: 统一资源定位符</p></li><li><p>表示资源位置的字符串</p><ul><li>基本格式: “协议://IP地址/路径和文件名”<ul><li><a href="ftp://ftp.is.co.za/rfc/rfc1808.txt">ftp://ftp.is.co.za/rfc/rfc1808.txt</a></li><li><a href="http://www.ietf.org/rfc/rfc2396.txt">http://www.ietf.org/rfc/rfc2396.txt</a></li><li><a href="telnet://192.0.2.16:80/">telnet://192.0.2.16:80/</a></li></ul></li></ul></li><li><p>URN（Uniform Resource  Name）: 统一资源名称</p><ul><li>P2P下载中使用的磁力链接</li></ul></li><li><p>URI（Uniform Resource  Identifier）: 统一资源标识符</p><ul><li>是一个紧凑的字符串用来标示抽象或物理资源, <strong>URL是URI的一种</strong></li><li>让URI能成为URL的当然就是那个“访问机制”，“网络位置”。e.g. <code>http://</code> or <code>ftp://</code>。<ul><li>files.hp.com </li><li><a href="tel:+1-816-555-1212">tel:+1-816-555-1212</a></li><li><a href="ftp://ftp.is.co.za/rfc/rfc1808.txt">ftp://ftp.is.co.za/rfc/rfc1808.txt</a>               （also a URL）</li><li><a href="http://www.ietf.org/rfc/rfc2396.txt">http://www.ietf.org/rfc/rfc2396.txt</a>         （also a URL）</li><li><a href="telnet://192.0.2.16:80/">telnet://192.0.2.16:80/</a>                              （also a URL）</li></ul></li></ul></li></ul></blockquote></li><li><p>经验式理解:</p><p><img src="https://gitee.com/txt1994/images/raw/master/img/nginx/7.png"></p><p>从包含关系上说: URI包含URL</p><p>字符串长度上说: URL包含URI</p><div class="code-wrapper"><pre><code class="hljs">UIRI可以没有协议, 没有地址(IP/域名)</code></pre></div></li></ol><table><thead><tr><th>URL</th><th>红色字体部分+绿色字体部分</th></tr></thead><tbody><tr><td>URI</td><td>绿色字体部分</td></tr></tbody></table><h3><span id="2-dns-jie-xi-guo-cheng">2. DNS解析过程</span><a href="#2-dns-jie-xi-guo-cheng" class="header-anchor">#</a></h3><p><img src="https://gitee.com/txt1994/images/raw/master/img/nginx/2033581_1370929843HFAO.png" alt="wps_clip_image-14256"></p><ol><li><p>DNS解析的过程</p><blockquote><ol><li>在浏览器中输入<a href="http://www.magedu.com域名,操作系统会先检查自己本地的hosts文件是否有这个网址映射关系,如果有,就先调用这个ip地址映射,完成域名解析./">www.magedu.com域名，操作系统会先检查自己本地的hosts文件是否有这个网址映射关系，如果有，就先调用这个IP地址映射，完成域名解析。</a></li><li>如果hosts里没有这个域名的映射，则查找本地DNS解析器缓存，是否有这个网址映射关系，如果有，直接返回，完成域名解析。<ul><li>Windows和Linux系统都会在本地缓存dns解析的记录，提高速度。</li></ul></li><li>如果hosts与本地DNS解析器缓存都没有相应的网址映射关系，首先会找<code>TCP/IP</code>参数中设置的首选DNS服务器，在此我们叫它本地DNS服务器，此服务器收到查询时，如果要查询的域名，包含在本地配置区域资源中，则返回解析结果给客户机，完成域名解析，此解析具有权威性。</li><li>如果要查询的域名，不由本地DNS服务器区域解析，但该DNS服务器已缓存了此网址映射关系，则调用这个IP地址映射，完成域名解析，此解析不具有权威性。</li><li>如果本地DNS服务器本地区域文件与缓存解析都失效，则根据本地DNS服务器的设置（没有设置转发器）进行查询，如果未用转发模式，本地DNS就把请求发至13台根DNS，根DNS服务器收到请求后会判断这个域名(.com)是谁来授权管理，并会返回一个负责该顶级域名服务器的一个IP。本地DNS服务器收到IP信息后，将会联系负责 .com域的这台服务器。这台负责 .com域的服务器收到请求后，如果自己无法解析，它就会找一个管理 .com域的下一级DNS服务器地址(magedu.com)给本地DNS服务器。当本地DNS服务器收到这个地址后，就会找magedu.com域服务器，重复上面的动作进行查询，直至找到<a href="http://www.magedu.com主机./">www.magedu.com主机。</a></li><li>如果用的是转发模式（设置转发器），此DNS服务器就会把请求转发至上一级ISP DNS服务器，由上一级服务器进行解析，上一级服务器如果不能解析，或找根DNS或把转请求转至上上级，以此循环。不管是本地DNS服务器用是是转发，还是根提示，最后都是把结果返回给本地DNS服务器，由此DNS服务器再返回给客户机。</li></ol></blockquote></li><li><p>域名解析服务器</p><blockquote><ul><li><p>Pod DNS+:</p><ul><li>首选：119.29.29.29</li><li>备选：182.254.116.116</li></ul></li><li><p>114DNS:</p><ul><li>首选：114.114.114.114</li><li>备选：114.114.114.115</li></ul></li><li><p>阿里 AliDNS:</p><ul><li><p>首选：223.5.5.5</p></li><li><p>备选：223.6.6.6</p></li></ul></li></ul></blockquote></li><li><p>hosts文件</p><div class="code-wrapper"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">存储的是域名和IP的对应关系</span>-windows目录: "C:\Windows\System32\drivers\etc\hosts"</code></pre></div><h2><span id="fu-xi">复习</span><a href="#fu-xi" class="header-anchor">#</a></h2><p>redis</p><ol><li><p>是什么?</p><ul><li>非关系型数据库 - nosql<ul><li>数据存储在内存里边</li></ul></li></ul></li><li><p>能干什么?</p><ul><li>提高程序效率</li><li>程序中频繁访问的数据, 可以存储到redis中</li></ul></li><li><p>我们需要干什么?</p><ul><li><p>会安装</p></li><li><p>掌握启动redis服务器和客户端的启动命令</p><div class="code-wrapper"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">服务器</span>redis-server (配置文件名)<span class="hljs-meta prompt_"># </span><span class="language-bash">客户端</span>redis-cli (-h redis服务器IP -p 端口)</code></pre></div></li><li><p>redis中支持的数据类型 - value</p><ul><li><p>键值对方式存储数据</p><ul><li>key - 字符串</li><li>value<ul><li>字符串 - string</li><li>列表 - list</li><li>集合 - set</li><li>排序集合 - sortedSet</li><li>哈希 - hash</li></ul></li></ul></li><li><p>关于服务器使用的配置文件的修改</p></li><li><p>redis中持久化</p><ul><li>rdb</li><li>aof</li></ul></li></ul></li></ul></li><li><p>能够在程序中操作redis服务器</p><ul><li>需要使用以下函数接口</li><li>官方地址 - &gt; 客户端 -&gt; 选择语言</li></ul></li></ol></li></ol>]]></content>
    
    
    
    <tags>
      
      <tag>nginx</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>MySQL数据库API库</title>
    <link href="/2022/01/05/MySQL%E6%95%B0%E6%8D%AE%E5%BA%93API%E5%BA%93/"/>
    <url>/2022/01/05/MySQL%E6%95%B0%E6%8D%AE%E5%BA%93API%E5%BA%93/</url>
    
    <content type="html"><![CDATA[<div class="toc"><!-- toc --><ul><li><a href="#mysql-shu-ju-ku-api-ku">MySQL数据库API库</a><ul><li><a href="#bian-xie-hello-ying-yong-lian-jie-han-shu-ku">编写hello应用链接函数库</a></li></ul></li><li><a href="#mysql-api-chang-yong-han-shu"><strong>MySQL</strong> API常用函数</a><ul><li><a href="#zong-ti-yin-xiang">总体印象</a></li><li><a href="#chu-shi-hua">初始化</a></li><li><a href="#makefile-guan-li">Makefile 管理</a></li><li><a href="#lian-jie-shu-ju-ku-guan-bi-lian-jie">连接数据库关闭连接</a></li><li><a href="#du-qu-shu-ju">读取数据</a></li><li><a href="#shi-li-cheng-xu">示例程序</a></li></ul></li><li><a href="#mysql-tools-shi-xian">MySQL tools实现</a><ul><li><a href="#si-lu-fen-xi">思路分析</a></li><li><a href="#cheng-xu-shi-xian">程序实现</a></li><li><a href="#zhong-wen-wen-ti">中文问题：</a></li></ul></li><li><a href="#yu-chu-li-lei-api-han-shu">预处理类API函数：</a></li><li><a href="#ri-qi-shi-jian-lei-api-han-shu">日期时间类API函数</a></li><li><a href="#duo-cha-xun-zhi-xing-de-c-api-han-shu">多查询执行的C API函数</a></li><li><a href="#mysql-zhong-de-shi-wu">MySQL中的事务</a></li></ul><!-- tocstop --></div><h2><span id="mysql-shu-ju-ku-api-ku">MySQL数据库API库</span><a href="#mysql-shu-ju-ku-api-ku" class="header-anchor">#</a></h2><p>访问MySQL服务器，这需要使用mysqlclient库，MySQL的大多数客户端API（除Java和.NET）都是通过这个库来和MySQL服务器通讯的，而这个库正是使用C语言编写的。</p><p>可使用mysql -V 命令查看当前系统内所使用的mysql数据库版本信息。数据库版本为5.6.20版。因此，我们可从帮助手册refman-5.6-en.a4.pdf入手，了解学习MySQL C API使用的一般信息。</p><p>从API手册23.8中可获取信息，MySQL客户端使用 libmysqlclient 库内部的函数访问MySQL服务器。因此我们在编程过程中，如若使用到库内的函数，必须链接函数库，对应的要找到头文件所在目录位置、函数库路径。以便我们在使用gcc编译工具时可以填充参数-I、-L、-l。</p><p>从手册中可获知，函数库名为mysqlclient。</p><p>因此我们使用命令:</p><div class="code-wrapper"><pre><code class="hljs shell">find / -name libmysqlclient* 查找该库的路径。得到 /usr/lib64/mysql/libmysqlclient.a。</code></pre></div><p><code>nm /usr/lib64/mysql/libmysqlclient.a</code>命令可查看库内包含的函数。</p><h3><span id="bian-xie-hello-ying-yong-lian-jie-han-shu-ku">编写hello应用链接函数库</span><a href="#bian-xie-hello-ying-yong-lian-jie-han-shu-ku" class="header-anchor">#</a></h3><p>编写一个hello.c应用程序，链接使用该库。          </p><p>用到头文件 <code>&lt;mysql.h&gt;</code> 可使用<code>locate mysql.h</code>查看其目录位置<code>/usr/include/mysql/mysql.h</code>。</p><p>编译引用了库的应用程序。    </p><div class="code-wrapper"><pre><code class="hljs shell">gcc hello.c -o hello -I/usr/include/mysql/ -L/usr/lib64/mysql/ -lmysqlclient</code></pre></div><p>参见帮助手册refman-5.6-en.a4.pdf：23.8.4.3小节。</p><h2><span id="mysql-api-chang-yong-han-shu"><strong>MySQL</strong>  API常用函数</span><a href="#mysql-api-chang-yong-han-shu" class="header-anchor">#</a></h2><h3><span id="zong-ti-yin-xiang">总体印象</span><a href="#zong-ti-yin-xiang" class="header-anchor">#</a></h3><p>使用MySQL库API函数的一般步骤：</p><p>a. 初始化.     <code>MYSQL *mysql_init(MYSQL *mysql);</code></p><p>b. 错误处理    <code>unsigned int mysql_errno(MYSQL *mysql);                         char *mysql_error(MYSQL *mysql);</code></p><p>c. 建立连接.    <code>MYSQL *mysql_real_connect(MYSQL *mysql, const char *host, const char *user, const char *passwd,const char *db,                             unsigned int port, const char *unix_socket, unsigned long client_flag);</code></p><p>d. 执行SQL语句    <code>int mysql_query(MYSQL *mysql, const char *stmt_str);</code></p><p>e. 获取结果    <code>MYSQL_RES *mysql_store_result(MYSQL *mysql)</code><br>                        <code>MYSQL_ROW mysql_fetch_row(MYSQL_RES *result);</code></p><p>f. 释放内存    <code>void mysql_free_result(MYSQL_RES *result);</code></p><p>g. 关闭连接    <code>void mysql_close(MYSQL *mysql);</code></p><h3><span id="chu-shi-hua">初始化</span><a href="#chu-shi-hua" class="header-anchor">#</a></h3><p>编写程序测试 初始化函数<code>MYSQL *mysql_init(MYSQL *mysql)</code>。</p><p>其中有一种新数据类型MYSQL。可在头文件mysql.h → 263. typedef struct st_mysql {…} MYSQL;找到其定义。是一个结构体。</p><div class="code-wrapper"><pre><code class="hljs">处理错误码的函数：unsigned int mysql_errno(MYSQL *mysql) </code></pre></div><div class="code-wrapper"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">"mysql.h"</span></span><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>{<span class="hljs-type">int</span> i, ret = <span class="hljs-number">0</span>, num = <span class="hljs-number">0</span>;MYSQL *mysql = mysql_init(<span class="hljs-literal">NULL</span>);<span class="hljs-keyword">if</span> (mysql == <span class="hljs-literal">NULL</span>) {ret = mysql_errno(mysql);<span class="hljs-built_in">printf</span>(<span class="hljs-string">"mysql_init err:%d\n"</span>, ret);<span class="hljs-keyword">return</span> ret;}<span class="hljs-built_in">printf</span>(<span class="hljs-string">"init ok...\n"</span>);<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;}</code></pre></div><blockquote><p>编译出错，原因是64位Linux环境下，动态库配置不完整。<br>需手动指定编译所用的动态库。根据错误提示分析需要加入如下函数库：</p></blockquote><ol><li><p>__gxx_personality_v0        –&gt;     -lstdc++        使用g++相关的环境</p></li><li><p>dlclose/dlopen/dlsym          –&gt;    -ldl            完成用一个程序加载其他动态库的作用。</p></li><li><p>pthread_*                            –&gt;  -lpthread        线程库</p></li><li><p><code>my_getsystime'/</code>clock_gettime’    –&gt;  -lrt            librt.so是glibc中对real-time的支持库</p></li></ol><p>使用<code>ldd</code>命令可以查看该可执行文件运行所依赖的库文件。</p><h3><span id="makefile-guan-li">Makefile 管理</span><a href="#makefile-guan-li" class="header-anchor">#</a></h3><div class="code-wrapper"><pre><code class="hljs makefile">src = <span class="hljs-variable">$(<span class="hljs-built_in">wildcard</span> *.c)</span>target = <span class="hljs-variable">$(<span class="hljs-built_in">patsubst</span> %.c, %, <span class="hljs-variable">$(src)</span>)</span>inc_path = /usr/<span class="hljs-keyword">include</span>/mysql/lib_path = /usr/lib64/mysql/<span class="hljs-section">all: <span class="hljs-variable">$(target)</span></span><span class="hljs-section">%:%.c</span>gcc <span class="hljs-variable">$&lt;</span> -o <span class="hljs-variable">$@</span> -I<span class="hljs-variable">$(inc_path)</span> -L<span class="hljs-variable">$(lib_path)</span> -lmysqlclient -lstdc++ -lpthread -ldl -lrt<span class="hljs-section">clean:</span>-rm -rf <span class="hljs-variable">$(target)</span><span class="hljs-meta"><span class="hljs-keyword">.PHONY</span>: all clean</span></code></pre></div><p>注意：在测试makefile时，应先使用-n参数，检查无误再执行。</p><h3><span id="lian-jie-shu-ju-ku-guan-bi-lian-jie">连接数据库关闭连接</span><a href="#lian-jie-shu-ju-ku-guan-bi-lian-jie" class="header-anchor">#</a></h3><div class="code-wrapper"><pre><code class="hljs c"><span class="hljs-comment">// 依据proc猜想应该是一个类似于connect的函数，查看API文档发现：mysql_connect();但该函数已经过时，应该使用手册中推荐的mysql_real_connect函数取而代之。</span>MYSQL *<span class="hljs-title function_">mysql_real_connect</span><span class="hljs-params">(MYSQL *mysql, <span class="hljs-type">const</span> <span class="hljs-type">char</span> *host, </span><span class="hljs-params">                          <span class="hljs-type">const</span> <span class="hljs-type">char</span> *user, <span class="hljs-type">const</span> <span class="hljs-type">char</span> *passwd, </span><span class="hljs-params">                          <span class="hljs-type">const</span> <span class="hljs-type">char</span> *db, <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> port, </span><span class="hljs-params">                          <span class="hljs-type">const</span> <span class="hljs-type">char</span> *unix_socket, <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> client_flag</span><span class="hljs-params">                         )</span>;<span class="hljs-comment">// 根据手册中的描述，我们可以使用基础的链接方式与MySQL数据库建立连接。</span>mysql = mysql_real_connect(mysql, <span class="hljs-string">"localhost"</span>, <span class="hljs-string">"root"</span>,                            <span class="hljs-string">"123456"</span>, <span class="hljs-string">"mydb61"</span>, <span class="hljs-number">0</span>, <span class="hljs-literal">NULL</span>, <span class="hljs-number">0</span>                          );<span class="hljs-comment">//  连接数据库成功。对表中数据进行访问，</span><span class="hljs-comment">//访问结束需调用void mysql_close(MYSQL *mysql) 函数关闭连接。</span><span class="hljs-comment">//  该函数在断开连接的同时，还可以解除分配由mysql指向的连接句柄。</span>mysql_close(mysql);</code></pre></div><h3><span id="du-qu-shu-ju">读取数据</span><a href="#du-qu-shu-ju" class="header-anchor">#</a></h3><h4><span id="cha-xun-biao-shu-ju">查询表数据</span><a href="#cha-xun-biao-shu-ju" class="header-anchor">#</a></h4><div class="code-wrapper"><pre><code class="hljs c"><span class="hljs-comment">// mysql_query函数不单单能完成查询sql的功能，还能完成非select语句在c程序中的执行。</span><span class="hljs-comment">// 是一个十分万能的c程序中执行SQL语句的函数。并且该函数本身直接支持静态SQL。查询以\0结尾的字符串。</span><span class="hljs-comment">// 如果语句中包含二进制数据，则需要调用mysql_real_query来执行查询语句。</span><span class="hljs-comment">// 函数原型：int mysql_query(MYSQL *mysql, const char *query);</span><span class="hljs-comment">//成功返回0，失败返回非0</span><span class="hljs-type">char</span> *psql = <span class="hljs-string">"select * from emp"</span>;ret = mysql_query(mysql, psql);</code></pre></div><p>若执行的是<code>UPDATE</code>, <code>DELETE</code>或<code>INSERT</code>语句，则可通过<code>mysql_affected_rows()</code>获知受影响的记录数。</p><p>若执行的是<code>SELECT</code>语句，查询结束后，查询结果被保存在<code>mysql句柄</code>中。需要使用获取结果集的API函数将结果集获取出来。有两种方式可以获取结果集。</p><p>注意: <code>mysql_query</code>执行的SQL语句不应为语句添加终结分号（‘;’）或“\g”。</p><h4><span id="huo-qu-jie-guo-ji">获取结果集</span><a href="#huo-qu-jie-guo-ji" class="header-anchor">#</a></h4><p>一种方式是通过<code>mysql_store_result()</code>将整个结果集全部取回来。另一种方式则是调用<code>mysql_use_result()</code>初始化获取操作，但暂时不取回任何记录。视结果集的条目数选择获取结果集的函数。两种方法均通过<code>mysql_fetch_row()</code>来访问每一条记录。</p><div class="code-wrapper"><pre><code class="hljs c">MYSQL_RES *<span class="hljs-title function_">mysql_store_result</span><span class="hljs-params">(MYSQL *mysql)</span> <span class="hljs-comment">// 成功返回MYSQL_RES结果集指针，失败返回NULL。</span><span class="hljs-comment">// MYSQL_RES是一个结构体类型，可以从mysql.h头文件中找到该结构体的定义：</span>mysql.h → 308. <span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span> st_mysql_res {...} MYSQL_RES;</code></pre></div><p>整体获取的结果集，保存在 <code>MYSQL_RES</code> 结构体指针中，通过检查<code>mysql_store_result()</code>是否返回<code>NULL</code>，可检测函数执行是否成功：</p><div class="code-wrapper"><pre><code class="hljs c">MYSQL_RES *result = mysql_store_result(mysql);<span class="hljs-keyword">if</span> (result == <span class="hljs-literal">NULL</span>) {    ret = mysql_errno(mysql);    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"mysql_store_result error: %s\n"</span>, mysql_error(mysql));    <span class="hljs-keyword">return</span> ret;}</code></pre></div><p>该函数调用成功，则SQL查询的结果被保存在result中，但我们不清楚有多少条数据。所以应使用游标的方式将结果集中的数据逐条取出。</p><h4><span id="jie-xi-jie-guo-ji">解析结果集</span><a href="#jie-xi-jie-guo-ji" class="header-anchor">#</a></h4><p>通过游标一行一行fetch结果集中的数据。根据游标使用的一般特性，应使用循环结构，到达结尾或者出错，返回NULL。</p><div class="code-wrapper"><pre><code class="hljs c"><span class="hljs-comment">// 函数原型：MYSQL_ROW mysql_fetch_row(MYSQL_RES *result) 成功返回下一行的MYSQL_ROW结构。</span><span class="hljs-comment">// 如果没有更多要检索的行或出现了错误，返回NULL。-----MYSQL_ROW定义在118行</span>select * from emp  <span class="hljs-comment">// 可以看到emp表一共有8列数据。可以循环将每行上每一列的数据显示到屏幕。</span>MYSQL_ROW row = <span class="hljs-literal">NULL</span>;<span class="hljs-comment">//typedef char **MYSQL_ROW;</span><span class="hljs-keyword">while</span> ((row = mysql_fetch_row(result))) {<span class="hljs-built_in">printf</span>(<span class="hljs-string">"%s\t%s\t%s\t%s\t%s\t%s\t%s\t%s\n"</span>, row[<span class="hljs-number">0</span>],row[<span class="hljs-number">1</span>],row[<span class="hljs-number">2</span>],row[<span class="hljs-number">3</span>],row[<span class="hljs-number">4</span>],row[<span class="hljs-number">5</span>],row[<span class="hljs-number">6</span>],row[<span class="hljs-number">7</span>]);}</code></pre></div><p>MYSQL_ROW的本质是 typedef char ** MYSQL_ROW; 数据信息存储的形式如下图所示：</p><p><img src="https://gitee.com/txt1994/images/raw/master/img/mysql/wps1.jpg" alt="img"></p><p>从<code>mysql.h</code>头文件可查看MYSQL_ROW定义: 118. typedef char **MYSQL_ROW; /<em>return data as array of string</em>/</p><div class="code-wrapper"><pre><code class="hljs c"><span class="hljs-comment">// 从上图分析MYSQL_ROW为什么被定义为char**类型呢？推测mysq_fetch_row()的函数实现大致思想如下：</span><span class="hljs-type">char</span> **<span class="hljs-title function_">mysql_fetch_row</span><span class="hljs-params">()</span>{    <span class="hljs-type">char</span> **tmp = (<span class="hljs-type">char</span> **) <span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(<span class="hljs-type">char</span> *) * <span class="hljs-number">8</span>);    <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">8</span>; i++) {        tmp[i] = (<span class="hljs-type">char</span> *)<span class="hljs-built_in">malloc</span>(<span class="hljs-number">50</span>);    }    <span class="hljs-built_in">strcpy</span>(tmp[<span class="hljs-number">0</span>], <span class="hljs-string">"7369"</span>);    <span class="hljs-built_in">strcpy</span>(tmp[<span class="hljs-number">1</span>], <span class="hljs-string">"SMITH"</span>);    <span class="hljs-built_in">strcpy</span>(tmp[<span class="hljs-number">2</span>], <span class="hljs-string">"CLERK"</span>);    ...    <span class="hljs-keyword">return</span> tmp;}</code></pre></div><h4><span id="shi-fang-jie-guo-ji">释放结果集</span><a href="#shi-fang-jie-guo-ji" class="header-anchor">#</a></h4><blockquote><p>结果集处理完成，应调用对应的函数释放所占用的内存。        </p></blockquote><p><code>void mysql_free_result(MYSQL_RES *result)</code>; 成功释放参数传递的结果集。没有失败情况。</p><div class="code-wrapper"><pre><code class="hljs c">mysql_free_result(result);</code></pre></div><p>思考：上述实现是直接在MySQL工具中数出列数。找寻能获取列数的API函数、获取表头的API函数。</p><h4><span id="huo-qu-lie-shu">获取列数</span><a href="#huo-qu-lie-shu" class="header-anchor">#</a></h4><div class="code-wrapper"><pre><code class="hljs c"><span class="hljs-comment">// 查看帮助手册可以看到，有两个函数具备获取列数的功能：</span><span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> <span class="hljs-title function_">mysql_field_count</span><span class="hljs-params">(MYSQL *mysql)</span> <span class="hljs-comment">// 从mysql句柄中获取有多少列。</span><span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> <span class="hljs-title function_">mysql_num_fields</span><span class="hljs-params">(MYSQL_RES *result)</span> <span class="hljs-comment">// 从返回的结果集中获取有多少列。</span><span class="hljs-comment">// 选择任意一种方式均可以完成该功能。</span><span class="hljs-type">int</span> num = mysql_field_count(connect); <span class="hljs-keyword">while</span> (row = mysql_fetch_row(result)) {    <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; num; i++) {    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%s\t"</span>, row[i]);}<span class="hljs-built_in">printf</span>(<span class="hljs-string">"\n"</span>);<span class="hljs-comment">//printf("%s\t%s\t%s\t%s\t%s\t%s\t%s\t%s\n", row[0],row[1],row[2],row[3],row[4],row[5],row[6],row[7]);</span></code></pre></div><h4><span id="huo-qu-biao-tou">获取表头</span><a href="#huo-qu-biao-tou" class="header-anchor">#</a></h4><div class="code-wrapper"><pre><code class="hljs c"><span class="hljs-comment">// 获取表头的API函数同样有两个：</span>MYSQL_FIELD *<span class="hljs-title function_">mysql_fetch_fields</span><span class="hljs-params">(MYSQL_RES *result)</span> <span class="hljs-comment">// 全部获取</span>MYSQL_FIELD *<span class="hljs-title function_">mysql_fetch_field</span><span class="hljs-params">(MYSQL_RES *result)</span> <span class="hljs-comment">// 获取单个</span><span class="hljs-comment">// MYSQL_FIELD也是一个结构体类型，其内部保存了选择列表项的信息，</span><span class="hljs-comment">// 其中的name成员变量就保存着列名。可从头文件mysql.h中94-116行找到其定义。</span>MYSQL_FIELD *fields = <span class="hljs-literal">NULL</span>;fields = mysql_fetch_fields(result);<span class="hljs-comment">//得到表头的结构体数组</span><span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; num; i++) {<span class="hljs-comment">//已通过 mysql_field_count获取了总列数</span>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%s\t"</span>, fields[i].name);<span class="hljs-comment">//每一列的列名保存在name成员中 </span>}<span class="hljs-built_in">printf</span>(<span class="hljs-string">"\n"</span>);</code></pre></div><h3><span id="shi-li-cheng-xu">示例程序</span><a href="#shi-li-cheng-xu" class="header-anchor">#</a></h3><div class="code-wrapper"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">"mysql.h"</span> </span><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>{    <span class="hljs-type">int</span> i, ret = <span class="hljs-number">0</span>, num = <span class="hljs-number">0</span>;    <span class="hljs-type">char</span> *psql = <span class="hljs-string">"select * from emp"</span>;     MYSQL_RES *result = <span class="hljs-literal">NULL</span>;    MYSQL_FIELD *fields = <span class="hljs-literal">NULL</span>;    MYSQL_ROW row = <span class="hljs-literal">NULL</span>;    MYSQL *mysql = mysql_init(<span class="hljs-literal">NULL</span>);    <span class="hljs-keyword">if</span> (mysql == <span class="hljs-literal">NULL</span>) {        ret = mysql_errno(mysql);        <span class="hljs-built_in">printf</span>(<span class="hljs-string">"mysql_init err:%d\n"</span>, ret);        <span class="hljs-keyword">return</span> ret;    }    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"init ok...\n"</span>);    mysql = mysql_real_connect(mysql, <span class="hljs-string">"localhost"</span>, <span class="hljs-string">"root"</span>, <span class="hljs-string">"123456"</span>, <span class="hljs-string">"mydb61"</span>, <span class="hljs-number">0</span>, <span class="hljs-literal">NULL</span>, <span class="hljs-number">0</span>);    <span class="hljs-keyword">if</span> (mysql == <span class="hljs-literal">NULL</span>) {        ret = mysql_errno(mysql);        <span class="hljs-built_in">printf</span>(<span class="hljs-string">"mysql_init err:%d\n"</span>, ret);        <span class="hljs-keyword">return</span> ret;    }    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"connect ok...\n"</span>);    ret = mysql_query(mysql, psql);    <span class="hljs-keyword">if</span> (ret != <span class="hljs-number">0</span>) {        <span class="hljs-built_in">printf</span>(<span class="hljs-string">"mysql_query error: %s\n"</span>, mysql_error(mysql));        <span class="hljs-keyword">return</span> ret;    }    num = mysql_field_count(mysql);        result = mysql_store_result(mysql);    <span class="hljs-keyword">if</span> (result == <span class="hljs-literal">NULL</span>) {        ret = mysql_errno(mysql);        <span class="hljs-built_in">printf</span>(<span class="hljs-string">"mysql_store_result error: %s\n"</span>, mysql_error(mysql));        <span class="hljs-keyword">return</span> ret;    }    fields = mysql_fetch_fields(result);    <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; num; i++) {        <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%10s\t"</span>, fields[i].name);    }    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"\n"</span>);    <span class="hljs-keyword">while</span> ((row = mysql_fetch_row(result))) {        <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; num; i++) {            <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%10s\t"</span>, row[i]);        }        <span class="hljs-built_in">printf</span>(<span class="hljs-string">"\n"</span>);    }    mysql_free_result(result);    mysql_close(mysql);    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;}</code></pre></div><h2><span id="mysql-tools-shi-xian">MySQL tools实现</span><a href="#mysql-tools-shi-xian" class="header-anchor">#</a></h2><p>依托我们所学习的MySQL基础类API函数，可以编写程序实现简单的<code>sqlplus/mysql</code> 工具的功能。</p><h3><span id="si-lu-fen-xi">思路分析</span><a href="#si-lu-fen-xi" class="header-anchor">#</a></h3><p>\1. 仿照mysql工具，应在连接数据库成功之后，在一个while循环中不断的接受用户输入的SQL语句。定义char sqlbuf[1024] 存储用户输入的SQL语句。初始化该buf，并提示用户输入SQL语句。使用gets函数在循环中动态接收用户输入。</p><div class="code-wrapper"><pre><code class="hljs c"><span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>) {    <span class="hljs-built_in">memset</span>(sqlbuf, <span class="hljs-number">0</span>, <span class="hljs-keyword">sizeof</span>(sqlbuf));    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"\nYourSQL&gt; "</span>);    fgets(sqlbuf, <span class="hljs-keyword">sizeof</span>(sqlbuf), <span class="hljs-built_in">stdin</span>);}</code></pre></div><ol start="2"><li><p>在mysql_query(connect, sqlbuf)之前，如果用户输入了“exit”那么程序直接结束。</p></li><li><p>在执行完 mysql_query(connect, sqlbuf)之后，应该判别用户输入的是否为select语句。如不是select语句不需要查询结果集、处理结果集等繁复操作。</p></li><li><p>如用户输入的是有结果集的SQL语句，将获取列数、获取结果集、获取表头、解析结果集、释放结果集等相关代码一起并入<code>if (strncmp(sqlbuf, "select", 6))</code>中。</p></li></ol><blockquote><p>测试注意：执行SQL语句时不要在结尾加“;”            </p></blockquote><h3><span id="cheng-xu-shi-xian">程序实现</span><a href="#cheng-xu-shi-xian" class="header-anchor">#</a></h3><div class="code-wrapper"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">"mysql.h"</span> </span><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>{     <span class="hljs-type">int</span> i, ret = <span class="hljs-number">0</span>, num = <span class="hljs-number">0</span>;    <span class="hljs-comment">//char *psql = "select * from emp"; </span>    <span class="hljs-type">char</span> sqlbuf[<span class="hljs-number">1024</span>];     MYSQL *mysql = mysql_init(<span class="hljs-literal">NULL</span>);    <span class="hljs-keyword">if</span> (mysql == <span class="hljs-literal">NULL</span>) {        ret = mysql_errno(mysql);        <span class="hljs-built_in">printf</span>(<span class="hljs-string">"mysql_init err:%d\n"</span>, ret);        <span class="hljs-keyword">return</span> ret;    }    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"init ok...\n"</span>);     mysql = mysql_real_connect(mysql, <span class="hljs-string">"localhost"</span>, <span class="hljs-string">"root"</span>, <span class="hljs-string">"123456"</span>, <span class="hljs-string">"mydb61"</span>, <span class="hljs-number">0</span>, <span class="hljs-literal">NULL</span>, <span class="hljs-number">0</span>);    <span class="hljs-keyword">if</span> (mysql == <span class="hljs-literal">NULL</span>) {        ret = mysql_errno(mysql);        <span class="hljs-built_in">printf</span>(<span class="hljs-string">"mysql_init err:%d\n"</span>, ret);        <span class="hljs-keyword">return</span> ret;    }    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"connect ok...\n"</span>);    ret = mysql_query(mysql, <span class="hljs-string">"set names utf8"</span>);     <span class="hljs-keyword">if</span> (ret != <span class="hljs-number">0</span>) {        <span class="hljs-built_in">printf</span>(<span class="hljs-string">"mysql_query error: %s\n"</span>, mysql_error(mysql));        <span class="hljs-keyword">return</span> ret;    }    <span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>) {        <span class="hljs-built_in">memset</span>(sqlbuf, <span class="hljs-number">0</span>, <span class="hljs-keyword">sizeof</span>(sqlbuf));        <span class="hljs-built_in">printf</span>(<span class="hljs-string">"YourSQL&gt; "</span>);        fgets(sqlbuf, <span class="hljs-keyword">sizeof</span>(sqlbuf), <span class="hljs-built_in">stdin</span>);        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">strncmp</span>(sqlbuf, <span class="hljs-string">"exit"</span>, <span class="hljs-number">4</span>) || <span class="hljs-built_in">strncmp</span>(sqlbuf, <span class="hljs-string">"quit"</span>, <span class="hljs-number">4</span>) ) {            <span class="hljs-keyword">break</span>;        }        ret = mysql_query(mysql, sqlbuf);        <span class="hljs-keyword">if</span> (ret != <span class="hljs-number">0</span>) {            <span class="hljs-built_in">printf</span>(<span class="hljs-string">"mysql_query error: %s\n"</span>, mysql_error(mysql));            <span class="hljs-keyword">return</span> ret;        }        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">strncmp</span>(sqlbuf, <span class="hljs-string">"select"</span>, <span class="hljs-number">6</span>) || <span class="hljs-built_in">strncmp</span>(sqlbuf, <span class="hljs-string">"SELECT"</span>, <span class="hljs-number">6</span>)) {            num = mysql_field_count(mysql);            MYSQL_RES *result = <span class="hljs-literal">NULL</span>;            result = mysql_store_result(mysql);            <span class="hljs-keyword">if</span> (result == <span class="hljs-literal">NULL</span>) {                ret = mysql_errno(mysql);                <span class="hljs-built_in">printf</span>(<span class="hljs-string">"mysql_store_result error: %s\n"</span>, mysql_error(mysql));                <span class="hljs-keyword">return</span> ret;            }            <span class="hljs-comment">//打印表头 </span>            MYSQL_FIELD *fields = <span class="hljs-literal">NULL</span>;            fields = mysql_fetch_fields(result);            <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; num; i++) {                <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%10s\t"</span>, fields[i].name);            }            <span class="hljs-built_in">printf</span>(<span class="hljs-string">"\n"</span>);            <span class="hljs-comment">//解析结果集</span>            MYSQL_ROW row = <span class="hljs-literal">NULL</span>;<span class="hljs-comment">//typedef char **MYSQL_ROW;</span>            <span class="hljs-keyword">while</span> ((row = mysql_fetch_row(result))) {                <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; num; i++) {                    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%10s\t"</span>, row[i]);                }                <span class="hljs-built_in">printf</span>(<span class="hljs-string">"\n"</span>);            }            mysql_free_result(result);        } <span class="hljs-keyword">else</span> {            <span class="hljs-built_in">printf</span>(<span class="hljs-string">"\n--- not select sql---\n"</span>);            <span class="hljs-built_in">printf</span>(<span class="hljs-string">"affected: %ld\n"</span>, (<span class="hljs-type">long</span>)mysql_affected_rows(mysql));        }    }    mysql_close(mysql);    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;}</code></pre></div><h3><span id="zhong-wen-wen-ti">中文问题：</span><a href="#zhong-wen-wen-ti" class="header-anchor">#</a></h3><p>修改<code>mysql_real_connect()</code>参数，连接到表中有中文数据的数据库，如mydb2，执行程序，测试显示中文出现乱码。我们可以使用<code>mysql_query</code>函数来解决该问题。</p><p>在 while (1) 之前使用 <code>ret = mysql_query(mysql, "set names utf8")</code>; 来设置查询属性(也可以加到while中)。表示在查询的时候使用utf8的形式进行查询。</p><p>或者<code>mysql_set_character_set(mysql, "utf8")</code>;</p><p>获取当前使用的字符集:  <code>const char *mysql_character_set_name(MYSQL *mysql)</code></p><h2><span id="yu-chu-li-lei-api-han-shu">预处理类API函数：</span><a href="#yu-chu-li-lei-api-han-shu" class="header-anchor">#</a></h2><p>该类函数解决问题：处理带有占位符的SQL语句。<code>insert into table111(col1, col2, col3) values(?, ?, ?)</code>;    </p><p>这种SQL语句由两部分组成，一部分是SQL语句体模型部分，另一部分是？所匹配的值。    </p><p>性能、调优是数据库编程永恒不变的主题！如果能把SQL语句框架预先处理好，当真正要执行SQL语句时只需要发送对应的参数到对应的SQL框架中，就能提高客户端访问服务器的速度，且数据量小，可以减少网络通信量，提高数据传输效率高。                </p><p>元数据（Metadata）：又称中介数据、中继数据，为描述数据的数据，主要是描述数据属性的信息，用来支持如指示存储位置、历史数据、资源查找、文件记录等功能。</p><p>根据API提供的案例学习该部分内容。主要有 4 个函数：    </p><p><code>mysql_stmt_init()</code>                初始化预处理环境句柄。    返回一个结构体指针 MYSQL_STMT *stmt</p><p><code>mysql_stmt_prepare()</code>            向上面句柄中添加SQL语句，带有 (?,?,?) 占位符</p><p><code>mysql_stmt_param_count()</code>     求绑定变量的个数(辅助函数)， 有多少个’?’就返回多少</p><p><code>mysql_stmt_bind_param()</code>        将?对应的实参，设置到预处理环境句柄中</p><p><code>mysql_stmt_execute()</code>            执行预处理的SQL语句</p><p><img src="https://gitee.com/txt1994/images/raw/master/img/mysql/wps2.jpg" alt="img"> </p><blockquote><p>在不熟悉这套API函数的情况下，如何能快速的找到一个完整的案例，使用这套函数呢？分析：在以上4个过程中，哪个最重要呢？找到它，去查看API文档！发现有对应的demo程序。将该demo导入到我们的程序中，运行，观察它的作用。</p></blockquote><div class="code-wrapper"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">"mysql.h"</span> </span><span class="hljs-meta">#<span class="hljs-keyword">define</span> STRING_SIZE 50 </span><span class="hljs-meta">#<span class="hljs-keyword">define</span> DROP_SAMPLE_TABLE <span class="hljs-string">"DROP TABLE IF EXISTS test_table"</span></span><span class="hljs-meta">#<span class="hljs-keyword">define</span> CREATE_SAMPLE_TABLE <span class="hljs-string">"CREATE TABLE test_table(col1 INT,\</span></span><span class="hljs-string"><span class="hljs-meta">                         col2 VARCHAR(40),\</span></span><span class="hljs-string"><span class="hljs-meta">                         col3 SMALLINT,\</span></span><span class="hljs-string"><span class="hljs-meta">                         col4 TIMESTAMP)"</span></span><span class="hljs-meta">#<span class="hljs-keyword">define</span> INSERT_SAMPLE <span class="hljs-string">"INSERT INTO test_table(col1,col2,col3) VALUES(?,?,?)"</span> </span><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>{ <span class="hljs-type">int</span> ret = <span class="hljs-number">0</span>;MYSQL *mysql = mysql_init(<span class="hljs-literal">NULL</span>);<span class="hljs-keyword">if</span> (mysql == <span class="hljs-literal">NULL</span>) {<span class="hljs-comment">//unsigned int mysql_errno(MYSQL *mysql) </span>ret = mysql_errno(mysql);<span class="hljs-built_in">printf</span>(<span class="hljs-string">"mysql_init err:%d\n"</span>, ret);<span class="hljs-keyword">return</span> ret;}<span class="hljs-built_in">printf</span>(<span class="hljs-string">"init ok...\n"</span>); mysql = mysql_real_connect(mysql, <span class="hljs-string">"localhost"</span>, <span class="hljs-string">"root"</span>, <span class="hljs-string">"123456"</span>, <span class="hljs-string">"mydb61"</span>, <span class="hljs-number">0</span>, <span class="hljs-literal">NULL</span>, <span class="hljs-number">0</span>);<span class="hljs-keyword">if</span> (mysql == <span class="hljs-literal">NULL</span>) {ret = mysql_errno(mysql);<span class="hljs-built_in">printf</span>(<span class="hljs-string">"mysql_init err:%d\n"</span>, ret);<span class="hljs-keyword">return</span> ret;}<span class="hljs-built_in">printf</span>(<span class="hljs-string">"connect ok...\n"</span>);<span class="hljs-comment">////////////////////////以下为demo源码//////////////////////////////// </span>MYSQL_STMT   *stmt;MYSQL_BIND   bind[<span class="hljs-number">3</span>];my_ulonglong  affected_rows;<span class="hljs-type">int</span>      param_count;<span class="hljs-type">short</span>     small_data;<span class="hljs-type">int</span>      int_data;<span class="hljs-type">char</span>      str_data[STRING_SIZE];<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> str_length;my_bool    is_null; <span class="hljs-keyword">if</span> (mysql_query(mysql, DROP_SAMPLE_TABLE)){<span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">" DROP TABLE failed\n"</span>);<span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">" %s\n"</span>, mysql_error(mysql));<span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>);} <span class="hljs-keyword">if</span> (mysql_query(mysql, CREATE_SAMPLE_TABLE)){<span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">" CREATE TABLE failed\n"</span>);<span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">" %s\n"</span>, mysql_error(mysql));<span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>);}<span class="hljs-comment">/* Prepare an INSERT query with 3 parameters */</span><span class="hljs-comment">/* (the TIMESTAMP column is not named; the server */</span><span class="hljs-comment">/*  sets it to the current date and time) */</span>stmt = mysql_stmt_init(mysql);<span class="hljs-keyword">if</span> (!stmt){<span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">" mysql_stmt_init(), out of memory\n"</span>);<span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>);}<span class="hljs-keyword">if</span> (mysql_stmt_prepare(stmt, INSERT_SAMPLE, <span class="hljs-built_in">strlen</span>(INSERT_SAMPLE))){<span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">" mysql_stmt_prepare(), INSERT failed\n"</span>);<span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">" %s\n"</span>, mysql_stmt_error(stmt));<span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>);}<span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stdout</span>, <span class="hljs-string">" prepare, INSERT successful\n"</span>); <span class="hljs-comment">/* Get the parameter count from the statement */</span>param_count= mysql_stmt_param_count(stmt);<span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stdout</span>, <span class="hljs-string">" total parameters in INSERT: %d\n"</span>, param_count);<span class="hljs-keyword">if</span> (param_count != <span class="hljs-number">3</span>) <span class="hljs-comment">/* validate parameter count */</span>{<span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">" invalid parameter count returned by MySQL\n"</span>);<span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>);}    <span class="hljs-comment">/* Bind the data for all 3 parameters */</span><span class="hljs-built_in">memset</span>(bind, <span class="hljs-number">0</span>, <span class="hljs-keyword">sizeof</span>(bind));<span class="hljs-comment">/* INTEGER PARAM */</span><span class="hljs-comment">/* This is a number type, so there is no need to specify buffer_length */</span>bind[<span class="hljs-number">0</span>].buffer_type = MYSQL_TYPE_LONG;bind[<span class="hljs-number">0</span>].buffer = (<span class="hljs-type">char</span> *)&amp;int_data;bind[<span class="hljs-number">0</span>].is_null = <span class="hljs-number">0</span>;bind[<span class="hljs-number">0</span>].length = <span class="hljs-number">0</span>;<span class="hljs-comment">/* STRING PARAM */</span>bind[<span class="hljs-number">1</span>].buffer_type = MYSQL_TYPE_STRING;bind[<span class="hljs-number">1</span>].buffer = (<span class="hljs-type">char</span> *)str_data;bind[<span class="hljs-number">1</span>].buffer_length = STRING_SIZE;bind[<span class="hljs-number">1</span>].is_null = <span class="hljs-number">0</span>;bind[<span class="hljs-number">1</span>].length = &amp;str_length;<span class="hljs-comment">/* SMALLINT PARAM */</span>bind[<span class="hljs-number">2</span>].buffer_type = MYSQL_TYPE_SHORT;bind[<span class="hljs-number">2</span>].buffer = (<span class="hljs-type">char</span> *)&amp;small_data;bind[<span class="hljs-number">2</span>].is_null = &amp;is_null;bind[<span class="hljs-number">2</span>].length = <span class="hljs-number">0</span>;<span class="hljs-comment">/* Bind the buffers */</span><span class="hljs-keyword">if</span> (mysql_stmt_bind_param(stmt, bind)){<span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">" mysql_stmt_bind_param() failed\n"</span>);<span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">" %s\n"</span>, mysql_stmt_error(stmt));<span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>);}<span class="hljs-comment">/* Specify the data values for the first row */</span>int_data= <span class="hljs-number">10</span>;       <span class="hljs-comment">/* integer */</span><span class="hljs-built_in">strncpy</span>(str_data, <span class="hljs-string">"MySQL"</span>, STRING_SIZE); <span class="hljs-comment">/* string  */</span>str_length= <span class="hljs-built_in">strlen</span>(str_data);<span class="hljs-comment">/* INSERT SMALLINT data as NULL */</span>is_null= <span class="hljs-number">1</span>;<span class="hljs-comment">/* Execute the INSERT statement - 1*/</span><span class="hljs-keyword">if</span> (mysql_stmt_execute(stmt)){<span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">" mysql_stmt_execute(), 1 failed\n"</span>);<span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">" %s\n"</span>, mysql_stmt_error(stmt));<span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>);}<span class="hljs-comment">/* Get the total number of affected rows */</span>affected_rows= mysql_stmt_affected_rows(stmt);<span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stdout</span>, <span class="hljs-string">" total affected rows(insert 1): %lu\n"</span>,      (<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>) affected_rows);<span class="hljs-keyword">if</span> (affected_rows != <span class="hljs-number">1</span>) <span class="hljs-comment">/* validate affected rows */</span>{<span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">" invalid affected rows by MySQL\n"</span>);<span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>);}<span class="hljs-comment">/* Specify data values for second row, then re-execute the statement */</span>int_data= <span class="hljs-number">1000</span>;<span class="hljs-built_in">strncpy</span>(str_data, <span class="hljs-string">"The most popular Open Source database"</span>, STRING_SIZE);str_length= <span class="hljs-built_in">strlen</span>(str_data);small_data= <span class="hljs-number">1000</span>;     <span class="hljs-comment">/* smallint */</span>is_null= <span class="hljs-number">0</span>;        <span class="hljs-comment">/* reset */</span><span class="hljs-comment">/* Execute the INSERT statement - 2*/</span><span class="hljs-keyword">if</span> (mysql_stmt_execute(stmt)){<span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">" mysql_stmt_execute, 2 failed\n"</span>);<span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">" %s\n"</span>, mysql_stmt_error(stmt));<span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>);}<span class="hljs-comment">/* Get the total rows affected */</span>affected_rows= mysql_stmt_affected_rows(stmt);<span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stdout</span>, <span class="hljs-string">" total affected rows(insert 2): %lu\n"</span>,      (<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>) affected_rows);    <span class="hljs-keyword">if</span> (affected_rows != <span class="hljs-number">1</span>) <span class="hljs-comment">/* validate affected rows */</span>{<span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">" invalid affected rows by MySQL\n"</span>);<span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>);}<span class="hljs-comment">/* Close the statement */</span><span class="hljs-keyword">if</span> (mysql_stmt_close(stmt)){<span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">" failed while closing the statement\n"</span>);<span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">" %s\n"</span>, mysql_stmt_error(stmt));<span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>);}mysql_close(mysql);<span class="hljs-built_in">printf</span>(<span class="hljs-string">"hello mysql...\n"</span>);<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;}</code></pre></div><p>注意：bind –&gt; mysql.h下 MYSQL_BIND结构体  bind[3]; 是一个结构体数组。有3个‘?’占位符，所以用三个结构体(数组)来对应保存信息。0-&gt;第一列；1-&gt;第二列；2-&gt;第三列。</p><p><code>mysql.h</code>中查找 <code>MYSQL_BIND</code> 结构体原型。对比：<code>select * from teat_table</code>;  和 <code>desc test_table</code>; 的查询结果。</p><p>帮助理解bind的小程序框架：            </p><div class="code-wrapper"><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">xxx</span>{</span>    <span class="hljs-type">char</span> *p1;    <span class="hljs-type">char</span> *p2;    <span class="hljs-type">char</span> *p3;} MYSQL_BIND;<span class="hljs-type">void</span> <span class="hljs-title function_">saveXXXInfo</span><span class="hljs-params">(MYSQL_BIND *bind, <span class="hljs-type">int</span> num)</span>{    insert into test_table <span class="hljs-title function_">valudes</span><span class="hljs-params">(bind[<span class="hljs-number">0</span>].p2, bind[<span class="hljs-number">1</span>].p3, bind[<span class="hljs-number">2</span>].p1)</span>;}<span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>{    MYSQL_BIND bind[<span class="hljs-number">3</span>];    bind[<span class="hljs-number">0</span>].p1 = <span class="hljs-string">"类型1"</span>;<span class="hljs-comment">//第一列</span>    bind[<span class="hljs-number">0</span>].p2 = <span class="hljs-string">"10"</span>;    bind[<span class="hljs-number">0</span>].p3 = <span class="hljs-string">"其他数据"</span>;    bind[<span class="hljs-number">1</span>].p1 = <span class="hljs-string">"类型"</span>;<span class="hljs-comment">//第二列</span>    bind[<span class="hljs-number">1</span>].p2 = <span class="hljs-string">"数据"</span>;    bind[<span class="hljs-number">1</span>].p3 = <span class="hljs-string">"描述"</span>;    bind[<span class="hljs-number">2</span>].p1 = <span class="hljs-string">"p1p1p1"</span>;<span class="hljs-comment">//第三列   </span>    <span class="hljs-comment">//第四列是时间戳，不需要用户使用?来指定，直接使用了系统时间。</span>    bind[<span class="hljs-number">2</span>].p2 = <span class="hljs-string">"数据"</span>;    bind[<span class="hljs-number">2</span>].p3 = <span class="hljs-string">"其他限定条件"</span>;    saveXXXInfo(bind, <span class="hljs-number">3</span>);}</code></pre></div><h2><span id="ri-qi-shi-jian-lei-api-han-shu">日期时间类API函数</span><a href="#ri-qi-shi-jian-lei-api-han-shu" class="header-anchor">#</a></h2><p>练习：熟悉上述预处理类工作模式，模拟精简一个将时间插入数据库的程序。将时间存入数据库有两种方式：        </p><ol><li><p>使用SQL语句方式</p></li><li><p>预处理环境句柄变量方式存入</p></li></ol><p>提示：</p><div class="code-wrapper"><pre><code class="hljs c">MYSQL_TIME  ts;<span class="hljs-comment">// 浏览头文件 mysql_time.h 熟悉MYSQL_TIME结构体。</span>MYSQL_BIND  bind[<span class="hljs-number">3</span>];MYSQL_STMT  *stmt;<span class="hljs-comment">// 可直接使用SQL语句提前创建表test_table2，也可以使用mysql_query函数来创建。</span>create table <span class="hljs-title function_">test_table2</span> <span class="hljs-params">(date_field date, time_field time, timestamp_field timestamp)</span>;<span class="hljs-type">char</span> query[<span class="hljs-number">1024</span>] = <span class="hljs-string">"INSERT INTO test_table2(date_field, time_field, timestamp_field) VALUES(?,?,?)"</span>;stmt = mysql_stmt_init(mysql);<span class="hljs-comment">// MYSQL_TIME 是一个结构体，使用typedef定义。位于mysql_time.h文件中。</span></code></pre></div><p>API参考：refman-5.6-en.a4.pdf手册25.2.10. 日期和时间值的C API处理</p><h2><span id="duo-cha-xun-zhi-xing-de-c-api-han-shu">多查询执行的C API函数</span><a href="#duo-cha-xun-zhi-xing-de-c-api-han-shu" class="header-anchor">#</a></h2><p>一次性执行多条SQL语句，包括select、drop、update、create等。<br>如：</p><div class="code-wrapper"><pre><code class="hljs c">mysql_query(mysql,<span class="hljs-string">"DROP TABLE IF EXISTS test_table;\</span><span class="hljs-string"></span><span class="hljs-string">CREATE TABLE test_table(id INT);\</span><span class="hljs-string"></span><span class="hljs-string">INSERT INTO test_table VALUES(10);\</span><span class="hljs-string"></span><span class="hljs-string">UPDATE test_table SET id=20 WHERE id=10;\</span><span class="hljs-string"></span><span class="hljs-string">SELECT * FROM test_table;\</span><span class="hljs-string"></span><span class="hljs-string">DROP TABLE test_table"</span>);</code></pre></div><div class="code-wrapper"><pre><code class="hljs">文档：25.2.9. 多查询执行的C API处理。中文文档只有demo框架。查阅对应英文文档refman-5.6-en.a4.pdf。关键字Multiple 23.8.17注意：打桩函数——函数接口if (mysql_real_connect (mysql, host_name, user_name, password,db_name, port_num, socket_name, CLIENT_MULTI_STATEMENTS) == NULL)CLIENT_MULTI_STATEMENTS：客户端通知Server，将要发送多个SQL语句。mysql_field_count(mysql)：影响的行数。 如：当select * from dept;    执行结束，提示：“5 rows in set”        表示影响了4行。当Create一张表，    执行结束，提示：“Query OK, 0 rows affected (0.01 sec)”当delete一行，        执行结束，提示：“Query OK, 1 row affected (0.00 sec)”mysql_field_count函数调用后会将影响的行数保存到句柄 mysql 中。</code></pre></div><p>下方是帮助文档中demo程序，它将帮助我们分析与之前掌握的API函数间的区别与联系：</p><div class="code-wrapper"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">"mysql.h"</span> </span><span class="hljs-type">void</span> <span class="hljs-title function_">process_result_set</span><span class="hljs-params">(MYSQL *mysql, MYSQL_RES *result)</span>{<span class="hljs-type">int</span> i, num;num = mysql_field_count(mysql);MYSQL_FIELD *fields = <span class="hljs-literal">NULL</span>;fields = mysql_fetch_fields(result);<span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; num; i++) {<span class="hljs-built_in">printf</span>(<span class="hljs-string">"%10s\t"</span>, fields[i].name);}<span class="hljs-built_in">printf</span>(<span class="hljs-string">"\n"</span>);MYSQL_ROW row = <span class="hljs-literal">NULL</span>;<span class="hljs-keyword">while</span> ((row = mysql_fetch_row(result))) {<span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; num; i++) {<span class="hljs-built_in">printf</span>(<span class="hljs-string">"%10s\t"</span>, row[i]);}<span class="hljs-built_in">printf</span>(<span class="hljs-string">"\n"</span>);}}<span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>{<span class="hljs-type">int</span> ret = <span class="hljs-number">0</span>, status = <span class="hljs-number">0</span>;MYSQL_RES *result = <span class="hljs-literal">NULL</span>;MYSQL *mysql = mysql_init(<span class="hljs-literal">NULL</span>);<span class="hljs-keyword">if</span> (mysql == <span class="hljs-literal">NULL</span>) {<span class="hljs-comment">//unsigned int mysql_errno(MYSQL *mysql) </span>ret = mysql_errno(mysql);<span class="hljs-built_in">printf</span>(<span class="hljs-string">"mysql_init err:%d\n"</span>, ret);<span class="hljs-keyword">return</span> ret;}mysql = mysql_real_connect(mysql, <span class="hljs-string">"localhost"</span>, <span class="hljs-string">"root"</span>, <span class="hljs-string">"123456"</span>, <span class="hljs-string">"mydb61"</span>, <span class="hljs-number">0</span>, <span class="hljs-literal">NULL</span>, CLIENT_MULTI_STATEMENTS);<span class="hljs-keyword">if</span> (mysql == <span class="hljs-literal">NULL</span>) {ret = mysql_errno(mysql);<span class="hljs-built_in">printf</span>(<span class="hljs-string">"mysql_init err:%d\n"</span>, ret);<span class="hljs-keyword">return</span> ret;}<span class="hljs-comment">/////////////////////////////以下为demo源码//////////////////////////////</span><span class="hljs-comment">/* execute multiple statements */</span>status = mysql_query(mysql,<span class="hljs-string">"DROP TABLE IF EXISTS test_table;\</span><span class="hljs-string"></span><span class="hljs-string">CREATE TABLE test_table(id INT);\</span><span class="hljs-string"></span><span class="hljs-string">INSERT INTO test_table VALUES(10);\</span><span class="hljs-string"></span><span class="hljs-string">UPDATE test_table SET id=20 WHERE id=10;\</span><span class="hljs-string"></span><span class="hljs-string">SELECT * FROM test_table;"</span>);DROP TABLE test_table<span class="hljs-title function_">if</span> <span class="hljs-params">(status)</span>{<span class="hljs-built_in">printf</span>(<span class="hljs-string">"Could not execute statement(s)"</span>);mysql_close(mysql);<span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>);}<span class="hljs-comment">/* process each statement result */</span><span class="hljs-keyword">do</span> {<span class="hljs-comment">/* did current statement return data? */</span>result = mysql_store_result(mysql);<span class="hljs-keyword">if</span> (result){<span class="hljs-comment">/* yes; process rows and free the result set */</span>process_result_set(mysql, result);mysql_free_result(result);}<span class="hljs-keyword">else</span> <span class="hljs-comment">/* no result set or error */</span>{<span class="hljs-keyword">if</span> (mysql_field_count(mysql) == <span class="hljs-number">0</span>){<span class="hljs-built_in">printf</span>(<span class="hljs-string">"%lld rows affected\n"</span>,mysql_affected_rows(mysql));}<span class="hljs-keyword">else</span> <span class="hljs-comment">/* some error occurred */</span>{<span class="hljs-built_in">printf</span>(<span class="hljs-string">"Could not retrieve result set\n"</span>);<span class="hljs-keyword">break</span>;}        }<span class="hljs-comment">/* more results? -1 = no, &gt;0 = error, 0 = yes (keep looping) */</span><span class="hljs-keyword">if</span> ((status = mysql_next_result(mysql)) &gt; <span class="hljs-number">0</span>)<span class="hljs-built_in">printf</span>(<span class="hljs-string">"Could not execute statement\n"</span>);<span class="hljs-built_in">printf</span>(<span class="hljs-string">"------------status: %d\n"</span>, status);} <span class="hljs-keyword">while</span> (status == <span class="hljs-number">0</span>);mysql_close(mysql);<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;}</code></pre></div><p><code>process_result_set</code>函数是文档中给我们预留的打桩函数，需要我们在使用的过程中，自己实现它。</p><p>函数实现就是借助mysql和result两个参数打印一条sql语句查询到的结果集到屏幕。</p><p>可以直接使用<code>mysq_tool.c</code>中<code>if (strncmp(sqlbuf, "select", 6) == 0 || strncmp(sqlbuf, "SELECT", 6) == 0)</code>内的代码。“获取结果集”片段可以删除。“释放结果集”片段可以删除。API示例中含有该部分内容。</p><p>常见错误：在<code>process_result_set</code>函数实现中，不要使用<code>mysql_store_result(mysql)</code>再次获取结果集， 该result已经在API函数接口传入，直接使用参数result即可。否则会出现【段错误】。</p><h2><span id="mysql-zhong-de-shi-wu">MySQL中的事务</span><a href="#mysql-zhong-de-shi-wu" class="header-anchor">#</a></h2><p>测试MySQL中事务的特性。</p><div class="code-wrapper"><pre><code class="hljs">MySQL的事务的默认自动提交的，每执行一个sql语句都自动commitOracle的事务是自动打开的(以你执行的一条DML语句为标志)，但每次执行需要手动commit</code></pre></div><p>在程序中设置autocommit修改MySQL事务的属性。</p><div class="code-wrapper"><pre><code class="hljs">set autocommit = 0 禁止自动提交set autocommit = 1 开启自动提交MySQL中InnoDB引擎才支持事务默认自动提交机制。MYISAM引擎不支持。</code></pre></div><div class="code-wrapper"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">"mysql.h"</span> </span><span class="hljs-meta">#<span class="hljs-keyword">define</span> SET_TRAN<span class="hljs-string">"SET AUTOCOMMIT=0"</span>  <span class="hljs-comment">//手动commit</span></span><span class="hljs-meta">#<span class="hljs-keyword">define</span> UNSET_TRAN<span class="hljs-string">"SET AUTOCOMMIT=1"</span><span class="hljs-comment">//自动commit </span></span><span class="hljs-comment">//设置事务为手动提交</span><span class="hljs-type">int</span> <span class="hljs-title function_">mysql_OperationTran</span><span class="hljs-params">(MYSQL *mysql)</span>  {    <span class="hljs-comment">//--开启事务</span>    <span class="hljs-type">int</span> ret = mysql_query(mysql, <span class="hljs-string">"start transaction"</span>);      <span class="hljs-keyword">if</span> (ret != <span class="hljs-number">0</span>) {        <span class="hljs-built_in">printf</span>(<span class="hljs-string">"mysql_OperationTran query start err: %s\n"</span>, mysql_error(mysql));        <span class="hljs-keyword">return</span> ret;    }    <span class="hljs-comment">//--设置事务为手动提交</span>    ret = mysql_query(mysql, SET_TRAN);    <span class="hljs-keyword">if</span> (ret != <span class="hljs-number">0</span>) {        <span class="hljs-built_in">printf</span>(<span class="hljs-string">"mysql_OperationTran query set err: %s\n"</span>, mysql_error(mysql));        <span class="hljs-keyword">return</span> ret;    }    <span class="hljs-keyword">return</span> ret;}<span class="hljs-comment">//设置事务为自动提交</span><span class="hljs-type">int</span> <span class="hljs-title function_">mysql_AutoTran</span><span class="hljs-params">(MYSQL *mysql)</span>{    <span class="hljs-comment">//--开启事务</span>    <span class="hljs-type">int</span> ret = mysql_query(mysql, <span class="hljs-string">"start transaction"</span>);      <span class="hljs-keyword">if</span> (ret != <span class="hljs-number">0</span>) {        <span class="hljs-built_in">printf</span>(<span class="hljs-string">"mysql_AutoTran query start err: %s\n"</span>, mysql_error(mysql));                <span class="hljs-keyword">return</span> ret;    }    <span class="hljs-comment">//--设置事务为自动提交</span>    ret = mysql_query(mysql, UNSET_TRAN);    <span class="hljs-keyword">if</span> (ret != <span class="hljs-number">0</span>) {        <span class="hljs-built_in">printf</span>(<span class="hljs-string">"mysql_AutoTran query set err: %s\n"</span>, mysql_error(mysql));                <span class="hljs-keyword">return</span> ret;    }    <span class="hljs-keyword">return</span> ret;}<span class="hljs-comment">//执行commit，手动提交事务</span><span class="hljs-type">int</span> <span class="hljs-title function_">mysql_Commit</span><span class="hljs-params">(MYSQL *mysql)</span>{    <span class="hljs-type">int</span> ret = mysql_query(mysql, <span class="hljs-string">"COMMIT"</span>);     <span class="hljs-keyword">if</span> (ret != <span class="hljs-number">0</span>) {        <span class="hljs-built_in">printf</span>(<span class="hljs-string">"commit err: %s\n"</span>, mysql_error(mysql));          <span class="hljs-keyword">return</span> ret;    }    <span class="hljs-keyword">return</span> ret;}<span class="hljs-comment">//执行rollback，回滚事务</span><span class="hljs-type">int</span> <span class="hljs-title function_">mysql_Rollback</span><span class="hljs-params">(MYSQL *mysql)</span>{    <span class="hljs-type">int</span> ret = mysql_query(mysql, <span class="hljs-string">"ROLLBACK"</span>);    <span class="hljs-keyword">if</span> (ret != <span class="hljs-number">0</span>) {        <span class="hljs-built_in">printf</span>(<span class="hljs-string">"rollback err: %s\n"</span>, mysql_error(mysql));        <span class="hljs-keyword">return</span> ret;    }    <span class="hljs-keyword">return</span> ret;} <span class="hljs-meta">#<span class="hljs-keyword">define</span> DROP_SAMPLE_TABLE <span class="hljs-string">"DROP TABLE IF EXISTS test_table"</span></span><span class="hljs-meta">#<span class="hljs-keyword">define</span> CREATE_SAMPLE_TABLE <span class="hljs-string">"CREATE TABLE test_table(col1 INT,\</span></span><span class="hljs-string"><span class="hljs-meta">                             col2 VARCHAR(10),\</span></span><span class="hljs-string"><span class="hljs-meta">                             col3 VARCHAR(10))"</span></span><span class="hljs-meta">#<span class="hljs-keyword">define</span> sql01 <span class="hljs-string">"INSERT INTO test_table(col1,col2,col3) VALUES(10, 'AAA', 'A1')"</span></span><span class="hljs-meta">#<span class="hljs-keyword">define</span> sql02 <span class="hljs-string">"INSERT INTO test_table(col1,col2,col3) VALUES(20, 'BBB', 'B2')"</span></span><span class="hljs-meta">#<span class="hljs-keyword">define</span> sql03 <span class="hljs-string">"INSERT INTO test_table(col1,col2,col3) VALUES(30, 'CCC', 'C3')"</span></span><span class="hljs-meta">#<span class="hljs-keyword">define</span> sql04 <span class="hljs-string">"INSERT INTO test_table(col1,col2,col3) VALUES(40, 'DDD', 'D4')"</span></span><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>{    <span class="hljs-type">int</span> ret = <span class="hljs-number">0</span>;    MYSQL *mysql = mysql_init(<span class="hljs-literal">NULL</span>);    mysql = mysql_real_connect(mysql, <span class="hljs-string">"localhost"</span>, <span class="hljs-string">"root"</span>, <span class="hljs-string">"123456"</span>, <span class="hljs-string">"mydb2"</span>, <span class="hljs-number">0</span>, <span class="hljs-literal">NULL</span>, <span class="hljs-number">0</span>);    <span class="hljs-keyword">if</span> (mysql == <span class="hljs-literal">NULL</span>) {        ret = mysql_errno(mysql);        <span class="hljs-built_in">printf</span>(<span class="hljs-string">"func mysql_real_connect() err：%d\n"</span>, ret);        <span class="hljs-keyword">return</span> ret;    }     <span class="hljs-built_in">printf</span>(<span class="hljs-string">" --- connect ok......\n"</span>);    <span class="hljs-keyword">if</span> (mysql_query(mysql, DROP_SAMPLE_TABLE)) {        <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">" DROP TABLE failed\n"</span>);        <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">" %s\n"</span>, mysql_error(mysql));               <span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>);    }    <span class="hljs-keyword">if</span> (mysql_query(mysql, CREATE_SAMPLE_TABLE)) {        <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">" CREATE TABLE failed\n"</span>);        <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">" %s\n"</span>, mysql_error(mysql));        <span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>);    }    ret = mysql_OperationTran(mysql); <span class="hljs-comment">//开启事务，并修改事务属性为手动commit </span>    <span class="hljs-keyword">if</span> (ret != <span class="hljs-number">0</span>) {        <span class="hljs-built_in">printf</span>(<span class="hljs-string">"mysql_OperationTran() err:%d\n"</span>, ret);        <span class="hljs-keyword">return</span> ret;    }    ret = mysql_query(mysql, sql01);<span class="hljs-comment">//向表中插入第一行数据 ‘AAA’</span>    <span class="hljs-keyword">if</span> (ret != <span class="hljs-number">0</span>) {        <span class="hljs-built_in">printf</span>(<span class="hljs-string">"mysql_query() err:%d\n"</span>, ret);        <span class="hljs-keyword">return</span> ret;    }    ret = mysql_query(mysql, sql02);<span class="hljs-comment">//向表中插入第二行数据 ‘BBB’</span>    <span class="hljs-keyword">if</span> (ret != <span class="hljs-number">0</span>) {        <span class="hljs-built_in">printf</span>(<span class="hljs-string">"mysql_query() err:%d\n"</span>, ret);                <span class="hljs-keyword">return</span> ret;    }    ret = mysql_Commit(mysql); <span class="hljs-comment">//手动提交事务</span>    <span class="hljs-keyword">if</span> (ret != <span class="hljs-number">0</span>) {        <span class="hljs-built_in">printf</span>(<span class="hljs-string">"mysql_Commit() err:%d\n"</span>, ret);        <span class="hljs-keyword">return</span> ret;    }    ret = mysql_AutoTran(mysql); <span class="hljs-comment">// =再次= 修改事务属性为【自动】commit</span>    <span class="hljs-keyword">if</span> (ret != <span class="hljs-number">0</span>) {        <span class="hljs-built_in">printf</span>(<span class="hljs-string">"mysql_OperationTran() err:%d\n"</span>, ret);        <span class="hljs-keyword">return</span> ret;    }    ret = mysql_OperationTran(mysql); <span class="hljs-comment">// =再次= 修改事务属性为【手动】commit</span>    <span class="hljs-keyword">if</span> (ret != <span class="hljs-number">0</span>) {        <span class="hljs-built_in">printf</span>(<span class="hljs-string">"mysql_OperationTran() err:%d\n"</span>, ret);        <span class="hljs-keyword">return</span> ret;    }    ret = mysql_query(mysql, sql03);<span class="hljs-comment">//向表中插入第三行数据 ‘CCC’</span>    <span class="hljs-keyword">if</span> (ret != <span class="hljs-number">0</span>) {        <span class="hljs-built_in">printf</span>(<span class="hljs-string">"mysql_query() err:%d\n"</span>, ret);        <span class="hljs-keyword">return</span> ret;    }    ret = mysql_query(mysql, sql04);<span class="hljs-comment">//向表中插入第四行数据 ‘DDD’</span>    <span class="hljs-keyword">if</span> (ret != <span class="hljs-number">0</span>) {        <span class="hljs-built_in">printf</span>(<span class="hljs-string">"mysql_query() err:%d\n"</span>, ret);        <span class="hljs-keyword">return</span> ret;    }    ret = mysql_Rollback(mysql);<span class="hljs-comment">//直接rollback操作</span>    <span class="hljs-keyword">if</span> (ret != <span class="hljs-number">0</span>) {        <span class="hljs-built_in">printf</span>(<span class="hljs-string">"mysql_Rollback() err:%d\n"</span>, ret);        <span class="hljs-keyword">return</span> ret;    }    <span class="hljs-comment">//rollback操作是否能回退掉CCC、DDD的值，取决于事务属性。</span>    mysql_close(mysql);    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;}</code></pre></div><p>对应参考API手册。中文：25.2.3.2.        英文：23.8.7.2</p>]]></content>
    
    
    
    <tags>
      
      <tag>DataBase</tag>
      
      <tag>Mysql</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Mysql数据库</title>
    <link href="/2022/01/05/Mysql%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    <url>/2022/01/05/Mysql%E6%95%B0%E6%8D%AE%E5%BA%93/</url>
    
    <content type="html"><![CDATA[<div class="toc"><!-- toc --><ul><li><a href="#1-mysql-ji-chu-zhi-shi">1 MySQL基础知识</a><ul><li><a href="#1-1-mysql-ban-ben-ji-xia-zai">1.1 MySQL版本及下载</a></li><li><a href="#1-2-xia-zai-an-zhuang-bao">1.2 下载安装包</a></li></ul></li><li><a href="#2-mysql-fu-wu-qi-an-zhuang-he-qi-dong">2 MySQL服务器安装和启动</a><ul><li><a href="#2-1-cha-xun-fu-wu-qi-shang-yi-jing-an-zhuang-de-mysql">2.1 查询服务器上已经安装的mysql</a></li><li><a href="#2-2-xie-zai-jiu-de-ban-ben">2.2 卸载旧的版本</a></li><li><a href="#2-3-an-zhuang">2.3 安装</a><ul><li><a href="#2-3-1-an-zhuang-fu-wu-qi">2.3.1 安装服务器</a></li><li><a href="#2-3-2-an-zhuang-ke-hu-duan">2.3.2 安装客户端：</a></li><li><a href="#2-4-cha-kan-mysql-fu-wu-qi-shi-fou-yi-jing-qi-dong">2.4 查看mysql服务器是否已经启动</a></li></ul></li><li><a href="#2-5-deng-lu-mysql">2.5 登录Mysql</a><ul><li><a href="#1-cha-kan-wen-jian-xun-zhao-mi-ma">1.查看文件寻找密码</a></li><li><a href="#2-yi-root-yong-hu-shen-fen-deng-lu-mysql">2.以root用户身份登陆MySQL</a></li><li><a href="#3-xiu-gai-mi-ma">3.修改密码</a></li><li><a href="#4-cha-kan-shu-ju-ku">4.查看数据库</a></li><li><a href="#5-yuan-cheng-root-deng-lu-mysql">5.远程root登录mysql</a></li><li><a href="#5-2-6-cha-kan-root-yong-hu-de-host">5.2.6查看 root 用户的 host</a></li></ul></li><li><a href="#6-shu-ju-ku-de-curd">6. 数据库的CURD</a><ul><li><a href="#6-1-cha-kan-shu-ju-ku">6.1查看数据库</a></li><li><a href="#6-2-chuang-jian-shu-ju-ku">6.2创建数据库</a></li><li><a href="#6-3-xiu-gai-shu-ju-ku">6.3修改数据库</a></li><li><a href="#6-4-shan-chu-shu-ju-ku">6.4删除数据库</a></li></ul></li><li><a href="#7-biao-de-curd">7. 表的CURD</a><ul><li><a href="#7-1-cha-kan-biao">7.1 查看表</a></li><li><a href="#7-2-chuang-jian-biao">7.2创建表</a></li><li><a href="#7-3-xiu-gai-biao">7.3修改表</a></li><li><a href="#7-4-shan-chu-biao">7.4 删除表</a></li></ul></li><li><a href="#8-biao-shu-ju-de-curd">8. 表数据的CURD</a></li><li><a href="#9-mysql-han-shu-de-shi-yong">9. mysql函数的使用</a><ul><li><a href="#9-1-ri-qi-han-shu">9.1 日期函数</a></li><li><a href="#9-2-zi-fu-chuan-han-shu">9.2 字符串函数</a></li><li><a href="#9-3-shu-xue-han-shu">9.3 数学函数</a></li><li><a href="#9-4-ri-qi-zhuan-huan">9.4 日期转换</a></li></ul></li><li><a href="#10-duo-biao-cha-xun">10. 多表查询</a><ul><li><a href="#10-1-nei-lian-jie-inner-join">10.1 内连接 – inner join</a></li><li><a href="#10-2-wai-lian-jie-outer-join">10.2 外连接 – outer join</a></li><li><a href="#10-3-zi-lian-jie">10.3 自连接</a></li></ul></li><li><a href="#11-biao-de-yue-shu">11. 表的约束</a><ul><li><a href="#11-1-yue-shu-chong-lei">11.1 约束种类</a></li><li><a href="#11-2-yue-shu-de-shi-yong">11.2 约束的使用</a></li></ul></li><li><a href="#12-shi-wu">12. 事务</a></li><li><a href="#13-mysql-api">13. mysql API</a></li></ul></li></ul><!-- tocstop --></div><h1><span id="1-mysql-ji-chu-zhi-shi">1  MySQL基础知识</span><a href="#1-mysql-ji-chu-zhi-shi" class="header-anchor">#</a></h1><p>瑞典MySQL AB公司开发，由SUN收购，而后SUN被甲骨文并购，目前属于Oracle公司。</p><p>MySQL是一种关联数据库管理系统 由于其体积小、速度快、总体拥有成本低、MySQL软件采用了双授权政策，分为社区版和企业版。</p><h2><span id="1-1-mysql-ban-ben-ji-xia-zai">1.1 MySQL版本及下载</span><a href="#1-1-mysql-ban-ben-ji-xia-zai" class="header-anchor">#</a></h2><p>MySQL数据库版本相对比较繁杂。常见的有：Community社区版、Enterprise企业版。</p><p>MySQL Community Server 版是开源免费的，这也是我们通常用的MySQL的版本。可以满足绝大多数用户需求。</p><p>MySQL Enterprise Edition 企业版收费的，官方指出提供30天免费试用期。可进一步划分为MySQL标准版、MySQL企业版、MySQL集群版。官方提供付费服务。</p><p>其中Community Server 可以直接从mysql 的官网下载。但Enterprice Edition只能从Oracle edelivery上下载，而Edelivery有时会屏蔽中国IP。</p><p>MySQL各版本区别参见：</p><p><a href="http://www.admin10000.com/Document/62.html">http://www.admin10000.com/Document/62.html</a></p><p>下载mysql时注意区分版本细节及所应用的系统平台：<code>linux(32/64)</code> 、<code>win(32/64)</code></p><p>举例：</p><p><strong>win版本：</strong></p><p>mysql-installer-community-8.0.26.0.msi版本</p><p>​    GA 是指软件的通用版本，一般指正式发布的版本 (Generally Available (GA) Release)</p><p>​    mysql-essential-5.1.60-win32.msi精简版，如果只需要mysql服务，就选择此版本。</p><p>​    mysql-5.1.60-win32.msi          是完    是整版，包含安装程序和配置向导，有MySQL文档。</p><p>mysql-noinstall-5.1.60-win32.zip 是非安装的zip压缩包，没有自动安装程序和配置向导，无安装向导</p><p>​    mysql-5.1.60.zip 是用于windows的Mysql源码压缩包</p><p><strong>linux版本</strong></p><p>​    在<a href="http://www.mysql.com/downloads/%E7%BD%91%E7%AB%99%E4%B8%8A%E4%B8%8B%E8%BD%BD%E4%B8%8D%E4%BA%86">http://www.mysql.com/downloads/网站上下载不了</a></p><p>​    在 <a href="http://www.oracle.com/downloads">www.oracle.com/downloads</a> 找mysql 注册用户, 选择操作系统平台和mysql版本 进行下载</p><p>官方文档上有关MySQL安装，介绍了3种类型及其对应安装方式来安装MySQL数据库：</p><p>　　Linux supports a number of different solutions for installing MySQL. The recommended method is to use one of the distributions from Oracle. If you choose this method, there are three options available:</p><p>(1)  Installing from a generic binary package in .tar.gz format. See Section 2.2,“Installing MySQL from Generic Binaries on Unix/Linux”for more information.</p><p>(2)  Extracting and compiling MySQL from a source distribution. For detailed instructions, see Section 2.9, “Installing MySQL from Source”.</p><p>(3)  Installing using a pre-compiled RPM package. For more information on using the RPM solution, see Section 2.5.1,“Installing MySQL from RPM Packages on Linux”</p><p>我们选用较简单的RPM 包来安装。</p><h2><span id="1-2-xia-zai-an-zhuang-bao">1.2 下载安装包</span><a href="#1-2-xia-zai-an-zhuang-bao" class="header-anchor">#</a></h2><p><strong>Community Server</strong> 下载地址：<a href="https://dev.mysql.com/downloads/mysql/">https://dev.mysql.com/downloads/mysql/</a></p><p>MySQL Community Server.          mysql社区版，开源、免费</p><p>MySQL Enterprise Edition.        mysql企业版，非免费</p><p>MySQL Cluster.                   mysql集群版，开源、免费</p><h1><span id="2-mysql-fu-wu-qi-an-zhuang-he-qi-dong">2   MySQL服务器安装和启动</span><a href="#2-mysql-fu-wu-qi-an-zhuang-he-qi-dong" class="header-anchor">#</a></h1><h2><span id="2-1-cha-xun-fu-wu-qi-shang-yi-jing-an-zhuang-de-mysql">2.1 查询服务器上已经安装的mysql</span><a href="#2-1-cha-xun-fu-wu-qi-shang-yi-jing-an-zhuang-de-mysql" class="header-anchor">#</a></h2><p>​    在终端提示符输入：<code>rpm -aq | grep mysql</code>    命令。查询结果如下显示：</p><div class="code-wrapper"><pre><code class="hljs shell">qt-mysql-4.6.2-25.el6.x86_64mysql-connector-odbc-5.1.5r1144-7.el6.x86_64mysql-bench-5.1.66-2.el6_3.x86_64mysql-devel-5.1.66-2.el6_3.x86_64libdbi-dbd-mysql-0.8.3-5.1.el6.x86_64mysql-test-5.1.66-2.el6_3.x86_64mysql-libs-5.1.66-2.el6_3.x86_64mysql-5.1.66-2.el6_3.x86_64mysql-connector-java-5.1.17-6.el6.noarchmysql-server-5.1.66-2.el6_3.x86_64</code></pre></div><p>​    注：各机器有可能不相同，软件列表视实际情况。</p><h2><span id="2-2-xie-zai-jiu-de-ban-ben">2.2 卸载旧的版本</span><a href="#2-2-xie-zai-jiu-de-ban-ben" class="header-anchor">#</a></h2><p>rpm -e 软件包名 –nodeps –allmatches (不理会依赖关系，删除所有上一步查出来的相同的mysql)</p><div class="code-wrapper"><pre><code class="hljs shell">[root@localhost home]# rpm -e mysql-connector-odbc-3.51.26r1127-1.el5 --nodeps --allmatches    [root@localhost home]# rpm -e libdbi-dbd-mysql-0.8.1a-1.2.2 --nodeps --allmatches    [root@localhost home]# rpm -e mysql-server-5.0.77-3.el5 --nodeps --allmatches    [root@localhost home]# rpm -aq | grep mysql    [root@localhost home]#</code></pre></div><p>​    <strong>将老版本的几个文件手动删除</strong></p><div class="code-wrapper"><pre><code class="hljs shell">rm -f /etc/my.cnf    rm -rf /var/lib/mysql    rm -rf /var/share/mysql    rm -rf /usr/bin/mysql*</code></pre></div><h2><span id="2-3-an-zhuang">2.3 安装</span><a href="#2-3-an-zhuang" class="header-anchor">#</a></h2><p>解压.zip安装包</p><div class="code-wrapper"><pre><code class="hljs shell">unzip V46610-01-MySQL Database 5.6.20 RPM for Oracle Linux RHEL 6 x86 (64bit).zip</code></pre></div><p><strong>得到如下软件包</strong>：</p><div class="code-wrapper"><pre><code class="hljs shell">MySQL-client-advanced-5.6.20-1.el6.x86_64.rpm  MySQL-devil-advanced-5.6.20-1.el6.x86_64.rpm    MySQL-server-advanced-5.6.20-1.el6.x86_64.rpm    MySQL-embedded-advanced-5.6.20-1.el6.x86_64.rpm  MySQL-shared-advanced-5.6.20-1.el6.x86_64.rpm    MySQL-shared-compal-advanced-5.6.20-1.el6.x86_64.rpm   MySQL-test-advanced-5.6.20-1.el6.x86_64.rpm    README.txt</code></pre></div><h3><span id="2-3-1-an-zhuang-fu-wu-qi">2.3.1 安装服务器</span><a href="#2-3-1-an-zhuang-fu-wu-qi" class="header-anchor">#</a></h3><div class="code-wrapper"><pre><code class="hljs shell">rpm -ivh MySQL-server-advanced-5.6.****-1.el6.x86_64.rpm    A RANDOM PASSWORD HAS BEEN SET FOR THE MySQL root USER !    You will find that password in '/root/.mysql_secret'.    You must change that password on your first connect,    no other statement but 'SET PASSWORD' will be accepted.    See the manual for the semantics of the 'password expired' flag.    Also, the account for the anonymous user has been removed.    In addition, you can run:        /usr/bin/mysql_secure_installation    which will also give you the option of removing the test database.    This is strongly recommended for production servers.    See the manual for more instructions.    Please report any problems at http://bugs.mysql.com/    The latest information about MySQL is available on the web at    http://www.mysql.com    Support MySQL by buying support/licenses at http://shop.mysql.com    New default config file was created as /usr/my.cnf and    will be used by default by the server when you start it.    You may edit this file to change server settings</code></pre></div><h3><span id="2-3-2-an-zhuang-ke-hu-duan">2.3.2 安装客户端：</span><a href="#2-3-2-an-zhuang-ke-hu-duan" class="header-anchor">#</a></h3><div class="code-wrapper"><pre><code class="hljs shell">rpm -ivh MySQL-client-advanced-5.6.****-1.el6.x86_64.rpm</code></pre></div><p><strong>说明</strong>:不安装mysql-client是不能使用mysql工具登陆到mysql数据库</p><p>​    其他软件包选择性安装：<br><code>rpm -ivh MySQL-devel-advanced-5.6.20-1.el6.x86_64.rpm</code></p><h3><span id="2-4-cha-kan-mysql-fu-wu-qi-shi-fou-yi-jing-qi-dong">2.4 查看mysql服务器是否已经启动</span><a href="#2-4-cha-kan-mysql-fu-wu-qi-shi-fou-yi-jing-qi-dong" class="header-anchor">#</a></h3><div class="code-wrapper"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">查看状态</span>systemctl status mysqld <span class="hljs-meta prompt_"># </span><span class="language-bash">启动mysql</span>systemctl start mysqld <span class="hljs-meta prompt_"># </span><span class="language-bash">关闭mysql</span>systemctl stop mysqld <span class="hljs-meta prompt_"># </span><span class="language-bash">重新启动mysql</span>systemctl restart mysqld <span class="hljs-meta prompt_"># </span><span class="language-bash">开机启动mysql</span>systemctl enable mysqld <span class="hljs-meta prompt_"># </span><span class="language-bash">关闭开机启动mysql</span>systemctl disable mysqld<span class="hljs-meta prompt_"># </span><span class="language-bash">另外一种操作方式</span>service mysqld status</code></pre></div><h2><span id="2-5-deng-lu-mysql">2.5 登录Mysql</span><a href="#2-5-deng-lu-mysql" class="header-anchor">#</a></h2><p>oracle收购Mysql后, 新版的mysql刚安装完mysql后不能直接输入mysql登录数据库, 而是设置了默认free password密码, 默认密码放在了/root/.mysql_secret文件中, 登陆后需要修改密码。</p><h3><span id="1-cha-kan-wen-jian-xun-zhao-mi-ma">1.查看文件寻找密码</span><a href="#1-cha-kan-wen-jian-xun-zhao-mi-ma" class="header-anchor">#</a></h3><div class="code-wrapper"><pre><code class="hljs shell">cat /root/.mysql_secret</code></pre></div><h3><span id="2-yi-root-yong-hu-shen-fen-deng-lu-mysql">2.以root用户身份登陆MySQL</span><a href="#2-yi-root-yong-hu-shen-fen-deng-lu-mysql" class="header-anchor">#</a></h3><p>服务启动和关闭：</p><div class="code-wrapper"><pre><code class="hljs shell">service mysql startservice mysql stop</code></pre></div><p><code>ps -u mysql</code> #可以查看mysql用户（安装MySQL时，系统自动创建该用户）的进程</p><div class="code-wrapper"><pre><code class="hljs shell">PID TTY     TIME CMD7586 ?         00:00:50 mysqld     守护进程</code></pre></div><p><strong>登陆服务器</strong>：</p><p><code>mysql -uroot –p 密码</code></p><p>输入从.mysql_secret中读到的密码登录。</p><p>如果登录期间发生异常，无法登陆：</p><p>使用root将mysql的后台进程kill -9 PID</p><h3><span id="3-xiu-gai-mi-ma">3.修改密码</span><a href="#3-xiu-gai-mi-ma" class="header-anchor">#</a></h3><p><code>mysql&gt; set password=password('123456');    将密码设置为：123456</code></p><p>密码修改成后，再次登录使用：</p><p>$mysql -uroot -p123456   即可。</p><h3><span id="4-cha-kan-shu-ju-ku">4.查看数据库</span><a href="#4-cha-kan-shu-ju-ku" class="header-anchor">#</a></h3><p><code>mysql&gt; show databases;</code><br><img src="https://gitee.com/txt1994/images/raw/master/img/2021/08/clip_image002.jpg"></p><h3><span id="5-yuan-cheng-root-deng-lu-mysql">5.远程root登录mysql</span><a href="#5-yuan-cheng-root-deng-lu-mysql" class="header-anchor">#</a></h3><h4><span id="5-1mysql8-0-chuang-jian-yong-hu-he-shou-quan">5.1Mysql8.0创建用户和授权</span><a href="#5-1mysql8-0-chuang-jian-yong-hu-he-shou-quan" class="header-anchor">#</a></h4><p>mysql8.0需要先创建用户和设置密码,然后才能授权.</p><div class="code-wrapper"><pre><code class="hljs sql">#先创建一个用户<span class="hljs-keyword">create</span> <span class="hljs-keyword">user</span> <span class="hljs-string">'tone'</span>@<span class="hljs-string">'%'</span> identified <span class="hljs-keyword">by</span> <span class="hljs-string">'123123'</span>; #再进行授权<span class="hljs-keyword">grant</span> <span class="hljs-keyword">all</span> privileges <span class="hljs-keyword">on</span> <span class="hljs-operator">*</span>.<span class="hljs-operator">*</span> <span class="hljs-keyword">to</span> <span class="hljs-string">'tone'</span>@<span class="hljs-string">'%'</span> <span class="hljs-keyword">with</span> <span class="hljs-keyword">grant</span> option;</code></pre></div><h4><span id="5-2mysql8-0-de-yuan-cheng-lian-jie">5.2MySQL8.0 的远程链接</span><a href="#5-2mysql8-0-de-yuan-cheng-lian-jie" class="header-anchor">#</a></h4><p>MySQL 安装完成后只支持 localhost 访问，我们必须设置一下才可以远程访问，另外还有一些 MySQL 8.0 连接时的一些问题.</p><h5><span id="5-2-1-deng-lu-mysql">5.2.1登录MySQL</span><a href="#5-2-1-deng-lu-mysql" class="header-anchor">#</a></h5><div class="code-wrapper"><pre><code class="hljs shell">mysql -u root -p<span class="hljs-meta prompt_">#</span><span class="language-bash">然后输入您的密码</span></code></pre></div><h5><span id="5-2-2-xuan-ze-mysql-shu-ju-ku">5.2.2选择 mysql 数据库</span><a href="#5-2-2-xuan-ze-mysql-shu-ju-ku" class="header-anchor">#</a></h5><div class="code-wrapper"><pre><code class="hljs sql">use mysql;<span class="hljs-comment">--因为 mysql 数据库中存储了用户信息的 user 表。   </span></code></pre></div><h5><span id="5-2-3-zai-mysql-shu-ju-ku-de-user-biao-zhong-cha-kan-dang-qian-root-yong-hu-de-xiang-guan-xin-xi">5.2.3在 mysql 数据库的 user 表中查看当前 root 用户的相关信息</span><a href="#5-2-3-zai-mysql-shu-ju-ku-de-user-biao-zhong-cha-kan-dang-qian-root-yong-hu-de-xiang-guan-xin-xi" class="header-anchor">#</a></h5><div class="code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> host, <span class="hljs-keyword">user</span>, authentication_string, plugin <span class="hljs-keyword">from</span> <span class="hljs-keyword">user</span>; <span class="hljs-comment">--执行完上面的命令后会显示一个表格</span><span class="hljs-comment">--查看表格中 root 用户的 host，默认应该显示的 localhost，只支持本地访问，不允许远程访问。</span></code></pre></div><h5><span id="5-2-4-shou-quan-root-yong-hu-de-suo-you-quan-xian-bing-she-zhi-yuan-cheng-fang-wen">5.2.4授权 root 用户的所有权限并设置远程访问</span><a href="#5-2-4-shou-quan-root-yong-hu-de-suo-you-quan-xian-bing-she-zhi-yuan-cheng-fang-wen" class="header-anchor">#</a></h5><div class="code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">GRANT</span> <span class="hljs-keyword">ALL</span> <span class="hljs-keyword">ON</span> <span class="hljs-operator">*</span>.<span class="hljs-operator">*</span> <span class="hljs-keyword">TO</span> <span class="hljs-string">'root'</span>@<span class="hljs-string">'%'</span>;<span class="hljs-keyword">GRANT</span> <span class="hljs-keyword">ALL</span> <span class="hljs-keyword">ON</span> 表示所有权限，<span class="hljs-operator">%</span> 表示通配所有 host，可以访问远程。<span class="hljs-keyword">ALTER</span> <span class="hljs-keyword">USER</span> <span class="hljs-string">'root'</span>@<span class="hljs-string">'%'</span> IDENTIFIED <span class="hljs-keyword">WITH</span> mysql_native_password <span class="hljs-keyword">BY</span> <span class="hljs-string">'你自己的密码'</span>;</code></pre></div><h5><span id="5-2-5-shua-xin-quan-xian">5.2.5刷新权限</span><a href="#5-2-5-shua-xin-quan-xian" class="header-anchor">#</a></h5><div class="code-wrapper"><pre><code class="hljs sql"><span class="hljs-comment">--所有操作后，应执行    </span>flush privileges;</code></pre></div><h3><span id="5-2-6-cha-kan-root-yong-hu-de-host">5.2.6查看 root 用户的 host</span><a href="#5-2-6-cha-kan-root-yong-hu-de-host" class="header-anchor">#</a></h3><div class="code-wrapper"><pre><code class="hljs">use mysql;select host, user, authentication_string, plugin from user;--会发现 root 用户的 host 已经变成 %，说明我们的修改已经成功，可以远程访问了。</code></pre></div><p><img src="https://gitee.com/txt1994/images/raw/master/img/2021/08/mysql8%E8%BF%9C%E7%A8%8B%E8%BF%9E%E6%8E%A5.bmp"></p><h4><span id="5-3-fang-wen-shu-ju-ku">5.3访问数据库</span><a href="#5-3-fang-wen-shu-ju-ku" class="header-anchor">#</a></h4><div class="code-wrapper"><pre><code class="hljs sql"><span class="hljs-comment">--输入访问的 host 和密码，报 2059 错误，这是因为 MySql8.0 版本 和 5.7 的加密规则不一样，而现在的可视化工具只支持旧的加密方式。</span><span class="hljs-comment">--出现这个原因是mysql8 之前的版本中加密规则是mysql_native_password,而在mysql8之后,加密规则是caching_sha2_password.</span><span class="hljs-comment">--解决问题方法有两种,一种是升级navicat驱动,一种是把mysql用户登录密码加密规则还原成mysql_native_password.</span><span class="hljs-comment">--这里采用第二种方式 ：</span>        <span class="hljs-comment">--修改加密规则:</span>    <span class="hljs-keyword">ALTER</span> <span class="hljs-keyword">USER</span> <span class="hljs-string">'root'</span>@<span class="hljs-string">'%'</span> IDENTIFIED <span class="hljs-keyword">BY</span> <span class="hljs-string">'password'</span> PASSWORD EXPIRE NEVER;     password 为你当前密码。    <span class="hljs-comment">--更新 root 用户密码:</span>    <span class="hljs-keyword">ALTER</span> <span class="hljs-keyword">USER</span> <span class="hljs-string">'root'</span>@<span class="hljs-string">'%'</span> IDENTIFIED <span class="hljs-keyword">WITH</span> mysql_native_password <span class="hljs-keyword">BY</span> <span class="hljs-string">'password'</span>;     password 为你新设置的密码。    <span class="hljs-comment">--刷新权限:</span>    FLUSH PRIVILEGES;     <span class="hljs-comment">--OK，设置完成，再次使用 Navicat 连接数据库</span></code></pre></div><h2><span id="6-shu-ju-ku-de-curd">6.  数据库的CURD</span><a href="#6-shu-ju-ku-de-curd" class="header-anchor">#</a></h2><blockquote><p>  对数据库进行增(Create)、改(Update) 、查(Retrieve) 、删(Delete)操作。</p></blockquote><h3><span id="6-1-cha-kan-shu-ju-ku">6.1查看数据库</span><a href="#6-1-cha-kan-shu-ju-ku" class="header-anchor">#</a></h3><ul><li><p>显示所有数据库</p><div class="code-wrapper"><pre><code class="hljs sql">mysql<span class="hljs-operator">&gt;</span> <span class="hljs-keyword">show</span> databases;<span class="hljs-operator">+</span><span class="hljs-comment">--------------------+</span><span class="hljs-operator">|</span> Database           <span class="hljs-operator">|</span><span class="hljs-operator">+</span><span class="hljs-comment">--------------------+</span><span class="hljs-operator">|</span> information_schema <span class="hljs-operator">|</span><span class="hljs-operator">|</span> itcast             <span class="hljs-operator">|</span><span class="hljs-operator">|</span> itcast1            <span class="hljs-operator">|</span><span class="hljs-operator">|</span> itcast2            <span class="hljs-operator">|</span><span class="hljs-operator">|</span> mysql              <span class="hljs-operator">|</span><span class="hljs-operator">|</span> performance_schema <span class="hljs-operator">|</span><span class="hljs-operator">|</span> sys                <span class="hljs-operator">|</span><span class="hljs-operator">+</span><span class="hljs-comment">--------------------+</span><span class="hljs-number">7</span> <span class="hljs-keyword">rows</span> <span class="hljs-keyword">in</span> <span class="hljs-keyword">set</span> (<span class="hljs-number">0.01</span> sec)</code></pre></div></li><li><p>显示创建数据库的语句信息</p><div class="code-wrapper"><pre><code class="hljs sql">mysql<span class="hljs-operator">&gt;</span> <span class="hljs-keyword">show</span> <span class="hljs-keyword">create</span> database itcast;<span class="hljs-operator">+</span><span class="hljs-comment">----------+-----------------------------------------------------------------+</span><span class="hljs-operator">|</span> Database <span class="hljs-operator">|</span> <span class="hljs-keyword">Create</span> Database                                              <span class="hljs-operator">|</span><span class="hljs-operator">+</span><span class="hljs-comment">----------+-----------------------------------------------------------------+</span><span class="hljs-operator">|</span> itcast   <span class="hljs-operator">|</span> <span class="hljs-keyword">CREATE</span> DATABASE `itcast` <span class="hljs-comment">/*!40100 DEFAULT CHARACTER SET utf8 */</span> <span class="hljs-operator">|</span><span class="hljs-operator">+</span><span class="hljs-comment">----------+-----------------------------------------------------------------+</span><span class="hljs-number">1</span> <span class="hljs-type">row</span> <span class="hljs-keyword">in</span> <span class="hljs-keyword">set</span> (<span class="hljs-number">0.00</span> sec)  <span class="hljs-comment">/* `itcast` 两端是反单引号, esc下的键, 使用``包含数据库的名字是区分大小写的 */</span></code></pre></div></li><li><p>使用数据库</p><div class="code-wrapper"><pre><code class="hljs sql"><span class="hljs-comment">/* 我们以root用户登录, 用户下有很多数据库, 需要指定, 当前使用哪一个数据库, 操作的就是那个数据库中的数据 */</span>mysql<span class="hljs-operator">&gt;</span> use itcast1;Database changedmysql<span class="hljs-operator">&gt;</span> use itcast2;Database changed</code></pre></div></li></ul><h3><span id="6-2-chuang-jian-shu-ju-ku">6.2创建数据库</span><a href="#6-2-chuang-jian-shu-ju-ku" class="header-anchor">#</a></h3><div class="code-wrapper"><pre><code class="hljs">-- IF NOT EXISTS 表示只有数据库不存在的时候才创建，如果存在同名就不再执行该语句-- create_specification是建库的一些选项-- 关键字不区分大小写CREATE {DATABASE} [IF NOT EXISTS] db_name  [create_specification [, create_specification] ...]</code></pre></div><ul><li><p>创建一名为itcast的数据库</p><div class="code-wrapper"><pre><code class="hljs sql">mysql<span class="hljs-operator">&gt;</span> <span class="hljs-keyword">create</span> database itheima;                          <span class="hljs-comment">/* utf8 */</span></code></pre></div></li><li><p>创建一个使用 latin1 字符集的数据库</p><div class="code-wrapper"><pre><code class="hljs sql">mysql<span class="hljs-operator">&gt;</span> <span class="hljs-keyword">create</span> database itheima <span class="hljs-type">character</span> <span class="hljs-keyword">set</span> latin1;</code></pre></div></li></ul><h3><span id="6-3-xiu-gai-shu-ju-ku">6.3修改数据库</span><a href="#6-3-xiu-gai-shu-ju-ku" class="header-anchor">#</a></h3><div class="code-wrapper"><pre><code class="hljs sql"><span class="hljs-comment">-- 修改字符集, 不能改名</span><span class="hljs-keyword">alter</span> database itcast <span class="hljs-type">character</span> <span class="hljs-keyword">set</span> utf8;</code></pre></div><h3><span id="6-4-shan-chu-shu-ju-ku">6.4删除数据库</span><a href="#6-4-shan-chu-shu-ju-ku" class="header-anchor">#</a></h3><div class="code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">drop</span> database itcast;</code></pre></div><h2><span id="7-biao-de-curd">7. 表的CURD</span><a href="#7-biao-de-curd" class="header-anchor">#</a></h2><blockquote><p>  对表本身进行操作：创建，查看，修改，删除</p></blockquote><h3><span id="7-1-cha-kan-biao">7.1 查看表</span><a href="#7-1-cha-kan-biao" class="header-anchor">#</a></h3><ul><li><p>查看当前数据库下的数据库表</p><p>  – 当前使用的数据库下的表<br>  mysql&gt; show tables;</p></li><li><p>查看指定表的创建语句</p><p>  mysql&gt; show create table 表名;</p></li><li><p>查看表结构</p><p>  mysql&gt; desc 表名;</p></li></ul><h3><span id="7-2-chuang-jian-biao">7.2创建表</span><a href="#7-2-chuang-jian-biao" class="header-anchor">#</a></h3><blockquote><p>  mysql中表名区分大小写, 列名不区分大小写</p></blockquote><ul><li>数据类型</li></ul><p><img src="https://gitee.com/txt1994/images/raw/master/img/2021/07/20180606134721859.png"><br><img src="https://gitee.com/txt1994/images/raw/master/img/2021/07/20180606134730934.png"></p><ul><li>float/double: 指定精确到小数点以后第几位, 比如: 精确到后3位</li><li>通过计算得到一个数据: 12.345678</li><li>这个数的678会被抹掉</li><li>decimal</li><li>完整的保存精度, 最少有小数后有两位</li><li>12.3 保存为: 12.30</li></ul><p><img src="https://gitee.com/txt1994/images/raw/master/img/2021/07/20180606133023230.png"><br><img src="https://gitee.com/txt1994/images/raw/master/img/2021/07/20180606133307614.png"></p><ul><li>创建表  <div class="code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">create</span> <span class="hljs-keyword">table</span> 表名(  列名 text [<span class="hljs-keyword">default</span> <span class="hljs-string">'xxx'</span>],  列名 类型 [<span class="hljs-keyword">default</span> <span class="hljs-keyword">value</span>],  类名 类型 [<span class="hljs-keyword">default</span> <span class="hljs-keyword">value</span>],  ......);</code></pre></div></li></ul><h3><span id="7-3-xiu-gai-biao">7.3修改表</span><a href="#7-3-xiu-gai-biao" class="header-anchor">#</a></h3><ul><li><p>修改表名</p>  <div class="code-wrapper"><pre><code class="hljs sql"><span class="hljs-comment">-- oracle和mysql相同</span>rename <span class="hljs-keyword">table</span> oldN <span class="hljs-keyword">to</span> newN;</code></pre></div></li><li><p>添加一个字段</p>  <div class="code-wrapper"><pre><code class="hljs sql"><span class="hljs-comment">-- oracle</span><span class="hljs-keyword">alter</span> <span class="hljs-keyword">table</span> 表名 <span class="hljs-keyword">add</span> 列名 列的类型;<span class="hljs-comment">-- mysql</span><span class="hljs-keyword">alter</span> <span class="hljs-keyword">table</span> 表名 <span class="hljs-keyword">add</span> <span class="hljs-keyword">column</span> 列名 列的类型;</code></pre></div></li><li><p>修改一个字段</p>  <div class="code-wrapper"><pre><code class="hljs sql"><span class="hljs-comment">-- oracle</span><span class="hljs-keyword">alter</span> <span class="hljs-keyword">table</span> 表名 modify 列名 列的类型;<span class="hljs-comment">-- mysql</span><span class="hljs-keyword">alter</span> <span class="hljs-keyword">table</span> 表名 modify <span class="hljs-keyword">column</span> 列名 列的类型;</code></pre></div></li><li><p>删除一个字段</p>  <div class="code-wrapper"><pre><code class="hljs sql"><span class="hljs-comment">-- mysql和oracle相同</span><span class="hljs-keyword">alter</span> <span class="hljs-keyword">table</span> 表名 <span class="hljs-keyword">drop</span> <span class="hljs-keyword">column</span> 列;<span class="hljs-comment">-- mysql中没有对对字段的rename操作</span></code></pre></div></li><li><p>修改表的字符集</p>  <div class="code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">alter</span> <span class="hljs-keyword">table</span> 表名 <span class="hljs-type">character</span> <span class="hljs-keyword">set</span> utf8;</code></pre></div></li></ul><h3><span id="7-4-shan-chu-biao">7.4 删除表</span><a href="#7-4-shan-chu-biao" class="header-anchor">#</a></h3><div class="code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">drop</span> <span class="hljs-keyword">table</span> 表名;<span class="hljs-comment">-- oracle中可以这么做, mysql中不行</span><span class="hljs-keyword">drop</span> <span class="hljs-keyword">table</span> 表名 purge</code></pre></div><h2><span id="8-biao-shu-ju-de-curd">8. 表数据的CURD</span><a href="#8-biao-shu-ju-de-curd" class="header-anchor">#</a></h2><ul><li><p>插入数据</p><ul><li>表名后的列名什么时候可以省略? </li><li>在values(列的值, 列的值, ….)中将表有的字段值都指定出来的时候, 列名可以省略  <div class="code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> 表名[(列名, 列名, ...)] <span class="hljs-keyword">values</span>(列的值, 列的值, ....);</code></pre></div></li></ul></li><li><p>更新数据</p>  <div class="code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">update</span> 表名 <span class="hljs-keyword">set</span> 列名<span class="hljs-operator">=</span>新值 <span class="hljs-keyword">where</span> 列名<span class="hljs-operator">=</span>值;</code></pre></div></li><li><p>删除数据</p>  <div class="code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">delete</span> <span class="hljs-keyword">from</span> 表名; <span class="hljs-comment">-- 删除所有行</span><span class="hljs-keyword">delete</span> <span class="hljs-keyword">from</span> 表名 <span class="hljs-keyword">where</span> 列名<span class="hljs-operator">=</span>值; <span class="hljs-comment">-- 删除满足条件的行</span></code></pre></div></li><li><p>查询数据</p>  <div class="code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span><span class="hljs-operator">|</span>列名<span class="hljs-operator">|</span>表达式 <span class="hljs-keyword">from</span> 表名 <span class="hljs-keyword">where</span> 条件 <span class="hljs-keyword">group</span> <span class="hljs-keyword">by</span> 列名 <span class="hljs-keyword">having</span> 条件 <span class="hljs-keyword">order</span> <span class="hljs-keyword">by</span> <span class="hljs-keyword">asc</span><span class="hljs-operator">|</span><span class="hljs-keyword">desc</span>;</code></pre></div></li><li><p>练习</p><ul><li>创建数据库 student 表<div class="code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">create</span> <span class="hljs-keyword">table</span> student(  id <span class="hljs-type">int</span>,  name <span class="hljs-type">varchar</span>(<span class="hljs-number">20</span>),  chinese <span class="hljs-type">int</span>,  english <span class="hljs-type">int</span>,  math <span class="hljs-type">int</span>);</code></pre></div></li><li>插入数据<div class="code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> student(id,name,chinese,english,math) <span class="hljs-keyword">values</span>(<span class="hljs-number">1</span>, <span class="hljs-string">'范建'</span>,<span class="hljs-number">80</span>,<span class="hljs-number">85</span>,<span class="hljs-number">90</span>);<span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> student(id,name,chinese,english,math) <span class="hljs-keyword">values</span>(<span class="hljs-number">2</span>,<span class="hljs-string">'罗况'</span>,<span class="hljs-number">90</span>,<span class="hljs-number">95</span>,<span class="hljs-number">95</span>);<span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> student(id,name,chinese,english,math) <span class="hljs-keyword">values</span>(<span class="hljs-number">3</span>,<span class="hljs-string">'杜子腾'</span>,<span class="hljs-number">80</span>,<span class="hljs-number">96</span>,<span class="hljs-number">96</span>);<span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> student(id,name,chinese,english,math) <span class="hljs-keyword">values</span>(<span class="hljs-number">4</span>,<span class="hljs-string">'范冰'</span>,<span class="hljs-number">81</span>,<span class="hljs-number">97</span>,<span class="hljs-number">85</span>);<span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> student(id,name,chinese,english,math) <span class="hljs-keyword">values</span>(<span class="hljs-number">5</span>,<span class="hljs-string">'申晶冰'</span>,<span class="hljs-number">85</span>,<span class="hljs-number">84</span>,<span class="hljs-number">90</span>);<span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> student(id,name,chinese,english,math) <span class="hljs-keyword">values</span>(<span class="hljs-number">6</span>,<span class="hljs-string">'郝丽海'</span>,<span class="hljs-number">92</span>,<span class="hljs-number">85</span>,<span class="hljs-number">87</span>);<span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> student(id,name,chinese,english,math) <span class="hljs-keyword">values</span>(<span class="hljs-number">7</span>,<span class="hljs-string">'郭迪辉'</span>,<span class="hljs-number">75</span>,<span class="hljs-number">81</span>,<span class="hljs-number">80</span>);<span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> student(id,name,chinese,english,math) <span class="hljs-keyword">values</span>(<span class="hljs-number">8</span>,<span class="hljs-string">'拎壶冲'</span>,<span class="hljs-number">77</span>,<span class="hljs-number">80</span>,<span class="hljs-number">79</span>);<span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> student(id,name,chinese,english,math) <span class="hljs-keyword">values</span>(<span class="hljs-number">9</span>,<span class="hljs-string">'任我行'</span>,<span class="hljs-number">95</span>,<span class="hljs-number">85</span>,<span class="hljs-number">85</span>);<span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> student(id,name,chinese,english,math) <span class="hljs-keyword">values</span>(<span class="hljs-number">10</span>,<span class="hljs-string">'史泰香'</span>,<span class="hljs-number">94</span>,<span class="hljs-number">85</span>,<span class="hljs-number">84</span>);</code></pre></div></li></ul></li></ul><blockquote><ul><li><p>查询表中所有学生的信息。</p></li><li><p>查询表中所有学生的姓名和对应的英语成绩。</p></li><li><p>将第二步查询结果中的重复成绩过滤掉。</p></li><li><p>在所有学生英语分数上加10分特长分。</p></li><li><p>统计每个学生的总分。</p></li><li><p>使用别名表示学生分数</p></li><li><p>查询姓名为何东的学生成绩</p></li><li><p>查询英语成绩大于90分的同学</p></li><li><p>查询总分大于250分的所有同学</p></li><li><p>查询英语分数在 85－95之间的同学。</p></li><li><p>查询数学分数为84,90,91的同学。</p></li><li><p>查询所有姓何的学生成绩。</p></li><li><p>查询数学分&gt;85，语文分&gt;90的同学。</p></li><li><p>对数学成绩排序后输出。</p></li><li><p>对总分排序后输出，然后再按从高到低的顺序输出</p></li><li><p>对姓何的学生成绩排序输出</p></li><li><p>统计一个班级共有多少学生？</p></li><li><p>统计数学成绩大于90的学生有多少个？</p></li><li><p>统计总分大于250的人数有多少？</p></li><li><p>统计一个班级数学总成绩？</p></li><li><p>统计一个班级语文、英语、数学各科的总成绩</p></li><li><p>统计一个班级语文、英语、数学的成绩总和</p></li><li><p>求一个班级数学平均分？</p></li><li><p>求一个班级总分平均分</p></li><li><p>求班级最高分和最低分</p></li></ul></blockquote><h2><span id="9-mysql-han-shu-de-shi-yong">9. mysql函数的使用</span><a href="#9-mysql-han-shu-de-shi-yong" class="header-anchor">#</a></h2><h3><span id="9-1-ri-qi-han-shu">9.1 日期函数</span><a href="#9-1-ri-qi-han-shu" class="header-anchor">#</a></h3><blockquote><p>MySQL里面时间分为三类：时间、日期、时间戳(含有时分秒的sysdate)。</p></blockquote><p><img src="https://gitee.com/txt1994/images/raw/master/img/2021/07/image-20191130180806388.png"></p><div class="code-wrapper"><pre><code class="hljs sql"><span class="hljs-comment">-- 当前时间: now() == sysdate()</span>mysql<span class="hljs-operator">&gt;</span> <span class="hljs-keyword">select</span> sysdate() <span class="hljs-keyword">from</span> dual;<span class="hljs-operator">+</span><span class="hljs-comment">---------------------+</span><span class="hljs-operator">|</span> sysdate()           <span class="hljs-operator">|</span><span class="hljs-operator">+</span><span class="hljs-comment">---------------------+</span><span class="hljs-operator">|</span> <span class="hljs-number">2019</span><span class="hljs-number">-12</span><span class="hljs-number">-02</span> <span class="hljs-number">09</span>:<span class="hljs-number">03</span>:<span class="hljs-number">42</span> <span class="hljs-operator">|</span><span class="hljs-operator">+</span><span class="hljs-comment">---------------------+</span><span class="hljs-number">1</span> <span class="hljs-type">row</span> <span class="hljs-keyword">in</span> <span class="hljs-keyword">set</span> (<span class="hljs-number">0.00</span> sec)mysql<span class="hljs-operator">&gt;</span> <span class="hljs-keyword">select</span> now() <span class="hljs-keyword">from</span> dual;<span class="hljs-operator">+</span><span class="hljs-comment">---------------------+</span><span class="hljs-operator">|</span> now()               <span class="hljs-operator">|</span><span class="hljs-operator">+</span><span class="hljs-comment">---------------------+</span><span class="hljs-operator">|</span> <span class="hljs-number">2019</span><span class="hljs-number">-12</span><span class="hljs-number">-02</span> <span class="hljs-number">09</span>:<span class="hljs-number">04</span>:<span class="hljs-number">35</span> <span class="hljs-operator">|</span><span class="hljs-operator">+</span><span class="hljs-comment">---------------------+</span><span class="hljs-number">1</span> <span class="hljs-type">row</span> <span class="hljs-keyword">in</span> <span class="hljs-keyword">set</span> (<span class="hljs-number">0.00</span> sec)<span class="hljs-comment">-- addtime(time, s) 给当前实际, 添加对应的秒数</span><span class="hljs-keyword">select</span> addtime(<span class="hljs-string">'09:04:35'</span>,<span class="hljs-number">20</span>) <span class="hljs-keyword">from</span> dual; <span class="hljs-operator">+</span><span class="hljs-comment">------------------------+</span><span class="hljs-operator">|</span> addtime(<span class="hljs-string">'09:04:35'</span>,<span class="hljs-number">20</span>) <span class="hljs-operator">|</span><span class="hljs-operator">+</span><span class="hljs-comment">------------------------+</span><span class="hljs-operator">|</span> <span class="hljs-number">09</span>:<span class="hljs-number">04</span>:<span class="hljs-number">55</span>               <span class="hljs-operator">|</span><span class="hljs-operator">+</span><span class="hljs-comment">------------------------+</span><span class="hljs-comment">-- 当前日期: 年, 月, 日</span>mysql<span class="hljs-operator">&gt;</span> <span class="hljs-keyword">select</span> <span class="hljs-built_in">current_date</span>() <span class="hljs-keyword">from</span> dual;<span class="hljs-operator">+</span><span class="hljs-comment">----------------+</span><span class="hljs-operator">|</span> <span class="hljs-built_in">current_date</span>() <span class="hljs-operator">|</span><span class="hljs-operator">+</span><span class="hljs-comment">----------------+</span><span class="hljs-operator">|</span> <span class="hljs-number">2019</span><span class="hljs-number">-12</span><span class="hljs-number">-02</span>     <span class="hljs-operator">|</span><span class="hljs-operator">+</span><span class="hljs-comment">----------------+</span><span class="hljs-number">1</span> <span class="hljs-type">row</span> <span class="hljs-keyword">in</span> <span class="hljs-keyword">set</span> (<span class="hljs-number">0.00</span> sec)<span class="hljs-comment">-- 当前时间: 时, 分, 秒</span>mysql<span class="hljs-operator">&gt;</span> <span class="hljs-keyword">select</span> <span class="hljs-built_in">current_time</span>() <span class="hljs-keyword">from</span> dual;    <span class="hljs-operator">+</span><span class="hljs-comment">----------------+</span><span class="hljs-operator">|</span> <span class="hljs-built_in">current_time</span>() <span class="hljs-operator">|</span><span class="hljs-operator">+</span><span class="hljs-comment">----------------+</span><span class="hljs-operator">|</span> <span class="hljs-number">09</span>:<span class="hljs-number">08</span>:<span class="hljs-number">10</span>       <span class="hljs-operator">|</span><span class="hljs-operator">+</span><span class="hljs-comment">----------------+</span><span class="hljs-number">1</span> <span class="hljs-type">row</span> <span class="hljs-keyword">in</span> <span class="hljs-keyword">set</span> (<span class="hljs-number">0.00</span> sec)<span class="hljs-comment">-- 时间戳</span>mysql<span class="hljs-operator">&gt;</span> <span class="hljs-keyword">select</span> <span class="hljs-built_in">current_timestamp</span>() <span class="hljs-keyword">from</span> dual;    <span class="hljs-operator">+</span><span class="hljs-comment">---------------------+</span><span class="hljs-operator">|</span> <span class="hljs-built_in">current_timestamp</span>() <span class="hljs-operator">|</span><span class="hljs-operator">+</span><span class="hljs-comment">---------------------+</span><span class="hljs-operator">|</span> <span class="hljs-number">2019</span><span class="hljs-number">-12</span><span class="hljs-number">-02</span> <span class="hljs-number">09</span>:<span class="hljs-number">09</span>:<span class="hljs-number">47</span> <span class="hljs-operator">|</span><span class="hljs-operator">+</span><span class="hljs-comment">---------------------+</span><span class="hljs-number">1</span> <span class="hljs-type">row</span> <span class="hljs-keyword">in</span> <span class="hljs-keyword">set</span> (<span class="hljs-number">0.00</span> sec)<span class="hljs-comment">-- 将给定时间的日期取出</span><span class="hljs-keyword">select</span> <span class="hljs-type">date</span>(now()) <span class="hljs-keyword">from</span> dual;                 <span class="hljs-operator">+</span><span class="hljs-comment">-------------+</span><span class="hljs-operator">|</span> <span class="hljs-type">date</span>(now()) <span class="hljs-operator">|</span><span class="hljs-operator">+</span><span class="hljs-comment">-------------+</span><span class="hljs-operator">|</span> <span class="hljs-number">2019</span><span class="hljs-number">-12</span><span class="hljs-number">-02</span>  <span class="hljs-operator">|</span><span class="hljs-operator">+</span><span class="hljs-comment">-------------+</span><span class="hljs-number">1</span> <span class="hljs-type">row</span> <span class="hljs-keyword">in</span> <span class="hljs-keyword">set</span> (<span class="hljs-number">0.00</span> sec)<span class="hljs-comment">-- date_add(), 第二个参数的type: 天: day, 月:month, 年: year</span>mysql<span class="hljs-operator">&gt;</span> <span class="hljs-keyword">select</span> date_add(now(), <span class="hljs-type">interval</span> <span class="hljs-number">1</span> <span class="hljs-keyword">day</span>) <span class="hljs-keyword">from</span> dual;               <span class="hljs-operator">+</span><span class="hljs-comment">---------------------------------+</span><span class="hljs-operator">|</span> date_add(now(), <span class="hljs-type">interval</span> <span class="hljs-number">1</span> <span class="hljs-keyword">day</span>) <span class="hljs-operator">|</span><span class="hljs-operator">+</span><span class="hljs-comment">---------------------------------+</span><span class="hljs-operator">|</span> <span class="hljs-number">2019</span><span class="hljs-number">-12</span><span class="hljs-number">-03</span> <span class="hljs-number">09</span>:<span class="hljs-number">14</span>:<span class="hljs-number">57</span>             <span class="hljs-operator">|</span><span class="hljs-operator">+</span><span class="hljs-comment">---------------------------------+</span><span class="hljs-number">1</span> <span class="hljs-type">row</span> <span class="hljs-keyword">in</span> <span class="hljs-keyword">set</span> (<span class="hljs-number">0.00</span> sec)mysql<span class="hljs-operator">&gt;</span> <span class="hljs-keyword">select</span> date_add(now(), <span class="hljs-type">interval</span> <span class="hljs-number">1</span> <span class="hljs-keyword">month</span>) <span class="hljs-keyword">from</span> dual;   <span class="hljs-operator">+</span><span class="hljs-comment">-----------------------------------+</span><span class="hljs-operator">|</span> date_add(now(), <span class="hljs-type">interval</span> <span class="hljs-number">1</span> <span class="hljs-keyword">month</span>) <span class="hljs-operator">|</span><span class="hljs-operator">+</span><span class="hljs-comment">-----------------------------------+</span><span class="hljs-operator">|</span> <span class="hljs-number">2020</span><span class="hljs-number">-01</span><span class="hljs-number">-02</span> <span class="hljs-number">09</span>:<span class="hljs-number">15</span>:<span class="hljs-number">27</span>               <span class="hljs-operator">|</span><span class="hljs-operator">+</span><span class="hljs-comment">-----------------------------------+</span><span class="hljs-number">1</span> <span class="hljs-type">row</span> <span class="hljs-keyword">in</span> <span class="hljs-keyword">set</span> (<span class="hljs-number">0.00</span> sec)mysql<span class="hljs-operator">&gt;</span> <span class="hljs-keyword">select</span> date_add(now(), <span class="hljs-type">interval</span> <span class="hljs-number">1</span> <span class="hljs-keyword">year</span>) <span class="hljs-keyword">from</span> dual;     <span class="hljs-operator">+</span><span class="hljs-comment">----------------------------------+</span><span class="hljs-operator">|</span> date_add(now(), <span class="hljs-type">interval</span> <span class="hljs-number">1</span> <span class="hljs-keyword">year</span>) <span class="hljs-operator">|</span><span class="hljs-operator">+</span><span class="hljs-comment">----------------------------------+</span><span class="hljs-operator">|</span> <span class="hljs-number">2020</span><span class="hljs-number">-12</span><span class="hljs-number">-02</span> <span class="hljs-number">09</span>:<span class="hljs-number">15</span>:<span class="hljs-number">37</span>              <span class="hljs-operator">|</span><span class="hljs-operator">+</span><span class="hljs-comment">----------------------------------+</span><span class="hljs-number">1</span> <span class="hljs-type">row</span> <span class="hljs-keyword">in</span> <span class="hljs-keyword">set</span> (<span class="hljs-number">0.00</span> sec)<span class="hljs-comment">-- 计算两个日期的差值</span>mysql<span class="hljs-operator">&gt;</span> <span class="hljs-keyword">select</span> datediff(<span class="hljs-string">'2019-12-01 09:18:06'</span>, <span class="hljs-string">'2019-1-02 09:18:06'</span>); <span class="hljs-operator">+</span><span class="hljs-comment">-------------------------------------------------------+</span><span class="hljs-operator">|</span> datediff(<span class="hljs-string">'2019-12-01 09:18:06'</span>, <span class="hljs-string">'2019-1-02 09:18:06'</span>) <span class="hljs-operator">|</span><span class="hljs-operator">+</span><span class="hljs-comment">-------------------------------------------------------+</span><span class="hljs-operator">|</span>                                                   <span class="hljs-number">333</span> <span class="hljs-operator">|</span><span class="hljs-operator">+</span><span class="hljs-comment">-------------------------------------------------------+</span><span class="hljs-number">1</span> <span class="hljs-type">row</span> <span class="hljs-keyword">in</span> <span class="hljs-keyword">set</span> (<span class="hljs-number">0.00</span> sec)mysql<span class="hljs-operator">&gt;</span> <span class="hljs-keyword">select</span> datediff(<span class="hljs-string">'2018-12-01 09:18:06'</span>, <span class="hljs-string">'2019-1-02 09:18:06'</span>); <span class="hljs-operator">+</span><span class="hljs-comment">-------------------------------------------------------+</span><span class="hljs-operator">|</span> datediff(<span class="hljs-string">'2018-12-01 09:18:06'</span>, <span class="hljs-string">'2019-1-02 09:18:06'</span>) <span class="hljs-operator">|</span><span class="hljs-operator">+</span><span class="hljs-comment">-------------------------------------------------------+</span><span class="hljs-operator">|</span>                                                   <span class="hljs-number">-32</span> <span class="hljs-operator">|</span><span class="hljs-operator">+</span><span class="hljs-comment">-------------------------------------------------------+</span><span class="hljs-number">1</span> <span class="hljs-type">row</span> <span class="hljs-keyword">in</span> <span class="hljs-keyword">set</span> (<span class="hljs-number">0.00</span> sec)<span class="hljs-comment">-- 单独显示当前年, 月, 日</span><span class="hljs-keyword">select</span> <span class="hljs-keyword">year</span>(now()) "年", <span class="hljs-keyword">month</span>(now()) "月", <span class="hljs-keyword">day</span>(now()) "日" <span class="hljs-keyword">from</span> dual;<span class="hljs-comment">-- 单独显示当前日期, 时间, 时间戳</span><span class="hljs-comment">-- 显示昨天, 今天, 明天</span><span class="hljs-keyword">select</span>  date_sub(now(), <span class="hljs-type">interval</span> <span class="hljs-number">1</span> <span class="hljs-keyword">day</span>), now(), date_add(now(), <span class="hljs-type">interval</span> <span class="hljs-number">1</span> <span class="hljs-keyword">day</span>) <span class="hljs-keyword">from</span> dual;</code></pre></div><h3><span id="9-2-zi-fu-chuan-han-shu">9.2 字符串函数</span><a href="#9-2-zi-fu-chuan-han-shu" class="header-anchor">#</a></h3><p><img src="https://gitee.com/txt1994/images/raw/master/img/2021/07/image-20191130182700039.png"></p><div class="code-wrapper"><pre><code class="hljs sql"><span class="hljs-comment">-- 字符串连接</span>    <span class="hljs-comment">-- mydql中可以连接多个字符串, oracle中只能连接两个字符串</span>    mysql<span class="hljs-operator">&gt;</span> <span class="hljs-keyword">select</span> concat("hello", " world", " 你好,", "世界") <span class="hljs-keyword">from</span> dual;    <span class="hljs-operator">+</span><span class="hljs-comment">-------------------------------------------------+</span>    <span class="hljs-operator">|</span> concat("hello", " world", " 你好,", "世界")     <span class="hljs-operator">|</span>    <span class="hljs-operator">+</span><span class="hljs-comment">-------------------------------------------------+</span>    <span class="hljs-operator">|</span> hello world 你好,世界                           <span class="hljs-operator">|</span>    <span class="hljs-operator">+</span><span class="hljs-comment">-------------------------------------------------+</span>    <span class="hljs-comment">-- 大小写转换</span>    mysql<span class="hljs-operator">&gt;</span> <span class="hljs-keyword">select</span> ucase("hello"), lcase("WORLD") <span class="hljs-keyword">from</span> dual;    <span class="hljs-operator">+</span><span class="hljs-comment">----------------+----------------+</span>    <span class="hljs-operator">|</span> ucase("hello") <span class="hljs-operator">|</span> lcase("WORLD") <span class="hljs-operator">|</span>    <span class="hljs-operator">+</span><span class="hljs-comment">----------------+----------------+</span>    <span class="hljs-operator">|</span> HELLO          <span class="hljs-operator">|</span> world          <span class="hljs-operator">|</span>    <span class="hljs-operator">+</span><span class="hljs-comment">----------------+----------------+</span>    <span class="hljs-number">1</span> <span class="hljs-type">row</span> <span class="hljs-keyword">in</span> <span class="hljs-keyword">set</span> (<span class="hljs-number">0.00</span> sec)    <span class="hljs-comment">-- 字符串截取, 从左侧开始</span>    mysql<span class="hljs-operator">&gt;</span> <span class="hljs-keyword">select</span> <span class="hljs-keyword">left</span>("hello,world", <span class="hljs-number">5</span>) <span class="hljs-keyword">from</span> dual;                          <span class="hljs-operator">+</span><span class="hljs-comment">------------------------+</span>    <span class="hljs-operator">|</span> <span class="hljs-keyword">left</span>("hello,world", <span class="hljs-number">5</span>) <span class="hljs-operator">|</span>    <span class="hljs-operator">+</span><span class="hljs-comment">------------------------+</span>    <span class="hljs-operator">|</span> hello                  <span class="hljs-operator">|</span>    <span class="hljs-operator">+</span><span class="hljs-comment">------------------------+</span>    <span class="hljs-number">1</span> <span class="hljs-type">row</span> <span class="hljs-keyword">in</span> <span class="hljs-keyword">set</span> (<span class="hljs-number">0.00</span> sec)        <span class="hljs-comment">-- 字符串比较</span>    mysql<span class="hljs-operator">&gt;</span> <span class="hljs-keyword">select</span> strcmp("abc", "bca") <span class="hljs-keyword">from</span> dual;    <span class="hljs-operator">+</span><span class="hljs-comment">----------------------+</span>    <span class="hljs-operator">|</span> strcmp("abc", "bca") <span class="hljs-operator">|</span>    <span class="hljs-operator">+</span><span class="hljs-comment">----------------------+</span>    <span class="hljs-operator">|</span>                   <span class="hljs-number">-1</span> <span class="hljs-operator">|</span>  <span class="hljs-comment">-- 小于</span>    <span class="hljs-operator">+</span><span class="hljs-comment">----------------------+</span>    <span class="hljs-number">1</span> <span class="hljs-type">row</span> <span class="hljs-keyword">in</span> <span class="hljs-keyword">set</span> (<span class="hljs-number">0.00</span> sec)        mysql<span class="hljs-operator">&gt;</span> <span class="hljs-keyword">select</span> strcmp("aaa", "aa") <span class="hljs-keyword">from</span> dual;         <span class="hljs-operator">+</span><span class="hljs-comment">---------------------+</span>    <span class="hljs-operator">|</span> strcmp("aaa", "aa") <span class="hljs-operator">|</span>    <span class="hljs-operator">+</span><span class="hljs-comment">---------------------+</span>    <span class="hljs-operator">|</span>                   <span class="hljs-number">1</span> <span class="hljs-operator">|</span> <span class="hljs-comment">-- 大于</span>    <span class="hljs-operator">+</span><span class="hljs-comment">---------------------+</span>    <span class="hljs-number">1</span> <span class="hljs-type">row</span> <span class="hljs-keyword">in</span> <span class="hljs-keyword">set</span> (<span class="hljs-number">0.00</span> sec)        mysql<span class="hljs-operator">&gt;</span> <span class="hljs-keyword">select</span> strcmp("aaa", "aaa") <span class="hljs-keyword">from</span> dual;    <span class="hljs-operator">+</span><span class="hljs-comment">----------------------+</span>    <span class="hljs-operator">|</span> strcmp("aaa", "aaa") <span class="hljs-operator">|</span>    <span class="hljs-operator">+</span><span class="hljs-comment">----------------------+</span>    <span class="hljs-operator">|</span>                    <span class="hljs-number">0</span> <span class="hljs-operator">|</span> <span class="hljs-comment">-- 等于</span>    <span class="hljs-operator">+</span><span class="hljs-comment">----------------------+</span>    <span class="hljs-number">1</span> <span class="hljs-type">row</span> <span class="hljs-keyword">in</span> <span class="hljs-keyword">set</span> (<span class="hljs-number">0.00</span> sec)</code></pre></div><h3><span id="9-3-shu-xue-han-shu">9.3 数学函数</span><a href="#9-3-shu-xue-han-shu" class="header-anchor">#</a></h3><p><img src="https://gitee.com/txt1994/images/raw/master/img/2021/07/image-20191130183602147.png"><br>    – 向上取整<br>    – mysql<br>    ceiling(小数)<br>    – oracle<br>    ceil(小数)</p><div class="code-wrapper"><pre><code class="hljs sql"><span class="hljs-comment">-- 进制转换</span>mysql<span class="hljs-operator">&gt;</span> <span class="hljs-keyword">select</span> conv(<span class="hljs-number">100</span>, <span class="hljs-number">10</span>, <span class="hljs-number">16</span>) <span class="hljs-keyword">from</span> dual; <span class="hljs-operator">+</span><span class="hljs-comment">-------------------+</span><span class="hljs-operator">|</span> conv(<span class="hljs-number">100</span>, <span class="hljs-number">10</span>, <span class="hljs-number">16</span>) <span class="hljs-operator">|</span><span class="hljs-operator">+</span><span class="hljs-comment">-------------------+</span><span class="hljs-operator">|</span> <span class="hljs-number">64</span>                <span class="hljs-operator">|</span><span class="hljs-operator">+</span><span class="hljs-comment">-------------------+</span><span class="hljs-comment">-- 保留指定的小数位数, 可以四舍五入</span>mysql<span class="hljs-operator">&gt;</span> <span class="hljs-keyword">select</span> format(<span class="hljs-number">12.345</span>, <span class="hljs-number">2</span>) <span class="hljs-keyword">from</span> dual;<span class="hljs-operator">+</span><span class="hljs-comment">-------------------+</span><span class="hljs-operator">|</span> format(<span class="hljs-number">12.345</span>, <span class="hljs-number">2</span>) <span class="hljs-operator">|</span><span class="hljs-operator">+</span><span class="hljs-comment">-------------------+</span><span class="hljs-operator">|</span> <span class="hljs-number">12.35</span>             <span class="hljs-operator">|</span><span class="hljs-operator">+</span><span class="hljs-comment">-------------------+</span><span class="hljs-number">1</span> <span class="hljs-type">row</span> <span class="hljs-keyword">in</span> <span class="hljs-keyword">set</span> (<span class="hljs-number">0.00</span> sec)<span class="hljs-comment">-- 取集合中的最小值</span>mysql<span class="hljs-operator">&gt;</span> <span class="hljs-keyword">select</span> least(<span class="hljs-number">12</span>, <span class="hljs-number">1</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">0</span>) <span class="hljs-keyword">from</span> dual;<span class="hljs-operator">+</span><span class="hljs-comment">-----------------------+</span><span class="hljs-operator">|</span> least(<span class="hljs-number">12</span>, <span class="hljs-number">1</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">0</span>) <span class="hljs-operator">|</span><span class="hljs-operator">+</span><span class="hljs-comment">-----------------------+</span><span class="hljs-operator">|</span>                     <span class="hljs-number">0</span> <span class="hljs-operator">|</span><span class="hljs-operator">+</span><span class="hljs-comment">-----------------------+</span><span class="hljs-number">1</span> <span class="hljs-type">row</span> <span class="hljs-keyword">in</span> <span class="hljs-keyword">set</span> (<span class="hljs-number">0.00</span> sec)<span class="hljs-comment">-- 生成随机数</span><span class="hljs-comment">-- 生成的随机数范围: 0-1</span>mysql<span class="hljs-operator">&gt;</span> <span class="hljs-keyword">select</span> rand(now()) <span class="hljs-keyword">from</span> dual;<span class="hljs-operator">+</span><span class="hljs-comment">--------------------+</span><span class="hljs-operator">|</span> rand(now())        <span class="hljs-operator">|</span><span class="hljs-operator">+</span><span class="hljs-comment">--------------------+</span><span class="hljs-operator">|</span> <span class="hljs-number">0.8633374812671333</span> <span class="hljs-operator">|</span><span class="hljs-operator">+</span><span class="hljs-comment">--------------------+</span><span class="hljs-number">1</span> <span class="hljs-type">row</span> <span class="hljs-keyword">in</span> <span class="hljs-keyword">set</span> (<span class="hljs-number">0.00</span> sec)</code></pre></div><h3><span id="9-4-ri-qi-zhuan-huan">9.4 日期转换</span><a href="#9-4-ri-qi-zhuan-huan" class="header-anchor">#</a></h3><div class="code-wrapper"><pre><code class="hljs sql"><span class="hljs-comment">-- oracle 日期格式: yyyy-mm-dd hh24:mi:ss 不区分大小写</span>to_char()  日期转字符串to_date()  字符串转日期<span class="hljs-comment">-- mysql 日期格式: %Y-%m-%d %H:%i:%s    区分大小写</span>date_format() 日期转字符串str_to_date() 字符串转日期</code></pre></div><table><thead><tr><th></th><th>值</th><th align="center">含义</th></tr></thead><tbody><tr><td>秒</td><td>%S、%s</td><td align="center">两位数字形式的秒（ 00,01, …, 59）</td></tr><tr><td>分</td><td>%i</td><td align="center">两位数字形式的分（ 00,01, …, 59）</td></tr><tr><td>小时</td><td>%H</td><td align="center">24小时制，两位数形式小时（00,01, …,23）</td></tr><tr><td></td><td>%h</td><td align="center">12小时制，两位数形式小时（00,01, …,12）</td></tr><tr><td></td><td>%k</td><td align="center">24小时制，数形式小时（0,1, …,23）</td></tr><tr><td></td><td>%l</td><td align="center">12小时制，数形式小时（0,1, …,12）</td></tr><tr><td></td><td>%T</td><td align="center">24小时制，时间形式（HH:mm:ss）</td></tr><tr><td></td><td>%r</td><td align="center">12小时制，时间形式（hh:mm:ss AM 或 PM）</td></tr><tr><td></td><td>%p</td><td align="center">AM上午或PM下午</td></tr><tr><td>周</td><td>%W</td><td align="center">一周中每一天的名称（Sunday,Monday, …,Saturday）</td></tr><tr><td></td><td>%a</td><td align="center">一周中每一天名称的缩写（Sun,Mon, …,Sat）</td></tr><tr><td></td><td>%w</td><td align="center">以数字形式标识周（0=Sunday,1=Monday, …,6=Saturday）</td></tr><tr><td></td><td>%U</td><td align="center">数字表示周数，星期天为周中第一天</td></tr><tr><td></td><td>%u</td><td align="center">数字表示周数，星期一为周中第一天</td></tr><tr><td>天</td><td>%d</td><td align="center">两位数字表示月中天数（01,02, …,31）</td></tr><tr><td></td><td>%e</td><td align="center">数字表示月中天数（1,2, …,31）</td></tr><tr><td></td><td>%D</td><td align="center">英文后缀表示月中天数（1st,2nd,3rd …）</td></tr><tr><td></td><td>%j</td><td align="center">以三位数字表示年中天数（001,002, …,366）</td></tr><tr><td></td><td>%M</td><td align="center">英文月名（January,February, …,December）</td></tr><tr><td></td><td>%b</td><td align="center">英文缩写月名（Jan,Feb, …,Dec）</td></tr><tr><td></td><td>%m</td><td align="center">两位数字表示月份（01,02, …,12）</td></tr><tr><td></td><td>%c</td><td align="center">数字表示月份（1,2, …,12）</td></tr><tr><td>年</td><td>%Y</td><td align="center">四位数字表示的年份（2015,2016…）</td></tr><tr><td></td><td>%y</td><td align="center">两位数字表示的年份（15,16…）</td></tr><tr><td>文字输出</td><td>%文字</td><td align="center">直接输出文字内容</td></tr></tbody></table><ul><li><p>date类型装换为varchar类型</p>  <div class="code-wrapper"><pre><code class="hljs sql"><span class="hljs-comment">-- date_format(日期, fmt)</span>mysql<span class="hljs-operator">&gt;</span> <span class="hljs-keyword">select</span> date_format(now(), <span class="hljs-string">'%Y/%m/%d %H:%i:%s'</span>) <span class="hljs-keyword">from</span> dual;   <span class="hljs-operator">+</span><span class="hljs-comment">-----------------------------------------+</span><span class="hljs-operator">|</span> date_format(now(), <span class="hljs-string">'%Y/%m/%d %H:%i:%s'</span>) <span class="hljs-operator">|</span><span class="hljs-operator">+</span><span class="hljs-comment">-----------------------------------------+</span><span class="hljs-operator">|</span> <span class="hljs-number">2019</span><span class="hljs-operator">/</span><span class="hljs-number">12</span><span class="hljs-operator">/</span><span class="hljs-number">02</span> <span class="hljs-number">10</span>:<span class="hljs-number">07</span>:<span class="hljs-number">37</span>                     <span class="hljs-operator">|</span><span class="hljs-operator">+</span><span class="hljs-comment">-----------------------------------------+</span></code></pre></div></li><li><p>varchar类型转换为date类型</p>  <div class="code-wrapper"><pre><code class="hljs sql"><span class="hljs-comment">-- 参数fmt的个数应该和日期字符串的形式一致</span><span class="hljs-comment">-- str_to_date(日期字符串, fmt)</span>mysql<span class="hljs-operator">&gt;</span> <span class="hljs-keyword">select</span> str_to_date("2019/12/02 10:07:37", "%Y/%m/%d %H:%i:%s") <span class="hljs-keyword">from</span> dual;  <span class="hljs-operator">+</span><span class="hljs-comment">---------------------------------------------------------+</span><span class="hljs-operator">|</span> str_to_date("2019/12/02 10:07:37", "%Y/%m/%d %H:%i:%s") <span class="hljs-operator">|</span><span class="hljs-operator">+</span><span class="hljs-comment">---------------------------------------------------------+</span><span class="hljs-operator">|</span> <span class="hljs-number">2019</span><span class="hljs-number">-12</span><span class="hljs-number">-02</span> <span class="hljs-number">10</span>:<span class="hljs-number">07</span>:<span class="hljs-number">37</span>                                     <span class="hljs-operator">|</span><span class="hljs-operator">+</span><span class="hljs-comment">---------------------------------------------------------+</span><span class="hljs-number">1</span> <span class="hljs-type">row</span> <span class="hljs-keyword">in</span> <span class="hljs-keyword">set</span> (<span class="hljs-number">0.00</span> sec)</code></pre></div></li></ul><h2><span id="10-duo-biao-cha-xun">10. 多表查询</span><a href="#10-duo-biao-cha-xun" class="header-anchor">#</a></h2><div class="code-wrapper"><pre><code class="hljs sql"><span class="hljs-comment">-- 分组函数</span><span class="hljs-built_in">count</span>(); <span class="hljs-comment">-- 求总数</span><span class="hljs-built_in">avg</span>();     <span class="hljs-comment">-- 求平均值</span><span class="hljs-built_in">sum</span>();       <span class="hljs-comment">-- 求和</span><span class="hljs-built_in">min</span>();       <span class="hljs-comment">-- 最小值</span><span class="hljs-built_in">max</span>();     <span class="hljs-comment">-- 最大值</span><span class="hljs-comment">-- having 必须出现在group by 后边, 不能写where</span><span class="hljs-comment">-- where 写在 from 的后边</span><span class="hljs-comment">-- order by: 默认升序 asc, 降序 desc</span><span class="hljs-keyword">select</span> 列名<span class="hljs-operator">|</span>表达式 <span class="hljs-keyword">as</span> "别名" <span class="hljs-keyword">from</span> 表名 "表的别名" <span class="hljs-keyword">where</span> 表达式 <span class="hljs-keyword">group</span> <span class="hljs-keyword">by</span> 列名 <span class="hljs-keyword">having</span> 条件 <span class="hljs-keyword">order</span> <span class="hljs-keyword">by</span> <span class="hljs-keyword">asc</span> <span class="hljs-operator">|</span> <span class="hljs-keyword">desc</span><span class="hljs-comment">-- 求两个表的笛卡尔积 cross join</span><span class="hljs-comment">-- 最简单的两个表查询</span><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> dept, emp;<span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> dept <span class="hljs-keyword">cross</span> <span class="hljs-keyword">join</span> emp;</code></pre></div><h3><span id="10-1-nei-lian-jie-inner-join">10.1 内连接 – inner join</span><a href="#10-1-nei-lian-jie-inner-join" class="header-anchor">#</a></h3><blockquote><p>  显示部门名称, 部门编号, 员工编号,和员工姓名</p></blockquote><div class="code-wrapper"><pre><code class="hljs sql"><span class="hljs-comment">-- mysql+oracle</span><span class="hljs-keyword">select</span> d.deptno, d.dname, e.empno, e.ename <span class="hljs-keyword">from</span> dept d, emp e <span class="hljs-keyword">where</span> d.deptno<span class="hljs-operator">=</span>e.deptno;    <span class="hljs-comment">-- mysql+oracle</span><span class="hljs-comment">-- 将表之间的逗号替换为 inner join --&gt; 简写为 join</span><span class="hljs-comment">-- 将 where 替换为 on</span><span class="hljs-keyword">select</span> d.deptno, d.dname, e.empno, e.ename <span class="hljs-keyword">from</span> dept d  <span class="hljs-keyword">join</span> emp e <span class="hljs-keyword">on</span> d.deptno<span class="hljs-operator">=</span>e.deptno;</code></pre></div><h3><span id="10-2-wai-lian-jie-outer-join">10.2 外连接 – outer join</span><a href="#10-2-wai-lian-jie-outer-join" class="header-anchor">#</a></h3><blockquote><p>  外连接: 在多表查询的时候, 要通过where进行过滤, 有些表中的字段值不满足条件, 被过滤掉了, 不会显示在最终的结果集中, 必须使用外连接的方式, 才能够使其显示在结果集中.</p><p>  按部门统计员工人数，显示如下信息：部门号，部门名称，人数(所有部门的人数都统计)</p></blockquote><ul><li><p>左外连接 – left outer join</p><div class="code-wrapper"><pre><code class="hljs sql"><span class="hljs-comment">-- oracle</span><span class="hljs-keyword">select</span> d.deptno, d.dname, <span class="hljs-built_in">count</span>(e.empno) <span class="hljs-keyword">from</span> dept d, emp e <span class="hljs-keyword">where</span> d.deptno<span class="hljs-operator">=</span>e.deptno(<span class="hljs-operator">+</span>) <span class="hljs-keyword">group</span> <span class="hljs-keyword">by</span> d.deptno, d.dname;    <span class="hljs-comment">-- mysql + oracle</span>  <span class="hljs-comment">-- 表之间的逗号替换为:   left outer join -&gt; outer 可以省略 -&gt; left join</span>  <span class="hljs-comment">-- where -&gt; on</span>  <span class="hljs-keyword">select</span> d.deptno, d.dname, <span class="hljs-built_in">count</span>(e.empno) <span class="hljs-keyword">from</span> dept d <span class="hljs-keyword">left</span> <span class="hljs-keyword">outer</span> <span class="hljs-keyword">join</span> emp e <span class="hljs-keyword">on</span> d.deptno<span class="hljs-operator">=</span>e.deptno <span class="hljs-keyword">group</span> <span class="hljs-keyword">by</span> d.deptno, d.dname;</code></pre></div></li><li><p>右外连接 – right outer join</p><div class="code-wrapper"><pre><code class="hljs sql"><span class="hljs-comment">-- oracle</span><span class="hljs-keyword">select</span> d.deptno, d.dname, <span class="hljs-built_in">count</span>(e.empno) <span class="hljs-keyword">from</span> dept d, emp e <span class="hljs-keyword">where</span> e.deptno(<span class="hljs-operator">+</span>)<span class="hljs-operator">=</span>d.deptno <span class="hljs-keyword">group</span> <span class="hljs-keyword">by</span> d.deptno, d.dname;<span class="hljs-comment">-- mysql + oracle</span><span class="hljs-comment">-- 表之间的逗号替换为:   right outer join -&gt; outer 可以省略 -&gt; right join</span><span class="hljs-comment">-- where -&gt; on</span><span class="hljs-keyword">select</span> d.deptno, d.dname, <span class="hljs-built_in">count</span>(e.empno) <span class="hljs-keyword">from</span> emp e <span class="hljs-keyword">right</span> <span class="hljs-keyword">join</span> dept d <span class="hljs-keyword">on</span> e.deptno<span class="hljs-operator">=</span>d.deptno <span class="hljs-keyword">group</span> <span class="hljs-keyword">by</span> d.deptno, d.dname;</code></pre></div></li><li><p>全外连接 – full outer join</p></li></ul><blockquote><p>  在多表查询的时候, 要通过where进行过滤, 有些表中的字段值不满足条件, 被过滤掉了, 不会显示在最终的结果集中, 不知道的那个表的字段不满足条件或者是左侧不满足条件或右侧表不满足条件, 需要将这些不满条件对数据全部显示到结果集中, 可以使用全外连接.</p><ul><li>两个表互相补充</li></ul></blockquote><div class="code-wrapper"><pre><code class="hljs sql"><span class="hljs-comment">-- 在mysql中不支持全外连接, oracle中是支持的</span>    <span class="hljs-comment">-- full outer join -&gt; 简写: full join</span><span class="hljs-comment">-- 有可能emp表给dept提供补充, 也有可能dept给emp提供补充</span><span class="hljs-keyword">select</span> d.deptno, d.dname, <span class="hljs-built_in">count</span>(e.empno) <span class="hljs-keyword">from</span> emp e <span class="hljs-keyword">full</span> <span class="hljs-keyword">join</span> dept d <span class="hljs-keyword">on</span> e.deptno<span class="hljs-operator">=</span>d.deptno <span class="hljs-keyword">group</span> <span class="hljs-keyword">by</span> d.deptno, d.dname;</code></pre></div><h3><span id="10-3-zi-lian-jie">10.3 自连接</span><a href="#10-3-zi-lian-jie" class="header-anchor">#</a></h3><blockquote><p>查询员工、老板信息，显示: xxx的老板是xxx</p></blockquote><div class="code-wrapper"><pre><code class="hljs sql"><span class="hljs-comment">-- oracle</span><span class="hljs-keyword">select</span> e.ename "员工", nvl(b.ename, <span class="hljs-string">'jump'</span>) "领导"  <span class="hljs-keyword">from</span> emp e, emp b <span class="hljs-keyword">where</span> e.mgr<span class="hljs-operator">=</span>b.empno(<span class="hljs-operator">+</span>);  <span class="hljs-comment">-- mysql</span><span class="hljs-comment">-- mysql 中的ifnull 等价于 oracle 中的 nvl</span><span class="hljs-keyword">select</span> e.ename "员工", ifnull(b.ename, <span class="hljs-string">'jump'</span>) "领导"  <span class="hljs-keyword">from</span> emp e <span class="hljs-keyword">left</span> <span class="hljs-keyword">join</span> emp b <span class="hljs-keyword">on</span> e.mgr<span class="hljs-operator">=</span>b.empno;</code></pre></div><h2><span id="11-biao-de-yue-shu">11. 表的约束</span><a href="#11-biao-de-yue-shu" class="header-anchor">#</a></h2><div class="code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">create</span> <span class="hljs-keyword">table</span> 表名(    列名 列的类型 <span class="hljs-keyword">default</span> 默认值,    列名 列的类型,    列名 列的类型);</code></pre></div><h3><span id="11-1-yue-shu-chong-lei">11.1 约束种类</span><a href="#11-1-yue-shu-chong-lei" class="header-anchor">#</a></h3><p>mysql中常用的约束有五种:</p><ul><li><p>主键约束　<strong>primary key</strong></p><ul><li>非空 + 唯一</li></ul></li><li><p>主键自动增长　<strong>auto_increment</strong></p><ul><li>给主键用的, 只有列是主键才能加这个约束</li><li>主键是数字的时候使用</li></ul></li><li><p>唯一约束　 <strong>unique</strong></p></li><li><p>非空约束　 <strong>not null</strong></p></li><li><p>外键约束　 <strong>foreign key</strong></p></li><li><p>检查约束 check (在MySQL中语法保留，但没有效果)</p></li></ul><h3><span id="11-2-yue-shu-de-shi-yong">11.2 约束的使用</span><a href="#11-2-yue-shu-de-shi-yong" class="header-anchor">#</a></h3><div class="code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">create</span> <span class="hljs-keyword">table</span> persion(    id <span class="hljs-type">int</span>,            <span class="hljs-comment">-- 主键, 自动增长</span>    age <span class="hljs-type">int</span>,            <span class="hljs-comment">-- 非空</span>    name <span class="hljs-type">varchar</span>(<span class="hljs-number">20</span>),    <span class="hljs-comment">-- 唯一</span>    deptno <span class="hljs-type">int</span>        <span class="hljs-comment">-- 外键</span>);</code></pre></div><ul><li><p>表级别的约束</p><div class="code-wrapper"><pre><code class="hljs sql"><span class="hljs-comment">-- auto_increment只能放到列的位置</span><span class="hljs-comment">-- not null 非空只能在列上添加约束</span><span class="hljs-keyword">create</span> <span class="hljs-keyword">table</span> persion(    id <span class="hljs-type">int</span> auto_increment,            <span class="hljs-comment">-- 主键, 自动增长</span>    age <span class="hljs-type">int</span> <span class="hljs-keyword">not</span> <span class="hljs-keyword">null</span>,            <span class="hljs-comment">-- 非空</span>    name <span class="hljs-type">varchar</span>(<span class="hljs-number">20</span>),    <span class="hljs-comment">-- 唯一</span>    deptno <span class="hljs-type">int</span>,        <span class="hljs-comment">-- 外键</span>    <span class="hljs-keyword">constraint</span> pk_id_xxx <span class="hljs-keyword">primary</span> key(id) ,    <span class="hljs-keyword">constraint</span> un_name_xxx <span class="hljs-keyword">unique</span>(name),    <span class="hljs-keyword">constraint</span> fk_deptno_xx <span class="hljs-keyword">foreign</span> key(deptno) <span class="hljs-keyword">references</span> dept(deptno));</code></pre></div></li><li><p>列级别的约束</p><div class="code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">create</span> <span class="hljs-keyword">table</span> persion1(    id <span class="hljs-type">int</span> <span class="hljs-keyword">primary</span> key auto_increment,            <span class="hljs-comment">-- 主键, 自动增长</span>    age <span class="hljs-type">int</span> <span class="hljs-keyword">not</span> <span class="hljs-keyword">null</span>,            <span class="hljs-comment">-- 非空</span>    name <span class="hljs-type">varchar</span>(<span class="hljs-number">20</span>) <span class="hljs-keyword">unique</span>,    <span class="hljs-comment">-- 唯一</span>    deptno <span class="hljs-type">int</span> <span class="hljs-keyword">references</span> dept(deptno)    <span class="hljs-comment">-- 外键</span>);</code></pre></div></li></ul><h2><span id="12-shi-wu">12. 事务</span><a href="#12-shi-wu" class="header-anchor">#</a></h2><blockquote><p>  在mysql中事务默认是自动提交的，oracle中默认是手动提交的。</p><ul><li>原子性</li><li>一致性</li><li>隔离性</li><li>永久性</li></ul></blockquote><div class="code-wrapper"><pre><code class="hljs sql"><span class="hljs-comment">-- 修改事务提交方式</span> <span class="hljs-comment">-- 手动提交</span>mysql<span class="hljs-operator">&gt;</span> <span class="hljs-keyword">set</span> autocommit<span class="hljs-operator">=</span><span class="hljs-number">0</span>;Query OK, <span class="hljs-number">0</span> <span class="hljs-keyword">rows</span> affected (<span class="hljs-number">0.00</span> sec) <span class="hljs-comment">-- 提交数据</span>mysql<span class="hljs-operator">&gt;</span> <span class="hljs-keyword">commit</span>;Query OK, <span class="hljs-number">0</span> <span class="hljs-keyword">rows</span> affected (<span class="hljs-number">0.00</span> sec) <span class="hljs-comment">-- 数据回滚</span>mysql<span class="hljs-operator">&gt;</span> <span class="hljs-keyword">rollback</span>;Query OK, <span class="hljs-number">0</span> <span class="hljs-keyword">rows</span> affected (<span class="hljs-number">0.00</span> sec) <span class="hljs-comment">-- 自动提交</span>mysql<span class="hljs-operator">&gt;</span> <span class="hljs-keyword">set</span> autocommit<span class="hljs-operator">=</span><span class="hljs-number">1</span>;Query OK, <span class="hljs-number">0</span> <span class="hljs-keyword">rows</span> affected (<span class="hljs-number">0.00</span> sec)</code></pre></div><h2><span id="13-mysql-api">13. mysql API</span><a href="#13-mysql-api" class="header-anchor">#</a></h2><blockquote><ol><li>初始化连接环境</li><li>连接mysql的服务器</li><li>执行sql语句</li></ol><ul><li>查询</li><li>插入</li><li>更新</li><li>删除</li><li>创建/删除/修改数据库表</li></ul><ol start="4"><li>如果是插入/删除/修改数据等操作只能看到状态</li></ol><ul><li>成功</li><li>失败</li></ul><ol start="5"><li>如果sql语句是查询, 得到结果集</li><li>遍历结果集</li><li>释放资源</li></ol></blockquote><ul><li><p>初始化连接环境</p><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-comment">// 参数: NULL</span><span class="hljs-comment">// 返回值: 返回函数申请的内存的地址</span><span class="hljs-function">MYSQL *<span class="hljs-title">mysql_init</span><span class="hljs-params">(MYSQL *mysql)</span>  </span></code></pre></div></li><li><p>连接mysql服务器</p><div class="code-wrapper"><pre><code class="hljs cpp"> <span class="hljs-comment">// 返回值: 失败-&gt; NULL, 成功了-&gt; 返回值和第一个参数的地址相同</span><span class="hljs-function">MYSQL *<span class="hljs-title">mysql_real_connect</span><span class="hljs-params">(</span></span><span class="hljs-params"><span class="hljs-function">                MYSQL *mysql,     <span class="hljs-comment">// mysql_init函数的返回值</span></span></span><span class="hljs-params"><span class="hljs-function">                <span class="hljs-comment">// 本地: localhost, 远程连接:192.168.xx.xx;</span></span></span><span class="hljs-params"><span class="hljs-function">                <span class="hljs-type">const</span> <span class="hljs-type">char</span> *host,     <span class="hljs-comment">// mysql服务器地址, IP/主机名      </span></span></span><span class="hljs-params"><span class="hljs-function">                <span class="hljs-type">const</span> <span class="hljs-type">char</span> *user,     <span class="hljs-comment">// mysql数据用户名, root       </span></span></span><span class="hljs-params"><span class="hljs-function">                <span class="hljs-type">const</span> <span class="hljs-type">char</span> *passwd,   <span class="hljs-comment">// root用户的密码</span></span></span><span class="hljs-params"><span class="hljs-function">                <span class="hljs-type">const</span> <span class="hljs-type">char</span> *db,       <span class="hljs-comment">// 数据库的名字       </span></span></span><span class="hljs-params"><span class="hljs-function">                <span class="hljs-comment">// 如果port==0, 使用默认端口, !=0是使用指定的端口</span></span></span><span class="hljs-params"><span class="hljs-function">                <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> port,    <span class="hljs-comment">// 数据库的端口, 默认3306    </span></span></span><span class="hljs-params"><span class="hljs-function">                <span class="hljs-type">const</span> <span class="hljs-type">char</span> *unix_socket,   <span class="hljs-comment">// NULL  </span></span></span><span class="hljs-params"><span class="hljs-function">                <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> client_flag  <span class="hljs-comment">// 0</span></span></span><span class="hljs-params"><span class="hljs-function">)</span></span>;</code></pre></div></li><li><p>执行sql语句</p></li></ul><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-comment">// 添删查改的sql语句都是可以执行的</span><span class="hljs-comment">// 参数:</span><span class="hljs-comment">//         mysql: mysql_real_connect()函数的返回值</span><span class="hljs-comment">//      query: sql语句, 语句的结尾不要加 ;</span><span class="hljs-comment">// 返回值: 成功-&gt; 0, 失败-&gt;非0</span><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">mysql_query</span><span class="hljs-params">(MYSQL *mysql, <span class="hljs-type">const</span> <span class="hljs-type">char</span> *query)</span></span>;</code></pre></div><ul><li><p>获取结果集</p><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-comment">// 将结果集保存到本地内存中</span><span class="hljs-comment">// 返回值: 错误-&gt;null, 成功-&gt;非空</span><span class="hljs-comment">// 参数 mysql: mysql_real_connect() 返回值</span><span class="hljs-comment">// 结果集中保存了多条记录, 每条记录中有若干个字段</span><span class="hljs-function">MYSQL_RES *<span class="hljs-title">mysql_store_result</span><span class="hljs-params">(MYSQL *mysql)</span></span>;</code></pre></div></li><li><p>得到结果集的列数</p><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> <span class="hljs-title">mysql_num_fields</span><span class="hljs-params">(MYSQL_RES *result)</span></span></code></pre></div></li><li><p>获取表头 -&gt; 列名(字段名)</p></li></ul><div class="code-wrapper"><pre><code class="hljs cpp">/ mysql.h<span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">st_mysql_field</span> {  <span class="hljs-type">char</span> *name;                 <span class="hljs-comment">/* Name of column */</span>  <span class="hljs-type">char</span> *org_name;             <span class="hljs-comment">/* Original column name, if an alias */</span>  <span class="hljs-type">char</span> *table;                <span class="hljs-comment">/* Table of column if column was a field */</span>  <span class="hljs-type">char</span> *org_table;            <span class="hljs-comment">/* Org table name, if table was an alias */</span>  <span class="hljs-type">char</span> *db;                   <span class="hljs-comment">/* Database for table */</span>  <span class="hljs-type">char</span> *catalog;          <span class="hljs-comment">/* Catalog for table */</span>  <span class="hljs-type">char</span> *def;                  <span class="hljs-comment">/* Default value (set by mysql_list_fields) */</span>  <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> length;       <span class="hljs-comment">/* Width of column (create length) */</span>  <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> max_length;   <span class="hljs-comment">/* Max width for selected set */</span>  <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> name_length;  <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> org_name_length;                                                                                          <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> table_length;  <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> org_table_length;  <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> db_length;  <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> catalog_length;  <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> def_length;  <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> flags;         <span class="hljs-comment">/* Div flags */</span>  <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> decimals;      <span class="hljs-comment">/* Number of decimals in field */</span>  <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> charsetnr;     <span class="hljs-comment">/* Character set */</span>  <span class="hljs-keyword">enum</span> <span class="hljs-title class_">enum_field_types</span> type; <span class="hljs-comment">/* Type of field. See mysql_com.h for types */</span>  <span class="hljs-type">void</span> *extension;} MYSQL_FIELD; <span class="hljs-comment">// 返回值 中保存了所有的字段名, 返回值是一个数组</span><span class="hljs-function">MYSQL_FIELD *<span class="hljs-title">mysql_fetch_fields</span><span class="hljs-params">(MYSQL_RES *result)</span></span>; MYSQL_FIELD *fields = <span class="hljs-built_in">mysql_fetch_fields</span>(result);<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>; i&lt;num; ++i){    fields[i].name}</code></pre></div><ul><li>遍历结果集</li></ul><div class="code-wrapper"><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-type">char</span>** MYSQL_ROW;<span class="hljs-comment">// 函数每调用一次, 从结果集中取出一条记录(行)</span><span class="hljs-comment">// 参数: 结果集, mysql_store_result()返回值</span><span class="hljs-comment">// 返回值: char* row[], char**执向一个指针数组, 数组中的每一个元素都是一个字符串, 字符串就是字段值</span><span class="hljs-comment">//        不管字段原来是什么类型, 结果集中都是以字符串形式保存的</span><span class="hljs-comment">// 如果还有下一行返回非空, 没有下一行, 或者失败了返回NULL</span>MYSQL_ROW <span class="hljs-title function_">mysql_fetch_row</span><span class="hljs-params">(MYSQL_RES *result)</span>;</code></pre></div><ul><li><p>资源回收</p><div class="code-wrapper"><pre><code class="hljs c"><span class="hljs-comment">// 参数是 mysql_store_result() 函数的返回值</span><span class="hljs-type">void</span> <span class="hljs-title function_">mysql_free_result</span><span class="hljs-params">(MYSQL_RES *result)</span>; <span class="hljs-comment">// 参数是: mysql_init() 函数的返回值</span><span class="hljs-type">void</span> <span class="hljs-title function_">mysql_close</span><span class="hljs-params">(MYSQL *mysql)</span>;</code></pre></div></li><li><p>字符编码</p></li></ul><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-comment">// 获取字节编码</span><span class="hljs-function"><span class="hljs-type">const</span> <span class="hljs-type">char</span> *<span class="hljs-title">mysql_character_set_name</span><span class="hljs-params">(MYSQL *mysql)</span></span>;<span class="hljs-comment">// 设置字节编码</span><span class="hljs-comment">// csname: 编码的名字, utf8</span><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">mysql_set_character_set</span><span class="hljs-params">(MYSQL *mysql, <span class="hljs-type">char</span> *csname)</span></span>;</code></pre></div><ul><li>事务操作</li></ul><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-comment">// mode==0 -&gt; 手动提交, mode1 -&gt; 自动提交事务</span><span class="hljs-function">my_bool <span class="hljs-title">mysql_autocommit</span><span class="hljs-params">(MYSQL *mysql, my_bool mode)</span></span>;<span class="hljs-function">my_bool <span class="hljs-title">mysql_commit</span><span class="hljs-params">(MYSQL *mysql)</span></span>;<span class="hljs-function">my_bool <span class="hljs-title">mysql_rollback</span><span class="hljs-params">(MYSQL *mysql)</span></span>;</code></pre></div><ul><li>打印错误信息</li></ul><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-comment">// 返回错误的描述</span><span class="hljs-function"><span class="hljs-type">const</span> <span class="hljs-type">char</span> *<span class="hljs-title">mysql_error</span><span class="hljs-params">(MYSQL *mysql)</span></span>;<span class="hljs-comment">// 返回错误的编号</span><span class="hljs-function"><span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> <span class="hljs-title">mysql_errno</span><span class="hljs-params">(MYSQL *mysql)</span></span>;</code></pre></div><ul><li>需要的头文件</li></ul><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;mysql.h&gt;</span></span> <span class="hljs-comment">// 动态库名: libmysqlclient.so</span><span class="hljs-comment">// 静态库名: libmysqlclient.a</span></code></pre></div><ul><li><p>搜索文件</p><div class="code-wrapper"><pre><code class="hljs shell">find 路径 -name 文件名locate 文件名      <span class="hljs-meta prompt_"># </span><span class="language-bash">centos</span><span class="hljs-meta prompt_"># </span><span class="language-bash">切换到root下安装</span>yum install mlocateupdatedb    # 只需要做一次, 安装完成之后做</code></pre></div></li><li><p>完整实例</p><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;mysql.h&gt;</span></span> <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>{    MYSQL *mysql = <span class="hljs-built_in">mysql_init</span>(<span class="hljs-literal">NULL</span>);    <span class="hljs-keyword">if</span> (mysql == <span class="hljs-literal">nullptr</span>)    {        <span class="hljs-built_in">printf</span>(<span class="hljs-string">"mysql_init() failed\n"</span>);        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;    }        <span class="hljs-built_in">mysql_real_connect</span>(mysql, <span class="hljs-string">"192.168.213.128"</span>, <span class="hljs-string">"root"</span>, <span class="hljs-string">"zzc123"</span>, <span class="hljs-string">"scott"</span>, <span class="hljs-number">0</span>, <span class="hljs-literal">NULL</span>, <span class="hljs-number">0</span>);    <span class="hljs-keyword">if</span> (mysql == <span class="hljs-literal">NULL</span>)    {        <span class="hljs-built_in">printf</span>(<span class="hljs-string">"mysql_real_connect() failed\n"</span>);        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;    }    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"服务器连接成功!\n"</span>);    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"原字符编码: %s\n"</span>, <span class="hljs-built_in">mysql_character_set_name</span>(mysql));    <span class="hljs-built_in">mysql_set_character_set</span>(mysql, <span class="hljs-string">"utf8"</span>);    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"现字符编码: %s\n"</span>, <span class="hljs-built_in">mysql_character_set_name</span>(mysql));        <span class="hljs-type">int</span> ret = <span class="hljs-built_in">mysql_query</span>(mysql, <span class="hljs-string">"select * from emp"</span>);        <span class="hljs-keyword">if</span> (ret != <span class="hljs-number">0</span>)    {        <span class="hljs-built_in">printf</span>(<span class="hljs-string">"mysql_query(select) failed: %s\n"</span>, <span class="hljs-built_in">mysql_error</span>(mysql));        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;    }        MYSQL_RES *res = <span class="hljs-built_in">mysql_store_result</span>(mysql);    <span class="hljs-type">int</span> colNum = <span class="hljs-built_in">mysql_num_fields</span>(res);    <span class="hljs-comment">//fields是一个结构体数组</span>    MYSQL_FIELD *fields = <span class="hljs-built_in">mysql_fetch_fields</span>(res);        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; colNum; i ++)    {        <span class="hljs-comment">//遍历结构体内名字字段</span>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%s\t"</span>, fields[i].name);    }    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"\n"</span>);        <span class="hljs-comment">//读取每一行</span>    <span class="hljs-comment">//二级指针</span>    MYSQL_ROW row;    <span class="hljs-keyword">while</span> ((row = <span class="hljs-built_in">mysql_fetch_row</span>(res)) != <span class="hljs-literal">NULL</span>)    {        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; colNum; i ++)        {            <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%s\t"</span>, row[i]);        }        <span class="hljs-built_in">printf</span>(<span class="hljs-string">"\n"</span>);    }        <span class="hljs-comment">//释放结果集</span>    <span class="hljs-built_in">mysql_free_result</span>(res);        <span class="hljs-comment">//设置事务手动提交</span>    <span class="hljs-built_in">mysql_autocommit</span>(mysql, <span class="hljs-number">0</span>);        <span class="hljs-comment">//将下面的四个操作设置为事务</span>    <span class="hljs-comment">//插入数据</span>    <span class="hljs-type">int</span> fl1 = <span class="hljs-built_in">mysql_query</span>(mysql, <span class="hljs-string">"insert into dept values(11, '海军', 'china')"</span>);    <span class="hljs-type">int</span> fl2 = <span class="hljs-built_in">mysql_query</span>(mysql, <span class="hljs-string">"insert into dept values(12, '革命军', 'china')"</span>);    <span class="hljs-type">int</span> fl3 = <span class="hljs-built_in">mysql_query</span>(mysql, <span class="hljs-string">"insert into dept values(13, '马戏团', 'china')"</span>);    <span class="hljs-comment">//更新数据</span>    <span class="hljs-type">int</span> fl4 = <span class="hljs-built_in">mysql_query</span>(mysql, <span class="hljs-string">"update dept set dname='群众' where loc='china'"</span>);        <span class="hljs-comment">//全部成功</span>    <span class="hljs-keyword">if</span> (!fl1 &amp;&amp; !fl2 &amp;&amp; !fl3 &amp;&amp; !fl4)    {        <span class="hljs-comment">//提交事务</span>        <span class="hljs-built_in">mysql_commit</span>(mysql);    }    <span class="hljs-keyword">else</span>    {        <span class="hljs-comment">//事务回滚</span>        <span class="hljs-built_in">mysql_roolback</span>(mysql);    }        <span class="hljs-comment">//释放资源</span>    <span class="hljs-built_in">mysql_close</span>(mysql);        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;}</code></pre></div></li><li><p>mysql和oracle区别</p><ul><li><p>结构不同</p><ul><li><p>msyql 基于数据库</p><ul><li>表存储在数据库中</li></ul></li><li><p>oracle 基于用户的</p><ul><li>表属于用户</li></ul></li></ul></li><li><p>mysql没有表空间, oracle有表空间</p></li><li><p>管理员</p><ul><li><p>mysql</p><ul><li>root</li></ul></li><li><p>oralce</p><ul><li>sys -&gt; 管理员, 身份 sysdba</li><li>system -&gt; 管理员, 登录的时候需要使用normal身份登录</li><li>其他的普通用户</li></ul></li></ul></li><li><p>事务</p><ul><li><p>oracle默认手动提交</p><ul><li>occi接口 (C++接口), 这个接口中是自动提交事务的</li></ul></li><li><p>mysql中默认是自动提交</p></li></ul></li><li><p>sql语句</p><ul><li><p>外连接</p><ul><li>oralce中可以使用 (+)</li><li>mysql中必须使用 , 不支持(+)<ul><li>right outer join -&gt; oracle也支持这种写法</li><li>left outer join</li></ul></li><li>mysql不支持全外连接, oracle支持的<ul><li>full outer join</li></ul></li></ul></li></ul></li><li><p>函数:</p><ul><li><p>nvl -&gt; oralce</p></li><li><p>ifnull -&gt; mysql</p></li><li><p>日期</p></li><li><p>字符串</p></li><li><p>数学函数</p></li></ul></li><li><p>建表的时候的约束指定</p><ul><li><p>都有:</p><ul><li>主键 -&gt; primary key</li><li>非空: not null</li><li>唯一性: unique</li><li>外键约束: foreign key</li></ul></li><li><p>不同:</p><ul><li>oralce:<ul><li>check, 在mysql中也有, 但是不起作用</li></ul></li><li>mysql<ul><li><p>主键自动增长: auto_increment</p><ul><li>需要和主键约束一起使用</li></ul></li></ul></li></ul></li></ul></li><li><p>删除表</p><ul><li><p>oracle</p><ul><li>drop talbe 表名 purge;</li></ul></li><li><p>msyql</p><ul><li>drop talbe 表名; –&gt; 不能使用 purge</li></ul></li></ul></li><li><p>字段的修改</p><ul><li><p>oralce</p><ul><li>列的添加<div class="code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">alter</span> <span class="hljs-keyword">table</span> 表名 <span class="hljs-keyword">add</span> 列名 列的属性;<span class="hljs-keyword">alter</span> <span class="hljs-keyword">table</span> 表名 modify 列名 列的属性;</code></pre></div></li></ul></li><li><p>mysql</p><ul><li>列的添加修改<div class="code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">alter</span> <span class="hljs-keyword">table</span> 表名 <span class="hljs-keyword">add</span> <span class="hljs-keyword">column</span> 列名 列的属性;<span class="hljs-keyword">alter</span> <span class="hljs-keyword">table</span> 表名 modify <span class="hljs-keyword">column</span> 列名 列的属性;</code></pre></div></li></ul></li></ul></li></ul></li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>DataBase</tag>
      
      <tag>Mysql</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Json的使用</title>
    <link href="/2022/01/04/Json%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
    <url>/2022/01/04/Json%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<div class="toc"><!-- toc --><ul><li><a href="#json-xia-zai">json下载</a></li><li><a href="#bian-yi-json-jing-tai-ku">编译 json静态库</a></li><li><a href="#shi-yong-json">使用 json</a></li><li><a href="#jie-xi-json5">解析 Json5</a></li><li><a href="#sheng-cheng">生成</a></li></ul><!-- tocstop --></div><p><a href="https://baike.baidu.com/item/JSON/2462549">百度百科</a><br><a href="https://baike.baidu.com/item/JSON">JSON</a>(<a href="https://baike.baidu.com/item/JavaScript">JavaScript</a> Object Notation, JS 对象简谱) 是一种轻量级的数据交换格式。它基于 <a href="https://baike.baidu.com/item/ECMAScript">ECMAScript</a> (欧洲计算机协会制定的js规范)的一个子集，<strong>采用完全独立于编程语言的文本格式来存储和表示数据</strong>。简洁和清晰的层次结构使得 JSON 成为理想的数据交换语言。 易于人阅读和编写，同时也易于机器解析和生成，并有效地提升网络传输效率。</p><p>本文采用<a href="https://github.com/MistEO"><img src="https://avatars.githubusercontent.com/u/18511905?s=48&amp;v=4" alt="@MistEO"></a></p><p><a href="https://github.com/MistEO/meojson/commits?author=MistEO">MistEO</a>哥哥写的项目。</p><p>他写两个很棒的项目</p><p>Json:<a href="https://github.com/MistEO/meojson">MistEO/meojson: A fast and easy-to-use JSON parser/generator for C++ (github.com)</a></p><p>明日方舟助手：<a href="https://github.com/MistEO/MeoAssistantArknights">MistEO/MeoAssistantArknights: 明日方舟助手，自动刷图、智能基建换班，全日常一键长草！ (github.com)</a></p><p>他的博客<a href="https://www.misteo.top/">肝！ (misteo.top)</a>，不过是鸽王。</p><p>好了开始正题了</p><h3><span id="json-xia-zai">json下载</span><a href="#json-xia-zai" class="header-anchor">#</a></h3><p>下载<code>玛丽</code>写的Json项目<a href="https://github.com/MistEO/meojson">MistEO:Json</a></p><div class="code-wrapper"><pre><code class="hljs shell">git clone https://github.com.cnpmjs.org/MistEO/meojson.git</code></pre></div><h3><span id="bian-yi-json-jing-tai-ku">编译 json静态库</span><a href="#bian-yi-json-jing-tai-ku" class="header-anchor">#</a></h3><div class="code-wrapper"><pre><code class="hljs shell">make</code></pre></div><p>运行命令后会在<code>build</code>文件夹生成<code>libmeojson.a</code>,然后就在项目中可以使用了</p><ul><li>在代码中添加头文件</li></ul><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">"json.h"</span></span></code></pre></div><ul><li>若您需要解析 Json5, 则请包含 json5.hpp 头文件<div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">"json5.hpp"</span></span></code></pre></div></li><li>meojson 仅依赖 STL, 但需要 c++17 标准</li></ul><h3><span id="shi-yong-json">使用 json</span><a href="#shi-yong-json" class="header-anchor">#</a></h3><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-comment">/***</span><span class="hljs-comment"> * from sample/sample.cpp</span><span class="hljs-comment">***/</span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">"json.hpp"</span></span><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">parsing</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>{    std::string content = <span class="hljs-string">R"(</span><span class="hljs-string">    {</span><span class="hljs-string">        "repo": "meojson",</span><span class="hljs-string">        "author": {</span><span class="hljs-string">            "MistEO": "https://github.com/MistEO",</span><span class="hljs-string">            "ChingCdesu": "https://github.com/ChingCdesu"</span><span class="hljs-string">        },</span><span class="hljs-string">        "list": [</span><span class="hljs-string">            1, 2, 3</span><span class="hljs-string">        ],</span><span class="hljs-string">        "str": "abc",</span><span class="hljs-string">        "num": 3.1416</span><span class="hljs-string">    }</span><span class="hljs-string">    )"</span>;    <span class="hljs-keyword">auto</span> ret = json::<span class="hljs-built_in">parse</span>(content);    <span class="hljs-keyword">if</span> (!ret) {        std::cerr &lt;&lt; <span class="hljs-string">"Parsing failed"</span> &lt;&lt; std::endl;        <span class="hljs-keyword">return</span>;    }    <span class="hljs-keyword">auto</span> value = ret.<span class="hljs-built_in">value</span>();  <span class="hljs-comment">// As also, you can use rvalues, like</span>                               <span class="hljs-comment">// `auto value = std::move(ret).value();`</span>    <span class="hljs-comment">// Output: meojson</span>    std::cout &lt;&lt; value[<span class="hljs-string">"repo"</span>].<span class="hljs-built_in">as_string</span>() &lt;&lt; std::endl;    <span class="hljs-comment">/* Output:</span><span class="hljs-comment">        ChingCdesu 's homepage: https://github.com/ChingCdesu</span><span class="hljs-comment">        MistEO 's homepage: https://github.com/MistEO</span><span class="hljs-comment">    */</span>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span>&amp;&amp; [name, homepage] : value[<span class="hljs-string">"author"</span>].<span class="hljs-built_in">as_object</span>()) {        std::cout &lt;&lt; name &lt;&lt; <span class="hljs-string">" 's homepage: "</span> &lt;&lt; homepage.<span class="hljs-built_in">as_string</span>() &lt;&lt; std::endl;    }    <span class="hljs-comment">// Output: abc</span>    std::string str = (std::string)value[<span class="hljs-string">"str"</span>];    <span class="hljs-comment">// As also, you can use `value["str"].as_string()`</span>    std::cout &lt;&lt; str &lt;&lt; std::endl;    <span class="hljs-comment">// Output: 3.141600</span>    <span class="hljs-type">double</span> num = value[<span class="hljs-string">"num"</span>].<span class="hljs-built_in">as_double</span>();          <span class="hljs-comment">// As also, you can use `(double)value["num"]`</span>    std::cout &lt;&lt; num &lt;&lt; std::endl;    <span class="hljs-comment">// Output: not found</span>    std::string str_get = value.<span class="hljs-built_in">get</span>(<span class="hljs-string">"maybe_exists"</span>, <span class="hljs-string">"not found"</span>);    std::cout &lt;&lt; str_get &lt;&lt; std::endl;    <span class="hljs-comment">/*  Output:</span><span class="hljs-comment">        1</span><span class="hljs-comment">        2</span><span class="hljs-comment">        3</span><span class="hljs-comment">    */</span>    <span class="hljs-comment">// It's const!</span>    <span class="hljs-keyword">for</span> (<span class="hljs-type">const</span> <span class="hljs-keyword">auto</span>&amp; ele : value.<span class="hljs-built_in">at</span>(<span class="hljs-string">"list"</span>).<span class="hljs-built_in">as_array</span>()) {        <span class="hljs-type">int</span> x = (<span class="hljs-type">int</span>)ele;        std::cout &lt;&lt; x &lt;&lt; std::endl;    }}</code></pre></div><h3><span id="jie-xi-json5">解析 Json5</span><a href="#jie-xi-json5" class="header-anchor">#</a></h3><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-comment">/***</span><span class="hljs-comment"> * from sample/json5_parse.cpp</span><span class="hljs-comment">***/</span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">"json5.hpp"</span></span><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">parsing</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>{    std::string content = <span class="hljs-string">R"(</span><span class="hljs-string">// 这是一段json5格式的信息</span><span class="hljs-string">{</span><span class="hljs-string">  名字: "MistEO",                  /* key的引号可省略 */</span><span class="hljs-string">  😊: '😄',                       // emoji为key</span><span class="hljs-string">  thanks: 'ありがとう',             /* 单引号也可以表示字符串 */</span><span class="hljs-string">  \u006Bey: ['value',],            // 普通字符和转义可以混用</span><span class="hljs-string">  inf: +Infinity, nan: NaN,        // 数字可以以"+"开头</span><span class="hljs-string">  fractional: .3, integer: 42.,    // 小数点作为起始/结尾</span><span class="hljs-string">  byte_max: 0xff,                  // 十六进制数</span><span class="hljs-string">  light_speed: +3e8,               // 科学计数法</span><span class="hljs-string">}</span><span class="hljs-string">)"</span>;    <span class="hljs-keyword">auto</span> ret = json::<span class="hljs-built_in">parse5</span>(content);    <span class="hljs-keyword">if</span> (!ret) {        std::cerr &lt;&lt; <span class="hljs-string">"Parsing failed"</span> &lt;&lt; std::endl;        <span class="hljs-keyword">return</span>;    }    <span class="hljs-keyword">auto</span> value = ret.<span class="hljs-built_in">value</span>();  <span class="hljs-comment">// As also, you can use rvalues, like</span>                               <span class="hljs-comment">// `auto value = std::move(ret).value();`</span>    <span class="hljs-comment">// Output: MistEO</span>    std::cout &lt;&lt; value[<span class="hljs-string">"名字"</span>] &lt;&lt; std::endl;    <span class="hljs-comment">// Output: value</span>    std::string str = (std::string)value[<span class="hljs-string">"key"</span>][<span class="hljs-number">0</span>];    std::cout &lt;&lt; str &lt;&lt; std::endl;        <span class="hljs-comment">// for more json::value usage, please refer to sample.cpp</span>}</code></pre></div><h3><span id="sheng-cheng">生成</span><a href="#sheng-cheng" class="header-anchor">#</a></h3><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-comment">/***</span><span class="hljs-comment"> * from sample/sample.cpp</span><span class="hljs-comment">***/</span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">"json.hpp"</span></span><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">generating</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>{    json::value root;    root[<span class="hljs-string">"hello"</span>] = <span class="hljs-string">"meojson"</span>;    root[<span class="hljs-string">"Pi"</span>] = <span class="hljs-number">3.1416</span>;    root[<span class="hljs-string">"arr"</span>] = json::array{        <span class="hljs-string">"a"</span>, <span class="hljs-string">"b"</span>, <span class="hljs-string">"c"</span>    };    root[<span class="hljs-string">"obj"</span>] = json::object{        {<span class="hljs-string">"obj_key1"</span>, <span class="hljs-string">"aaa"</span>},        {<span class="hljs-string">"obj_key2"</span>, <span class="hljs-number">123</span>},        {<span class="hljs-string">"obj_key3"</span>, <span class="hljs-literal">true</span>}    };    root[<span class="hljs-string">"obj"</span>].<span class="hljs-built_in">object_emplace</span>(<span class="hljs-string">"key4"</span>, json::object{ { <span class="hljs-string">"key4 child"</span>, <span class="hljs-string">"lol"</span> } });    root[<span class="hljs-string">"obj_another"</span>][<span class="hljs-string">"child"</span>][<span class="hljs-string">"grand"</span>] = <span class="hljs-string">"i am grand"</span>;    std::vector&lt;<span class="hljs-type">int</span>&gt; vec = { <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span> };    root[<span class="hljs-string">"arr from vec"</span>] = json::<span class="hljs-built_in">array</span>(vec);    root[<span class="hljs-string">"arr from vec"</span>].<span class="hljs-built_in">array_emplace</span>(<span class="hljs-number">6</span>);        std::set&lt;std::string&gt; set = { <span class="hljs-string">"a"</span>, <span class="hljs-string">"bbb"</span>, <span class="hljs-string">"cc"</span> };    root[<span class="hljs-string">"arr from set"</span>] = json::<span class="hljs-built_in">array</span>(set);    std::map&lt;std::string, <span class="hljs-type">int</span>&gt; map;    map.<span class="hljs-built_in">emplace</span>(<span class="hljs-string">"key1"</span>, <span class="hljs-number">1</span>);    map.<span class="hljs-built_in">emplace</span>(<span class="hljs-string">"key2"</span>, <span class="hljs-number">2</span>);    root[<span class="hljs-string">"obj from map"</span>] = json::<span class="hljs-built_in">object</span>(map);    std::cout &lt;&lt; root.format() &lt;&lt; std::endl;}</code></pre></div>]]></content>
    
    
    
    <tags>
      
      <tag>C++</tag>
      
      <tag>Json</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Visual_Studio_2022添加第三方库</title>
    <link href="/2022/01/04/Visual-Studio-2022%E6%B7%BB%E5%8A%A0%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/"/>
    <url>/2022/01/04/Visual-Studio-2022%E6%B7%BB%E5%8A%A0%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/</url>
    
    <content type="html"><![CDATA[<div class="toc"><!-- toc --><ul><li><a href="#wen-jian-jia-chuang-jian">文件夹创建</a></li><li><a href="#xiang-mu-tou-wen-jian-tian-jia">项目头文件添加</a></li><li><a href="#xiang-mu-ku-wen-jian-tian-jia">项目库文件添加</a></li></ul><!-- tocstop --></div><h1><span id="wen-jian-jia-chuang-jian">文件夹创建</span><a href="#wen-jian-jia-chuang-jian" class="header-anchor">#</a></h1><ol><li>在项目根目录创建<code>Dependencies</code>,然后在<code>Dependencies</code>创建<code>include</code>目录<br>  <img src="https://gitee.com/txt1994/images/raw/master/img/Visual_Studio/explorer_dZv7Sj1zKv.png"></li><li>在<code>Dependencies</code>中创建Libs</li></ol><p><img src="https://gitee.com/txt1994/images/raw/master/img/Visual_Studio/explorer_OfVTAKdKwG.png"></p><p>把头文件和库文件放到对目录</p><h1><span id="xiang-mu-tou-wen-jian-tian-jia">项目头文件添加</span><a href="#xiang-mu-tou-wen-jian-tian-jia" class="header-anchor">#</a></h1><ol><li>然后用Visual Studio打开项目，找到<br>  <img src="https://gitee.com/txt1994/images/raw/master/img/Visual_Studio/devenv_m2Hpr9hqkF.png"></li></ol><p>红色圈中的功能条</p><p>再点击最下边的属性</p><p><img src="https://gitee.com/txt1994/images/raw/master/img/Visual_Studio/mia3Eg3WRZ.png"></p><p>定位到常规，然后再编辑附加包含目录，添加一条新item为<code>$(SolutionDir)Dependencies\include\</code></p><p><img src="https://gitee.com/txt1994/images/raw/master/img/Visual_Studio/devenv_4dDWoNrKwt.png"></p><p>其中 <code>$(SolutionDir)</code>为项目根目录，<code>Dependencies\include\</code>为头文件目录</p><p>至此第三方库的头文件已经添加完成</p><h1><span id="xiang-mu-ku-wen-jian-tian-jia">项目库文件添加</span><a href="#xiang-mu-ku-wen-jian-tian-jia" class="header-anchor">#</a></h1><p><img src="https://gitee.com/txt1994/images/raw/master/img/Visual_Studio/devenv_dX8CZIf3KK.png"></p><p>点击链接器，常规，附加库目录，添加一条<code>$(SolutionDir)Dependencies\Libs\GLFW</code>,</p><p><img src="https://gitee.com/txt1994/images/raw/master/img/Visual_Studio/devenv_R78BVre94f.png"></p><p>然后点击输入，附加依赖项，写入要使用的库文件名，点击确定，第三方库已被添加到项目中</p><p>End.</p>]]></content>
    
    
    
    <tags>
      
      <tag>C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Cmake的安装与CMakeLists.txt的编写</title>
    <link href="/2022/01/03/Cmake%E7%9A%84%E5%AE%89%E8%A3%85%E4%B8%8ECMakeLists-txt%E7%9A%84%E7%BC%96%E5%86%99/"/>
    <url>/2022/01/03/Cmake%E7%9A%84%E5%AE%89%E8%A3%85%E4%B8%8ECMakeLists-txt%E7%9A%84%E7%BC%96%E5%86%99/</url>
    
    <content type="html"><![CDATA[<div class="toc"><!-- toc --><ul><li><a href="#an-zhuang">安装</a></li><li><a href="#bian-xie-cmakelists-txt">编写CMakeLists.txt</a><ul><li><a href="#dan-wen-jian-dan-mu-lu-cmakelists-txt-bian-xie"><code>单文件单目录CMakeLists.txt编写</code></a></li><li><a href="#duo-wen-jian-dan-mu-lu-cmakelists-txt-bian-xie"><code>多文件单目录CMakeLists.txt编写</code></a></li><li><a href="#duo-wen-jian-duo-wen-jian-jia-cmakelists-txt-bian-xie"><code>多文件多文件夹CMakeLists.txt编写</code></a></li><li><a href="#ku-wen-jian-cmakelists-txt-bian-xie"><code>库文件CMakeLists.txt编写</code></a></li><li><a href="#ku-wen-jian-an-zhuang-cmakelists-txt-bian-xie"><code>库文件安装CMakeLists.txt编写</code></a></li><li><a href="#ku-wen-jian-zhi-ding-shu-chu-lu-jing-yu-bian-yi-hou-de-gong-cheng-mu-lu"><code>库文件指定输出路径与编译后的工程目录</code></a></li></ul></li></ul><!-- tocstop --></div><h1><span id="an-zhuang">安装</span><a href="#an-zhuang" class="header-anchor">#</a></h1><p>cmake是自动化项目编译工具，可以编译<a href="https://baike.baidu.com/item/%E6%BA%90%E4%BB%A3%E7%A0%81">源代码</a>、制作程序库、产生<a href="https://baike.baidu.com/item/%E9%80%82%E9%85%8D%E5%99%A8/908851">适配器</a>（wrapper）、还可以用任意的顺序建构<a href="https://baike.baidu.com/item/%E6%89%A7%E8%A1%8C%E6%A1%A3">执行档</a>。CMake 支持 in-place 建构（二进档和源代码在同一个目录树中）和 out-of-place 建构（二进档在别的目录里），因此可以很容易从同一个源代码目录树中建构出多个二进档。CMake 也支持静态与动态<a href="https://baike.baidu.com/item/%E7%A8%8B%E5%BC%8F%E5%BA%93/9957874">程式库</a>的建构。</p><p>下载地址👉<a href="https://cmake.org/download/">Download | CMake</a>， 建议二进制安装。</p><p>win:</p><div class="code-wrapper"><pre><code class="hljs shell">https://github.com/Kitware/CMake/releases/download/v3.22.1/cmake-3.22.1-windows-x86_64.zip</code></pre></div><p>ubuntu:</p><div class="code-wrapper"><pre><code class="hljs shell">sudo apt install cmake</code></pre></div><div class="code-wrapper"><pre><code class="hljs shell">wget https://github.com/Kitware/CMake/releases/download/v3.22.1/cmake-3.22.1-linux-x86_64.tar.gz</code></pre></div><p>centos:</p><div class="code-wrapper"><pre><code class="hljs shell">sudo yum install cmake</code></pre></div><p>arch:</p><div class="code-wrapper"><pre><code class="hljs shell">sudo pacman -S cmake</code></pre></div><h1><span id="bian-xie-cmakelists-txt">编写CMakeLists.txt</span><a href="#bian-xie-cmakelists-txt" class="header-anchor">#</a></h1><h2><span id="dan-wen-jian-dan-mu-lu-cmakelists-txt-bian-xie"><code>单文件单目录CMakeLists.txt编写</code></span><a href="#dan-wen-jian-dan-mu-lu-cmakelists-txt-bian-xie" class="header-anchor">#</a></h2><div class="code-wrapper"><pre><code class="hljs cmake"><span class="hljs-comment"># 指定cmake版本</span><span class="hljs-keyword">cmake_minimum_required</span>(VERSION <span class="hljs-number">3.22</span>)<span class="hljs-comment"># 工程名</span><span class="hljs-keyword">project</span>(demo1)<span class="hljs-comment"># 指定编译后文件名</span><span class="hljs-keyword">set</span>(OUTPUTNAME demo1)<span class="hljs-keyword">set</span>(CMAKE_CXX_FLAGS <span class="hljs-string">"${CMAKE_CXX_FLAGS} -Wall -g -O2 -std=c++20"</span>) <span class="hljs-comment"># 指定编译参数</span><span class="hljs-comment"># 指定源文件夹</span><span class="hljs-keyword">aux_source_directory</span>(. DIR_SRCS)<span class="hljs-comment"># 编译文件</span><span class="hljs-keyword">add_executable</span>(<span class="hljs-variable">${OUTPUTNAME}</span> <span class="hljs-variable">${DIR_SRCS}</span>)</code></pre></div><p>此文件加编写完毕后，创建一个build文件夹，cd进去，执行<code>cmake ..</code>，会生成Makefile文件，再然后执行<code>make</code>编译，最终生成项目文件。</p><h2><span id="duo-wen-jian-dan-mu-lu-cmakelists-txt-bian-xie"><code>多文件单目录CMakeLists.txt编写</code></span><a href="#duo-wen-jian-dan-mu-lu-cmakelists-txt-bian-xie" class="header-anchor">#</a></h2><p>和demo1相同</p><div class="code-wrapper"><pre><code class="hljs cmake"><span class="hljs-comment"># 指定cmake版本</span><span class="hljs-keyword">cmake_minimum_required</span>(VERSION <span class="hljs-number">3.22</span>)<span class="hljs-comment"># 工程名</span><span class="hljs-keyword">project</span>(demo2)<span class="hljs-comment"># 指定编译后文件名</span><span class="hljs-keyword">set</span>(OUTPUTNAME demo2)<span class="hljs-keyword">set</span>(CMAKE_CXX_FLAGS <span class="hljs-string">"${CMAKE_CXX_FLAGS} -Wall -g -O2 -std=c++20"</span>) <span class="hljs-comment"># 指定编译参数</span><span class="hljs-comment"># 指定源文件夹</span><span class="hljs-keyword">aux_source_directory</span>(. DIR_SRCS)<span class="hljs-comment"># 编译文件</span><span class="hljs-keyword">add_executable</span>(<span class="hljs-variable">${OUTPUTNAME}</span> <span class="hljs-variable">${DIR_SRCS}</span>)</code></pre></div><h2><span id="duo-wen-jian-duo-wen-jian-jia-cmakelists-txt-bian-xie"><code>多文件多文件夹CMakeLists.txt编写</code></span><a href="#duo-wen-jian-duo-wen-jian-jia-cmakelists-txt-bian-xie" class="header-anchor">#</a></h2><p>每一个项目都要建一个CMakeLists.txt，并且每一个文件夹都要有一个CMakeLists.txt文件</p><p><strong>项目根目录的CMakeLists.txt</strong></p><div class="code-wrapper"><pre><code class="hljs cmake"><span class="hljs-comment"># 指定cmake版本</span><span class="hljs-keyword">cmake_minimum_required</span> (VERSION <span class="hljs-number">3.22</span>)<span class="hljs-comment"># 项目信息</span><span class="hljs-keyword">project</span> (Demo3)<span class="hljs-comment"># 指定编译后文件名</span><span class="hljs-keyword">set</span>(OUTPUTNAME demo3)<span class="hljs-keyword">set</span>(CMAKE_CXX_FLAGS <span class="hljs-string">"${CMAKE_CXX_FLAGS} -Wall -g -O2 -std=c++20"</span>) <span class="hljs-comment"># 指定编译参数</span><span class="hljs-comment"># 查找当前目录下的所有源文件</span><span class="hljs-comment"># 并将名称保存到 DIR_SRCS 变量</span><span class="hljs-keyword">aux_source_directory</span>(. DIR_SRCS)<span class="hljs-comment"># 添加 math 子目录</span><span class="hljs-keyword">add_subdirectory</span>(<span class="hljs-keyword">math</span>)<span class="hljs-comment"># 指定生成目标 </span><span class="hljs-keyword">add_executable</span>(<span class="hljs-variable">${OUTPUTNAME}</span> <span class="hljs-variable">${DIR_SRCS}</span>)<span class="hljs-comment"># 添加链接库</span><span class="hljs-keyword">target_link_libraries</span>(<span class="hljs-variable">${OUTPUTNAME}</span> MathFunctions)</code></pre></div><p><strong>项目其他目录的CMakeLists.txt</strong></p><div class="code-wrapper"><pre><code class="hljs cmake"><span class="hljs-comment"># 查找当前目录下的所有源文件</span><span class="hljs-comment"># 并将名称保存到 DIR_LIB_SRCS 变量</span><span class="hljs-keyword">aux_source_directory</span>(. DIR_LIB_SRCS)<span class="hljs-comment"># 生成链接库,动态库</span><span class="hljs-comment"># 静态库add_library (MathFunctions STATIC ${DIR_LIB_SRCS})</span><span class="hljs-keyword">add_library</span> (MathFunctions SHARED <span class="hljs-variable">${DIR_LIB_SRCS}</span>)</code></pre></div><h2><span id="ku-wen-jian-cmakelists-txt-bian-xie"><code>库文件CMakeLists.txt编写</code></span><a href="#ku-wen-jian-cmakelists-txt-bian-xie" class="header-anchor">#</a></h2><div class="code-wrapper"><pre><code class="hljs cmake"><span class="hljs-comment"># 查找当前目录下的所有源文件</span><span class="hljs-comment"># 并将名称保存到 DIR_LIB_SRCS 变量</span><span class="hljs-keyword">aux_source_directory</span>(. DIR_LIB_SRCS)<span class="hljs-comment"># 生成链接库,动态库</span><span class="hljs-comment"># 静态库add_library (MathFunctions STATIC ${DIR_LIB_SRCS})</span><span class="hljs-keyword">add_library</span> (MathFunctions SHARED <span class="hljs-variable">${DIR_LIB_SRCS}</span>)</code></pre></div><h2><span id="ku-wen-jian-an-zhuang-cmakelists-txt-bian-xie"><code>库文件安装CMakeLists.txt编写</code></span><a href="#ku-wen-jian-an-zhuang-cmakelists-txt-bian-xie" class="header-anchor">#</a></h2><p>在指定的库源文件目录添加：</p><div class="code-wrapper"><pre><code class="hljs cmake"><span class="hljs-comment"># 指定 MathFunctions 库的安装路径</span><span class="hljs-keyword">install</span> (TARGETS MathFunctions DESTINATION bin)<span class="hljs-keyword">install</span> (FILES MathFunctions.h DESTINATION <span class="hljs-keyword">include</span>)</code></pre></div><p>demo会被放到bin，<code>*.h</code>会被放到<code>/usr/local/include</code></p><div class="code-wrapper"><pre><code class="hljs cmake"><span class="hljs-comment"># 指定安装路径</span><span class="hljs-keyword">install</span> (TARGETS Demo DESTINATION bin)<span class="hljs-keyword">install</span> (FILES <span class="hljs-string">"${PROJECT_BINARY_DIR}/config.h"</span>         DESTINATION <span class="hljs-keyword">include</span>)</code></pre></div><h2><span id="ku-wen-jian-zhi-ding-shu-chu-lu-jing-yu-bian-yi-hou-de-gong-cheng-mu-lu"><code>库文件指定输出路径与编译后的工程目录</code></span><a href="#ku-wen-jian-zhi-ding-shu-chu-lu-jing-yu-bian-yi-hou-de-gong-cheng-mu-lu" class="header-anchor">#</a></h2><p>库文件输出目录设置</p><div class="code-wrapper"><pre><code class="hljs cmake"><span class="hljs-comment"># 查找当前目录下的所有源文件</span><span class="hljs-comment"># 并将名称保存到 DIR_LIB_SRCS 变量</span><span class="hljs-keyword">aux_source_directory</span>(. DIR_LIB_SRCS)<span class="hljs-comment"># 把库文件的输出路径设置为lib</span><span class="hljs-keyword">set</span>(LIBRARY_OUTPUT_PATH <span class="hljs-variable">${PROJECT_BINARY_DIR}</span>/lib)<span class="hljs-comment"># 生成链接库,动态库</span><span class="hljs-comment"># 静态库add_library (MathFunctions STATIC ${DIR_LIB_SRCS})</span><span class="hljs-keyword">add_library</span> (MathFunctions SHARED <span class="hljs-variable">${DIR_LIB_SRCS}</span>)</code></pre></div><p>项目工程目录设置</p><div class="code-wrapper"><pre><code class="hljs cmake"><span class="hljs-keyword">cmake_minimum_required</span>(VERSION <span class="hljs-number">3.22</span>)<span class="hljs-keyword">project</span>(abstract_factory_pattern)<span class="hljs-keyword">set</span>(OUTPUTNAME <span class="hljs-keyword">test</span>)<span class="hljs-keyword">set</span>(CMAKE_CXX_FLAGS <span class="hljs-string">"${CMAKE_CXX_FLAGS} -Wall -g -O2 -std=c++20"</span>)<span class="hljs-comment"># 声明库文件目录</span><span class="hljs-keyword">include_directories</span>(<span class="hljs-variable">${PROJECT_SOURCE_DIR}</span>/mylib)<span class="hljs-keyword">set</span>(EXECUTABLE_OUTPUT_PATH <span class="hljs-variable">${PROJECT_BINARY_DIR}</span>/bin) <span class="hljs-comment"># 设置可执行文件输出目录为bin</span><span class="hljs-keyword">aux_source_directory</span>(. DIR_SRCS)<span class="hljs-keyword">add_executable</span>(<span class="hljs-variable">${OUTPUTNAME}</span> <span class="hljs-variable">${DIR_SRCS}</span>)<span class="hljs-keyword">target_link_libraries</span>(<span class="hljs-variable">${OUTPUTNAME}</span> Mylib) <span class="hljs-comment"># 链接mylib目录下的Mylib库</span></code></pre></div>]]></content>
    
    
    
    <tags>
      
      <tag>CMake</tag>
      
      <tag>CMakeLists.txt</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C++设计模式-行为模式</title>
    <link href="/2022/01/03/C-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E8%A1%8C%E4%B8%BA%E6%A8%A1%E5%BC%8F/"/>
    <url>/2022/01/03/C-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E8%A1%8C%E4%B8%BA%E6%A8%A1%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<div class="toc"><!-- toc --><ul><li><a href="#guan-cha-zhe-mo-shi">观察者模式</a></li><li><a href="#fang-wen-zhe-mo-shi">访问者模式</a></li><li><a href="#ze-ren-lian-mo-shi">责任链模式</a></li><li><a href="#ming-ling-mo-shi">命令模式</a></li><li><a href="#die-dai-qi-mo-shi">迭代器模式</a></li><li><a href="#zhong-jie-zhe-mo-shi">中介者模式</a></li><li><a href="#bei-wang-lu-mo-shi">备忘录模式</a></li><li><a href="#zhuang-tai-mo-shi">状态模式</a></li><li><a href="#ce-lue-mo-shi">策略模式</a></li><li><a href="#mo-ban-fang-fa-mo-shi">模板方法模式</a></li></ul><!-- tocstop --></div><p>推荐看👉<a href="https://refactoringguru.cn/design-patterns">常用设计模式有哪些？ (refactoringguru.cn)</a></p><h1><span id="guan-cha-zhe-mo-shi">观察者模式</span><a href="#guan-cha-zhe-mo-shi" class="header-anchor">#</a></h1><p><strong>观察者模式</strong>是一种行为设计模式， 允许你定义一种订阅机制， 可在对象事件发生时通知多个 “观察” 该对象的其他对象。</p><p>适用场景:</p><ul><li><p><strong>当一个对象状态的改变需要改变其他对象， 或实际对象是事先未知的或动态变化的时， 可使用观察者模式。</strong></p></li><li><p>当你使用图形用户界面类时通常会遇到一个问题。 比如， 你创建了自定义按钮类并允许客户端在按钮中注入自定义代码， 这样当用户按下按钮时就会触发这些代码。</p></li><li><p>观察者模式允许任何实现了订阅者接口的对象订阅发布者对象的事件通知。 你可在按钮中添加订阅机制， 允许客户端通过自定义订阅类注入自定义代码。</p></li><li><p><strong>当应用中的一些对象必须观察其他对象时， 可使用该模式。 但仅能在有限时间内或特定情况下使用。</strong></p></li><li><p>订阅列表是动态的， 因此订阅者可随时加入或离开该列表。</p></li></ul><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-comment">/**</span><span class="hljs-comment"> * Observer Design Pattern</span><span class="hljs-comment"> *</span><span class="hljs-comment"> * Intent: Lets you define a subscription mechanism to notify multiple objects</span><span class="hljs-comment"> * about any events that happen to the object they're observing.</span><span class="hljs-comment"> *</span><span class="hljs-comment"> * Note that there's a lot of different terms with similar meaning associated</span><span class="hljs-comment"> * with this pattern. Just remember that the Subject is also called the</span><span class="hljs-comment"> * Publisher and the Observer is often called the Subscriber and vice versa.</span><span class="hljs-comment"> * Also the verbs "observe", "listen" or "track" usually mean the same thing.</span><span class="hljs-comment"> */</span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;list&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span><span class="hljs-keyword">class</span> <span class="hljs-title class_">IObserver</span> {<span class="hljs-keyword">public</span>:    <span class="hljs-keyword">virtual</span> ~<span class="hljs-built_in">IObserver</span>(){};    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">Update</span><span class="hljs-params">(<span class="hljs-type">const</span> std::string &amp;message_from_subject)</span> </span>= <span class="hljs-number">0</span>;};<span class="hljs-keyword">class</span> <span class="hljs-title class_">ISubject</span> {<span class="hljs-keyword">public</span>:    <span class="hljs-keyword">virtual</span> ~<span class="hljs-built_in">ISubject</span>(){};    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">Attach</span><span class="hljs-params">(IObserver *observer)</span> </span>= <span class="hljs-number">0</span>;    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">Detach</span><span class="hljs-params">(IObserver *observer)</span> </span>= <span class="hljs-number">0</span>;    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">Notify</span><span class="hljs-params">()</span> </span>= <span class="hljs-number">0</span>;};<span class="hljs-comment">/**</span><span class="hljs-comment"> * The Subject owns some important state and notifies observers when the state</span><span class="hljs-comment"> * changes.</span><span class="hljs-comment"> */</span><span class="hljs-keyword">class</span> <span class="hljs-title class_">Subject</span> : <span class="hljs-keyword">public</span> ISubject {<span class="hljs-keyword">public</span>:    <span class="hljs-keyword">virtual</span> ~<span class="hljs-built_in">Subject</span>() {        std::cout &lt;&lt; <span class="hljs-string">"Goodbye, I was the Subject.\n"</span>;    }    <span class="hljs-comment">/**</span><span class="hljs-comment">       * The subscription management methods.</span><span class="hljs-comment">       */</span>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Attach</span><span class="hljs-params">(IObserver *observer)</span> <span class="hljs-keyword">override</span> </span>{        list_observer_.<span class="hljs-built_in">push_back</span>(observer);    }    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Detach</span><span class="hljs-params">(IObserver *observer)</span> <span class="hljs-keyword">override</span> </span>{        list_observer_.<span class="hljs-built_in">remove</span>(observer);    }    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Notify</span><span class="hljs-params">()</span> <span class="hljs-keyword">override</span> </span>{        std::list&lt;IObserver *&gt;::iterator iterator = list_observer_.<span class="hljs-built_in">begin</span>();        <span class="hljs-built_in">HowManyObserver</span>();        <span class="hljs-keyword">while</span> (iterator != list_observer_.<span class="hljs-built_in">end</span>()) {            (*iterator)-&gt;<span class="hljs-built_in">Update</span>(message_);            ++iterator;        }    }    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">CreateMessage</span><span class="hljs-params">(std::string message = <span class="hljs-string">"Empty"</span>)</span> </span>{        <span class="hljs-keyword">this</span>-&gt;message_ = message;        <span class="hljs-built_in">Notify</span>();    }    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">HowManyObserver</span><span class="hljs-params">()</span> </span>{        std::cout &lt;&lt; <span class="hljs-string">"There are "</span> &lt;&lt; list_observer_.<span class="hljs-built_in">size</span>() &lt;&lt; <span class="hljs-string">" observers in the list.\n"</span>;    }    <span class="hljs-comment">/**</span><span class="hljs-comment">       * Usually, the subscription logic is only a fraction of what a Subject can</span><span class="hljs-comment">       * really do. Subjects commonly hold some important business logic, that</span><span class="hljs-comment">       * triggers a notification method whenever something important is about to</span><span class="hljs-comment">       * happen (or after it).</span><span class="hljs-comment">       */</span>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">SomeBusinessLogic</span><span class="hljs-params">()</span> </span>{        <span class="hljs-keyword">this</span>-&gt;message_ = <span class="hljs-string">"change message message"</span>;        <span class="hljs-built_in">Notify</span>();        std::cout &lt;&lt; <span class="hljs-string">"I'm about to do some thing important\n"</span>;    }<span class="hljs-keyword">private</span>:    std::list&lt;IObserver *&gt; list_observer_;    std::string message_;};<span class="hljs-keyword">class</span> <span class="hljs-title class_">Observer</span> : <span class="hljs-keyword">public</span> IObserver {<span class="hljs-keyword">public</span>:    <span class="hljs-built_in">Observer</span>(Subject &amp;subject) : <span class="hljs-built_in">subject_</span>(subject) {        <span class="hljs-keyword">this</span>-&gt;subject_.<span class="hljs-built_in">Attach</span>(<span class="hljs-keyword">this</span>);        std::cout &lt;&lt; <span class="hljs-string">"Hi, I'm the Observer \""</span> &lt;&lt; ++Observer::static_number_ &lt;&lt; <span class="hljs-string">"\".\n"</span>;        <span class="hljs-keyword">this</span>-&gt;number_ = Observer::static_number_;    }    <span class="hljs-keyword">virtual</span> ~<span class="hljs-built_in">Observer</span>() {        std::cout &lt;&lt; <span class="hljs-string">"Goodbye, I was the Observer \""</span> &lt;&lt; <span class="hljs-keyword">this</span>-&gt;number_ &lt;&lt; <span class="hljs-string">"\".\n"</span>;    }    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Update</span><span class="hljs-params">(<span class="hljs-type">const</span> std::string &amp;message_from_subject)</span> <span class="hljs-keyword">override</span> </span>{        message_from_subject_ = message_from_subject;        <span class="hljs-built_in">PrintInfo</span>();    }    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">RemoveMeFromTheList</span><span class="hljs-params">()</span> </span>{        subject_.<span class="hljs-built_in">Detach</span>(<span class="hljs-keyword">this</span>);        std::cout &lt;&lt; <span class="hljs-string">"Observer \""</span> &lt;&lt; number_ &lt;&lt; <span class="hljs-string">"\" removed from the list.\n"</span>;    }    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">PrintInfo</span><span class="hljs-params">()</span> </span>{        std::cout &lt;&lt; <span class="hljs-string">"Observer \""</span> &lt;&lt; <span class="hljs-keyword">this</span>-&gt;number_ &lt;&lt; <span class="hljs-string">"\": a new message is available --&gt; "</span> &lt;&lt; <span class="hljs-keyword">this</span>-&gt;message_from_subject_ &lt;&lt; <span class="hljs-string">"\n"</span>;    }<span class="hljs-keyword">private</span>:    std::string message_from_subject_;    Subject &amp;subject_;    <span class="hljs-type">static</span> <span class="hljs-type">int</span> static_number_;    <span class="hljs-type">int</span> number_;};<span class="hljs-type">int</span> Observer::static_number_ = <span class="hljs-number">0</span>;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">ClientCode</span><span class="hljs-params">()</span> </span>{    Subject *subject = <span class="hljs-keyword">new</span> Subject;    Observer *observer1 = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Observer</span>(*subject);    Observer *observer2 = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Observer</span>(*subject);    Observer *observer3 = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Observer</span>(*subject);    Observer *observer4;    Observer *observer5;    subject-&gt;<span class="hljs-built_in">CreateMessage</span>(<span class="hljs-string">"Hello World! :D"</span>);    observer3-&gt;<span class="hljs-built_in">RemoveMeFromTheList</span>();    subject-&gt;<span class="hljs-built_in">CreateMessage</span>(<span class="hljs-string">"The weather is hot today! :p"</span>);    observer4 = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Observer</span>(*subject);    observer2-&gt;<span class="hljs-built_in">RemoveMeFromTheList</span>();    observer5 = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Observer</span>(*subject);    subject-&gt;<span class="hljs-built_in">CreateMessage</span>(<span class="hljs-string">"My new car is great! ;)"</span>);    observer5-&gt;<span class="hljs-built_in">RemoveMeFromTheList</span>();    observer4-&gt;<span class="hljs-built_in">RemoveMeFromTheList</span>();    observer1-&gt;<span class="hljs-built_in">RemoveMeFromTheList</span>();    <span class="hljs-keyword">delete</span> observer5;    <span class="hljs-keyword">delete</span> observer4;    <span class="hljs-keyword">delete</span> observer3;    <span class="hljs-keyword">delete</span> observer2;    <span class="hljs-keyword">delete</span> observer1;    <span class="hljs-keyword">delete</span> subject;}<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>{    <span class="hljs-built_in">ClientCode</span>();    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;}</code></pre></div><h1><span id="fang-wen-zhe-mo-shi">访问者模式</span><a href="#fang-wen-zhe-mo-shi" class="header-anchor">#</a></h1><p><strong>问者模式</strong>是一种行为设计模式， 它能将算法与其所作用的对象隔离开来。</p><p>适用场景:</p><ul><li><p><strong>如果你需要对一个复杂对象结构 （例如对象树） 中的所有元素执行某些操作， 可使用访问者模式。</strong></p></li><li><p>访问者模式通过在访问者对象中为多个目标类提供相同操作的变体， 让你能在属于不同类的一组对象上执行同一操作。</p></li><li><p><strong>可使用访问者模式来清理辅助行为的业务逻辑。</strong></p></li><li><p>该模式会将所有非主要的行为抽取到一组访问者类中， 使得程序的主要类能更专注于主要的工作。</p></li><li><p><strong>当某个行为仅在类层次结构中的一些类中有意义， 而在其他类中没有意义时， 可使用该模式。</strong></p></li><li><p>你可将该行为抽取到单独的访问者类中， 只需实现接收相关类的对象作为参数的访问者方法并将其他方法留空即可。</p></li></ul><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-comment">/**</span><span class="hljs-comment"> * The Visitor Interface declares a set of visiting methods that correspond to</span><span class="hljs-comment"> * component classes. The signature of a visiting method allows the visitor to</span><span class="hljs-comment"> * identify the exact class of the component that it's dealing with.</span><span class="hljs-comment"> */</span><span class="hljs-keyword">class</span> <span class="hljs-title class_">ConcreteComponentA</span>;<span class="hljs-keyword">class</span> <span class="hljs-title class_">ConcreteComponentB</span>;<span class="hljs-keyword">class</span> <span class="hljs-title class_">Visitor</span> {<span class="hljs-keyword">public</span>:    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">VisitConcreteComponentA</span><span class="hljs-params">(<span class="hljs-type">const</span> ConcreteComponentA *element)</span> <span class="hljs-type">const</span> </span>= <span class="hljs-number">0</span>;    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">VisitConcreteComponentB</span><span class="hljs-params">(<span class="hljs-type">const</span> ConcreteComponentB *element)</span> <span class="hljs-type">const</span> </span>= <span class="hljs-number">0</span>;};<span class="hljs-comment">/**</span><span class="hljs-comment"> * The Component interface declares an `accept` method that should take the base</span><span class="hljs-comment"> * visitor interface as an argument.</span><span class="hljs-comment"> */</span><span class="hljs-keyword">class</span> <span class="hljs-title class_">Component</span> {<span class="hljs-keyword">public</span>:    <span class="hljs-keyword">virtual</span> ~<span class="hljs-built_in">Component</span>() {}    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">Accept</span><span class="hljs-params">(Visitor *visitor)</span> <span class="hljs-type">const</span> </span>= <span class="hljs-number">0</span>;};<span class="hljs-comment">/**</span><span class="hljs-comment"> * Each Concrete Component must implement the `Accept` method in such a way that</span><span class="hljs-comment"> * it calls the visitor's method corresponding to the component's class.</span><span class="hljs-comment"> */</span><span class="hljs-keyword">class</span> <span class="hljs-title class_">ConcreteComponentA</span> : <span class="hljs-keyword">public</span> Component {  <span class="hljs-comment">/**</span><span class="hljs-comment">   * Note that we're calling `visitConcreteComponentA`, which matches the</span><span class="hljs-comment">   * current class name. This way we let the visitor know the class of the</span><span class="hljs-comment">   * component it works with.</span><span class="hljs-comment">   */</span><span class="hljs-keyword">public</span>:    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Accept</span><span class="hljs-params">(Visitor *visitor)</span> <span class="hljs-type">const</span> <span class="hljs-keyword">override</span> </span>{        visitor-&gt;<span class="hljs-built_in">VisitConcreteComponentA</span>(<span class="hljs-keyword">this</span>);    }    <span class="hljs-comment">/**</span><span class="hljs-comment">       * Concrete Components may have special methods that don't exist in their base</span><span class="hljs-comment">       * class or interface. The Visitor is still able to use these methods since</span><span class="hljs-comment">       * it's aware of the component's concrete class.</span><span class="hljs-comment">       */</span>    <span class="hljs-function">std::string <span class="hljs-title">ExclusiveMethodOfConcreteComponentA</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>{        <span class="hljs-keyword">return</span> <span class="hljs-string">"A"</span>;    }};<span class="hljs-keyword">class</span> <span class="hljs-title class_">ConcreteComponentB</span> : <span class="hljs-keyword">public</span> Component {  <span class="hljs-comment">/**</span><span class="hljs-comment">   * Same here: visitConcreteComponentB =&gt; ConcreteComponentB</span><span class="hljs-comment">   */</span><span class="hljs-keyword">public</span>:    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Accept</span><span class="hljs-params">(Visitor *visitor)</span> <span class="hljs-type">const</span> <span class="hljs-keyword">override</span> </span>{        visitor-&gt;<span class="hljs-built_in">VisitConcreteComponentB</span>(<span class="hljs-keyword">this</span>);    }    <span class="hljs-function">std::string <span class="hljs-title">SpecialMethodOfConcreteComponentB</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>{        <span class="hljs-keyword">return</span> <span class="hljs-string">"B"</span>;    }};<span class="hljs-comment">/**</span><span class="hljs-comment"> * Concrete Visitors implement several versions of the same algorithm, which can</span><span class="hljs-comment"> * work with all concrete component classes.</span><span class="hljs-comment"> *</span><span class="hljs-comment"> * You can experience the biggest benefit of the Visitor pattern when using it</span><span class="hljs-comment"> * with a complex object structure, such as a Composite tree. In this case, it</span><span class="hljs-comment"> * might be helpful to store some intermediate state of the algorithm while</span><span class="hljs-comment"> * executing visitor's methods over various objects of the structure.</span><span class="hljs-comment"> */</span><span class="hljs-keyword">class</span> <span class="hljs-title class_">ConcreteVisitor1</span> : <span class="hljs-keyword">public</span> Visitor {<span class="hljs-keyword">public</span>:    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">VisitConcreteComponentA</span><span class="hljs-params">(<span class="hljs-type">const</span> ConcreteComponentA *element)</span> <span class="hljs-type">const</span> <span class="hljs-keyword">override</span> </span>{        std::cout &lt;&lt; element-&gt;<span class="hljs-built_in">ExclusiveMethodOfConcreteComponentA</span>() &lt;&lt; <span class="hljs-string">" + ConcreteVisitor1\n"</span>;    }    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">VisitConcreteComponentB</span><span class="hljs-params">(<span class="hljs-type">const</span> ConcreteComponentB *element)</span> <span class="hljs-type">const</span> <span class="hljs-keyword">override</span> </span>{        std::cout &lt;&lt; element-&gt;<span class="hljs-built_in">SpecialMethodOfConcreteComponentB</span>() &lt;&lt; <span class="hljs-string">" + ConcreteVisitor1\n"</span>;    }};<span class="hljs-keyword">class</span> <span class="hljs-title class_">ConcreteVisitor2</span> : <span class="hljs-keyword">public</span> Visitor {<span class="hljs-keyword">public</span>:    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">VisitConcreteComponentA</span><span class="hljs-params">(<span class="hljs-type">const</span> ConcreteComponentA *element)</span> <span class="hljs-type">const</span> <span class="hljs-keyword">override</span> </span>{        std::cout &lt;&lt; element-&gt;<span class="hljs-built_in">ExclusiveMethodOfConcreteComponentA</span>() &lt;&lt; <span class="hljs-string">" + ConcreteVisitor2\n"</span>;    }    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">VisitConcreteComponentB</span><span class="hljs-params">(<span class="hljs-type">const</span> ConcreteComponentB *element)</span> <span class="hljs-type">const</span> <span class="hljs-keyword">override</span> </span>{        std::cout &lt;&lt; element-&gt;<span class="hljs-built_in">SpecialMethodOfConcreteComponentB</span>() &lt;&lt; <span class="hljs-string">" + ConcreteVisitor2\n"</span>;    }};<span class="hljs-comment">/**</span><span class="hljs-comment"> * The client code can run visitor operations over any set of elements without</span><span class="hljs-comment"> * figuring out their concrete classes. The accept operation directs a call to</span><span class="hljs-comment"> * the appropriate operation in the visitor object.</span><span class="hljs-comment"> */</span><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">ClientCode</span><span class="hljs-params">(std::array&lt;<span class="hljs-type">const</span> Component *, <span class="hljs-number">2</span>&gt; components, Visitor *visitor)</span> </span>{    <span class="hljs-comment">// ...</span>    <span class="hljs-keyword">for</span> (<span class="hljs-type">const</span> Component *comp : components) {        comp-&gt;<span class="hljs-built_in">Accept</span>(visitor);    }    <span class="hljs-comment">// ...</span>}<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>{    std::array&lt;<span class="hljs-type">const</span> Component *, 2&gt; components = {<span class="hljs-keyword">new</span> ConcreteComponentA, <span class="hljs-keyword">new</span> ConcreteComponentB};    std::cout &lt;&lt; <span class="hljs-string">"The client code works with all visitors via the base Visitor interface:\n"</span>;    ConcreteVisitor1 *visitor1 = <span class="hljs-keyword">new</span> ConcreteVisitor1;    <span class="hljs-built_in">ClientCode</span>(components, visitor1);    std::cout &lt;&lt; <span class="hljs-string">"\n"</span>;    std::cout &lt;&lt; <span class="hljs-string">"It allows the same client code to work with different types of visitors:\n"</span>;    ConcreteVisitor2 *visitor2 = <span class="hljs-keyword">new</span> ConcreteVisitor2;    <span class="hljs-built_in">ClientCode</span>(components, visitor2);    <span class="hljs-keyword">for</span> (<span class="hljs-type">const</span> Component *comp : components) {        <span class="hljs-keyword">delete</span> comp;    }    <span class="hljs-keyword">delete</span> visitor1;    <span class="hljs-keyword">delete</span> visitor2;    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;}</code></pre></div><h1><span id="ze-ren-lian-mo-shi">责任链模式</span><a href="#ze-ren-lian-mo-shi" class="header-anchor">#</a></h1><p><strong>责任链模式</strong>是一种行为设计模式， 允许你将请求沿着处理者链进行发送。 收到请求后， 每个处理者均可对请求进行处理， 或将其传递给链上的下个处理者。</p><p>适合应用场景:</p><ul><li><p><strong>当程序需要使用不同方式处理不同种类请求， 而且请求类型和顺序预先未知时， 可以使用责任链模式。</strong></p></li><li><p>该模式能将多个处理者连接成一条链。 接收到请求后， 它会 “询问” 每个处理者是否能够对其进行处理。 这样所有处理者都有机会来处理请求。</p></li><li><p><strong>当必须按顺序执行多个处理者时， 可以使用该模式。</strong></p></li><li><p>无论你以何种顺序将处理者连接成一条链， 所有请求都会严格按照顺序通过链上的处理者。</p></li><li><p>如<strong>果所需处理者及其顺序必须在运行时进行改变， 可以使用责任链模式。</strong></p></li><li><p>如果在处理者类中有对引用成员变量的设定方法， 你将能动态地插入和移除处理者， 或者改变其顺序。</p></li></ul><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-comment">/**</span><span class="hljs-comment"> * The Handler interface declares a method for building the chain of handlers.</span><span class="hljs-comment"> * It also declares a method for executing a request.</span><span class="hljs-comment"> */</span><span class="hljs-keyword">class</span> <span class="hljs-title class_">Handler</span> {<span class="hljs-keyword">public</span>:    <span class="hljs-function"><span class="hljs-keyword">virtual</span> Handler *<span class="hljs-title">SetNext</span><span class="hljs-params">(Handler *handler)</span> </span>= <span class="hljs-number">0</span>;    <span class="hljs-function"><span class="hljs-keyword">virtual</span> std::string <span class="hljs-title">Handle</span><span class="hljs-params">(std::string request)</span> </span>= <span class="hljs-number">0</span>;};<span class="hljs-comment">/**</span><span class="hljs-comment"> * The default chaining behavior can be implemented inside a base handler class.</span><span class="hljs-comment"> */</span><span class="hljs-keyword">class</span> <span class="hljs-title class_">AbstractHandler</span> : <span class="hljs-keyword">public</span> Handler {  <span class="hljs-comment">/**</span><span class="hljs-comment">   * @var Handler</span><span class="hljs-comment">   */</span><span class="hljs-keyword">private</span>:  Handler *next_handler_;<span class="hljs-keyword">public</span>:    <span class="hljs-built_in">AbstractHandler</span>() : <span class="hljs-built_in">next_handler_</span>(<span class="hljs-literal">nullptr</span>) {    }    <span class="hljs-function">Handler *<span class="hljs-title">SetNext</span><span class="hljs-params">(Handler *handler)</span> <span class="hljs-keyword">override</span> </span>{        <span class="hljs-keyword">this</span>-&gt;next_handler_ = handler;        <span class="hljs-comment">// Returning a handler from here will let us link handlers in a convenient</span>        <span class="hljs-comment">// way like this:</span>        <span class="hljs-comment">// $monkey-&gt;setNext($squirrel)-&gt;setNext($dog);</span>        <span class="hljs-keyword">return</span> handler;    }    <span class="hljs-function">std::string <span class="hljs-title">Handle</span><span class="hljs-params">(std::string request)</span> <span class="hljs-keyword">override</span> </span>{        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>-&gt;next_handler_) {            <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>-&gt;next_handler_-&gt;<span class="hljs-built_in">Handle</span>(request);        }        <span class="hljs-keyword">return</span> {};    }};<span class="hljs-comment">/**</span><span class="hljs-comment"> * All Concrete Handlers either handle a request or pass it to the next handler</span><span class="hljs-comment"> * in the chain.</span><span class="hljs-comment"> */</span><span class="hljs-keyword">class</span> <span class="hljs-title class_">MonkeyHandler</span> : <span class="hljs-keyword">public</span> AbstractHandler {<span class="hljs-keyword">public</span>:    <span class="hljs-function">std::string <span class="hljs-title">Handle</span><span class="hljs-params">(std::string request)</span> <span class="hljs-keyword">override</span> </span>{        <span class="hljs-keyword">if</span> (request == <span class="hljs-string">"Banana"</span>) {            <span class="hljs-keyword">return</span> <span class="hljs-string">"Monkey: I'll eat the "</span> + request + <span class="hljs-string">".\n"</span>;        } <span class="hljs-keyword">else</span> {            <span class="hljs-keyword">return</span> AbstractHandler::<span class="hljs-built_in">Handle</span>(request);        }    }};<span class="hljs-keyword">class</span> <span class="hljs-title class_">SquirrelHandler</span> : <span class="hljs-keyword">public</span> AbstractHandler {<span class="hljs-keyword">public</span>:    <span class="hljs-function">std::string <span class="hljs-title">Handle</span><span class="hljs-params">(std::string request)</span> <span class="hljs-keyword">override</span> </span>{        <span class="hljs-keyword">if</span> (request == <span class="hljs-string">"Nut"</span>) {            <span class="hljs-keyword">return</span> <span class="hljs-string">"Squirrel: I'll eat the "</span> + request + <span class="hljs-string">".\n"</span>;        } <span class="hljs-keyword">else</span> {            <span class="hljs-keyword">return</span> AbstractHandler::<span class="hljs-built_in">Handle</span>(request);        }    }};<span class="hljs-keyword">class</span> <span class="hljs-title class_">DogHandler</span> : <span class="hljs-keyword">public</span> AbstractHandler {<span class="hljs-keyword">public</span>:    <span class="hljs-function">std::string <span class="hljs-title">Handle</span><span class="hljs-params">(std::string request)</span> <span class="hljs-keyword">override</span> </span>{        <span class="hljs-keyword">if</span> (request == <span class="hljs-string">"MeatBall"</span>) {            <span class="hljs-keyword">return</span> <span class="hljs-string">"Dog: I'll eat the "</span> + request + <span class="hljs-string">".\n"</span>;        } <span class="hljs-keyword">else</span> {            <span class="hljs-keyword">return</span> AbstractHandler::<span class="hljs-built_in">Handle</span>(request);        }    }};<span class="hljs-comment">/**</span><span class="hljs-comment"> * The client code is usually suited to work with a single handler. In most</span><span class="hljs-comment"> * cases, it is not even aware that the handler is part of a chain.</span><span class="hljs-comment"> */</span><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">ClientCode</span><span class="hljs-params">(Handler &amp;handler)</span> </span>{    std::vector&lt;std::string&gt; food = {<span class="hljs-string">"Nut"</span>, <span class="hljs-string">"Banana"</span>, <span class="hljs-string">"Cup of coffee"</span>};    <span class="hljs-keyword">for</span> (<span class="hljs-type">const</span> std::string &amp;f : food) {        std::cout &lt;&lt; <span class="hljs-string">"Client: Who wants a "</span> &lt;&lt; f &lt;&lt; <span class="hljs-string">"?\n"</span>;        <span class="hljs-type">const</span> std::string result = handler.<span class="hljs-built_in">Handle</span>(f);        <span class="hljs-keyword">if</span> (!result.<span class="hljs-built_in">empty</span>()) {            std::cout &lt;&lt; <span class="hljs-string">"  "</span> &lt;&lt; result;        } <span class="hljs-keyword">else</span> {            std::cout &lt;&lt; <span class="hljs-string">"  "</span> &lt;&lt; f &lt;&lt; <span class="hljs-string">" was left untouched.\n"</span>;        }    }}<span class="hljs-comment">/**</span><span class="hljs-comment"> * The other part of the client code constructs the actual chain.</span><span class="hljs-comment"> */</span><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>{    MonkeyHandler *monkey = <span class="hljs-keyword">new</span> MonkeyHandler;    SquirrelHandler *squirrel = <span class="hljs-keyword">new</span> SquirrelHandler;    DogHandler *dog = <span class="hljs-keyword">new</span> DogHandler;    monkey-&gt;<span class="hljs-built_in">SetNext</span>(squirrel)-&gt;<span class="hljs-built_in">SetNext</span>(dog);    <span class="hljs-comment">/**</span><span class="hljs-comment">       * The client should be able to send a request to any handler, not just the</span><span class="hljs-comment">       * first one in the chain.</span><span class="hljs-comment">       */</span>    std::cout &lt;&lt; <span class="hljs-string">"Chain: Monkey &gt; Squirrel &gt; Dog\n\n"</span>;    <span class="hljs-built_in">ClientCode</span>(*monkey);    std::cout &lt;&lt; <span class="hljs-string">"\n"</span>;    std::cout &lt;&lt; <span class="hljs-string">"Subchain: Squirrel &gt; Dog\n\n"</span>;    <span class="hljs-built_in">ClientCode</span>(*squirrel);    <span class="hljs-keyword">delete</span> monkey;    <span class="hljs-keyword">delete</span> squirrel;    <span class="hljs-keyword">delete</span> dog;    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;}</code></pre></div><h1><span id="ming-ling-mo-shi">命令模式</span><a href="#ming-ling-mo-shi" class="header-anchor">#</a></h1><p><strong>命令模式</strong>是一种行为设计模式， 它可将请求转换为一个包含与请求相关的所有信息的独立对象。 该转换让你能根据不同的请求将方法参数化、 延迟请求执行或将其放入队列中， 且能实现可撤销操作。</p><p>适合应用场景:</p><ul><li><p><strong>如果你需要通过操作来参数化对象， 可使用命令模式。</strong></p></li><li><p>命令模式可将特定的方法调用转化为独立对象。 这一改变也带来了许多有趣的应用： 你可以将命令作为方法的参数进行传递、 将命令保存在其他对象中， 或者在运行时切换已连接的命令等。</p></li><li><p>举个例子： 你正在开发一个 GUI 组件 （例如上下文菜单）， 你希望用户能够配置菜单项， 并在点击菜单项时触发操作。</p></li></ul><p> <strong>如果你想要将操作放入队列中、 操作的执行或者远程执行操作， 可使用命令模式。</strong></p><ul><li><p>同其他对象一样， 命令也可以实现序列化 （序列化的意思是转化为字符串）， 从而能方便地写入文件或数据库中。 一段时间后， 该字符串可被恢复成为最初的命令对象。 因此， 你可以延迟或计划命令的执行。 但其功能远不止如此！ 使用同样的方式， 你还可以将命令放入队列、 记录命令或者通过网络发送命令。</p></li><li><p><strong>如果你想要实现操作回滚功能， 可使用命令模式。</strong></p></li><li><p>尽管有很多方法可以实现撤销和恢复功能， 但命令模式可能是其中最常用的一种。</p></li><li><p>为了能够回滚操作， 你需要实现已执行操作的历史记录功能。 命令历史记录是一种包含所有已执行命令对象及其相关程序状态备份的栈结构。</p></li><li><p>这种方法有两个缺点。 首先， 程序状态的保存功能并不容易实现， 因为部分状态可能是私有的。 你可以使用<a href="https://refactoringguru.cn/design-patterns/memento">备忘录</a>模式来在一定程度上解决这个问题。</p></li><li><p>其次， 备份状态可能会占用大量内存。 因此， 有时你需要借助另一种实现方式： 命令无需恢复原始状态， 而是执行反向操作。 反向操作也有代价： 它可能会很难甚至是无法实现。</p></li></ul><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-comment">/**</span><span class="hljs-comment"> * The Command interface declares a method for executing a command.</span><span class="hljs-comment"> */</span><span class="hljs-keyword">class</span> <span class="hljs-title class_">Command</span> {<span class="hljs-keyword">public</span>:    <span class="hljs-keyword">virtual</span> ~<span class="hljs-built_in">Command</span>() {    }    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">Execute</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>= <span class="hljs-number">0</span>;};<span class="hljs-comment">/**</span><span class="hljs-comment"> * Some commands can implement simple operations on their own.</span><span class="hljs-comment"> */</span><span class="hljs-keyword">class</span> <span class="hljs-title class_">SimpleCommand</span> : <span class="hljs-keyword">public</span> Command {<span class="hljs-keyword">private</span>:  std::string pay_load_;<span class="hljs-keyword">public</span>:    <span class="hljs-function"><span class="hljs-keyword">explicit</span> <span class="hljs-title">SimpleCommand</span><span class="hljs-params">(std::string pay_load)</span> : pay_load_(pay_load) {</span>    }    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Execute</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> <span class="hljs-keyword">override</span> </span>{        std::cout &lt;&lt; <span class="hljs-string">"SimpleCommand: See, I can do simple things like printing ("</span> &lt;&lt; <span class="hljs-keyword">this</span>-&gt;pay_load_ &lt;&lt; <span class="hljs-string">")\n"</span>;    }};<span class="hljs-comment">/**</span><span class="hljs-comment"> * The Receiver classes contain some important business logic. They know how to</span><span class="hljs-comment"> * perform all kinds of operations, associated with carrying out a request. In</span><span class="hljs-comment"> * fact, any class may serve as a Receiver.</span><span class="hljs-comment"> */</span><span class="hljs-keyword">class</span> <span class="hljs-title class_">Receiver</span> {<span class="hljs-keyword">public</span>:    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">DoSomething</span><span class="hljs-params">(<span class="hljs-type">const</span> std::string &amp;a)</span> </span>{        std::cout &lt;&lt; <span class="hljs-string">"Receiver: Working on ("</span> &lt;&lt; a &lt;&lt; <span class="hljs-string">".)\n"</span>;    }    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">DoSomethingElse</span><span class="hljs-params">(<span class="hljs-type">const</span> std::string &amp;b)</span> </span>{        std::cout &lt;&lt; <span class="hljs-string">"Receiver: Also working on ("</span> &lt;&lt; b &lt;&lt; <span class="hljs-string">".)\n"</span>;    }};<span class="hljs-comment">/**</span><span class="hljs-comment"> * However, some commands can delegate more complex operations to other objects,</span><span class="hljs-comment"> * called "receivers."</span><span class="hljs-comment"> */</span><span class="hljs-keyword">class</span> <span class="hljs-title class_">ComplexCommand</span> : <span class="hljs-keyword">public</span> Command {  <span class="hljs-comment">/**</span><span class="hljs-comment">   * @var Receiver</span><span class="hljs-comment">   */</span><span class="hljs-keyword">private</span>:    Receiver *receiver_;    <span class="hljs-comment">/**</span><span class="hljs-comment">       * Context data, required for launching the receiver's methods.</span><span class="hljs-comment">       */</span>    std::string a_;    std::string b_;    <span class="hljs-comment">/**</span><span class="hljs-comment">       * Complex commands can accept one or several receiver objects along with any</span><span class="hljs-comment">       * context data via the constructor.</span><span class="hljs-comment">       */</span><span class="hljs-keyword">public</span>:    <span class="hljs-built_in">ComplexCommand</span>(Receiver *receiver, std::string a, std::string b) : <span class="hljs-built_in">receiver_</span>(receiver), <span class="hljs-built_in">a_</span>(a), <span class="hljs-built_in">b_</span>(b) {    }    <span class="hljs-comment">/**</span><span class="hljs-comment">       * Commands can delegate to any methods of a receiver.</span><span class="hljs-comment">       */</span>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Execute</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> <span class="hljs-keyword">override</span> </span>{        std::cout &lt;&lt; <span class="hljs-string">"ComplexCommand: Complex stuff should be done by a receiver object.\n"</span>;        <span class="hljs-keyword">this</span>-&gt;receiver_-&gt;<span class="hljs-built_in">DoSomething</span>(<span class="hljs-keyword">this</span>-&gt;a_);        <span class="hljs-keyword">this</span>-&gt;receiver_-&gt;<span class="hljs-built_in">DoSomethingElse</span>(<span class="hljs-keyword">this</span>-&gt;b_);    }};<span class="hljs-comment">/**</span><span class="hljs-comment"> * The Invoker is associated with one or several commands. It sends a request to</span><span class="hljs-comment"> * the command.</span><span class="hljs-comment"> */</span><span class="hljs-keyword">class</span> <span class="hljs-title class_">Invoker</span> {  <span class="hljs-comment">/**</span><span class="hljs-comment">   * @var Command</span><span class="hljs-comment">   */</span><span class="hljs-keyword">private</span>:    Command *on_start_;    <span class="hljs-comment">/**</span><span class="hljs-comment">       * @var Command</span><span class="hljs-comment">       */</span>    Command *on_finish_;    <span class="hljs-comment">/**</span><span class="hljs-comment">       * Initialize commands.</span><span class="hljs-comment">       */</span><span class="hljs-keyword">public</span>:    ~<span class="hljs-built_in">Invoker</span>() {        <span class="hljs-keyword">delete</span> on_start_;        <span class="hljs-keyword">delete</span> on_finish_;    }    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">SetOnStart</span><span class="hljs-params">(Command *command)</span> </span>{        <span class="hljs-keyword">this</span>-&gt;on_start_ = command;    }    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">SetOnFinish</span><span class="hljs-params">(Command *command)</span> </span>{        <span class="hljs-keyword">this</span>-&gt;on_finish_ = command;    }    <span class="hljs-comment">/**</span><span class="hljs-comment">       * The Invoker does not depend on concrete command or receiver classes. The</span><span class="hljs-comment">       * Invoker passes a request to a receiver indirectly, by executing a command.</span><span class="hljs-comment">       */</span>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">DoSomethingImportant</span><span class="hljs-params">()</span> </span>{        std::cout &lt;&lt; <span class="hljs-string">"Invoker: Does anybody want something done before I begin?\n"</span>;        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>-&gt;on_start_) {            <span class="hljs-keyword">this</span>-&gt;on_start_-&gt;<span class="hljs-built_in">Execute</span>();        }        std::cout &lt;&lt; <span class="hljs-string">"Invoker: ...doing something really important...\n"</span>;        std::cout &lt;&lt; <span class="hljs-string">"Invoker: Does anybody want something done after I finish?\n"</span>;        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>-&gt;on_finish_) {            <span class="hljs-keyword">this</span>-&gt;on_finish_-&gt;<span class="hljs-built_in">Execute</span>();        }    }};<span class="hljs-comment">/**</span><span class="hljs-comment"> * The client code can parameterize an invoker with any commands.</span><span class="hljs-comment"> */</span><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>{    Invoker *invoker = <span class="hljs-keyword">new</span> Invoker;    invoker-&gt;<span class="hljs-built_in">SetOnStart</span>(<span class="hljs-keyword">new</span> <span class="hljs-built_in">SimpleCommand</span>(<span class="hljs-string">"Say Hi!"</span>));    Receiver *receiver = <span class="hljs-keyword">new</span> Receiver;    invoker-&gt;<span class="hljs-built_in">SetOnFinish</span>(<span class="hljs-keyword">new</span> <span class="hljs-built_in">ComplexCommand</span>(receiver, <span class="hljs-string">"Send email"</span>, <span class="hljs-string">"Save report"</span>));    invoker-&gt;<span class="hljs-built_in">DoSomethingImportant</span>();    <span class="hljs-keyword">delete</span> invoker;    <span class="hljs-keyword">delete</span> receiver;    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;}</code></pre></div><h1><span id="die-dai-qi-mo-shi">迭代器模式</span><a href="#die-dai-qi-mo-shi" class="header-anchor">#</a></h1><p><strong>迭代器模式</strong>是一种行为设计模式， 让你能在不暴露集合底层表现形式 （列表、 栈和树等） 的情况下遍历集合中所有的元素。</p><p>适合应用场景:</p><ul><li><p><strong>当集合背后为复杂的数据结构， 且你希望对客户端隐藏其复杂性时 （出于使用便利性或安全性的考虑）， 可以使用迭代器模式。</strong></p></li><li><p>迭代器封装了与复杂数据结构进行交互的细节， 为客户端提供多个访问集合元素的简单方法。 这种方式不仅对客户端来说非常方便， 而且能避免客户端在直接与集合交互时执行错误或有害的操作， 从而起到保护集合的作用。</p></li><li><p><strong>使用该模式可以减少程序中重复的遍历代码。</strong></p></li><li><p>重要迭代算法的代码往往体积非常庞大。 当这些代码被放置在程序业务逻辑中时， 它会让原始代码的职责模糊不清， 降低其可维护性。 因此， 将遍历代码移到特定的迭代器中可使程序代码更加精炼和简洁。</p></li><li><p><strong>如果你希望代码能够遍历不同的甚至是无法预知的数据结构， 可以使用迭代器模式。</strong></p></li><li><p>该模式为集合和迭代器提供了一些通用接口。 如果你在代码中使用了这些接口， 那么将其他实现了这些接口的集合和迭代器传递给它时， 它仍将可以正常运行。</p></li></ul><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-comment">/**</span><span class="hljs-comment"> * Iterator Design Pattern</span><span class="hljs-comment"> *</span><span class="hljs-comment"> * Intent: Lets you traverse elements of a collection without exposing its</span><span class="hljs-comment"> * underlying representation (list, stack, tree, etc.).</span><span class="hljs-comment"> */</span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><span class="hljs-comment">/**</span><span class="hljs-comment"> * C++ has its own implementation of iterator that works with a different</span><span class="hljs-comment"> * generics containers defined by the standard library.</span><span class="hljs-comment"> */</span><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T, <span class="hljs-keyword">typename</span> U&gt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">Iterator</span> {<span class="hljs-keyword">public</span>:    <span class="hljs-keyword">typedef</span> <span class="hljs-keyword">typename</span> std::vector&lt;T&gt;::iterator iter_type;    <span class="hljs-built_in">Iterator</span>(U *p_data, <span class="hljs-type">bool</span> reverse = <span class="hljs-literal">false</span>) : <span class="hljs-built_in">m_p_data_</span>(p_data) {        m_it_ = m_p_data_-&gt;m_data_.<span class="hljs-built_in">begin</span>();    }    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">First</span><span class="hljs-params">()</span> </span>{        m_it_ = m_p_data_-&gt;m_data_.<span class="hljs-built_in">begin</span>();    }    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Next</span><span class="hljs-params">()</span> </span>{        m_it_++;    }    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">IsDone</span><span class="hljs-params">()</span> </span>{        <span class="hljs-keyword">return</span> (m_it_ == m_p_data_-&gt;m_data_.<span class="hljs-built_in">end</span>());    }    <span class="hljs-function">iter_type <span class="hljs-title">Current</span><span class="hljs-params">()</span> </span>{        <span class="hljs-keyword">return</span> m_it_;    }<span class="hljs-keyword">private</span>:    U *m_p_data_;    iter_type m_it_;};<span class="hljs-comment">/**</span><span class="hljs-comment"> * Generic Collections/Containers provides one or several methods for retrieving</span><span class="hljs-comment"> * fresh iterator instances, compatible with the collection class.</span><span class="hljs-comment"> */</span><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">T</span>&gt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">Container</span> {  <span class="hljs-keyword">friend</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Iterator</span>&lt;T, Container&gt;;<span class="hljs-keyword">public</span>:    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Add</span><span class="hljs-params">(T a)</span> </span>{        m_data_.<span class="hljs-built_in">push_back</span>(a);    }    <span class="hljs-function">Iterator&lt;T, Container&gt; *<span class="hljs-title">CreateIterator</span><span class="hljs-params">()</span> </span>{        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Iterator</span>&lt;T, Container&gt;(<span class="hljs-keyword">this</span>);    }<span class="hljs-keyword">private</span>:  std::vector&lt;T&gt; m_data_;};<span class="hljs-keyword">class</span> <span class="hljs-title class_">Data</span> {<span class="hljs-keyword">public</span>:    <span class="hljs-built_in">Data</span>(<span class="hljs-type">int</span> a = <span class="hljs-number">0</span>) : <span class="hljs-built_in">m_data_</span>(a) {}    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">set_data</span><span class="hljs-params">(<span class="hljs-type">int</span> a)</span> </span>{        m_data_ = a;    }    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">data</span><span class="hljs-params">()</span> </span>{        <span class="hljs-keyword">return</span> m_data_;    }<span class="hljs-keyword">private</span>:  <span class="hljs-type">int</span> m_data_;};<span class="hljs-comment">/**</span><span class="hljs-comment"> * The client code may or may not know about the Concrete Iterator or Collection</span><span class="hljs-comment"> * classes, for this implementation the container is generic so you can used</span><span class="hljs-comment"> * with an int or with a custom class.</span><span class="hljs-comment"> */</span><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">ClientCode</span><span class="hljs-params">()</span> </span>{    std::cout &lt;&lt; <span class="hljs-string">"________________Iterator with int______________________________________"</span> &lt;&lt; std::endl;    Container&lt;<span class="hljs-type">int</span>&gt; cont;    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++) {        cont.<span class="hljs-built_in">Add</span>(i);    }    Iterator&lt;<span class="hljs-type">int</span>, Container&lt;<span class="hljs-type">int</span>&gt;&gt; *it = cont.<span class="hljs-built_in">CreateIterator</span>();    <span class="hljs-keyword">for</span> (it-&gt;<span class="hljs-built_in">First</span>(); !it-&gt;<span class="hljs-built_in">IsDone</span>(); it-&gt;<span class="hljs-built_in">Next</span>()) {        std::cout &lt;&lt; *it-&gt;<span class="hljs-built_in">Current</span>() &lt;&lt; std::endl;    }    Container&lt;Data&gt; cont2;    <span class="hljs-function">Data <span class="hljs-title">a</span><span class="hljs-params">(<span class="hljs-number">100</span>)</span>, <span class="hljs-title">b</span><span class="hljs-params">(<span class="hljs-number">1000</span>)</span>, <span class="hljs-title">c</span><span class="hljs-params">(<span class="hljs-number">10000</span>)</span></span>;    cont2.<span class="hljs-built_in">Add</span>(a);    cont2.<span class="hljs-built_in">Add</span>(b);    cont2.<span class="hljs-built_in">Add</span>(c);    std::cout &lt;&lt; <span class="hljs-string">"________________Iterator with custom Class______________________________"</span> &lt;&lt; std::endl;    Iterator&lt;Data, Container&lt;Data&gt;&gt; *it2 = cont2.<span class="hljs-built_in">CreateIterator</span>();    <span class="hljs-keyword">for</span> (it2-&gt;<span class="hljs-built_in">First</span>(); !it2-&gt;<span class="hljs-built_in">IsDone</span>(); it2-&gt;<span class="hljs-built_in">Next</span>()) {        std::cout &lt;&lt; it2-&gt;<span class="hljs-built_in">Current</span>()-&gt;<span class="hljs-built_in">data</span>() &lt;&lt; std::endl;    }    <span class="hljs-keyword">delete</span> it;    <span class="hljs-keyword">delete</span> it2;}<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>{    <span class="hljs-built_in">ClientCode</span>();    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;}</code></pre></div><h1><span id="zhong-jie-zhe-mo-shi">中介者模式</span><a href="#zhong-jie-zhe-mo-shi" class="header-anchor">#</a></h1><p><strong>中介者模式</strong>是一种行为设计模式， 能让你减少对象之间混乱无序的依赖关系。 该模式会限制对象之间的直接交互， 迫使它们通过一个中介者对象进行合作。</p><p>适合应用场景:</p><ul><li><p><strong>当一些对象和其他对象紧密耦合以致难以对其进行修改时， 可使用中介者模式。</strong></p></li><li><p>该模式让你将对象间的所有关系抽取成为一个单独的类， 以使对于特定组件的修改工作独立于其他组件。</p></li><li><p><strong>当组件因过于依赖其他组件而无法在不同应用中复用时， 可使用中介者模式。</strong></p></li><li><p>应用中介者模式后， 每个组件不再知晓其他组件的情况。 尽管这些组件无法直接交流， 但它们仍可通过中介者对象进行间接交流。 如果你希望在不同应用中复用一个组件， 则需要为其提供一个新的中介者类。</p></li><li><p><strong>如果为了能在不同情景下复用一些基本行为， 导致你需要被迫创建大量组件子类时， 可使用中介者模式。</strong></p></li><li><p>由于所有组件间关系都被包含在中介者中， 因此你无需修改组件就能方便地新建中介者类以定义新的组件合作方式。</p></li></ul><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span><span class="hljs-comment">/**</span><span class="hljs-comment"> * The Mediator interface declares a method used by components to notify the</span><span class="hljs-comment"> * mediator about various events. The Mediator may react to these events and</span><span class="hljs-comment"> * pass the execution to other components.</span><span class="hljs-comment"> */</span><span class="hljs-keyword">class</span> <span class="hljs-title class_">BaseComponent</span>;<span class="hljs-keyword">class</span> <span class="hljs-title class_">Mediator</span> {<span class="hljs-keyword">public</span>:  <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">Notify</span><span class="hljs-params">(BaseComponent *sender, std::string event)</span> <span class="hljs-type">const</span> </span>= <span class="hljs-number">0</span>;};<span class="hljs-comment">/**</span><span class="hljs-comment"> * The Base Component provides the basic functionality of storing a mediator's</span><span class="hljs-comment"> * instance inside component objects.</span><span class="hljs-comment"> */</span><span class="hljs-keyword">class</span> <span class="hljs-title class_">BaseComponent</span> {<span class="hljs-keyword">protected</span>:  Mediator *mediator_;<span class="hljs-keyword">public</span>:    <span class="hljs-built_in">BaseComponent</span>(Mediator *mediator = <span class="hljs-literal">nullptr</span>) : <span class="hljs-built_in">mediator_</span>(mediator) {    }    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">set_mediator</span><span class="hljs-params">(Mediator *mediator)</span> </span>{        <span class="hljs-keyword">this</span>-&gt;mediator_ = mediator;    }};<span class="hljs-comment">/**</span><span class="hljs-comment"> * Concrete Components implement various functionality. They don't depend on</span><span class="hljs-comment"> * other components. They also don't depend on any concrete mediator classes.</span><span class="hljs-comment"> */</span><span class="hljs-keyword">class</span> <span class="hljs-title class_">Component1</span> : <span class="hljs-keyword">public</span> BaseComponent {<span class="hljs-keyword">public</span>:    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">DoA</span><span class="hljs-params">()</span> </span>{        std::cout &lt;&lt; <span class="hljs-string">"Component 1 does A.\n"</span>;        <span class="hljs-keyword">this</span>-&gt;mediator_-&gt;<span class="hljs-built_in">Notify</span>(<span class="hljs-keyword">this</span>, <span class="hljs-string">"A"</span>);    }    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">DoB</span><span class="hljs-params">()</span> </span>{        std::cout &lt;&lt; <span class="hljs-string">"Component 1 does B.\n"</span>;        <span class="hljs-keyword">this</span>-&gt;mediator_-&gt;<span class="hljs-built_in">Notify</span>(<span class="hljs-keyword">this</span>, <span class="hljs-string">"B"</span>);    }};<span class="hljs-keyword">class</span> <span class="hljs-title class_">Component2</span> : <span class="hljs-keyword">public</span> BaseComponent {<span class="hljs-keyword">public</span>:    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">DoC</span><span class="hljs-params">()</span> </span>{        std::cout &lt;&lt; <span class="hljs-string">"Component 2 does C.\n"</span>;        <span class="hljs-keyword">this</span>-&gt;mediator_-&gt;<span class="hljs-built_in">Notify</span>(<span class="hljs-keyword">this</span>, <span class="hljs-string">"C"</span>);    }    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">DoD</span><span class="hljs-params">()</span> </span>{        std::cout &lt;&lt; <span class="hljs-string">"Component 2 does D.\n"</span>;        <span class="hljs-keyword">this</span>-&gt;mediator_-&gt;<span class="hljs-built_in">Notify</span>(<span class="hljs-keyword">this</span>, <span class="hljs-string">"D"</span>);    }};<span class="hljs-comment">/**</span><span class="hljs-comment"> * Concrete Mediators implement cooperative behavior by coordinating several</span><span class="hljs-comment"> * components.</span><span class="hljs-comment"> */</span><span class="hljs-keyword">class</span> <span class="hljs-title class_">ConcreteMediator</span> : <span class="hljs-keyword">public</span> Mediator {<span class="hljs-keyword">private</span>:    Component1 *component1_;    Component2 *component2_;<span class="hljs-keyword">public</span>:    <span class="hljs-built_in">ConcreteMediator</span>(Component1 *c1, Component2 *c2) : <span class="hljs-built_in">component1_</span>(c1), <span class="hljs-built_in">component2_</span>(c2) {        <span class="hljs-keyword">this</span>-&gt;component1_-&gt;<span class="hljs-built_in">set_mediator</span>(<span class="hljs-keyword">this</span>);        <span class="hljs-keyword">this</span>-&gt;component2_-&gt;<span class="hljs-built_in">set_mediator</span>(<span class="hljs-keyword">this</span>);    }    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Notify</span><span class="hljs-params">(BaseComponent *sender, std::string event)</span> <span class="hljs-type">const</span> <span class="hljs-keyword">override</span> </span>{        <span class="hljs-keyword">if</span> (event == <span class="hljs-string">"A"</span>) {            std::cout &lt;&lt; <span class="hljs-string">"Mediator reacts on A and triggers following operations:\n"</span>;            <span class="hljs-keyword">this</span>-&gt;component2_-&gt;<span class="hljs-built_in">DoC</span>();        }        <span class="hljs-keyword">if</span> (event == <span class="hljs-string">"D"</span>) {            std::cout &lt;&lt; <span class="hljs-string">"Mediator reacts on D and triggers following operations:\n"</span>;            <span class="hljs-keyword">this</span>-&gt;component1_-&gt;<span class="hljs-built_in">DoB</span>();            <span class="hljs-keyword">this</span>-&gt;component2_-&gt;<span class="hljs-built_in">DoC</span>();        }    }};<span class="hljs-comment">/**</span><span class="hljs-comment"> * The client code.</span><span class="hljs-comment"> */</span><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">ClientCode</span><span class="hljs-params">()</span> </span>{    Component1 *c1 = <span class="hljs-keyword">new</span> Component1;    Component2 *c2 = <span class="hljs-keyword">new</span> Component2;    ConcreteMediator *mediator = <span class="hljs-keyword">new</span> <span class="hljs-built_in">ConcreteMediator</span>(c1, c2);    std::cout &lt;&lt; <span class="hljs-string">"Client triggers operation A.\n"</span>;    c1-&gt;<span class="hljs-built_in">DoA</span>();    std::cout &lt;&lt; <span class="hljs-string">"\n"</span>;    std::cout &lt;&lt; <span class="hljs-string">"Client triggers operation D.\n"</span>;    c2-&gt;<span class="hljs-built_in">DoD</span>();    <span class="hljs-keyword">delete</span> c1;    <span class="hljs-keyword">delete</span> c2;    <span class="hljs-keyword">delete</span> mediator;}<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>{    <span class="hljs-built_in">ClientCode</span>();    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;}</code></pre></div><h1><span id="bei-wang-lu-mo-shi">备忘录模式</span><a href="#bei-wang-lu-mo-shi" class="header-anchor">#</a></h1><p><strong>备忘录模式</strong>是一种行为设计模式， 允许在不暴露对象实现细节的情况下保存和恢复对象之前的状态。</p><p>适合应用场景：</p><ul><li><p><strong>当你需要创建对象状态快照来恢复其之前的状态时， 可以使用备忘录模式。</strong></p></li><li><p>备忘录模式允许你复制对象中的全部状态 （包括私有成员变量）， 并将其独立于对象进行保存。 尽管大部分人因为 “撤销” 这个用例才记得该模式， 但其实它在处理事务 （比如需要在出现错误时回滚一个操作） 的过程中也必不可少。</p></li><li><p><strong>当直接访问对象的成员变量、 获取器或设置器将导致封装被突破时， 可以使用该模式。</strong></p></li><li><p>备忘录让对象自行负责创建其状态的快照。 任何其他对象都不能读取快照， 这有效地保障了数据的安全性。</p></li></ul><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-comment">/**</span><span class="hljs-comment"> * The Memento interface provides a way to retrieve the memento's metadata, such</span><span class="hljs-comment"> * as creation date or name. However, it doesn't expose the Originator's state.</span><span class="hljs-comment"> */</span><span class="hljs-keyword">class</span> <span class="hljs-title class_">Memento</span> {<span class="hljs-keyword">public</span>:    <span class="hljs-function"><span class="hljs-keyword">virtual</span> std::string <span class="hljs-title">GetName</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>= <span class="hljs-number">0</span>;    <span class="hljs-function"><span class="hljs-keyword">virtual</span> std::string <span class="hljs-title">date</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>= <span class="hljs-number">0</span>;    <span class="hljs-function"><span class="hljs-keyword">virtual</span> std::string <span class="hljs-title">state</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>= <span class="hljs-number">0</span>;};<span class="hljs-comment">/**</span><span class="hljs-comment"> * The Concrete Memento contains the infrastructure for storing the Originator's</span><span class="hljs-comment"> * state.</span><span class="hljs-comment"> */</span><span class="hljs-keyword">class</span> <span class="hljs-title class_">ConcreteMemento</span> : <span class="hljs-keyword">public</span> Memento {<span class="hljs-keyword">private</span>:    std::string state_;    std::string date_;<span class="hljs-keyword">public</span>:    <span class="hljs-built_in">ConcreteMemento</span>(std::string state) : <span class="hljs-built_in">state_</span>(state) {        <span class="hljs-keyword">this</span>-&gt;state_ = state;        std::<span class="hljs-type">time_t</span> now = std::<span class="hljs-built_in">time</span>(<span class="hljs-number">0</span>);        <span class="hljs-keyword">this</span>-&gt;date_ = std::<span class="hljs-built_in">ctime</span>(&amp;now);    }    <span class="hljs-comment">/**</span><span class="hljs-comment">       * The Originator uses this method when restoring its state.</span><span class="hljs-comment">       */</span>    <span class="hljs-function">std::string <span class="hljs-title">state</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> <span class="hljs-keyword">override</span> </span>{        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>-&gt;state_;    }    <span class="hljs-comment">/**</span><span class="hljs-comment">       * The rest of the methods are used by the Caretaker to display metadata.</span><span class="hljs-comment">       */</span>    <span class="hljs-function">std::string <span class="hljs-title">GetName</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> <span class="hljs-keyword">override</span> </span>{        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>-&gt;date_ + <span class="hljs-string">" / ("</span> + <span class="hljs-keyword">this</span>-&gt;state_.<span class="hljs-built_in">substr</span>(<span class="hljs-number">0</span>, <span class="hljs-number">9</span>) + <span class="hljs-string">"...)"</span>;    }    <span class="hljs-function">std::string <span class="hljs-title">date</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> <span class="hljs-keyword">override</span> </span>{        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>-&gt;date_;    }};<span class="hljs-comment">/**</span><span class="hljs-comment"> * The Originator holds some important state that may change over time. It also</span><span class="hljs-comment"> * defines a method for saving the state inside a memento and another method for</span><span class="hljs-comment"> * restoring the state from it.</span><span class="hljs-comment"> */</span><span class="hljs-keyword">class</span> <span class="hljs-title class_">Originator</span> {  <span class="hljs-comment">/**</span><span class="hljs-comment">   * @var string For the sake of simplicity, the originator's state is stored</span><span class="hljs-comment">   * inside a single variable.</span><span class="hljs-comment">   */</span><span class="hljs-keyword">private</span>:    std::string state_;    <span class="hljs-function">std::string <span class="hljs-title">GenerateRandomString</span><span class="hljs-params">(<span class="hljs-type">int</span> length = <span class="hljs-number">10</span>)</span> </span>{        <span class="hljs-type">const</span> <span class="hljs-type">char</span> alphanum[] =            <span class="hljs-string">"0123456789"</span>            <span class="hljs-string">"ABCDEFGHIJKLMNOPQRSTUVWXYZ"</span>            <span class="hljs-string">"abcdefghijklmnopqrstuvwxyz"</span>;        <span class="hljs-type">int</span> stringLength = <span class="hljs-built_in">sizeof</span>(alphanum) - <span class="hljs-number">1</span>;        std::string random_string;        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; length; i++) {            random_string += alphanum[std::<span class="hljs-built_in">rand</span>() % stringLength];        }        <span class="hljs-keyword">return</span> random_string;    }<span class="hljs-keyword">public</span>:    <span class="hljs-built_in">Originator</span>(std::string state) : <span class="hljs-built_in">state_</span>(state) {        std::cout &lt;&lt; <span class="hljs-string">"Originator: My initial state is: "</span> &lt;&lt; <span class="hljs-keyword">this</span>-&gt;state_ &lt;&lt; <span class="hljs-string">"\n"</span>;    }    <span class="hljs-comment">/**</span><span class="hljs-comment">       * The Originator's business logic may affect its internal state. Therefore,</span><span class="hljs-comment">       * the client should backup the state before launching methods of the business</span><span class="hljs-comment">       * logic via the save() method.</span><span class="hljs-comment">       */</span>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">DoSomething</span><span class="hljs-params">()</span> </span>{        std::cout &lt;&lt; <span class="hljs-string">"Originator: I'm doing something important.\n"</span>;        <span class="hljs-keyword">this</span>-&gt;state_ = <span class="hljs-keyword">this</span>-&gt;<span class="hljs-built_in">GenerateRandomString</span>(<span class="hljs-number">30</span>);        std::cout &lt;&lt; <span class="hljs-string">"Originator: and my state has changed to: "</span> &lt;&lt; <span class="hljs-keyword">this</span>-&gt;state_ &lt;&lt; <span class="hljs-string">"\n"</span>;    }    <span class="hljs-comment">/**</span><span class="hljs-comment">       * Saves the current state inside a memento.</span><span class="hljs-comment">       */</span>    <span class="hljs-function">Memento *<span class="hljs-title">Save</span><span class="hljs-params">()</span> </span>{        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">ConcreteMemento</span>(<span class="hljs-keyword">this</span>-&gt;state_);    }    <span class="hljs-comment">/**</span><span class="hljs-comment">       * Restores the Originator's state from a memento object.</span><span class="hljs-comment">       */</span>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Restore</span><span class="hljs-params">(Memento *memento)</span> </span>{        <span class="hljs-keyword">this</span>-&gt;state_ = memento-&gt;<span class="hljs-built_in">state</span>();        std::cout &lt;&lt; <span class="hljs-string">"Originator: My state has changed to: "</span> &lt;&lt; <span class="hljs-keyword">this</span>-&gt;state_ &lt;&lt; <span class="hljs-string">"\n"</span>;    }};<span class="hljs-comment">/**</span><span class="hljs-comment"> * The Caretaker doesn't depend on the Concrete Memento class. Therefore, it</span><span class="hljs-comment"> * doesn't have access to the originator's state, stored inside the memento. It</span><span class="hljs-comment"> * works with all mementos via the base Memento interface.</span><span class="hljs-comment"> */</span><span class="hljs-keyword">class</span> <span class="hljs-title class_">Caretaker</span> {  <span class="hljs-comment">/**</span><span class="hljs-comment">   * @var Memento[]</span><span class="hljs-comment">   */</span><span class="hljs-keyword">private</span>:    std::vector&lt;Memento *&gt; mementos_;    <span class="hljs-comment">/**</span><span class="hljs-comment">       * @var Originator</span><span class="hljs-comment">       */</span>    Originator *originator_;<span class="hljs-keyword">public</span>:    <span class="hljs-built_in">Caretaker</span>(Originator *originator) : <span class="hljs-built_in">originator_</span>(originator) {        <span class="hljs-keyword">this</span>-&gt;originator_ = originator;    }    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Backup</span><span class="hljs-params">()</span> </span>{        std::cout &lt;&lt; <span class="hljs-string">"\nCaretaker: Saving Originator's state...\n"</span>;        <span class="hljs-keyword">this</span>-&gt;mementos_.<span class="hljs-built_in">push_back</span>(<span class="hljs-keyword">this</span>-&gt;originator_-&gt;<span class="hljs-built_in">Save</span>());    }    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Undo</span><span class="hljs-params">()</span> </span>{        <span class="hljs-keyword">if</span> (!<span class="hljs-keyword">this</span>-&gt;mementos_.<span class="hljs-built_in">size</span>()) {            <span class="hljs-keyword">return</span>;        }        Memento *memento = <span class="hljs-keyword">this</span>-&gt;mementos_.<span class="hljs-built_in">back</span>();        <span class="hljs-keyword">this</span>-&gt;mementos_.<span class="hljs-built_in">pop_back</span>();        std::cout &lt;&lt; <span class="hljs-string">"Caretaker: Restoring state to: "</span> &lt;&lt; memento-&gt;<span class="hljs-built_in">GetName</span>() &lt;&lt; <span class="hljs-string">"\n"</span>;        <span class="hljs-keyword">try</span> {            <span class="hljs-keyword">this</span>-&gt;originator_-&gt;<span class="hljs-built_in">Restore</span>(memento);        } <span class="hljs-built_in">catch</span> (...) {            <span class="hljs-keyword">this</span>-&gt;<span class="hljs-built_in">Undo</span>();        }    }    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">ShowHistory</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>{        std::cout &lt;&lt; <span class="hljs-string">"Caretaker: Here's the list of mementos:\n"</span>;        <span class="hljs-keyword">for</span> (Memento *memento : <span class="hljs-keyword">this</span>-&gt;mementos_) {            std::cout &lt;&lt; memento-&gt;<span class="hljs-built_in">GetName</span>() &lt;&lt; <span class="hljs-string">"\n"</span>;        }    }};<span class="hljs-comment">/**</span><span class="hljs-comment"> * Client code.</span><span class="hljs-comment"> */</span><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">ClientCode</span><span class="hljs-params">()</span> </span>{    Originator *originator = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Originator</span>(<span class="hljs-string">"Super-duper-super-puper-super."</span>);    Caretaker *caretaker = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Caretaker</span>(originator);    caretaker-&gt;<span class="hljs-built_in">Backup</span>();    originator-&gt;<span class="hljs-built_in">DoSomething</span>();    caretaker-&gt;<span class="hljs-built_in">Backup</span>();    originator-&gt;<span class="hljs-built_in">DoSomething</span>();    caretaker-&gt;<span class="hljs-built_in">Backup</span>();    originator-&gt;<span class="hljs-built_in">DoSomething</span>();    std::cout &lt;&lt; <span class="hljs-string">"\n"</span>;    caretaker-&gt;<span class="hljs-built_in">ShowHistory</span>();    std::cout &lt;&lt; <span class="hljs-string">"\nClient: Now, let's rollback!\n\n"</span>;    caretaker-&gt;<span class="hljs-built_in">Undo</span>();    std::cout &lt;&lt; <span class="hljs-string">"\nClient: Once more!\n\n"</span>;    caretaker-&gt;<span class="hljs-built_in">Undo</span>();    <span class="hljs-keyword">delete</span> originator;    <span class="hljs-keyword">delete</span> caretaker;}<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>{    std::<span class="hljs-built_in">srand</span>(<span class="hljs-built_in">static_cast</span>&lt;<span class="hljs-type">unsigned</span> <span class="hljs-type">int</span>&gt;(std::<span class="hljs-built_in">time</span>(<span class="hljs-literal">NULL</span>)));    <span class="hljs-built_in">ClientCode</span>();    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;}</code></pre></div><h1><span id="zhuang-tai-mo-shi">状态模式</span><a href="#zhuang-tai-mo-shi" class="header-anchor">#</a></h1><p><strong>状态模式</strong>是一种行为设计模式， 让你能在一个对象的内部状态变化时改变其行为， 使其看上去就像改变了自身所属的类一样。</p><p>适合应用场景:</p><ul><li><p><strong>如果对象需要根据自身当前状态进行不同行为， 同时状态的数量非常多且与状态相关的代码会频繁变更的话， 可使用状态模式。</strong></p></li><li><p>模式建议你将所有特定于状态的代码抽取到一组独立的类中。 这样一来， 你可以在独立于其他状态的情况下添加新状态或修改已有状态， 从而减少维护成本。</p></li><li><p><strong>如果某个类需要根据成员变量的当前值改变自身行为， 从而需要使用大量的条件语句时， 可使用该模式。</strong></p></li><li><p>状态模式会将这些条件语句的分支抽取到相应状态类的方法中。 同时， 你还可以清除主要类中与特定状态相关的临时成员变量和帮手方法代码。</p></li><li><p><strong>当相似状态和基于条件的状态机转换中存在许多重复代码时， 可使用状态模式。</strong></p></li><li><p>状态模式让你能够生成状态类层次结构， 通过将公用代码抽取到抽象基类中来<code>减少重复</code>。</p></li></ul><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;typeinfo&gt;</span></span><span class="hljs-comment">/**</span><span class="hljs-comment"> * The base State class declares methods that all Concrete State should</span><span class="hljs-comment"> * implement and also provides a backreference to the Context object, associated</span><span class="hljs-comment"> * with the State. This backreference can be used by States to transition the</span><span class="hljs-comment"> * Context to another State.</span><span class="hljs-comment"> */</span><span class="hljs-keyword">class</span> <span class="hljs-title class_">Context</span>;<span class="hljs-keyword">class</span> <span class="hljs-title class_">State</span> {  <span class="hljs-comment">/**</span><span class="hljs-comment">   * @var Context</span><span class="hljs-comment">   */</span><span class="hljs-keyword">protected</span>:  Context *context_;<span class="hljs-keyword">public</span>:    <span class="hljs-keyword">virtual</span> ~<span class="hljs-built_in">State</span>() {    }    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">set_context</span><span class="hljs-params">(Context *context)</span> </span>{        <span class="hljs-keyword">this</span>-&gt;context_ = context;    }    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">Handle1</span><span class="hljs-params">()</span> </span>= <span class="hljs-number">0</span>;    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">Handle2</span><span class="hljs-params">()</span> </span>= <span class="hljs-number">0</span>;};<span class="hljs-comment">/**</span><span class="hljs-comment"> * The Context defines the interface of interest to clients. It also maintains a</span><span class="hljs-comment"> * reference to an instance of a State subclass, which represents the current</span><span class="hljs-comment"> * state of the Context.</span><span class="hljs-comment"> */</span><span class="hljs-keyword">class</span> <span class="hljs-title class_">Context</span> {  <span class="hljs-comment">/**</span><span class="hljs-comment">   * @var State A reference to the current state of the Context.</span><span class="hljs-comment">   */</span><span class="hljs-keyword">private</span>:  State *state_;<span class="hljs-keyword">public</span>:    <span class="hljs-built_in">Context</span>(State *state) : <span class="hljs-built_in">state_</span>(<span class="hljs-literal">nullptr</span>) {        <span class="hljs-keyword">this</span>-&gt;<span class="hljs-built_in">TransitionTo</span>(state);    }    ~<span class="hljs-built_in">Context</span>() {        <span class="hljs-keyword">delete</span> state_;    }    <span class="hljs-comment">/**</span><span class="hljs-comment">       * The Context allows changing the State object at runtime.</span><span class="hljs-comment">       */</span>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">TransitionTo</span><span class="hljs-params">(State *state)</span> </span>{        std::cout &lt;&lt; <span class="hljs-string">"Context: Transition to "</span> &lt;&lt; <span class="hljs-built_in">typeid</span>(*state).<span class="hljs-built_in">name</span>() &lt;&lt; <span class="hljs-string">".\n"</span>;        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>-&gt;state_ != <span class="hljs-literal">nullptr</span>)            <span class="hljs-keyword">delete</span> <span class="hljs-keyword">this</span>-&gt;state_;        <span class="hljs-keyword">this</span>-&gt;state_ = state;        <span class="hljs-keyword">this</span>-&gt;state_-&gt;<span class="hljs-built_in">set_context</span>(<span class="hljs-keyword">this</span>);    }    <span class="hljs-comment">/**</span><span class="hljs-comment">       * The Context delegates part of its behavior to the current State object.</span><span class="hljs-comment">       */</span>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Request1</span><span class="hljs-params">()</span> </span>{        <span class="hljs-keyword">this</span>-&gt;state_-&gt;<span class="hljs-built_in">Handle1</span>();    }    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Request2</span><span class="hljs-params">()</span> </span>{        <span class="hljs-keyword">this</span>-&gt;state_-&gt;<span class="hljs-built_in">Handle2</span>();    }};<span class="hljs-comment">/**</span><span class="hljs-comment"> * Concrete States implement various behaviors, associated with a state of the</span><span class="hljs-comment"> * Context.</span><span class="hljs-comment"> */</span><span class="hljs-keyword">class</span> <span class="hljs-title class_">ConcreteStateA</span> : <span class="hljs-keyword">public</span> State {<span class="hljs-keyword">public</span>:    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Handle1</span><span class="hljs-params">()</span> <span class="hljs-keyword">override</span></span>;    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Handle2</span><span class="hljs-params">()</span> <span class="hljs-keyword">override</span> </span>{        std::cout &lt;&lt; <span class="hljs-string">"ConcreteStateA handles request2.\n"</span>;    }};<span class="hljs-keyword">class</span> <span class="hljs-title class_">ConcreteStateB</span> : <span class="hljs-keyword">public</span> State {<span class="hljs-keyword">public</span>:    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Handle1</span><span class="hljs-params">()</span> <span class="hljs-keyword">override</span> </span>{        std::cout &lt;&lt; <span class="hljs-string">"ConcreteStateB handles request1.\n"</span>;    }    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Handle2</span><span class="hljs-params">()</span> <span class="hljs-keyword">override</span> </span>{        std::cout &lt;&lt; <span class="hljs-string">"ConcreteStateB handles request2.\n"</span>;        std::cout &lt;&lt; <span class="hljs-string">"ConcreteStateB wants to change the state of the context.\n"</span>;        <span class="hljs-keyword">this</span>-&gt;context_-&gt;<span class="hljs-built_in">TransitionTo</span>(<span class="hljs-keyword">new</span> ConcreteStateA);    }};<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">ConcreteStateA::Handle1</span><span class="hljs-params">()</span> </span>{    std::cout &lt;&lt; <span class="hljs-string">"ConcreteStateA handles request1.\n"</span>;    std::cout &lt;&lt; <span class="hljs-string">"ConcreteStateA wants to change the state of the context.\n"</span>;    <span class="hljs-keyword">this</span>-&gt;context_-&gt;<span class="hljs-built_in">TransitionTo</span>(<span class="hljs-keyword">new</span> ConcreteStateB);}<span class="hljs-comment">/**</span><span class="hljs-comment"> * The client code.</span><span class="hljs-comment"> */</span><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">ClientCode</span><span class="hljs-params">()</span> </span>{    Context *context = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Context</span>(<span class="hljs-keyword">new</span> ConcreteStateA);    context-&gt;<span class="hljs-built_in">Request1</span>();    context-&gt;<span class="hljs-built_in">Request2</span>();    <span class="hljs-keyword">delete</span> context;}<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>{    <span class="hljs-built_in">ClientCode</span>();    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;}</code></pre></div><h1><span id="ce-lue-mo-shi">策略模式</span><a href="#ce-lue-mo-shi" class="header-anchor">#</a></h1><p><strong>策略模式</strong>是一种行为设计模式， 它能让你定义一系列算法， 并将每种算法分别放入独立的类中， 以使算法的对象能够相互替换。</p><p>适合应用场景:</p><ul><li><p><strong>当你想使用对象中各种不同的算法变体， 并希望能在运行时切换算法时， 可使用策略模式。</strong></p></li><li><p>策略模式让你能够将对象关联至可以不同方式执行特定子任务的不同子对象， 从而以间接方式在运行时更改对象行为。</p></li><li><p><strong>当你有许多仅在执行某些行为时略有不同的相似类时， 可使用策略模式。</strong></p></li><li><p>策略模式让你能将不同行为抽取到一个独立类层次结构中， 并将原始类组合成同一个， 从而减少重复代码。</p></li><li><p><strong>如果算法在上下文的逻辑中不是特别重要， 使用该模式能将类的业务逻辑与其算法实现细节隔离开来。</strong></p></li><li><p>策略模式让你能将各种算法的代码、 内部数据和依赖关系与其他代码隔离开来。 不同客户端可通过一个简单接口执行算法， 并能在运行时进行切换。</p></li><li><p><strong>当类中使用了复杂条件运算符以在同一算法的不同变体中切换时， 可使用该模式。</strong></p></li><li><p>策略模式将所有继承自同样接口的算法抽取到独立类中， 因此不再需要条件语句。 原始对象并不实现所有算法的变体， 而是将执行工作委派给其中的一个独立算法对象。</p></li></ul><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-comment">/**</span><span class="hljs-comment"> * The Strategy interface declares operations common to all supported versions</span><span class="hljs-comment"> * of some algorithm.</span><span class="hljs-comment"> *</span><span class="hljs-comment"> * The Context uses this interface to call the algorithm defined by Concrete</span><span class="hljs-comment"> * Strategies.</span><span class="hljs-comment"> */</span><span class="hljs-keyword">class</span> <span class="hljs-title class_">Strategy</span>{<span class="hljs-keyword">public</span>:    <span class="hljs-keyword">virtual</span> ~<span class="hljs-built_in">Strategy</span>() {}    <span class="hljs-function"><span class="hljs-keyword">virtual</span> std::string <span class="hljs-title">DoAlgorithm</span><span class="hljs-params">(<span class="hljs-type">const</span> std::vector&lt;std::string&gt; &amp;data)</span> <span class="hljs-type">const</span> </span>= <span class="hljs-number">0</span>;};<span class="hljs-comment">/**</span><span class="hljs-comment"> * The Context defines the interface of interest to clients.</span><span class="hljs-comment"> */</span><span class="hljs-keyword">class</span> <span class="hljs-title class_">Context</span>{    <span class="hljs-comment">/**</span><span class="hljs-comment">     * @var Strategy The Context maintains a reference to one of the Strategy</span><span class="hljs-comment">     * objects. The Context does not know the concrete class of a strategy. It</span><span class="hljs-comment">     * should work with all strategies via the Strategy interface.</span><span class="hljs-comment">     */</span><span class="hljs-keyword">private</span>:    Strategy *strategy_;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * Usually, the Context accepts a strategy through the constructor, but also</span><span class="hljs-comment">     * provides a setter to change it at runtime.</span><span class="hljs-comment">     */</span><span class="hljs-keyword">public</span>:    <span class="hljs-built_in">Context</span>(Strategy *strategy = <span class="hljs-literal">nullptr</span>) : <span class="hljs-built_in">strategy_</span>(strategy)    {    }    ~<span class="hljs-built_in">Context</span>()    {        <span class="hljs-keyword">delete</span> <span class="hljs-keyword">this</span>-&gt;strategy_;    }    <span class="hljs-comment">/**</span><span class="hljs-comment">     * Usually, the Context allows replacing a Strategy object at runtime.</span><span class="hljs-comment">     */</span>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">set_strategy</span><span class="hljs-params">(Strategy *strategy)</span></span><span class="hljs-function">    </span>{        <span class="hljs-keyword">delete</span> <span class="hljs-keyword">this</span>-&gt;strategy_;        <span class="hljs-keyword">this</span>-&gt;strategy_ = strategy;    }    <span class="hljs-comment">/**</span><span class="hljs-comment">     * The Context delegates some work to the Strategy object instead of</span><span class="hljs-comment">     * implementing +multiple versions of the algorithm on its own.</span><span class="hljs-comment">     */</span>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">DoSomeBusinessLogic</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span><span class="hljs-function">    </span>{        <span class="hljs-comment">// ...</span>        std::cout &lt;&lt; <span class="hljs-string">"Context: Sorting data using the strategy (not sure how it'll do it)\n"</span>;        std::string result = <span class="hljs-keyword">this</span>-&gt;strategy_-&gt;<span class="hljs-built_in">DoAlgorithm</span>(std::vector&lt;std::string&gt;{<span class="hljs-string">"a"</span>, <span class="hljs-string">"e"</span>, <span class="hljs-string">"c"</span>, <span class="hljs-string">"b"</span>, <span class="hljs-string">"d"</span>});        std::cout &lt;&lt; result &lt;&lt; <span class="hljs-string">"\n"</span>;        <span class="hljs-comment">// ...</span>    }};<span class="hljs-comment">/**</span><span class="hljs-comment"> * Concrete Strategies implement the algorithm while following the base Strategy</span><span class="hljs-comment"> * interface. The interface makes them interchangeable in the Context.</span><span class="hljs-comment"> */</span><span class="hljs-keyword">class</span> <span class="hljs-title class_">ConcreteStrategyA</span> : <span class="hljs-keyword">public</span> Strategy{<span class="hljs-keyword">public</span>:    <span class="hljs-function">std::string <span class="hljs-title">DoAlgorithm</span><span class="hljs-params">(<span class="hljs-type">const</span> std::vector&lt;std::string&gt; &amp;data)</span> <span class="hljs-type">const</span> <span class="hljs-keyword">override</span></span><span class="hljs-function">    </span>{        std::string result;        std::for_each(std::<span class="hljs-built_in">begin</span>(data), std::<span class="hljs-built_in">end</span>(data), [&amp;result](<span class="hljs-type">const</span> std::string &amp;letter) {            result += letter;        });        std::<span class="hljs-built_in">sort</span>(std::<span class="hljs-built_in">begin</span>(result), std::<span class="hljs-built_in">end</span>(result));        <span class="hljs-keyword">return</span> result;    }};<span class="hljs-keyword">class</span> <span class="hljs-title class_">ConcreteStrategyB</span> : <span class="hljs-keyword">public</span> Strategy{    <span class="hljs-function">std::string <span class="hljs-title">DoAlgorithm</span><span class="hljs-params">(<span class="hljs-type">const</span> std::vector&lt;std::string&gt; &amp;data)</span> <span class="hljs-type">const</span> <span class="hljs-keyword">override</span></span><span class="hljs-function">    </span>{        std::string result;        std::for_each(std::<span class="hljs-built_in">begin</span>(data), std::<span class="hljs-built_in">end</span>(data), [&amp;result](<span class="hljs-type">const</span> std::string &amp;letter) {            result += letter;        });        std::<span class="hljs-built_in">sort</span>(std::<span class="hljs-built_in">begin</span>(result), std::<span class="hljs-built_in">end</span>(result));        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; result.<span class="hljs-built_in">size</span>() / <span class="hljs-number">2</span>; i++)        {            std::<span class="hljs-built_in">swap</span>(result[i], result[result.<span class="hljs-built_in">size</span>() - i - <span class="hljs-number">1</span>]);        }        <span class="hljs-keyword">return</span> result;    }};<span class="hljs-comment">/**</span><span class="hljs-comment"> * The client code picks a concrete strategy and passes it to the context. The</span><span class="hljs-comment"> * client should be aware of the differences between strategies in order to make</span><span class="hljs-comment"> * the right choice.</span><span class="hljs-comment"> */</span><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">ClientCode</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>{    Context *context = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Context</span>(<span class="hljs-keyword">new</span> ConcreteStrategyA);    std::cout &lt;&lt; <span class="hljs-string">"Client: Strategy is set to normal sorting.\n"</span>;    context-&gt;<span class="hljs-built_in">DoSomeBusinessLogic</span>();    std::cout &lt;&lt; <span class="hljs-string">"\n"</span>;    std::cout &lt;&lt; <span class="hljs-string">"Client: Strategy is set to reverse sorting.\n"</span>;    context-&gt;<span class="hljs-built_in">set_strategy</span>(<span class="hljs-keyword">new</span> ConcreteStrategyB);    context-&gt;<span class="hljs-built_in">DoSomeBusinessLogic</span>();    <span class="hljs-keyword">delete</span> context;}<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>{    <span class="hljs-built_in">ClientCode</span>();    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;}</code></pre></div><h1><span id="mo-ban-fang-fa-mo-shi">模板方法模式</span><a href="#mo-ban-fang-fa-mo-shi" class="header-anchor">#</a></h1><p><strong>模板方法模式</strong>是一种行为设计模式， 它在超类中定义了一个算法的框架， 允许子类在不修改结构的情况下重写算法的特定步骤。</p><p>适合应用场景:</p><ul><li><p><strong>当你只希望客户端扩展某个特定算法步骤， 而不是整个算法或其结构时， 可使用模板方法模式。</strong></p></li><li><p>模板方法将整个算法转换为一系列独立的步骤， 以便子类能对其进行扩展， 同时还可让超类中所定义的结构保持完整。</p></li><li><p><strong>当多个类的算法除一些细微不同之外几乎完全一样时， 你可使用该模式。 但其后果就是， 只要算法发生变化， 你就可能需要修改所有的类。</strong></p></li><li><p>在将算法转换为模板方法时， 你可将相似的实现步骤提取到超类中以去除重复代码。 子类间各不同的代码可继续保留在子类中。</p></li></ul><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-comment">/**</span><span class="hljs-comment"> * The Abstract Class defines a template method that contains a skeleton of some</span><span class="hljs-comment"> * algorithm, composed of calls to (usually) abstract primitive operations.</span><span class="hljs-comment"> *</span><span class="hljs-comment"> * Concrete subclasses should implement these operations, but leave the template</span><span class="hljs-comment"> * method itself intact.</span><span class="hljs-comment"> */</span><span class="hljs-keyword">class</span> <span class="hljs-title class_">AbstractClass</span> {  <span class="hljs-comment">/**</span><span class="hljs-comment">   * The template method defines the skeleton of an algorithm.</span><span class="hljs-comment">   */</span><span class="hljs-keyword">public</span>:    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">TemplateMethod</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>{        <span class="hljs-keyword">this</span>-&gt;<span class="hljs-built_in">BaseOperation1</span>();        <span class="hljs-keyword">this</span>-&gt;<span class="hljs-built_in">RequiredOperations1</span>();        <span class="hljs-keyword">this</span>-&gt;<span class="hljs-built_in">BaseOperation2</span>();        <span class="hljs-keyword">this</span>-&gt;<span class="hljs-built_in">Hook1</span>();        <span class="hljs-keyword">this</span>-&gt;<span class="hljs-built_in">RequiredOperation2</span>();        <span class="hljs-keyword">this</span>-&gt;<span class="hljs-built_in">BaseOperation3</span>();        <span class="hljs-keyword">this</span>-&gt;<span class="hljs-built_in">Hook2</span>();    }  <span class="hljs-comment">/**</span><span class="hljs-comment">   * These operations already have implementations.</span><span class="hljs-comment">   */</span><span class="hljs-keyword">protected</span>:    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">BaseOperation1</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>{        std::cout &lt;&lt; <span class="hljs-string">"AbstractClass says: I am doing the bulk of the work\n"</span>;    }    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">BaseOperation2</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>{        std::cout &lt;&lt; <span class="hljs-string">"AbstractClass says: But I let subclasses override some operations\n"</span>;    }    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">BaseOperation3</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>{        std::cout &lt;&lt; <span class="hljs-string">"AbstractClass says: But I am doing the bulk of the work anyway\n"</span>;    }    <span class="hljs-comment">/**</span><span class="hljs-comment">       * These operations have to be implemented in subclasses.</span><span class="hljs-comment">       */</span>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">RequiredOperations1</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>= <span class="hljs-number">0</span>;    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">RequiredOperation2</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>= <span class="hljs-number">0</span>;    <span class="hljs-comment">/**</span><span class="hljs-comment">       * These are "hooks." Subclasses may override them, but it's not mandatory</span><span class="hljs-comment">       * since the hooks already have default (but empty) implementation. Hooks</span><span class="hljs-comment">       * provide additional extension points in some crucial places of the</span><span class="hljs-comment">       * algorithm.</span><span class="hljs-comment">       */</span>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">Hook1</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>{}    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">Hook2</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>{}};<span class="hljs-comment">/**</span><span class="hljs-comment"> * Concrete classes have to implement all abstract operations of the base class.</span><span class="hljs-comment"> * They can also override some operations with a default implementation.</span><span class="hljs-comment"> */</span><span class="hljs-keyword">class</span> <span class="hljs-title class_">ConcreteClass1</span> : <span class="hljs-keyword">public</span> AbstractClass {<span class="hljs-keyword">protected</span>:    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">RequiredOperations1</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> <span class="hljs-keyword">override</span> </span>{        std::cout &lt;&lt; <span class="hljs-string">"ConcreteClass1 says: Implemented Operation1\n"</span>;    }    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">RequiredOperation2</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> <span class="hljs-keyword">override</span> </span>{        std::cout &lt;&lt; <span class="hljs-string">"ConcreteClass1 says: Implemented Operation2\n"</span>;    }};<span class="hljs-comment">/**</span><span class="hljs-comment"> * Usually, concrete classes override only a fraction of base class' operations.</span><span class="hljs-comment"> */</span><span class="hljs-keyword">class</span> <span class="hljs-title class_">ConcreteClass2</span> : <span class="hljs-keyword">public</span> AbstractClass {<span class="hljs-keyword">protected</span>:    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">RequiredOperations1</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> <span class="hljs-keyword">override</span> </span>{        std::cout &lt;&lt; <span class="hljs-string">"ConcreteClass2 says: Implemented Operation1\n"</span>;    }    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">RequiredOperation2</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> <span class="hljs-keyword">override</span> </span>{        std::cout &lt;&lt; <span class="hljs-string">"ConcreteClass2 says: Implemented Operation2\n"</span>;    }    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Hook1</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> <span class="hljs-keyword">override</span> </span>{        std::cout &lt;&lt; <span class="hljs-string">"ConcreteClass2 says: Overridden Hook1\n"</span>;    }};<span class="hljs-comment">/**</span><span class="hljs-comment"> * The client code calls the template method to execute the algorithm. Client</span><span class="hljs-comment"> * code does not have to know the concrete class of an object it works with, as</span><span class="hljs-comment"> * long as it works with objects through the interface of their base class.</span><span class="hljs-comment"> */</span><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">ClientCode</span><span class="hljs-params">(AbstractClass *class_)</span> </span>{    <span class="hljs-comment">// ...</span>    class_-&gt;<span class="hljs-built_in">TemplateMethod</span>();    <span class="hljs-comment">// ...</span>}<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>{    std::cout &lt;&lt; <span class="hljs-string">"Same client code can work with different subclasses:\n"</span>;    ConcreteClass1 *concreteClass1 = <span class="hljs-keyword">new</span> ConcreteClass1;    <span class="hljs-built_in">ClientCode</span>(concreteClass1);    std::cout &lt;&lt; <span class="hljs-string">"\n"</span>;    std::cout &lt;&lt; <span class="hljs-string">"Same client code can work with different subclasses:\n"</span>;    ConcreteClass2 *concreteClass2 = <span class="hljs-keyword">new</span> ConcreteClass2;    <span class="hljs-built_in">ClientCode</span>(concreteClass2);    <span class="hljs-keyword">delete</span> concreteClass1;    <span class="hljs-keyword">delete</span> concreteClass2;    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;}</code></pre></div>]]></content>
    
    
    
    <tags>
      
      <tag>设计模式</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C++设计模式-结构型模式</title>
    <link href="/2022/01/03/C-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E7%BB%93%E6%9E%84%E5%9E%8B%E6%A8%A1%E5%BC%8F/"/>
    <url>/2022/01/03/C-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E7%BB%93%E6%9E%84%E5%9E%8B%E6%A8%A1%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<div class="toc"><!-- toc --><ul><li><a href="#dai-li-mo-shi">代理模式</a></li><li><a href="#gua-pei-qi-mo-shi">适配器模式</a></li><li><a href="#qiao-jie-mo-shi">桥接模式</a></li><li><a href="#zu-he-mo-shi">组合模式</a></li><li><a href="#zhuang-shi-mo-shi">装饰模式</a></li><li><a href="#wai-guan-mo-shi">外观模式</a></li><li><a href="#xiang-yuan-mo-shi">享元模式</a></li></ul><!-- tocstop --></div><p>推荐看👉<a href="https://refactoringguru.cn/design-patterns">常用设计模式有哪些？ (refactoringguru.cn)</a></p><h1><span id="dai-li-mo-shi">代理模式</span><a href="#dai-li-mo-shi" class="header-anchor">#</a></h1><p>解释</p><blockquote><p>对真正要被访问的产品或类加以控制，并可以进行一些控制，把访问产品与代理进行映射，访问代理就相当于访问产品</p></blockquote><p>适用场景：</p><p>使用代理模式的方式多种多样， 我们来看看最常见的几种。</p><ul><li><p><strong>延迟初始化 （虚拟代理）。 如果你有一个偶尔使用的重量级服务对象， 一直保持该对象运行会消耗系统资源时， 可使用代理模式。</strong></p></li><li><p>你无需在程序启动时就创建该对象， 可将对象的初始化延迟到真正有需要的时候。</p></li><li><p><strong>访问控制 （保护代理）。 如果你只希望特定客户端使用服务对象， 这里的对象可以是操作系统中非常重要的部分， 而客户端则是各种已启动的程序 （包括恶意程序）， 此时可使用代理模式。</strong></p></li><li><p>代理可仅在客户端凭据满足要求时将请求传递给服务对象。</p></li><li><p><strong>本地执行远程服务 （远程代理）。 适用于服务对象位于远程服务器上的情形。</strong></p></li><li><p>在这种情形中， 代理通过网络传递客户端请求， 负责处理所有与网络相关的复杂细节。</p></li><li><p><strong>记录日志请求 （日志记录代理）。 适用于当你需要保存对于服务对象的请求历史记录时。 代理可以在向服务传递请求前进行记录。</strong></p></li><li><p>缓存请求结果 （缓存代理）。 适用于需要缓存客户请求结果并对缓存生命周期进行管理时， 特别是当返回结果的体积非常大时。</p></li><li><p>代理可对重复请求所需的相同结果进行缓存， 还可使用请求参数作为索引缓存的键值。</p></li><li><p><strong>智能引用。 可在没有客户端使用某个重量级对象时立即销毁该对象。</strong></p></li><li><p>代理会将所有获取了指向服务对象或其结果的客户端记录在案。 代理会时不时地遍历各个客户端， 检查它们是否仍在运行。 如果相应的客户端列表为空， 代理就会销毁该服务对象， 释放底层系统资源。</p></li><li><p>代理还可以记录客户端是否修改了服务对象。 其他客户端还可以复用未修改的对象。</p></li></ul><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Subject</span> {<span class="hljs-keyword">public</span>:  <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">Request</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>= <span class="hljs-number">0</span>;};<span class="hljs-comment">/**</span><span class="hljs-comment"> * The RealSubject contains some core business logic. Usually, RealSubjects are</span><span class="hljs-comment"> * capable of doing some useful work which may also be very slow or sensitive -</span><span class="hljs-comment"> * e.g. correcting input data. A Proxy can solve these issues without any</span><span class="hljs-comment"> * changes to the RealSubject's code.</span><span class="hljs-comment"> */</span><span class="hljs-keyword">class</span> <span class="hljs-title class_">RealSubject</span> : <span class="hljs-keyword">public</span> Subject {<span class="hljs-keyword">public</span>:  <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Request</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> <span class="hljs-keyword">override</span> </span>{    std::cout &lt;&lt; <span class="hljs-string">"RealSubject: Handling request.\n"</span>;  }};<span class="hljs-comment">/**</span><span class="hljs-comment"> * The Proxy has an interface identical to the RealSubject.</span><span class="hljs-comment"> */</span><span class="hljs-keyword">class</span> <span class="hljs-title class_">Proxy</span> : <span class="hljs-keyword">public</span> Subject {  <span class="hljs-comment">/**</span><span class="hljs-comment">   * @var RealSubject</span><span class="hljs-comment">   */</span><span class="hljs-keyword">private</span>:  RealSubject *real_subject_;    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">CheckAccess</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>{        <span class="hljs-comment">// Some real checks should go here.</span>        std::cout &lt;&lt; <span class="hljs-string">"Proxy: Checking access prior to firing a real request.\n"</span>;        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;    }    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">LogAccess</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>{        std::cout &lt;&lt; <span class="hljs-string">"Proxy: Logging the time of request.\n"</span>;    }  <span class="hljs-comment">/**</span><span class="hljs-comment">   * The Proxy maintains a reference to an object of the RealSubject class. It</span><span class="hljs-comment">   * can be either lazy-loaded or passed to the Proxy by the client.</span><span class="hljs-comment">   */</span><span class="hljs-keyword">public</span>:    <span class="hljs-built_in">Proxy</span>(RealSubject *real_subject) : <span class="hljs-built_in">real_subject_</span>(<span class="hljs-keyword">new</span> <span class="hljs-built_in">RealSubject</span>(*real_subject)) {    }    ~<span class="hljs-built_in">Proxy</span>() {        <span class="hljs-keyword">delete</span> real_subject_;    }  <span class="hljs-comment">/**</span><span class="hljs-comment">   * The most common applications of the Proxy pattern are lazy loading,</span><span class="hljs-comment">   * caching, controlling the access, logging, etc. A Proxy can perform one of</span><span class="hljs-comment">   * these things and then, depending on the result, pass the execution to the</span><span class="hljs-comment">   * same method in a linked RealSubject object.</span><span class="hljs-comment">   */</span>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Request</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> <span class="hljs-keyword">override</span> </span>{        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>-&gt;<span class="hljs-built_in">CheckAccess</span>()) {            <span class="hljs-keyword">this</span>-&gt;real_subject_-&gt;<span class="hljs-built_in">Request</span>();            <span class="hljs-keyword">this</span>-&gt;<span class="hljs-built_in">LogAccess</span>();        }    }};<span class="hljs-comment">/**</span><span class="hljs-comment"> * The client code is supposed to work with all objects (both subjects and</span><span class="hljs-comment"> * proxies) via the Subject interface in order to support both real subjects and</span><span class="hljs-comment"> * proxies. In real life, however, clients mostly work with their real subjects</span><span class="hljs-comment"> * directly. In this case, to implement the pattern more easily, you can extend</span><span class="hljs-comment"> * your proxy from the real subject's class.</span><span class="hljs-comment"> */</span><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">ClientCode</span><span class="hljs-params">(<span class="hljs-type">const</span> Subject &amp;subject)</span> </span>{    <span class="hljs-comment">// ...</span>    subject.<span class="hljs-built_in">Request</span>();    <span class="hljs-comment">// ...</span>}<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>{    std::cout &lt;&lt; <span class="hljs-string">"Client: Executing the client code with a real subject:\n"</span>;    RealSubject *real_subject = <span class="hljs-keyword">new</span> RealSubject;    <span class="hljs-built_in">ClientCode</span>(*real_subject);    std::cout &lt;&lt; <span class="hljs-string">"\n"</span>;    std::cout &lt;&lt; <span class="hljs-string">"Client: Executing the same client code with a proxy:\n"</span>;    Proxy *proxy = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Proxy</span>(real_subject);    <span class="hljs-built_in">ClientCode</span>(*proxy);    <span class="hljs-keyword">delete</span> real_subject;    <span class="hljs-keyword">delete</span> proxy;    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;}</code></pre></div><h1><span id="gua-pei-qi-mo-shi">适配器模式</span><a href="#gua-pei-qi-mo-shi" class="header-anchor">#</a></h1><p><strong>适配器模式</strong>是一种结构型设计模式， 它能使接口不兼容的对象能够相互合作。</p><p>适用场景：</p><ul><li><p><strong>当你希望使用某个类， 但是其接口与其他代码不兼容时， 可以使用适配器类。</strong></p></li><li><p>适配器模式允许你创建一个中间层类， 其可作为代码与遗留类、 第三方类或提供怪异接口的类之间的转换器。</p></li><li><p><strong>如果您需要复用这样一些类， 他们处于同一个继承体系， 并且他们又有了额外的一些共同的方法， 但是这些共同的方法不是所有在这一继承体系中的子类所具有的共性。</strong></p></li><li><p>你可以扩展每个子类， 将缺少的功能添加到新的子类中。 但是， 你必须在所有新子类中重复添加这些代码， 这样会使得代码有<a href="https://refactoringguru.cn/smells/duplicate-code">坏味道</a>。</p></li><li><p>将缺失功能添加到一个适配器类中是一种优雅得多的解决方案。 然后你可以将缺少功能的对象封装在适配器中， 从而动态地获取所需功能。 如要这一点正常运作， 目标类必须要有通用接口， 适配器的成员变量应当遵循该通用接口。 这种方式同<a href="https://refactoringguru.cn/design-patterns/decorator">装饰</a>模式非常相似。</p></li></ul><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Target</span> {<span class="hljs-keyword">public</span>:    <span class="hljs-keyword">virtual</span> ~<span class="hljs-built_in">Target</span>() = <span class="hljs-keyword">default</span>;    <span class="hljs-function"><span class="hljs-keyword">virtual</span> std::string <span class="hljs-title">Request</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>{        <span class="hljs-keyword">return</span> <span class="hljs-string">"Target: The default target's behavior."</span>;    }};<span class="hljs-comment">/**</span><span class="hljs-comment"> * The Adaptee contains some useful behavior, but its interface is incompatible</span><span class="hljs-comment"> * with the existing client code. The Adaptee needs some adaptation before the</span><span class="hljs-comment"> * client code can use it.</span><span class="hljs-comment"> */</span><span class="hljs-keyword">class</span> <span class="hljs-title class_">Adaptee</span> {<span class="hljs-keyword">public</span>:    <span class="hljs-function">std::string <span class="hljs-title">SpecificRequest</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>{        <span class="hljs-keyword">return</span> <span class="hljs-string">".eetpadA eht fo roivaheb laicepS"</span>;    }};<span class="hljs-comment">/**</span><span class="hljs-comment"> * The Adapter makes the Adaptee's interface compatible with the Target's</span><span class="hljs-comment"> * interface.</span><span class="hljs-comment"> */</span><span class="hljs-keyword">class</span> <span class="hljs-title class_">Adapter</span> : <span class="hljs-keyword">public</span> Target {<span class="hljs-keyword">private</span>:  Adaptee *adaptee_;<span class="hljs-keyword">public</span>:    <span class="hljs-built_in">Adapter</span>(Adaptee *adaptee) : <span class="hljs-built_in">adaptee_</span>(adaptee) {}    <span class="hljs-function">std::string <span class="hljs-title">Request</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> <span class="hljs-keyword">override</span> </span>{        std::string to_reverse = <span class="hljs-keyword">this</span>-&gt;adaptee_-&gt;<span class="hljs-built_in">SpecificRequest</span>();        std::<span class="hljs-built_in">reverse</span>(to_reverse.<span class="hljs-built_in">begin</span>(), to_reverse.<span class="hljs-built_in">end</span>());        <span class="hljs-keyword">return</span> <span class="hljs-string">"Adapter: (TRANSLATED) "</span> + to_reverse;    }};<span class="hljs-comment">/**</span><span class="hljs-comment"> * The client code supports all classes that follow the Target interface.</span><span class="hljs-comment"> */</span><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">ClientCode</span><span class="hljs-params">(<span class="hljs-type">const</span> Target *target)</span> </span>{  std::cout &lt;&lt; target-&gt;<span class="hljs-built_in">Request</span>();}<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>{    std::cout &lt;&lt; <span class="hljs-string">"Client: I can work just fine with the Target objects:\n"</span>;    Target *target = <span class="hljs-keyword">new</span> Target;    <span class="hljs-built_in">ClientCode</span>(target);    std::cout &lt;&lt; <span class="hljs-string">"\n\n"</span>;    Adaptee *adaptee = <span class="hljs-keyword">new</span> Adaptee;    std::cout &lt;&lt; <span class="hljs-string">"Client: The Adaptee class has a weird interface. See, I don't understand it:\n"</span>;    std::cout &lt;&lt; <span class="hljs-string">"Adaptee: "</span> &lt;&lt; adaptee-&gt;<span class="hljs-built_in">SpecificRequest</span>();    std::cout &lt;&lt; <span class="hljs-string">"\n\n"</span>;    std::cout &lt;&lt; <span class="hljs-string">"Client: But I can work with it via the Adapter:\n"</span>;    Adapter *adapter = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Adapter</span>(adaptee);    <span class="hljs-built_in">ClientCode</span>(adapter);    std::cout &lt;&lt; <span class="hljs-string">"\n"</span>;    <span class="hljs-keyword">delete</span> target;    <span class="hljs-keyword">delete</span> adaptee;    <span class="hljs-keyword">delete</span> adapter;    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;}</code></pre></div><h1><span id="qiao-jie-mo-shi">桥接模式</span><a href="#qiao-jie-mo-shi" class="header-anchor">#</a></h1><p><strong>桥接模式</strong>是一种结构型设计模式， 可将一个大类或一系列紧密相关的类拆分为抽象和实现两个独立的层次结构， 从而能在开发时分别使用。</p><p>适用场景：</p><ul><li><p><strong>如果你想要拆分或重组一个具有多重功能的庞杂类 （例如能与多个数据库服务器进行交互的类）， 可以使用桥接模式。</strong></p></li><li><p>类的代码行数越多， 弄清其运作方式就越困难， 对其进行修改所花费的时间就越长。 一个功能上的变化可能需要在整个类范围内进行修改， 而且常常会产生错误， 甚至还会有一些严重的副作用。</p></li><li><p>桥接模式可以将庞杂类拆分为几个类层次结构。 此后， 你可以修改任意一个类层次结构而不会影响到其他类层次结构。 这种方法可以简化代码的维护工作， 并将修改已有代码的风险降到最低。</p></li><li><p><strong>如果你希望在几个独立维度上扩展一个类， 可使用该模式。</strong></p></li><li><p>桥接建议将每个维度抽取为独立的类层次。 初始类将相关工作委派给属于对应类层次的对象， 无需自己完成所有工作。</p></li><li><p><strong>如果你需要在运行时切换不同实现方法， 可使用桥接模式。</strong></p></li><li><p>当然并不是说一定要实现这一点， 桥接模式可替换抽象部分中的实现对象， 具体操作就和给成员变量赋新值一样简单。</p></li><li><p>顺便提一句， 最后一点是很多人混淆桥接模式和<a href="https://refactoringguru.cn/design-patterns/strategy">策略</a>模式的主要原因。 记住， 设计模式并不仅是一种对类进行组织的方式， 它还能用于沟通意图和解决问题。</p></li></ul><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Implementation</span> {<span class="hljs-keyword">public</span>:    <span class="hljs-keyword">virtual</span> ~<span class="hljs-built_in">Implementation</span>() {}    <span class="hljs-function"><span class="hljs-keyword">virtual</span> std::string <span class="hljs-title">OperationImplementation</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>= <span class="hljs-number">0</span>;};<span class="hljs-comment">/**</span><span class="hljs-comment"> * Each Concrete Implementation corresponds to a specific platform and</span><span class="hljs-comment"> * implements the Implementation interface using that platform's API.</span><span class="hljs-comment"> */</span><span class="hljs-keyword">class</span> <span class="hljs-title class_">ConcreteImplementationA</span> : <span class="hljs-keyword">public</span> Implementation {<span class="hljs-keyword">public</span>:    <span class="hljs-function">std::string <span class="hljs-title">OperationImplementation</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> <span class="hljs-keyword">override</span> </span>{        <span class="hljs-keyword">return</span> <span class="hljs-string">"ConcreteImplementationA: Here's the result on the platform A.\n"</span>;    }};<span class="hljs-keyword">class</span> <span class="hljs-title class_">ConcreteImplementationB</span> : <span class="hljs-keyword">public</span> Implementation {<span class="hljs-keyword">public</span>:    <span class="hljs-function">std::string <span class="hljs-title">OperationImplementation</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> <span class="hljs-keyword">override</span> </span>{        <span class="hljs-keyword">return</span> <span class="hljs-string">"ConcreteImplementationB: Here's the result on the platform B.\n"</span>;    }};<span class="hljs-comment">/**</span><span class="hljs-comment"> * The Abstraction defines the interface for the "control" part of the two class</span><span class="hljs-comment"> * hierarchies. It maintains a reference to an object of the Implementation</span><span class="hljs-comment"> * hierarchy and delegates all of the real work to this object.</span><span class="hljs-comment"> */</span><span class="hljs-keyword">class</span> <span class="hljs-title class_">Abstraction</span> {  <span class="hljs-comment">/**</span><span class="hljs-comment">   * @var Implementation</span><span class="hljs-comment">   */</span><span class="hljs-keyword">protected</span>:  Implementation* implementation_;<span class="hljs-keyword">public</span>:    <span class="hljs-built_in">Abstraction</span>(Implementation* implementation) : <span class="hljs-built_in">implementation_</span>(implementation) {    }    <span class="hljs-keyword">virtual</span> ~<span class="hljs-built_in">Abstraction</span>() {    }    <span class="hljs-function"><span class="hljs-keyword">virtual</span> std::string <span class="hljs-title">Operation</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>{        <span class="hljs-keyword">return</span> <span class="hljs-string">"Abstraction: Base operation with:\n"</span> +            <span class="hljs-keyword">this</span>-&gt;implementation_-&gt;<span class="hljs-built_in">OperationImplementation</span>();    }};<span class="hljs-comment">/**</span><span class="hljs-comment"> * You can extend the Abstraction without changing the Implementation classes.</span><span class="hljs-comment"> */</span><span class="hljs-keyword">class</span> <span class="hljs-title class_">ExtendedAbstraction</span> : <span class="hljs-keyword">public</span> Abstraction {<span class="hljs-keyword">public</span>:    <span class="hljs-built_in">ExtendedAbstraction</span>(Implementation* implementation) : <span class="hljs-built_in">Abstraction</span>(implementation) {    }    <span class="hljs-function">std::string <span class="hljs-title">Operation</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> <span class="hljs-keyword">override</span> </span>{        <span class="hljs-keyword">return</span> <span class="hljs-string">"ExtendedAbstraction: Extended operation with:\n"</span> +            <span class="hljs-keyword">this</span>-&gt;implementation_-&gt;<span class="hljs-built_in">OperationImplementation</span>();    }};<span class="hljs-comment">/**</span><span class="hljs-comment"> * Except for the initialization phase, where an Abstraction object gets linked</span><span class="hljs-comment"> * with a specific Implementation object, the client code should only depend on</span><span class="hljs-comment"> * the Abstraction class. This way the client code can support any abstraction-</span><span class="hljs-comment"> * implementation combination.</span><span class="hljs-comment"> */</span><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">ClientCode</span><span class="hljs-params">(<span class="hljs-type">const</span> Abstraction&amp; abstraction)</span> </span>{    <span class="hljs-comment">// ...</span>    std::cout &lt;&lt; abstraction.<span class="hljs-built_in">Operation</span>();    <span class="hljs-comment">// ...</span>}<span class="hljs-comment">/**</span><span class="hljs-comment"> * The client code should be able to work with any pre-configured abstraction-</span><span class="hljs-comment"> * implementation combination.</span><span class="hljs-comment"> */</span><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>{    Implementation* implementation = <span class="hljs-keyword">new</span> ConcreteImplementationA;    Abstraction* abstraction = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Abstraction</span>(implementation);    <span class="hljs-built_in">ClientCode</span>(*abstraction);    std::cout &lt;&lt; std::endl;    <span class="hljs-keyword">delete</span> implementation;    <span class="hljs-keyword">delete</span> abstraction;    implementation = <span class="hljs-keyword">new</span> ConcreteImplementationB;    abstraction = <span class="hljs-keyword">new</span> <span class="hljs-built_in">ExtendedAbstraction</span>(implementation);    <span class="hljs-built_in">ClientCode</span>(*abstraction);    <span class="hljs-keyword">delete</span> implementation;    <span class="hljs-keyword">delete</span> abstraction;    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;}</code></pre></div><h1><span id="zu-he-mo-shi">组合模式</span><a href="#zu-he-mo-shi" class="header-anchor">#</a></h1><p><strong>组合模式</strong>是一种结构型设计模式， 你可以使用它将对象组合成树状结构， 并且能像使用独立对象一样使用它们。</p><p><strong>适用场景</strong></p><ul><li><p>如果你需要实现树状对象结构， 可以使用组合模式。</p></li><li><p>组合模式为你提供了两种共享公共接口的基本元素类型： 简单叶节点和复杂容器。 容器中可以包含叶节点和其他容器。 这使得你可以构建树状嵌套递归对象结构。</p></li><li><p>如果你希望客户端代码以相同方式处理简单和复杂元素， 可以使用该模式。</p></li><li><p>组合模式中定义的所有元素共用同一个接口。 在这一接口的帮助下， 客户端不必在意其所使用的对象的具体类。</p></li></ul><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;list&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span><span class="hljs-comment">/**</span><span class="hljs-comment"> * The base Component class declares common operations for both simple and</span><span class="hljs-comment"> * complex objects of a composition.</span><span class="hljs-comment"> */</span><span class="hljs-keyword">class</span> <span class="hljs-title class_">Component</span> {      <span class="hljs-comment">/**</span><span class="hljs-comment">       * @var Component</span><span class="hljs-comment">       */</span><span class="hljs-keyword">protected</span>:  Component *parent_;      <span class="hljs-comment">/**</span><span class="hljs-comment">       * Optionally, the base Component can declare an interface for setting and</span><span class="hljs-comment">       * accessing a parent of the component in a tree structure. It can also</span><span class="hljs-comment">       * provide some default implementation for these methods.</span><span class="hljs-comment">       */</span><span class="hljs-keyword">public</span>:    <span class="hljs-keyword">virtual</span> ~<span class="hljs-built_in">Component</span>() {}    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">SetParent</span><span class="hljs-params">(Component *parent)</span> </span>{        <span class="hljs-keyword">this</span>-&gt;parent_ = parent;    }    <span class="hljs-function">Component *<span class="hljs-title">GetParent</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>{        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>-&gt;parent_;    }    <span class="hljs-comment">/**</span><span class="hljs-comment">       * In some cases, it would be beneficial to define the child-management</span><span class="hljs-comment">       * operations right in the base Component class. This way, you won't need to</span><span class="hljs-comment">       * expose any concrete component classes to the client code, even during the</span><span class="hljs-comment">       * object tree assembly. The downside is that these methods will be empty for</span><span class="hljs-comment">       * the leaf-level components.</span><span class="hljs-comment">       */</span>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">Add</span><span class="hljs-params">(Component *component)</span> </span>{}    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">Remove</span><span class="hljs-params">(Component *component)</span> </span>{}    <span class="hljs-comment">/**</span><span class="hljs-comment">       * You can provide a method that lets the client code figure out whether a</span><span class="hljs-comment">       * component can bear children.</span><span class="hljs-comment">       */</span>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">bool</span> <span class="hljs-title">IsComposite</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>{        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;    }    <span class="hljs-comment">/**</span><span class="hljs-comment">       * The base Component may implement some default behavior or leave it to</span><span class="hljs-comment">       * concrete classes (by declaring the method containing the behavior as</span><span class="hljs-comment">       * "abstract").</span><span class="hljs-comment">       */</span>  <span class="hljs-function"><span class="hljs-keyword">virtual</span> std::string <span class="hljs-title">Operation</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>= <span class="hljs-number">0</span>;};<span class="hljs-comment">/**</span><span class="hljs-comment">     * The Leaf class represents the end objects of a composition. A leaf can't have</span><span class="hljs-comment">     * any children.</span><span class="hljs-comment">     *</span><span class="hljs-comment">     * Usually, it's the Leaf objects that do the actual work, whereas Composite</span><span class="hljs-comment">     * objects only delegate to their sub-components.</span><span class="hljs-comment">     */</span><span class="hljs-keyword">class</span> <span class="hljs-title class_">Leaf</span> : <span class="hljs-keyword">public</span> Component {<span class="hljs-keyword">public</span>:    <span class="hljs-function">std::string <span class="hljs-title">Operation</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> <span class="hljs-keyword">override</span> </span>{        <span class="hljs-keyword">return</span> <span class="hljs-string">"Leaf"</span>;    }};<span class="hljs-comment">/**</span><span class="hljs-comment"> * The Composite class represents the complex components that may have children.</span><span class="hljs-comment"> * Usually, the Composite objects delegate the actual work to their children and</span><span class="hljs-comment"> * then "sum-up" the result.</span><span class="hljs-comment"> */</span><span class="hljs-keyword">class</span> <span class="hljs-title class_">Composite</span> : <span class="hljs-keyword">public</span> Component {  <span class="hljs-comment">/**</span><span class="hljs-comment">   * @var \SplObjectStorage</span><span class="hljs-comment">   */</span><span class="hljs-keyword">protected</span>:  std::list&lt;Component *&gt; children_;<span class="hljs-keyword">public</span>:    <span class="hljs-comment">/**</span><span class="hljs-comment">       * A composite object can add or remove other components (both simple or</span><span class="hljs-comment">       * complex) to or from its child list.</span><span class="hljs-comment">       */</span>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Add</span><span class="hljs-params">(Component *component)</span> <span class="hljs-keyword">override</span> </span>{        <span class="hljs-keyword">this</span>-&gt;children_.<span class="hljs-built_in">push_back</span>(component);        component-&gt;<span class="hljs-built_in">SetParent</span>(<span class="hljs-keyword">this</span>);    }  <span class="hljs-comment">/**</span><span class="hljs-comment">   * Have in mind that this method removes the pointer to the list but doesn't</span><span class="hljs-comment">   * frees the</span><span class="hljs-comment">   *     memory, you should do it manually or better use smart pointers.</span><span class="hljs-comment">   */</span>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Remove</span><span class="hljs-params">(Component *component)</span> <span class="hljs-keyword">override</span> </span>{        children_.<span class="hljs-built_in">remove</span>(component);        component-&gt;<span class="hljs-built_in">SetParent</span>(<span class="hljs-literal">nullptr</span>);    }    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">IsComposite</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> <span class="hljs-keyword">override</span> </span>{        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;    }  <span class="hljs-comment">/**</span><span class="hljs-comment">   * The Composite executes its primary logic in a particular way. It traverses</span><span class="hljs-comment">   * recursively through all its children, collecting and summing their results.</span><span class="hljs-comment">   * Since the composite's children pass these calls to their children and so</span><span class="hljs-comment">   * forth, the whole object tree is traversed as a result.</span><span class="hljs-comment">   */</span>    <span class="hljs-function">std::string <span class="hljs-title">Operation</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> <span class="hljs-keyword">override</span> </span>{        std::string result;        <span class="hljs-keyword">for</span> (<span class="hljs-type">const</span> Component *c : children_) {            <span class="hljs-keyword">if</span> (c == children_.<span class="hljs-built_in">back</span>()) {                result += c-&gt;<span class="hljs-built_in">Operation</span>();            } <span class="hljs-keyword">else</span> {                result += c-&gt;<span class="hljs-built_in">Operation</span>() + <span class="hljs-string">"+"</span>;            }        }        <span class="hljs-keyword">return</span> <span class="hljs-string">"Branch("</span> + result + <span class="hljs-string">")"</span>;    }};<span class="hljs-comment">/**</span><span class="hljs-comment"> * The client code works with all of the components via the base interface.</span><span class="hljs-comment"> */</span><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">ClientCode</span><span class="hljs-params">(Component *component)</span> </span>{    <span class="hljs-comment">// ...</span>    std::cout &lt;&lt; <span class="hljs-string">"RESULT: "</span> &lt;&lt; component-&gt;<span class="hljs-built_in">Operation</span>();    <span class="hljs-comment">// ...</span>}<span class="hljs-comment">/**</span><span class="hljs-comment"> * Thanks to the fact that the child-management operations are declared in the</span><span class="hljs-comment"> * base Component class, the client code can work with any component, simple or</span><span class="hljs-comment"> * complex, without depending on their concrete classes.</span><span class="hljs-comment"> */</span><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">ClientCode2</span><span class="hljs-params">(Component *component1, Component *component2)</span> </span>{    <span class="hljs-comment">// ...</span>    <span class="hljs-keyword">if</span> (component1-&gt;<span class="hljs-built_in">IsComposite</span>()) {        component1-&gt;<span class="hljs-built_in">Add</span>(component2);    }    std::cout &lt;&lt; <span class="hljs-string">"RESULT: "</span> &lt;&lt; component1-&gt;<span class="hljs-built_in">Operation</span>();    <span class="hljs-comment">// ...</span>}<span class="hljs-comment">/**</span><span class="hljs-comment"> * This way the client code can support the simple leaf components...</span><span class="hljs-comment"> */</span><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>{    Component *simple = <span class="hljs-keyword">new</span> Leaf;    std::cout &lt;&lt; <span class="hljs-string">"Client: I've got a simple component:\n"</span>;    <span class="hljs-built_in">ClientCode</span>(simple);    std::cout &lt;&lt; <span class="hljs-string">"\n\n"</span>;    <span class="hljs-comment">/**</span><span class="hljs-comment">       * ...as well as the complex composites.</span><span class="hljs-comment">       */</span>    Component *tree = <span class="hljs-keyword">new</span> Composite;    Component *branch1 = <span class="hljs-keyword">new</span> Composite;    Component *leaf_1 = <span class="hljs-keyword">new</span> Leaf;    Component *leaf_2 = <span class="hljs-keyword">new</span> Leaf;    Component *leaf_3 = <span class="hljs-keyword">new</span> Leaf;    branch1-&gt;<span class="hljs-built_in">Add</span>(leaf_1);    branch1-&gt;<span class="hljs-built_in">Add</span>(leaf_2);    Component *branch2 = <span class="hljs-keyword">new</span> Composite;    branch2-&gt;<span class="hljs-built_in">Add</span>(leaf_3);    tree-&gt;<span class="hljs-built_in">Add</span>(branch1);    tree-&gt;<span class="hljs-built_in">Add</span>(branch2);    std::cout &lt;&lt; <span class="hljs-string">"Client: Now I've got a composite tree:\n"</span>;    <span class="hljs-built_in">ClientCode</span>(tree);    std::cout &lt;&lt; <span class="hljs-string">"\n\n"</span>;    std::cout &lt;&lt; <span class="hljs-string">"Client: I don't need to check the components classes even when managing the tree:\n"</span>;    <span class="hljs-built_in">ClientCode2</span>(tree, simple);    std::cout &lt;&lt; <span class="hljs-string">"\n"</span>;    <span class="hljs-keyword">delete</span> simple;    <span class="hljs-keyword">delete</span> tree;    <span class="hljs-keyword">delete</span> branch1;    <span class="hljs-keyword">delete</span> branch2;    <span class="hljs-keyword">delete</span> leaf_1;    <span class="hljs-keyword">delete</span> leaf_2;    <span class="hljs-keyword">delete</span> leaf_3;    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;}</code></pre></div><h1><span id="zhuang-shi-mo-shi">装饰模式</span><a href="#zhuang-shi-mo-shi" class="header-anchor">#</a></h1><p><strong>装饰模式</strong>是一种结构型设计模式， 允许你通过将对象放入包含行为的特殊封装对象中来为原对象绑定新的行为。</p><p>适用场景：</p><ul><li><p>如果你希望在无需修改代码的情况下即可使用对象， 且希望在运行时为对象新增额外的行为， 可以使用装饰模式。</p></li><li><p>装饰能将业务逻辑组织为层次结构， 你可为各层创建一个装饰， 在运行时将各种不同逻辑组合成对象。 由于这些对象都遵循通用接口， 客户端代码能以相同的方式使用这些对象。</p></li><li><p>如果用继承来扩展对象行为的方案难以实现或者根本不可行， 你可以使用该模式。</p></li><li><p>许多编程语言使用 <code>final</code> <code>最终</code>关键字来限制对某个类的进一步扩展。 复用最终类已有行为的唯一方法是使用装饰模式： 用封装器对其进行封装。</p></li></ul><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-comment">/**</span><span class="hljs-comment"> * The base Component interface defines operations that can be altered by</span><span class="hljs-comment"> * decorators.</span><span class="hljs-comment"> */</span><span class="hljs-keyword">class</span> <span class="hljs-title class_">Component</span> {<span class="hljs-keyword">public</span>:    <span class="hljs-keyword">virtual</span> ~<span class="hljs-built_in">Component</span>() {}    <span class="hljs-function"><span class="hljs-keyword">virtual</span> std::string <span class="hljs-title">Operation</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>= <span class="hljs-number">0</span>;};<span class="hljs-comment">/**</span><span class="hljs-comment"> * Concrete Components provide default implementations of the operations. There</span><span class="hljs-comment"> * might be several variations of these classes.</span><span class="hljs-comment"> */</span><span class="hljs-keyword">class</span> <span class="hljs-title class_">ConcreteComponent</span> : <span class="hljs-keyword">public</span> Component {<span class="hljs-keyword">public</span>:    <span class="hljs-function">std::string <span class="hljs-title">Operation</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> <span class="hljs-keyword">override</span> </span>{        <span class="hljs-keyword">return</span> <span class="hljs-string">"ConcreteComponent"</span>;    }};<span class="hljs-comment">/**</span><span class="hljs-comment"> * The base Decorator class follows the same interface as the other components.</span><span class="hljs-comment"> * The primary purpose of this class is to define the wrapping interface for all</span><span class="hljs-comment"> * concrete decorators. The default implementation of the wrapping code might</span><span class="hljs-comment"> * include a field for storing a wrapped component and the means to initialize</span><span class="hljs-comment"> * it.</span><span class="hljs-comment"> */</span><span class="hljs-keyword">class</span> <span class="hljs-title class_">Decorator</span> : <span class="hljs-keyword">public</span> Component {  <span class="hljs-comment">/**</span><span class="hljs-comment">   * @var Component</span><span class="hljs-comment">   */</span><span class="hljs-keyword">protected</span>:  Component* component_;<span class="hljs-keyword">public</span>:    <span class="hljs-built_in">Decorator</span>(Component* component) : <span class="hljs-built_in">component_</span>(component) {    }    <span class="hljs-comment">/**</span><span class="hljs-comment">       * The Decorator delegates all work to the wrapped component.</span><span class="hljs-comment">       */</span>    <span class="hljs-function">std::string <span class="hljs-title">Operation</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> <span class="hljs-keyword">override</span> </span>{        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>-&gt;component_-&gt;<span class="hljs-built_in">Operation</span>();    }};<span class="hljs-comment">/**</span><span class="hljs-comment"> * Concrete Decorators call the wrapped object and alter its result in some way.</span><span class="hljs-comment"> */</span><span class="hljs-keyword">class</span> <span class="hljs-title class_">ConcreteDecoratorA</span> : <span class="hljs-keyword">public</span> Decorator {  <span class="hljs-comment">/**</span><span class="hljs-comment">   * Decorators may call parent implementation of the operation, instead of</span><span class="hljs-comment">   * calling the wrapped object directly. This approach simplifies extension of</span><span class="hljs-comment">   * decorator classes.</span><span class="hljs-comment">   */</span><span class="hljs-keyword">public</span>:    <span class="hljs-built_in">ConcreteDecoratorA</span>(Component* component) : <span class="hljs-built_in">Decorator</span>(component) {    }    <span class="hljs-function">std::string <span class="hljs-title">Operation</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> <span class="hljs-keyword">override</span> </span>{        <span class="hljs-keyword">return</span> <span class="hljs-string">"ConcreteDecoratorA("</span> + Decorator::<span class="hljs-built_in">Operation</span>() + <span class="hljs-string">")"</span>;    }};<span class="hljs-comment">/**</span><span class="hljs-comment"> * Decorators can execute their behavior either before or after the call to a</span><span class="hljs-comment"> * wrapped object.</span><span class="hljs-comment"> */</span><span class="hljs-keyword">class</span> <span class="hljs-title class_">ConcreteDecoratorB</span> : <span class="hljs-keyword">public</span> Decorator {<span class="hljs-keyword">public</span>:    <span class="hljs-built_in">ConcreteDecoratorB</span>(Component* component) : <span class="hljs-built_in">Decorator</span>(component) {    }    <span class="hljs-function">std::string <span class="hljs-title">Operation</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> <span class="hljs-keyword">override</span> </span>{        <span class="hljs-keyword">return</span> <span class="hljs-string">"ConcreteDecoratorB("</span> + Decorator::<span class="hljs-built_in">Operation</span>() + <span class="hljs-string">")"</span>;    }};<span class="hljs-comment">/**</span><span class="hljs-comment"> * The client code works with all objects using the Component interface. This</span><span class="hljs-comment"> * way it can stay independent of the concrete classes of components it works</span><span class="hljs-comment"> * with.</span><span class="hljs-comment"> */</span><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">ClientCode</span><span class="hljs-params">(Component* component)</span> </span>{    <span class="hljs-comment">// ...</span>    std::cout &lt;&lt; <span class="hljs-string">"RESULT: "</span> &lt;&lt; component-&gt;<span class="hljs-built_in">Operation</span>();    <span class="hljs-comment">// ...</span>}<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>{    <span class="hljs-comment">/**</span><span class="hljs-comment">       * This way the client code can support both simple components...</span><span class="hljs-comment">       */</span>    Component* simple = <span class="hljs-keyword">new</span> ConcreteComponent;    std::cout &lt;&lt; <span class="hljs-string">"Client: I've got a simple component:\n"</span>;    <span class="hljs-built_in">ClientCode</span>(simple);    std::cout &lt;&lt; <span class="hljs-string">"\n\n"</span>;    <span class="hljs-comment">/**</span><span class="hljs-comment">       * ...as well as decorated ones.</span><span class="hljs-comment">       *</span><span class="hljs-comment">       * Note how decorators can wrap not only simple components but the other</span><span class="hljs-comment">       * decorators as well.</span><span class="hljs-comment">       */</span>    Component* decorator1 = <span class="hljs-keyword">new</span> <span class="hljs-built_in">ConcreteDecoratorA</span>(simple);    Component* decorator2 = <span class="hljs-keyword">new</span> <span class="hljs-built_in">ConcreteDecoratorB</span>(decorator1);    std::cout &lt;&lt; <span class="hljs-string">"Client: Now I've got a decorated component:\n"</span>;    <span class="hljs-built_in">ClientCode</span>(decorator2);    std::cout &lt;&lt; <span class="hljs-string">"\n"</span>;    <span class="hljs-keyword">delete</span> simple;    <span class="hljs-keyword">delete</span> decorator1;    <span class="hljs-keyword">delete</span> decorator2;    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;}</code></pre></div><h1><span id="wai-guan-mo-shi">外观模式</span><a href="#wai-guan-mo-shi" class="header-anchor">#</a></h1><p><strong>外观模式</strong>是一种结构型设计模式， 能为程序库、 框架或其他复杂类提供一个简单的接口。</p><p>适用场景:</p><ul><li><p><strong>如果你需要一个指向复杂子系统的直接接口， 且该接口的功能有限， 则可以使用外观模式。</strong></p></li><li><p>子系统通常会随着时间的推进变得越来越复杂。 即便是应用了设计模式， 通常你也会创建更多的类。 尽管在多种情形中子系统可能是更灵活或易于复用的， 但其所需的配置和样板代码数量将会增长得更快。 为了解决这个问题， 外观将会提供指向子系统中最常用功能的快捷方式， 能够满足客户端的大部分需求。</p></li><li><p><strong>如果需要将子系统组织为多层结构， 可以使用外观。</strong></p></li><li><p>创建外观来定义子系统中各层次的入口。 你可以要求子系统仅使用外观来进行交互， 以减少子系统之间的耦合。</p></li><li><p>让我们回到视频转换框架的例子。 该框架可以拆分为两个层次： 音频相关和视频相关。 你可以为每个层次创建一个外观， 然后要求各层的类必须通过这些外观进行交互。 这种方式看上去与<a href="https://refactoringguru.cn/design-patterns/mediator">中介者</a>模式非常相似。</p></li></ul><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-comment">/**</span><span class="hljs-comment"> * The Subsystem can accept requests either from the facade or client directly.</span><span class="hljs-comment"> * In any case, to the Subsystem, the Facade is yet another client, and it's not</span><span class="hljs-comment"> * a part of the Subsystem.</span><span class="hljs-comment"> */</span><span class="hljs-keyword">class</span> <span class="hljs-title class_">Subsystem1</span> {<span class="hljs-keyword">public</span>:    <span class="hljs-function">std::string <span class="hljs-title">Operation1</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>{        <span class="hljs-keyword">return</span> <span class="hljs-string">"Subsystem1: Ready!\n"</span>;    }    <span class="hljs-comment">// ...</span>    <span class="hljs-function">std::string <span class="hljs-title">OperationN</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>{        <span class="hljs-keyword">return</span> <span class="hljs-string">"Subsystem1: Go!\n"</span>;    }};<span class="hljs-comment">/**</span><span class="hljs-comment"> * Some facades can work with multiple subsystems at the same time.</span><span class="hljs-comment"> */</span><span class="hljs-keyword">class</span> <span class="hljs-title class_">Subsystem2</span> {<span class="hljs-keyword">public</span>:    <span class="hljs-function">std::string <span class="hljs-title">Operation1</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>{        <span class="hljs-keyword">return</span> <span class="hljs-string">"Subsystem2: Get ready!\n"</span>;    }    <span class="hljs-comment">// ...</span>    <span class="hljs-function">std::string <span class="hljs-title">OperationZ</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>{        <span class="hljs-keyword">return</span> <span class="hljs-string">"Subsystem2: Fire!\n"</span>;    }};<span class="hljs-comment">/**</span><span class="hljs-comment"> * The Facade class provides a simple interface to the complex logic of one or</span><span class="hljs-comment"> * several subsystems. The Facade delegates the client requests to the</span><span class="hljs-comment"> * appropriate objects within the subsystem. The Facade is also responsible for</span><span class="hljs-comment"> * managing their lifecycle. All of this shields the client from the undesired</span><span class="hljs-comment"> * complexity of the subsystem.</span><span class="hljs-comment"> */</span><span class="hljs-keyword">class</span> <span class="hljs-title class_">Facade</span> {<span class="hljs-keyword">protected</span>:    Subsystem1 *subsystem1_;    Subsystem2 *subsystem2_;  <span class="hljs-comment">/**</span><span class="hljs-comment">   * Depending on your application's needs, you can provide the Facade with</span><span class="hljs-comment">   * existing subsystem objects or force the Facade to create them on its own.</span><span class="hljs-comment">   */</span><span class="hljs-keyword">public</span>:    <span class="hljs-comment">/**</span><span class="hljs-comment">       * In this case we will delegate the memory ownership to Facade Class</span><span class="hljs-comment">       */</span>    <span class="hljs-built_in">Facade</span>(        Subsystem1 *subsystem1 = <span class="hljs-literal">nullptr</span>,        Subsystem2 *subsystem2 = <span class="hljs-literal">nullptr</span>) {        <span class="hljs-keyword">this</span>-&gt;subsystem1_ = subsystem1 ?: <span class="hljs-keyword">new</span> Subsystem1;        <span class="hljs-keyword">this</span>-&gt;subsystem2_ = subsystem2 ?: <span class="hljs-keyword">new</span> Subsystem2;    }    ~<span class="hljs-built_in">Facade</span>() {        <span class="hljs-keyword">delete</span> subsystem1_;        <span class="hljs-keyword">delete</span> subsystem2_;    }    <span class="hljs-comment">/**</span><span class="hljs-comment">       * The Facade's methods are convenient shortcuts to the sophisticated</span><span class="hljs-comment">       * functionality of the subsystems. However, clients get only to a fraction of</span><span class="hljs-comment">       * a subsystem's capabilities.</span><span class="hljs-comment">       */</span>    <span class="hljs-function">std::string <span class="hljs-title">Operation</span><span class="hljs-params">()</span> </span>{        std::string result = <span class="hljs-string">"Facade initializes subsystems:\n"</span>;        result += <span class="hljs-keyword">this</span>-&gt;subsystem1_-&gt;<span class="hljs-built_in">Operation1</span>();        result += <span class="hljs-keyword">this</span>-&gt;subsystem2_-&gt;<span class="hljs-built_in">Operation1</span>();        result += <span class="hljs-string">"Facade orders subsystems to perform the action:\n"</span>;        result += <span class="hljs-keyword">this</span>-&gt;subsystem1_-&gt;<span class="hljs-built_in">OperationN</span>();        result += <span class="hljs-keyword">this</span>-&gt;subsystem2_-&gt;<span class="hljs-built_in">OperationZ</span>();        <span class="hljs-keyword">return</span> result;    }};<span class="hljs-comment">/**</span><span class="hljs-comment"> * The client code works with complex subsystems through a simple interface</span><span class="hljs-comment"> * provided by the Facade. When a facade manages the lifecycle of the subsystem,</span><span class="hljs-comment"> * the client might not even know about the existence of the subsystem. This</span><span class="hljs-comment"> * approach lets you keep the complexity under control.</span><span class="hljs-comment"> */</span><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">ClientCode</span><span class="hljs-params">(Facade *facade)</span> </span>{    <span class="hljs-comment">// ...</span>    std::cout &lt;&lt; facade-&gt;<span class="hljs-built_in">Operation</span>();    <span class="hljs-comment">// ...</span>}<span class="hljs-comment">/**</span><span class="hljs-comment"> * The client code may have some of the subsystem's objects already created. In</span><span class="hljs-comment"> * this case, it might be worthwhile to initialize the Facade with these objects</span><span class="hljs-comment"> * instead of letting the Facade create new instances.</span><span class="hljs-comment"> */</span><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>{    Subsystem1 *subsystem1 = <span class="hljs-keyword">new</span> Subsystem1;    Subsystem2 *subsystem2 = <span class="hljs-keyword">new</span> Subsystem2;    Facade *facade = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Facade</span>(subsystem1, subsystem2);    <span class="hljs-built_in">ClientCode</span>(facade);    <span class="hljs-keyword">delete</span> facade;    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;}</code></pre></div><h1><span id="xiang-yuan-mo-shi">享元模式</span><a href="#xiang-yuan-mo-shi" class="header-anchor">#</a></h1><p><strong>享元模式</strong>是一种结构型设计模式， 它摒弃了在每个对象中保存所有数据的方式， 通过共享多个对象所共有的相同状态， 让你能在有限的内存容量中载入更多对象。</p><p>适用场景:</p><ul><li><p><strong>仅在程序必须支持大量对象且没有足够的内存容量时使用享元模式。</strong></p></li><li><p>应用该模式所获的收益大小取决于使用它的方式和情景。 它在下列情况中最有效：</p><ul><li>程序需要生成数量巨大的相似对象</li><li>这将耗尽目标设备的所有内存</li><li>对象中包含可抽取且能在多个对象间共享的重复状态。</li></ul></li></ul><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-comment">/**</span><span class="hljs-comment"> * Flyweight Design Pattern</span><span class="hljs-comment"> *</span><span class="hljs-comment"> * Intent: Lets you fit more objects into the available amount of RAM by sharing</span><span class="hljs-comment"> * common parts of state between multiple objects, instead of keeping all of the</span><span class="hljs-comment"> * data in each object.</span><span class="hljs-comment"> */</span><span class="hljs-keyword">struct</span> <span class="hljs-title class_">SharedState</span>{    std::string brand_;    std::string model_;    std::string color_;    <span class="hljs-built_in">SharedState</span>(<span class="hljs-type">const</span> std::string &amp;brand, <span class="hljs-type">const</span> std::string &amp;model, <span class="hljs-type">const</span> std::string &amp;color)        : <span class="hljs-built_in">brand_</span>(brand), <span class="hljs-built_in">model_</span>(model), <span class="hljs-built_in">color_</span>(color)    {    }    <span class="hljs-keyword">friend</span> std::ostream &amp;<span class="hljs-keyword">operator</span>&lt;&lt;(std::ostream &amp;os, <span class="hljs-type">const</span> SharedState &amp;ss)    {        <span class="hljs-keyword">return</span> os &lt;&lt; <span class="hljs-string">"[ "</span> &lt;&lt; ss.brand_ &lt;&lt; <span class="hljs-string">" , "</span> &lt;&lt; ss.model_ &lt;&lt; <span class="hljs-string">" , "</span> &lt;&lt; ss.color_ &lt;&lt; <span class="hljs-string">" ]"</span>;    }};<span class="hljs-keyword">struct</span> <span class="hljs-title class_">UniqueState</span>{    std::string owner_;    std::string plates_;    <span class="hljs-built_in">UniqueState</span>(<span class="hljs-type">const</span> std::string &amp;owner, <span class="hljs-type">const</span> std::string &amp;plates)        : <span class="hljs-built_in">owner_</span>(owner), <span class="hljs-built_in">plates_</span>(plates)    {    }    <span class="hljs-keyword">friend</span> std::ostream &amp;<span class="hljs-keyword">operator</span>&lt;&lt;(std::ostream &amp;os, <span class="hljs-type">const</span> UniqueState &amp;us)    {        <span class="hljs-keyword">return</span> os &lt;&lt; <span class="hljs-string">"[ "</span> &lt;&lt; us.owner_ &lt;&lt; <span class="hljs-string">" , "</span> &lt;&lt; us.plates_ &lt;&lt; <span class="hljs-string">" ]"</span>;    }};<span class="hljs-comment">/**</span><span class="hljs-comment"> * The Flyweight stores a common portion of the state (also called intrinsic</span><span class="hljs-comment"> * state) that belongs to multiple real business entities. The Flyweight accepts</span><span class="hljs-comment"> * the rest of the state (extrinsic state, unique for each entity) via its</span><span class="hljs-comment"> * method parameters.</span><span class="hljs-comment"> */</span><span class="hljs-keyword">class</span> <span class="hljs-title class_">Flyweight</span>{<span class="hljs-keyword">private</span>:    SharedState *shared_state_;<span class="hljs-keyword">public</span>:    <span class="hljs-built_in">Flyweight</span>(<span class="hljs-type">const</span> SharedState *shared_state) : <span class="hljs-built_in">shared_state_</span>(<span class="hljs-keyword">new</span> <span class="hljs-built_in">SharedState</span>(*shared_state))    {    }    <span class="hljs-built_in">Flyweight</span>(<span class="hljs-type">const</span> Flyweight &amp;other) : <span class="hljs-built_in">shared_state_</span>(<span class="hljs-keyword">new</span> <span class="hljs-built_in">SharedState</span>(*other.shared_state_))    {    }    ~<span class="hljs-built_in">Flyweight</span>()    {        <span class="hljs-keyword">delete</span> shared_state_;    }    <span class="hljs-function">SharedState *<span class="hljs-title">shared_state</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span><span class="hljs-function">    </span>{        <span class="hljs-keyword">return</span> shared_state_;    }    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Operation</span><span class="hljs-params">(<span class="hljs-type">const</span> UniqueState &amp;unique_state)</span> <span class="hljs-type">const</span></span><span class="hljs-function">    </span>{        std::cout &lt;&lt; <span class="hljs-string">"Flyweight: Displaying shared ("</span> &lt;&lt; *shared_state_ &lt;&lt; <span class="hljs-string">") and unique ("</span> &lt;&lt; unique_state &lt;&lt; <span class="hljs-string">") state.\n"</span>;    }};<span class="hljs-comment">/**</span><span class="hljs-comment"> * The Flyweight Factory creates and manages the Flyweight objects. It ensures</span><span class="hljs-comment"> * that flyweights are shared correctly. When the client requests a flyweight,</span><span class="hljs-comment"> * the factory either returns an existing instance or creates a new one, if it</span><span class="hljs-comment"> * doesn't exist yet.</span><span class="hljs-comment"> */</span><span class="hljs-keyword">class</span> <span class="hljs-title class_">FlyweightFactory</span>{    <span class="hljs-comment">/**</span><span class="hljs-comment">     * @var Flyweight[]</span><span class="hljs-comment">     */</span><span class="hljs-keyword">private</span>:    std::unordered_map&lt;std::string, Flyweight&gt; flyweights_;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * Returns a Flyweight's string hash for a given state.</span><span class="hljs-comment">     */</span>    <span class="hljs-function">std::string <span class="hljs-title">GetKey</span><span class="hljs-params">(<span class="hljs-type">const</span> SharedState &amp;ss)</span> <span class="hljs-type">const</span></span><span class="hljs-function">    </span>{        <span class="hljs-keyword">return</span> ss.brand_ + <span class="hljs-string">"_"</span> + ss.model_ + <span class="hljs-string">"_"</span> + ss.color_;    }<span class="hljs-keyword">public</span>:    <span class="hljs-built_in">FlyweightFactory</span>(std::initializer_list&lt;SharedState&gt; share_states)    {        <span class="hljs-keyword">for</span> (<span class="hljs-type">const</span> SharedState &amp;ss : share_states)        {            <span class="hljs-keyword">this</span>-&gt;flyweights_.<span class="hljs-built_in">insert</span>(std::<span class="hljs-built_in">make_pair</span>&lt;std::string, Flyweight&gt;(<span class="hljs-keyword">this</span>-&gt;<span class="hljs-built_in">GetKey</span>(ss), <span class="hljs-built_in">Flyweight</span>(&amp;ss)));        }    }    <span class="hljs-comment">/**</span><span class="hljs-comment">     * Returns an existing Flyweight with a given state or creates a new one.</span><span class="hljs-comment">     */</span>    <span class="hljs-function">Flyweight <span class="hljs-title">GetFlyweight</span><span class="hljs-params">(<span class="hljs-type">const</span> SharedState &amp;shared_state)</span></span><span class="hljs-function">    </span>{        std::string key = <span class="hljs-keyword">this</span>-&gt;<span class="hljs-built_in">GetKey</span>(shared_state);        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>-&gt;flyweights_.<span class="hljs-built_in">find</span>(key) == <span class="hljs-keyword">this</span>-&gt;flyweights_.<span class="hljs-built_in">end</span>())        {            std::cout &lt;&lt; <span class="hljs-string">"FlyweightFactory: Can't find a flyweight, creating new one.\n"</span>;            <span class="hljs-keyword">this</span>-&gt;flyweights_.<span class="hljs-built_in">insert</span>(std::<span class="hljs-built_in">make_pair</span>(key, <span class="hljs-built_in">Flyweight</span>(&amp;shared_state)));        }        <span class="hljs-keyword">else</span>        {            std::cout &lt;&lt; <span class="hljs-string">"FlyweightFactory: Reusing existing flyweight.\n"</span>;        }        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>-&gt;flyweights_.<span class="hljs-built_in">at</span>(key);    }    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">ListFlyweights</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span><span class="hljs-function">    </span>{        <span class="hljs-type">size_t</span> count = <span class="hljs-keyword">this</span>-&gt;flyweights_.<span class="hljs-built_in">size</span>();        std::cout &lt;&lt; <span class="hljs-string">"\nFlyweightFactory: I have "</span> &lt;&lt; count &lt;&lt; <span class="hljs-string">" flyweights:\n"</span>;        <span class="hljs-keyword">for</span> (std::pair&lt;std::string, Flyweight&gt; pair : <span class="hljs-keyword">this</span>-&gt;flyweights_)        {            std::cout &lt;&lt; pair.first &lt;&lt; <span class="hljs-string">"\n"</span>;        }    }};<span class="hljs-comment">// ...</span><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">AddCarToPoliceDatabase</span><span class="hljs-params">(</span></span><span class="hljs-params"><span class="hljs-function">    FlyweightFactory &amp;ff, <span class="hljs-type">const</span> std::string &amp;plates, <span class="hljs-type">const</span> std::string &amp;owner,</span></span><span class="hljs-params"><span class="hljs-function">    <span class="hljs-type">const</span> std::string &amp;brand, <span class="hljs-type">const</span> std::string &amp;model, <span class="hljs-type">const</span> std::string &amp;color)</span></span><span class="hljs-function"></span>{    std::cout &lt;&lt; <span class="hljs-string">"\nClient: Adding a car to database.\n"</span>;    <span class="hljs-type">const</span> Flyweight &amp;flyweight = ff.<span class="hljs-built_in">GetFlyweight</span>({brand, model, color});    <span class="hljs-comment">// The client code either stores or calculates extrinsic state and passes it</span>    <span class="hljs-comment">// to the flyweight's methods.</span>    flyweight.<span class="hljs-built_in">Operation</span>({owner, plates});}<span class="hljs-comment">/**</span><span class="hljs-comment"> * The client code usually creates a bunch of pre-populated flyweights in the</span><span class="hljs-comment"> * initialization stage of the application.</span><span class="hljs-comment"> */</span><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>{    FlyweightFactory *factory = <span class="hljs-keyword">new</span> <span class="hljs-built_in">FlyweightFactory</span>({{<span class="hljs-string">"Chevrolet"</span>, <span class="hljs-string">"Camaro2018"</span>, <span class="hljs-string">"pink"</span>}, {<span class="hljs-string">"Mercedes Benz"</span>, <span class="hljs-string">"C300"</span>, <span class="hljs-string">"black"</span>}, {<span class="hljs-string">"Mercedes Benz"</span>, <span class="hljs-string">"C500"</span>, <span class="hljs-string">"red"</span>}, {<span class="hljs-string">"BMW"</span>, <span class="hljs-string">"M5"</span>, <span class="hljs-string">"red"</span>}, {<span class="hljs-string">"BMW"</span>, <span class="hljs-string">"X6"</span>, <span class="hljs-string">"white"</span>}});    factory-&gt;<span class="hljs-built_in">ListFlyweights</span>();    <span class="hljs-built_in">AddCarToPoliceDatabase</span>(*factory,                            <span class="hljs-string">"CL234IR"</span>,                            <span class="hljs-string">"James Doe"</span>,                            <span class="hljs-string">"BMW"</span>,                            <span class="hljs-string">"M5"</span>,                            <span class="hljs-string">"red"</span>);    <span class="hljs-built_in">AddCarToPoliceDatabase</span>(*factory,                            <span class="hljs-string">"CL234IR"</span>,                            <span class="hljs-string">"James Doe"</span>,                            <span class="hljs-string">"BMW"</span>,                            <span class="hljs-string">"X1"</span>,                            <span class="hljs-string">"red"</span>);    factory-&gt;<span class="hljs-built_in">ListFlyweights</span>();    <span class="hljs-keyword">delete</span> factory;    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;}</code></pre></div>]]></content>
    
    
    
    <tags>
      
      <tag>设计模式</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>数据结构</title>
    <link href="/2022/01/01/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    <url>/2022/01/01/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/</url>
    
    <content type="html"><![CDATA[<div class="toc"><!-- toc --><ul><li><a href="#shu-ju-jie-gou-shu-ju-jie-gou-shi-wei-suan-fa-fu-wu-er-she-ji-de">数据结构：数据结构是为算法服务而设计的。</a></li><li><a href="#shu-ju-jie-gou-bu-fen">数据结构部分</a><ul><li><a href="#yi-shu-ju-jie-gou-de-cun-chu-fang-shi-you-liang-chong">一. 数据结构的存储方式有两种</a></li><li><a href="#er-chang-jian-shu-ju-jie-gou-shi-xian">二 常见数据结构实现</a></li></ul></li></ul><!-- tocstop --></div><p>推荐看👉 <a href="https://oi-wiki.org/">OI Wiki</a></p><h1><span id="shu-ju-jie-gou-shu-ju-jie-gou-shi-wei-suan-fa-fu-wu-er-she-ji-de">数据结构：数据结构是为算法服务而设计的。</span><a href="#shu-ju-jie-gou-shu-ju-jie-gou-shi-wei-suan-fa-fu-wu-er-she-ji-de" class="header-anchor">#</a></h1><p>算法：充分且合理利用计算机资源处理数据而诞生。</p><h1><span id="shu-ju-jie-gou-bu-fen">数据结构部分</span><a href="#shu-ju-jie-gou-bu-fen" class="header-anchor">#</a></h1><h3><span id="yi-shu-ju-jie-gou-de-cun-chu-fang-shi-you-liang-chong">一. 数据结构的存储方式有两种</span><a href="#yi-shu-ju-jie-gou-de-cun-chu-fang-shi-you-liang-chong" class="header-anchor">#</a></h3><h4><span id="1-shun-xu-cun-chu-shu-zu-nei-cun-lian-xu">1.顺序存储(数组,内存连续)</span><a href="#1-shun-xu-cun-chu-shu-zu-nei-cun-lian-xu" class="header-anchor">#</a></h4><h4><span id="2-lian-shi-cun-chu-lian-biao-nei-cun-bu-lian-xu-yi-kao-jie-dian-de-zhi-zhen-zhi-xiang-xia-yi-ge-jie-dian">2.链式存储(链表,内存不连续,依靠节点的指针指向下一个节点)</span><a href="#2-lian-shi-cun-chu-lian-biao-nei-cun-bu-lian-xu-yi-kao-jie-dian-de-zhi-zhen-zhi-xiang-xia-yi-ge-jie-dian" class="header-anchor">#</a></h4><p>常见的数据结构有： </p><blockquote><p> 数组(array),链表(LinkedList),</p><p> 双向链表(doubly-linked-list),</p><p> 树：</p><ul><li><p>二叉树(Binary tree),</p></li><li><p>二叉查找树(Binary Search Tree),平衡二叉树(AVL),</p></li><li><p>2-3-4树</p></li><li><p>红黑树(Red Black Tree), B树, B+树, B*树, AA-树</p></li><li><p>treap树, k-d树, 伸展树(Splay Tree)</p></li><li><p>最小生成树(<strong>Minimum Spanning Tree</strong>)</p></li><li><p>图(graph),</p></li></ul><p> 栈(stack), 堆(heap),队列(queue),</p><p> 散列表(hash), 位图(bitmap),</p><p> 字典(map)</p></blockquote><h3><span id="er-chang-jian-shu-ju-jie-gou-shi-xian">二 常见数据结构实现</span><a href="#er-chang-jian-shu-ju-jie-gou-shi-xian" class="header-anchor">#</a></h3><h4><span id="1-lian-biao">1.链表</span><a href="#1-lian-biao" class="header-anchor">#</a></h4><ul><li><strong>链表(LinkedList)</strong></li></ul><blockquote><p>避免数组插入和删除的线性开销,我们需要允许表可以不连续存储,防止数据大量移动</p></blockquote><ul><li><strong>链表的设计</strong></li></ul><p>设计成一个链表节点至少包含两部分：</p><blockquote><p>数据部和指针部</p><p>数据部为我们要存储的数据,指针部为指向下一个链表节点</p></blockquote><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">ListElmt_</span>{    <span class="hljs-type">void</span> *data;    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">ListElmt_</span> *next;} ListElmt;</code></pre></div><h5><span id="dan-xiang-lian-biao">单向链表</span><a href="#dan-xiang-lian-biao" class="header-anchor">#</a></h5><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">ListElmt_</span>{    <span class="hljs-type">void</span> *data;    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">ListElmt_</span> *next;} ListElmt;</code></pre></div><h6><span id="li-zi">例子</span><a href="#li-zi" class="header-anchor">#</a></h6><div class="code-wrapper"><pre><code class="hljs hpp"><span class="hljs-comment">/*1ist.h*/</span><span class="hljs-meta">#<span class="hljs-keyword">ifndef</span> LIST_H </span><span class="hljs-meta">#<span class="hljs-keyword">define</span> LIST_H</span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><span class="hljs-comment">/* Define a structure for linked list elements. */</span> <span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">ListElnt_</span>{    <span class="hljs-type">void</span> *data:<span class="hljs-keyword">struct</span> <span class="hljs-title class_">ListElnt</span> *next;} ListElmt;<span class="hljs-comment">/* Define a structure for linked lists, */</span> <span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">List_</span>{    <span class="hljs-type">int</span> size:<span class="hljs-built_in">int</span> (*<span class="hljs-built_in">match</span>()<span class="hljs-type">const</span> <span class="hljs-type">void</span> *keyl, <span class="hljs-type">const</span> <span class="hljs-type">void</span> *key2);    <span class="hljs-built_in">void</span> (*destroy)(<span class="hljs-type">void</span> *data);ListElmt *head;    ListElmt *tail;} List;<span class="hljs-comment">/* Public Interface*/</span><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">list_init</span><span class="hljs-params">(List *list, <span class="hljs-type">void</span> (*destroy)(<span class="hljs-type">void</span> *data))</span></span>; <span class="hljs-comment">// 初始化一个链表以便于进行后续操作</span><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">list_destroy</span><span class="hljs-params">(List *list)</span></span>;<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">list_ins_next</span><span class="hljs-params">(List *list, ListEInt *element, <span class="hljs-type">const</span> <span class="hljs-type">void</span> *data)</span></span>; <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">list_rem_next</span><span class="hljs-params">(List *list, ListElnt *element, <span class="hljs-type">void</span> **data)</span></span>; <span class="hljs-meta">#<span class="hljs-keyword">define</span> list_size(list()(list)-&gt;size)</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> list_head(list()(list)-&gt;head) </span><span class="hljs-meta">#<span class="hljs-keyword">define</span> list_tail(1ist()(1ist)-&gt;tail)</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> list_is_head(list, element()(element)= (list)-&gt;head ? 1: 0) </span><span class="hljs-meta">#<span class="hljs-keyword">define</span> list_is_tail(element()(element)-&gt;next  NULL ? 1:0)</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> list_data(element()(element)-&gt;data) </span><span class="hljs-meta">#<span class="hljs-keyword">define</span> list_next(element()(element)-&gt;next)</span><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span></code></pre></div><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-comment">/* list.c*/</span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">"list.h"</span></span><span class="hljs-comment">/*list init */</span><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">list_init</span><span class="hljs-params">(List *list, <span class="hljs-type">void</span> (*destroy)(<span class="hljs-type">void</span> *data))</span> </span>{<span class="hljs-comment">/* Initialize the list. */</span>list-&gt;size = <span class="hljs-number">0</span>;list-&gt;destroy = destroy;     list-&gt;head = <span class="hljs-literal">NULL</span>;     list-&gt;tail = <span class="hljs-literal">NULL</span>;}<span class="hljs-comment">/*listdestroy*/</span><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">list_destroy</span><span class="hljs-params">(List *list)</span> </span>{<span class="hljs-type">void</span>* data;    <span class="hljs-comment">/* Remove each element.*/</span>    <span class="hljs-keyword">while</span> (<span class="hljs-built_in">list_size</span>(list) &gt; <span class="hljs-number">0</span>){        <span class="hljs-keyword">if</span> (<span class="hljs-number">0</span> == <span class="hljs-built_in">list_rem_next</span>(list, <span class="hljs-literal">NULL</span>, (<span class="hljs-type">void</span> **)&amp;data) &amp;&amp; <span class="hljs-literal">NULL</span> != list-&gt;destroy){    <span class="hljs-comment">/* Call a user-defined function to free dynanically allocated data, */</span>         list-&gt;<span class="hljs-built_in">destroy</span>(data);        }    }<span class="hljs-comment">/* No operations are allowed now, but clear the structure as a precaution. */</span>     <span class="hljs-built_in">memset</span>(list, <span class="hljs-number">0</span>, <span class="hljs-built_in">sizeof</span>(List));}<span class="hljs-comment">/*list_ins_next*/</span><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">list_ins_next</span><span class="hljs-params">(List *list, ListElmt *element,<span class="hljs-type">const</span> <span class="hljs-type">void</span> *data)</span></span>{     ListElmt*new_element;    <span class="hljs-comment">/*Allocate storage for the element. */</span>    <span class="hljs-keyword">if</span>(<span class="hljs-literal">NULL</span> == (new_element-(ListElmt*)<span class="hljs-built_in">malloc</span>(<span class="hljs-built_in">sizeof</span>(ListElmt))))    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;    <span class="hljs-comment">/* Insert the element into the list. */</span>     new_element-&gt;data = (<span class="hljs-type">void</span> *)data;     <span class="hljs-keyword">if</span> (element == <span class="hljs-literal">NULL</span>) {    <span class="hljs-comment">/* Handle insertion at the head of the list. */</span>         <span class="hljs-keyword">if</span> (<span class="hljs-built_in">list_size</span>(list)==<span class="hljs-number">0</span>)        list-&gt;tail = <span class="hljs-keyword">new</span> _element;        new_element-&gt;next = list-&gt;head;         list-&gt;head=new_element;     }    <span class="hljs-keyword">else</span>{    <span class="hljs-comment">/* Handle insertion somewhere other than at the head. */</span>         <span class="hljs-keyword">if</span>(element-&gt;next == <span class="hljs-literal">NULL</span>)        list-&gt;tail = new_element;        new_element-&gt;next = element-&gt;next;        element-&gt;next = new_element;     }    <span class="hljs-comment">/*Adjust the size of the list to account for the inserted element. */</span>     list-&gt;size++;    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;}<span class="hljs-comment">/* list_rem_next */</span><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">list_rem_next</span><span class="hljs-params">(List *list, ListElmt *element, <span class="hljs-type">void</span> **data)</span> </span>{    ListElmt*old_element;        <span class="hljs-comment">/*Do not allow removal from an empty list.*/</span>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">list_size</span>(list) == <span class="hljs-number">0</span>)<span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;    <span class="hljs-comment">/* Remove the element from the list. */</span>     <span class="hljs-keyword">if</span> (element == <span class="hljs-literal">NULL</span>)    {        <span class="hljs-comment">/* Handle removal from the head of the list, */</span>        *data = list-&gt;head-&gt;data;        old_element = list-&gt;head;         list-&gt;head = list-&gt;head-&gt;next;        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">list_size</span>(list) == <span class="hljs-number">1</span>)             list-&gt;tail = <span class="hljs-literal">NULL</span>;    }    <span class="hljs-keyword">else</span>    {        <span class="hljs-comment">/* Handle removal from somewhere other than the head. */</span>        <span class="hljs-keyword">if</span> (element—&gt;next == <span class="hljs-literal">NULL</span>)        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;        *data = element-&gt;next-&gt;data;         old_element = element-&gt;next;        element-&gt;next = element-&gt;next-&gt;next;        <span class="hljs-keyword">if</span> (element-&gt;next = <span class="hljs-literal">NULL</span>)             list-&gt;tail = element;    }        <span class="hljs-comment">/* Free the storage allocated by the abstract datatype. */</span>     <span class="hljs-built_in">free</span>(old_element);        <span class="hljs-comment">/*Adjust the size of the list to account for the removed element.*/</span>     <span class="hljs-number">1</span>ist—&gt;size--;     <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>; }</code></pre></div><h5><span id="shuang-xiang-lian-biao">双向链表</span><a href="#shuang-xiang-lian-biao" class="header-anchor">#</a></h5><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">DListEImt_</span>{    <span class="hljs-type">void</span> *data;    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">DListEImt_</span> *prev;    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">DListEImt_</span> *next;} DListEImt;</code></pre></div><h6><span id="li-zi">例子</span><a href="#li-zi" class="header-anchor">#</a></h6><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-comment">/*dlist h */</span><span class="hljs-meta">#<span class="hljs-keyword">ifndef</span> DLIST_H</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> DLIST_H</span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><span class="hljs-comment">/* Define a structure for doubly-linked list elements. */</span><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">DListEImt_</span>{    <span class="hljs-type">void</span> *data;    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">DListEImt_</span> *prev;    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">DListEImt_</span> *next;} DListEImt;<span class="hljs-comment">/*Define structure for doubly-linked lists. */</span><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">Dlist_</span>{    <span class="hljs-type">int</span> size;    <span class="hljs-built_in">int</span> (*match)(<span class="hljs-type">const</span> <span class="hljs-type">void</span>*key1, <span class="hljs-type">const</span> <span class="hljs-type">void</span> *key2);    <span class="hljs-built_in">void</span> (*destroy)(<span class="hljs-type">void</span> *data);    DListEImt *head;    DListEImt *tail;}DList;<span class="hljs-comment">/* Public Interface */</span><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dlist_init</span><span class="hljs-params">(DList *list, <span class="hljs-type">void</span> (*destroy)(<span class="hljs-type">void</span> *data))</span></span>;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dlist_destroy</span><span class="hljs-params">(DList *list)</span></span>;<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">dlist_ins_next</span><span class="hljs-params">(DList *list, DListEImt *element <span class="hljs-type">const</span> <span class="hljs-type">void</span> *data)</span></span>;<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">dlist_ins_prev</span><span class="hljs-params">(DList *list, DListEImt *element, <span class="hljs-type">const</span> <span class="hljs-type">void</span> *data)</span></span>;<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">dlist_remove</span><span class="hljs-params">(DList *list, DListEImt *element, <span class="hljs-type">void</span> **data)</span></span>;<span class="hljs-meta">#<span class="hljs-keyword">define</span> dlist_size(list)((list)-&gt;size)</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> dlist_tail(list)((list)-&gt;tail)</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> dlist_is_head(element)((element)-&gt;prev == NULL ? 1: 0)</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> dlist_is_tail(element)((element)-&gt;next == NULL ? 1: 0)</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> dlist_data(element)((element)-&gt;data)</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> diist_next(element)((element)-&gt;next)</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> dlist_prev(element)(element )-&gt;prev)</span></code></pre></div><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-comment">/*d]主st.C*/</span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> dlist . h</span><span class="hljs-comment">/* dlist init */</span><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dlist_init</span><span class="hljs-params">(DList *list, <span class="hljs-type">void</span> (*destroy)(<span class="hljs-type">void</span> *data))</span></span><span class="hljs-function"></span>{    <span class="hljs-comment">/* Initialize the list. */</span>    list-&gt;size = <span class="hljs-number">0</span>;    list-&gt;destory = destroy;    list-&gt;head = <span class="hljs-literal">NULL</span>;    list-&gt;tail = <span class="hljs-literal">NULL</span>;}<span class="hljs-comment">/* dlist_destory */</span><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dlist_destroy</span> <span class="hljs-params">(DList *list)</span></span><span class="hljs-function"></span>{    <span class="hljs-type">void</span> *data    <span class="hljs-comment">/* Remove each element. */</span>    <span class="hljs-keyword">while</span> (<span class="hljs-built_in">dlist_size</span>(list) &gt; <span class="hljs-number">0</span>)    {        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">dlist_remove</span>(list, <span class="hljs-built_in">dlist_tail</span>(list), (<span class="hljs-type">void</span>**)adata)==<span class="hljs-number">0</span>           &amp;&amp; list-&gt;destory != <span class="hljs-literal">NULL</span>)        {            <span class="hljs-comment">/* Call a user-defined function to free dynamically allocated data. */</span>            list-&gt;<span class="hljs-built_in">destroy</span>(data);        }    }            <span class="hljs-comment">/* No operations are allowed now, but clear the structure as a precaution. */</span>    <span class="hljs-built_in">memset</span>(list, <span class="hljs-number">0</span>, <span class="hljs-built_in">sizeof</span>(DList));}<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">dlist_ins_next</span><span class="hljs-params">(DList *list, DListElmt *element, <span class="hljs-type">const</span> <span class="hljs-type">void</span> *data)</span></span><span class="hljs-function"></span>{    DListElmt *new_element;        <span class="hljs-comment">/* Do not allow a NUll element unless the list is empty. */</span>    <span class="hljs-keyword">if</span> (element == <span class="hljs-literal">NULL</span> &amp;&amp; <span class="hljs-built_in">dlist_size</span>(list) != <span class="hljs-number">0</span>)        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;        <span class="hljs-comment">/* Allocate storage for the element. */</span>    <span class="hljs-keyword">if</span> ((new_element = (DListElmt *)<span class="hljs-built_in">malloc</span>(<span class="hljs-built_in">sizeof</span>(DListElmt)))== <span class="hljs-literal">NULL</span>)    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>:    <span class="hljs-comment">/* Insert the new_element into the list. */</span>    new_element-&gt;data = (<span class="hljs-type">void</span> *)data;        <span class="hljs-keyword">if</span> (dlist <span class="hljs-built_in">size</span>(list) == <span class="hljs-number">0</span>)    {        <span class="hljs-comment">/* Handle insertion when the list is empty. */</span>        list-&gt;head = new_element;        list-&gt;head-&gt;prev = <span class="hljs-literal">NULL</span>;        list-&gt;head-&gt;next = <span class="hljs-literal">NULL</span>;        list-&gt;tail = new_element;    }    <span class="hljs-keyword">else</span>{         <span class="hljs-comment">/* Handle insertion when the list is not empty. */</span>        new_element-&gt;next = element-&gt;next;        new_element-&gt;prev = element;        <span class="hljs-keyword">if</span>(element-&gt;next == <span class="hljs-literal">NULL</span>)            list-&gt;tail = new_element;        <span class="hljs-keyword">else</span>            element-&gt;next-&gt;prev = new_element;        element-&gt;next = new_element;    }       <span class="hljs-comment">/* Adjust the size of the list to account for the inserted element. */</span>    list-&gt;size++;    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;}<span class="hljs-comment">/* dlist ins_ prev */</span><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">dlist_ins_prev</span><span class="hljs-params">(DList *list, DListElmt *element, <span class="hljs-type">const</span> <span class="hljs-type">void</span> *data)</span></span><span class="hljs-function"></span>{    DListElmt *new_element;        <span class="hljs-comment">/* Do not allow a NULL element unless the list is empty. */</span>    <span class="hljs-keyword">if</span> (element == <span class="hljs-literal">NULL</span> &amp;&amp; <span class="hljs-built_in">dlist_size</span>(list) != <span class="hljs-number">0</span>)    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;        <span class="hljs-comment">/* Allocate storage to be managed by the abstract datatype. */</span>    <span class="hljs-keyword">if</span>(new_element = (DListElmt *)<span class="hljs-built_in">malloc</span>(<span class="hljs-built_in">sizeof</span>(DListElmt))) == <span class="hljs-literal">NULL</span>)    <span class="hljs-keyword">return</span> - <span class="hljs-number">1</span>;        <span class="hljs-comment">/* Insert the new_element into the list */</span>    new_element-&gt;data =(<span class="hljs-type">void</span> *)data;    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">dlist_size</span>(list)== <span class="hljs-number">0</span>)    {        <span class="hljs-comment">/* Handle insertion when the list is empty. */</span>        list-&gt;head = new_element;        list-&gt;head-&gt;prev = <span class="hljs-literal">NULL</span>;        list-&gt;head-&gt;next = <span class="hljs-literal">NULL</span>;        list-&gt;tail = new_element;    }    <span class="hljs-keyword">else</span>    {        <span class="hljs-comment">/* Handle inserton when the list is not empty. */</span>        new_element = element;        new_element-&gt;prev = element-&gt;prev;                <span class="hljs-keyword">if</span> (element-&gt;prev == <span class="hljs-literal">NULL</span>)        list-&gt;head = new_element;        <span class="hljs-keyword">else</span>        element-&gt;prev-&gt;next = new_element;        element-&gt;prev = new_element;    }        <span class="hljs-comment">/* Adjust the size of the list to account for the new_element. */</span>    list-&gt;size++;    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;}<span class="hljs-comment">/* d1ist_remove */</span><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">dlist_remove</span><span class="hljs-params">(DList *list, DListElmt. *element, <span class="hljs-type">void</span> s*data)</span></span><span class="hljs-function"></span>{    <span class="hljs-comment">/* Do not allow a NULL element or removal from an empty list. */</span>    <span class="hljs-keyword">if</span> (element == <span class="hljs-literal">NULL</span> || <span class="hljs-built_in">dlist_size</span>(list) == <span class="hljs-number">0</span>)    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>:    <span class="hljs-comment">/* remove the element from the list. */</span>    *data s element -&gt;data;            <span class="hljs-keyword">if</span> (element == list-&gt;head)    {        <span class="hljs-comment">/* Handle removal from the head of the list. */</span>    list-&gt;head = element-&gt;next;                <span class="hljs-keyword">if</span> (list-&gt;head == <span class="hljs-literal">NULL</span>)list-&gt;tail = <span class="hljs-literal">NULL</span>;        <span class="hljs-keyword">else</span>        element-&gt;next-&gt;prev = <span class="hljs-literal">NULL</span>;    }    <span class="hljs-keyword">else</span>    {        <span class="hljs-comment">/* Handle removal from other than the head of the list. */</span>        element-&gt;prev-&gt;next = element-&gt;next;        <span class="hljs-keyword">if</span> (element-&gt;next == <span class="hljs-literal">NULL</span>)            list-&gt;tail = elenent-&gt;prev;        <span class="hljs-keyword">else</span>            element-&gt;next-&gt;prev = element-&gt;prev;    }    <span class="hljs-comment">/* Free the storage allocated by the abstract datatype. */</span>    <span class="hljs-built_in">free</span>(element);        <span class="hljs-comment">/* Adjust the size of the list to account for the removed element */</span>    list-&gt;size--;    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;}</code></pre></div><h5><span id="xun-huan-lian-biao">循环链表</span><a href="#xun-huan-lian-biao" class="header-anchor">#</a></h5><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">ClistElmt_</span>{    <span class="hljs-type">void</span> *data;    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">ClistElmt_</span> *next;}ClistElmt;</code></pre></div><h6><span id="li-zi">例子</span><a href="#li-zi" class="header-anchor">#</a></h6><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-comment">/* clist .h */</span><span class="hljs-meta">#<span class="hljs-keyword">ifndef</span> CLIST_H </span><span class="hljs-meta">#<span class="hljs-keyword">define</span> CLIST_H </span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><span class="hljs-comment">/* Define a structure for circular list elements .*/</span><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">CListElmt</span> {    <span class="hljs-type">void</span> * data;    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">CListElmt</span> * next;} CListElmt;<span class="hljs-comment">/* Definea structure for circular lists .*/</span> <span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">CList_</span>{    <span class="hljs-type">int</span> size;    <span class="hljs-built_in">int</span> (*match)(constvoid * key1, <span class="hljs-type">const</span> <span class="hljs-type">void</span> * key2);    <span class="hljs-built_in">void</span> (*destroy)(<span class="hljs-type">void</span>* data);    CListElmt *head;}CList;<span class="hljs-comment">/* Public Interface */</span> <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">clist_init</span><span class="hljs-params">(CList* list,<span class="hljs-type">void</span> ( *destroy)( <span class="hljs-type">void</span>* data))</span></span>;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">clist_destroy</span><span class="hljs-params">(CList* list)</span></span>;<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">clist_ins_next</span> <span class="hljs-params">(CList* list,CListElmt * element,<span class="hljs-type">const</span> <span class="hljs-type">void</span> *data)</span></span>;<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">clist_rem_next</span> <span class="hljs-params">(CList* list,CListElmt * element,<span class="hljs-type">void</span> **data)</span></span>;<span class="hljs-meta">#defineclist _size(list)((list)-&gt;size)</span><span class="hljs-meta">#defineclist head (list)(()-&gt;head)</span><span class="hljs-meta">#defineclist data (element)((element)-&gt;data)</span><span class="hljs-meta">#defineclist _next(element)((element)-&gt;next)</span><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span></code></pre></div><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-comment">/* clist .c */</span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h &gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">"clist.h"</span></span><span class="hljs-comment">/* clist init */</span><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">clist_init</span><span class="hljs-params">(CList* list,<span class="hljs-type">void</span> ( *destroy)( <span class="hljs-type">void</span>* data))</span></span><span class="hljs-function"></span>{    <span class="hljs-comment">/* Initialize the list .*/</span>     list-&gt;size = <span class="hljs-number">0</span>;    list-&gt;destroy = destroy ;    list-&gt;head = <span class="hljs-literal">NULL</span>;}<span class="hljs-comment">/* clist destroy */</span> <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">clist_destroy</span> <span class="hljs-params">(CList* list)</span></span><span class="hljs-function"></span>{    <span class="hljs-type">void</span> *data;    <span class="hljs-comment">/* Remove each element .*/</span>     <span class="hljs-keyword">while</span> (<span class="hljs-built_in">clist_size</span>(list) &gt; <span class="hljs-number">0</span>)    {        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">clist_remnext</span> (list,list-&gt;head, (<span class="hljs-type">void</span> **)&amp;data)== <span class="hljs-number">0</span>            &amp;&amp; list-&gt;destroy != <span class="hljs-literal">NULL</span>)        {            <span class="hljs-comment">/* Call a user-defined function to free dynamically allocated data .*/</span>             list-&gt;<span class="hljs-built_in">destroy</span>(data);        }    }            <span class="hljs-comment">/* No operations are allowed now ,but clear the structure as a precaution .*/</span><span class="hljs-built_in">memset</span> (list, <span class="hljs-number">0</span>, <span class="hljs-built_in">sizeof</span>(CList));}      <span class="hljs-comment">/* clist ins next */</span><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">clist_insnext</span> <span class="hljs-params">(CList* list,CListElmt * element,<span class="hljs-type">const</span> <span class="hljs-type">void</span> * data)</span></span><span class="hljs-function"></span>{    CListElmt* new_element;    <span class="hljs-comment">/*Allocate storage for the element .*/</span>    <span class="hljs-keyword">if</span> ((new_element = (CListElmt* )<span class="hljs-built_in">malloc</span>(<span class="hljs-built_in">sizeof</span>(CListElmt))) == <span class="hljs-literal">NULL</span>)    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;        <span class="hljs-comment">/* Insert the element into the list .*/</span>     new_element-&gt;data = (<span class="hljs-type">void</span> *)data;    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">clist_size</span>(list) == <span class="hljs-number">0</span>)    {        <span class="hljs-comment">/* Handle insertion when the list empty .*/</span>        new_element-&gt;next = new_element;        list-&gt;head = new_element;    }      <span class="hljs-keyword">else</span>     {        <span class="hljs-comment">/* Handle insertion when the list is not empty .*/</span>        new_element-&gt;next = element-&gt;next;        element-&gt;next = new_element;    }    <span class="hljs-comment">/* Adjust the size of the list to account for the inserted element .*/</span>     list-&gt;size++;    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span> ;}<span class="hljs-comment">/* clist_rem_next */</span><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">clist_rem_next</span><span class="hljs-params">(CList* list, CListElmt *element,<span class="hljs-type">void</span> **data)</span></span><span class="hljs-function"></span>{    CListElmt * old_element;        <span class="hljs-comment">/* Do not allow removal from an empty list . */</span>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">clist_size</span>(list) == <span class="hljs-number">0</span>)    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;        <span class="hljs-comment">/* Remove the element from the list . */</span>    *data = element-&gt;next-&gt;data;    <span class="hljs-keyword">if</span> (element-&gt;next == element)    {        <span class="hljs-comment">/* Handle removing the last element . */</span>        old_element = element-&gt;next;        list-&gt;headNULL;    }        <span class="hljs-keyword">else</span>     {        <span class="hljs-comment">/* Handle removing other than the last element . */</span>        old_element = element-&gt;next;        element-&gt;next = element-&gt;next-&gt;next;        <span class="hljs-keyword">if</span> (old_element == <span class="hljs-built_in">clist_head</span>(list))        list-&gt;head = old_element-&gt;next;    }            <span class="hljs-comment">/* Free the storage allocated by the abstract datatype . */</span>    <span class="hljs-built_in">free</span>(old_element);        <span class="hljs-comment">/* Adjust the size of the list to account for the removed element . */</span>    <span class="hljs-number">1</span>ist-&gt;size--;    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;}</code></pre></div><h4><span id="2-zhan-he-dui-lie">2.栈和队列</span><a href="#2-zhan-he-dui-lie" class="header-anchor">#</a></h4><p>栈和队列是另一种数据的存储方式。</p><p>用于检索数据的常用数据结构称为栈,栈的检索顺序和存储元素相反</p><blockquote><p>栈: 按照后进先出的顺序存储和检索数据的高效数据结构, 它检索数据的顺序和存储数据相反。</p></blockquote><blockquote><p>队列：按照先进先出的顺序存储和检索数据的高效数据结构, 它按照存储元素的顺序检索元素。</p></blockquote><h5><span id="zhan-li-zi">栈例子</span><a href="#zhan-li-zi" class="header-anchor">#</a></h5><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-comment">/* stack .h*/</span><span class="hljs-meta">#<span class="hljs-keyword">ifndef</span> STACK_H </span><span class="hljs-meta">#<span class="hljs-keyword">define</span> STACK_H </span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">"list.h"</span></span><span class="hljs-comment">/* Implement stacks as linked lists .*/</span> <span class="hljs-keyword">typedef</span> List Stack;<span class="hljs-comment">/*Public Interface */</span> <span class="hljs-meta">#<span class="hljs-keyword">define</span> stack_init list_init </span><span class="hljs-meta">#<span class="hljs-keyword">define</span> stack_destroy list_destroy</span><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">stack_push</span><span class="hljs-params">(Stack* stack,<span class="hljs-type">const</span> <span class="hljs-type">void</span> * data)</span></span>;<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">stack_pop</span><span class="hljs-params">(Stack* stack,<span class="hljs-type">void</span> ** data)</span></span>;<span class="hljs-meta">#<span class="hljs-keyword">define</span> stack_peek(stack)((stack)-&gt;head == NULL ? NULL : (stack)-&gt;head-&gt;data)</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> stack_size list_size </span><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span></code></pre></div><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-comment">/* Stack.c */</span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">"list.h"</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">"Stack.h"</span></span><span class="hljs-comment">/* stack_push */</span><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">stack_push</span><span class="hljs-params">(Stack* stack,<span class="hljs-type">const</span> <span class="hljs-type">void</span> * data)</span></span><span class="hljs-function"></span>{    <span class="hljs-comment">/* push the data onto the stack. */</span><span class="hljs-keyword">return</span> <span class="hljs-built_in">list_ins_next</span>(stack, <span class="hljs-literal">NULL</span>, data);}<span class="hljs-comment">/* stack_pop */</span><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">stack_pop</span><span class="hljs-params">(Stack* stack,<span class="hljs-type">void</span> ** data)</span></span><span class="hljs-function"></span>{    <span class="hljs-comment">/* Pop the data off the stack. */</span><span class="hljs-keyword">return</span> <span class="hljs-built_in">list_rem_next</span>(stack, <span class="hljs-literal">NULL</span>, data);}</code></pre></div><h5><span id="dui-lie-li-zi">队列例子</span><a href="#dui-lie-li-zi" class="header-anchor">#</a></h5><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-comment">/* queue . h */</span> <span class="hljs-meta">#<span class="hljs-keyword">ifndef</span> QUEUE_H </span><span class="hljs-meta">#<span class="hljs-keyword">define</span> QUEUE_H </span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span> </span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">"list.h"</span> </span><span class="hljs-comment">/* Implement queues as linked lists . */</span> <span class="hljs-keyword">typedef</span> List Queue ; <span class="hljs-comment">/* Public Interface */</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> queue_init list_init </span><span class="hljs-meta">#<span class="hljs-keyword">define</span> queue_destroy list_destroy </span><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">queue_enqueue</span> <span class="hljs-params">(Queue * queue, <span class="hljs-type">const</span> <span class="hljs-type">void</span>* data )</span></span>; <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">queue_dequeue</span> <span class="hljs-params">(Queue * queue, <span class="hljs-type">void</span> **data)</span></span>;<span class="hljs-meta">#<span class="hljs-keyword">define</span> queue_peek(queue()(queue)-&gt;head == NULL ? NULL : (queue)-&gt;head-&gt;data)</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> queue_size list_size </span><span class="hljs-meta">#<span class="hljs-keyword">endif</span> </span></code></pre></div><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-comment">/* queue.c */</span> <span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib&gt;</span>h &gt; </span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">"list.h"</span> </span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">"queue.h"</span> </span><span class="hljs-comment">/* queue_enqueue */</span><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">queue_enqueue</span> <span class="hljs-params">(Queue* queue, <span class="hljs-type">const</span> <span class="hljs-type">void</span>* data)</span> </span><span class="hljs-function"></span>{    <span class="hljs-comment">/* Enqueue the data . */</span>     <span class="hljs-keyword">return</span> <span class="hljs-built_in">list_ins_next</span>(queue, <span class="hljs-built_in">list_tail</span>(queue), data); }<span class="hljs-comment">/* queue_dequeue */</span><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">queue_dequeue</span><span class="hljs-params">(Queue* queue, <span class="hljs-type">void</span>** data)</span></span><span class="hljs-function"></span>{    <span class="hljs-comment">/* Dequeue the data . */</span>     <span class="hljs-keyword">return</span> <span class="hljs-built_in">list_rem_next</span>(queue, <span class="hljs-literal">NULL</span>, data); }</code></pre></div><h5><span id="dui-lie-shi-li-shi-jian-chu-li">队列示例：事件处理</span><a href="#dui-lie-shi-li-shi-jian-chu-li" class="header-anchor">#</a></h5><p>遵循实时事件发生的顺序执行。</p><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-comment">/* events.c */</span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">"event.h"</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">"events.h"</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">"queue.h"</span></span><span class="hljs-comment">/* receive_event */</span><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">receive_event</span><span class="hljs-params">(Queue *events, <span class="hljs-type">const</span> Event *event)</span></span><span class="hljs-function"></span>{    Event* new_event;        <span class="hljs-comment">/* Allocate space for the event. */</span>    <span class="hljs-keyword">if</span>(<span class="hljs-literal">NULL</span> == (new_event = (Event*)(<span class="hljs-built_in">sizeof</span>(Event))))        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;        <span class="hljs-comment">/* Make a copy of the event and enqueue it. */</span><span class="hljs-built_in">memcpy</span>(new_event, event, <span class="hljs-built_in">sizeof</span>(Event));        <span class="hljs-keyword">if</span>(<span class="hljs-built_in">queue_enqueue</span>(events, new_event) != <span class="hljs-number">0</span>)        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;}<span class="hljs-comment">/* process_event */</span><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">process_event</span><span class="hljs-params">(Queue *events, <span class="hljs-type">int</span> (*dispatch)(Event* event))</span></span><span class="hljs-function"></span>{    Event* event;        <span class="hljs-keyword">if</span>(<span class="hljs-number">0</span> == <span class="hljs-built_in">queue_size</span>(events))        <span class="hljs-comment">/* Return that there are no events to dispatch. */</span><span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;    <span class="hljs-keyword">else</span>    {        <span class="hljs-keyword">if</span>(<span class="hljs-number">0</span> != <span class="hljs-built_in">queue_deququq</span>(events, (<span class="hljs-type">void</span> **)&amp;event))            <span class="hljs-comment">/* Return that an event could not be retrived. */</span>    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;        <span class="hljs-keyword">else</span>        {            <span class="hljs-comment">/* Call a user-defined fintion to dispatch the event. */</span>        <span class="hljs-built_in">dispatch</span>(event);        <span class="hljs-built_in">free</span>(event);        }    }    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;}</code></pre></div><h4><span id="3-ji-he">3.集合</span><a href="#3-ji-he" class="header-anchor">#</a></h4><p>集合定义：集合是相关联成员的无序组合,且每个成员在集合中只出现一次</p><h5><span id="li-zi">例子</span><a href="#li-zi" class="header-anchor">#</a></h5><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-comment">/* set.h */</span><span class="hljs-meta">#<span class="hljs-keyword">ifndef</span> SET_H</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> SET_H</span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;Stdlib.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">"list.h"</span></span><span class="hljs-comment">/* Implement sets as linked lists. */</span><span class="hljs-keyword">typedef</span> List Set;<span class="hljs-comment">/* Public Interface */</span><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">set_init</span><span class="hljs-params">(Set *set, <span class="hljs-type">int</span> (*match)(<span class="hljs-type">const</span> <span class="hljs-type">void</span> *keyl, <span class="hljs-type">const</span> <span class="hljs-type">void</span> *key2), <span class="hljs-type">void</span> (*destory)(<span class="hljs-type">void</span> *data))</span></span>;<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">set_insert</span><span class="hljs-params">(Set *set, <span class="hljs-type">const</span> <span class="hljs-type">void</span> *data)</span></span>;<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">set_remcve</span><span class="hljs-params">(Set *set, <span class="hljs-type">void</span> **data)</span></span>;<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">set_union</span><span class="hljs-params">(Set *setu, <span class="hljs-type">const</span> Set *setl, <span class="hljs-type">const</span> Set *set2)</span></span>;<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">set_intersection</span><span class="hljs-params">(Set*seti, <span class="hljs-type">const</span> Set *seta, <span class="hljs-type">const</span> Set *set2)</span></span>;<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">set_difference</span><span class="hljs-params">(Set *setd, <span class="hljs-type">const</span> Set *setl, <span class="hljs-type">const</span> Set *set2)</span></span>;<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">set_is_memeber</span><span class="hljs-params">(<span class="hljs-type">const</span> Set *set, <span class="hljs-type">const</span> <span class="hljs-type">void</span> *data)</span></span>;<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">set_is_subset</span><span class="hljs-params">(<span class="hljs-type">const</span> Set *setl, <span class="hljs-type">const</span> Set *set2)</span></span>;<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">set_is_equal</span><span class="hljs-params">(<span class="hljs-type">const</span> Set *setl, <span class="hljs-type">const</span> Set *set2)</span></span>;<span class="hljs-meta">#<span class="hljs-keyword">define</span> set_size(set()(set) osize)</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> set_destroy list_destroy</span><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span></code></pre></div><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-comment">/* set.c */</span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;Stdlib.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">"list.h"</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">"set.h"</span></span><span class="hljs-comment">/* set_init */</span><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">set_init</span><span class="hljs-params">(Set *set, <span class="hljs-type">int</span> (*match)(<span class="hljs-type">const</span> <span class="hljs-type">void</span> *keyl, <span class="hljs-type">const</span> <span class="hljs-type">void</span> *key2), <span class="hljs-type">void</span> (*destory)(<span class="hljs-type">void</span> *data))</span></span><span class="hljs-function"></span>{    <span class="hljs-comment">/* Initialize the set. */</span>    <span class="hljs-built_in">list_init</span>(set, destory);    set-&gt;match = match;}<span class="hljs-comment">/* set_insert */</span><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">set_insert</span><span class="hljs-params">(Set *set, <span class="hljs-type">const</span> <span class="hljs-type">void</span> *data)</span></span><span class="hljs-function"></span>{    <span class="hljs-comment">/* Do not allow the insertion of duplicates. */</span>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">set_in_number</span>(set, data))        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;    <span class="hljs-comment">/* Insert the data. */</span>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">list_ins_tail</span>(set, <span class="hljs-built_in">list_tail</span>(set), data);}<span class="hljs-comment">/* set_remove. */</span><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">set_remove</span><span class="hljs-params">(Set* set, <span class="hljs-type">void</span> **data)</span></span><span class="hljs-function"></span>{    ListE1mt *member, *prev;        <span class="hljs-comment">/* Find the member to remove.*/</span>    prev = <span class="hljs-literal">NULL</span>;    <span class="hljs-keyword">for</span> (member = <span class="hljs-built_in">list_head</span>(set); member != <span class="hljs-literal">NULL</span>; member = <span class="hljs-built_in">list_next</span>(member))    {        <span class="hljs-function"><span class="hljs-keyword">if</span> <span class="hljs-title">list_data</span><span class="hljs-params">(member)</span>))</span><span class="hljs-function">            <span class="hljs-keyword">break</span></span>;        prev = member;    }           <span class="hljs-comment">/* Return if the member was not found.*/</span>    <span class="hljs-keyword">if</span> (member == <span class="hljs-literal">NULL</span>)        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span> ;        <span class="hljs-comment">/* Remove the member. */</span>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">list_rem_next</span>(set, prev, data);}<span class="hljs-comment">/* set_union */</span><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">set_unicn</span><span class="hljs-params">(Set *setu, <span class="hljs-type">const</span> Set *setl, <span class="hljs-type">const</span> Set *set2)</span></span><span class="hljs-function"></span>{    ListE1mt *member;    <span class="hljs-type">void</span> *data;        <span class="hljs-comment">/* Initialize the set for the union. */</span>    <span class="hljs-built_in">set_init</span>(setu, set1-&gt;match, <span class="hljs-literal">NULL</span>);        <span class="hljs-comment">/* Insert the members of the first set. */</span>    <span class="hljs-keyword">for</span> (member = <span class="hljs-built_in">list_head</span>(setl); member != <span class="hljs-literal">NULL</span>; member = <span class="hljs-built_in">list_next</span>(member))   {        data = <span class="hljs-built_in">list_data</span>(member);        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">list_ins_next</span>(setu, <span class="hljs-built_in">list_tail</span>(setu), data) != <span class="hljs-number">0</span>)         {            <span class="hljs-built_in">set_destroy</span>(setu);            <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;        }}    <span class="hljs-comment">/* Insert the members of the second set. */</span>    <span class="hljs-keyword">for</span> (member = <span class="hljs-built_in">list_head</span>(set2); member != <span class="hljs-literal">NULL</span>; member = <span class="hljs-built_in">list_next</span>(member))     {        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">set_is_member</span>(setl, <span class="hljs-built_in">list_data</span>(member)))        {             <span class="hljs-comment">/* Do not allow the insertion of duplicates. */</span>             <span class="hljs-keyword">continue</span>;        }        <span class="hljs-keyword">else</span>        {            data = <span class="hljs-built_in">list_data</span>(member);            <span class="hljs-keyword">if</span> (<span class="hljs-built_in">list_ins_next</span>(setu, <span class="hljs-built_in">list_tail</span>(setu), data) != <span class="hljs-number">0</span>)            {                <span class="hljs-built_in">set_destroy</span>(setu);                <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;            }        }    }    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;}    <span class="hljs-comment">/* set_intersection */</span><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">set_intersection</span><span class="hljs-params">(Set *seti, <span class="hljs-type">const</span> Set *setl, <span class="hljs-type">const</span> Set *set2)</span></span><span class="hljs-function"></span>{     ListElmt *member;    <span class="hljs-type">void</span> *data;        <span class="hljs-comment">/* Initialize the set for the intersection. */</span>     <span class="hljs-built_in">set_init</span>(set1, set1-&gt;match, <span class="hljs-literal">NULL</span>);        <span class="hljs-comment">/* Insert the members present in both sets- */</span>     <span class="hljs-keyword">for</span> (member = <span class="hljs-built_in">list_head</span>(set1); member != <span class="hljs-literal">NULL</span>; member = <span class="hljs-built_in">list_next</span>(member))    {        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">set_is_member</span>(set2, <span class="hljs-built_in">list_data</span>(member)))        {            data = <span class="hljs-built_in">list_data</span>(member);            <span class="hljs-keyword">if</span> (<span class="hljs-built_in">list_ins_next</span>(seti, <span class="hljs-built_in">list_tail</span>(seti), data) != <span class="hljs-number">0</span>)                {                    <span class="hljs-built_in">set_destroy</span>(seti);                    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;                }}    }    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;}<span class="hljs-comment">/* set_difference */</span><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">set_difference</span><span class="hljs-params">(Set *setd, <span class="hljs-type">const</span> Set *seti, <span class="hljs-type">const</span> Set *set2)</span></span><span class="hljs-function"></span>{     ListElmt *member;    <span class="hljs-type">void</span> *data;    <span class="hljs-comment">/* Initialize the set for the difference. */</span>    $<span class="hljs-built_in">et_init</span>(setd, set1-Mnatch, <span class="hljs-literal">NULL</span>);    <span class="hljs-comment">/* Insert the members from setl not in set2 */</span>    <span class="hljs-keyword">for</span> (member = <span class="hljs-built_in">list_head</span>(setl); member != <span class="hljs-literal">NULL</span>; member = <span class="hljs-built_in">list_next</span>(member))    {         <span class="hljs-keyword">if</span> (<span class="hljs-built_in">lset_is_member</span>(set2, <span class="hljs-built_in">list_data</span>(member)))        {              data = <span class="hljs-built_in">list_data</span>(member);             <span class="hljs-keyword">if</span> (<span class="hljs-built_in">list_ins_next</span>(setd, <span class="hljs-built_in">list_tail</span>(setd), data) != <span class="hljs-number">0</span>)             {                 <span class="hljs-built_in">set_destroy</span>(setd);                <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;             }        }    }    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;}<span class="hljs-comment">/* set_ls_member */</span><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">set_is_member</span><span class="hljs-params">(<span class="hljs-type">const</span> Set *set <span class="hljs-type">const</span> <span class="hljs-type">void</span> *data)</span></span><span class="hljs-function"></span>{     ListElmt *member;    <span class="hljs-comment">/* Determine if the data is a member of the set. */</span>     <span class="hljs-keyword">for</span> (member = <span class="hljs-built_in">list_head</span>(set); member != <span class="hljs-literal">NULL</span>; member = <span class="hljs-built_in">list_next</span>(member))    {        <span class="hljs-keyword">if</span> (set-&gt;<span class="hljs-built_in">match</span>(dataj <span class="hljs-built_in">listdata</span>(member)))             <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;    }    <span class="hljs-keyword">return</span> o;}<span class="hljs-comment">/* set_is_subset */</span><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">set_is_subset</span><span class="hljs-params">(<span class="hljs-type">const</span> Set *setl, <span class="hljs-type">const</span> Set *set2)</span></span><span class="hljs-function"></span>{    ListElmt*加ember;    <span class="hljs-comment">/* Do a quick test to rule out some cases. */</span>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">set_size</span>(setl) &gt; <span class="hljs-built_in">set_size</span>(set2))         <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;        <span class="hljs-comment">/* Determine if setl is a subset of set2, */</span>    <span class="hljs-keyword">for</span> (member = <span class="hljs-built_in">list_head</span>(set1); member != <span class="hljs-literal">NULL</span>; member = <span class="hljs-built_in">list_next</span>(member))    {        <span class="hljs-keyword">if</span>(!<span class="hljs-built_in">list_is_member</span>(set2, <span class="hljs-built_in">list_data</span>(member)))            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;    }    <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;}<span class="hljs-comment">/* setis_equal */</span><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">set_is_equal</span><span class="hljs-params">(<span class="hljs-type">const</span> Set *setl, <span class="hljs-type">const</span> Set *set2)</span></span><span class="hljs-function"></span>{    <span class="hljs-comment">/* Do a quick test to rule out some cases. */</span>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">set_size</span>(setl) != <span class="hljs-built_in">set_size</span>(set2))        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;    <span class="hljs-comment">/* Sets of the same size are equal if they are subsets, */</span>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">set_is_subset</span>(set1, set2);}</code></pre></div><h5><span id="set-shi-li-ji-he-fu-gai">Set示例：集合覆盖</span><a href="#set-shi-li-ji-he-fu-gai" class="header-anchor">#</a></h5><p>集合覆盖是一种优化求解问题, 对很多组合数学和资源选择问题给出了漂亮的抽象模型</p><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-comment">/* cover,c */</span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">"cover.h”</span></span><span class="hljs-string"><span class="hljs-meta">#include "</span>list<span class="hljs-string">'h"</span></span><span class="hljs-string"><span class="hljs-meta">#include "set.h"</span></span><span class="hljs-string"><span class="hljs-meta">/* cover */</span></span><span class="hljs-string"><span class="hljs-meta">int cover(Set *members&gt; Set 率subsets, Set *covering) </span></span><span class="hljs-string"><span class="hljs-meta">{</span></span><span class="hljs-string"><span class="hljs-meta">   Set intersection;</span></span><span class="hljs-string"><span class="hljs-meta">   KSet *subset;</span></span><span class="hljs-string"><span class="hljs-meta">   ListElflit "member,</span></span><span class="hljs-string"><span class="hljs-meta">              *max_member;</span></span><span class="hljs-string"><span class="hljs-meta">   void *data;</span></span><span class="hljs-string"><span class="hljs-meta">   int max_size;</span></span><span class="hljs-string"><span class="hljs-meta">    </span></span><span class="hljs-string"><span class="hljs-meta">   /* Initialize the covering» */</span></span><span class="hljs-string"><span class="hljs-meta">   set_init(covering, subsets-&gt;match, NULL);</span></span><span class="hljs-string"><span class="hljs-meta">    </span></span><span class="hljs-string"><span class="hljs-meta">   /* Continue while there are noncovered members and candidate subsets. */ </span></span><span class="hljs-string"><span class="hljs-meta">    while (set_size(members) &gt; 0 &amp;&amp; set_size(subset) &gt; 0)</span></span><span class="hljs-string"><span class="hljs-meta">    {</span></span><span class="hljs-string"><span class="hljs-meta">       </span></span><span class="hljs-string"><span class="hljs-meta">        /* Find the subset that covers the most members.*/</span></span><span class="hljs-string"><span class="hljs-meta">        max_size = 0;</span></span><span class="hljs-string"><span class="hljs-meta">        for (member = list_head(subsets); member != NULL;</span></span><span class="hljs-string"><span class="hljs-meta">                    member = list_next(member))</span></span><span class="hljs-string"><span class="hljs-meta">        { </span></span><span class="hljs-string"><span class="hljs-meta">           if (set-intersectionC&amp;intersection, &amp;((KSet *)list_data(member))-&gt;set, members) != 0)</span></span><span class="hljs-string"><span class="hljs-meta">           {</span></span><span class="hljs-string"><span class="hljs-meta">              return -1;</span></span><span class="hljs-string"><span class="hljs-meta">           }</span></span><span class="hljs-string"><span class="hljs-meta">           if (set_size(&amp;inteisection) &gt; max_size)</span></span><span class="hljs-string"><span class="hljs-meta">           {</span></span><span class="hljs-string"><span class="hljs-meta">              max_member = member;</span></span><span class="hljs-string"><span class="hljs-meta">              max_size = set_size(&amp;intersection);</span></span><span class="hljs-string"><span class="hljs-meta">           }</span></span><span class="hljs-string"><span class="hljs-meta">           set_destroy(&amp;intersection);</span></span><span class="hljs-string"><span class="hljs-meta">        }</span></span><span class="hljs-string"><span class="hljs-meta">        /* A covering is not possible if there was no intersection♦ */</span></span><span class="hljs-string"><span class="hljs-meta">        if (max_size == 0)</span></span><span class="hljs-string"><span class="hljs-meta">           return 1;</span></span><span class="hljs-string"><span class="hljs-meta"></span></span><span class="hljs-string"><span class="hljs-meta">        /* Insert the selected subset into the covering» */</span></span><span class="hljs-string"><span class="hljs-meta">        subset = (KSet *)list_data(max_nember);</span></span><span class="hljs-string"><span class="hljs-meta"></span></span><span class="hljs-string"><span class="hljs-meta">        if (set_insert(coverings, subset) != 0)</span></span><span class="hljs-string"><span class="hljs-meta">           return -1;</span></span><span class="hljs-string"><span class="hljs-meta"></span></span><span class="hljs-string"><span class="hljs-meta">        /* Remove each covered member -from the set of noncovered members. */</span></span><span class="hljs-string"><span class="hljs-meta">        for (member = list_head(&amp;((KSet *)list_data(max_member))-&gt;set);</span></span><span class="hljs-string"><span class="hljs-meta">              member != NULL; member = list_next(member)))</span></span><span class="hljs-string"><span class="hljs-meta">        {</span></span><span class="hljs-string"><span class="hljs-meta">            data = list_data(member);</span></span><span class="hljs-string"><span class="hljs-meta">            if(set_remove(members, (void*)&amp;data) == 0 &amp;&amp; members-&gt;destory != NULL)</span></span><span class="hljs-string"><span class="hljs-meta">                members-&gt;destory(data);</span></span><span class="hljs-string"><span class="hljs-meta">        }</span></span><span class="hljs-string"><span class="hljs-meta"></span></span><span class="hljs-string"><span class="hljs-meta">        /* Remove the subset from the set of cnadidate subsets. */</span></span><span class="hljs-string"><span class="hljs-meta">if(set_remove(subsets, (void**)&amp;subset) != 0)</span></span><span class="hljs-string"><span class="hljs-meta">    return -1;</span></span><span class="hljs-string"><span class="hljs-meta">    }</span></span><span class="hljs-string"><span class="hljs-meta">    </span></span><span class="hljs-string"><span class="hljs-meta">    /* No covering is possible if there are still noncoverd member */</span></span><span class="hljs-string"><span class="hljs-meta">if(set_size(members) &gt; 0)</span></span><span class="hljs-string"><span class="hljs-meta">        return -1;</span></span><span class="hljs-string"><span class="hljs-meta">    </span></span><span class="hljs-string"><span class="hljs-meta">    return 0;</span></span><span class="hljs-string"><span class="hljs-meta">}</span></span><span class="hljs-string"><span class="hljs-meta"></span></span></code></pre></div><h4><span id="4-ha-xi-biao">4.哈希表</span><a href="#4-ha-xi-biao" class="header-anchor">#</a></h4><p>哈希表是一种最有效的检索方法：<code>散列</code>。</p><p>从根本上来说,一个哈希表包含一个数组, 通过特殊的索引值(键)来访问数组中的元素,哈希表的主要思想是通过一个哈希函 数,在所有可能的键与槽位之间建立一张映射表。哈希函数每次接受一个键将返回与 键相对应的哈希编码或哈希值。键的数据类型可能多种多样,但哈希值的类型只能是整型。</p><h5><span id="lian-shi-ha-xi-biao">链式哈希表</span><a href="#lian-shi-ha-xi-biao" class="header-anchor">#</a></h5><p>将数据存储在 <code>桶</code> (bucket)中的哈希表。每个 “桶” 都是都是一个链表; 且链表的<br>容量能够随着冲突的增加而增大。</p><h6><span id="jie-jue-ha-xi-biao-chong-tu">解决哈希表冲突</span><a href="#jie-jue-ha-xi-biao-chong-tu" class="header-anchor">#</a></h6><p>如果想插入表中的元素数量远大于<code>桶</code>数量,那么即使是在一个均匀散列过的程中,表的性能会迅速降低。这种情况下<code>桶</code>会变得越来越深。因此我们要注意一个哈希表的<code>负载因子</code>。</p><p>其定义为：</p><p>​                <code>α = n/m</code></p><p>​                n为表中的元素数量,m是桶中的数量(数组元素数量)。</p><p>​                在均匀散列情况下,链式哈希表的负载因子告诉我们表中<code>桶</code>能装元素的最大值</p><h6><span id="xuan-ze-ha-xi-han-shu">选择哈希函数</span><a href="#xuan-ze-ha-xi-han-shu" class="header-anchor">#</a></h6><p>  这是哈希算法的核心问题：将键随机地分散到表中,使冲突最小化。因此,选择一 个能够实现这一过程的哈希函数尤为重要。</p><p>其定义为：</p><p>​                <code>h(k) = x</code></p><p>​                k为要被映射的值,h()为哈希函数,x为哈希表的位置</p><h6><span id="li-zi">例子</span><a href="#li-zi" class="header-anchor">#</a></h6><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-comment">/* chtbl.h */</span><span class="hljs-meta">#<span class="hljs-keyword">ifndef</span> CHTBL_H</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> CHTBL_H</span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">"list.h"</span></span><span class="hljs-comment">/* Define a structure for chained hash table. */</span><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">CHTBL_</span>{    <span class="hljs-type">int</span> buckets;        <span class="hljs-built_in">int</span> (*h)(<span class="hljs-type">const</span> <span class="hljs-type">void</span>* key);    <span class="hljs-built_in">int</span> (*match)(<span class="hljs-type">const</span> <span class="hljs-type">void</span>* key1, <span class="hljs-type">const</span> <span class="hljs-type">void</span> *key2);        <span class="hljs-type">int</span> size;    List* table;} CHTbl;<span class="hljs-comment">/* Public interface */</span><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">chtbl_init</span><span class="hljs-params">(CHTbl* htbl, <span class="hljs-type">int</span> buckets, <span class="hljs-type">int</span> (*h)(<span class="hljs-type">const</span> <span class="hljs-type">void</span>* key), <span class="hljs-type">int</span> (*match)(<span class="hljs-type">const</span> <span class="hljs-type">void</span>* key1, <span class="hljs-type">const</span> <span class="hljs-type">void</span> *key2), <span class="hljs-type">void</span> (*destory)(<span class="hljs-type">void</span>* data))</span></span>;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">chtbl_destory</span><span class="hljs-params">(CHTbl *htbl)</span></span>;  <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">chtbl_insert</span><span class="hljs-params">(CHTbl *htbl, <span class="hljs-type">const</span> <span class="hljs-type">void</span> *data)</span></span>;<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">chtbl_remove</span><span class="hljs-params">(CHTbl *htbl, <span class="hljs-type">void</span> **data)</span></span>;<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">chtbl_lookup</span><span class="hljs-params">(CHTbl *htbl, <span class="hljs-type">void</span> **data)</span></span>;<span class="hljs-meta">#<span class="hljs-keyword">define</span> chtbl_size(htbl()(chtbl)-&gt;size)</span><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span></code></pre></div><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-comment">/*chtbl.c*/</span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">"list.h"</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">"chtbl.h"</span></span><span class="hljs-comment">/* chtbl_init */</span><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">chtbl_init</span><span class="hljs-params">(CHTbl* htbl, <span class="hljs-type">int</span> buckets, <span class="hljs-type">int</span> (*h)(<span class="hljs-type">const</span> <span class="hljs-type">void</span>* key), <span class="hljs-type">int</span> (*match)(<span class="hljs-type">const</span> <span class="hljs-type">void</span>* key1, <span class="hljs-type">const</span> <span class="hljs-type">void</span> *key2), <span class="hljs-type">void</span> (*destory)(<span class="hljs-type">void</span>* data))</span></span><span class="hljs-function"></span>{    <span class="hljs-type">int</span> i;       <span class="hljs-comment">/* Allocate space for the hash table.*/</span>    <span class="hljs-keyword">if</span> ((htbl-&gt;table = (List *)<span class="hljs-built_in">malloc</span>(buckets * <span class="hljs-built_in">sizeof</span>(List))) == <span class="hljs-literal">NULL</span>)     <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;    <span class="hljs-comment">/* Initialize the buckets. */</span>    htbl-&gt;buckets = buckets;    <span class="hljs-keyword">for</span>(i = <span class="hljs-number">0</span>; i &lt; htbl-&gt;buckets; i++)    <span class="hljs-built_in">list_init</span>(&amp;htbl-&gt;table[i], destroy);        <span class="hljs-comment">/* Encapsulate the functions. */</span>    htbl-&gt;h = h    htbl-&gt;match match;    htbl-&gt;destroy = destroy;        <span class="hljs-comment">/* Initialize the number of elements in the table. */</span>    htbl-&gt;size = o;    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;}<span class="hljs-comment">/* chtbl_destroy */</span><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">chtbl_destory</span><span class="hljs-params">(CHTbl *htbl)</span></span><span class="hljs-function"></span>{       <span class="hljs-comment">/* Destroy each bucket. */</span>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = O; i &lt; htbl-&gt;buckets; i++)    {        <span class="hljs-built_in">list_destroy</span> (&amp;htbl -&gt;tableßl) ;    }        <span class="hljs-comment">/*Free the storage allocated for the hash table. */</span>    <span class="hljs-built_in">free</span>(htbl-&gt;table);        <span class="hljs-comment">/* No operations are allowed now, but clear the structure as a precaution.*/</span>    <span class="hljs-built_in">memset</span>(htbl, <span class="hljs-number">0</span>, <span class="hljs-built_in">sizeof</span>(CHTbl));}<span class="hljs-comment">/* chtbl insert */</span><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">chtbl_insert</span><span class="hljs-params">(CHTbl *htbl, <span class="hljs-type">const</span> <span class="hljs-type">void</span> *data)</span></span><span class="hljs-function"></span>{    <span class="hljs-type">void</span>* temp;    <span class="hljs-type">int</span> bucket,        retval;    <span class="hljs-comment">/* Do nothing if the data is already in the table. */</span>    temp = (<span class="hljs-type">void</span> *)data;    <span class="hljs-keyword">if</span>(<span class="hljs-built_in">chtbl_lookup</span>(htbl, &amp;temp) == <span class="hljs-number">0</span>)        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span> ;        <span class="hljs-comment">/* Hash the key. */</span>    bucket = htbl-&gt;<span class="hljs-built_in">h</span>(data) % htbl-&gt;buckets;    <span class="hljs-comment">/* Insert the data into the bucket. */</span><span class="hljs-keyword">if</span> (<span class="hljs-number">0</span> == (retval = <span class="hljs-built_in">list_ins_next</span>(&amp;htbl-&gt;table[bucket], <span class="hljs-literal">NULL</span>, data)))        htbl-&gt;size++;    <span class="hljs-keyword">return</span> retval; }<span class="hljs-comment">/* chtbl remove */</span><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">chtb1_remove</span><span class="hljs-params">(CHTbl* htbl, <span class="hljs-type">void</span> **data)</span></span><span class="hljs-function"></span>{    ListEImt*element,*prev;    <span class="hljs-type">int</span> bucket;        <span class="hljs-comment">/* Hash the key. */</span>bucket = htbl-&gt;<span class="hljs-built_in">h</span>(*data) % htbl-&gt;buckets;        <span class="hljs-comment">/* Search fcy the data in the bucket. */</span>prev = <span class="hljs-literal">NULL</span>;        <span class="hljs-keyword">for</span> (element = <span class="hljs-built_in">list_head</span>(&amp;htbl-&gt;table[bucket]); element != <span class="hljs-literal">NULL</span>; element = <span class="hljs-built_in">list_next</span>(element))    {<span class="hljs-keyword">if</span> (htbl-&gt;<span class="hljs-built_in">match</span>(*data, <span class="hljs-built_in">list_data</span>(element)))        {        <span class="hljs-comment">/* Remove the data from the bucket. */</span>            <span class="hljs-keyword">if</span>(<span class="hljs-number">0</span> == <span class="hljs-built_in">list_rem_next</span>(&amp;htbl-&gt;table[bucket], prev, data))            {                htbl-&gt;size--;                <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;            }        <span class="hljs-keyword">else</span>                <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;        }        prev = element;    }        <span class="hljs-comment">/* Return that the data was not found. */</span>    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;}<span class="hljs-comment">/* chtbl lookup */</span><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">chtbl_lookup</span><span class="hljs-params">(CHTbl *htbl, <span class="hljs-type">void</span> **data)</span></span><span class="hljs-function"></span>{    ListE1mt *element;    <span class="hljs-type">int</span> bucket;        <span class="hljs-comment">/* Hash the key.*/</span>    bucket = htbl-&gt;<span class="hljs-built_in">h</span>(*data) % htbl-&gt;buckets;    <span class="hljs-comment">/* Search for the data in the bucket.*/</span>    <span class="hljs-keyword">for</span>(element = <span class="hljs-built_in">list_head</span>(&amp;htbl-&gt;table[bucket]); element = <span class="hljs-built_in">list_next</span>(eleemnt))    {        <span class="hljs-keyword">if</span>(htbl-&gt;<span class="hljs-built_in">match</span>(*data, <span class="hljs-built_in">list_data</span>(element)))        {            <span class="hljs-comment">/* Pass back the data from the table. */</span>            *data = <span class="hljs-built_in">list_data</span>(element);            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;        }    }        <span class="hljs-comment">/* Return that the was not found. */</span> <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;}</code></pre></div><h5><span id="kai-di-zhi-ha-xi-biao">开地址哈希表</span><a href="#kai-di-zhi-ha-xi-biao" class="header-anchor">#</a></h5><p>  将数据存储在表本身中,而不是<code>桶</code>中的哈希表。它通过各种探查方法来避免冲突问题。</p><h6><span id="li-zi">例子</span><a href="#li-zi" class="header-anchor">#</a></h6><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-comment">/* ohtbl.h */</span><span class="hljs-meta">#<span class="hljs-keyword">ifndef</span> OHTBL_H</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> OHTBL_H</span><span class="hljs-meta">#incluge<span class="hljs-string">&lt;stdlib.h&gt;</span></span><span class="hljs-comment">/*Define astructure for open-addressed hash tables.*/</span><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">OHTbl_</span>{    <span class="hljs-type">int</span> positions;     <span class="hljs-function"><span class="hljs-type">void</span>* vacateds</span><span class="hljs-function"></span><span class="hljs-function">    <span class="hljs-title">int</span> <span class="hljs-params">(*h1)</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">void</span>*key)</span></span>;    <span class="hljs-built_in">int</span> (*h2)(<span class="hljs-type">const</span> <span class="hljs-type">void</span>*key);    <span class="hljs-built_in">int</span> (*match)(<span class="hljs-type">const</span> <span class="hljs-type">void</span>*key1,<span class="hljs-type">const</span> <span class="hljs-type">void</span>*key2);    <span class="hljs-built_in">int</span> (*destroy)(<span class="hljs-type">void</span>*data);    <span class="hljs-type">int</span> sizes;    <span class="hljs-type">void</span> **table;}OHTbl;<span class="hljs-comment">/*Public Interface*/</span><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">ohtbl_init</span><span class="hljs-params">(oHTbl*htbl,<span class="hljs-type">int</span> positions,<span class="hljs-type">int</span>{*hi)</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">void</span>*key)</span>,<span class="hljs-title">int</span> <span class="hljs-params">(*h2)</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">void</span>*key)</span>,<span class="hljs-title">int</span> <span class="hljs-params">(*match)</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">void</span>*key1, <span class="hljs-type">const</span> <span class="hljs-type">void</span>*key2)</span></span>;<span class="hljs-built_in">void</span> (*destroy)(<span class="hljs-type">void</span>*data));<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">ohtbl_destroy</span><span class="hljs-params">(OHTbl*htbl)</span></span>; <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">ohtbl_insert</span><span class="hljs-params">(OHTbl*htbl,<span class="hljs-type">const</span> <span class="hljs-type">void</span>*data)</span></span>;<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">ohtbl_remove</span><span class="hljs-params">(OHTbl*htbl,<span class="hljs-type">void</span>**data)</span></span>; <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">ohtbl_lookup</span><span class="hljs-params">(<span class="hljs-type">const</span> OHTbl *htbl,<span class="hljs-type">void</span> **data)</span></span>; <span class="hljs-meta">#<span class="hljs-keyword">define</span> ohtbl_size(htbl()(htbl)-&gt;size)</span><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span></code></pre></div><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-comment">/* ohtbl.c */</span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">"ohtbl.h"</span></span><span class="hljs-comment">/*Reserveasentinelmemoxy address for vacated elements.*/</span><span class="hljs-type">static</span> <span class="hljs-type">char</span> vacated;<span class="hljs-comment">/*ohtb_linit*/</span><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">ohtb_linit</span><span class="hljs-params">(oHTbl*htbl,<span class="hljs-type">int</span> positions,<span class="hljs-type">int</span> (*h1)(<span class="hljs-type">const</span> <span class="hljs-type">void</span>*key),<span class="hljs-type">int</span> (*h2)(<span class="hljs-type">const</span> <span class="hljs-type">void</span>*key),<span class="hljs-type">int</span> (*match)(<span class="hljs-type">const</span> <span class="hljs-type">void</span>*key1,<span class="hljs-type">const</span> <span class="hljs-type">void</span>*key2),<span class="hljs-type">void</span> (*destroy)(voi*data))</span></span><span class="hljs-function"></span>{    <span class="hljs-type">int</span> i;        <span class="hljs-comment">/*Allocate space for the hash table.*/</span>    <span class="hljs-keyword">if</span> ((htbl-&gt;table= (<span class="hljs-type">void</span>**)<span class="hljs-built_in">malloc</span>(positions*<span class="hljs-built_in">sizeof</span>(<span class="hljs-type">void</span>*)))==<span class="hljs-literal">NULL</span>)<span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;        <span class="hljs-comment">/*Initializeeachposition、*/</span>    htbl-&gt;positicns = pasitions;    <span class="hljs-keyword">for</span> (i=<span class="hljs-number">0</span>; i&lt; htbl-&gt;positions；i++)        htbl-&gt;table[i] = <span class="hljs-literal">NULL</span>;        <span class="hljs-comment">/*Set the vacated member tothe sentinel memory address reserved for this,*/</span>    htbl-&gt;vacated= &amp;vacated;        <span class="hljs-comment">/*Encapsulate the functions.*/</span>    htbl-&gt;h1 = h1;    htbl-&gt;h2 = h2;    htbl-match = match;    htbl-&gt;destroy = destroy;        <span class="hljs-comment">/*Initialize the number of elements in the table.*/</span>    htbl-&gt;size = <span class="hljs-number">0</span>;    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;}<span class="hljs-comment">/*ohtbl_destroy*/</span><span class="hljs-function">vold <span class="hljs-title">ohtbl_destroy</span><span class="hljs-params">(OHTbl*htbl)</span></span><span class="hljs-function"></span>{    <span class="hljs-type">int</span> i;    <span class="hljs-keyword">if</span>(htbl-&gt;destroy != <span class="hljs-literal">NULL</span>)    {<span class="hljs-comment">/*Calla user-defined function to free dynamically allocated data.*/</span>        <span class="hljs-keyword">for</span>(i = <span class="hljs-number">0</span>; i &lt; htbl-&gt;positions; i++)        {            <span class="hljs-keyword">if</span>(htbl-&gt;table[i] != <span class="hljs-literal">NULL</span> &amp;&amp; htbl-&gt;table[i] != htbl-&gt;vacated)            htbl-&gt;<span class="hljs-built_in">destroy</span>(htbl-&gt;table[i]);         }    }        <span class="hljs-comment">/*Free the storage allocated for the hash table，*/</span>    <span class="hljs-built_in">free</span>(htbl-&gt;table);        <span class="hljs-comment">/*No operations are allowed nowybut clear the structure asaprecautlon.*/</span><span class="hljs-built_in">memset</span>(htbl, <span class="hljs-number">0</span>, <span class="hljs-built_in">sizeof</span>(OHTbl));}               <span class="hljs-comment">/*ohtblinsert*/</span><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">ohtb_linsert</span><span class="hljs-params">(OHTbl*htbl，constvoid *data)</span></span><span class="hljs-function"></span>{    <span class="hljs-type">void</span>* temp;<span class="hljs-type">int</span> position, i;             <span class="hljs-comment">/*Do not exceed the number of positions in the table.*/</span>    <span class="hljs-keyword">if</span> (htbl-&gt;size == htbl-&gt;positions)        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;    <span class="hljs-comment">/*Do nothing ifthe data is already in the table.*/</span>    temp= (<span class="hljs-type">void</span>*)data;    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">ohtbl_fookup</span>(htbl, &amp;temp) == <span class="hljs-number">0</span>)        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;        <span class="hljs-comment">/*Use double hashing to hash the key.*/</span>    <span class="hljs-keyword">for</span> (i=<span class="hljs-number">0</span>; i &lt; htbl-&gt;positions; i++)    {        position = (htbl-&gt;<span class="hljs-built_in">h1</span>(data) + (i * htbl-&gt;<span class="hljs-built_in">h2</span>(data))) % htbl-&gt;positions;        <span class="hljs-keyword">if</span> (htbl-&gt;table[position] == <span class="hljs-literal">NULL</span> || htbl-&gt;table[position] == htbl-&gt;vacated)        {            <span class="hljs-comment">/* Insert the data into the table.*/</span>            htbl-&gt;table[position] = (<span class="hljs-type">void</span>*)data;            htbl-&gt;size++;            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>        }    }        <span class="hljs-comment">/* Return that the hash funtions were selected incorrectly. */</span><span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;}<span class="hljs-comment">/*ohtbl_remove */</span><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">ohtbl_remove</span><span class="hljs-params">(OHTbl *htbl，<span class="hljs-type">void</span>**data)</span></span><span class="hljs-function"></span>{    <span class="hljs-type">int</span> position, i;        <span class="hljs-comment">/*Use touble hashingtohashthekey.*/</span>    <span class="hljs-keyword">for</span> (i=<span class="hljs-number">0</span>; i &lt; htbl-&gt;positions; i++)     {        position = (htbl-&gt;<span class="hljs-built_in">h1</span>(*data) + (i * htbl-&gt;<span class="hljs-built_in">h2</span>(*data))) % htbl-&gt;positions;    }    <span class="hljs-keyword">if</span> (htbl-&gt;table[position] == <span class="hljs-literal">NULL</span>)     {        <span class="hljs-comment">/* Returnthat the data was not found，*/</span>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>；    }    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (htbl-&gt;table[position]==htbl-&gt;vacated)     {        <span class="hljs-comment">/*Seaxch beyond vacated pasitions.*/</span>        <span class="hljs-keyword">continue</span>;    }    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (htbl-&gt;<span class="hljs-built_in">match</span>(htbl-&gt;table[position],*data))    {        <span class="hljs-comment">/* Pass back the data from the table，*/</span>        *data = htbl-&gt;table[position];        htbl-&gt;table[positian] = htbl-&gt;vacated;        htbl-&gt;size--;        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;     }        <span class="hljs-comment">/*Return that the data wasnot found，*/</span>    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;}<span class="hljs-comment">/* ohtbI_lookup */</span><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">ohtbl_lcokup</span><span class="hljs-params">(<span class="hljs-type">const</span> OHTbl *htbl, <span class="hljs-type">void</span> **data)</span></span><span class="hljs-function"></span>{    <span class="hljs-type">int</span> positiong, i;    <span class="hljs-comment">/* Use double hashing to hash the key.*/</span>    <span class="hljs-keyword">for</span> (i = O; i &lt; htbl-&gt;positions; i++)    {        positicn = (htb1-&gt;<span class="hljs-built_in">hz</span>(*data) + (i * htb1-&gt;<span class="hljs-built_in">h2</span>(*data))) % htb1-&gt;positions;        <span class="hljs-keyword">if</span> (htbl-&gt;table[position] == <span class="hljs-literal">NULL</span>)        {            <span class="hljs-comment">/* Return that the data was not found.*/</span>            <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;        }        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(htbl-&gt;<span class="hljs-built_in">match</span>(htbl-&gt;table[position], *data))        {            <span class="hljs-comment">/* Pass back the data from the table. */</span>            *data = htbl-&gt;table[positipon];            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;        }    }        <span class="hljs-comment">/* Return that the data was not found. */</span>    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;}</code></pre></div><h4><span id="5-shu">5.树</span><a href="#5-shu" class="header-anchor">#</a></h4><h5><span id="shu-de-ding-yi">树的定义：</span><a href="#shu-de-ding-yi" class="header-anchor">#</a></h5><blockquote><p>在计算机科学中，树由称之为节点的元素按照层次结构方式组织而成。层次最顶端为根(root)。与根相连的为子节点，通常子节点也有自己的子节点。二叉树是分支因子为2的树。二叉搜索树是专门用于查找的树。</p></blockquote><h5><span id="er-cha-shu">二叉树</span><a href="#er-cha-shu" class="header-anchor">#</a></h5><p><img src="https://gitee.com/txt1994/images/raw/master/img/Algorithmic_refinement/%E4%BA%8C%E5%8F%89%E6%A0%91.png"></p><p>二叉树的一个节点包含三部分：一个<code>数据部</code>和两个左右<code>指针部</code></p><p><img src="https://gitee.com/txt1994/images/raw/master/img/Algorithmic_refinement/%E8%8A%82%E7%82%B9%E4%BA%8C%E5%8F%89%E6%A0%91.png"></p><h6><span id="shu-de-bian-li-suan-fa">树的遍历算法</span><a href="#shu-de-bian-li-suan-fa" class="header-anchor">#</a></h6><p>先序遍历：根(root)，左，右</p><p>中层遍历：左，根(root)，右</p><p>后序遍历：左，右，根(root)</p><p>层序遍历：根(root), 一层一层遍历到叶子</p><h5><span id="shu-de-ping-heng">树的平衡</span><a href="#shu-de-ping-heng" class="header-anchor">#</a></h5><p>树的平衡是指对于给定数量的节点，保证树的高度尽可能短的过程。这意味着在结点加入下一层之前必须保证本层结点满额。也就是说树的叶子都在倒数两层，且倒数第二层叶子是满的，则称这棵树是平衡的。最后一层叶子结点靠左，则称这棵树是左平衡的。</p><p><img src="https://gitee.com/txt1994/images/raw/master/img/Algorithmic_refinement/%E5%B7%A6%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91.png"></p><h5><span id="er-cha-shu-de-jie-kou-ding-yi">二叉树的接口定义：</span><a href="#er-cha-shu-de-jie-kou-ding-yi" class="header-anchor">#</a></h5><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-comment">/* bitree.h */</span><span class="hljs-meta">#<span class="hljs-keyword">ifndef</span> BITREE_H</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> BITREE_H</span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><span class="hljs-comment">/* Define a structure for binary tree nodes.*/</span><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">BiTreeNode_</span>{    <span class="hljs-type">void</span> *data;    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">BiTreeNode</span> *left;    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">BiTreeNode_</span>*right;}BiTreeNode;<span class="hljs-comment">/* Defmne a structure for binary trees.*/</span><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">BiTree_</span>{    <span class="hljs-type">int</span> size;    <span class="hljs-built_in">int</span> (*compare)(<span class="hljs-type">const</span> <span class="hljs-type">void</span> *key1, <span class="hljs-type">const</span> <span class="hljs-type">void</span> *key2);    <span class="hljs-built_in">void</span> (*destroy)(<span class="hljs-type">void</span> *data);    BiTreeNode *root;}BiTree;<span class="hljs-comment">/* Public Interface */</span><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">bitree_init</span><span class="hljs-params">(BiTree *tree, <span class="hljs-type">void</span> (*destroy)(<span class="hljs-type">void</span> *data))</span></span>;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">bitree_destroy</span><span class="hljs-params">(BiTree *tree)</span></span>;<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">bitree_ins_left</span><span class="hljs-params">(BiTree *tree, BiTreeNode *node, <span class="hljs-type">const</span> <span class="hljs-type">void</span> *data)</span></span>;<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">bitree_ins_right</span><span class="hljs-params">(BiTree *tree, BiTreeNode *node, <span class="hljs-type">const</span> <span class="hljs-type">void</span> *data)</span></span>;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">bitree_rem_left</span><span class="hljs-params">(BiTree *tree, BiTreeNode *node)</span></span>;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">bitree_rem_right</span><span class="hljs-params">(BiTree *tree,BiTreeNode *node)</span></span>;<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">bitree_merge</span><span class="hljs-params">(BiTree *merge, BiTree *left,BiTree *right,<span class="hljs-type">const</span> <span class="hljs-type">void</span> *data)</span></span>;<span class="hljs-meta">#<span class="hljs-keyword">define</span> bitree_size(tree) ((tree)-&gt;size)</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> bitree root(tree) ((tree)-&gt;root))</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> bitxee_is_eob(node) ((node) == NULL)</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> bitree_is_leaf(node) ((node)-&gt;left == NULL &amp;&amp; (node)-&gt;right == NULL)</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> bitree_data(node) ((node)-&gt;data)</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> bitree left(node) ((node)-&gt;left)</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> bitree_right(node) ((node)-&gt;right)</span><span class="hljs-meta">#edif</span></code></pre></div><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-comment">/* bitree.c */</span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">"bitree.h"</span></span><span class="hljs-comment">/*bitree init*/</span><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">bitree_init</span><span class="hljs-params">(BiTree *tree, <span class="hljs-type">void</span> (*destroy)(<span class="hljs-type">void</span> *data))</span></span><span class="hljs-function"></span>{    <span class="hljs-comment">/* Initialize the binary tree.*/</span>    tree-&gt;size = <span class="hljs-number">0</span>;    tree-&gt;destroy = destroy;    tree-&gt;root = <span class="hljs-literal">NULL</span>;}<span class="hljs-comment">/* bitree_destroy*/</span><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">bitree_destroy</span><span class="hljs-params">(BiTree *tree)</span></span><span class="hljs-function"></span>{    <span class="hljs-comment">/* Remove all the nodes from the tree.*/</span>    <span class="hljs-built_in">bitree_rem_left</span>(tree, <span class="hljs-literal">NULL</span>);    <span class="hljs-comment">/* No operations are aIlowed now, but clear the structure as a precaution. */</span>    <span class="hljs-built_in">memset</span>(tree, <span class="hljs-number">0</span>, <span class="hljs-built_in">sizeof</span>(BiTree);}<span class="hljs-comment">/* bitree ins left */</span><span class="hljs-type">int</span> <span class="hljs-built_in">bitree_ins_left</span>(BiTree *tree, BiTreeNode *node, <span class="hljs-type">const</span> <span class="hljs-type">void</span> *data){    BiTreeNode new_node, **position;    <span class="hljs-comment">/* Determine where to insert the node.*/</span>    <span class="hljs-keyword">if</span> (node == <span class="hljs-literal">NULL</span>)    {        <span class="hljs-comment">/* Allow insertion at the root only in an empty tree.*/</span>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">bitree_size</span>(tree) &gt; <span class="hljs-number">0</span>)            <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;        position = &amp;tree-&gt;root;    }    <span class="hljs-keyword">else</span>    {        <span class="hljs-comment">/* Normally allow insertion only at the end of a branch.*/</span>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">bitree_left</span>(node) != <span class="hljs-literal">NULL</span>)            <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;        position = &amp;node-&gt;left;    }    <span class="hljs-comment">/* Allocate storage for the node.*/</span>    <span class="hljs-keyword">if</span> ((new_node = (BiTreeNode *)<span class="hljs-built_in">malloc</span>(<span class="hljs-built_in">sizeof</span>(BiTreeNcde))) == <span class="hljs-literal">NULL</span>)        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;    <span class="hljs-comment">/* Insert the node into the tree.*/</span>    new_node-&gt;data = (<span class="hljs-type">void</span> *)data;    new_node-&gt;ieft = <span class="hljs-literal">NULL</span>;    new_node-&gt;right = <span class="hljs-literal">NULL</span>;    *position = new_node;    <span class="hljs-comment">/* Adjust the size of the tree to account for the inserted node.*/</span>    tree-&gt;size++;    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;}<span class="hljs-comment">/* bitree_ins_right */</span><span class="hljs-type">int</span> <span class="hljs-built_in">bitree_ins_right</span>(BiTree *tree, BiTreeNode *node, <span class="hljs-type">const</span> <span class="hljs-type">void</span> *data){    BiTreeNode *new_node, **position;    <span class="hljs-comment">/* Determine where to insert the node.*/</span>    <span class="hljs-keyword">if</span> (node == <span class="hljs-literal">NULL</span>)    {        <span class="hljs-comment">/* Allow insertion at the root only in an empty tree.*/</span>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">bitree_size</span>(tree) &gt; <span class="hljs-number">0</span>)            <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;        position = &amp;tree-&gt;root;    }    <span class="hljs-keyword">else</span>    {        <span class="hljs-comment">/* Normally allow insertion only at the end of a branch. */</span>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">bitree_right</span>(node) != <span class="hljs-literal">NULL</span>)            <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;        position = &amp;node-&gt;right;    }    <span class="hljs-comment">/* Allocate storage for the node.*/</span>    <span class="hljs-keyword">if</span> ((new_node = (BiTreeNode *)<span class="hljs-built_in">malloc</span>(<span class="hljs-built_in">sizeof</span>(BiTreeNode))) == <span class="hljs-literal">NULL</span>)        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;    <span class="hljs-comment">/* Insert the node into the tree.*/</span>    new_node-&gt;data = (<span class="hljs-type">void</span> *)data;    new_node-&gt;left = <span class="hljs-literal">NULL</span>;    new_node-&gt;right = <span class="hljs-literal">NULL</span>;    *position = new_node;    <span class="hljs-comment">/* Adjust the size of the tree to account for the inserted node.*/</span>    tree-&gt;size++;    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;}<span class="hljs-comment">/* bitree_rem_left */</span><span class="hljs-type">void</span> <span class="hljs-built_in">bitree_rem_left</span>(BiTree *tree, BiTreeNode *node){    BiTreeNode **position;    <span class="hljs-comment">/* Do not allow removal from an empty tree.*/</span>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">bitree_size</span>(tree) == <span class="hljs-number">0</span>)    <span class="hljs-keyword">return</span>;    <span class="hljs-comment">/*Determine where to remove nodes.*/</span>    <span class="hljs-keyword">if</span> (node == <span class="hljs-literal">NULL</span>)        position = &amp;tree-&gt;root;    <span class="hljs-keyword">else</span>        position = &amp;node-&gt;left;    <span class="hljs-comment">/*Remove the nodes.*/</span>    <span class="hljs-keyword">if</span> (*position != <span class="hljs-literal">NULL</span>)    {        <span class="hljs-built_in">bitree_rem_left</span>(tree, *position);        <span class="hljs-built_in">bitree_rem_right</span>(tree, *position);        <span class="hljs-keyword">if</span> (tree-&gt;destroy != <span class="hljs-literal">NULL</span>)        {            <span class="hljs-comment">/* Call a user-defined function to free dynamically allocated data.*/</span>            tree-&gt;<span class="hljs-built_in">destroy</span>((*position-&gt;data);           }        <span class="hljs-built_in">free</span>(*position);        *position = <span class="hljs-literal">NULL</span>;        <span class="hljs-comment">/* Adjust the size of the tree to account for the removed node.*/</span>        tree-&gt;size--;    }    <span class="hljs-keyword">return</span>;}<span class="hljs-comment">/* bitree_rem_right */</span><span class="hljs-type">void</span> <span class="hljs-built_in">bitree_rem_right</span>(BiTzee *tree, BiTreeNode *node){    BiTreeNode **position;        <span class="hljs-comment">/* Do not allow removal from an empty tree. */</span>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">bitree_size</span>(tree) == <span class="hljs-number">0</span>)        <span class="hljs-keyword">return</span>;    <span class="hljs-comment">/* Determine where to remove nodes.*/</span>    <span class="hljs-keyword">if</span> (node == <span class="hljs-literal">NULL</span>)        position = &amp;tree-&gt;root;    <span class="hljs-keyword">else</span>        position = &amp;node-&gt;right;    <span class="hljs-comment">/* Remove the nodes.*/</span>    <span class="hljs-keyword">if</span> (*position != <span class="hljs-literal">NULL</span>)    {        <span class="hljs-built_in">bitree_rem_left</span>(txee,*position);        <span class="hljs-built_in">bitree_rem_right</span>(tree,*position);        <span class="hljs-keyword">if</span> (tree-&gt;destroy != <span class="hljs-literal">NULL</span>)        {            <span class="hljs-comment">/* CalI a user-defined function to free dynamically allocated data.*/</span>            tree-&gt;<span class="hljs-built_in">destroy</span>((*position)-&gt;data);        }        <span class="hljs-built_in">free</span>(*position);        *position = <span class="hljs-literal">NULL</span>;        <span class="hljs-comment">/* Adjust the size of the tree to account for the removed node.*/</span>        tree-&gt;size--;    }    <span class="hljs-keyword">return</span>;}<span class="hljs-comment">/* bitree_merge*/</span><span class="hljs-type">int</span> <span class="hljs-built_in">bitree_merge</span>(BiTree *merge, BiTree *left, BiTree *right, <span class="hljs-type">const</span> <span class="hljs-type">void</span> *data){    <span class="hljs-comment">/* Initialize the merged tree.*/</span>    <span class="hljs-built_in">bitree_init</span>(merge, left-&gt;destroy);    <span class="hljs-comment">/* Insert the data for the root node of the merged tree.*/</span>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">bitree_ins_left</span>(merge, <span class="hljs-literal">NULL</span>, data) != <span class="hljs-number">0</span>)    {        <span class="hljs-built_in">bitree_destroy</span>(merge);        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;    }    <span class="hljs-comment">/* Merge the two binary trees into a single binary tree.*/</span>    <span class="hljs-built_in">bitree_root</span>(merge)-&gt;left = <span class="hljs-built_in">bitree_root</span>(left);    <span class="hljs-built_in">bitree_root</span>(merge)-&gt;right = <span class="hljs-built_in">bitree_root</span>(right);    <span class="hljs-comment">/* Adjust the size of the new binary tree.*/</span>    merge-&gt;size = merge-&gt;size + <span class="hljs-built_in">bitree_size</span>(left) + <span class="hljs-built_in">bitree_size</span>(right);    <span class="hljs-comment">/* Do not let the original trees access the merged nodes.*/</span>    left-&gt;root = <span class="hljs-literal">NULL</span>;    left-&gt;size = <span class="hljs-number">0</span>;    right-&gt;root = <span class="hljs-literal">NULL</span>;    right-&gt;size = <span class="hljs-number">0</span>;    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;}</code></pre></div><h5><span id="er-cha-sou-suo-shu">二叉搜索树</span><a href="#er-cha-sou-suo-shu" class="header-anchor">#</a></h5><h6><span id="ding-yi">定义：</span><a href="#ding-yi" class="header-anchor">#</a></h6><blockquote><p>二叉搜索树是有二叉树组成的专用于查找和搜索目的的一种数据结构。</p><p>数据插入遵循：比根节点(root)大的数插入根右边，比根节点小的数插入左边。</p><p>数据搜索遵循：要查询的值比根(root)大的数向右子节点查，比根节点小向左节点查。</p><p>不允许有重复值出现</p><p>二叉搜素树应尽量保持平衡，但比较困难。非平衡树会造成搜索的节点数量过多，最多O(n)</p></blockquote><p>二叉搜索树要保持平衡最好的方法是</p><h5><span id="avl-shu"><strong>AVL</strong>树</span><a href="#avl-shu" class="header-anchor">#</a></h5><p>其定义为：</p><blockquote><p>AVL树每个节点都保持了一个平衡因子。</p><p>插入结点时AVL树需要自我调整。</p><p>平衡因子：结点的右子树高度-左子树高度，其值为+1, 0，-1。</p><p>+1：代表树是左倾斜的</p><p>-1：代表树是右倾斜的</p></blockquote><p><img src="https://gitee.com/txt1994/images/raw/master/img/Algorithmic_refinement/%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91.png"></p><p>平衡因子改变：</p><blockquote><p>插入新的结点会造成平衡因子改变，因此这棵树需要重新平衡，我们称这种平衡为<code>AVL树的旋转</code></p></blockquote><p><code>AVL树</code>旋转方法：</p><blockquote><p>LL(left-left)，LR(left-right)，RR(right-right)，RL(right-left)</p></blockquote><blockquote><p>avl树旋转有一个更简单的方法:</p><blockquote><ol><li><p>把这颗树抽象成一棵自然界的树，节点的平衡因子不是-1，0，+1时，RR和LL的节点小于-1或大于+1时树的树梢向下落一层；</p></li><li><p>RL和LR的节点小于-1或大于+1时是因为不平衡的子节点引起的，找到不平衡的子节点重复LL或RR的过程，不平衡子节点旋转之后父节点重复LL或RR.</p></li></ol></blockquote></blockquote><h6><span id="jie-kou-ding-yi">接口定义：</span><a href="#jie-kou-ding-yi" class="header-anchor">#</a></h6><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-comment">/* bistree.h */</span><span class="hljs-meta">#<span class="hljs-keyword">ifndef</span> BISTREE_H</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> BISTREE_R</span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">"bitree.h"</span></span><span class="hljs-comment">/* Define balance factors for AVL trees. */</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> AVL_LFT_HEAVY   1</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> AVL_BALANCED    0</span><span class="hljs-meta">#deftne AVERGT_HEAVY    -1</span><span class="hljs-comment">/* Define a structure for nodes in AVL trees. */</span><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">AvlNode_</span>{    <span class="hljs-type">void</span> *data;    <span class="hljs-type">int</span> hidden;    <span class="hljs-type">int</span> factor;}Av1Node;<span class="hljs-comment">/* Implement binary search trees as binary trees. */</span><span class="hljs-keyword">typedef</span> BiTree BisTree;<span class="hljs-comment">/* Public Interface */</span><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">bistree_init</span><span class="hljs-params">(Bistree *tree, <span class="hljs-type">int</span> (*compare)(<span class="hljs-type">const</span> <span class="hljs-type">void</span> *key1, <span class="hljs-type">const</span> <span class="hljs-type">void</span> *key2), <span class="hljs-type">void</span> (*destroy)(<span class="hljs-type">void</span> *data))</span></span>;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">bistree_destroy</span><span class="hljs-params">(BisTree *tree)</span></span>;<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">bistree_insert</span><span class="hljs-params">(BisTree *tree, <span class="hljs-type">const</span> <span class="hljs-type">void</span> *data)</span></span>;<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">bistree_remove</span><span class="hljs-params">(BisTree *tree, <span class="hljs-type">const</span> <span class="hljs-type">void</span> *data)</span></span>;<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">bistree_lookup</span><span class="hljs-params">(BisTree *tree, <span class="hljs-type">void</span> **data)</span></span>;<span class="hljs-meta">#<span class="hljs-keyword">define</span> bistree_size(tree) ((txee) -&gt;size)</span><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span></code></pre></div><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-comment">/* bistree.c */</span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">"bistree.h"</span></span><span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title">destroy_right</span><span class="hljs-params">(BisTree *tree, BiTreeNode *node)</span></span>;/ * rotate_left */<span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title">rotate_left</span><span class="hljs-params">(BiTreeNode **node)</span></span><span class="hljs-function"></span>{    BiTreeNode *left, *grandchild;    left = <span class="hljs-built_in">bitree_left</span>(*node);    <span class="hljs-keyword">if</span> (((AvlNode *)<span class="hljs-built_in">bitree_data</span>(left))-&gt;factor == AVL_LFT_HEAVY)    {        <span class="hljs-comment">/* Perform an LL rotation. */</span>        <span class="hljs-built_in">bitree_left</span>(*node) = <span class="hljs-built_in">bitree_right</span>(left);        <span class="hljs-built_in">bitree_right</span>(left) = *node;        ((AvlNode *)<span class="hljs-built_in">bitree_data</span>(*node))-&gt;factor = AVL_BALANCED;        ((AvlNode *)<span class="hljs-built_in">bitree_data</span>(left))-&gt;factor = AVL_BALANCED;        *node = left;    }    <span class="hljs-keyword">else</span>    {        <span class="hljs-comment">/* Perform an LR rotation. */</span>        grandchild = <span class="hljs-built_in">bitree_right</span>(left);        <span class="hljs-built_in">bitree_right</span>(left) = <span class="hljs-built_in">bitree_left</span>(grandchild);        <span class="hljs-built_in">bitree_left</span>(grandchild) = left;        <span class="hljs-built_in">bitree_left</span>(*node) = <span class="hljs-built_in">bitree_right</span>(grandchild);        <span class="hljs-built_in">bitree_right</span>(grandchild) = *node;        <span class="hljs-keyword">switch</span> (((AvlNode *)<span class="hljs-built_in">bitree_data</span>(left))-&gt;factor)        {            <span class="hljs-keyword">case</span> AVL_LFT_HEAVY:                ((AvlNode *)<span class="hljs-built_in">bitree_data</span>(*node))-&gt;factor = AVL_RGT_HEAVY;                ((AvlNode *)<span class="hljs-built_in">bitree_data</span>(left))-&gt;factor = AVL_BALANCED;                <span class="hljs-keyword">break</span>;                        <span class="hljs-keyword">case</span> AVL_BALANCED:                ((AvlNode *)<span class="hljs-built_in">bitree_data</span>(*node))-&gt;factor = AVL_BALANCED;                ((AvlNode *)<span class="hljs-built_in">bitree_data</span>(left))-&gt;factor = AVL_BALANCED;                <span class="hljs-keyword">break</span>;                        <span class="hljs-keyword">case</span> AVL_RGT_HEAVY:                ((AvlNode *)<span class="hljs-built_in">bitree_data</span>(*node))-&gt;factor = AVL_BALANCED;                ((AvlNode *)<span class="hljs-built_in">bitree_data</span>(left))-&gt;factor = AVL_LFT_HEAVY;                <span class="hljs-keyword">break</span>;        }        ((AvlNode *)<span class="hljs-built_in">bitree_data</span>(grandchild))-&gt;factor = AVL_BALANCED;        *node = grandchild;    }}/ * rotate_right */<span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title">rotate_right</span><span class="hljs-params">(BiTreeNode **node)</span></span><span class="hljs-function"></span>{    BiTreeNode *right, *grandchild;    right = <span class="hljs-built_in">bitree_right</span>(*node);    <span class="hljs-keyword">if</span> (((AvlNode *)<span class="hljs-built_in">bitree_data</span>(right))-&gt;factor == AVL_RGT_HEAVY)    {        <span class="hljs-comment">/* Perform an RR rotation. */</span>        <span class="hljs-built_in">bitree_right</span>(*node) = <span class="hljs-built_in">bitree_right</span>(right);        <span class="hljs-built_in">bitree_left</span>(right) = *node;        ((AvlNode *)<span class="hljs-built_in">bitree_data</span>(*node))-&gt;factor = AVL_BALANCED;        ((AvlNode *)<span class="hljs-built_in">bitree_data</span>(right))-&gt;factor = AVL_BALANCED;        *node = right;    }    <span class="hljs-keyword">else</span>    {        <span class="hljs-comment">/* Perform an RL rotation. */</span>        grandchild = <span class="hljs-built_in">bitree_left</span>(right);        <span class="hljs-built_in">bitree_right</span>(right) = <span class="hljs-built_in">bitree_right</span>(grandchild);        <span class="hljs-built_in">bitree_right</span>(grandchild) = right;        <span class="hljs-built_in">bitree_right</span>(*node) = <span class="hljs-built_in">bitree_left</span>(grandchild);        <span class="hljs-built_in">bitree_left</span>(grandchild) = *node;        <span class="hljs-keyword">switch</span> (((AvlNode *)<span class="hljs-built_in">bitree_data</span>(grandchild))-&gt;factor)        {            <span class="hljs-keyword">case</span> AVL_LFT_HEAVY:                ((AvlNode *)<span class="hljs-built_in">bitree_data</span>(*node))-&gt;factor = AVL_BALANCED;                ((AvlNode *)<span class="hljs-built_in">bitree_data</span>(right))-&gt;factor = AVL_RGT_HEAVY;                <span class="hljs-keyword">break</span>;                        <span class="hljs-keyword">case</span> AVL_BALANCED:                ((AvlNode *)<span class="hljs-built_in">bitree_data</span>(*node))-&gt;factor = AVL_BALANCED;                ((AvlNode *)<span class="hljs-built_in">bitree_data</span>(right))-&gt;factor = AVL_BALANCED;                <span class="hljs-keyword">break</span>;                        <span class="hljs-keyword">case</span> AVL_RGT_HEAVY:                ((AvlNode *)<span class="hljs-built_in">bitree_data</span>(*node))-&gt;factor = AVL_LFT_HEAVY;                ((AvlNode *)<span class="hljs-built_in">bitree_data</span>(right))-&gt;factor = AVL_BALANCED ;                <span class="hljs-keyword">break</span>;        }        ((AvlNode *)<span class="hljs-built_in">bitree_data</span>(grandchild))-&gt;factor = AVL_BALANCED;        *node = grandchild;    }}<span class="hljs-comment">/* destroy_left */</span><span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title">destroy_left</span><span class="hljs-params">(BisTree *tree, BiTreeNode *node)</span></span><span class="hljs-function"></span>{    BiTreeNode **position;    <span class="hljs-comment">/* Do not allow destruction of an empty tree. */</span>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">bitree_size</span>(tree) == <span class="hljs-number">0</span>)        <span class="hljs-keyword">return</span>;    <span class="hljs-comment">/* Determine where to destroy nodes.*/</span>    <span class="hljs-keyword">if</span> (node == <span class="hljs-literal">NULL</span>)        position = &amp;tree-&gt;root;    <span class="hljs-keyword">else</span>        position = &amp;tree-&gt;left;    <span class="hljs-comment">/* Destroy the nodes. */</span>    <span class="hljs-keyword">if</span> (*position != <span class="hljs-literal">NULL</span>)    {        <span class="hljs-built_in">destroy_left</span>(tree, *position);        <span class="hljs-built_in">destroy_right</span>(tree, *position);        <span class="hljs-keyword">if</span> (tree-&gt;destroy != <span class="hljs-literal">NULL</span>)        {            <span class="hljs-comment">/* Call a user-defined function to free dynamically allocated data. */</span>            tree-&gt;<span class="hljs-built_in">destory</span>(((AvlNode *)(*position)-&gt;data)-&gt;data);        }                <span class="hljs-comment">/* Free the AVL data in the node, then free the node itself. */</span>        <span class="hljs-built_in">free</span>((*position)-&gt;data);        <span class="hljs-built_in">free</span>(*position);        *position = <span class="hljs-literal">NULL</span>;        <span class="hljs-comment">/* Adjust the size of the tree to account for the destroyed node. */</span>        tree-&gt;size--;    }}/ * destroy_right */<span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title">destroy_right</span><span class="hljs-params">(BisTree *tree, BiTreeNode *node)</span></span><span class="hljs-function"></span>{     BiTreeNode **position;    <span class="hljs-comment">/* Do not allow destruction of an empty tree. */</span>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">bitree_size</span>(tree) == <span class="hljs-number">0</span>)        <span class="hljs-keyword">return</span>;    <span class="hljs-comment">/* Determine where to destroy nodes.*/</span>    <span class="hljs-keyword">if</span> (node == <span class="hljs-literal">NULL</span>)        position = &amp;tree-&gt;root;    <span class="hljs-keyword">else</span>        position = &amp;tree-&gt;right;    <span class="hljs-comment">/* Destroy the nodes. */</span>    <span class="hljs-keyword">if</span> (*position != <span class="hljs-literal">NULL</span>)    {        <span class="hljs-built_in">destroy_left</span>(tree, *position);        <span class="hljs-built_in">destroy_right</span>(tree, *position);        <span class="hljs-keyword">if</span> (tree-&gt;destroy != <span class="hljs-literal">NULL</span>)        {            <span class="hljs-comment">/* Call a user-defined function to free dynamically allocated data. */</span>            tree-&gt;<span class="hljs-built_in">destory</span>(((AvlNode *)(*position)-&gt;data)-&gt;data);        }                <span class="hljs-comment">/* Free the AVL data in the node, then free the node itself. */</span>        <span class="hljs-built_in">free</span>((*position)-&gt;data);        <span class="hljs-built_in">free</span>(*position);        *position = <span class="hljs-literal">NULL</span>;        <span class="hljs-comment">/* Adjust the size of the tree to account for the destroyed node. */</span>        tree-&gt;size--;    }}<span class="hljs-comment">/* insert */</span><span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">int</span> <span class="hljs-title">insert</span><span class="hljs-params">(BisTree *tree, BiTreeNode **node, <span class="hljs-type">const</span> <span class="hljs-type">void</span> *data, <span class="hljs-type">int</span> *balanced)</span></span><span class="hljs-function"></span>{    AvlNode *avl_data;    <span class="hljs-type">int</span> cmpval, retval;    <span class="hljs-comment">/* Insert the data into the tree. */</span>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">bitree_is_eob</span>(*node))    {        <span class="hljs-comment">/* Handle insertion into an empty tree.*/</span>        <span class="hljs-keyword">if</span> ((avl_data = (AvlNode *)<span class="hljs-built_in">malloc</span>(<span class="hljs-built_in">sizeof</span>(AvlNode))) == <span class="hljs-literal">NULL</span>)            <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;        avl data-&gt;factor = AVL_BALANCED;        avi data-&gt;hidden = <span class="hljs-number">0</span>;        avl_data-&gt;data = (<span class="hljs-type">void</span> *)data;                <span class="hljs-keyword">return</span> <span class="hljs-built_in">bitree_ins_left</span>(tree, *node, avl_data);    }    <span class="hljs-keyword">else</span>    {        <span class="hljs-comment">/* Handle insertion into a tree that is not empty. */</span>        cmpval = tree-&gt;<span class="hljs-built_in">compare</span>(data, ((AvlNode *)<span class="hljs-built_in">bitree_data</span>(*node))-&gt;data);        <span class="hljs-keyword">if</span> (cmpval &lt; <span class="hljs-number">0</span>)        {            <span class="hljs-comment">/* Move to the left. */</span>            <span class="hljs-keyword">if</span> (<span class="hljs-built_in">bitree_is_eob</span>(<span class="hljs-built_in">bitree_left</span>(*node)))            {                <span class="hljs-keyword">if</span> ((avl_data = (AvlNode *)<span class="hljs-built_in">malloc</span>(<span class="hljs-built_in">sizeof</span>(AvlNode))) == <span class="hljs-literal">NULL</span>)                    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;                                avl_data-&gt;factor = AVL_BALANCED;                avl_data-&gt;hidden = <span class="hljs-number">0</span>;                avl_data-&gt;data = (<span class="hljs-type">void</span> *)data;                <span class="hljs-keyword">if</span> (<span class="hljs-built_in">bitree_ins_left</span>(tree, *node, avl_data) != <span class="hljs-number">0</span>)                    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;                                *balance = <span class="hljs-number">0</span>;            }            <span class="hljs-keyword">else</span>            {                <span class="hljs-keyword">if</span> ((retval = <span class="hljs-built_in">insert</span>(tree, &amp;<span class="hljs-built_in">bitree_left</span>(*node), data, balanced)) != <span class="hljs-number">0</span>)                <span class="hljs-keyword">return</span> retval;            }            <span class="hljs-comment">/* Ensure that the tree remains balanced. */</span>            <span class="hljs-keyword">if</span> (!(*balanced))            {                <span class="hljs-keyword">switch</span> (((AvlNode *)<span class="hljs-built_in">bitree_data</span>(*node))-&gt;factor)                {                    <span class="hljs-keyword">case</span> AVL_LFT_HEAVY:                        <span class="hljs-built_in">rotate_left</span>(node) ;                        *balanced = <span class="hljs-number">1</span>;                        <span class="hljs-keyword">break</span>;                    <span class="hljs-keyword">case</span> AVL_BALANCED:                        ((AvlNode *)<span class="hljs-built_in">bitree_data</span>(*node))-&gt;factor = AVL_LFT_HEAVY;                        <span class="hljs-keyword">break</span>;                    <span class="hljs-keyword">case</span> AVL_RGT_HEAVY:                        ((AvlNode *)<span class="hljs-built_in">bitree_data</span>(*node))-&gt;factor = AVL_BALANCED;                        *balanced = <span class="hljs-number">1</span>;                        <span class="hljs-keyword">break</span>;                }                            }        } <span class="hljs-comment">/* if (cmpval &lt; 0) */</span>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (cmpval &gt; <span class="hljs-number">0</span>)        {            <span class="hljs-comment">/* move to the right. */</span>            <span class="hljs-keyword">if</span> (<span class="hljs-built_in">bitree_is_eob</span>(<span class="hljs-built_in">bitree_right</span>(*node)))            {                <span class="hljs-keyword">if</span> ((avl_data = (AvlNode *)<span class="hljs-built_in">malloc</span>(<span class="hljs-built_in">sizeof</span>(AvlNode))) == <span class="hljs-literal">NULL</span>)                    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;                                avl_data-&gt;factor = AVL_BALANCED;                avl_data-&gt;hidden = <span class="hljs-number">0</span>;                avl_data-&gt;data = (<span class="hljs-type">void</span> *)data;                <span class="hljs-keyword">if</span> (<span class="hljs-built_in">bitree_ins_right</span>(tree, *node, avl_data) != <span class="hljs-number">0</span>)                    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;                                *balance = <span class="hljs-number">0</span>;            }            <span class="hljs-keyword">else</span>             {                <span class="hljs-keyword">if</span> ((retval = <span class="hljs-built_in">insert</span>(tree, &amp;<span class="hljs-built_in">bitree_right</span>(*node), data, balanced)) != <span class="hljs-number">0</span>)                    <span class="hljs-keyword">return</span> retval;            }            <span class="hljs-comment">/* Ensure that the tree remains balanced. */</span>            <span class="hljs-keyword">if</span> (!(*balanced))            {                <span class="hljs-keyword">switch</span> (((AvlNode *)<span class="hljs-built_in">bitree_data</span>(*node))-&gt;factor)                {                    <span class="hljs-keyword">case</span> AVL_LFT_HEAVY:                        ((AvlNode *)<span class="hljs-built_in">bitree_data</span>(*node))-&gt;factor = AVL_BALANCED;                        *balanced = <span class="hljs-number">1</span>;                        <span class="hljs-keyword">break</span>;                    <span class="hljs-keyword">case</span> AVL_BALANCED:                        ((AvlNode *)<span class="hljs-built_in">bitree_data</span>(*node))-&gt;factor = AVL_RGT_HEAVY;                        <span class="hljs-keyword">break</span>;                    <span class="hljs-keyword">case</span> AVL_RGT_HEAVY:                        <span class="hljs-built_in">rotate_right</span>(node) ;                        *balanced = <span class="hljs-number">1</span>;                        <span class="hljs-keyword">break</span>;                }                            } <span class="hljs-comment">/* if (cmpval) &gt; 0 */</span>            <span class="hljs-keyword">else</span>            {                 <span class="hljs-comment">/* Handle finding a copy of the data. */</span>                <span class="hljs-keyword">if</span> (!((Av1Node *)<span class="hljs-built_in">bitree_data</span>(*node))-&gt;hodden)                {                    <span class="hljs-comment">/* Do nothing since the data is in the tree and not hidden. */</span>                    <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;                }                <span class="hljs-keyword">else</span>                {                    <span class="hljs-comment">/* Insert the new data and mark it as not hidden. */</span>                    <span class="hljs-keyword">if</span> (tree-&gt;destroy != <span class="hljs-literal">NULL</span>)                    {                        <span class="hljs-comment">/* Destroy the hidden data since it is being replaced. */</span>                        tree-&gt;<span class="hljs-built_in">destory</span>(((Av1Node *)<span class="hljs-built_in">bitree_data</span>(*node))-&gt;data);                    }                    ((Av1Node *)<span class="hljs-built_in">bitree_data</span>(*node))-&gt;data = (<span class="hljs-type">void</span> *)data;                    ((Av1Node *)<span class="hljs-built_in">bitree_data</span>(*node))-&gt;hidden = <span class="hljs-number">0</span>;                                        <span class="hljs-comment">/* Do not rebalance because the tree structure is unchanged. */</span>                    *balanced = <span class="hljs-number">1</span>;                }            }        }                         }    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;}<span class="hljs-comment">/* hide */</span><span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">int</span> <span class="hljs-title">hide</span><span class="hljs-params">(BisTree *tree, BiTreeNode *node, <span class="hljs-type">const</span> <span class="hljs-type">void</span> *data)</span></span><span class="hljs-function"></span>{    <span class="hljs-type">int</span> cmpval, retval;    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">bitree_is_eob</span>(node))    {        <span class="hljs-comment">/* Return that the data was not found. */</span>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;    }    cmpval = tree-&gt;<span class="hljs-built_in">compare</span>(data, ((AvlNode *)<span class="hljs-built_in">bitree_data</span>(node))-&gt;data);    <span class="hljs-keyword">if</span> (cmpval &lt; <span class="hljs-number">0</span>)    {        <span class="hljs-comment">/* Move to the left.*/</span>        retval = <span class="hljs-built_in">hide</span>(tree, <span class="hljs-built_in">bitree_left</span>(node), data);    }    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (cmpval &gt; <span class="hljs-number">0</span>)    {        <span class="hljs-comment">/* Move to the right.*/</span>        retval = <span class="hljs-built_in">hide</span>(tree, <span class="hljs-built_in">bitree_right</span>(node), data);    }    <span class="hljs-keyword">else</span>    {        <span class="hljs-comment">/* Mark the node as hidden. */</span>        ((AvLNode *)<span class="hljs-built_in">bitree_data</span>(node))-&gt;hidden = <span class="hljs-number">1</span>;        retvaL = <span class="hljs-number">0</span>;    }    <span class="hljs-keyword">return</span> retval;}<span class="hljs-comment">/* lookup */</span><span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">int</span> <span class="hljs-title">lookup</span><span class="hljs-params">(BisTree *tree, BiTreeNode *node, <span class="hljs-type">void</span> *data)</span></span><span class="hljs-function"></span>{    <span class="hljs-type">int</span> cmpval, retval;    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">bitree_is_eob</span>(node))    {        <span class="hljs-comment">/* Return that the data was not found. */</span>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;    }    cmpval = tree-&gt;<span class="hljs-built_in">compare</span>(data, ((AvlNode *)<span class="hljs-built_in">bitree_data</span>(node))-&gt;data);    <span class="hljs-keyword">if</span> (cmpval &lt; <span class="hljs-number">0</span>)    {        <span class="hljs-comment">/* Move to the left.*/</span>        retval = <span class="hljs-built_in">lookup</span>(tree, <span class="hljs-built_in">bitree_left</span>(node), data);    }    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (cmpval &gt; <span class="hljs-number">0</span>)    {        <span class="hljs-comment">/* Move to the right.*/</span>        retval = <span class="hljs-built_in">lookup</span>(tree, <span class="hljs-built_in">bitree_right</span>(node), data);    }     <span class="hljs-keyword">else</span>    {        <span class="hljs-keyword">if</span>(!((AvlNode *)<span class="hljs-built_in">bitree_data</span>(node))-&lt;hidden)        {            <span class="hljs-comment">/* Pass back the data from the tree. */</span>            *data = ((AvlNode *)<span class="hljs-built_in">bitree_data</span>(node))-&gt;data;            retval = <span class="hljs-number">0</span>;        }        <span class="hljs-keyword">else</span>        {            <span class="hljs-comment">/* Return that the data was not found. */</span>            <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;         }    }    <span class="hljs-keyword">return</span> retval;}<span class="hljs-comment">/* bistree_init */</span><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">bistree_init</span><span class="hljs-params">(BisTree *tree, <span class="hljs-type">int</span> (*cpmpare)(<span class="hljs-type">void</span> *keyl, <span class="hljs-type">const</span> <span class="hljs-type">void</span> *key2), <span class="hljs-type">void</span> (*destory)(*data))</span></span><span class="hljs-function"></span>{    <span class="hljs-comment">/* Initialize the tree. */</span>    <span class="hljs-built_in">bitree_init</span>(tree, destory);    tree-&gt;compare = compare;}<span class="hljs-comment">/* bistree_destroy */</span><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">bistree_destroy</span><span class="hljs-params">(BisTree *tree)</span></span><span class="hljs-function"></span>{    <span class="hljs-comment">/* Destroy all nodes in the tree. */</span>    <span class="hljs-built_in">destory_left</span>(tree, <span class="hljs-literal">NULL</span>);    <span class="hljs-comment">/* No operations are allowed now, but clear the structure as a precaution. */</span>    <span class="hljs-built_in">memset</span>(tree, <span class="hljs-number">0</span>, <span class="hljs-built_in">sizeof</span>(BisTree));}<span class="hljs-comment">/* bistree_insert */</span><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">bistree_insert</span><span class="hljs-params">(BisTree *tree, <span class="hljs-type">const</span> <span class="hljs-type">void</span> *data)</span></span><span class="hljs-function"></span>{    <span class="hljs-type">int</span> balanced = O;    <span class="hljs-keyword">return</span> <span class="hljs-built_in">insert</span>(tree, &amp;<span class="hljs-built_in">bitree_rot</span>(tree), data, &amp;balanced);}<span class="hljs-comment">/* bitree_remove */</span><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">bitree_remove</span><span class="hljs-params">(BisTree *tree, <span class="hljs-type">const</span> <span class="hljs-type">void</span> *data)</span></span><span class="hljs-function"></span>{    <span class="hljs-keyword">return</span> <span class="hljs-built_in">hide</span>(tree, <span class="hljs-built_in">bitree_root</span>(tree), data);}<span class="hljs-comment">/* bistree_lookup */</span><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">bistree_lookup</span><span class="hljs-params">(BisTree *tree, <span class="hljs-type">void</span> *data)</span></span><span class="hljs-function"></span>{    <span class="hljs-keyword">return</span> <span class="hljs-built_in">lookup</span>(tree, <span class="hljs-built_in">bitree_root</span>(tree), data);}</code></pre></div><h5><span id="hong-hei-shu-r-b-shu">红黑树（R-B树）</span><a href="#hong-hei-shu-r-b-shu" class="header-anchor">#</a></h5><p><img src="https://gitee.com/txt1994/images/raw/master/img/R_B_tree/R_B_tree.png"></p><h6><span id="ding-yi">定义：</span><a href="#ding-yi" class="header-anchor">#</a></h6><p><strong>红黑树</strong> 为妥协的AVL树，平衡要求没AVL树严格，因此适用范围比AVL树多</p><p>红黑树是每个结点都带有颜色属性的二叉查找树，颜色或红色或黑色。待插入结点默认为红色结点，插入时按照二分插入。</p><ul><li><p>性质1. 结点是红色或黑色。</p></li><li><p>性质2. 根结点是黑色。 </p></li><li><p>性质3. 所有叶子都是黑色。（叶子是NIL结点）</p></li><li><p>性质4. 每个红色结点的两个子结点都是黑色。（从每个叶子到根的所有路径上不能有两个连续的红色结点）</p></li><li><p>性质5. 从任一节结点其每个叶子的所有路径都包含相同数目的黑色结点。</p></li></ul><h6><span id="r-b-shu-de-cha-ru-xuan-zhuan-fa"><strong><code>R_B树的插入旋转法</code></strong></span><a href="#r-b-shu-de-cha-ru-xuan-zhuan-fa" class="header-anchor">#</a></h6><blockquote><p> RR或LL，刚插入的结点的父节点是红色，叔叔结点也是红色，那么父节点和叔叔变为黑色，祖父结点变为红色</p><blockquote><p>刚插入的结点的父节点是红色，叔叔结点是黑色，那么父节点和叔叔结点需要左旋或右旋，然后原父结点变为黑色，叔叔结点变为红色。</p></blockquote></blockquote><blockquote><p> LR或RL，刚插入结点父结点是红色，叔叔结点也是红色，那么父节点和叔叔结点变为黑色，祖父结点变为红色，</p><blockquote><p>刚插入结点父结点是红色，叔叔结点为黑色，那么刚插入结点和父节点需要左旋或右旋，再次执行RR或LL步骤。</p></blockquote></blockquote><h6><span id="r-b-shu-de-shan-chu-xuan-zhuan-fa"><strong>R_B树的删除旋转法</strong>：</span><a href="#r-b-shu-de-shan-chu-xuan-zhuan-fa" class="header-anchor">#</a></h6><p>​        R_B树的删除为红黑树最复杂部分</p><p>1、红黑树删除的情形</p><p>​    一、从树中删除节点X（以寻找后继节点的方式进行删除）</p><p>​        情况①：如果X没有孩子，且如果X是红色，直接删除X；如果X是黑色，则以X为当前节点进行旋转调色，最后删掉X</p><p><img src="https://gitee.com/txt1994/images/raw/master/img/R_B_tree/R_B_Tree_leaf.svg"></p><p>​        情况②：如果X只有一个孩子C，交换X和C的数值，再对新X进行删除。根据红黑树特性，此时X不可能为红色，因为红色节点要么没有孩子，要么有两个黑孩子。此时以新X为当前节点进行情况①的判断</p><p><img src="https://gitee.com/txt1994/images/raw/master/img/R_B_tree/R_B_Tree_one_node.svg"></p><p>​        情况③：如果X有两个孩子，则从后继中找到最小节点D，交换X和D的数值，再对新X进行删除。此时以新X为当前节点进行情况①或②的判断</p><p>​    二、旋转调色（N=旋转调色的当前节点[等于情况①中的X]，P=N的父亲，W=N的兄弟，Nf=N的远侄子，Nn=N的近侄子）</p><p>​        情况1：N是根或者N是红色，则：直接将N设为黑色</p><p>​        情况2：N不是根且N是黑色，且W为红色，则：将W设为黑色，P设为红色，对P进行旋转(N为P的左子时进行左旋，N为P的右子时进行右旋)，将情况转化为情况1、2、3、4、5</p><p>​        情况3：N不是根且N是黑色，且W为黑色，且W的左右子均为黑色，则：将W设为红色，将P设为当前节点进行旋转调色，将情况转化为情况1、2、3、4、5</p><p>​        情况4：N不是根且N是黑色，且W为黑色，且Nf为黑色，Nn为红色，则：交换W与Nn的颜色，并对W进行旋转(N为P的左子进行右旋，N为P的右子进行左旋)，旋转后N的新兄弟W有一个红色WR，则转换为情况5</p><p>​        情况5：N不是根且N是黑色，且W为黑色，且Nf为红色，Nn为黑色，则：将W设为P的颜色，P和Nf设为黑色，并对P进行旋转(N为P的左子进行左旋，N为P的右子进行右旋)，N设为根</p><h5><span id="b-shu-b-shu-b-shu">B树，B+树，B*树</span><a href="#b-shu-b-shu-b-shu" class="header-anchor">#</a></h5><p>当数据量非常大时，二叉树已经不能满足需求，如果还用二叉树那么树的深度过大，一个节点存储多个数据就应运而生了。</p><p>定义：</p><p>B树是一种平衡的多分树，通常我们说m阶的B树，它必须满足如下条件： </p><ul><li><p>每个节点最多只有m个子节点。</p></li><li><p>每个非叶子节点（除了根）具有至少⌈ m/2⌉子节点。</p></li><li><p>如果根不是叶节点，则根至少有两个子节点。</p></li><li><p>具有<em>k</em>个子节点的非叶节点包含<em>k</em> -1个键。</p></li><li><p>所有叶子都出现在同一水平，没有任何信息（高度一致）。</p><p><img src="https://gitee.com/txt1994/images/raw/master/img/data-structure/997909-20190727111522935-981534929.png"></p></li></ul><p>此树的一个节点最多有4个结点，一个节点最多有三个值，</p><p>插入如删除方法：<a href="https://www.cnblogs.com/lianzhilei/p/11250589.html"><strong>B树插入与删除</strong></a></p><p><strong>B+树</strong></p><p>在B树的基础上增加了数据遍历优点，想要遍历整个树的数据只要把叶子节点便完毕就行，因为B+树的叶子节点数据是整棵树数据，非叶子节点是叶子节点索引。</p><p><img src="https://gitee.com/txt1994/images/raw/master/img/data-structure/997909-20190728114240297-169990922.png"></p><p><strong>B*树</strong></p><p>B*树在B+树的基础上增加了非叶子结点之间链表相联系。</p><p><img src="https://gitee.com/txt1994/images/raw/master/img/data-structure/171056_sAnR_135650.jpg"></p><h5><span id="2-3-4-shu"><strong>2-3-4树</strong></span><a href="#2-3-4-shu" class="header-anchor">#</a></h5><p>2-3-4树是4阶B树，<a href="https://www.cnblogs.com/sfencs-hcy/p/10363259.html"><strong>2-3-4树插入与删除</strong></a></p><h5><span id="treap-shu">treap树</span><a href="#treap-shu" class="header-anchor">#</a></h5><p>所谓的Treap树堆其实就是树 + 堆。树是二叉查找树BST，堆是二叉堆，大根堆小根堆都可以。</p><p>树堆既是一棵二叉查找树，也是一个二叉堆。但是这两种数据结构貌似还是矛盾的存在，如果是二叉查找树，就不能是一个堆，如果是一个堆，那么必然不是二叉查找树。</p><p>所以树堆用了一个很巧妙的方式解决这个问题：<strong>给每个键值一个随机附加的优先级</strong>，让键值满足二叉查找树的结构，让优先级满足二叉堆的结构。</p><p><a href="https://www.cnblogs.com/fusiwei/p/12884254.html"><strong>treap树的详解，插入与删除</strong></a></p><h5><span id="k-d-shu"><strong>k-d树</strong></span><a href="#k-d-shu" class="header-anchor">#</a></h5><p><strong>k-d树</strong>常用来作空间划分及近邻搜索，是二叉空间划分树的一个特例。</p><p><a href="https://www.cnblogs.com/flyinggod/p/8727584.html">K-D TREE算法原理及实现</a></p><h5><span id="zui-xiao-sheng-cheng-shu-minimum-spanning-tree">最小生成树(Minimum Spanning Tree)</span><a href="#zui-xiao-sheng-cheng-shu-minimum-spanning-tree" class="header-anchor">#</a></h5><p>对于有n个顶点的连通图，生成树有n-1条边，若边数小于此数就不可能将各顶点连通，如果边的数量多于n-1条边，必定会产生回路。</p><p><a href="https://www.cnblogs.com/dengfaheng/p/9245794.html">最小生成树(Minimum Spanning Tree理解</a></p><h4><span id="6-dui-he-you-xian-dui-lie">6.堆和优先队列</span><a href="#6-dui-he-you-xian-dui-lie" class="header-anchor">#</a></h4><p>在许多问题中，当对数据集进行频繁的插入和删除操作时，往往需要快速确定最大或最小的元素。处理这个问题的方法之一，就是使用一个已排好序的数据集，通过这种方法，最大或最小的元素总是处在数据集的头部（这取决于使用升序还是降序排列）。然而将数据集一遍又一遍地进行排序的代价是非常高的。并且许多情况下，将元素排序并不是超越的目的，最终我们可能在真正要做的工作之外做了很多其他工作，想要快速的找到最大或最小的元素，只需要让元素储存在可以找到它的位置上就行。堆和优先队列，就是一种处理这种问题的有效方法。</p><p>本章内容包括：</p><h5><span id="dui"><strong>堆</strong>：</span><a href="#dui" class="header-anchor">#</a></h5><blockquote><p>它是一种树形组织，使我们能够迅速确定包含最大值的结点。维持一棵树的代价低于维持一个有序数据集。同样，我们可以确定通过堆快速地找到包含最小值的元素。</p></blockquote><h5><span id="you-xian-dui-lie"><strong>优先队列</strong></span><a href="#you-xian-dui-lie" class="header-anchor">#</a></h5><blockquote><p>它是一个从堆自然衍生而来的数据结构。在优先队列中，数据保存在一个堆中，这样我们能够迅速确定下一个最高优先级的结点。所谓元素的“优先级”在不同的问题中有不同的意义。</p></blockquote><p>队和优先队列的一些应用：</p><h5><span id="pai-xu-dui-pai-xu">排序：堆排序</span><a href="#pai-xu-dui-pai-xu" class="header-anchor">#</a></h5><h5><span id="ren-wu-diao-du">任务调度</span><a href="#ren-wu-diao-du" class="header-anchor">#</a></h5><blockquote><p>任务调度会告诉操作系统接下来哪个进程将在CPU上运行。操作系统会不断调整进 程的优先级，用优先队列来存储进程是相对比较高效的方法，因为它可以确保下一 个将在CPU中运行的进程的优先级是最高的。</p></blockquote><h5><span id="bao-qian-fen-jian-jian-ben-zhang-xiang-guan-zhang-jie">包褰分拣（见本章相关章节）</span><a href="#bao-qian-fen-jian-jian-ben-zhang-xiang-guan-zhang-jie" class="header-anchor">#</a></h5><blockquote><p>快递公司通常用包裹分拣法来确定包裹递送的优先级。当扫描包裹时，高优先级的 包裹将作为急快件投递出去。而非急快件将作为较低优先级的包裹投递出去。计算 机系统通常使用优先队列来保证最高优先级的包在系统中运行最顺畅，因为这种方 法十分高效。</p></blockquote><h5><span id="huo-fu-man-bian-ma">霍夫曼编码</span><a href="#huo-fu-man-bian-ma" class="header-anchor">#</a></h5><blockquote><p>这是一种数据压缩方法，它使用霍夫曼树为数据符号分配编码（见第14章）。向出 现频率较高的符号分配较短的编码,向出现频率较低的符号分配较长的编码。霍夫 曼树是由较小的二叉树两两合并构成。由于每次都必须合并键值最小的二叉树，因 此每次合并的两棵树都是从一个优先队列中取出的。</p></blockquote><h5><span id="fu-zai-jun-heng">负载均衡</span><a href="#fu-zai-jun-heng" class="header-anchor">#</a></h5><blockquote><p>它用来维护管理一系列处理类似任务的服务。当连接请求到达时，优先队列可以确定哪 个服务器能够最好地处理到达的任务。</p></blockquote><p><a href="https://gitee.com/txt1994/images/raw/master/img/Heap_tree/heap.svg">堆排序</a></p><p><img src="https://gitee.com/txt1994/images/raw/master/img/Heap_tree/heap.svg"></p><p><strong>优先队列的描述:</strong></p><p>   优先队列将数据按照优先级顺序排列。一个优先队列由许多有序的元素构成，所以优先级最高的元素可以有效而快速地确定,例如，我们看一组用来做负载均衡的服务器，时时观察它们的使用情况。当连接请求到达时，优先队列可以告知当前哪个服务器是处理 此连接请求的最佳服务器。在这种情况下，最空闲的服务器获取的优先级最高，因为它 可以最好地处理服务请求。</p>]]></content>
    
    
    
    <tags>
      
      <tag>data-structures</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>算法</title>
    <link href="/2022/01/01/%E7%AE%97%E6%B3%95/"/>
    <url>/2022/01/01/%E7%AE%97%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<div class="toc"><!-- toc --><ul><li><a href="#suan-fa-bu-fen">算法部分</a></li></ul><!-- tocstop --></div><p>推荐看👉 <a href="https://oi-wiki.org/">OI Wiki</a></p><h1><span id="suan-fa-bu-fen">算法部分</span><a href="#suan-fa-bu-fen" class="header-anchor">#</a></h1><h5><span id="wei-tu-bitmap"><strong>位图(bitmap)</strong></span><a href="#wei-tu-bitmap" class="header-anchor">#</a></h5><p>通过一个bit位来表示某个元素对应的值或者状态，其中的key就是对应元素本身，value对应0或1，我们知道8个bit可以组成一个Byte，所以bitmap本身会极大的节省储存空间。</p><p><a href="https://www.cnblogs.com/chjxbt/p/10615304.html">位图BitMap</a></p><h5><span id="zi-dian-map"><strong>字典(map)</strong></span><a href="#zi-dian-map" class="header-anchor">#</a></h5><ul><li><p>字典有什么特点呢?</p><ul><li>字典的主要特点是一一对应的关系.</li><li>比如保存一个人的信息, 在合适的情况下取出这些信息.</li><li>使用数组的方式: [18, “Coderwhy”, 1.88]. 可以通过下标值取出信息.</li><li>使用字典的方式: {“age” : 18, “name” : “Coderwhy”, “height”: 1.88}. 可以通过key取出value</li></ul><p><a href="https://www.jianshu.com/p/c53460c9c8e4">字典(map)的详细解释</a></p></li></ul><h5><span id="kmp-suan-fa"><strong>kmp算法</strong></span><a href="#kmp-suan-fa" class="header-anchor">#</a></h5><p>kmp算法也就是字符串匹配算法。</p><p>比如：<br>在string str = “abc<code>ababc</code>ba”中匹配<br>string str2 = “<code>ababc</code>“字符串</p><p>最长公共前后缀：要匹配的字符串生成的数组</p><p>从一个字符开始到整个字符串，默认每行的公共前后缀最大值为全部字母数，然后判断是否符合其数字，如果不符合减一，一直判断到0结束。一行元素为1的数字为0，最后一行不统计</p><p>0    a</p><p>0    a    b</p><p>1    a    b    a</p><p>2    <code>a    b    a    b</code></p><p>0    a    b    a    b    c</p><p>得出的公共前后缀为</p><table><thead><tr><th align="left"></th><th align="left"></th><th align="left"></th><th align="left"></th><th align="left"></th></tr></thead><tbody><tr><td align="left">0</td><td align="left">0</td><td align="left">1</td><td align="left">2</td><td align="left">0</td></tr></tbody></table><p>然后整体向后移动一位，原最后一位被覆盖，下标为0的位置设为-1,最后的公共前后缀为</p><table><thead><tr><th></th><th></th><th></th><th></th><th></th></tr></thead><tbody><tr><td><code>-1</code></td><td>0</td><td>0</td><td>1</td><td>2</td></tr></tbody></table><p>kmp匹配过程</p><p>abc<code>ababc</code>ba</p><p>ababc</p><p><img src="https://gitee.com/txt1994/images/raw/master/img/algorithm/kmp.png"></p><p>如果匹配到不相等元素，则通过next数组(P)决定next数组移动的位置，例如上图next数组(P)下标为2的元素与T字符串不相等，则看一下P数组下标2的next数组的值为0，则把next数组下标为0的位置移动到不匹配的地方</p><p><img src="https://gitee.com/txt1994/images/raw/master/img/algorithm/kmp_2.png"></p><p>如果next数组的值为-1则next数组整体右移，或找到T字符串与子字符串第一个元素(如果找到的话)，然后把P移动到此位置(T的剩余的元素大于等于子字符串元素个数)；</p><p><strong>代码</strong></p><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstring&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span><span class="hljs-comment">// 计算最长公共前后缀</span><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">prefix_table</span><span class="hljs-params">(<span class="hljs-type">char</span> pattern[], <span class="hljs-type">int</span> prefix[], <span class="hljs-type">int</span> n)</span> </span>{     prefix[<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;     <span class="hljs-type">int</span> len = <span class="hljs-number">0</span>;     <span class="hljs-type">int</span> i = <span class="hljs-number">1</span>;     <span class="hljs-keyword">while</span> (i &lt; n) {         <span class="hljs-keyword">if</span> (pattern[i] == pattern[len]) {             len++;             prefix[i] = len;             i++;         } <span class="hljs-keyword">else</span> {             <span class="hljs-keyword">if</span> (len &gt; <span class="hljs-number">0</span>) {                 len = prefix[len - <span class="hljs-number">1</span>];             } <span class="hljs-keyword">else</span> {                 prefix[i] = len;                 i++;             }         }     }}<span class="hljs-comment">// 计算next数组</span><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">move_prefix_table</span><span class="hljs-params">(<span class="hljs-type">int</span> table[], <span class="hljs-type">int</span> n)</span> </span>{    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = n - <span class="hljs-number">1</span>; i &gt; <span class="hljs-number">0</span>; --i) {        table[i] = table[i - <span class="hljs-number">1</span>];    }    table[<span class="hljs-number">0</span>] = <span class="hljs-number">-1</span>;}<span class="hljs-comment">// kmp算法</span><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">kmp_search</span><span class="hljs-params">(<span class="hljs-type">char</span> text[], <span class="hljs-type">char</span> pattern[])</span> </span>{    <span class="hljs-type">int</span> n = <span class="hljs-built_in">strlen</span>(pattern);    <span class="hljs-type">int</span> m = <span class="hljs-built_in">strlen</span>(text);    <span class="hljs-type">int</span> *prefix = <span class="hljs-keyword">new</span> <span class="hljs-type">int</span>[n];     <span class="hljs-built_in">prefix_table</span>(pattern, prefix, n);    <span class="hljs-built_in">move_prefix_table</span>(prefix, n);      <span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;    <span class="hljs-type">int</span> j = <span class="hljs-number">0</span>;    <span class="hljs-keyword">while</span> (i &lt; m) {        <span class="hljs-keyword">if</span> (j == n - <span class="hljs-number">1</span> &amp;&amp; text[i] == pattern[j]) {            std::cout &lt;&lt; <span class="hljs-string">"Found pattern at "</span> &lt;&lt; i - j &lt;&lt; <span class="hljs-string">'\n'</span>;            j = prefix[j];        }        <span class="hljs-keyword">if</span> (text[i] == pattern[j]) {            i++;            j++;        } <span class="hljs-keyword">else</span> {            j = prefix[j];            <span class="hljs-keyword">if</span> (j == <span class="hljs-number">-1</span>) {                i++;                j++;            }        }    }     <span class="hljs-keyword">delete</span>[] prefix;}<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span> </span>{    <span class="hljs-type">char</span> pattern[] = <span class="hljs-string">"ABABCABAA"</span>;     <span class="hljs-type">char</span> text[] = <span class="hljs-string">"ABABABCABAABABABAAB"</span>;    <span class="hljs-built_in">kmp_search</span>(text, pattern);    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;}</code></pre></div><h5><span id="shuang-zhi-zhen"><strong>双指针</strong></span><a href="#shuang-zhi-zhen" class="header-anchor">#</a></h5><h5><span id="tong-xiang-shuang-zhi-zhen"><strong>同向双指针</strong></span><a href="#tong-xiang-shuang-zhi-zhen" class="header-anchor">#</a></h5><p>判断一个链表是否有<strong>环</strong></p><p>创建两个指针<code>ptr1,ptr2</code>,两个指针同时指向链表头结点。ptr1每次向后移动一个结点，ptr2每次移动2个结点，如果链表有环他们会指向同一个结点</p><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> {<span class="hljs-keyword">public</span>:    <span class="hljs-comment">/**</span><span class="hljs-comment">     * @param circles: The value of 6 points on n rings</span><span class="hljs-comment">     * @return: Whether there are two same circles</span><span class="hljs-comment">     */</span>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">samecircle</span><span class="hljs-params">(Node head)</span> </span>{        <span class="hljs-comment">// write your code here</span>        Node ptr2 = head;        Node ptr2 = head;        <span class="hljs-keyword">while</span> (p1 != <span class="hljs-literal">nullptr</span> &amp;&amp; p2 != <span class="hljs-literal">nullptr</span>)        {            ptr1 = p1.next;            ptr2 = p2.next.next;            <span class="hljs-keyword">if</span> (ptr1 == ptr2) <span class="hljs-comment">// 结点相遇</span>                <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;        }        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;    }};</code></pre></div><p><strong>判断环长</strong></p><p>第一次相遇代表有环，第二次相遇代表两个指针发生了套环，所以：</p><p>环长 = 速度差 * 移动次数</p><p><strong>判断入环点</strong></p><p>慢指针<strong>ptr1</strong>每次走一步，所以走的距离是：</p><p>d1 = D  + X * (S1 + S2) + S1</p><p>快指针ptr2走的距离是：</p><p>d2 = D + N * (S1 + S2) + S1</p><p>快指针速度是慢指针2倍。 即：</p><p>2 * d1 = d2</p><p>整理后的公式为</p><p>D = (n - 2X - 1)(S1 + S2) + S2</p><p>假设<code>n - 2X -1</code>的值为0，则<code>D = S2</code>;，那么我们就可以在首次相遇点的时候，定义一个指针指向链表的起点，一个指针指向首次相遇点，然后两个指针每次前进1步，当两个指针相遇的时候就是链表的入环点。</p><p>例子：</p><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> {<span class="hljs-keyword">public</span>:    <span class="hljs-comment">/**</span><span class="hljs-comment">     * @param circles: The value of 6 points on n rings</span><span class="hljs-comment">     * @return: Whether there are two same circles</span><span class="hljs-comment">     */</span>    <span class="hljs-function">Node <span class="hljs-title">find_node</span><span class="hljs-params">(Node head)</span></span><span class="hljs-function">    </span>{        <span class="hljs-comment">// write your code here</span>        Node ptr1 = head;        Node ptr2 = head;        Node ptr3 = <span class="hljs-literal">nullptr</span>;        Node ptr4 = <span class="hljs-literal">nullptr</span>;        <span class="hljs-keyword">while</span> (p1 != <span class="hljs-literal">nullptr</span> &amp;&amp; p2 != <span class="hljs-literal">nullptr</span>)        {            ptr1 = p1.next;            ptr2 = p2.next.next;            <span class="hljs-keyword">if</span> (ptr1 == ptr2) <span class="hljs-comment">// 结点相遇</span>                ptr3 = head;            ptr4 = ptr1;            <span class="hljs-keyword">break</span>;        }        <span class="hljs-keyword">if</span> (ptr3 != <span class="hljs-literal">nullptr</span> &amp;&amp; != ptr4 != <span class="hljs-literal">nullptr</span>)        {            <span class="hljs-keyword">while</span>(ptr3 != ptr4)            {                ptr3 = ptr3.next;                ptr4 = ptr4.next;            }            <span class="hljs-keyword">return</span> ptr4;        }        <span class="hljs-keyword">return</span> <span class="hljs-literal">nullptr</span>;    }};</code></pre></div><h5><span id="xiang-xiang-shuang-zhi-zhen"><strong>相向双指针</strong></span><a href="#xiang-xiang-shuang-zhi-zhen" class="header-anchor">#</a></h5><h5><span id="er-fen-fa"><strong>二分法</strong></span><a href="#er-fen-fa" class="header-anchor">#</a></h5><ul><li>又称折半搜索，期望时间复杂度为O(log2n)，最差为O(log2(n + 1))</li></ul><blockquote><p>二分法前提是数据已经有序</p><p>在A[0] … A[n]中搜索K。</p></blockquote><blockquote><p>步骤：<br>   \1. 令low = 0， high = n - 1，初始的查找区域为[low， high].<br>   \2. 取low和high的中间值mid = (low+high)/2。<br>   \3. 如果A[mid] = K，则返回mid, 如果不等，则重新确定查找区间。<br>   \4. 当low &gt; high 时，则表示区间已经失效，如果还未找到，则表示数组中不包含K的值，返回-1。</p></blockquote><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span> T&gt;</span><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">binary_search</span><span class="hljs-params">(vector&lt;T&gt; &amp;A, T K)</span></span><span class="hljs-function"></span>{    <span class="hljs-type">int</span> low = <span class="hljs-number">0</span>;    <span class="hljs-type">int</span> high = A.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>;        <span class="hljs-keyword">while</span>( low &lt; high )    {        <span class="hljs-type">int</span> mid = (low + high)/<span class="hljs-number">2</span>;        <span class="hljs-keyword">if</span>( A[mid]  &lt; K )            low = mid + <span class="hljs-number">1</span>;        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>( A[mid] &gt; k )            high = mid - <span class="hljs-number">1</span>;        <span class="hljs-keyword">else</span>            <span class="hljs-keyword">return</span> mid;    }      <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;      <span class="hljs-comment">/*返回-1表示数组不存在K的值*/</span> }</code></pre></div><h5><span id="er-fen-da-an"><strong>二分答案</strong></span><a href="#er-fen-da-an" class="header-anchor">#</a></h5><blockquote><p><code>二分答案</code>与<code>二分查找</code> 其实是不一样的</p><p><code>二分答案</code>: 即对你要求的答案进行二分<br><code>二分查找</code>: 对一个已知的有序数据集上进行二分的查找</p></blockquote><p><a href="https://www.cnblogs.com/Potassium/p/10125386.html">基础算法·二分答案 - Potassium - 博客园 (cnblogs.com)</a></p><h5><span id="fen-zhi-fa"><strong>分治法</strong></span><a href="#fen-zhi-fa" class="header-anchor">#</a></h5><blockquote><p>分治分治，即分而治之。分治，就是<strong>把一个复杂的问题分成两个或更多的相同或相似的子问题</strong>，再把子问题分成更小的子问题……直到最后子问题可以简单的直接求解，原问题的解即子问题的解的合并。这个技巧是很多高效算法的基础，如<strong>排序算法</strong>(快速排序，归并排序)，<strong>傅立叶变换</strong>(快速傅立叶变换)……直接说就是将一个难以直接解决的大问题，分割成一些规模比较小的相同的小问题，以便各个击破，分而治之。</p></blockquote><blockquote><p>分治法所能解决的问题一般具有以下几个特征：</p><p>\1) 该问题的规模缩小到一定的程度就可以容易地解决</p><p>\2) 该问题可以分解为若干个规模较小的相同问题，即该问题具有最优子结构性质。</p><p>\3) 利用该问题分解出的子问题的解可以合并为该问题的解；</p><p>\4) 该问题所分解出的各个子问题是相互独立的，即子问题之间不包含公共的子子问题。</p><p>第一条: 特征是绝大多数问题都可以满足的，因为问题的计算复杂性一般是随着问题规模的增加而增加；</p><p><strong>第二条: 特征是应用分治法的前提</strong>它也是大多数问题可以满足的，此特征反映了递归思想的应用；、</p><p><strong>第三条: 特征是关键，能否利用分治法完全取决于问题是否具有第三条特征</strong>，如果具备了第一条和第二条特征，而不具备第三条特征，则可以考虑用贪心法或动态规划法。</p><p><strong>第四条: 特征涉及到分治法的效率</strong>，如果各子问题是不独立的则分治法要做许多不必要的工作，重复地解公共的子问题，此时虽然可用分治法，但<strong>一般用动态规划法较好</strong>。</p></blockquote><p>经典问题:</p><p><strong>二分查找</strong></p><p><strong>棋盘覆盖</strong></p><p><strong>汉诺塔问题</strong></p><p><strong>归并排序/合并排序</strong></p><p><strong>快速排序</strong></p><h5><span id="kuan-du-you-xian-sou-suo-bfs"><strong>宽度优先搜索(BFS)</strong></span><a href="#kuan-du-you-xian-sou-suo-bfs" class="header-anchor">#</a></h5><blockquote><p>它并不考虑结果的可能位置，彻底地搜索整张图，直到找到结果为止。</p><p>基本过程，BFS 是从根节点开始，沿着树(图)的宽度遍历树(图)的节点。如果所有节点均被访问，则算法中止。一般用队列数据结构来辅助实现 BFS 算法。</p></blockquote><p><a href="https://www.cnblogs.com/huansky/p/12826857.html">广度优先搜索原理与实践 - huansky - 博客园 (cnblogs.com)</a></p><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">private</span> Map&lt;String, Boolean&gt; status = <span class="hljs-keyword">new</span> <span class="hljs-built_in">HashMap</span>&lt;String, Boolean&gt;();    <span class="hljs-keyword">private</span> Queue&lt;String&gt; queue = <span class="hljs-keyword">new</span> <span class="hljs-built_in">LinkedList</span>&lt;String&gt;();    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-type">void</span> <span class="hljs-title">BFSSearch</span><span class="hljs-params">(String startPoint)</span> </span>{        <span class="hljs-comment">//1.把起始点放入queue；</span>        queue.<span class="hljs-built_in">add</span>(startPoint);        status.<span class="hljs-built_in">put</span>(startPoint, <span class="hljs-literal">false</span>);        <span class="hljs-built_in">bfsLoop</span>();    }        <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-type">void</span> <span class="hljs-title">bfsLoop</span><span class="hljs-params">()</span> </span>{        <span class="hljs-keyword">while</span>(!queue.<span class="hljs-built_in">isEmpty</span>()) {            <span class="hljs-comment">//  1) 从queue中取出队列头的点；更新状态为已经遍历。</span>            String currentQueueHeader = queue.<span class="hljs-built_in">poll</span>(); <span class="hljs-comment">//出队</span>            status.<span class="hljs-built_in">put</span>(currentQueueHeader, <span class="hljs-literal">true</span>);            System.out.<span class="hljs-built_in">println</span>(currentQueueHeader);            <span class="hljs-comment">//  2) 找出与此点邻接的且尚未遍历的点，进行标记，然后全部放入queue中。</span>            List&lt;String&gt; neighborPoints = graph.<span class="hljs-built_in">get</span>(currentQueueHeader);            <span class="hljs-keyword">for</span> (String poinit : neighborPoints) {                <span class="hljs-keyword">if</span> (!status.<span class="hljs-built_in">getOrDefault</span>(poinit, <span class="hljs-literal">false</span>)) { <span class="hljs-comment">//未被遍历</span>                    <span class="hljs-keyword">if</span> (queue.<span class="hljs-built_in">contains</span>(poinit)) <span class="hljs-keyword">continue</span>;                    queue.<span class="hljs-built_in">add</span>(poinit);                    status.<span class="hljs-built_in">put</span>(poinit, <span class="hljs-literal">false</span>);                }            }        }    }</code></pre></div><h5><span id="tuo-bu-pai-xu-fa"><strong>拓扑排序法</strong></span><a href="#tuo-bu-pai-xu-fa" class="header-anchor">#</a></h5><ul><li>拓扑排序指的是将有向无环<a href="http://data.biancheng.net/view/200.html">图</a>（又称“DAG”图）中的顶点按照图中指定的先后顺序进行排序。</li></ul><p><a href="https://www.cnblogs.com/MrSaver/p/9994720.html">算法：拓扑排序 - 子烁爱学习 - 博客园 (cnblogs.com)</a></p><p><a href="http://data.biancheng.net/view/43.html">拓扑排序算法及C语言实现 (biancheng.net)</a></p><h5><span id="shen-du-you-xian-sou-suo-hui-su-fa-dfs"><strong>深度优先搜索/回溯法 (DFS)</strong></span><a href="#shen-du-you-xian-sou-suo-hui-su-fa-dfs" class="header-anchor">#</a></h5><blockquote><p>深度优先搜索（缩写DFS）有点类似广度优先搜索，也是对一个连通图进行遍历的算法。它的思想是<strong>从一个顶点V0开始，沿着一条路一直走到底</strong>，如果发现不能到达目标解，那就返回到上一个节点，然后从另一条路开始走到底，这种尽量往深处走的概念即是深度优先的概念。</p></blockquote><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-comment">/**</span><span class="hljs-comment"> * DFS核心伪代码</span><span class="hljs-comment"> * 前置条件是visit数组全部设置成false</span><span class="hljs-comment"> * @param n 当前开始搜索的节点</span><span class="hljs-comment"> * @param d 当前到达的深度，也即是路径长度</span><span class="hljs-comment"> * @return 是否有解</span><span class="hljs-comment"> */</span><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">DFS</span><span class="hljs-params">(Node n, <span class="hljs-type">int</span> d)</span></span>{    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">isEnd</span>(n, d)){<span class="hljs-comment">//路径长度为返回true，表示此次搜索有解</span>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;    }     <span class="hljs-keyword">for</span> (Node nextNode in n){<span class="hljs-comment">//遍历跟节点n相邻的节点nextNode，</span>        <span class="hljs-keyword">if</span> (!visit[nextNode]){<span class="hljs-comment">//未访问过的节点才能继续搜索</span>             <span class="hljs-comment">//例如搜索到V1了，那么V1要设置成已访问</span>            visit[nextNode] = <span class="hljs-literal">true</span>;             <span class="hljs-comment">//接下来要从V1开始继续访问了，路径长度当然要加</span>             <span class="hljs-keyword">if</span> (<span class="hljs-built_in">DFS</span>(nextNode, d+<span class="hljs-number">1</span>)){<span class="hljs-comment">//如果搜索出有解</span>                <span class="hljs-comment">//例如到了V6，找到解了，你必须一层一层递归的告诉上层已经找到解</span>                <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;            }             <span class="hljs-comment">//重新设置成未访问，因为它有可能出现在下一次搜索的别的路径中</span>            visit[nextNode] = <span class="hljs-literal">false</span>;         }        <span class="hljs-comment">//到这里，发现本次搜索还没找到解，那就要从当前节点的下一个节点开始搜索。</span>    }    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<span class="hljs-comment">//本次搜索无解</span>}</code></pre></div><h5><span id="dong-tai-gui-hua"><strong>动态规划</strong></span><a href="#dong-tai-gui-hua" class="header-anchor">#</a></h5><blockquote><p>它将问题分成小问题，并先着手解决这些小问题</p></blockquote><h5><span id="bei-bao-xing-dp"><strong>背包型DP</strong></span><a href="#bei-bao-xing-dp" class="header-anchor">#</a></h5><p>假设有三种商品，分别是小汽车1吨，卡车3吨，起重机4吨.价格分别是：3000，4000，6000。</p><p>现在只能卖总共4吨的商品，怎么卖商品售价最高？</p><p>所有的组合为：</p><table><thead><tr><th align="left">组合</th><th align="left">价值</th></tr></thead><tbody><tr><td align="left">无</td><td align="left">0</td></tr><tr><td align="left">小汽车</td><td align="left">3000</td></tr><tr><td align="left">卡车</td><td align="left">4000</td></tr><tr><td align="left">起重机</td><td align="left">6000</td></tr><tr><td align="left">小汽车和起重机</td><td align="left">重量过大</td></tr><tr><td align="left">小汽车和卡车</td><td align="left">7000</td></tr><tr><td align="left">卡车和起重机</td><td align="left">重量过大</td></tr><tr><td align="left">小汽车,卡车，起重机</td><td align="left">重量过大</td></tr></tbody></table><p>可以看到随着商品种类增加组合也在飞速增长，时间复杂度为O(2^n),太慢了</p><p>动态规划算法可以用网格描述</p><p><img src="https://gitee.com/txt1994/images/raw/master/img/algorithm/DP-knapsack.png"></p><p>填充这些表格最后就是背包问题的解法。</p><blockquote><p>当在小汽车一行时，其他种类的商品选不了，所以都是3000</p></blockquote><p><img src="https://gitee.com/txt1994/images/raw/master/img/algorithm/DP-knapsack%20-2.png"></p><blockquote><p>当加入卡车时1-2吨放不下3吨的卡车，3吨可以放下卡车，所以为4000，4吨可以放下一个卡车和一个小汽车，共7000</p></blockquote><p><img src="https://gitee.com/txt1994/images/raw/master/img/algorithm/DP-knapsack%20-%203.png"></p><blockquote><p>加入起重机时，1-2背包只能装小汽车，3吨可以装一辆卡车，4吨可以装起重机，但是价格低于7000所以不选起重机的价格，定位卡车加小汽车，价格为7000.</p></blockquote><p><img src="https://gitee.com/txt1994/images/raw/master/img/algorithm/DP-knapsack%20-%204.png"></p><h5><span id="zuo-biao-xing-dp"><strong>坐标型DP</strong></span><a href="#zuo-biao-xing-dp" class="header-anchor">#</a></h5><blockquote><p>又被称为网格型动态规划</p><p>一个网格有m行n列，一个小动物从(0, 0)出发，每一步可以向下或向右走一步，最总到达(m - 1, n - 1)处</p></blockquote><ul><li>最简单的动态规划类型</li><li>给定一个序列或者网格</li><li>需要找到序列中某个/些子序列或网格中的某条路径<ul><li>某种性质最大/最小</li><li>计数</li><li>存在性</li></ul></li><li>动态规划方程 f[i] 中的下标i表示以ai为结尾的满足条件的子序列的性质，f[i][j] 中下标 i , j 表示以格子( i , j )为结尾的满足条件的路径的性质<ul><li>最大值/最小值</li><li>个数</li><li>存在性</li></ul></li><li>坐标型动态规划的初始条件f[0]就是指以a0为结尾的子序列的性质</li></ul><p><a href="https://www.motongxue.cn/posts/1487252037/#D2-%E5%9D%90%E6%A0%87%E5%9E%8B%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92">D2-坐标型动态规划</a></p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> {    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">uniquePathsWithObstacles</span><span class="hljs-params">(<span class="hljs-type">int</span>[][] obstacleGrid)</span> {        <span class="hljs-keyword">if</span>(obstacleGrid==<span class="hljs-literal">null</span>||obstacleGrid.length==<span class="hljs-number">0</span>){            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;        }        <span class="hljs-type">int</span> [] [] dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[obstacleGrid.length][obstacleGrid[<span class="hljs-number">0</span>].length];        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;obstacleGrid.length;i++){            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;j&lt;obstacleGrid[i].length;j++){                <span class="hljs-keyword">if</span>(obstacleGrid[i][j]==<span class="hljs-number">1</span>){<span class="hljs-comment">//有障碍</span>                    dp[i][j]=<span class="hljs-number">0</span>;                    <span class="hljs-keyword">continue</span>;                }<span class="hljs-keyword">else</span>{                    <span class="hljs-keyword">if</span>(i == <span class="hljs-number">0</span> &amp;&amp; j == <span class="hljs-number">0</span>) dp[i][j]=<span class="hljs-number">1</span>;<span class="hljs-comment">//没有障碍起点</span>                    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(i==<span class="hljs-number">0</span>) dp[i][j]=dp[i][j-<span class="hljs-number">1</span>];<span class="hljs-comment">//在第一行,上一题在没有障碍情况下默认是1,但是有障碍就取决于该行前面是否有障碍了</span>                    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(j==<span class="hljs-number">0</span>) dp[i][j]=dp[i-<span class="hljs-number">1</span>][j];<span class="hljs-comment">//第一列,没有障碍默认是1,有障碍就取决于该列前面是否有障碍了</span>                    <span class="hljs-keyword">else</span>{                         dp[i][j]=dp[i-<span class="hljs-number">1</span>][j]+dp[i][j-<span class="hljs-number">1</span>];                    }                }                            }        }        <span class="hljs-keyword">return</span> dp[obstacleGrid.length-<span class="hljs-number">1</span>][obstacleGrid[<span class="hljs-number">0</span>].length-<span class="hljs-number">1</span>];    }}</code></pre></div><h5><span id="xu-lie-xing-dp"><strong>序列型DP</strong></span><a href="#xu-lie-xing-dp" class="header-anchor">#</a></h5><p><a href="https://www.motongxue.cn/posts/717263946/">D3-序列型动态规划</a></p><h5><span id="shuang-xu-lie-xing-dp"><strong>双序列型DP</strong></span><a href="#shuang-xu-lie-xing-dp" class="header-anchor">#</a></h5><p><a href="https://www.motongxue.cn/posts/1999848756/">D7-双序列型动态规划</a></p><h5><span id="hua-fen-xing-dp"><strong>划分型DP</strong></span><a href="#hua-fen-xing-dp" class="header-anchor">#</a></h5><p>常见类型：</p><div class="code-wrapper"><pre><code class="hljs css"><span class="hljs-number">1</span>. 给定长度为N的序列或字符串，要求划分成若干段   - 段数不限，或指定K段   - 每一段满足一定的性质<span class="hljs-number">2</span>. 做法   - 类似于序列型动态规划，但是通常要加上段数信息   - 一般用`f<span class="hljs-selector-attr">[i]</span><span class="hljs-selector-attr">[j]</span>`记录前<span class="hljs-selector-tag">i</span>个元素（元素<span class="hljs-number">0</span>~<span class="hljs-selector-tag">i</span>-<span class="hljs-number">1</span>）分成 j 段的性质，如最小代价</code></pre></div><p><a href="https://www.motongxue.cn/posts/2930816015/">D4 划分型动态规划</a></p><h5><span id="ji-yi-hua-sou-suo"><strong>记忆化搜索</strong></span><a href="#ji-yi-hua-sou-suo" class="header-anchor">#</a></h5><p><a href="https://oi-wiki.org/dp/memo/">记忆化搜索 - OI Wiki (oi-wiki.org)</a></p><h5><span id="qu-jian-xing-dp"><strong>区间型DP</strong></span><a href="#qu-jian-xing-dp" class="header-anchor">#</a></h5><p><a href="https://www.motongxue.cn/posts/1906695755/">D6-区间型动态规划</a></p><h5><span id="zhuang-tai-ya-suo-dp"><strong>状态压缩DP</strong></span><a href="#zhuang-tai-ya-suo-dp" class="header-anchor">#</a></h5><p><a href="https://oi-wiki.org/dp/state/">状压 DP - OI Wiki (oi-wiki.org)</a></p><h5><span id="bo-yi-xing-dp"><strong>博弈型DP</strong></span><a href="#bo-yi-xing-dp" class="header-anchor">#</a></h5><p><a href="https://www.motongxue.cn/posts/2506571106/">D4-博弈型动态规划</a></p><h5><span id="pi-pei-xing-dp"><strong>匹配型DP</strong></span><a href="#pi-pei-xing-dp" class="header-anchor">#</a></h5><h5><span id="shu-wei-dp">数位 DP</span><a href="#shu-wei-dp" class="header-anchor">#</a></h5><p><a href="https://oi-wiki.org/dp/number/">数位 DP - OI Wiki (oi-wiki.org)</a></p><h5><span id="shu-xing-dp"><strong>树形DP</strong></span><a href="#shu-xing-dp" class="header-anchor">#</a></h5><p><a href="https://oi-wiki.org/dp/tree/">树形 DP - OI Wiki (oi-wiki.org)</a></p><h5><span id="cha-tou-dp">插头 DP</span><a href="#cha-tou-dp" class="header-anchor">#</a></h5><p><a href="https://oi-wiki.org/dp/plug/">插头 DP - OI Wiki (oi-wiki.org)</a></p><h5><span id="gai-lu-dp">概率 DP</span><a href="#gai-lu-dp" class="header-anchor">#</a></h5><p><a href="https://oi-wiki.org/dp/probability/">概率 DP - OI Wiki (oi-wiki.org)</a></p><h5><span id="dong-tai-dp">动态 DP</span><a href="#dong-tai-dp" class="header-anchor">#</a></h5><p><a href="https://oi-wiki.org/dp/dynamic/">动态 DP - OI Wiki (oi-wiki.org)</a></p><h5><span id="pai-xu-suan-fa"><strong>排序算法</strong></span><a href="#pai-xu-suan-fa" class="header-anchor">#</a></h5><p><a href="https://oi-wiki.org/basic/sort-intro/">排序简介 - OI Wiki (oi-wiki.org)</a></p><h5><span id="wai-pai-xu-suan-fa"><strong>外排序算法</strong></span><a href="#wai-pai-xu-suan-fa" class="header-anchor">#</a></h5><p><a href="https://www.cnblogs.com/codeMedita/p/7425291.html">排序之外部排序 - Judy518 - 博客园 (cnblogs.com)</a></p><h5><span id="kuai-su-pai-xu-suan-fa"><strong>快速排序算法</strong></span><a href="#kuai-su-pai-xu-suan-fa" class="header-anchor">#</a></h5><p><a href="https://oi-wiki.org/basic/quick-sort/">快速排序 - OI Wiki (oi-wiki.org)</a></p><h5><span id="ou-la-lu-jing"><strong>欧拉路径</strong></span><a href="#ou-la-lu-jing" class="header-anchor">#</a></h5><blockquote><p>什么是欧拉路径？欧拉路径就是一条能够不重不漏地经过图上的每一条边的路径，即小学奥数中的一笔画问题。而若这条路径的起点和终点相同，则将这条路径称为欧拉回路。</p></blockquote><p><a href="https://www.cnblogs.com/TEoS/p/11376707.html">欧拉路径详解 - TEoS - 博客园 (cnblogs.com)</a></p><h5><span id="mo-ni-fa"><strong>模拟法</strong></span><a href="#mo-ni-fa" class="header-anchor">#</a></h5><p><a href="https://blog.csdn.net/qq_36257171/article/details/95651331">模拟算法（C++）_1只小弛的博客-CSDN博客_c++模拟</a></p><p><a href="https://www.cnblogs.com/wugu-2333/p/13439938.html">C++算法：模拟 - 无咕 - 博客园 (cnblogs.com)</a></p><h5><span id="sao-miao-xian-suan-fa"><strong>扫描线算法</strong></span><a href="#sao-miao-xian-suan-fa" class="header-anchor">#</a></h5><blockquote><p>扫描线是一种用于求矩阵面积并或者周长并的算法，可以使用 <code>线段树</code> 来优化。假设给定了平面上若干个可能相交的矩阵，需要求出它们的面积并（面积之和减去相交部分）或者周长并（外轮廓的长度）。我们可以虚拟出一条按顺序扫描整个平面的线段，通过对平行或垂直于 <em>[Math Processing Error]x</em> 轴的线段进行处理得到答案。</p></blockquote><p><a href="https://www.cnblogs.com/lingspace/p/scan-line.html">扫描线 - Ling_Lover - 博客园 (cnblogs.com)</a></p><h5><span id="mei-ju-fa"><strong>枚举法</strong></span><a href="#mei-ju-fa" class="header-anchor">#</a></h5><p><a href="https://www.cnblogs.com/jhpy/articles/11567665.html">枚举法 - Huise.J - 博客园 (cnblogs.com)</a></p><h5><span id="zui-duan-lu-jing"><strong>最短路径</strong></span><a href="#zui-duan-lu-jing" class="header-anchor">#</a></h5><p><a href="https://www.cnblogs.com/thousfeet/p/9229395.html">看完就懂了！一篇搞定图论最短路径问题 - thousfeet - 博客园 (cnblogs.com)</a></p><h5><span id="tan-xin-fa"><strong>贪心法</strong></span><a href="#tan-xin-fa" class="header-anchor">#</a></h5><p><a href="https://www.cnblogs.com/goWithHappy/p/greedy-algorithm.html">贪心算法原理及其应用 - vcjmhg - 博客园 (cnblogs.com)</a></p><h5><span id="zui-xiao-sheng-cheng-shu"><strong>最小生成树</strong></span><a href="#zui-xiao-sheng-cheng-shu" class="header-anchor">#</a></h5><p><a href="https://www.cnblogs.com/SeanOcean/p/10975694.html">最小生成树 - SeanOcean - 博客园 (cnblogs.com)</a></p><h5><span id="di-ke-si-te-la-suan-fa"><strong>狄克斯特拉算法</strong></span><a href="#di-ke-si-te-la-suan-fa" class="header-anchor">#</a></h5><p><a href="https://www.cnblogs.com/skywang12345/p/3711512.html">Dijkstra算法(一)之 C语言详解 - 如果天空不死 - 博客园 (cnblogs.com)</a></p><h5><span id="jin-si-suan-fa"><strong>近似算法</strong></span><a href="#jin-si-suan-fa" class="header-anchor">#</a></h5><p><a href="https://www.cnblogs.com/f91og/p/6257739.html">算法课堂笔记6—近似算法 - f91og - 博客园 (cnblogs.com)</a></p><h5><span id="gao-jing-du-ji-suan">高精度计算</span><a href="#gao-jing-du-ji-suan" class="header-anchor">#</a></h5><p><a href="https://www.cnblogs.com/wugu-2333/p/13436997.html">高精度计算</a></p><h5><span id="lru-suan-fa">LRU算法</span><a href="#lru-suan-fa" class="header-anchor">#</a></h5><blockquote><p>缓存淘汰算法</p><p>长期不被使用的数据，在未来被用到的几率也不大。如果缓存到达了预设值就要删除一些内容，给新的内容腾位置</p></blockquote><p><a href="https://www.cnblogs.com/kyoner/p/11179766.html">如何实现LRU算法？ - murphy_gb - 博客园 (cnblogs.com)</a></p><h5><span id="a-xing-xun-lu-suan-fa">A星寻路算法</span><a href="#a-xing-xun-lu-suan-fa" class="header-anchor">#</a></h5><p><a href="https://www.cnblogs.com/szmtjs10/p/15741514.html">A星寻路算法 - szmtjs10 - 博客园 (cnblogs.com)</a></p><p><a href="https://www.cnblogs.com/zhoug2020/p/3468167.html">A星寻路算法介绍 - 莫水千流 - 博客园 (cnblogs.com)</a></p><p><a href="https://zhuanlan.zhihu.com/p/385733813">A-Star（A*）寻路算法原理与实现 - 知乎 (zhihu.com)</a></p>]]></content>
    
    
    
    <tags>
      
      <tag>algorithms</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C++设计模式-创建型模式</title>
    <link href="/2021/12/27/C-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%88%9B%E5%BB%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F/"/>
    <url>/2021/12/27/C-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%88%9B%E5%BB%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<div class="toc"><!-- toc --><ul><li><a href="#fen-lei">分类</a><ul><li><a href="#chuang-jian-xing-mo-shi">创建型模式</a></li></ul></li></ul><!-- tocstop --></div><p>推荐看👉<a href="https://refactoringguru.cn/design-patterns">常用设计模式有哪些？ (refactoringguru.cn)</a></p><p>设计模式描述：</p><p>用特定的<code>套路</code>解决现实问题，每一个设计模式对应一个法子</p><h2><span id="fen-lei">分类</span><a href="#fen-lei" class="header-anchor">#</a></h2><p>根据意图或目的分类</p><ul><li><strong>创建型模式</strong>: 提供创建对象机制，增加已有的代码灵活性和可复用性</li><li><strong>结构型模式</strong>: 介绍如何将对象和类组装成较大的结构， 并同时保持结构的灵活和高效。</li><li><strong>行为模式</strong>: 负责对象间的高效沟通和职责委派。</li></ul><h3><span id="chuang-jian-xing-mo-shi">创建型模式</span><a href="#chuang-jian-xing-mo-shi" class="header-anchor">#</a></h3><h4><span id="simple-factory-pattern-jian-dan-gong-han"><strong>simple_factory_pattern(简单工厂)</strong></span><a href="#simple-factory-pattern-jian-dan-gong-han" class="header-anchor">#</a></h4><h4><span id="factory-method-gong-han-fang-fa"><strong>Factory Method(工厂方法)</strong></span><a href="#factory-method-gong-han-fang-fa" class="header-anchor">#</a></h4><blockquote><blockquote><p>在父类中提供一个创建对象的方法， 允许<code>子类决定实例化</code>对象的类型。</p></blockquote></blockquote><p>要解决的问题：</p><blockquote><blockquote><p>当增加一个新类，和其他类<code>低耦合</code></p></blockquote></blockquote><p>解决方案:</p><blockquote><blockquote><p>增加一个子类的抽象类，所有的子类继承于抽象类，并且写父类的实现</p></blockquote></blockquote><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><span class="hljs-keyword">class</span> <span class="hljs-title class_">product</span>{<span class="hljs-keyword">public</span>:    <span class="hljs-keyword">virtual</span> ~<span class="hljs-built_in">product</span>() {}};<span class="hljs-keyword">class</span> <span class="hljs-title class_">phone</span> : <span class="hljs-keyword">public</span> product{<span class="hljs-keyword">public</span>:    <span class="hljs-built_in">phone</span>()    {        std::cout &lt;&lt; <span class="hljs-string">"make phone"</span> &lt;&lt; std::endl;    }};<span class="hljs-keyword">class</span> <span class="hljs-title class_">tv</span> : <span class="hljs-keyword">public</span> product{<span class="hljs-keyword">public</span>:    <span class="hljs-built_in">tv</span>()    {        std::cout &lt;&lt; <span class="hljs-string">"make tv"</span> &lt;&lt; std::endl;    }};<span class="hljs-keyword">class</span> <span class="hljs-title class_">factory</span>{<span class="hljs-keyword">public</span>:    <span class="hljs-keyword">virtual</span> ~<span class="hljs-built_in">factory</span>() {}    <span class="hljs-function"><span class="hljs-keyword">virtual</span> product* <span class="hljs-title">make_product</span><span class="hljs-params">()</span> </span>= <span class="hljs-number">0</span>; };<span class="hljs-keyword">class</span> <span class="hljs-title class_">phone_factory</span> : <span class="hljs-keyword">public</span> factory{<span class="hljs-keyword">public</span>:    <span class="hljs-function"><span class="hljs-keyword">virtual</span> product* <span class="hljs-title">make_product</span><span class="hljs-params">()</span></span><span class="hljs-function">    </span>{        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">phone</span>();    }};<span class="hljs-keyword">class</span> <span class="hljs-title class_">tv_factory</span> : <span class="hljs-keyword">public</span> factory{<span class="hljs-keyword">public</span>:    <span class="hljs-function"><span class="hljs-keyword">virtual</span> product* <span class="hljs-title">make_product</span><span class="hljs-params">()</span></span><span class="hljs-function">    </span>{        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">tv</span>();    }};<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>{    factory* factory1 = <span class="hljs-keyword">new</span> <span class="hljs-built_in">phone_factory</span>();    product* product1 = factory1-&gt;<span class="hljs-built_in">make_product</span>();    factory* factory2 = <span class="hljs-keyword">new</span> <span class="hljs-built_in">tv_factory</span>();    product* product2 = factory2-&gt;<span class="hljs-built_in">make_product</span>();    <span class="hljs-keyword">delete</span> factory1;    <span class="hljs-keyword">delete</span> product1;    <span class="hljs-keyword">delete</span> factory2;    <span class="hljs-keyword">delete</span> product2;        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;}</code></pre></div><h4><span id="abstract-factory-chou-xiang-gong-han-mo-shi">Abstract Factory(抽象工厂模式)</span><a href="#abstract-factory-chou-xiang-gong-han-mo-shi" class="header-anchor">#</a></h4><blockquote><blockquote><p>随着业务的发展，更多的类需要创建，比如<strong>美国工厂，欧洲工厂，亚洲工厂，南美工厂</strong>，每个地区工厂又需要<strong>创建各自的产品</strong></p></blockquote></blockquote><p>问题：</p><blockquote><blockquote><p>每个地区生产的产品拥有一个风格，不同地区的产品混杂一起对顾客不友好</p><p>保持核心代码不修改。</p></blockquote></blockquote><p>解决：</p><blockquote><blockquote><p>首先， 抽象工厂模式建议为系列中的每件产品明确声明接口 （例如phone、 tv）。 然后， 确保所有产品变体都继承这些接口。 例如， 所有风格的椅子都实现 <code>phone</code>接口； 所有风格的咖啡桌都实现 <code>tv</code>接口， 以此类推。</p></blockquote></blockquote><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><span class="hljs-comment">// 食草动物.</span><span class="hljs-keyword">class</span> <span class="hljs-title class_">herbivore</span>{<span class="hljs-keyword">public</span>:    <span class="hljs-keyword">virtual</span> ~<span class="hljs-built_in">herbivore</span>() {}};<span class="hljs-comment">// 食肉动物.</span><span class="hljs-keyword">class</span> <span class="hljs-title class_">carnivore</span>{<span class="hljs-keyword">public</span>:    <span class="hljs-keyword">virtual</span> ~<span class="hljs-built_in">carnivore</span>() {}    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">eat</span><span class="hljs-params">(herbivore* h)</span> </span>= <span class="hljs-number">0</span>;};<span class="hljs-comment">// 角马.</span><span class="hljs-keyword">class</span> <span class="hljs-title class_">wildebeest</span> : <span class="hljs-keyword">public</span> herbivore{};<span class="hljs-comment">// 野牛.</span><span class="hljs-keyword">class</span> <span class="hljs-title class_">bison</span> : <span class="hljs-keyword">public</span> herbivore{};<span class="hljs-comment">// 狮子.</span><span class="hljs-keyword">class</span> <span class="hljs-title class_">lion</span> : <span class="hljs-keyword">public</span> carnivore{<span class="hljs-keyword">public</span>:    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">eat</span><span class="hljs-params">(herbivore*)</span></span><span class="hljs-function">    </span>{        std::cout &lt;&lt; <span class="hljs-string">"lion eat wildebeest"</span> &lt;&lt; std::endl;    }};<span class="hljs-comment">// 狼.</span><span class="hljs-keyword">class</span> <span class="hljs-title class_">wolf</span> : <span class="hljs-keyword">public</span> carnivore{<span class="hljs-keyword">public</span>:    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">eat</span><span class="hljs-params">(herbivore*)</span></span><span class="hljs-function">    </span>{        std::cout &lt;&lt; <span class="hljs-string">"wolf eat bison"</span> &lt;&lt; std::endl;    }};<span class="hljs-comment">// 抽象工厂.</span><span class="hljs-keyword">class</span> <span class="hljs-title class_">factory</span>{<span class="hljs-keyword">public</span>:    <span class="hljs-keyword">virtual</span> ~<span class="hljs-built_in">factory</span>() {}    <span class="hljs-comment">// 创建食草动物.</span>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> herbivore* <span class="hljs-title">create_herbivore</span><span class="hljs-params">()</span> </span>= <span class="hljs-number">0</span>;    <span class="hljs-comment">// 创建食肉动物.</span>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> carnivore* <span class="hljs-title">create_carnivore</span><span class="hljs-params">()</span> </span>= <span class="hljs-number">0</span>;};<span class="hljs-comment">// 非洲工厂.</span><span class="hljs-keyword">class</span> <span class="hljs-title class_">africa_factory</span> : <span class="hljs-keyword">public</span> factory{<span class="hljs-keyword">public</span>:    <span class="hljs-function"><span class="hljs-keyword">virtual</span> herbivore* <span class="hljs-title">create_herbivore</span><span class="hljs-params">()</span></span><span class="hljs-function">    </span>{        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">wildebeest</span>();    }    <span class="hljs-function"><span class="hljs-keyword">virtual</span> carnivore* <span class="hljs-title">create_carnivore</span><span class="hljs-params">()</span></span><span class="hljs-function">    </span>{        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">lion</span>();    }};<span class="hljs-comment">// 美洲工厂.</span><span class="hljs-keyword">class</span> <span class="hljs-title class_">america_factory</span> : <span class="hljs-keyword">public</span> factory{<span class="hljs-keyword">public</span>:    <span class="hljs-function"><span class="hljs-keyword">virtual</span> herbivore* <span class="hljs-title">create_herbivore</span><span class="hljs-params">()</span></span><span class="hljs-function">    </span>{        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">bison</span>();    }    <span class="hljs-function"><span class="hljs-keyword">virtual</span> carnivore* <span class="hljs-title">create_carnivore</span><span class="hljs-params">()</span></span><span class="hljs-function">    </span>{        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">wolf</span>();    }};<span class="hljs-comment">// 动物世界（客户端）.</span><span class="hljs-keyword">class</span> <span class="hljs-title class_">animal_world</span>{<span class="hljs-keyword">public</span>:    <span class="hljs-built_in">animal_world</span>(factory* f)    {        _herbivore = f-&gt;<span class="hljs-built_in">create_herbivore</span>();         _carnivore = f-&gt;<span class="hljs-built_in">create_carnivore</span>();    }    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">start</span><span class="hljs-params">()</span></span><span class="hljs-function">    </span>{        _carnivore-&gt;<span class="hljs-built_in">eat</span>(_herbivore);    }<span class="hljs-keyword">private</span>:    herbivore* _herbivore;    carnivore* _carnivore;};<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>{    factory* factory1 = <span class="hljs-keyword">new</span> <span class="hljs-built_in">africa_factory</span>();    animal_world* world1 = <span class="hljs-keyword">new</span> <span class="hljs-built_in">animal_world</span>(factory1);    world1-&gt;<span class="hljs-built_in">start</span>();    factory* factory2 = <span class="hljs-keyword">new</span> <span class="hljs-built_in">america_factory</span>();    animal_world* world2 = <span class="hljs-keyword">new</span> <span class="hljs-built_in">animal_world</span>(factory2);    world2-&gt;<span class="hljs-built_in">start</span>();    <span class="hljs-keyword">delete</span> factory1;    <span class="hljs-keyword">delete</span> world1;    <span class="hljs-keyword">delete</span> factory2;    <span class="hljs-keyword">delete</span> world2;    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;}</code></pre></div><h4><span id="singletonton-pattern-dan-li-mo-shi">singletonton_pattern(单例模式)</span><a href="#singletonton-pattern-dan-li-mo-shi" class="header-anchor">#</a></h4><blockquote><blockquote><p>保证一个类<strong>只有一个实例</strong>， 并提供一个访问该<strong>实例的全局节点</strong>。</p></blockquote></blockquote><p>问题：</p><blockquote><blockquote><p>同时解决了两个问题, 但违反了单一职责原则</p></blockquote></blockquote><p>解决：</p><blockquote><blockquote><ul><li><p>将默认构造函数设为私有， 防止其他对象使用单例类的 <code>new</code>运算符。</p></li><li><p>新建一个静态构建方法作为构造函数。 该函数会 “偷偷” 调用私有构造函数来创建对象， 并将其保存在一个静态成员变量中。 此后所有对于该函数的调用都将返回这一缓存对象。</p></li></ul></blockquote></blockquote><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><span class="hljs-keyword">class</span> <span class="hljs-title class_">singleton</span>{<span class="hljs-keyword">public</span>:    <span class="hljs-built_in">singleton</span>() = <span class="hljs-keyword">default</span>;    <span class="hljs-built_in">singleton</span>(<span class="hljs-type">const</span> singleton&amp;) = <span class="hljs-keyword">delete</span>;    singleton&amp; <span class="hljs-keyword">operator</span>=(<span class="hljs-type">const</span> singleton&amp;) = <span class="hljs-keyword">delete</span>;    <span class="hljs-function"><span class="hljs-type">static</span> singleton&amp; <span class="hljs-title">get_instance</span><span class="hljs-params">()</span></span><span class="hljs-function">    </span>{        <span class="hljs-type">static</span> singleton s;        <span class="hljs-keyword">return</span> s;    }    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">print</span><span class="hljs-params">()</span></span><span class="hljs-function">    </span>{        std::cout &lt;&lt; <span class="hljs-string">"Hello world"</span> &lt;&lt; std::endl;    }};<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>{    singleton::<span class="hljs-built_in">get_instance</span>().<span class="hljs-built_in">print</span>();    singleton::<span class="hljs-built_in">get_instance</span>().<span class="hljs-built_in">print</span>();    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;}</code></pre></div><h4><span id="prototype-pattern-yuan-xing-mo-shi">prototype_pattern(原型模式)</span><a href="#prototype-pattern-yuan-xing-mo-shi" class="header-anchor">#</a></h4><blockquote><blockquote><p>使你能够复制已有对象， 而又无需使代码依赖它们所属的类。</p></blockquote></blockquote><p>问题：</p><blockquote><blockquote><p>如果你有一个对象， 并希望生成与其完全相同的一个复制品， 你该如何实现呢？ 首先， 你必须新建一个属于相同类的对象。 然后， 你必须遍历原始对象的所有成员变量， 并将成员变量值复制到新对象中。</p><p>不错！ 但有个小问题。 并非所有对象都能通过这种方式进行复制， 因为有些对象可能拥有私有成员变量， 它们在对象本身以外是不可见的。</p></blockquote><p>直接复制还有另外一个问题。 因为你必须知道对象所属的类才能创建复制品， 所以代码必须依赖该类。 即使你可以接受额外的依赖性， 那还有另外一个问题： 有时你只知道对象所实现的接口， 而不知道其所属的具体类， 比如可向方法的某个参数传入实现了某个接口的任何对象。</p></blockquote><p>解决：</p><blockquote><blockquote><p>原型模式将克隆过程委派给被克隆的实际对象。 模式为所有支持克隆的对象声明了一个通用接口， 该接口让你能够克隆对象， 同时又无需将代码和对象所属类耦合。 通常情况下， 这样的接口中仅包含一个 <code>克隆</code>方法。</p><p>所有的类对 <code>克隆</code>方法的实现都非常相似。 该方法会创建一个当前类的对象， 然后将原始对象所有的成员变量值复制到新建的类中。 你甚至可以复制私有成员变量， 因为绝大部分编程语言都允许对象访问其同类对象的私有成员变量。</p><p>支持克隆的对象即为<em>原型</em>。 当你的对象有几十个成员变量和几百种类型时， 对其进行克隆甚至可以代替子类的构造。</p></blockquote><blockquote><p>其运作方式如下： 创建一系列不同类型的对象并不同的方式对其进行配置。 如果所需对象与预先配置的对象相同， 那么你只需克隆原型即可， 无需新建一个对象。</p></blockquote></blockquote><blockquote><p>可以类比<strong>有丝分裂</strong>：由于工业原型并不是真正意义上的自我复制， 因此细胞有丝分裂 （还记得生物学知识吗？） 或许是更恰当的类比。 有丝分裂会产生一对完全相同的细胞。 原始细胞就是一个原型， 它在复制体的生成过程中起到了推动作用。</p></blockquote><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span><span class="hljs-comment">// #include &lt;vector&gt;</span><span class="hljs-keyword">class</span> <span class="hljs-title class_">resume</span>{<span class="hljs-keyword">public</span>:    <span class="hljs-built_in">resume</span>() {}    <span class="hljs-keyword">virtual</span> ~<span class="hljs-built_in">resume</span>() {}    <span class="hljs-function"><span class="hljs-keyword">virtual</span> resume* <span class="hljs-title">clone</span><span class="hljs-params">()</span> </span>{ <span class="hljs-keyword">return</span> <span class="hljs-literal">nullptr</span>; }    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">set</span><span class="hljs-params">(<span class="hljs-type">char</span>*)</span> </span>{}    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">show</span><span class="hljs-params">()</span> </span>{}<span class="hljs-keyword">protected</span>:    <span class="hljs-type">char</span>* _name = <span class="hljs-literal">nullptr</span>;};<span class="hljs-keyword">class</span> <span class="hljs-title class_">resume_a</span> : <span class="hljs-keyword">public</span> resume{<span class="hljs-keyword">public</span>:    <span class="hljs-built_in">resume_a</span>(<span class="hljs-type">const</span> <span class="hljs-type">char</span>* str)    {        <span class="hljs-keyword">if</span> (str == <span class="hljs-literal">nullptr</span>)        {            _name = <span class="hljs-keyword">new</span> <span class="hljs-type">char</span>[<span class="hljs-number">1</span>];            _name[<span class="hljs-number">0</span>] = <span class="hljs-string">'\0'</span>;        }        <span class="hljs-keyword">else</span>        {            _name = <span class="hljs-keyword">new</span> <span class="hljs-type">char</span>[<span class="hljs-built_in">strlen</span>(str) + <span class="hljs-number">1</span>];            <span class="hljs-built_in">strcpy</span>(_name, str);        }    }    ~<span class="hljs-built_in">resume_a</span>()    {        <span class="hljs-keyword">if</span> (_name != <span class="hljs-literal">nullptr</span>)        {            <span class="hljs-keyword">delete</span> [] _name;            _name = <span class="hljs-literal">nullptr</span>;        }    }    <span class="hljs-built_in">resume_a</span>(<span class="hljs-type">const</span> resume_a&amp; other)    {        <span class="hljs-keyword">if</span> (_name != <span class="hljs-literal">nullptr</span>)        {            <span class="hljs-keyword">delete</span> [] _name;            _name = <span class="hljs-literal">nullptr</span>;        }        _name = <span class="hljs-keyword">new</span> <span class="hljs-type">char</span>[<span class="hljs-built_in">strlen</span>(other._name) + <span class="hljs-number">1</span>];        <span class="hljs-built_in">strcpy</span>(_name, other._name);    }    <span class="hljs-function"><span class="hljs-keyword">virtual</span> resume_a* <span class="hljs-title">clone</span><span class="hljs-params">()</span></span><span class="hljs-function">    </span>{        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">resume_a</span>(*<span class="hljs-keyword">this</span>);    }    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">show</span><span class="hljs-params">()</span></span><span class="hljs-function">    </span>{        std::cout &lt;&lt; <span class="hljs-string">"resume_a name: "</span> &lt;&lt; _name &lt;&lt; std::endl;    }};<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>{    resume* r1 = <span class="hljs-keyword">new</span> <span class="hljs-built_in">resume_a</span>(<span class="hljs-string">"A"</span>);    resume* r2 = r1-&gt;<span class="hljs-built_in">clone</span>();    r1-&gt;<span class="hljs-built_in">show</span>();    <span class="hljs-keyword">delete</span> r1;    r2-&gt;<span class="hljs-built_in">show</span>();    <span class="hljs-keyword">delete</span> r2;    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;}</code></pre></div><h4><span id="builder-pattern-sheng-cheng-qi-mo-shi">builder_pattern(生成器模式)</span><a href="#builder-pattern-sheng-cheng-qi-mo-shi" class="header-anchor">#</a></h4><blockquote><blockquote><p>使你能够分步骤创建复杂对象。 该模式允许你使用相同的创建代码生成不同类型和形式的对象。</p></blockquote></blockquote><p>问题：</p><blockquote><blockquote><p>假设有这样一个复杂对象， 在对其进行构造时需要对诸多成员变量和嵌套对象进行繁复的初始化工作。 这些初始化代码通常深藏于一个包含众多参数且让人基本看不懂的构造函数中； 甚至还有更糟糕的情况， 那就是这些代码散落在客户端代码的多个位置。<br>例如， 我们来思考如何创建一个 房屋House对象。 建造一栋简单的房屋， 首先你需要建造四面墙和地板， 安装房门和一套窗户， 然后再建造一个屋顶。 但是如果你想要一栋更宽敞更明亮的房屋， 还要有院子和其他设施 （例如暖气、 排水和供电设备）， 那又该怎么办呢？</p></blockquote></blockquote><p>最简单的方法是扩展 房屋基类， 然后创建一系列涵盖所有参数组合的子类。 但最终你将面对相当数量的子类。 任何新增的参数 （例如门廊类型） 都会让这个层次结构更加复杂。</p><p>另一种方法则无需生成子类。 你可以在 房屋基类中创建一个包括所有可能参数的超级构造函数， 并用它来控制房屋对象。 这种方法确实可以避免生成子类， 但它却会造成另外一个问题。<br>通常情况下， 绝大部分的参数都没有使用， 这使得对于构造函数的调用十分不简洁。 例如， 只有很少的房子有游泳池， 因此与游泳池相关的参数十之八九是毫无用处的。</p><p>解决：</p><blockquote><blockquote><p>生成器模式建议将对象构造代码从产品类中抽取出来， 并将其放在一个名为生成器的独立对象中。<br>该模式会将对象构造过程划分为一组步骤， 比如 build­Walls创建墙壁和 build­Door创建房门创建房门等。 每次创建对象时， 你都需要通过生成器对象执行一系列步骤。 重点在于你无需调用所有步骤， 而只需调用创建特定对象配置所需的那些步骤即可。</p></blockquote></blockquote><p>当你需要创建不同形式的产品时， 其中的一些构造步骤可能需要不同的实现。 例如， 木屋的房门可能需要使用木头制造， 而城堡的房门则必须使用石头制造。</p><p>在这种情况下， 你可以创建多个不同的生成器， 用不同方式实现一组相同的创建步骤。 然后你就可以在创建过程中使用这些生成器 （例如按顺序调用多个构造步骤） 来生成不同类型的对象。</p><blockquote><blockquote><p>例如， 假设第一个建造者使用木头和玻璃制造房屋， 第二个建造者使用石头和钢铁， 而第三个建造者使用黄金和钻石。 在调用同一组步骤后， 第一个建造者会给你一栋普通房屋， 第二个会给你一座小城堡， 而第三个则会给你一座宫殿。 但是， 只有在调用构造步骤的客户端代码可以通过通用接口与建造者进行交互时， 这样的调用才能返回需要的房屋。<br><strong>主管</strong><br>你可以进一步将用于创建产品的一系列生成器步骤调用抽取成为单独的主管类。 主管类可定义创建步骤的执行顺序， 而生成器则提供这些步骤的实现。</p></blockquote></blockquote><blockquote><blockquote><p>严格来说， 你的程序中并不一定需要主管类。 客户端代码可直接以特定顺序调用创建步骤。 不过， 主管类中非常适合放入各种例行构造流程， 以便在程序中反复使用。</p></blockquote></blockquote><p>此外， 对于客户端代码来说， 主管类完全隐藏了产品构造细节。 客户端只需要将一个生成器与主管类关联， 然后使用主管类来构造产品， 就能从生成器处获得构造结果了。</p><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><span class="hljs-comment">// 产品.</span><span class="hljs-keyword">class</span> <span class="hljs-title class_">product</span>{<span class="hljs-keyword">public</span>:    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-type">const</span> std::string&amp; product_name)</span></span><span class="hljs-function">    </span>{        _product_name_vec.<span class="hljs-built_in">emplace_back</span>(product_name);    }    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">show</span><span class="hljs-params">()</span></span><span class="hljs-function">    </span>{        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span>&amp; name : _product_name_vec)        {            std::cout &lt;&lt; name &lt;&lt; std::endl;        }    }<span class="hljs-keyword">private</span>:    std::vector&lt;std::string&gt; _product_name_vec;};<span class="hljs-comment">// 抽象建造者.</span><span class="hljs-keyword">class</span> <span class="hljs-title class_">builder</span>{<span class="hljs-keyword">public</span>:    <span class="hljs-keyword">virtual</span> ~<span class="hljs-built_in">builder</span>() {}    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">build_ricenoodles</span><span class="hljs-params">()</span> </span>= <span class="hljs-number">0</span>;    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">build_cooldish</span><span class="hljs-params">()</span> </span>= <span class="hljs-number">0</span>;    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">build_drink</span><span class="hljs-params">()</span> </span>= <span class="hljs-number">0</span>;    <span class="hljs-function"><span class="hljs-keyword">virtual</span> product* <span class="hljs-title">get_product</span><span class="hljs-params">()</span> </span>= <span class="hljs-number">0</span>;};<span class="hljs-comment">// 建造者A.</span><span class="hljs-keyword">class</span> <span class="hljs-title class_">builder_a</span> : <span class="hljs-keyword">public</span> builder{<span class="hljs-keyword">public</span>:    <span class="hljs-built_in">builder_a</span>()    {        _product = <span class="hljs-keyword">new</span> product;    }    ~<span class="hljs-built_in">builder_a</span>()    {        <span class="hljs-keyword">delete</span> _product;    }    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">build_ricenoodles</span><span class="hljs-params">()</span></span><span class="hljs-function">    </span>{        _product-&gt;<span class="hljs-built_in">add</span>(<span class="hljs-string">"ricenoodles a"</span>);    }    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">build_cooldish</span><span class="hljs-params">()</span></span><span class="hljs-function">    </span>{        _product-&gt;<span class="hljs-built_in">add</span>(<span class="hljs-string">"cooldish a"</span>);    }    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">build_drink</span><span class="hljs-params">()</span></span><span class="hljs-function">    </span>{        _product-&gt;<span class="hljs-built_in">add</span>(<span class="hljs-string">"drink a"</span>);    }    <span class="hljs-function"><span class="hljs-keyword">virtual</span> product* <span class="hljs-title">get_product</span><span class="hljs-params">()</span></span><span class="hljs-function">    </span>{        <span class="hljs-keyword">return</span> _product;    }<span class="hljs-keyword">private</span>:    product* _product;};<span class="hljs-comment">// 导演.</span><span class="hljs-keyword">class</span> <span class="hljs-title class_">director</span>{<span class="hljs-keyword">public</span>:    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">construct</span><span class="hljs-params">(builder* b)</span></span><span class="hljs-function">    </span>{        b-&gt;<span class="hljs-built_in">build_ricenoodles</span>();        b-&gt;<span class="hljs-built_in">build_cooldish</span>();        b-&gt;<span class="hljs-built_in">build_drink</span>();    }};<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>{    director* d = <span class="hljs-keyword">new</span> <span class="hljs-built_in">director</span>();    builder* b = <span class="hljs-keyword">new</span> <span class="hljs-built_in">builder_a</span>();    d-&gt;<span class="hljs-built_in">construct</span>(b);    product* p = b-&gt;<span class="hljs-built_in">get_product</span>();    p-&gt;<span class="hljs-built_in">show</span>();    <span class="hljs-keyword">delete</span> b;    <span class="hljs-keyword">delete</span> d;    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;}</code></pre></div>]]></content>
    
    
    
    <tags>
      
      <tag>设计模式</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>gdb代码调试工具</title>
    <link href="/2021/12/26/gdb%E4%BB%A3%E7%A0%81%E8%B0%83%E8%AF%95%E5%B7%A5%E5%85%B7/"/>
    <url>/2021/12/26/gdb%E4%BB%A3%E7%A0%81%E8%B0%83%E8%AF%95%E5%B7%A5%E5%85%B7/</url>
    
    <content type="html"><![CDATA[<div class="toc"><!-- toc --><ul><li><a href="#1-linux-xia-an-zhuang-er-jin-zhi-ban-gdb-diao-shi-qi">1. Linux下安装二进制版GDB调试器</a></li><li><a href="#2-yuan-ma-an-zhuang-xia-zai">2. 源码安装下载：</a></li><li><a href="#3-diao-shi-zhun-bei">3. 调试准备</a></li><li><a href="#zhi-shi-wei-liao-diao-shi-dai-ma-xu-yao-zai-bian-yi-shi-jia-ru-g-can-shu-guan-diao-bian-yi-qi-you-hua-can-shu-o0-da-kai-suo-you-warning-wall">只是为了调试代码需要在编译时加入：-g参数，关掉编译器优化参数：-O0，打开所有 warning：-Wall</a></li><li><a href="#4-gdb-de-qi-dong-yu-tui-chu">4. GDB的启动与退出</a></li><li><a href="#5-cha-kan-dai-ma">5. 查看代码</a></li><li><a href="#6-duan-dian-cao-zuo">6.断点操作</a></li><li><a href="#7-diao-shi-ming-ling">7.调试命令</a></li></ul><!-- tocstop --></div><p>GDB是是 Linux 平台下最常用的一款程序调试器，通常服务于终端下，无GUI。Linux下很多IDE的调试能力源于GDB调试器</p><h3><span id="1-linux-xia-an-zhuang-er-jin-zhi-ban-gdb-diao-shi-qi">1. Linux下安装二进制版GDB调试器</span><a href="#1-linux-xia-an-zhuang-er-jin-zhi-ban-gdb-diao-shi-qi" class="header-anchor">#</a></h3><p>centos下命令：</p><div class="code-wrapper"><pre><code class="hljs C++">sudo yum -y install gdb</code></pre></div><p>Ubuntu下安装命令：</p><div class="code-wrapper"><pre><code class="hljs c++">sudo apt -y install gdb</code></pre></div><h3><span id="2-yuan-ma-an-zhuang-xia-zai">2. 源码安装下载：</span><a href="#2-yuan-ma-an-zhuang-xia-zai" class="header-anchor">#</a></h3><div class="code-wrapper"><pre><code class="hljs c++">sudo wget http:<span class="hljs-comment">//ftp.gnu.org/gnu/gdb/gdb-11.1.tar.xz</span></code></pre></div><p>解压：</p><div class="code-wrapper"><pre><code class="hljs c++">tar -zxvf gdb<span class="hljs-number">-11.1</span>.tar.xz</code></pre></div><p>进入源码目录安装：</p><div class="code-wrapper"><pre><code class="hljs c++">./configuremakesudo make install</code></pre></div><h3><span id="3-diao-shi-zhun-bei">3. 调试准备</span><a href="#3-diao-shi-zhun-bei" class="header-anchor">#</a></h3><p>GDB supports the following languages (in alphabetical order):</p><ul><li>Ada</li><li>Assembly</li><li>C</li><li>C++</li><li>D</li><li>Fortran</li><li>Go</li><li>Objective-C</li><li>OpenCL</li><li>Modula-2</li><li>Pascal</li><li>Rust</li></ul><h3><span id="zhi-shi-wei-liao-diao-shi-dai-ma-xu-yao-zai-bian-yi-shi-jia-ru-g-can-shu-guan-diao-bian-yi-qi-you-hua-can-shu-o0-da-kai-suo-you-warning-wall">只是为了调试代码需要在编译时加入：-g参数，关掉编译器优化参数：-O0，打开所有 warning：-Wall</span><a href="#zhi-shi-wei-liao-diao-shi-dai-ma-xu-yao-zai-bian-yi-shi-jia-ru-g-can-shu-guan-diao-bian-yi-qi-you-hua-can-shu-o0-da-kai-suo-you-warning-wall" class="header-anchor">#</a></h3><h3><span id="4-gdb-de-qi-dong-yu-tui-chu">4. GDB的启动与退出</span><a href="#4-gdb-de-qi-dong-yu-tui-chu" class="header-anchor">#</a></h3><p>启动gdb调试<br>gdb 可执行程序文件名</p><div class="code-wrapper"><pre><code class="hljs bash">(gdb) gdb app</code></pre></div><p>退出调试</p><div class="code-wrapper"><pre><code class="hljs bash">quit = q(gdb) q</code></pre></div><h4><span id="ming-ling-xing-chuan-can-show-args">命令行传参:show args</span><a href="#ming-ling-xing-chuan-can-show-args" class="header-anchor">#</a></h4><p>设置的时机: 启动gdb之后, 在应用程序启动之前</p><div class="code-wrapper"><pre><code class="hljs bash">(gdb) <span class="hljs-built_in">set</span> args 参数1 参数2 …. …</code></pre></div><p>查看设置的命令行参数</p><div class="code-wrapper"><pre><code class="hljs shell">(gdb) show args</code></pre></div><p>例子：<br>非gdb调试命令行传参</p><div class="code-wrapper"><pre><code class="hljs c++">argc 参数总个数，argv[<span class="hljs-number">0</span>] == ./app， argv[<span class="hljs-number">1</span>] == <span class="hljs-string">"11"</span>  argv[<span class="hljs-number">2</span>] == <span class="hljs-string">"22"</span> argv[<span class="hljs-number">3</span>] == <span class="hljs-string">"33"</span>  argv[<span class="hljs-number">4</span>] == <span class="hljs-string">"44"</span> argv[<span class="hljs-number">5</span>] == <span class="hljs-string">"55"</span>./app <span class="hljs-number">11</span> <span class="hljs-number">22</span> <span class="hljs-number">33</span> <span class="hljs-number">44</span> <span class="hljs-number">55</span></code></pre></div><p>使用 gdb 调试</p><div class="code-wrapper"><pre><code class="hljs shell">gdb app(gdb) set args 11 22 33 44 55</code></pre></div><p>查看设置的命令行参数</p><div class="code-wrapper"><pre><code class="hljs shell">(gdb) show argsArgument list to give program being debugged when it is started is "11 22 33 44 55".</code></pre></div><h4><span id="gdb-zhong-qi-dong-cheng-xu">gdb 中启动程序</span><a href="#gdb-zhong-qi-dong-cheng-xu" class="header-anchor">#</a></h4><p><strong>run</strong>: 缩写为 r,停在第一个断点的位置，如果没有设置断点，程序就执行完了<br><strong>start</strong>: 启动程序，阻塞在 main 函数的第一行，等待输入后续其它 gdb 指令</p><p>例子：</p><div class="code-wrapper"><pre><code class="hljs bash">&gt;<span class="hljs-comment"># 两种方式</span><span class="hljs-comment"># 方式1: run == r</span>(gdb) run         (如果有断点会停在断点处)<span class="hljs-comment"># 方式2: start    (会停在main函数处)</span>(gdb) start</code></pre></div><p>继续运行：</p><div class="code-wrapper"><pre><code class="hljs bash"><span class="hljs-comment"># quit == q</span>(gdb) qui</code></pre></div><h3><span id="5-cha-kan-dai-ma">5. 查看代码</span><a href="#5-cha-kan-dai-ma" class="header-anchor">#</a></h3><p>查看代码的命令叫做 <code>list</code> 可以缩写为 l，此命令可以通过行号，函数名查看，也可以查看不同文件的信息</p><p>如果不切换文件会停在main函数所在文件</p><h4><span id="dang-qian-wen-jian">当前文件</span><a href="#dang-qian-wen-jian" class="header-anchor">#</a></h4><div class="code-wrapper"><pre><code class="hljs bash">从第一行开始显示(gdb) l默认只显示10行内容，上下文(gdb) l 行号显示这个函数的上下文内容, 默认显示10行(gdb) l 函数名</code></pre></div><h4><span id="qie-huan-wen-jian">切换文件</span><a href="#qie-huan-wen-jian" class="header-anchor">#</a></h4><div class="code-wrapper"><pre><code class="hljs bash">切到指定文件行号处，默认显示10行(gdb) l 文件名:行号切到指定文件函数处，默认显示10行(gdb) l 文件名:函数名</code></pre></div><h4><span id="she-zhi-mo-ren-xian-shi-de-xing-shu">设置默认显示的行数</span><a href="#she-zhi-mo-ren-xian-shi-de-xing-shu" class="header-anchor">#</a></h4><div class="code-wrapper"><pre><code class="hljs bash"><span class="hljs-comment"># 以下两个命令中的 listsize 都可以写成 list</span>(gdb) <span class="hljs-built_in">set</span> listsize 行数<span class="hljs-comment"># 查看当前list一次显示的行数</span>(gdb) show listsize</code></pre></div><h3><span id="6-duan-dian-cao-zuo">6.断点操作</span><a href="#6-duan-dian-cao-zuo" class="header-anchor">#</a></h3><h4><span id="she-zhi-duan-dian">设置断点</span><a href="#she-zhi-duan-dian" class="header-anchor">#</a></h4><p>断点设置有两个方式：常规断点：程序只要运行到这个位置就会被阻塞</p><p>条件断点：条件被满足了程序才会在断点处阻塞。</p><h5><span id="dang-qian-wen-jian">当前文件：</span><a href="#dang-qian-wen-jian" class="header-anchor">#</a></h5><div class="code-wrapper"><pre><code class="hljs bash"><span class="hljs-comment"># 在当前文件的某一行上设置断点</span><span class="hljs-comment"># break == b</span>(gdb) b 行号(gdb) b 函数名<span class="hljs-comment"># 停止在函数的第一行</span></code></pre></div><h5><span id="fei-dang-qian-wen-jian">非当前文件：</span><a href="#fei-dang-qian-wen-jian" class="header-anchor">#</a></h5><div class="code-wrapper"><pre><code class="hljs bash"><span class="hljs-comment"># 在非当前文件的某一行上设置断点</span>(gdb) b 文件名:行号(gdb) b 文件名:函数名<span class="hljs-comment"># 停止在函数的第一行</span></code></pre></div><h5><span id="she-zhi-tiao-jian-duan-dian">设置条件断点</span><a href="#she-zhi-tiao-jian-duan-dian" class="header-anchor">#</a></h5><div class="code-wrapper"><pre><code class="hljs bash"><span class="hljs-comment"># 必须要满足某个条件, 程序才会停在这个断点的位置上</span><span class="hljs-comment"># 通常情况下, 在循环中条件断点用的比较多</span>(gdb) b 行数 <span class="hljs-keyword">if</span> 变量名==某个值</code></pre></div><h4><span id="cha-kan-duan-dian">查看断点</span><a href="#cha-kan-duan-dian" class="header-anchor">#</a></h4><div class="code-wrapper"><pre><code class="hljs bash"><span class="hljs-comment"># 查看设置的断点信息</span>(gdb) i b   <span class="hljs-comment">#info break</span><span class="hljs-comment"># 举例</span>(gdb) i bNum     Type           Disp Enb Address              What1       breakpoint     keep y   0x0000000000400cb5 <span class="hljs-keyword">in</span> main() at test.cpp:122       breakpoint     keep y   0x0000000000400cbd <span class="hljs-keyword">in</span> main() at test.cpp:133       breakpoint     keep y   0x0000000000400cec <span class="hljs-keyword">in</span> main() at test.cpp:184       breakpoint     keep y   0x00000000004009a5 <span class="hljs-keyword">in</span> insertionSort(int*, int)                                                    at insert.cpp:85       breakpoint     keep y   0x0000000000400cdd <span class="hljs-keyword">in</span> main() at test.cpp:166       breakpoint     keep y   0x00000000004009e5 <span class="hljs-keyword">in</span> insertionSort(int*, int)                                                    at insert.cpp:16</code></pre></div><p>需要关注的点：</p><ul><li>Num: 断点的编号，删除断点或者设置断点状态的时候都需要使用</li><li>Enb: 当前断点的状态，y 表示断点可用，n 表示断点不可用</li><li>What: 描述断点被设置在了哪个文件的哪一行或者哪个函数上</li></ul><h4><span id="shan-chu-duan-dian">删除断点</span><a href="#shan-chu-duan-dian" class="header-anchor">#</a></h4><div class="code-wrapper"><pre><code class="hljs bash"><span class="hljs-comment"># 需要 info b 查看断点的信息, 第一列就是编号</span>(gdb) d 断点的编号1 &amp;<span class="hljs-comment">#091;断点编号2 ...]</span><span class="hljs-comment"># 举例: </span>(gdb) d 1          <span class="hljs-comment"># 删除第1个断点</span>(gdb) d 2 4 6      <span class="hljs-comment"># 删除第2,4,6个断点</span><span class="hljs-comment"># 删除一个范围, 断点编号 num1 - numN 是一个连续区间</span>(gdb) d num1-numN<span class="hljs-comment"># 举例, 删除第1到第5个断点</span>(gdb) d 1-5</code></pre></div><h4><span id="she-zhi-duan-dian-zhuang-tai">设置断点状态</span><a href="#she-zhi-duan-dian-zhuang-tai" class="header-anchor">#</a></h4><h5><span id="duan-dian-wu-xiao-hua">断点无效化</span><a href="#duan-dian-wu-xiao-hua" class="header-anchor">#</a></h5><p>dis 断点编号<br>dis 断点1编号-断点n编号<br>断点无效化例子：</p><div class="code-wrapper"><pre><code class="hljs bash"><span class="hljs-comment"># 查看断点信息</span>(gdb) i bNum     Type           Disp Enb Address            What2       breakpoint     keep y   0x0000000000400cce <span class="hljs-keyword">in</span> main() at test.cpp:144       breakpoint     keep y   0x0000000000400cdd <span class="hljs-keyword">in</span> main() at test.cpp:165       breakpoint     keep y   0x0000000000400d46 <span class="hljs-keyword">in</span> main() at test.cpp:236       breakpoint     keep y   0x0000000000400d4e <span class="hljs-keyword">in</span> main() at test.cpp:257       breakpoint     keep y   0x0000000000400d6e <span class="hljs-keyword">in</span> main() at test.cpp:288       breakpoint     keep y   0x0000000000400d7d <span class="hljs-keyword">in</span> main() at test.cpp:30<span class="hljs-comment"># 设置第2, 第4 个断点无效</span>(gdb) dis 2 4<span class="hljs-comment"># 查看断点信息</span>(gdb) i bNum     Type           Disp Enb Address            What2       breakpoint     keep n   0x0000000000400cce <span class="hljs-keyword">in</span> main() at test.cpp:144       breakpoint     keep n   0x0000000000400cdd <span class="hljs-keyword">in</span> main() at test.cpp:165       breakpoint     keep y   0x0000000000400d46 <span class="hljs-keyword">in</span> main() at test.cpp:236       breakpoint     keep y   0x0000000000400d4e <span class="hljs-keyword">in</span> main() at test.cpp:257       breakpoint     keep y   0x0000000000400d6e <span class="hljs-keyword">in</span> main() at test.cpp:288       breakpoint     keep y   0x0000000000400d7d <span class="hljs-keyword">in</span> main() at test.cpp:30<span class="hljs-comment"># 设置 第5,6,7,8个 断点无效</span>(gdb) dis 5-8<span class="hljs-comment"># 查看断点信息</span>(gdb) i bNum     Type           Disp Enb Address            What2       breakpoint     keep n   0x0000000000400cce <span class="hljs-keyword">in</span> main() at test.cpp:144       breakpoint     keep n   0x0000000000400cdd <span class="hljs-keyword">in</span> main() at test.cpp:165       breakpoint     keep n   0x0000000000400d46 <span class="hljs-keyword">in</span> main() at test.cpp:236       breakpoint     keep n   0x0000000000400d4e <span class="hljs-keyword">in</span> main() at test.cpp:257       breakpoint     keep n   0x0000000000400d6e <span class="hljs-keyword">in</span> main() at test.cpp:288       breakpoint     keep n   0x0000000000400d7d <span class="hljs-keyword">in</span> main() at test.cpp:30</code></pre></div><h5><span id="rang-wu-xiao-de-duan-dian-sheng-xiao">让无效的断点生效</span><a href="#rang-wu-xiao-de-duan-dian-sheng-xiao" class="header-anchor">#</a></h5><div class="code-wrapper"><pre><code class="hljs bash"><span class="hljs-comment"># enable == ena</span><span class="hljs-comment"># 设置某一个或者某几个断点有效</span>(gdb) ena 断点1的编号 &amp;<span class="hljs-comment">#091;断点2的编号 ...]</span><span class="hljs-comment"># 设置某个区间断点有效</span>(gdb) ena 断点1编号-断点n编号</code></pre></div><p>有效化例子：</p><div class="code-wrapper"><pre><code class="hljs bash"><span class="hljs-comment"># 查看断点信息</span>(gdb) i bNum     Type           Disp Enb Address            What2       breakpoint     keep n   0x0000000000400cce <span class="hljs-keyword">in</span> main() at test.cpp:144       breakpoint     keep n   0x0000000000400cdd <span class="hljs-keyword">in</span> main() at test.cpp:165       breakpoint     keep n   0x0000000000400d46 <span class="hljs-keyword">in</span> main() at test.cpp:236       breakpoint     keep n   0x0000000000400d4e <span class="hljs-keyword">in</span> main() at test.cpp:257       breakpoint     keep n   0x0000000000400d6e <span class="hljs-keyword">in</span> main() at test.cpp:288       breakpoint     keep n   0x0000000000400d7d <span class="hljs-keyword">in</span> main() at test.cpp:30<span class="hljs-comment"># 设置第2, 第4个断点有效</span>(gdb) ena 2 4<span class="hljs-comment"># 查看断点信息</span>(gdb) i bNum     Type           Disp Enb Address            What2       breakpoint     keep y   0x0000000000400cce <span class="hljs-keyword">in</span> main() at test.cpp:144       breakpoint     keep y   0x0000000000400cdd <span class="hljs-keyword">in</span> main() at test.cpp:165       breakpoint     keep n   0x0000000000400d46 <span class="hljs-keyword">in</span> main() at test.cpp:236       breakpoint     keep n   0x0000000000400d4e <span class="hljs-keyword">in</span> main() at test.cpp:257       breakpoint     keep n   0x0000000000400d6e <span class="hljs-keyword">in</span> main() at test.cpp:288       breakpoint     keep n   0x0000000000400d7d <span class="hljs-keyword">in</span> main() at test.cpp:30<span class="hljs-comment"># 设置第5,6,7个断点有效</span>(gdb) ena 5-7<span class="hljs-comment"># 查看断点信息</span>(gdb) i bNum     Type           Disp Enb Address            What2       breakpoint     keep y   0x0000000000400cce <span class="hljs-keyword">in</span> main() at test.cpp:144       breakpoint     keep y   0x0000000000400cdd <span class="hljs-keyword">in</span> main() at test.cpp:165       breakpoint     keep y   0x0000000000400d46 <span class="hljs-keyword">in</span> main() at test.cpp:236       breakpoint     keep y   0x0000000000400d4e <span class="hljs-keyword">in</span> main() at test.cpp:257       breakpoint     keep y   0x0000000000400d6e <span class="hljs-keyword">in</span> main() at test.cpp:288       breakpoint     keep n   0x0000000000400d7d <span class="hljs-keyword">in</span> main() at test.cpp:30</code></pre></div><h3><span id="7-diao-shi-ming-ling">7.调试命令</span><a href="#7-diao-shi-ming-ling" class="header-anchor">#</a></h3><h4><span id="ji-xu-yun-xing-gdb">继续运行 gdb</span><a href="#ji-xu-yun-xing-gdb" class="header-anchor">#</a></h4><div class="code-wrapper"><pre><code class="hljs bash"><span class="hljs-comment"># cont = continue</span>(gdb) cont = <span class="hljs-built_in">continue</span></code></pre></div><h4><span id="shou-dong-da-yin-xin-xi">手动打印信息</span><a href="#shou-dong-da-yin-xin-xi" class="header-anchor">#</a></h4><p>当程序被某个断点阻塞之后，可以通过一些命令打印变量的名字或者变量的类型，并且还可以跟踪打印某个变量的值。</p><h5><span id="da-yin-bian-liang-zhi">打印变量值</span><a href="#da-yin-bian-liang-zhi" class="header-anchor">#</a></h5><p>print 命令的语法格式如下:</p><div class="code-wrapper"><pre><code class="hljs bash"><span class="hljs-comment"># print == p</span>(gdb) p 变量名<span class="hljs-comment"># 如果变量是一个整形, 默认对应的值是以10进制格式输出, 其他格式请参考上表</span>(gdb) p/fmt 变量名</code></pre></div><p>例子：</p><div class="code-wrapper"><pre><code class="hljs bash"><span class="hljs-comment"># 举例</span>(gdb) p i       <span class="hljs-comment"># 10进制</span><span class="hljs-variable">$5</span> = 3(gdb) p/x i     <span class="hljs-comment"># 16进制</span><span class="hljs-variable">$6</span> = 0x3(gdb) p/o i     <span class="hljs-comment"># 8进制</span><span class="hljs-variable">$7</span> = 03</code></pre></div><h4><span id="da-yin-bian-liang-lei-xing">打印变量类型</span><a href="#da-yin-bian-liang-lei-xing" class="header-anchor">#</a></h4><p>查看某个变量的类型</p><div class="code-wrapper"><pre><code class="hljs bash">(gdb) ptype 变量名</code></pre></div><p>例子：</p><div class="code-wrapper"><pre><code class="hljs bash"><span class="hljs-comment"># 打印变量类型</span>(gdb) ptype i<span class="hljs-built_in">type</span> = int(gdb) ptype array&amp;<span class="hljs-comment">#091;i]</span><span class="hljs-built_in">type</span> = int(gdb) ptype array<span class="hljs-built_in">type</span> = int &amp;<span class="hljs-comment">#091;12]</span></code></pre></div><h4><span id="zi-dong-da-yin-xin-xi">自动打印信息</span><a href="#zi-dong-da-yin-xin-xi" class="header-anchor">#</a></h4><h5><span id="she-zhi-bian-liang-ming-zi-dong-xian-shi">设置变量名自动显示</span><a href="#she-zhi-bian-liang-ming-zi-dong-xian-shi" class="header-anchor">#</a></h5><p>频繁查看某个变量或表达式的值从而观察它的变化情况时，使用 display 命令可以一劳永逸。display 命令没有缩写形式</p><div class="code-wrapper"><pre><code class="hljs bash"><span class="hljs-comment"># 在变量的有效取值范围内, 自动打印变量的值(设置一次, 以后就会自动显示)</span>(gdb) display 变量名<span class="hljs-comment"># 以指定的整形格式打印变量的值, 关于 fmt 的取值, 请参考 print 命令</span>(gdb) display/fmt 变量名</code></pre></div><h5><span id="cha-kan-zi-dong-xian-shi-lie-biao">查看自动显示列表</span><a href="#cha-kan-zi-dong-xian-shi-lie-biao" class="header-anchor">#</a></h5><div class="code-wrapper"><pre><code class="hljs bash"><span class="hljs-comment"># info == i</span>(gdb) info displayAuto-display expressions now <span class="hljs-keyword">in</span> effect:Num Enb Expression1:   y  i2:   y  array&amp;<span class="hljs-comment">#091;i]</span>3:   y  /x array&amp;<span class="hljs-comment">#091;i]</span></code></pre></div><p>在展示出的信息中，每个列的含义如下:</p><ul><li><strong>Num</strong> : 变量或表达式的编号，GDB 调试器为每个变量或表达式都分配有唯一的编号</li><li><strong>Enb</strong> : 表示当前变量（表达式）是处于激活状态还是禁用状态，如果处于激活状态（用 y 表示），则每次程序停止执行，该变量的值都会被打印出来；反之，如果处于禁用状态（用 n 表示），则该变量（表达式）的值不会被打印。</li><li><strong>Expression</strong> ：被自动打印值的变量或表达式的名字。</li></ul><h4><span id="qu-xiao-zi-dong-xian-shi">取消自动显示</span><a href="#qu-xiao-zi-dong-xian-shi" class="header-anchor">#</a></h4><p>对于不需要再打印值的变量或表达式，可以将其删除或者禁用。</p><div class="code-wrapper"><pre><code class="hljs bash"><span class="hljs-comment"># 命令中的 num 是通过 info display 得到的编号, 编号可以是一个或者多个</span>(gdb) undisplay num &amp;<span class="hljs-comment">#091;num1 ...]</span><span class="hljs-comment"># num1 - numN 表示一个范围</span>(gdb) undisplay num1-numN(gdb) delete display num &amp;<span class="hljs-comment">#091;num1 ...]</span>(gdb) delete display num1-numN&lt;/code&gt;&lt;/pre&gt;</code></pre></div><p>例子：</p><div class="code-wrapper"><pre><code class="hljs bash"><span class="hljs-comment"># 查看显示列表</span>(gdb) info displayAuto-display expressions now <span class="hljs-keyword">in</span> effect:Num Enb Expression1:   y  i2:   y  array&amp;<span class="hljs-comment">#091;i]</span>3:   y  /x array&amp;<span class="hljs-comment">#091;i]</span><span class="hljs-comment"># 删除变量显示, 需要使用 info display 得到的变量/表达式编号</span>(gdb) undisplay 1 2<span class="hljs-comment"># 查看显示列表, 只剩下一个了</span>(gdb) i displayAuto-display expressions now <span class="hljs-keyword">in</span> effect:Num Enb Expression3:   y  /x array&amp;<span class="hljs-comment">#091;i]</span></code></pre></div><p>禁用自动显示列表中处于激活状态下的变量或表达式</p><div class="code-wrapper"><pre><code class="hljs bash"><span class="hljs-comment"># 命令中的 num 是通过 info display 得到的编号, 编号可以是一个或者多个</span>(gdb) <span class="hljs-built_in">disable</span> display num &amp;<span class="hljs-comment">#091;num1 ...]</span><span class="hljs-comment"># num1 - numN 表示一个范围</span>(gdb) <span class="hljs-built_in">disable</span> display num1-numN</code></pre></div><p>当需要启用自动显示列表中被禁用的变量或表达式时，可以使用下边的命令</p><div class="code-wrapper"><pre><code class="hljs bash"><span class="hljs-comment"># 命令中的 num 是通过 info display 得到的编号, 编号可以是一个或者多个</span>(gdb) <span class="hljs-built_in">enable</span>  display num &amp;<span class="hljs-comment">#091;num1 ...]</span><span class="hljs-comment"># num1 - numN 表示一个范围</span>(gdb) <span class="hljs-built_in">disable</span> display num1-numN</code></pre></div><h4><span id="dan-bu-diao-shi">单步调试</span><a href="#dan-bu-diao-shi" class="header-anchor">#</a></h4><p>当程序阻塞到某个断点上之后，可以通过以下命令对程序进行单步调试:</p><h5><span id="step">step</span><a href="#step" class="header-anchor">#</a></h5><p>step 命令可以缩写为 s, 命令被执行一次代码被向下执行一行，如果这一行是一个函数调用，那么程序会进入到函数体内部。</p><div class="code-wrapper"><pre><code class="hljs bash"><span class="hljs-comment"># 从当前代码行位置, 一次调试当前行下的每一行代码</span><span class="hljs-comment"># step == s</span><span class="hljs-comment"># 如果这一行是函数调用, 执行这个命令, 就可以进入到函数体的内部</span>(gdb) step</code></pre></div><h5><span id="finish">finish</span><a href="#finish" class="header-anchor">#</a></h5><p>作用：跳出函数体，函数体内不能有有效断点</p><div class="code-wrapper"><pre><code class="hljs bash"><span class="hljs-comment"># 如果通过 s 单步调试进入到函数内部, 想要跳出这个函数体</span>(gdb) finish</code></pre></div><h5><span id="next">next</span><a href="#next" class="header-anchor">#</a></h5><p>作用：和step相似，但不会进入函数体内部</p><div class="code-wrapper"><pre><code class="hljs bash"><span class="hljs-comment"># next == n</span><span class="hljs-comment"># 如果这一行是函数调用, 执行这个命令, 不会进入到函数体的内部</span>(gdb) next</code></pre></div><h5><span id="until">until</span><a href="#until" class="header-anchor">#</a></h5><p>until作用：直接跳出某个循环体<br>循环体内部不能有有效的断点，必须要在循环体的开始 / 结束行执行该命令</p><div class="code-wrapper"><pre><code class="hljs bash">(gdb) until</code></pre></div><h4><span id="she-zhi-bian-liang-zhi">设置变量值</span><a href="#she-zhi-bian-liang-zhi" class="header-anchor">#</a></h4><p>set var 变量名=值</p><p>设置某个变量的值</p>]]></content>
    
    
    
    <tags>
      
      <tag>Linux</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>从Portainer点击端口号进入容器服务方法</title>
    <link href="/2021/12/26/%E4%BB%8EPortainer%E7%82%B9%E5%87%BB%E7%AB%AF%E5%8F%A3%E5%8F%B7%E8%BF%9B%E5%85%A5%E5%AE%B9%E5%99%A8%E6%9C%8D%E5%8A%A1%E6%96%B9%E6%B3%95/"/>
    <url>/2021/12/26/%E4%BB%8EPortainer%E7%82%B9%E5%87%BB%E7%AB%AF%E5%8F%A3%E5%8F%B7%E8%BF%9B%E5%85%A5%E5%AE%B9%E5%99%A8%E6%9C%8D%E5%8A%A1%E6%96%B9%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<div class="toc"><!-- toc --><!-- tocstop --></div><p><img src="https://gitee.com/txt1994/images/raw/master/img/2021/05/image-5.png"></p><h4><span id="1-dian-ji-home-zai-dian-ji-pei-zhi-ran-hou-tian-xie-nas-de-ip-di-zhi-ji-ke">1.点击home,再点击配置，然后填写nas的ip地址即可</span><a href="#1-dian-ji-home-zai-dian-ji-pei-zhi-ran-hou-tian-xie-nas-de-ip-di-zhi-ji-ke" class="header-anchor">#</a></h4><p><img src="https://gitee.com/txt1994/images/raw/master/img/2021/05/image-6.png"><br><img src="https://gitee.com/txt1994/images/raw/master/img/2021/05/image-7.png"></p>]]></content>
    
    
    
    <tags>
      
      <tag>nas</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>OpenMediaVault中docker与工具portainer</title>
    <link href="/2021/12/26/OpenMediaVault%E4%B8%AD%E5%AE%89%E8%A3%85docker%E4%B8%8EGUI%E5%B7%A5%E5%85%B7portainer/"/>
    <url>/2021/12/26/OpenMediaVault%E4%B8%AD%E5%AE%89%E8%A3%85docker%E4%B8%8EGUI%E5%B7%A5%E5%85%B7portainer/</url>
    
    <content type="html"><![CDATA[<div class="toc"><!-- toc --><ul><li><a href="#1-an-zhuang-wan-di-san-fang-cha-jian-hou-zai-an-zhuang-docker-yu-portainer">1. 安装完第三方插件后，再安装docker与portainer</a></li><li><a href="#2-dian-ji-opem-portainer-chuang-jian-guan-li-zhang-hao">2. 点击Opem Portainer创建管理账号</a></li><li><a href="#3-ran-hou-chuang-jian-yi-ge-rong-qi-wang-luo">3. 然后创建一个容器网络</a></li></ul><!-- tocstop --></div><h3><span id="1-an-zhuang-wan-di-san-fang-cha-jian-hou-zai-an-zhuang-docker-yu-portainer">1. 安装完第三方插件后，再安装docker与portainer</span><a href="#1-an-zhuang-wan-di-san-fang-cha-jian-hou-zai-an-zhuang-docker-yu-portainer" class="header-anchor">#</a></h3><p><img src="https://gitee.com/txt1994/images/raw/master/img/2021/05/2021-05-05-214837.png"></p><h3><span id="2-dian-ji-opem-portainer-chuang-jian-guan-li-zhang-hao">2. 点击Opem Portainer创建管理账号</span><a href="#2-dian-ji-opem-portainer-chuang-jian-guan-li-zhang-hao" class="header-anchor">#</a></h3><p><img src="https://gitee.com/txt1994/images/raw/master/img/2021/05/image-1.png"></p><h3><span id="3-ran-hou-chuang-jian-yi-ge-rong-qi-wang-luo">3. 然后创建一个容器网络</span><a href="#3-ran-hou-chuang-jian-yi-ge-rong-qi-wang-luo" class="header-anchor">#</a></h3><p><img src="https://gitee.com/txt1994/images/raw/master/img/2021/05/image-2.png"></p>]]></content>
    
    
    
    <tags>
      
      <tag>nas</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>OpenMediaVault软件源修改</title>
    <link href="/2021/12/26/OpenMediaVault%E8%BD%AF%E4%BB%B6%E6%BA%90%E4%BF%AE%E6%94%B9/"/>
    <url>/2021/12/26/OpenMediaVault%E8%BD%AF%E4%BB%B6%E6%BA%90%E4%BF%AE%E6%94%B9/</url>
    
    <content type="html"><![CDATA[<div class="toc"><!-- toc --><ul><li><a href="#yi-bian-ji-sources-list"><strong>一、编辑 sources.list</strong></a></li><li><a href="#er-bian-ji-openmediavault-kernel-backports-list"><strong>二、编辑 openmediavault-kernel-backports.list</strong></a></li><li><a href="#san-bian-ji-openmediavault-list"><strong>三、编辑 openmediavault.list</strong></a></li><li><a href="#wu-shua-xin-ruan-jian-yuan"><strong>五. 刷新软件源</strong></a></li></ul><!-- tocstop --></div><p>OpenMediaVault 国内软件源镜像服务器</p><ul><li><strong>清华大学镜像</strong></li></ul><div class="code-wrapper"><pre><code class="hljs bash">https://mirrors.tuna.tsinghua.edu.cn/OpenMediaVault/</code></pre></div><ul><li><strong>北京外国语大学镜像</strong></li></ul><div class="code-wrapper"><pre><code class="hljs bash">https://mirrors.bfsu.edu.cn/OpenMediaVault/</code></pre></div><p><strong>OMV 5</strong></p><h3><span id="yi-bian-ji-sources-list"><strong>一、编辑 sources.list</strong></span><a href="#yi-bian-ji-sources-list" class="header-anchor">#</a></h3><p>1. 备份配置文件</p><div class="code-wrapper"><pre><code class="hljs bash">sudo <span class="hljs-built_in">cp</span> /etc/apt/sources.list /etc/apt/sources.list.bak</code></pre></div><p>2. 清空配置文件</p><div class="code-wrapper"><pre><code class="hljs bash">sudo sh -c <span class="hljs-string">'echo &gt; /etc/apt/sources.list'</span></code></pre></div><p>3. 编辑配置文件</p><div class="code-wrapper"><pre><code class="hljs bash">sudo nano /etc/apt/sources.list</code></pre></div><p><strong>复制并粘贴以下内容：</strong></p><div class="code-wrapper"><pre><code class="hljs bash">deb https://mirrors.tuna.tsinghua.edu.cn/debian/ buster main<span class="hljs-comment"># deb-src https://mirrors.tuna.tsinghua.edu.cn/debian/ buster main</span>deb https://mirrors.tuna.tsinghua.edu.cn/debian-security buster/updates main contrib non-free<span class="hljs-comment"># deb-src https://mirrors.tuna.tsinghua.edu.cn/debian-security buster/updates main contrib non-free</span>deb https://mirrors.tuna.tsinghua.edu.cn/debian/ buster-updates main contrib non-free<span class="hljs-comment"># deb-src https://mirrors.tuna.tsinghua.edu.cn/debian/ buster-updates main contrib non-free</span></code></pre></div><h3><span id="er-bian-ji-openmediavault-kernel-backports-list"><strong>二、编辑 openmediavault-kernel-backports.list</strong></span><a href="#er-bian-ji-openmediavault-kernel-backports-list" class="header-anchor">#</a></h3><p>1. 备份配置文件</p><div class="code-wrapper"><pre><code class="hljs bash">sudo <span class="hljs-built_in">cp</span> /etc/apt/sources.list.d/openmediavault-kernel-backports.list /etc/apt/sources.list.d/openmediavault-kernel-backports.list.bak</code></pre></div><p>2. 清空配置文件</p><div class="code-wrapper"><pre><code class="hljs bash">sudo sh -c <span class="hljs-string">'echo &gt; /etc/apt/sources.list.d/openmediavault-kernel-backports.list'</span></code></pre></div><h4><span id="3-bian-ji-pei-zhi-wen-jian">3. 编辑配置文件</span><a href="#3-bian-ji-pei-zhi-wen-jian" class="header-anchor">#</a></h4><div class="code-wrapper"><pre><code class="hljs bash">sudo nano /etc/apt/sources.list.d/openmediavault-kernel-backports.list</code></pre></div><p><strong>复制并粘贴以下内容：</strong></p><div class="code-wrapper"><pre><code class="hljs c++">deb https:<span class="hljs-comment">//mirrors.tuna.tsinghua.edu.cn/debian buster-backports main contrib non-free</span></code></pre></div><h3><span id="san-bian-ji-openmediavault-list"><strong>三、编辑 openmediavault.list</strong></span><a href="#san-bian-ji-openmediavault-list" class="header-anchor">#</a></h3><h4><span id="1-bei-fen-pei-zhi-wen-jian">1. 备份配置文件</span><a href="#1-bei-fen-pei-zhi-wen-jian" class="header-anchor">#</a></h4><div class="code-wrapper"><pre><code class="hljs bash">sudo <span class="hljs-built_in">cp</span> /etc/apt/sources.list.d/openmediavault.list /etc/apt/sources.list.d/openmediavault.list.bak</code></pre></div><h4><span id="2-qing-kong-pei-zhi-wen-jian">2. 清空配置文件</span><a href="#2-qing-kong-pei-zhi-wen-jian" class="header-anchor">#</a></h4><div class="code-wrapper"><pre><code class="hljs bash">sudo sh -c <span class="hljs-string">'echo &gt; /etc/apt/sources.list.d/openmediavault.list'</span></code></pre></div><h4><span id="3-bian-ji-pei-zhi-wen-jian">3. 编辑配置文件</span><a href="#3-bian-ji-pei-zhi-wen-jian" class="header-anchor">#</a></h4><div class="code-wrapper"><pre><code class="hljs bash">sudo nano /etc/apt/sources.list.d/openmediavault.list</code></pre></div><p><strong>复制并粘贴以下内容：</strong></p><div class="code-wrapper"><pre><code class="hljs c++">deb https:<span class="hljs-comment">//mirrors.tuna.tsinghua.edu.cn/OpenMediaVault/public/ usul main</span></code></pre></div><p><strong>四、编辑 omvextras.list</strong></p><h4><span id="1-bei-fen-pei-zhi-wen-jian">1. 备份配置文件</span><a href="#1-bei-fen-pei-zhi-wen-jian" class="header-anchor">#</a></h4><div class="code-wrapper"><pre><code class="hljs bash">sudo <span class="hljs-built_in">cp</span> /etc/apt/sources.list.d/omvextras.list /etc/apt/sources.list.d/omvextras.list.bak</code></pre></div><h4><span id="2-qing-kong-pei-zhi-wen-jian"><strong>2. 清空配置文件</strong></span><a href="#2-qing-kong-pei-zhi-wen-jian" class="header-anchor">#</a></h4><div class="code-wrapper"><pre><code class="hljs bash">sudo sh -c <span class="hljs-string">'echo &gt; /etc/apt/sources.list.d/omvextras.list'</span></code></pre></div><h4><span id="3-bian-ji-pei-zhi-wen-jian"><strong>3. 编辑配置文件</strong></span><a href="#3-bian-ji-pei-zhi-wen-jian" class="header-anchor">#</a></h4><div class="code-wrapper"><pre><code class="hljs bash">sudo nano /etc/apt/sources.list.d/omvextras.list</code></pre></div><p><strong>复制并粘贴以下内容：</strong></p><div class="code-wrapper"><pre><code class="hljs markdown">deb https://mirrors.tuna.tsinghua.edu.cn/OpenMediaVault/openmediavault-plugin-developers usul maindeb [arch=amd64] https://mirrors.tuna.tsinghua.edu.cn/docker-ce/linux/debian buster stabledeb http://linux.teamviewer.com/deb stable main</code></pre></div><h3><span id="wu-shua-xin-ruan-jian-yuan"><strong>五. 刷新软件源</strong></span><a href="#wu-shua-xin-ruan-jian-yuan" class="header-anchor">#</a></h3><div class="code-wrapper"><pre><code class="hljs bash">sudo apt update</code></pre></div>]]></content>
    
    
    
    <tags>
      
      <tag>nas</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>OpenMediaVault创建容器</title>
    <link href="/2021/12/26/OpenMediaVault%E5%88%9B%E5%BB%BA%E5%AE%B9%E5%99%A8/"/>
    <url>/2021/12/26/OpenMediaVault%E5%88%9B%E5%BB%BA%E5%AE%B9%E5%99%A8/</url>
    
    <content type="html"><![CDATA[<div class="toc"><!-- toc --><ul><li><a href="#1-zai-yi-ge-fen-qu-shang-chuang-jian-wo-men-xu-yao-de-wen-jian-jia-cun-fang-pei-zhi-wen-jian"><strong>1.在一个分区上创建我们需要的文件夹存放配置文件</strong></a></li><li><a href="#2-zai-zhong-duan-la-qu-shang-mian-de-ge-ge-jing-xiang-wen-jian">2.在终端拉取上面的各个镜像文件</a></li><li><a href="#3-chuang-jian-ge-ge-rong-qi"><strong>3.创建各个容器</strong></a></li></ul><!-- tocstop --></div><p>要创建的容器有：</p><div class="code-wrapper"><pre><code class="hljs">Mariadb: 关系型数据库，mysql的开源版本Adminer：开源的数据库管理软件Gitea：开源的私人代码版本管理器Flarum：开源的论坛WordPress：开源的博客软件NextCloud：开源的私人网盘软件</code></pre></div><h3><span id="1-zai-yi-ge-fen-qu-shang-chuang-jian-wo-men-xu-yao-de-wen-jian-jia-cun-fang-pei-zhi-wen-jian"><strong>1.在一个分区上创建我们需要的文件夹存放配置文件</strong></span><a href="#1-zai-yi-ge-fen-qu-shang-chuang-jian-wo-men-xu-yao-de-wen-jian-jia-cun-fang-pei-zhi-wen-jian" class="header-anchor">#</a></h3><p><img src="https://gitee.com/txt1994/images/raw/master/img/2021/05/image-3.png"></p><h3><span id="2-zai-zhong-duan-la-qu-shang-mian-de-ge-ge-jing-xiang-wen-jian">2.在终端拉取上面的各个镜像文件</span><a href="#2-zai-zhong-duan-la-qu-shang-mian-de-ge-ge-jing-xiang-wen-jian" class="header-anchor">#</a></h3><h4><span id="1-flarum">1.flarum</span><a href="#1-flarum" class="header-anchor">#</a></h4><div class="code-wrapper"><pre><code class="hljs">docker pull mondedie/flarum:latest</code></pre></div><h4><span id="2-wordpress">2.wordpress</span><a href="#2-wordpress" class="header-anchor">#</a></h4><div class="code-wrapper"><pre><code class="hljs">docker pull wordpress</code></pre></div><h4><span id="3-adminer">3.adminer</span><a href="#3-adminer" class="header-anchor">#</a></h4><div class="code-wrapper"><pre><code class="hljs">docker pull adminer</code></pre></div><h4><span id="4-mariadb">4.mariadb</span><a href="#4-mariadb" class="header-anchor">#</a></h4><div class="code-wrapper"><pre><code class="hljs">docker pull mariadb</code></pre></div><h4><span id="5-gitea">5.gitea</span><a href="#5-gitea" class="header-anchor">#</a></h4><div class="code-wrapper"><pre><code class="hljs">docker pull gitea/gitea</code></pre></div><h4><span id="6-nextcloud">6.nextcloud</span><a href="#6-nextcloud" class="header-anchor">#</a></h4><div class="code-wrapper"><pre><code class="hljs">docker pull nextcloud</code></pre></div><h3><span id="3-chuang-jian-ge-ge-rong-qi"><strong>3.创建各个容器</strong></span><a href="#3-chuang-jian-ge-ge-rong-qi" class="header-anchor">#</a></h3><p>按顺序应该创建数据库软件与数据库管理软件<br><img src="https://gitee.com/txt1994/images/raw/master/img/2021/05/image-4.png"></p><h4><span id="1-mariadb-rong-qi-chuang-jian-can-kao">1.mariadb容器创建参考</span><a href="#1-mariadb-rong-qi-chuang-jian-can-kao" class="header-anchor">#</a></h4><div class="code-wrapper"><pre><code class="hljs">container_name: mariadb    environment:      - PUID=1000      - PGID=1000      - MYSQL_ROOT_PASSWORD=1      - TZ=Asia/Shanghai    volumes:      - /srv/dev-disk-by-id-ata-VBOX_HARDDISK_VBdf1e9e6f-f90961e1-part1/mariadb/config:/config    ports:      - 3306:3306    networks:      - mynet    restart: alwaysnetworks:  mynet:    external:      name: mynet</code></pre></div><h4><span id="2-adminer-chuang-jian-can-kao">2.adminer创建参考</span><a href="#2-adminer-chuang-jian-can-kao" class="header-anchor">#</a></h4><div class="code-wrapper"><pre><code class="hljs">container_name: adminer    environment:      - ADMINER_DEFAULT_SERVER=mariadb    ports:      - 8080:8080    networks:      - mynet    restart: alwaysnetworks:  mynet:    external:      name: mynet</code></pre></div><h4><span id="3-flarum-chuang-jian-can-kao">3.flarum创建参考</span><a href="#3-flarum-chuang-jian-can-kao" class="header-anchor">#</a></h4><h5><span id="3-1-zai-ying-she-de-flarum-gen-mu-lu-chuang-jian-docker-compose-yaml">3.1在映射的flarum根目录创建docker-compose.yaml</span><a href="#3-1-zai-ying-she-de-flarum-gen-mu-lu-chuang-jian-docker-compose-yaml" class="header-anchor">#</a></h5><div class="code-wrapper"><pre><code class="hljs">version: "3"services:  flarum:    image: mondedie/flarum:stable    container_name: flarum    env_file:      - /srv/dev-disk-by-id-ata-VBOX_HARDDISK_VBdf1e9e6f-f90961e1-part1/flarum/flarum.env    volumes:      - /srv/dev-disk-by-id-ata-VBOX_HARDDISK_VBdf1e9e6f-f90961e1-part1/flarum/assets:/flarum/app/public/assets      - /srv/dev-disk-by-id-ata-VBOX_HARDDISK_VBdf1e9e6f-f90961e1-part1/flarum/extensions:/flarum/app/extensions      - /srv/dev-disk-by-id-ata-VBOX_HARDDISK_VBdf1e9e6f-f90961e1-part1/flarum/nginx:/etc/nginx/flarum      - /mnt/docker/flarum/storage/logs:/flarum/app/storage/logs    ports:      - 8081:8888    networks:      - mynet    restart: alwaysnetworks:  mynet:    external:      name: mynet</code></pre></div><h5><span id="3-2-zai-chuang-jian-flarum-env">3.2再创建flarum.env</span><a href="#3-2-zai-chuang-jian-flarum-env" class="header-anchor">#</a></h5><div class="code-wrapper"><pre><code class="hljs">DEBUG=falseFORUM_URL=http://192.168.1.105:8081# Database configurationDB_HOST=mariadbDB_NAME=flarumDB_USER=flarumDB_PASS=123456789DB_PREF=flarum_DB_PORT=3306# User admin flarum (environment variable for first installation)# /!\ admin password must contain at least 8 characters /!\FLARUM_ADMIN_USER=adminFLARUM_ADMIN_PASS=123456789FLARUM_ADMIN_MAIL=txt1994s@163.comFLARUM_TITLE=txt1994的论坛</code></pre></div><p>登录adminer,然后创建数据库</p><div class="code-wrapper"><pre><code class="hljs">DB_HOST=mariadb (地址)DB_NAME=flarum  (数据库)DB_USER=flarum  （用户）DB_PASS=123456789（密码）</code></pre></div><p>然后运行命令：</p><div class="code-wrapper"><pre><code class="hljs">docker-compose up -d flarum</code></pre></div><p>安装中文插件</p><blockquote><p>=Beta 14</p></blockquote><p><code>docker exec -ti flarum extension require ffans/lang-simplified-chinese</code></p><p>安装emoji表情插件<br><code>docker exec -ti flarum extension require clarkwinkelmann/flarum-ext-emojionearea</code></p><p>安装显示帖子阅读次数<br><code>docker exec -ti flarum extension require michaelbelgium/flarum-discussion-views</code></p><p>安装flarum媒体增强插件<br><code>docker exec -ti flarum extension require fof/formatting</code></p><p>表格支持插件</p><p><code>docker exec -ti flarum extension require askvortsov/flarum-markdown-tables</code></p><p>代码高亮</p><p><code>docker exec -ti flarum extension require therealsujitk/flarum-ext-hljs</code></p><h4><span id="4-gitea-chuang-jian-can-kao">4.gitea创建参考</span><a href="#4-gitea-chuang-jian-can-kao" class="header-anchor">#</a></h4><div class="code-wrapper"><pre><code class="hljs">container_name: gitea    volumes:      - /srv/dev-disk-by-id-ata-VBOX_HARDDISK_VBdf1e9e6f-f90961e1-part1/gitea/data:/data    ports:      - "3000:3000"      - "2222:22"    networks:      - mynet    restart: alwaysnetworks:  mynet:    external:      name: mynet创建数据库：      - MYSQL_ROOT_PASSWORD=1      - MYSQL_DATABASE=gitea      - MYSQL_USER=gitea      - MYSQL_PASSWORD=123456789</code></pre></div><h4><span id="5-wordpress-chuang-jian-can-kao">5.wordpress创建参考</span><a href="#5-wordpress-chuang-jian-can-kao" class="header-anchor">#</a></h4><div class="code-wrapper"><pre><code class="hljs">container_name: wordpress    volumes:      - /srv/dev-disk-by-id-ata-VBOX_HARDDISK_VBdf1e9e6f-f90961e1-part1/wordpress/html:/var/www/html    ports:      - 8082:80    environment:      WORDPRESS_DB_HOST: mariadb      WORDPRESS_DB_USER: wordpress      WORDPRESS_DB_PASSWORD: 123456789      WORDPRESS_DB_NAME: wordpress    networks:      - mynet    restart: alwaysnetworks:  mynet:    external:      name: mynet   创建好数据库：      WORDPRESS_DB_HOST: mariadb      WORDPRESS_DB_USER: wordpress      WORDPRESS_DB_PASSWORD: 123456789      WORDPRESS_DB_NAME: wordpress</code></pre></div><h4><span id="6-nextcloud-chuang-jian-can-kao">6.nextcloud创建参考</span><a href="#6-nextcloud-chuang-jian-can-kao" class="header-anchor">#</a></h4><div class="code-wrapper"><pre><code class="hljs">container_name: nextcloud    volumes:      - /srv/dev-disk-by-id-ata-VBOX_HARDDISK_VBdf1e9e6f-f90961e1-part1/nextcloud/html:/var/www/html    ports:      - 8083:80       networks:      - mynet        restart: always    创建好数据库：environment:      - MYSQL_PASSWORD=123456789      - MYSQL_DATABASE=nextcloud      - MYSQL_USER=nextcloud      - MYSQL_HOST=mariadb</code></pre></div>]]></content>
    
    
    
    <tags>
      
      <tag>nas</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>OpenMediaVault安装与初步设置</title>
    <link href="/2021/12/26/OpenMediaVault%E5%AE%89%E8%A3%85%E4%B8%8E%E5%88%9D%E6%AD%A5%E8%AE%BE%E7%BD%AE/"/>
    <url>/2021/12/26/OpenMediaVault%E5%AE%89%E8%A3%85%E4%B8%8E%E5%88%9D%E6%AD%A5%E8%AE%BE%E7%BD%AE/</url>
    
    <content type="html"><![CDATA[<div class="toc"><!-- toc --><ul><li><a href="#1-jing-xiang-xia-zai"><strong>1. 镜像下载</strong></a></li><li><a href="#2-ke-lu-huo-xu-ni-ji-an-zhuang"><strong>2. 刻录或虚拟机安装</strong></a></li><li><a href="#an-zhuang-omv-extras-qi-yong-omv-5-she-qu-cha-jian-zhi-chi"><strong>安装 omv-extras 启用 OMV 5 社区插件支持</strong></a></li><li><a href="#3-an-zhuang-yi-lai-de-gong-ju"><strong>3. 安装依赖的工具</strong></a></li><li><a href="#4-xia-zai-zui-xin-de-omv-extras-an-zhuang-bao"><strong>4. 下载最新的omv-extras 安装包</strong></a></li><li><a href="#5-an-zhuang"><strong>5. 安装</strong></a></li><li><a href="#6-an-zhuang-wan-kai-qi-docker-kuo-zhan-yuan"><strong>6. 安装完开启docker扩展源</strong></a></li><li><a href="#7-docker-xiu-gai-jing-xiang-yuan-bing-zai-omv-zhong-de-an-zhuang-he-shi-yong"><strong>7. Docker修改镜像源并在OMV 中的安装和使用</strong></a></li></ul><!-- tocstop --></div><p>OpenMediaVault（omv）是开源的nas系统，本博客尽量采用开源的代码和软件</p><h3><span id="1-jing-xiang-xia-zai"><strong>1. 镜像下载</strong></span><a href="#1-jing-xiang-xia-zai" class="header-anchor">#</a></h3><p>下载地址</p><div class="code-wrapper"><pre><code class="hljs bash">https://sourceforge.net/projects/openmediavault/files/latest/download</code></pre></div><h3><span id="2-ke-lu-huo-xu-ni-ji-an-zhuang"><strong>2. 刻录或虚拟机安装</strong></span><a href="#2-ke-lu-huo-xu-ni-ji-an-zhuang" class="header-anchor">#</a></h3><p>可以用etcher软件刻录镜像</p><h3><span id="an-zhuang-omv-extras-qi-yong-omv-5-she-qu-cha-jian-zhi-chi"><strong>安装 omv-extras 启用 OMV 5 社区插件支持</strong></span><a href="#an-zhuang-omv-extras-qi-yong-omv-5-she-qu-cha-jian-zhi-chi" class="header-anchor">#</a></h3><h3><span id="3-an-zhuang-yi-lai-de-gong-ju"><strong>3. 安装依赖的工具</strong></span><a href="#3-an-zhuang-yi-lai-de-gong-ju" class="header-anchor">#</a></h3><div class="code-wrapper"><pre><code class="hljs bash">sudo apt --<span class="hljs-built_in">yes</span> --no-install-recommends install dirmngr gnupg</code></pre></div><h3><span id="4-xia-zai-zui-xin-de-omv-extras-an-zhuang-bao"><strong>4. 下载最新的omv-extras 安装包</strong></span><a href="#4-xia-zai-zui-xin-de-omv-extras-an-zhuang-bao" class="header-anchor">#</a></h3><div class="code-wrapper"><pre><code class="hljs bash">地址：https://mirrors.tuna.tsinghua.edu.cn/OpenMediaVault/openmediavault-plugin-developers/pool/main/o/openmediavault-omvextrasorg/openmediavault-omvextrasorg_5.6.2_all.deb下载命令：sudo wget https://mirrors.tuna.tsinghua.edu.cn/OpenMediaVault/openmediavault-plugin-developers/pool/main/o/openmediavault-omvextrasorg/openmediavault-omvextrasorg_5.6.2_all.deb</code></pre></div><h3><span id="5-an-zhuang"><strong>5. 安装</strong></span><a href="#5-an-zhuang" class="header-anchor">#</a></h3><div class="code-wrapper"><pre><code class="hljs bash">sudo dpkg -i openmediavault-omvextrasorg_5.6.2_all.deb</code></pre></div><h3><span id="6-an-zhuang-wan-kai-qi-docker-kuo-zhan-yuan"><strong>6. 安装完开启docker扩展源</strong></span><a href="#6-an-zhuang-wan-kai-qi-docker-kuo-zhan-yuan" class="header-anchor">#</a></h3><p><img src="https://gitee.com/txt1994/images/raw/master/img/2021/05/OpenMediaVault2021-05-05-214136.png"><br><img src="https://gitee.com/txt1994/images/raw/master/img/2021/05/%E8%BD%AF%E4%BB%B6%E6%BA%902021-05-05-214306.png"></p><h3><span id="7-docker-xiu-gai-jing-xiang-yuan-bing-zai-omv-zhong-de-an-zhuang-he-shi-yong"><strong>7. Docker修改镜像源并在OMV 中的安装和使用</strong></span><a href="#7-docker-xiu-gai-jing-xiang-yuan-bing-zai-omv-zhong-de-an-zhuang-he-shi-yong" class="header-anchor">#</a></h3><p>Docker 设置国内镜像服务器</p><h4><span id="di-yi-bu-chuang-jian-docker-pei-zhi-wen-jian-mu-lu"><strong>第一步 创建 docker 配置文件目录</strong></span><a href="#di-yi-bu-chuang-jian-docker-pei-zhi-wen-jian-mu-lu" class="header-anchor">#</a></h4><div class="code-wrapper"><pre><code class="hljs bash">sudo <span class="hljs-built_in">mkdir</span> /etc/docker</code></pre></div><h4><span id="di-er-bu-chuang-jian-daemon-json-pei-zhi-wen-jian"><strong>第二步 创建 daemon.json 配置文件</strong></span><a href="#di-er-bu-chuang-jian-daemon-json-pei-zhi-wen-jian" class="header-anchor">#</a></h4><div class="code-wrapper"><pre><code class="hljs bash">sudo <span class="hljs-built_in">touch</span> /etc/docker/daemon.json</code></pre></div><h4><span id="di-san-bu-bian-ji-pei-zhi-wen-jian"><strong>第三步 编辑配置文件</strong></span><a href="#di-san-bu-bian-ji-pei-zhi-wen-jian" class="header-anchor">#</a></h4><div class="code-wrapper"><pre><code class="hljs bash">sudo nano /etc/docker/daemon.json</code></pre></div><h5><span id="zai-bian-ji-qi-zhong-nian-tie-yi-xia-nei-rong">在编辑器中粘贴以下内容:</span><a href="#zai-bian-ji-qi-zhong-nian-tie-yi-xia-nei-rong" class="header-anchor">#</a></h5><div class="code-wrapper"><pre><code class="hljs shell">{  "registry-mirrors": [    "https://hub-mirror.c.163.com",    "https://mirror.baidubce.com"  ]}</code></pre></div><h4><span id="di-si-bu-chong-qi-docker-fu-wu"><strong>第四步 重启 docker 服务</strong></span><a href="#di-si-bu-chong-qi-docker-fu-wu" class="header-anchor">#</a></h4><div class="code-wrapper"><pre><code class="hljs bash">sudo systemctl daemon-reload sudo systemctl restart docker</code></pre></div><p><strong>检查设置是否生效</strong></p><div class="code-wrapper"><pre><code class="hljs bash">sudo docker info</code></pre></div><p>如果生效返回的信息类似下面这样</p><div class="code-wrapper"><pre><code class="hljs bash">Registry Mirrors: https://hub-mirror.c.163.com/</code></pre></div>]]></content>
    
    
    
    <tags>
      
      <tag>nas</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>OpenLib-c++</title>
    <link href="/2021/12/26/OpenLib-c/"/>
    <url>/2021/12/26/OpenLib-c/</url>
    
    <content type="html"><![CDATA[<div class="toc"><!-- toc --><ul><li><a href="#kai-yuan-c-ku-lie-biao">开源 C++ 库列表</a><ul><li><a href="#bao-guan-li-qi">包管理器</a></li><li><a href="#ku">库</a></li><li><a href="#yin-pin">音频</a></li><li><a href="#xing-neng-ce-shi">性能测试</a></li><li><a href="#tong-xin">通信</a></li><li><a href="#bing-fa">并发</a></li><li><a href="#pei-zhi">配置</a></li><li><a href="#rong-qi">容器</a></li><li><a href="#mi-ma-xue">密码学</a></li><li><a href="#shu-ju-ku">数据库</a></li><li><a href="#qian-ru-yu-yan-bang-ding">嵌入语言绑定</a></li><li><a href="#qian-ru-shi-shi-shi">嵌入式/实时</a></li><li><a href="#wen-jian-yuan-shu-ju">文件元数据</a></li><li><a href="#jin-rong-ji-suan">金融计算</a></li><li><a href="#you-xi-yin-qing-jia-gou">游戏引擎架构</a></li><li><a href="#tong-yong-duo-mei-ti">通用多媒体</a></li><li><a href="#tong-yong">通用</a></li><li><a href="#gps">GPS</a></li><li><a href="#tu-xing-yong-hu-jie-mian">图形用户界面</a></li><li><a href="#tu-xing">图形</a></li><li><a href="#tu-xiang">图像</a></li><li><a href="#3d-tu-xing">3D 图形</a></li><li><a href="#tu-xiang-chu-li">图像处理</a></li><li><a href="#guo-ji-hua">国际化</a></li><li><a href="#ji-lu">记录</a></li><li><a href="#shu-xue">数学</a></li><li><a href="#yuan-bian-cheng">元编程</a></li><li><a href="#pdf">PDF</a></li><li><a href="#wu-li-yu-mo-ni">物理与模拟</a></li><li><a href="#xu-lie-hua">序列化</a></li><li><a href="#pai-xu">排序</a></li><li><a href="#zhong-duan">终端</a></li><li><a href="#ce-shi">测试</a></li><li><a href="#wen-ben">文本</a></li><li><a href="#ban-ben-kong-zhi">版本控制</a></li><li><a href="#shi-pin">视频</a></li><li><a href="#web">Web</a></li></ul></li></ul><!-- tocstop --></div><h1><span id="kai-yuan-c-ku-lie-biao">开源 C++ 库列表</span><a href="#kai-yuan-c-ku-lie-biao" class="header-anchor">#</a></h1><p>&lt; <a href="mk:@MSITStore:C:\Users\txt1994\Downloads\cppreference-zh-20210212-dev.chm::/chmhelp/cpp.html">cpp</a>‎ | <a href="mk:@MSITStore:C:\Users\txt1994\Downloads\cppreference-zh-20210212-dev.chm::/chmhelp/cpp-links.html">links</a></p><p>此页面的目的是构建开源 C++ 库的比较列表，使得人们在需要特定功能的实现时，不必浪费时间在网上（ DuckDuckGo 、谷歌、必应等）搜索。</p><p>若你知道可能对其他人有用的库，请在此添加到它的链接。能包含进来的库没有限制，但是必须能便捷地下载库的源码。</p><p>以“原态”提供此页面——希望这有用，但不提供任何担保。过时、误导或错误的链接可能出现于此。若你注意到这些错误，则改正它会很有意义。</p><h2><span id="bao-guan-li-qi">包管理器</span><a href="#bao-guan-li-qi" class="header-anchor">#</a></h2><table><thead><tr><th>Package manager</th><th>Description</th></tr></thead><tbody><tr><td><a href="https://build2.org/">build2</a></td><td>一个开源的 (MIT)、跨平台的构建工具链，旨在为开发和打包 C/C++ 项目时提供如 Rust Cargo 一样的便利性。</td></tr><tr><td><a href="https://cget.readthedocs.io/en/latest/">cget</a></td><td>Cmake 包检索工具，可用于下载并安装 Cmake 包。</td></tr><tr><td><a href="https://github.com/scapix-com/cmodule">cmodule</a></td><td>非侵入式 CMake 依赖管理。</td></tr><tr><td><a href="https://conan.io/">conan</a></td><td>去中心化、开源 (MIT) 的 C/C++ 包管理器。</td></tr><tr><td><a href="https://github.com/TheLartians/CPM.cmake">CPM.cmake</a></td><td>一段可以为 CMake 加入依赖管理功能的 CMake 脚本。它是作为 CMake 的 FetchContent 模块的一个简单包装构建的。该模块加入了版本控制、缓存、简单 API 等功能。</td></tr><tr><td><a href="https://hunter.readthedocs.io/en/latest/">hunter</a></td><td>一个 CMake 驱动的跨平台包管理器，服务于 C/C++ 项目。</td></tr><tr><td><a href="https://spack.io/">spack</a></td><td>一个超级计算机、Linux、macOS 平台的包管理器。它使得安装科学软件变得简单。非绑定于某一特定语言。</td></tr><tr><td><a href="https://bitbucket.org/benman/teaport">teaport</a></td><td>一个受 cocoapods 启发的依赖管理器。</td></tr><tr><td><a href="https://docs.microsoft.com/en-us/cpp/vcpkg">vcpkg</a></td><td>一个 Windows、Linux、macOS 平台的 C++ 包管理器。</td></tr></tbody></table><h2><span id="ku">库</span><a href="#ku" class="header-anchor">#</a></h2><h2><span id="yin-pin">音频</span><a href="#yin-pin" class="header-anchor">#</a></h2><table><thead><tr><th>库名</th><th>简述</th><th>协议</th><th>配置手段</th></tr></thead><tbody><tr><td><a href="https://github.com/zsiciarz/aquila">Aquila</a></td><td>Aquila 是一个开源、跨平台的 C++11 DSP 库。</td><td>MIT 许可</td><td>CMake</td></tr><tr><td><a href="https://essentia.upf.edu/index.html">Essentia</a></td><td>开源库，音频和音乐分析、描述和合成工具 (MIR) <a href="https://github.com/MTG/essentia">(源码)</a></td><td><a href="http://www.gnu.org/licenses/agpl.html">Affero GPLv3</a></td><td></td></tr><tr><td><a href="http://www.fftw.org/">FFTW</a></td><td>离散傅里叶变换 (DFT) 计算库 (SSE/SSE2/AVX/Altivec/ARM Neon)。 <a href="https://github.com/FFTW/fftw3">(源码)</a></td><td>GPL-2.0</td><td>CMake</td></tr><tr><td><a href="https://www.kfrlib.com/">KFR</a></td><td>快速、现代、C++17、开源并且跨平台的 DSP/DFT 框架。支持音频重采样、 FIR/IIR 滤波器、二阶滤波器, (SSE, AVX, AVX-512, ARM NEON)。 <a href="https://github.com/kfrlib/kfr">(源码)</a></td><td>GPL-2.0</td><td>CMake</td></tr><tr><td><a href="http://www.surina.net/soundtouch/">soundtouch</a></td><td>SoundTouch 是一个开源、跨平台的音频处理库，用于更改音频流或音频文件的速度、音调和播放速率。 <a href="https://gitlab.com/soundtouch/soundtouch">(源码)</a></td><td><a href="https://www.gnu.org/licenses/old-licenses/lgpl-2.1.html">LGPL-2.1</a></td><td>Makefile</td></tr></tbody></table><ul><li>音频指纹</li></ul><table><thead><tr><th>库名</th><th>简述</th><th>协议</th><th>配置手段</th></tr></thead><tbody><tr><td><a href="https://acoustid.org/chromaprint">chromaprint</a></td><td><a href="https://github.com/acoustid/chromaprint">(源码)</a></td><td>MIT 许可, LGPL 2.1</td><td>CMake</td></tr><tr><td><a href="https://musicbrainz.org/doc/libmusicbrainz">libmusicbrainz</a></td><td><a href="https://github.com/metabrainz/libmusicbrainz">(源码)</a></td><td>LGPL-2.1</td><td>CMake</td></tr><tr><td><a href="https://github.com/tanob/libofa/">libofa</a></td><td>MusicIP 开源音频指纹库</td><td><a href="https://github.com/tanob/libofa/blob/master/COPYING">APL</a></td><td>makefile</td></tr></tbody></table><ul><li>格式</li></ul><table><thead><tr><th>库名</th><th>简述</th><th>协议</th><th>配置手段</th></tr></thead><tbody><tr><td><a href="http://audiofile.68k.org/">audiofile</a></td><td></td><td>LGPL-2.1</td><td>makefile</td></tr><tr><td><a href="https://xiph.org/flac/">flac</a></td><td></td><td><a href="http://opensource.org/docs/definition.php">Open Source</a>, BSD 许可, GPL 许可</td><td></td></tr><tr><td><a href="http://www.mega-nerd.com/libsndfile/">libsndfile</a></td><td></td><td>LGPL v2.0 or v3.0</td><td></td></tr></tbody></table><ul><li>标签</li></ul><table><thead><tr><th>库名</th><th>简述</th><th>协议</th><th>配置手段</th></tr></thead><tbody><tr><td><a href="http://id3lib.sourceforge.net/">id3lib</a></td><td></td><td>LGPL v2</td><td></td></tr><tr><td><a href="https://taglib.org/">taglib</a></td><td><a href="https://github.com/taglib/taglib">(源码)</a></td><td><a href="http://www.gnu.org/licenses/lgpl.html">LGPL</a> 和 <a href="http://www.mozilla.org/MPL/MPL-1.1.html">MPL v1.1</a></td><td></td></tr></tbody></table><ul><li>CD</li></ul><table><thead><tr><th>库名</th><th>简述</th><th>协议</th><th>配置手段</th></tr></thead><tbody><tr><td><a href="https://github.com/KDE/libkcompactdisc">libkcompactdisc</a></td><td>CD 接口库</td><td>GPL v2.0</td><td>CMake</td></tr></tbody></table><h2><span id="xing-neng-ce-shi">性能测试</span><a href="#xing-neng-ce-shi" class="header-anchor">#</a></h2><table><thead><tr><th>库名</th><th>简述</th><th>协议</th><th>配置手段</th></tr></thead><tbody><tr><td><a href="https://github.com/google/benchmark">benchmark</a></td><td></td><td>Apache2.0 许可</td><td>CMake</td></tr><tr><td><a href="https://github.com/DigitalInBlue/Celero">Celero</a></td><td></td><td>Apache 许可</td><td>CMake</td></tr><tr><td><a href="https://github.com/gperftools/gperftools">gperftools</a></td><td>“谷歌性能工具”包含高性能、多线程的 malloc 实现加上评测堆分配和 CPU 利用的工具。</td><td>BSD 3-Clause “New” or “Revised” License</td><td>configure</td></tr><tr><td><a href="https://github.com/mattreecebentley/plf_nanotimer">plf::nanotimer</a></td><td>用于性能评测的最低开销、跨平台的简单定时器类。</td><td>zlib 许可</td><td></td></tr></tbody></table><h2><span id="tong-xin">通信</span><a href="#tong-xin" class="header-anchor">#</a></h2><table><thead><tr><th>库名</th><th>简述</th><th>协议</th><th>配置手段</th></tr></thead><tbody><tr><td><a href="https://www.dre.vanderbilt.edu/~schmidt/ACE.html">ACE</a></td><td>异步网络、多路分离、报文发送</td><td></td><td></td></tr><tr><td><a href="https://thrift.apache.org/">Apache Thrift</a></td><td>Apache Thrift 软件框架，用于规模可变的跨语言服务开发，将软件栈与代码生成引擎结合，构建有效而无缝地在 C++ 、 Java 、 Python 、 PHP 、 Ruby 、 Erlang 、 Perl 、 Haskell 、 C# 、 Cocoa 、 JavaScript 、 Node.js 、 Smalltalk 、 Ocaml 、 Delphi 及其他语言间工作的服务。</td><td></td><td></td></tr><tr><td><a href="http://boost.org/libs/asio/">Boost.Asio</a></td><td>异步及同步网络、定时器、序列 I/O</td><td><a href="https://www.boost.org/LICENSE_1_0.txt">BSL-1.0</a></td><td></td></tr><tr><td><a href="http://boost.org/libs/beast/">Boost.Beast</a></td><td>建立于 Boost.Asio 顶上的 HTTP 及 WebSocket 库</td><td><a href="https://www.boost.org/LICENSE_1_0.txt">BSL-1.0</a></td><td></td></tr><tr><td><a href="https://github.com/Organic-Code/Breep">Breep</a></td><td>基于事件、高层、点对点库，允许用户直接发送和接收对象。</td><td>European Union Public License 1.1</td><td>CMake</td></tr><tr><td><a href="https://github.com/Microsoft/cpprestsdk">C++ REST SDK</a></td><td>异步 HTTP 客户端及监听器、异步 Stream 、 URI 、 JSON</td><td>MIT 许可</td><td>CMake</td></tr><tr><td><a href="https://github.com/cpp-netlib/cpp-netlib">cpp-netlib</a></td><td>cpp-netlib ： C++ 网络库</td><td><a href="https://www.boost.org/LICENSE_1_0.txt">BSL-1.0</a></td><td>CMake</td></tr><tr><td><a href="https://github.com/whoshuu/cpr">cpr</a></td><td>现代 C++ HTTP 请求库</td><td>MIT 许可</td><td>CMake</td></tr><tr><td><a href="https://github.com/ipkn/crow">Crow</a></td><td></td><td>BSD-3-Clause</td><td>CMake</td></tr><tr><td><a href="http://www.curlpp.org/">curlpp</a></td><td>CURL 库的 C++ 包装</td><td></td><td></td></tr><tr><td><a href="https://github.com/pdumais/DumaisLib">DumaisLib</a></td><td></td><td>MIT 许可</td><td>Makefile</td></tr><tr><td><a href="https://github.com/sony/easyhttpcpp">EasyHttp</a></td><td>跨平台的 HTTP 客户端库，专注于可用性和速度，支持 http 响应缓存及更多</td><td>MIT 许可</td><td>CMake</td></tr><tr><td><a href="https://github.com/continental/ecal">eCAL</a></td><td>高性能进程间通信</td><td>Apache2.0 许可</td><td>CMake</td></tr><tr><td><a href="https://github.com/continental/fineftp-server">fineftp-server</a></td><td></td><td>MIT 许可</td><td>CMake</td></tr><tr><td><a href="https://grpc.io/">gRPC</a></td><td></td><td></td><td></td></tr><tr><td><a href="http://gsoap2.sourceforge.net/">gsoap</a></td><td>XML 数据绑定、快速 WSDL/SOAP/XML 网络服务、 WS 安全、 JSON/XML-RPC RESTful 服务的 C/C++ 开发工具套</td><td></td><td></td></tr><tr><td><a href="https://github.com/daedric/httpp">HTTPP</a></td><td>简单、生产就绪的构建在 Boost 上的 HTTP 服务器，及构建在 libcurl 上的客户端。</td><td>BSD 2-Clause “Simplified” License</td><td>CMake, Makefile</td></tr><tr><td><a href="https://github.com/machinezone/IXWebSocket">IXWebSocket</a></td><td>无依赖的开源 WebSocket + HTTP 库，支持 SSL 和逐条消息 deflate 的 WebSocket 扩展。</td><td>BSD 3-Clause “New” or “Revised” License</td><td>CMake, Makefile</td></tr><tr><td><a href="https://github.com/skywind3000/kcp/blob/master/README.en.md">KCP</a></td><td>快速可靠的 ARQ 协议，帮助应用减少网络延迟。</td><td>MIT 许可</td><td>CMake</td></tr><tr><td><a href="https://github.com/tghosgor/libashttp">libashttp</a></td><td>异步 HTTP 客户端库</td><td>GNU Lesser General Public License v3.0</td><td></td></tr><tr><td><a href="https://github.com/titi38/libnavajo">libnavajo</a></td><td></td><td>CeCILL-C FREE SOFTWARE LICENSE AGREEMENT</td><td>CMake</td></tr><tr><td><a href="https://libtins.github.io/">libtins</a></td><td>网络包装制作及嗅探库</td><td></td><td></td></tr><tr><td><a href="https://nanomsg.org/">nanomsg</a></td><td></td><td></td><td></td></tr><tr><td><a href="https://github.com/gmlc-tdc/netif">netif</a></td><td></td><td>BSD 3-Clause “New” or “Revised” License</td><td>CMake</td></tr><tr><td><a href="https://github.com/nghttp2/nghttp2">nghttp2</a></td><td>HTTP/2 C 库及工具（服务器、客户端、代理和评测工具）</td><td>MIT 许可</td><td>CMake, configure</td></tr><tr><td><a href="https://github.com/loentar/ngrest">ngrest</a></td><td>快速而简易的利用 JSON 的 RESTful 网络服务框架</td><td>Apache2.0 许可</td><td>CMake</td></tr><tr><td><a href="https://nng.nanomsg.org/">nng</a></td><td></td><td></td><td></td></tr><tr><td><a href="http://omniorb.sourceforge.net/">omniORB</a></td><td>最快速、完整而可移植的 CORBA ORB 在 C++ 中的实现</td><td></td><td></td></tr><tr><td><a href="http://www.opendds.org/">OpenDDS</a></td><td>DDS 实现</td><td></td><td></td></tr><tr><td><a href="https://github.com/eclipse/paho.mqtt.cpp/">Paho MQTT</a></td><td></td><td></td><td>CMake</td></tr><tr><td><a href="http://seladb.github.io/PcapPlusPlus-Doc/">PcapPlusPlus</a></td><td>多平台 C++ 网络嗅探和包装分析及制作框架</td><td></td><td></td></tr><tr><td><a href="http://pocoproject.org/">POCO</a></td><td>网络：加密、 HTTP ； ZIP 文件</td><td></td><td></td></tr><tr><td><a href="https://github.com/topcpporg/rest_rpc">rest_rpc</a></td><td>现代、简单、易用的 rpc 框架</td><td></td><td>CMake</td></tr><tr><td><a href="https://github.com/corvusoft/restbed">restbed</a></td><td>设计以嵌入到宽范围的应用中的 C++ 为框架。</td><td><a href="https://github.com/Corvusoft/restbed/blob/master/LICENSE">许可协议</a></td><td>CMake</td></tr><tr><td><a href="https://github.com/jgaa/restc-cpp">restc-cpp</a></td><td>将痛苦从自 C++ 访问 JSON API 带走。 HTTP 客户端，原生 C++ 类到/自 JSON 的序列化，通过 boost::asio coroutines 携程的异步 IO 。 C++14 。</td><td>MIT 许可</td><td>CMake</td></tr><tr><td><a href="https://github.com/logandk/restful_mapper">restful_mapper</a></td><td>于 C++ 中消费 RESTful JSON API 的 ORM</td><td></td><td>CMake, Makefile</td></tr><tr><td><a href="https://github.com/scylladb/seastar">seastar</a></td><td>用C++11实现的高性能异步编程框架。</td><td>Apache2.0 许可</td><td>CMake, etc.</td></tr><tr><td><a href="http://siliconframework.org/">Silicon</a></td><td>快速而稳健的 Web APIs</td><td>MIT 许可</td><td>CMake</td></tr><tr><td><a href="https://github.com/fpagliughi/sockpp">sockpp</a></td><td>简单的现代 C++ 套接库</td><td>BSD 3-Clause “New” or “Revised” License</td><td>CMake</td></tr><tr><td><a href="https://github.com/pdumais/rest">Simple C++ REST library</a></td><td>在你的 C++ 应用中创建 REST API 的非常简单且自成文档的库</td><td></td><td></td></tr><tr><td><a href="https://github.com/TinkoffCreditSystems/stream-client">stream-client</a></td><td>轻量、唯头文件的、基于 Boost 的客户端 socket/connector/socket pool/resolver</td><td>Apache2.0 许可</td><td>CMake</td></tr><tr><td><a href="https://github.com/Cylix/tacopie/">tacopie</a></td><td>C++11 TCP 库</td><td>MIT 许可</td><td>CMake</td></tr><tr><td><a href="https://www.dre.vanderbilt.edu/~schmidt/TAO.html">TAO</a></td><td>CORBA</td><td></td><td></td></tr><tr><td><a href="https://www.taox11.org/">taox11</a></td><td>基于 C++11 的 CORBA 实现</td><td>MIT 许可</td><td></td></tr><tr><td><a href="http://libunicomm.org/">Unicomm</a></td><td>异步网络、高层 TCP 交互框架</td><td></td><td></td></tr><tr><td><a href="https://github.com/skypjack/uvw">uvw</a></td><td>现代 C++ 书写的 libuv</td><td>MIT 许可</td><td>CMake</td></tr><tr><td><a href="https://github.com/apenwarr/wvstreams">wvstreams</a></td><td></td><td>GPL 许可</td><td></td></tr><tr><td><a href="http://zeromq.org/">zeromq</a></td><td>快速消息队列</td><td></td><td></td></tr></tbody></table><h2><span id="bing-fa">并发</span><a href="#bing-fa" class="header-anchor">#</a></h2><table><thead><tr><th>库名</th><th>简述</th><th>协议</th><th>配置手段</th></tr></thead><tbody><tr><td><a href="https://github.com/CodeExMachina/BlockingCollection">BlockingCollection</a></td><td>C++11 线程安全汇集类，模仿 .Net BlockingCollection。</td><td></td><td></td></tr><tr><td><a href="https://www.boost.org/doc/libs/release/doc/html/atomic.html">Boost.Atomic</a></td><td></td><td><a href="https://www.boost.org/LICENSE_1_0.txt">BSL-1.0</a></td><td></td></tr><tr><td><a href="https://github.com/kylelutz/compute">Boost.Compute</a></td><td>（非官方） OpenCL 的仿 STL 算法及数据结构</td><td><a href="https://www.boost.org/LICENSE_1_0.txt">BSL-1.0</a></td><td></td></tr><tr><td><a href="https://www.boost.org/doc/libs/release/libs/context/doc/html/index.html">Boost.Context</a></td><td></td><td><a href="https://www.boost.org/LICENSE_1_0.txt">BSL-1.0</a></td><td></td></tr><tr><td><a href="https://www.boost.org/doc/libs/release/doc/html/interprocess.html">Boost.Interprocess</a></td><td></td><td><a href="https://www.boost.org/LICENSE_1_0.txt">BSL-1.0</a></td><td></td></tr><tr><td><a href="https://www.boost.org/doc/libs/release/doc/html/lockfree.html">Boost.Lockfree</a></td><td></td><td><a href="https://www.boost.org/LICENSE_1_0.txt">BSL-1.0</a></td><td></td></tr><tr><td><a href="https://www.boost.org/doc/libs/release/doc/html/mpi.html">Boost.MPI</a></td><td></td><td><a href="https://www.boost.org/LICENSE_1_0.txt">BSL-1.0</a></td><td></td></tr><tr><td><a href="https://www.boost.org/doc/libs/release/doc/html/thread.html">Boost.Thread</a></td><td></td><td><a href="https://www.boost.org/LICENSE_1_0.txt">BSL-1.0</a></td><td></td></tr><tr><td><a href="https://github.com/cpp-taskflow/cpp-taskflow">Cpp-Taskflow</a></td><td>带任务依赖的快速 C++ 并行编程</td><td></td><td></td></tr><tr><td><a href="https://github.com/illuhad/hipSYCL">hipSYCL</a></td><td></td><td>BSD-2-Clause License</td><td>CMake</td></tr><tr><td><a href="https://github.com/STEllAR-GROUP/hpx/">HPX</a></td><td>任何规模的并行和分布式应用的通用 C++ 运行时系统</td><td></td><td></td></tr><tr><td><a href="http://threadingbuildingblocks.org/documentation.php">Intel TBB</a></td><td></td><td></td><td></td></tr><tr><td><a href="https://github.com/kokkos/kokkos">KOKKOS</a></td><td>C++ 中的编程模型，用于书写高性能的便携 HPC 应用</td><td></td><td></td></tr><tr><td><a href="http://www.open-mpi.org/">libopenmpi</a></td><td></td><td></td><td></td></tr><tr><td><a href="https://github.com/p12tic/libsimdpp">libsimdpp</a></td><td></td><td></td><td></td></tr><tr><td><a href="https://github.com/oleh-derevenko/mutexgear">MutexGear</a></td><td></td><td>The MutexGear Library License</td><td>configure, MSVC</td></tr><tr><td><a href="http://www.openmp.org/specifications/">OpenMP</a></td><td></td><td></td><td></td></tr><tr><td><a href="http://raftlib.io/">RaftLib</a></td><td>类似并发行动者的 C++ 流</td><td></td><td></td></tr><tr><td><a href="https://sourceforge.net/projects/sobjectizer/">SObjectizer</a></td><td>通过行动者和出版订阅模型，简化开发并发和事件驱动应用的 C++ 中的小型框架。</td><td></td><td></td></tr><tr><td><a href="https://github.com/benman64/subprocess">subprocess</a></td><td></td><td></td><td></td></tr><tr><td><a href="https://github.com/taskflow/taskflow">Taskflow</a></td><td></td><td></td><td></td></tr><tr><td><a href="http://thrust.github.io/">Thrust</a></td><td>CUDA 的仿 STL 算法及数据结构</td><td></td><td></td></tr><tr><td><a href="https://github.com/ddemidov/vexcl">VexCL</a></td><td>OpenCL 和 CUDA 的 C++ 表达式模板库</td><td></td><td></td></tr><tr><td><a href="http://viennacl.sourceforge.net/">ViennaCL</a></td><td>带 OpenMP 、 CUDA 及 OpenCL 后端的线性代数及算法</td><td></td><td></td></tr><tr><td><a href="https://github.com/mpoeter/xenium">Xenium</a></td><td></td><td></td><td></td></tr></tbody></table><h2><span id="pei-zhi">配置</span><a href="#pei-zhi" class="header-anchor">#</a></h2><table><thead><tr><th>库名</th><th>简述</th><th>协议</th><th>配置手段</th></tr></thead><tbody><tr><td><a href="https://www.boost.org/doc/libs/release/doc/html/program_options.html">Boost.Program_options</a></td><td></td><td><a href="https://www.boost.org/LICENSE_1_0.txt">BSL-1.0</a></td><td></td></tr><tr><td><a href="https://www.gtkmm.org/">gconfmm</a></td><td></td><td></td><td></td></tr><tr><td><a href="http://www.hyperrealm.com/libconfig/">libconfig</a></td><td></td><td></td><td></td></tr><tr><td><a href="https://madmurphy.github.io/libconfini/">libconfini</a></td><td>INI 分析器</td><td></td><td></td></tr></tbody></table><ul><li>XML</li></ul><table><thead><tr><th>库名</th><th>简述</th><th>协议</th><th>配置手段</th></tr></thead><tbody><tr><td><a href="https://github.com/CarloWood/ai-xml">ai-xml</a></td><td></td><td></td><td></td></tr><tr><td><a href="https://github.com/simulton/gpds">GPDS</a></td><td></td><td></td><td></td></tr><tr><td><a href="http://gsoap2.sourceforge.net/">gSOAP</a></td><td>XML 数据绑定</td><td></td><td></td></tr><tr><td><a href="http://libxmlplusplus.sourceforge.net/">libxml++</a></td><td></td><td></td><td></td></tr><tr><td><a href="http://pugixml.org/">pugixml</a></td><td></td><td></td><td></td></tr><tr><td><a href="http://www.grinninglizard.com/tinyxml/">tinyxml</a></td><td></td><td></td><td></td></tr><tr><td><a href="https://github.com/leethomason/tinyxml2/">tinyxml2</a></td><td>另一 TinyXML ，建设中。</td><td></td><td></td></tr><tr><td><a href="http://xerces.apache.org/xerces-c/">Xerces</a></td><td></td><td></td><td></td></tr></tbody></table><ul><li>JSON</li></ul><table><thead><tr><th>库名</th><th>简述</th><th>协议</th><th>配置手段</th></tr></thead><tbody><tr><td><a href="https://github.com/bblanchon/ArduinoJson">ArduinoJson</a></td><td>ArduinoJson</td><td></td><td></td></tr><tr><td><a href="http://cajun-jsonapi.sourceforge.net/">CAJUN</a></td><td></td><td></td><td></td></tr><tr><td><a href="http://www.digip.org/jansson/">jansson</a></td><td>Jansson 是编码、解码及操纵 JSON 数据的 C 库。</td><td></td><td></td></tr><tr><td><a href="https://github.com/jeaye/jeayeson">jeayeson</a></td><td>非常健全的（唯头文件） C++14 JSON 库</td><td></td><td></td></tr><tr><td><a href="https://github.com/castedo/jios">jios</a></td><td>JSON 输入输出流 (JSON Input Output Streams)</td><td>MIT 许可</td><td>CMake</td></tr><tr><td><a href="http://ddsbench.svn.sourceforge.net/viewvc/ddsbench/trunk/jost/">JOST</a></td><td></td><td></td><td></td></tr><tr><td><a href="http://tgockel.github.io/json-voorhees/">JSON Voorhees</a></td><td>C++ 的杀手 JSON</td><td></td><td></td></tr><tr><td><a href="https://github.com/nlohmann/json">json</a></td><td>Niels Lohmann JSON</td><td></td><td></td></tr><tr><td><a href="https://github.com/ascheglov/json-cpp">json-cpp</a></td><td></td><td></td><td></td></tr><tr><td><a href="https://github.com/dropbox/json11">json11</a></td><td>json11 是 C++11 的轻量 JSON 库，提供 JSON 分析及序列化。</td><td></td><td></td></tr><tr><td><a href="https://github.com/anhero/JsonBox">JsonBox</a></td><td></td><td></td><td></td></tr><tr><td><a href="https://github.com/danielaparker/jsoncons/">jsoncons</a></td><td>JSON 与类 JSON 数据结构的唯头文件库，含 JSON Pointer 、 JSON Patch 、 JSONPath 、 CSV 、 MessagePack 、 CBOR 、 BSON 、 UBJSON。</td><td></td><td></td></tr><tr><td><a href="https://github.com/open-source-parsers/jsoncpp">jsoncpp</a></td><td></td><td></td><td></td></tr><tr><td><a href="https://github.com/pibara/jsonme--">jsonme–</a></td><td></td><td></td><td></td></tr><tr><td><a href="https://sourceforge.net/projects/libjson/">libjson</a></td><td></td><td></td><td></td></tr><tr><td><a href="https://giacomodrago.github.io/minijson/">minijson</a></td><td>C++ 无 DOM 且免分配的 JSON 分析及序列化</td><td></td><td></td></tr><tr><td><a href="http://fossil.wanderinghorse.net/repos/nosjob/index.cgi/index">nosjob</a></td><td></td><td></td><td></td></tr><tr><td><a href="http://qjson.sourceforge.net/">qjson</a></td><td></td><td></td><td></td></tr><tr><td><a href="https://github.com/miloyip/rapidjson">rapidjson</a></td><td></td><td></td><td></td></tr><tr><td><a href="https://github.com/simdjson/simdjson">simdjson</a></td><td>每秒解析 GB 级别的 JSON</td><td></td><td></td></tr><tr><td><a href="https://github.com/bk192077/struct_mapping">struct_mapping</a></td><td></td><td></td><td></td></tr><tr><td><a href="https://github.com/Loki-Astari/ThorsSerializer">ThorsSerializer</a></td><td>JSON/YAML Input Output Streams</td><td>MIT 许可</td><td>Makefile</td></tr><tr><td><a href="https://bitbucket.org/awangk/ujson">ujson</a></td><td>µjson 是小型的 C++11、UTF-8 JSON 库</td><td></td><td></td></tr><tr><td><a href="http://www.zoolib.org/doc/">zoolib</a></td><td></td><td></td><td></td></tr><tr><td><a href="https://github.com/MistEO/meojson">meojson</a></td><td>json简单库，作者<a href="https://www.misteo.top/">MistEo</a></td><td>MIT许可</td><td>Cmake, Makefile</td></tr></tbody></table><ul><li>YAML</li></ul><table><thead><tr><th>库名</th><th>简述</th><th>协议</th><th>配置手段</th></tr></thead><tbody><tr><td><a href="https://github.com/jbeder/yaml-cpp">yaml-cpp</a></td><td></td><td></td><td></td></tr></tbody></table><ul><li>TOML</li></ul><table><thead><tr><th>库名</th><th>简述</th><th>协议</th><th>配置手段</th></tr></thead><tbody><tr><td><a href="https://marzer.github.io/tomlplusplus/">toml++</a></td><td></td><td></td><td></td></tr><tr><td><a href="https://github.com/ToruNiina/toml11">toml11</a></td><td>基于 C++11 的 TOML 解析库</td><td></td><td></td></tr></tbody></table><ul><li>HOCON</li></ul><table><thead><tr><th>库名</th><th>简述</th><th>协议</th><th>配置手段</th></tr></thead><tbody><tr><td><a href="https://github.com/puppetlabs/cpp-hocon/tree/master/lib/src">cpp-hocon</a></td><td>Pupplet 开发的 HOCON 格式的 C++ 实现。</td><td></td><td></td></tr></tbody></table><ul><li>CSS</li></ul><table><thead><tr><th>库名</th><th>简述</th><th>协议</th><th>配置手段</th></tr></thead><tbody><tr><td><a href="https://github.com/lexborisov/mycss">mycss</a></td><td>CSS 解析器</td><td></td><td></td></tr></tbody></table><h2><span id="rong-qi">容器</span><a href="#rong-qi" class="header-anchor">#</a></h2><table><thead><tr><th>库名</th><th>简述</th><th>协议</th><th>配置手段</th></tr></thead><tbody><tr><td><a href="https://www.boost.org/doc/libs/release/libs/bimap/">Boost.Bimap</a></td><td></td><td><a href="https://www.boost.org/LICENSE_1_0.txt">BSL-1.0</a></td><td></td></tr><tr><td><a href="https://www.boost.org/doc/libs/release/libs/container/">Boost.Container</a></td><td></td><td><a href="https://www.boost.org/LICENSE_1_0.txt">BSL-1.0</a></td><td></td></tr><tr><td><a href="https://www.boost.org/doc/libs/release/libs/fusion/">Boost.Fusion</a></td><td></td><td><a href="https://www.boost.org/LICENSE_1_0.txt">BSL-1.0</a></td><td></td></tr><tr><td><a href="https://www.boost.org/doc/libs/release/libs/heap/">Boost.Heap</a></td><td></td><td><a href="https://www.boost.org/LICENSE_1_0.txt">BSL-1.0</a></td><td></td></tr><tr><td><a href="https://www.boost.org/doc/libs/release/libs/ptr_container/">Boost.Pointer Container</a></td><td></td><td><a href="https://www.boost.org/LICENSE_1_0.txt">BSL-1.0</a></td><td></td></tr><tr><td><a href="https://www.boost.org/doc/libs/release/libs/tuple/">Boost.Tuple</a></td><td></td><td><a href="https://www.boost.org/LICENSE_1_0.txt">BSL-1.0</a></td><td></td></tr><tr><td><a href="https://www.boost.org/doc/libs/release/libs/variant/">Boost.Variant</a></td><td></td><td><a href="https://www.boost.org/LICENSE_1_0.txt">BSL-1.0</a></td><td></td></tr><tr><td><a href="https://github.com/diegocaro/cpp-btree/">cpp-btree</a></td><td>btree_map 、 btree_set 、 btree_multimap 、 btree_multiset 。</td><td></td><td></td></tr><tr><td><a href="https://github.com/hosseinmoein/DataFrame">DataFrame</a></td><td>C++ DataFrame —— 现代 C++ 中使用原生类型、连续内存存储，且无虚函数的 R 与 Pandas 数据框架。</td><td></td><td></td></tr><tr><td><a href="https://github.com/eggs-cpp/variant">eggs::variant</a></td><td>Eggs.Variant 是 C++11/14 的泛型、线程安全、有区别的联合体。值得注意的是它有很好的 constexpr 支持。</td><td></td><td></td></tr><tr><td><a href="https://github.com/serge-sans-paille">Frozen</a></td><td>constexpr 完美基于哈希的冻结集合与映射（ Apache 2.0 ）。</td><td></td><td></td></tr><tr><td><a href="https://github.com/arximboldi/immer">Immer</a></td><td></td><td>Boost License</td><td>CMake</td></tr><tr><td><a href="http://www.plflib.org/colony.htm">plf::colony</a></td><td>无序的“类背包”容器，在高度修改场景中性能优于 std:: 容器，同时维护指向未被擦除元素的合法指针，无关乎插入或擦除。</td><td></td><td></td></tr><tr><td><a href="http://www.plflib.org/list.htm">plf::list</a></td><td>std::list 实现，为缓存友好牺牲范围切割，导致更快的插入、擦除和迭代。</td><td></td><td></td></tr><tr><td><a href="http://www.plflib.org/stack.htm">plf::stack</a></td><td>std::stack 容器适配器的随意访问替换容器，在栈环境中有优于 std::vector 和 std::deque 的性能。</td><td></td><td></td></tr><tr><td><a href="https://github.com/martinmoene/ring-span-lite">ring_span</a></td><td>Guy Davidson 与 Arthur O’Dwyer 的 ring_span ——即环状缓冲区视图的简化实现。</td><td></td><td></td></tr><tr><td><a href="https://github.com/cbeck88/strict-variant">strict_variant</a></td><td>快速而决不空的 variant ，目标 C++11 。阻止许多不想要的隐式转换。</td><td></td><td></td></tr><tr><td><a href="https://sites.google.com/a/tdhgis.com/tdhlistsapi/">TdhLists</a></td><td></td><td></td><td></td></tr><tr><td><a href="https://github.com/tinloaf/ygg">Ygg</a></td><td>高性能容器和数据结构，例如红黑树、区间数和区间映射的侵入式 C++11 实现。</td><td></td><td></td></tr></tbody></table><h2><span id="mi-ma-xue">密码学</span><a href="#mi-ma-xue" class="header-anchor">#</a></h2><table><thead><tr><th>库名</th><th>简述</th><th>协议</th><th>配置手段</th></tr></thead><tbody><tr><td><a href="https://botan.randombit.net/">Botan</a></td><td></td><td></td><td></td></tr><tr><td><a href="https://www.cryptopp.com/">crypto++</a></td><td></td><td></td><td></td></tr><tr><td><a href="https://www.gnutls.org/">gnutls</a></td><td></td><td></td><td></td></tr><tr><td><a href="https://www.openssl.org/">openssl</a></td><td></td><td></td><td></td></tr><tr><td><a href="https://github.com/libtom/libtomcrypt">TomCrypt</a></td><td></td><td></td><td></td></tr></tbody></table><h2><span id="shu-ju-ku">数据库</span><a href="#shu-ju-ku" class="header-anchor">#</a></h2><table><thead><tr><th>库名</th><th>简述</th><th>协议</th><th>配置手段</th></tr></thead><tbody><tr><td><a href="https://github.com/sewenew/redis-plus-plus">redis-plus-plus</a></td><td>用C++ 11编写的Redis客户端, 支持Redis Sentinel，Redis Cluster，管道，事务，发布订阅，连接池以及类似于STL的接口</td><td></td><td></td></tr><tr><td><a href="https://github.com/Cylix/cpp_redis/">cpp-redis</a></td><td>C++11 轻量的 Redis 客户端：异步、线程安全、无依赖、管道化、多平台。</td><td></td><td></td></tr><tr><td><a href="http://otl.sourceforge.net/">OTL</a></td><td></td><td></td><td></td></tr><tr><td><a href="http://dtemplatelib.sourceforge.net/">DTL</a></td><td></td><td></td><td></td></tr><tr><td><a href="http://pqxx.org/development/libpqxx/">libpqxx</a></td><td></td><td></td><td></td></tr><tr><td><a href="https://github.com/bendiken/lmdbxx">lmdb++</a></td><td>LMDB 嵌入式 B+ 树数据库的 C++11 包装。</td><td></td><td></td></tr><tr><td><a href="https://github.com/mongodb/mongo-cxx-driver/tree/master">mongocxx</a></td><td>MongoDB 的 C++11 驱动库</td><td></td><td></td></tr><tr><td><a href="https://dev.mysql.com/">mysql++</a></td><td></td><td></td><td></td></tr><tr><td><a href="https://www.codesynthesis.com/products/odb/">ODB - C++ Object-Relational Mapping (ORM)</a></td><td></td><td></td><td></td></tr><tr><td><a href="https://github.com/dmitigr/pgfe/">Pgfe - PostGres FrontEnd</a></td><td>现代 C++ 客户端 API 到 PostgreSQL</td><td></td><td></td></tr><tr><td><a href="http://quince-lib.com/">QUINCE: QUeries IN C++ Expressions (ORM+EDSL)</a></td><td></td><td></td><td></td></tr><tr><td><a href="https://www.qxorm.com/">QxOrm - C++ Qt Object-Relational Mapping (ORM)</a></td><td></td><td></td><td></td></tr><tr><td><a href="http://soci.sourceforge.net/">SOCI</a></td><td></td><td></td><td></td></tr><tr><td><a href="https://github.com/rbock/sqlpp11">sqlpp11</a></td><td></td><td></td><td></td></tr><tr><td><a href="http://www.sqlapi.com/">SQLAPI++</a></td><td></td><td></td><td></td></tr><tr><td><a href="https://github.com/kramolnic/EasyQtSql">EasyQtSql</a></td><td>轻量唯头文件 C++11 库，用 QtSql 快速便捷地进行 SQL 查询</td><td></td><td></td></tr><tr><td><a href="https://github.com/google/leveldb">LevelDB</a></td><td>谷歌开发的、能够处理十亿级别规模 Key-Value 型数据持久性存储的C++ 程序库。</td><td></td><td></td></tr></tbody></table><h2><span id="qian-ru-yu-yan-bang-ding">嵌入语言绑定</span><a href="#qian-ru-yu-yan-bang-ding" class="header-anchor">#</a></h2><table><thead><tr><th>库名</th><th>简述</th><th>协议</th><th>配置手段</th></tr></thead><tbody><tr><td><a href="https://github.com/ChaiScript/ChaiScript">ChaiScript</a></td><td></td><td></td><td></td></tr><tr><td><a href="http://partow.net/programming/exprtk/index.html">ExprTk</a></td><td></td><td></td><td></td></tr><tr><td><a href="http://www.lua.org/">lua</a></td><td></td><td></td><td></td></tr><tr><td><a href="https://github.com/ThePhD/sol2">sol2</a></td><td></td><td></td><td></td></tr><tr><td><a href="http://angelcode.com/angelscript/">AngelScript</a></td><td>类似 C++ 的脚本语言。</td><td></td><td></td></tr><tr><td><a href="http://www.mozilla.org/js/spidermonkey/">mozjs</a></td><td></td><td></td><td></td></tr><tr><td><a href="http://muparser.sourceforge.net/">muparser</a></td><td></td><td></td><td></td></tr><tr><td><a href="http://pythonqt.sourceforge.net/">PythonQt</a></td><td></td><td></td><td></td></tr><tr><td><a href="https://github.com/Baduit/ScriptCaller">ScriptCaller</a></td><td>允许程序员调用 Ruby 脚本的唯头文件库。</td><td></td><td></td></tr><tr><td><a href="https://github.com/pmed/v8pp">v8pp</a></td><td>将 C++ 函数和类绑定到 V8 JavaScript引擎中。</td><td></td><td></td></tr></tbody></table><h2><span id="qian-ru-shi-shi-shi">嵌入式/实时</span><a href="#qian-ru-shi-shi-shi" class="header-anchor">#</a></h2><table><thead><tr><th>库名</th><th>简述</th><th>协议</th><th>配置手段</th></tr></thead><tbody><tr><td><a href="http://sourceforge.net/projects/qpc/files/QP_C%2B%2B/4.5.04/">QP/C++</a></td><td>RTOS 内核，双重 GPL</td><td></td><td></td></tr><tr><td><a href="http://www.etlcpp.com/">ETL - Embedded Template Library</a></td><td>C++03 ，为少资源平台裁剪的可移植模板库</td><td></td><td></td></tr><tr><td><a href="http://distortos.org/">distortos</a></td><td>微控制器的面向对象 C++ RTOS</td><td></td><td></td></tr><tr><td><a href="https://github.com/hutorny/micurest">µcuREST</a></td><td>微控制器的 C++11 REST/JSON 服务器框架</td><td></td><td></td></tr></tbody></table><h2><span id="wen-jian-yuan-shu-ju">文件元数据</span><a href="#wen-jian-yuan-shu-ju" class="header-anchor">#</a></h2><table><thead><tr><th>库名</th><th>简述</th><th>协议</th><th>配置手段</th></tr></thead><tbody><tr><td><a href="https://www.kde.org/">libkexiv2</a></td><td></td><td></td><td></td></tr><tr><td><a href="http://www.exiv2.org/">exiv2</a></td><td></td><td></td><td></td></tr><tr><td><a href="http://libopenraw.freedesktop.org/wiki/Exempi">exempi</a></td><td></td><td></td><td></td></tr><tr><td><a href="https://rarian.freedesktop.org/">rarian</a></td><td></td><td></td><td></td></tr></tbody></table><h2><span id="jin-rong-ji-suan">金融计算</span><a href="#jin-rong-ji-suan" class="header-anchor">#</a></h2><table><thead><tr><th>库名</th><th>简述</th><th>协议</th><th>配置手段</th></tr></thead><tbody><tr><td><a href="http://www.quantlib.org/">QuantLib - Quantitative finance library</a></td><td></td><td></td><td></td></tr><tr><td><a href="https://github.com/hosseinmoein/DataFrame">DataFrame</a></td><td>C++ DataFrame —— 现代 C++ 中使用原生类型、连续内存存储，且无虚函数的 R 与 Pandas 数据框架。</td><td></td><td></td></tr></tbody></table><h2><span id="you-xi-yin-qing-jia-gou">游戏引擎架构</span><a href="#you-xi-yin-qing-jia-gou" class="header-anchor">#</a></h2><table><thead><tr><th>库名</th><th>简述</th><th>协议</th><th>配置手段</th></tr></thead><tbody><tr><td><a href="https://github.com/alecthomas/entityx">EntityX</a></td><td></td><td></td><td></td></tr><tr><td><a href="https://github.com/miguelishawt/anax">Anax</a></td><td></td><td></td><td></td></tr><tr><td><a href="https://github.com/Yelnats321/EntityPlus">EntityPlus</a></td><td></td><td></td><td></td></tr><tr><td><a href="https://github.com/skypjack/entt">EnTT</a></td><td></td><td></td><td></td></tr><tr><td><a href="http://box2d.org/">BOX2D</a></td><td>物理引擎</td><td></td><td></td></tr></tbody></table><h2><span id="tong-yong-duo-mei-ti">通用多媒体</span><a href="#tong-yong-duo-mei-ti" class="header-anchor">#</a></h2><table><thead><tr><th>库名</th><th>简述</th><th>协议</th><th>配置手段</th></tr></thead><tbody><tr><td><a href="http://www.sfml-dev.org/index.php">SFML (Simple and Fast Multimedia Library)</a></td><td></td><td></td><td></td></tr><tr><td><a href="http://www.libsdl.org/">SDL (Simple DirectMedia Layer)</a></td><td>对音频、键盘、鼠标、操纵杆及图形硬件，经由平台上图形 API （通常为 OpenGL 或 Direct3D ）的跨平台低层访问（ zlib 许可）</td><td></td><td></td></tr><tr><td><a href="http://www.libsigil.com/">SIGIL (Sound, Input, and Graphics Integration Library)</a></td><td>文本、形状、输入、音频及 2D 图像的难以置信地简单的跨平台极简库</td><td></td><td></td></tr><tr><td><a href="http://libcinder.org/">Cinder</a></td><td></td><td></td><td></td></tr><tr><td><a href="http://www.openframeworks.cc/">openFrameworks</a></td><td></td><td></td><td></td></tr></tbody></table><h2><span id="tong-yong">通用</span><a href="#tong-yong" class="header-anchor">#</a></h2><table><thead><tr><th>库名</th><th>简述</th><th>协议</th><th>配置手段</th></tr></thead><tbody><tr><td><a href="https://www.boost.org/doc/libs">Boost</a></td><td>大量通用库的汇集</td><td>Boost 许可</td><td></td></tr><tr><td><a href="https://github.com/Microsoft/GSL">GSL</a></td><td>Guideline Support Library 实现，为 Bjarne Stroustrup, Herb Sutter 和 Co 在《 C++ 核心方针》中推荐</td><td></td><td></td></tr><tr><td><a href="https://github.com/bloomberg/bde">BDE</a></td><td>来自 Bloomberg L.P. 的 Bloomberg Development Environment 核心库</td><td>Apache 许可</td><td></td></tr><tr><td><a href="http://dlib.net/">Dlib</a></td><td>网络、线程、图形用户界面、数据结构、线性代数、机器学习、 XML 及文本分析、数值优化、贝叶斯网络和大量其他任务</td><td>Boost 许可</td><td></td></tr><tr><td><a href="http://www.juce.com/">JUCE</a></td><td>扩展性的成熟跨平台 C++ 工具套</td><td>GPL 许可</td><td></td></tr><tr><td><a href="http://loki-lib.sourceforge.net/">Loki</a></td><td>设计模式</td><td></td><td></td></tr><tr><td><a href="http://www.reasoning.biz/index.htm">Reason</a></td><td>xml 、 xpath 、正则表达式、线程、接头、 http 、 sql 、日期时间、流、编码与解码、文件系统、压缩</td><td>GPL 许可</td><td></td></tr><tr><td><a href="https://github.com/jll63/yomm2">yomm2</a></td><td>C++17 的开放式多方法</td><td>Boost 许可</td><td></td></tr><tr><td><a href="https://github.com/facebook/folly">Folly</a></td><td>Facebook 开源库。设计带有构思中的实践性和效率设计的 C++11 组件库。</td><td></td><td></td></tr><tr><td><a href="http://abseil.io/">Abseil</a></td><td>Google 设计以补足 C++ 标准库的开源 C++ 库代码汇集。</td><td></td><td></td></tr><tr><td><a href="http://ryan.gulix.cl/fossil.cgi/cxxomfort/">cxxomfort</a></td><td>C++ 特性逆向移植（ C++11 到 C++03 及 C++1y 提案到 C++11/C++03 ）。</td><td></td><td></td></tr><tr><td><a href="http://sourcey.com/libsourcey/">libsourcey</a></td><td>高速网络化和多媒体编码的跨平台 C++11 库。 HTTP 、 WebSockets 、 TURN 、 STUN 、 Symple 及更多……</td><td></td><td></td></tr><tr><td><a href="http://onposix.sourceforge.net/">OnPosix</a></td><td>在 POSIX 平台上提供各种抽象（例如线程、网络化、日志、 IPC 等）的 C++ 库。</td><td></td><td></td></tr><tr><td><a href="http://ultimatepp.org/">Ultimate++</a></td><td>跨平台的迅速应用开发框架</td><td></td><td></td></tr><tr><td><a href="https://github.com/actor-framework/actor-framework">CAF</a></td><td>C++ Actor Framework (CAF) 是开源的 C++11 行动者模型实现，特性为轻量而快速的行动者实现、消息的模式匹配、网络不可见消息传递及更多</td><td>BSD 许可</td><td></td></tr><tr><td><a href="https://github.com/carlomilanesi/cpp-mmf/">cpp-mmf</a></td><td>对 POSIX 或 Windows 封装映射到内存文件的 C++98 库</td><td></td><td></td></tr><tr><td><a href="https://github.com/daedric/commonpp">CommonPP</a></td><td>多用途库，强调在项目中得出度规。</td><td>BSD</td><td></td></tr><tr><td><a href="https://github.com/aantron/better-enums">Better Enums</a></td><td>反射性枚举（枚举到字符、迭代等），带 constexpr 支持。</td><td>BSD</td><td></td></tr><tr><td><a href="https://github.com/krabicezpapundeklu/smart_enum">Smart Enum</a></td><td>给你的枚举 “to_string” 、 “from_string” 和更多。</td><td>Boost 许可</td><td></td></tr><tr><td><a href="https://github.com/nyorain/nytl">nytl</a></td><td>通用的 C++17 唯头文件模板库。</td><td>Boost 许可</td><td></td></tr><tr><td><a href="https://github.com/duneroadrunner/SaferCPlusPlus">SaferCPlusPlus</a></td><td>SaferCPlusPlus - 不安全的 C++ 原始工具的安全兼容替换品，包括指针、 int 和 std::vector。</td><td>Boost 许可</td><td></td></tr><tr><td><a href="http://fcppt.org/">fcppt</a></td><td>Freundlich 的 C++ 工具套 (fcppt) 是聚焦于通过提供更好的类型和函数式编程改进 C++ 代码的库汇集。</td><td></td><td></td></tr><tr><td><a href="https://github.com/wkaras/C-plus-plus-library-bit-fields">bitfield.h</a></td><td>位域结构设施，比基础语言设施更可移植/灵活。</td><td></td><td></td></tr><tr><td><a href="https://github.com/wkaras/C-plus-plus-library-default-operators">composite_op.h</a></td><td>基础类数据成员自省，繁琐且常常不可重入，但有时有用。</td><td></td><td></td></tr><tr><td><a href="https://github.com/wkaras/C-plus-plus-intrusive-container-templates">Abstract Intrusive Containers</a></td><td>比 boost::intrusive 更灵活，但非 STL 兼容。</td><td></td><td></td></tr><tr><td><a href="https://bitbucket.org/alexey_gruzdev/yato/overview">Yato</a></td><td>现代 C++ (14/17) 的跨平台 STL 风格及 STL 兼容库，实现容器、范围、迭代器、类型特性和其他工具；行动者系统；类型安全配置接口</td><td>Apache-2.0</td><td></td></tr><tr><td><a href="https://github.com/gracicot/kangaru">Kangaru</a></td><td>C++11 与 C++14 的依赖注入容器</td><td>MIT 许可</td><td></td></tr><tr><td><a href="https://github.com/AmokHuginnsson/yaal">yaal</a></td><td>算法、汇集、任意精度计算、泛型 DSL 文法驱动分析器及更多</td><td>CC BY-ND-NC 4.0</td><td>CMake</td></tr><tr><td><a href="https://github.com/martinmoene/gsl-lite">gsl-lite</a></td><td>C++98 、 C++11 及后续版本的 ISO C++ Guideline 支持库 (GSL) 的单文件唯头文件版本。</td><td></td><td></td></tr><tr><td><a href="https://github.com/martinmoene/nonstd-lite">nonstd-lite</a></td><td>*-lite 仓库的亲属，将 C++11 后特性移植到古代 C++ 环境的迁移路径。</td><td></td><td></td></tr><tr><td><a href="https://github.com/nholthaus/units">units</a></td><td>编译时唯头文件的量纲分析及单位转换库，建立于 C++14 而无依赖。</td><td></td><td></td></tr></tbody></table><h2><span id="gps">GPS</span><a href="#gps" class="header-anchor">#</a></h2><table><thead><tr><th>库名</th><th>简述</th><th>协议</th><th>配置手段</th></tr></thead><tbody><tr><td><a href="http://www.catb.org/gpsd/">gpsd</a></td><td></td><td></td><td></td></tr></tbody></table><h2><span id="tu-xing-yong-hu-jie-mian">图形用户界面</span><a href="#tu-xing-yong-hu-jie-mian" class="header-anchor">#</a></h2><table><thead><tr><th>库名</th><th>简述</th><th>协议</th><th>配置手段</th></tr></thead><tbody><tr><td><a href="https://github.com/ocornut/imgui">Dear ImGui</a></td><td>高度优化的不膨胀的图形用户界面库。</td><td></td><td></td></tr><tr><td><a href="http://www.fltk.org/">FLTK</a></td><td></td><td></td><td></td></tr><tr><td><a href="http://nanapro.org/">nana</a></td><td>用现代 C++ 风格的 GUI 编程（ Boost 许可）</td><td></td><td></td></tr><tr><td><a href="https://github.com/wjakob/nanogui">nanogui</a></td><td>最小化的跨平台器件库，适用于 OpenGL 3.x 或更高版本</td><td></td><td></td></tr><tr><td><a href="http://wxwidgets.org/">WxWidgets</a></td><td></td><td></td><td></td></tr><tr><td><a href="http://sourceforge.net/projects/owlnext/">OWLNext</a></td><td>对 <a href="http://en.wikipedia.org/wiki/Object_Windows_Library">OWL</a> 的，用于在 Windows 上以标准 C++ 书写 GUI 应用的现代更新</td><td></td><td></td></tr><tr><td><a href="http://tinyfiledialogs.sourceforge.net/">tiny file dialogs</a></td><td>单个 C C++ 跨平台文件（无初始化、无 main 循环、 6 种形态的函数调用）</td><td></td><td></td></tr></tbody></table><ul><li>CopperSpice</li></ul><table><thead><tr><th>库名</th><th>简述</th><th>协议</th><th>配置手段</th></tr></thead><tbody><tr><td><a href="https://www.copperspice.com/">CopperSpice</a></td><td>CopperSpice 是用于开发跨平台软件应用的 C++ 库集合。它在 LGPL V2.1 许可下发布。它使用现代理念的 C++ 并与 STL 无缝结合。 CopperSpice 派生自 Qt 框架。</td><td></td><td></td></tr><tr><td><a href="https://github.com/copperspice/cs_signal">CsSignal</a></td><td>独立的 C++ 具线程信号/槽库</td><td></td><td></td></tr><tr><td><a href="https://github.com/copperspice/cs_string">CsString</a></td><td>独立的 C++ 具 Unicode 字符串库</td><td></td><td></td></tr><tr><td><a href="https://github.com/copperspice/libguarded">libGuarded</a></td><td>独立的 C++ 多线程库，用于管理对共享数据的访问</td><td></td><td></td></tr></tbody></table><ul><li>GTK+</li></ul><table><thead><tr><th>库名</th><th>简述</th><th>协议</th><th>配置手段</th></tr></thead><tbody><tr><td><a href="http://www.gtkmm.org/">glibmm</a></td><td></td><td></td><td></td></tr><tr><td><a href="http://www.gtkmm.org/">gtkmm</a></td><td></td><td></td><td></td></tr><tr><td><a href="http://live.gnome.org/GooCanvas">goocanvasmm</a></td><td></td><td></td><td></td></tr><tr><td><a href="http://www.gtkmm.org/">libglademm</a></td><td></td><td></td><td></td></tr><tr><td><a href="http://www.gtkmm.org/">libgnomecanvasmm</a></td><td></td><td></td><td></td></tr><tr><td><a href="http://webkitgtk.org/">webkitgtk</a></td><td></td><td></td><td></td></tr><tr><td><a href="http://drobilla.net/software/flowcanvas/">flowcanvas</a></td><td></td><td></td><td></td></tr><tr><td><a href="http://www.gnome.org/projects/evince/">evince</a></td><td></td><td></td><td></td></tr></tbody></table><ul><li>Qt</li></ul><table><thead><tr><th>库名</th><th>简述</th><th>协议</th><th>配置手段</th></tr></thead><tbody><tr><td><a href="http://qt.io/">Qt</a></td><td></td><td></td><td></td></tr><tr><td><a href="http://qwtplot3d.sourceforge.net/">qwtplot3d</a></td><td></td><td></td><td></td></tr><tr><td><a href="http://qwt.sourceforge.net/">qwt5</a></td><td>技术应用到 Qt Widgets</td><td></td><td></td></tr><tr><td><a href="https://launchpad.net/libdbusmenu-qt">libdbusmenu-qt</a></td><td></td><td></td><td></td></tr><tr><td><a href="https://github.com/cneben/QuickQanava">QuickQanava</a></td><td>直接在 Qt/QML 应用中画图的 C++14 库；项目主页： <a href="http://www.qanava.org/">http://www.qanava.org</a></td><td></td><td></td></tr><tr><td><a href="https://github.com/cneben/QuickProperties">QuickProperties</a></td><td>QObject/QtObject 属性编辑的 C++/QML 库；项目主页： <a href="http://www.qanava.org/">http://www.qanava.org</a></td><td></td><td></td></tr></tbody></table><h2><span id="tu-xing">图形</span><a href="#tu-xing" class="header-anchor">#</a></h2><table><thead><tr><th>库名</th><th>简述</th><th>协议</th><th>配置手段</th></tr></thead><tbody><tr><td><a href="http://cairographics.org/cairomm/">cairomm</a></td><td></td><td></td><td></td></tr><tr><td><a href="http://launchpad.net/nux">nux</a></td><td></td><td></td><td></td></tr><tr><td><a href="http://gtkmm.org/">pangomm</a></td><td></td><td></td><td></td></tr><tr><td><a href="https://github.com/memononen/nanovg">nanovg</a></td><td>基于openGL/DX/metal的2d绘图库。</td><td></td><td></td></tr><tr><td><a href="https://github.com/bkaradzic/bgfx">bgfx</a></td><td>非常强大的跨平台图形渲染库，支持平台包括 Windows Mac Linux iOS Android Web，渲染后端包括 DX, opengl, metal webgl等。</td><td></td><td></td></tr></tbody></table><h2><span id="tu-xiang">图像</span><a href="#tu-xiang" class="header-anchor">#</a></h2><table><thead><tr><th>库名</th><th>简述</th><th>协议</th><th>配置手段</th></tr></thead><tbody><tr><td><a href="http://gegl.org/">gegl</a></td><td></td><td></td><td></td></tr><tr><td><a href="https://github.com/nothings/stb.image">stb.image</a></td><td></td><td></td><td></td></tr><tr><td><a href="http://boost.org/libs/gil">Adobe/boost GIL</a></td><td>高层通用库，聚焦于 2D 图像上操作的算法。非常有限定 I/O 选项。</td><td></td><td></td></tr><tr><td><a href="http://www.graphicsmagick.org/">GraphicsMagick</a></td><td>读、写、操纵 88 种主要格式的图像。于 2002 年分化自 ImageMagick</td><td></td><td></td></tr><tr><td><a href="https://skia.org/">Skia Graphics Engine</a></td><td>Google 从 2005 年起的图形库，用于 Chrome 、 Chrome OS 、 Android 还有 Firefox 和 Sublime Text <a href="https://en.wikipedia.org/wiki/Skia_Graphics_Engine">enwiki:Skia_Graphics_Engine</a></td><td></td><td></td></tr><tr><td><a href="https://github.com/tyoma/agge">Anti-Grain Evolution</a></td><td>跨平台 2D 光栅化及绘图引擎</td><td></td><td></td></tr></tbody></table><ul><li>打点</li></ul><table><thead><tr><th>库名</th><th>简述</th><th>协议</th><th>配置手段</th></tr></thead><tbody><tr><td><a href="http://www.gnu.org/software/plotutils/">plotutils</a></td><td></td><td></td><td></td></tr></tbody></table><ul><li>格式</li></ul><table><thead><tr><th>库名</th><th>简述</th><th>协议</th><th>配置手段</th></tr></thead><tbody><tr><td><a href="http://www.libraw.org/">libraw</a></td><td></td><td></td><td></td></tr><tr><td><a href="http://www.openexr.com/">openexr</a></td><td></td><td></td><td></td></tr><tr><td><a href="http://www.kde.org/">qimageblitz</a></td><td></td><td></td><td></td></tr><tr><td><a href="http://www.imagemagick.org/">imagemagick</a></td><td></td><td></td><td></td></tr><tr><td><a href="http://djvu.sourceforge.net/">djvulibre</a></td><td></td><td></td><td></td></tr><tr><td><a href="http://poppler.freedesktop.org/">poppler</a></td><td></td><td></td><td></td></tr><tr><td><a href="http://svgpp.org/">SVG++</a></td><td></td><td></td><td></td></tr></tbody></table><h2><span id="3d-tu-xing">3D 图形</span><a href="#3d-tu-xing" class="header-anchor">#</a></h2><table><thead><tr><th>库名</th><th>简述</th><th>协议</th><th>配置手段</th></tr></thead><tbody><tr><td><a href="https://www.khronos.org/vulkan/">Vulkan</a></td><td></td><td></td><td></td></tr><tr><td><a href="http://www.opengl.org/">OpenGL</a></td><td></td><td></td><td></td></tr><tr><td><a href="https://github.com/bkaradzic/bgfx#bgfx---cross-platform-rendering-library">bgfx</a></td><td>跨平台、不知图形 API 、“带来你自己的引擎/框架”风格的制图库。</td><td></td><td></td></tr><tr><td><a href="http://www.ogre3d.org/docs/manual/">Ogre3D</a></td><td></td><td></td><td></td></tr><tr><td><a href="https://github.com/DiligentGraphics/DiligentEngine">Diligent Engine</a></td><td>现代跨平台低层 3D 图形库。</td><td></td><td></td></tr><tr><td><a href="http://glew.sourceforge.net/">GLEW</a></td><td>OpenGL 功能加载</td><td></td><td></td></tr><tr><td><a href="http://glad.dav1d.de/">GLAD</a></td><td>可定制的轻量库，用于加载 OpenGL 功能</td><td></td><td></td></tr><tr><td><a href="https://github.com/anholt/libepoxy">Epoxy</a></td><td>GLEM 的现代后继者。在 GL 环境的一些种类间抽象，这使得有时比使用 GLEW 更加单。自 2015 起为 GTK+ 项目所用。</td><td></td><td></td></tr><tr><td><a href="http://www.glfw.org/">GLFW</a></td><td>OpenGL 窗口管理器</td><td></td><td></td></tr><tr><td><a href="http://glm.g-truc.net/">GLM</a></td><td>制图用的唯头文件 C++ 数学库</td><td></td><td></td></tr><tr><td><a href="http://github.com/redorav/hlslpp">hlsl++</a></td><td>使用 hlsl 语法的唯头文件 C++ 渲染库。支持 SSE 和 NEON</td><td></td><td></td></tr><tr><td><a href="http://assimp.sourceforge.net/">assimp</a></td><td>3D 模型加载</td><td></td><td></td></tr><tr><td><a href="http://vtk.org/">VTK</a></td><td></td><td></td><td></td></tr><tr><td><a href="http://magnum.graphics/">Magnum</a></td><td>游戏和数据可视化的轻量模块化的 C++11/C++14 图形中间件</td><td></td><td></td></tr><tr><td><a href="http://irrlicht.sourceforge.net/">Irrlicht</a></td><td></td><td></td><td></td></tr><tr><td><a href="http://www.horde3d.org/">Horde3D</a></td><td></td><td></td><td></td></tr><tr><td><a href="https://github.com/szellmann/visionaray">Visionaray</a></td><td>C++ 光束追踪模板库</td><td></td><td></td></tr><tr><td><a href="https://www.opencascade.com/content/core-technology">Open CASCADE</a></td><td>3D CAD/CAM/CAE 应用的 SDK</td><td></td><td></td></tr><tr><td><a href="http://www.openscenegraph.org/">OpenSceneGraph</a></td><td></td><td></td><td></td></tr></tbody></table><h2><span id="tu-xiang-chu-li">图像处理</span><a href="#tu-xiang-chu-li" class="header-anchor">#</a></h2><table><thead><tr><th>库名</th><th>简述</th><th>协议</th><th>配置手段</th></tr></thead><tbody><tr><td><a href="http://opencv.org/">opencv</a></td><td></td><td></td><td></td></tr><tr><td><a href="http://dlib.net/imaging.html">dlib</a></td><td></td><td></td><td></td></tr><tr><td><a href="https://itk.org/">ITK</a></td><td></td><td></td><td></td></tr><tr><td><a href="https://www.orfeo-toolbox.org/">OTB</a></td><td></td><td></td><td></td></tr></tbody></table><h2><span id="guo-ji-hua">国际化</span><a href="#guo-ji-hua" class="header-anchor">#</a></h2><table><thead><tr><th>库名</th><th>简述</th><th>协议</th><th>配置手段</th></tr></thead><tbody><tr><td><a href="http://site.icu-project.org/">IBM ICU</a></td><td></td><td></td><td></td></tr><tr><td><a href="http://www.gnu.org/software/gettext/">gettext</a></td><td></td><td></td><td></td></tr><tr><td><a href="https://github.com/cbeck88/spirit-po">spirit-po</a></td><td>快速的唯头文件库，分析 po 文件，并提供类似 GNU libintl 的接口。基于 boost::spirit 。</td><td></td><td></td></tr></tbody></table><h2><span id="ji-lu">记录</span><a href="#ji-lu" class="header-anchor">#</a></h2><table><thead><tr><th>库名</th><th>简述</th><th>协议</th><th>配置手段</th></tr></thead><tbody><tr><td><a href="http://log4cpp.sourceforge.net/">Log4cpp</a></td><td>用于灵活地记录到文件、系统日志、 IDSA 或其他目标的 C++ 类库 (LGPL)</td><td></td><td></td></tr><tr><td><a href="https://github.com/log4cplus/log4cplus">Log4cplus</a></td><td>日志 API ，提供日志管理及配置上的线程安全、灵活且有任意粒度的控制。</td><td></td><td></td></tr><tr><td><a href="https://github.com/gabime/spdlog">spdlog</a></td><td>超快的唯头文件 C++ 日志库</td><td></td><td></td></tr><tr><td><a href="https://github.com/SergiusTheBest/plog">plog</a></td><td>C++ 的可移植且简单的日志，少于 1000 行代码 (MPL2)</td><td></td><td></td></tr><tr><td><a href="https://www.boost.org/doc/libs/1_65_0/libs/log/doc/html/index.html">Boost.Log</a></td><td></td><td></td><td></td></tr><tr><td><a href="https://github.com/google/glog">glog</a></td><td>Google 日志库</td><td></td><td></td></tr><tr><td><a href="https://logging.apache.org/log4cxx/latest_stable/index.html">log4cxx</a></td><td>Apache log4cxx 是 Apache log4j 后的 C++ 模式化记录框架</td><td></td><td></td></tr><tr><td><a href="http://www.pantheios.org/">Pantheios</a></td><td>诊断日志 API 库，提供类型安全、效率、泛型和可扩展性的结合</td><td></td><td></td></tr><tr><td><a href="https://github.com/bombela/backward-cpp">Backward</a></td><td>打印漂亮的 Python 风格栈追踪，带颜色和源代码片段，特别是在崩溃时（ MIT 许可）。</td><td></td><td></td></tr></tbody></table><h2><span id="shu-xue">数学</span><a href="#shu-xue" class="header-anchor">#</a></h2><table><thead><tr><th>库名</th><th>简述</th><th>协议</th><th>配置手段</th></tr></thead><tbody><tr><td><a href="http://statsxx.com/">stats++</a></td><td>先进、广泛的统计软件：数据收集及预处理、统计、机器学习及优化，拥有开放的 C++ 源码。</td><td></td><td></td></tr><tr><td><a href="https://github.com/kthohr/stats">StatsLib</a></td><td>统计分布函数的模板化唯头文件库。</td><td></td><td></td></tr><tr><td><a href="http://www.alglib.net/">alglib</a></td><td></td><td></td><td></td></tr><tr><td><a href="http://www.arrayfire.com/docs/index.htm">ArrayFire High Performance Computation Library</a></td><td></td><td></td><td></td></tr><tr><td><a href="http://gmplib.org/manual/C_002b_002b-Class-Interface.html#C_002b_002b-Class-Interface">GNU MP bignum C++ interface</a></td><td></td><td></td><td></td></tr><tr><td><a href="https://github.com/limeoats/BigNumber">BigNumber</a></td><td>创建和计算任意长度整数的 C++ 类</td><td></td><td></td></tr><tr><td><a href="https://www.boost.org/doc/libs/release/libs/multiprecision/doc/html/index.html">Boost.Multiprecision</a></td><td></td><td></td><td></td></tr><tr><td><a href="https://www.boost.org/doc/libs/release/libs/math/doc/sf_and_dist/html/">Boost.Math.Special Functions and Statistical Distributions</a></td><td></td><td></td><td></td></tr><tr><td><a href="https://www.boost.org/doc/libs/release/doc/html/boost_random.html">Boost.Random</a></td><td></td><td></td><td></td></tr><tr><td><a href="http://www.shoup.net/ntl/">NTL - A Library for doing Number Theory</a></td><td></td><td></td><td></td></tr><tr><td><a href="https://github.com/carlomilanesi/cpp-measures/">cpp-measures</a></td><td>处理物理度量的唯头文件 C++11 库</td><td></td><td></td></tr><tr><td><a href="http://gs.jku.at/gismo">G+Smo</a></td><td>等几何分析的跨平台库</td><td></td><td></td></tr><tr><td><a href="https://github.com/hosseinmoein/Matrix">C++ Matrix</a></td><td>高性能且精确（例如极端情况）的矩阵数学库，带表达式模板算术运算符</td><td></td><td></td></tr><tr><td><a href="https://gitlab.com/ToolsDevler/libdecimal">Exact floating-point arithmetic library</a></td><td></td><td></td><td></td></tr><tr><td><a href="https://github.com/exaeta/uniform_smooth_noise">RPNX Uniform Smooth Noise</a></td><td>N 维均匀分布的平滑噪声函数，以 C++ 实现。</td><td></td><td></td></tr></tbody></table><ul><li>数值计算</li></ul><table><thead><tr><th>库名</th><th>简述</th><th>协议</th><th>配置手段</th></tr></thead><tbody><tr><td><a href="https://bellard.org/libbf">LibBF</a></td><td>由 Bellard 开发的任意精度数值计算库，拥有一个将圆周率计算到数十亿位的示例程序</td><td></td><td></td></tr></tbody></table><ul><li>线性代数</li></ul><table><thead><tr><th>库名</th><th>简述</th><th>协议</th><th>配置手段</th></tr></thead><tbody><tr><td><a href="https://www.boost.org/doc/libs/release/libs/numeric/ublas/doc/index.htm">Boost.uBLAS</a></td><td></td><td></td><td></td></tr><tr><td><a href="http://eigen.tuxfamily.org/index.php?title=Main_Page#Documentation">Eigen</a></td><td></td><td></td><td></td></tr><tr><td><a href="http://arma.sourceforge.net/">Armadillo</a></td><td></td><td></td><td></td></tr><tr><td><a href="http://sourceforge.net/projects/blitz/">Blitz++</a></td><td></td><td></td><td></td></tr><tr><td><a href="http://sourceforge.net/projects/itpp/">IT++</a></td><td></td><td></td><td></td></tr><tr><td><a href="http://dlib.net/linear_algebra.html">Dlib - linear algebra tools</a></td><td></td><td></td><td></td></tr><tr><td><a href="https://bitbucket.org/blaze-lib/blaze">Blaze</a></td><td></td><td></td><td></td></tr><tr><td><a href="https://github.com/wichtounet/etl">ETL</a></td><td></td><td></td><td></td></tr><tr><td><a href="https://github.com/jmatta1/DecompLib">DecompLib</a></td><td>唯头文件的 C++11 库，分解向量为正定加权基向量的集合。</td><td></td><td></td></tr></tbody></table><ul><li>优化</li></ul><table><thead><tr><th>库名</th><th>简述</th><th>协议</th><th>配置手段</th></tr></thead><tbody><tr><td><a href="https://github.com/kthohr/optim">OptimLib</a></td><td>非线性函数数值优化方法的 C++11 库。</td><td></td><td></td></tr></tbody></table><ul><li>图论</li></ul><table><thead><tr><th>库名</th><th>简述</th><th>协议</th><th>配置手段</th></tr></thead><tbody><tr><td><a href="https://www.boost.org/doc/libs/release/libs/graph/doc/index.html">Boost.Graph</a></td><td></td><td></td><td></td></tr><tr><td><a href="http://lemon.cs.elte.hu/trac/lemon">LEMON</a></td><td></td><td></td><td></td></tr><tr><td><a href="http://www.ogdf.net/">OGDF - Open Graph Drawing Framework</a></td><td></td><td></td><td></td></tr><tr><td><a href="http://math.nist.gov/~RPozo/ngraph/ngraph_index.html">NGraph - a simple (Network) Graph library in C++</a></td><td></td><td></td><td></td></tr><tr><td><a href="https://github.com/cneben/GTpo">GTpo</a></td><td>C++14 泛型图拓扑库，带 Protocol Buffer 序列化；项目主页： <a href="http://www.qanava.org/">http://www.qanava.org</a></td><td></td><td></td></tr></tbody></table><ul><li>数的类库</li></ul><table><thead><tr><th>库名</th><th>简述</th><th>协议</th><th>配置手段</th></tr></thead><tbody><tr><td><a href="http://www.ginac.de/CLN/">cln</a></td><td></td><td></td><td></td></tr><tr><td><a href="https://github.com/stillwater-sc/universal">Universal</a></td><td>通用数算术的 C++ 模板库，取代 IEEE 浮点（ MIT 许可）</td><td></td><td></td></tr></tbody></table><ul><li>人工智能</li></ul><table><thead><tr><th>库名</th><th>简述</th><th>协议</th><th>配置手段</th></tr></thead><tbody><tr><td><a href="http://statsxx.com/">stats++</a></td><td></td><td></td><td></td></tr><tr><td><a href="http://www.csie.ntu.edu.tw/~cjlin/liblinear/">liblinear</a></td><td></td><td></td><td></td></tr><tr><td><a href="http://dlib.net/ml.html">Dlib</a></td><td>机器学习工具</td><td></td><td></td></tr><tr><td><a href="http://mlpack.org/">MLPACK</a></td><td>机器学习包</td><td></td><td></td></tr><tr><td><a href="http://shogun-toolbox.org/">Shogun</a></td><td>大规模机器学习工具箱</td><td></td><td></td></tr><tr><td><a href="http://leenissen.dk/fann/wp/">FANN</a></td><td>快速人工神经网络库</td><td></td><td></td></tr><tr><td><a href="https://github.com/tensorflow/tensorflow">TensorFlow</a></td><td>面向所有人的开源机器学习框架</td><td></td><td></td></tr><tr><td><a href="https://github.com/PaddlePaddle/Paddle">Paddle</a></td><td>并行化分布式深度学习库</td><td></td><td></td></tr><tr><td><a href="https://github.com/opencv/dldt">DLDT</a></td><td>OpenVINO™工具包-深度学习部署工具包</td><td></td><td></td></tr><tr><td><a href="https://github.com/NVIDIA/TensorRT">TensorRT</a></td><td>用于在 NVIDIA GPU 和深度学习加速器上进行高性能推理的 C++ 库</td><td></td><td></td></tr><tr><td><a href="https://github.com/Tencent/ncnn">NCNN</a></td><td>腾讯开发的、针对移动平台进行了优化的高性能神经网络推理框架</td><td></td><td></td></tr><tr><td><a href="https://github.com/CMU-Perceptual-Computing-Lab/openpose">OpenPose</a></td><td>实时多人关键点检测库，用于身体，面部，手和脚的检测</td><td></td><td></td></tr><tr><td><a href="https://github.com/ANNetGPGPU/ANNetGPGPU">ANNetGPGPU</a></td><td>基于GPU（CUDA）的人工神经网络库。</td><td></td><td></td></tr><tr><td><a href="https://github.com/aigamedev/btsk">btsk</a></td><td>游戏行为树入门套件。</td><td></td><td></td></tr><tr><td><a href="http://eodev.sourceforge.net/">Evolving Objects</a></td><td>基于模板的 C++ 演化计算库，可帮助您快速随意地编写自己的随机优化算法。</td><td></td><td></td></tr><tr><td><a href="https://github.com/Dobiasd/frugally-deep">frugally-deep</a></td><td>仅头文件的库，用于在 C++ 中使用Keras模型。</td><td></td><td></td></tr><tr><td><a href="https://github.com/codeplea/genann">Genann</a></td><td>简单神经网络库。</td><td></td><td></td></tr><tr><td><a href="https://github.com/recastnavigation/recastnavigation">Recast/Detour</a></td><td>导航网格生成器和浏览器，主要用于游戏。</td><td></td><td></td></tr><tr><td><a href="https://github.com/Microsoft/CNTK">CNTK</a></td><td>微软认知工具包（CNTK），一种开源的深度学习工具包。</td><td></td><td></td></tr><tr><td><a href="https://github.com/tiny-dnn/tiny-dnn">tiny-dnn</a></td><td>基于 C++11 的唯头文件、无依赖的深度学习框架。</td><td></td><td></td></tr><tr><td><a href="https://github.com/Samsung/veles">Veles</a></td><td>用于快速深度学习应用程序开发的分布式平台。</td><td></td><td></td></tr><tr><td><a href="https://github.com/kaldi-asr/kaldi">Kaldi</a></td><td>语音识别工具包。</td><td></td><td></td></tr></tbody></table><ul><li>计算几何</li></ul><table><thead><tr><th>库名</th><th>简述</th><th>协议</th><th>配置手段</th></tr></thead><tbody><tr><td><a href="http://www.cgal.org/">CGAL</a></td><td>计算几何算法库</td><td></td><td></td></tr><tr><td><a href="http://www.wykobi.com/">Wykobi</a></td><td>计算几何库</td><td></td><td></td></tr><tr><td><a href="http://pointclouds.org/">PCL</a></td><td>点云库</td><td></td><td></td></tr></tbody></table><ul><li>自动化理论</li></ul><table><thead><tr><th>库名</th><th>简述</th><th>协议</th><th>配置手段</th></tr></thead><tbody><tr><td><a href="http://yasmine.seadex.de/">yasmine - C++11 UML state machine framework</a></td><td></td><td></td><td></td></tr></tbody></table><h2><span id="yuan-bian-cheng">元编程</span><a href="#yuan-bian-cheng" class="header-anchor">#</a></h2><table><thead><tr><th>库名</th><th>简述</th><th>协议</th><th>配置手段</th></tr></thead><tbody><tr><td><a href="https://www.boost.org/doc/libs/release/libs/mpl/doc/index.html">Boost.MPL</a></td><td>原初元编程库，目标为 C++03 ，慢</td><td></td><td></td></tr><tr><td><a href="https://www.boost.org/doc/libs/release/libs/hana/doc/html/index.html">Boost.Hana</a></td><td>类型与值的新元编程库</td><td></td><td></td></tr><tr><td><a href="https://www.boost.org/doc/libs/release/libs/mp11/doc/html/mp11.html">Boost.Mp11</a></td><td></td><td></td><td></td></tr><tr><td><a href="https://www.boost.org/doc/libs/release/libs/callable_traits/doc/html/index.html">Boost.CallableTraits</a></td><td></td><td></td><td></td></tr><tr><td><a href="https://github.com/brunocodutra/metal">Metal</a></td><td>使用饿元函数， 100% SFINAE 友好</td><td></td><td></td></tr><tr><td><a href="https://github.com/edouarda/brigand">Brigand</a></td><td>使用饿元函数，为最佳性能优化</td><td></td><td></td></tr><tr><td><a href="https://github.com/ericniebler/meta">Meta</a></td><td>使用饿元函数，在 metal 和 brigand 之间，相对于性能妥协</td><td></td><td></td></tr><tr><td><a href="https://www.boost.org/doc/libs/1_61_0/doc/html/metaparse.html">Boost.Metaparse</a></td><td>编译时分析器库，从编译时字符串产生类型、值和元函数</td><td></td><td></td></tr><tr><td><a href="https://www.boost.org/doc/libs/1_61_0/doc/html/proto.html">Boost.Proto</a></td><td>构建基于表达式模板的 EDSLs 的库</td><td></td><td></td></tr><tr><td><a href="https://github.com/kfrlib/cometa">CoMeta</a></td><td>轻量、唯头文件的 C++14 元编程库</td><td></td><td></td></tr><tr><td><a href="https://github.com/cbeck88/visit_struct">visit_struct</a></td><td>小规模反射库，提供 C++11 的结构体观察器。自容纳， 100-200 行代码，取决于如何计算。</td><td></td><td></td></tr></tbody></table><h2><span id="pdf">PDF</span><a href="#pdf" class="header-anchor">#</a></h2><table><thead><tr><th>库名</th><th>简述</th><th>协议</th><th>配置手段</th></tr></thead><tbody><tr><td><a href="http://libharu.sourceforge.net/">HARU</a></td><td></td><td></td><td></td></tr><tr><td><a href="http://podofo.sourceforge.net/">PoDoFo</a></td><td></td><td></td><td></td></tr><tr><td><a href="http://www.jagpdf.org/">JagPDF</a></td><td></td><td></td><td></td></tr></tbody></table><h2><span id="wu-li-yu-mo-ni">物理与模拟</span><a href="#wu-li-yu-mo-ni" class="header-anchor">#</a></h2><table><thead><tr><th>库名</th><th>简述</th><th>协议</th><th>配置手段</th></tr></thead><tbody><tr><td><a href="https://www.reactphysics3d.com/">ReactPhysics3D</a></td><td>进行 3D 模拟与游戏的 C++ 物理引擎</td><td></td><td></td></tr><tr><td><a href="http://projectchrono.org/">ProjectCHRONO</a></td><td>开源多物理模拟引擎</td><td></td><td></td></tr><tr><td><a href="https://pybullet.org/wordpress">Bullet</a></td><td>游戏、视觉效果、机器人及加固学习的物理模拟</td><td></td><td></td></tr></tbody></table><h2><span id="xu-lie-hua">序列化</span><a href="#xu-lie-hua" class="header-anchor">#</a></h2><table><thead><tr><th>库名</th><th>简述</th><th>协议</th><th>配置手段</th></tr></thead><tbody><tr><td><a href="https://www.boost.org/doc/libs/release/libs/serialization/">Boost.Serialization</a></td><td></td><td></td><td></td></tr><tr><td><a href="http://www.s11n.net/">libs11n</a></td><td></td><td></td><td></td></tr><tr><td><a href="http://www.sweetsoftware.co.nz/persist_overview.html">sweet_persist</a></td><td></td><td></td><td></td></tr><tr><td><a href="https://github.com/google/protobuf/">protobuf</a></td><td></td><td></td><td></td></tr><tr><td><a href="http://gsoap2.sourceforge.net/">gSOAP</a></td><td>准确的 XML 序列化</td><td></td><td></td></tr><tr><td><a href="https://github.com/CarloWood/ai-xml">ai-xml</a></td><td>通过添加单个最小的函数到类，在 XML 间序列化及反序列化。在底层使用 libxml++ 。</td><td></td><td></td></tr><tr><td><a href="http://cppxmlobj.sourceforge.net/">C++ XML objects</a></td><td></td><td></td><td></td></tr><tr><td><a href="https://github.com/niXman/yas">YAS (Yet Another Serialization)</a></td><td></td><td></td><td></td></tr><tr><td><a href="https://github.com/jbeder/yaml-cpp">yaml-cpp</a></td><td></td><td></td><td></td></tr><tr><td><a href="http://uscilab.github.io/cereal/">cereal (C++11 serialization)</a></td><td></td><td></td><td></td></tr><tr><td><a href="https://github.com/castedo/jios">jios (JSON serialization)</a></td><td></td><td></td><td></td></tr><tr><td><a href="https://github.com/Loki-Astari/ThorsSerializer">ThorsSerializer (JSON/YAML Input Output Streams)</a></td><td></td><td></td><td></td></tr><tr><td><a href="https://github.com/tplgy/cppcodec">cppcodec</a></td><td>唯头文件库，编码/解码 base64 、 base32 和十六进制，有一致而灵活的 API （ MIT 许可）</td><td></td><td></td></tr><tr><td><a href="https://github.com/qicosmos/iguana">iguana (universal serialization engine)</a></td><td></td><td></td><td></td></tr><tr><td><a href="https://github.com/Exaeta/rpnx-serial">rpnx-serial</a></td><td>能（反）序列化如 std::map 、 std::vector 等类型的库</td><td></td><td></td></tr></tbody></table><ul><li>二进制序列化</li></ul><table><thead><tr><th>库名</th><th>简述</th><th>协议</th><th>配置手段</th></tr></thead><tbody><tr><td><a href="https://github.com/WhiZTiM/UbjsonCpp">UBjsonCpp</a></td><td>基于 C++14 的高性能 UBJson 读写库</td><td></td><td></td></tr><tr><td><a href="https://github.com/liteserver/binn">binn</a></td><td>旨在紧凑，快速且易于使用的二进制序列化库，自身是同名格式的实现。</td><td></td><td></td></tr><tr><td><a href="https://github.com/dwight/bson-cxx">bson-cxx</a></td><td>BSON 格式的 C++ 实现。</td><td></td><td></td></tr></tbody></table><h2><span id="pai-xu">排序</span><a href="#pai-xu" class="header-anchor">#</a></h2><table><thead><tr><th>库名</th><th>简述</th><th>协议</th><th>配置手段</th></tr></thead><tbody><tr><td><a href="https://github.com/gfx/cpp-TimSort">Timsort</a></td><td>模板化的稳定排序函数，对于逆序或半排序的数据，性能优于基于快速排序的算法，包括 std::sort 。 (MIT)</td><td></td><td></td></tr></tbody></table><h2><span id="zhong-duan">终端</span><a href="#zhong-duan" class="header-anchor">#</a></h2><table><thead><tr><th>库名</th><th>简述</th><th>协议</th><th>配置手段</th></tr></thead><tbody><tr><td><a href="https://cwidget.alioth.debian.org/">cwidget</a></td><td></td><td></td><td></td></tr><tr><td><a href="https://github.com/AmokHuginnsson/replxx">replxx</a></td><td>readline 和 libedit 的替换品，支持 UTF-8 、语法高亮和提示。</td><td></td><td></td></tr></tbody></table><h2><span id="ce-shi">测试</span><a href="#ce-shi" class="header-anchor">#</a></h2><table><thead><tr><th>库名</th><th>简述</th><th>协议</th><th>配置手段</th></tr></thead><tbody><tr><td><a href="https://www.boost.org/libs/test/">Boost.Test</a></td><td></td><td></td><td></td></tr><tr><td><a href="http://sourceforge.net/projects/cppunit/">cppunit</a></td><td></td><td></td><td></td></tr><tr><td><a href="https://github.com/google/googletest/">Google Test</a></td><td></td><td></td><td></td></tr><tr><td><a href="https://github.com/catchorg/Catch2">Catch2</a></td><td></td><td></td><td></td></tr><tr><td><a href="https://github.com/onqtam/doctest">doctest</a></td><td>单元测试和 TDD 使用的最轻量的特性丰富的 C++ 单头文件测试框架</td><td></td><td></td></tr><tr><td><a href="https://github.com/martinmoene/lest">lest</a></td><td>现代的 C++11 原生的单文件唯头文件的轻量单元测试、 TDD 和 BDD 框架（包含 C++98 变体）。</td><td></td><td></td></tr><tr><td><a href="https://github.com/etr/liblittletest">liblittletest</a></td><td>可移植，单个唯头文件的测试框架</td><td></td><td></td></tr><tr><td><a href="https://github.com/mollismerx/elfspy">ELFspy</a></td><td>杜绝假象和间谍的测试 - 仅 Linux</td><td></td><td></td></tr><tr><td><a href="https://github.com/gammasoft71/xtd.tunit">xtd.tunit</a></td><td>Windows 、 macOS 、 Linux 、 iOS 和 Android 上的现代 C++17 单元测试库。<a href="https://gammasoft71.wixsite.com/xtd-tunit">官方网站</a></td><td></td><td></td></tr><tr><td><a href="http://banditcpp.github.io/bandit/">bandit</a></td><td>C++11 的对人类友好单元测试</td><td></td><td></td></tr></tbody></table><h2><span id="wen-ben">文本</span><a href="#wen-ben" class="header-anchor">#</a></h2><ul><li>编码</li></ul><table><thead><tr><th>库名</th><th>简述</th><th>协议</th><th>配置手段</th></tr></thead><tbody><tr><td><a href="https://github.com/BYVoid/uchardet">uchardet</a></td><td>实现猜字符串编码的功能,和python里的uchardet功能基本一样。</td><td></td><td></td></tr><tr><td><a href="https://github.com/win-iconv/win-iconv">win-iconv</a></td><td>Linux 和 Mac 上的字符集编码转换库 iconv 的 Windows 实现，基于 Win32 字符集转换 API 实现。</td><td></td><td></td></tr></tbody></table><ul><li>格式化</li></ul><table><thead><tr><th>库名</th><th>简述</th><th>协议</th><th>配置手段</th></tr></thead><tbody><tr><td><a href="https://github.com/fmtlib/fmt">fmt</a></td><td>printf 不好用，ostream 也不好用，format 好用</td><td></td><td></td></tr></tbody></table><ul><li>分析</li></ul><table><thead><tr><th>库名</th><th>简述</th><th>协议</th><th>配置手段</th></tr></thead><tbody><tr><td><a href="https://github.com/taocpp/PEGTL">PEGTL</a></td><td>分析表达式文法的模板库</td><td></td><td></td></tr><tr><td><a href="https://github.com/r35382/bnflite">BNFlite</a></td><td>仅单个头文件的轻量文法分析器库</td><td></td><td></td></tr></tbody></table><ul><li>搜索</li></ul><table><thead><tr><th>库名</th><th>简述</th><th>协议</th><th>配置手段</th></tr></thead><tbody><tr><td><a href="http://clucene.sourceforge.net/">clucene</a></td><td></td><td></td><td></td></tr><tr><td><a href="https://xapian.org/">xapian</a></td><td></td><td></td><td></td></tr><tr><td><a href="https://github.com/storm-ptr/step">Step</a></td><td>Ukkonen 的构建后缀树在线算法， Manber 的构建后缀数组算法。</td><td></td><td></td></tr></tbody></table><ul><li>模板引擎</li></ul><table><thead><tr><th>库名</th><th>简述</th><th>协议</th><th>配置手段</th></tr></thead><tbody><tr><td><a href="https://github.com/pantor/inja">inja</a></td><td>现代 C++ 的模板引擎</td><td></td><td></td></tr></tbody></table><h2><span id="ban-ben-kong-zhi">版本控制</span><a href="#ban-ben-kong-zhi" class="header-anchor">#</a></h2><table><thead><tr><th>库名</th><th>简述</th><th>协议</th><th>配置手段</th></tr></thead><tbody><tr><td><a href="https://libgit2.org/">LibGit2</a></td><td>版本控制系统 Git 的核心库。</td><td></td><td></td></tr><tr><td><a href="https://github.com/easz/cpp-semver">cpp-semver</a></td><td>语义化版本号的 C++ 操作库。</td><td></td><td></td></tr></tbody></table><h2><span id="shi-pin">视频</span><a href="#shi-pin" class="header-anchor">#</a></h2><table><thead><tr><th>库名</th><th>简述</th><th>协议</th><th>配置手段</th></tr></thead><tbody><tr><td><a href="http://www.broadcom.com/support/crystal_hd/">crystalhd</a></td><td></td><td></td><td></td></tr><tr><td><a href="http://mjpeg.sourceforge.net/">mjpegtools</a></td><td></td><td></td><td></td></tr><tr><td><a href="http://www.matroska.org/">libmatroska</a></td><td></td><td></td><td></td></tr><tr><td><a href="http://wiki.videolan.org/LibVLC">libVLC</a></td><td></td><td></td><td></td></tr><tr><td><a href="http://gstreamer.freedesktop.org/">gstreamermm</a></td><td></td><td></td><td></td></tr></tbody></table><h2><span id="web">Web</span><a href="#web" class="header-anchor">#</a></h2><table><thead><tr><th>库名</th><th>简述</th><th>协议</th><th>配置手段</th></tr></thead><tbody><tr><td><a href="https://musicbrainz.org/doc/libmusicbrainz">libmusicbrainz5</a></td><td></td><td></td><td></td></tr><tr><td><a href="https://www.last.fm/">liblastfm</a></td><td></td><td></td><td></td></tr><tr><td><a href="https://www.kde.org/">libkcddb</a></td><td></td><td></td><td></td></tr><tr><td><a href="https://bitbucket.org/chromiumembedded/cef/">Chromium Embedded</a></td><td></td><td></td><td></td></tr><tr><td><a href="http://stefanfrings.de/qtwebapp/index-en.html">QtWebApp</a></td><td>Java Servlets 所启发的 HTTP(s) Server ，以 C++ 实现</td><td></td><td></td></tr><tr><td><a href="http://www.webtoolkit.eu/wt/">Wt</a></td><td></td><td></td><td></td></tr><tr><td><a href="https://github.com/vinipsmaker/tufao">Tufão</a></td><td></td><td></td><td></td></tr><tr><td><a href="https://github.com/etr/libhttpserver">libhttpserver</a></td><td></td><td></td><td></td></tr><tr><td><a href="https://github.com/arun11299/cpp-jwt">cpp-jwt</a></td><td></td><td></td><td></td></tr><tr><td><a href="https://oatpp.io/">oatpp</a></td><td>用于创建高性能网络服务的轻量零依赖框架</td><td></td><td></td></tr></tbody></table>]]></content>
    
    
    
    <tags>
      
      <tag>OpenLib</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Arch安装</title>
    <link href="/2021/12/24/Arch%E5%AE%89%E8%A3%85/"/>
    <url>/2021/12/24/Arch%E5%AE%89%E8%A3%85/</url>
    
    <content type="html"><![CDATA[<div class="toc"><!-- toc --><ul><li><a href="#arch-an-zhuang">Arch安装</a><ul><li><a href="#yi-zhun-bei-gong-zuo">一.准备工作</a></li><li><a href="#er-an-zhuang">二.安装</a></li><li><a href="#san-she-zhi-shi-qu">三.设置时区</a></li><li><a href="#si-pei-zhi-zhu-ji-ming">四.配置主机名</a></li><li><a href="#wu-pei-zhi-hosts">五.配置hosts</a></li><li><a href="#liu-yin-dao-xi-tong">六.引导系统</a></li><li><a href="#an-zhuang-wei-ma">|安装微码</a></li><li><a href="#qi-yong-hu-she-zhi">七. 用户设置</a></li><li><a href="#ba-she-zhi-mo-ren-bian-ji-qi">八.设置默认编辑器</a></li><li><a href="#jiu-an-zhuang-wang-luo-qu-dong">九.安装网络驱动</a></li><li><a href="#shi-tui-chu-chroot-bing-chong-qi">十.退出chroot并重启</a></li></ul></li><li><a href="#pei-zhi-xi-tong">配置系统</a></li><li><a href="#yi-wang-luo-pei-zhi">（一）网络配置</a><ul><li><a href="#1-wi-fi">1）Wi-Fi</a></li><li><a href="#2-dhcp">2）dhcp</a></li><li><a href="#3-timezone">3) timezone</a></li><li><a href="#4-set-ntp">4) set-ntp</a></li><li><a href="#5-etc-skel-bashrc">5) /etc/skel/.bashrc</a></li></ul></li><li><a href="#er-an-zhuang-qu-dong">（二）安装驱动</a><ul><li><a href="#1-xian-qia-qu-dong">1）显卡驱动</a></li><li><a href="#2-hong-mo-ban-qu-dong">2）触摸板驱动</a></li><li><a href="#3-an-zhuang-sheng-qia-qu-dong">3）安装声卡驱动</a></li></ul></li><li><a href="#san-an-zhuang-zhuo-mian-yi-gnome-zhuo-mian-wei-li">（三）安装桌面（以gnome桌面为例）</a></li><li><a href="#si-an-zhuang-aur-bao-ruan-jian-guan-li">（四）安装AUR包软件管理</a></li><li><a href="#wu-arch-linux-gnome-zhuo-mian-huan-jing-guan-li-extensions">（五）Arch Linux Gnome桌面环境管理extensions</a></li><li><a href="#liu-gnome-ying-yong-qi-dong-qi">（六）Gnome应用启动器</a></li><li><a href="#qi-shu-ru-fa-an-zhuang">（七）输入法安装</a></li></ul><ul><li><a href="#jian-pan-bu-ju-pei-zhi">键盘布局配置</a></li></ul><!-- tocstop --></div><h2><span id="arch-an-zhuang">Arch安装</span><a href="#arch-an-zhuang" class="header-anchor">#</a></h2><h3><span id="yi-zhun-bei-gong-zuo">一.准备工作</span><a href="#yi-zhun-bei-gong-zuo" class="header-anchor">#</a></h3><h4><span id="1-1-xia-zai-jing-xiang">1.1下载镜像</span><a href="#1-1-xia-zai-jing-xiang" class="header-anchor">#</a></h4><p>地址：</p><div class="code-wrapper"><pre><code class="hljs css">清华：https://mirrors.tuna.tsinghua.edu.cn/archlinux/iso/latest/<span class="hljs-number">163</span>:https://mirrors.<span class="hljs-number">163</span>.com/archlinux/iso/latest/中科大：https://mirrors.ustc.edu.cn/archlinux/iso/latest/上海交通：https://mirror.sjtu.edu.cn/archlinux/iso/latest/北大：https://mirrors.pku.edu.cn/archlinux/iso/latest/</code></pre></div><p>本文是Arch官方文档的再次梳理版</p><div class="code-wrapper"><pre><code class="hljs css">https://wiki.archlinux.org/title/<span class="hljs-built_in">Installation_guide_</span>(%E7%AE%<span class="hljs-number">80%</span>E4%BD%<span class="hljs-number">93%</span>E4%B8%AD%E6%<span class="hljs-number">96%</span><span class="hljs-number">87</span>)</code></pre></div><p>安装方法有很多种比如脚本，实体机，虚拟机</p><p>本文采用虚拟机+SSH安装+UEFI，SSH方便复制命令</p><h3><span id="er-an-zhuang">二.安装</span><a href="#er-an-zhuang" class="header-anchor">#</a></h3><h4><span id="1-jian-pan-bu-ju-mo-ren-wei-us-bu-xu-yao-geng-gai">1.键盘布局,默认为us，不需要更改</span><a href="#1-jian-pan-bu-ju-mo-ren-wei-us-bu-xu-yao-geng-gai" class="header-anchor">#</a></h4><h4><span id="2-yan-zheng-yin-dao-mo-shi">2.验证引导模式</span><a href="#2-yan-zheng-yin-dao-mo-shi" class="header-anchor">#</a></h4><div class="code-wrapper"><pre><code class="hljs bash"><span class="hljs-built_in">ls</span> /sys/firmware/efi/efivars</code></pre></div><p>结果无错误切有目录则是UEFI，反之是BIOS引导</p><h4><span id="3-lian-jie-wang-luo">3.连接网络</span><a href="#3-lian-jie-wang-luo" class="header-anchor">#</a></h4><div class="code-wrapper"><pre><code class="hljs shell">ip link</code></pre></div><p> 用 <a href="https://en.wikipedia.org/wiki/ping_(networking_utility)">ping</a> 检查网络连接 </p><div class="code-wrapper"><pre><code class="hljs shell">ping archlinux.org</code></pre></div><h4><span id="4-geng-xin-xi-tong-shi-jian">4.更新系统时间</span><a href="#4-geng-xin-xi-tong-shi-jian" class="header-anchor">#</a></h4><div class="code-wrapper"><pre><code class="hljs shell">timedatectl set-ntp true</code></pre></div><p>可用 timedatectl status 检查服务状态</p><h4><span id="5-jian-li-ying-pan-fen-qu">5.建立硬盘分区</span><a href="#5-jian-li-ying-pan-fen-qu" class="header-anchor">#</a></h4><p>cfdisk比fdisk配置简单许多，因此本文采用cfdisk</p><div class="code-wrapper"><pre><code class="hljs bash">cfdisk -lcfdisk</code></pre></div><p>UEFI采用GPT分区，一般情况下需要创建</p><table><thead><tr><th><strong>挂载点</strong></th><th>分区</th><th>分区类型</th><th>建议大小</th></tr></thead><tbody><tr><td><code>/mnt/boot</code> 或 <code>/mnt/efi</code></td><td>/dev/<em>efi_system_partition（efi 系统分区）</em></td><td>EFI 系统分区</td><td>至少 260 MiB</td></tr><tr><td>[SWAP]</td><td>/dev/<em>swap_partition（交换空间分区）</em></td><td>Linux swap (交换空间)</td><td>大于 512 MiB</td></tr><tr><td>/mnt</td><td>/dev/<em>root_partition（根分区）</em></td><td>Linux x86-64 根目录 (/)</td><td>剩余空间</td></tr></tbody></table><table><thead><tr><th align="center">文件系统</th><th align="center">创建命令</th><th align="center">工具</th><th align="center"><a href="https://wiki.archlinux.org/title/Archiso">Archiso</a> [<a href="https://gitlab.archlinux.org/archlinux/archiso/blob/master/configs/releng/packages.x86_64">1]</a></th><th align="center">内核文档 [<a href="https://www.kernel.org/doc/html/latest/filesystems/">2]</a></th><th align="center">说明</th></tr></thead><tbody><tr><td align="center"><a href="https://wiki.archlinux.org/title/Btrfs">Btrfs</a></td><td align="center"><a href="https://man.archlinux.org/man/mkfs.btrfs.8">mkfs.btrfs(8)</a></td><td align="center"><a href="https://archlinux.org/packages/?name=btrfs-progs">btrfs-progs</a></td><td align="center">是</td><td align="center"><a href="https://www.kernel.org/doc/html/latest/filesystems/btrfs.html">btrfs.html</a></td><td align="center"><a href="https://btrfs.wiki.kernel.org/index.php/Status">可靠性</a></td></tr><tr><td align="center"><a href="https://wiki.archlinux.org/title/VFAT">VFAT</a></td><td align="center"><a href="https://man.archlinux.org/man/mkfs.fat.8">mkfs.fat(8)</a></td><td align="center"><a href="https://archlinux.org/packages/?name=dosfstools">dosfstools</a></td><td align="center">是</td><td align="center"><a href="https://www.kernel.org/doc/html/latest/filesystems/vfat.html">vfat.html</a></td><td align="center"></td></tr><tr><td align="center"><a href="https://en.wikipedia.org/wiki/exFAT">exFAT</a></td><td align="center"><a href="https://man.archlinux.org/man/mkexfatfs.8">mkexfatfs(8)</a></td><td align="center"><a href="https://archlinux.org/packages/?name=exfat-utils">exfat-utils</a></td><td align="center">是</td><td align="center">N/A (FUSE-based)</td><td align="center"></td></tr><tr><td align="center"><a href="https://wiki.archlinux.org/title/F2FS">F2FS</a></td><td align="center"><a href="https://man.archlinux.org/man/mkfs.f2fs.8">mkfs.f2fs(8)</a></td><td align="center"><a href="https://archlinux.org/packages/?name=f2fs-tools">f2fs-tools</a></td><td align="center">是</td><td align="center"><a href="https://www.kernel.org/doc/html/latest/filesystems/f2fs.html">f2fs.html</a></td><td align="center">基于闪存的设备</td></tr><tr><td align="center"><a href="https://wiki.archlinux.org/title/Ext3">ext3</a></td><td align="center"><a href="https://man.archlinux.org/man/mke2fs.8">mke2fs(8)</a></td><td align="center"><a href="https://archlinux.org/packages/?name=e2fsprogs">e2fsprogs</a></td><td align="center">是 (<a href="https://archlinux.org/packages/?name=base">base</a>)</td><td align="center"><a href="https://www.kernel.org/doc/html/latest/filesystems/ext3.html">ext3.html</a></td><td align="center"></td></tr><tr><td align="center"><a href="https://wiki.archlinux.org/title/Ext4">ext4</a></td><td align="center"><a href="https://man.archlinux.org/man/mke2fs.8">mke2fs(8)</a></td><td align="center"><a href="https://archlinux.org/packages/?name=e2fsprogs">e2fsprogs</a></td><td align="center">是 (<a href="https://archlinux.org/packages/?name=base">base</a>)</td><td align="center"><a href="https://www.kernel.org/doc/Documentation/filesystems/ext4.txt">ext4.txt</a></td><td align="center"></td></tr><tr><td align="center"><a href="https://en.wikipedia.org/wiki/Hierarchical_File_System">HFS</a></td><td align="center">mkfs.hfsplus(8)</td><td align="center"><a href="https://aur.archlinux.org/packages/hfsprogs/">hfsprogs</a>AUR</td><td align="center">否</td><td align="center"><a href="https://www.kernel.org/doc/html/latest/filesystems/hfs.html">hfs.html</a></td><td align="center"><a href="https://en.wikipedia.org/wiki/macOS">macOS</a> (8.x-10.12.x) 文件系统</td></tr><tr><td align="center"><a href="https://wiki.archlinux.org/title/JFS">JFS</a></td><td align="center"><a href="https://man.archlinux.org/man/mkfs.jfs.8">mkfs.jfs(8)</a></td><td align="center"><a href="https://archlinux.org/packages/?name=jfsutils">jfsutils</a></td><td align="center">是 (<a href="https://archlinux.org/packages/?name=base">base</a>)</td><td align="center"><a href="https://www.kernel.org/doc/Documentation/filesystems/jfs.txt">jfs.txt</a></td><td align="center"></td></tr><tr><td align="center"><a href="https://en.wikipedia.org/wiki/NILFS">NILFS2</a></td><td align="center"><a href="https://man.archlinux.org/man/mkfs.nilfs2.8">mkfs.nilfs2(8)</a></td><td align="center"><a href="https://archlinux.org/packages/?name=nilfs-utils">nilfs-utils</a></td><td align="center">是</td><td align="center"><a href="https://www.kernel.org/doc/html/latest/filesystems/nilfs2.html">nilfs2.html</a></td><td align="center"></td></tr><tr><td align="center"><a href="https://wiki.archlinux.org/title/NTFS">NTFS</a></td><td align="center"><a href="https://man.archlinux.org/man/mkfs.ntfs.8">mkfs.ntfs(8)</a></td><td align="center"><a href="https://archlinux.org/packages/?name=ntfs-3g">ntfs-3g</a></td><td align="center">是</td><td align="center">N/A (FUSE-based)</td><td align="center"><a href="https://en.wikipedia.org/wiki/Microsoft_Windows">Windows</a> 文件系统</td></tr><tr><td align="center"><a href="https://wiki.archlinux.org/title/Reiser4">Reiser4</a></td><td align="center">mkfs.reiser4(8)</td><td align="center"><a href="https://aur.archlinux.org/packages/reiser4progs/">reiser4progs</a>AUR</td><td align="center">否</td><td align="center"></td><td align="center"></td></tr><tr><td align="center"><a href="https://en.wikipedia.org/wiki/ReiserFS">ReiserFS</a></td><td align="center"><a href="https://man.archlinux.org/man/mkfs.reiserfs.8">mkfs.reiserfs(8)</a></td><td align="center"><a href="https://archlinux.org/packages/?name=reiserfsprogs">reiserfsprogs</a></td><td align="center">是 (<a href="https://archlinux.org/packages/?name=base">base</a>)</td><td align="center"></td><td align="center"></td></tr><tr><td align="center"><a href="https://en.wikipedia.org/wiki/Universal_Disk_Format">UDF</a></td><td align="center"><a href="https://man.archlinux.org/man/mkfs.udf.8">mkfs.udf(8)</a></td><td align="center"><a href="https://archlinux.org/packages/?name=udftools">udftools</a></td><td align="center">Optional</td><td align="center"><a href="https://www.kernel.org/doc/html/latest/filesystems/udf.html">udf.html</a></td><td align="center"></td></tr><tr><td align="center"><a href="https://wiki.archlinux.org/title/XFS">XFS</a></td><td align="center"><a href="https://man.archlinux.org/man/mkfs.xfs.8">mkfs.xfs(8)</a></td><td align="center"><a href="https://archlinux.org/packages/?name=xfsprogs">xfsprogs</a></td><td align="center">是 (<a href="https://archlinux.org/packages/?name=base">base</a>)</td><td align="center"><a href="https://www.kernel.org/doc/Documentation/filesystems/xfs.txt">xfs.txt</a> <a href="https://www.kernel.org/doc/html/latest/filesystems/xfs-delayed-logging-design.html">xfs-delayed-logging-design.html</a> <a href="https://www.kernel.org/doc/html/latest/filesystems/xfs-self-describing-metadata.html">xfs-self-describing-metadata.html</a></td><td align="center"></td></tr><tr><td align="center"><a href="https://wiki.archlinux.org/title/ZFS">ZFS</a></td><td align="center"></td><td align="center"><a href="https://aur.archlinux.org/packages/zfs-linux/">zfs-linux</a>AUR</td><td align="center">否</td><td align="center">N/A (<a href="https://en.wikipedia.org/wiki/OpenZFS">OpenZFS</a> 移植)</td><td align="center"></td></tr></tbody></table><p>本文创建俩分区：根分区和ESP分区，ESP分区300M，根分区剩余全部空间</p><h4><span id="6-ge-shi-hua-shang-bian-chuang-jian-de-fen-qu">6.格式化上边创建的分区</span><a href="#6-ge-shi-hua-shang-bian-chuang-jian-de-fen-qu" class="header-anchor">#</a></h4><div class="code-wrapper"><pre><code class="hljs bash">mkfs.ext4 /dev/sda2 //根分区mkfs.vfat /dev/sda1//ESP分区</code></pre></div><h4><span id="7-gua-zai-ge-shi-hua-hou-de-fen-qu">7.挂载格式化后的分区</span><a href="#7-gua-zai-ge-shi-hua-hou-de-fen-qu" class="header-anchor">#</a></h4><p>挂载有先后顺序， 先挂载根（root）分区（到 <code>/mnt</code>），再挂载引导（boot）分区（到 <code>/mnt/boot</code> 或 <code>/mnt/efi</code> ， 否则您可能遇到安装完成后无法启动系统的问题 </p><div class="code-wrapper"><pre><code class="hljs bash">mount /dev/sda2 /mnt<span class="hljs-built_in">mkdir</span> /mnt/efimount /dev/sda1 /mnt/efi</code></pre></div><h4><span id="8-geng-huan-ruan-jian-yuan">8.更换软件源</span><a href="#8-geng-huan-ruan-jian-yuan" class="header-anchor">#</a></h4><div class="code-wrapper"><pre><code class="hljs bash">curl -L -o /etc/pacman.d/mirrorlist <span class="hljs-string">"https://www.archlinux.org/mirrorlist/?country=CN"</span></code></pre></div><p> 编辑<code>/etc/pacman.d/mirrorlist</code>，反注释其中一个或多个链接 </p><p>本文采用中科大和清华源</p><div class="code-wrapper"><pre><code class="hljs bash">vim /etc/pacman.d/mirrorlistServer = https://mirrors.tuna.tsinghua.edu.cn/archlinux/<span class="hljs-variable">$repo</span>/os/<span class="hljs-variable">$arch</span>Server = https://mirrors.ustc.edu.cn/archlinux/<span class="hljs-variable">$repo</span>/os/<span class="hljs-variable">$arch</span></code></pre></div><h4><span id="9-an-zhuang-xi-tong-dao-ci-pan">9.安装系统到磁盘</span><a href="#9-an-zhuang-xi-tong-dao-ci-pan" class="header-anchor">#</a></h4><p>基础包：</p><div class="code-wrapper"><pre><code class="hljs bash">pacstrap /mnt base base-devel linux linux-firmware  <span class="hljs-comment">#base-devel在AUR包的安装是必须的</span></code></pre></div><p> 功能性软件 :</p><div class="code-wrapper"><pre><code class="hljs bash">pacstrap /mnt vim nano ctags wget clang clangd gcc g++ cmake make git networkmanager dhcpcd iwd sudo bash-completion openssh   <span class="hljs-comment">#一个有线所需 一个无线所需 一个编辑器  一个提权工具 一个补全工具 iwd也需要dhcpcd</span></code></pre></div><h4><span id="10-pei-zhi-xi-tong">10.配置系统</span><a href="#10-pei-zhi-xi-tong" class="header-anchor">#</a></h4><div class="code-wrapper"><pre><code class="hljs bash">genfstab -U /mnt &gt;&gt; /mnt/etc/fstab<span class="hljs-built_in">cat</span> /mnt/etc/fstab</code></pre></div><h4><span id="11-qie-huan-dao-xin-xi-tong">11.切换到新系统</span><a href="#11-qie-huan-dao-xin-xi-tong" class="header-anchor">#</a></h4><div class="code-wrapper"><pre><code class="hljs bash">arch-chroot /mnt</code></pre></div><h3><span id="san-she-zhi-shi-qu">三.设置时区</span><a href="#san-she-zhi-shi-qu" class="header-anchor">#</a></h3><p> 本地时区配置 </p><div class="code-wrapper"><pre><code class="hljs bash"><span class="hljs-built_in">ln</span> -sf /usr/share/zoneinfo/Asia/Shanghai /etc/localtime</code></pre></div><p> 生成 <code>/etc/adjtime</code> </p><div class="code-wrapper"><pre><code class="hljs bash">hwclock --systohc --utc</code></pre></div><p>本地化： 明确规定了地域、货币、时区日期的格式、字符排列方式和其他本地化标准。</p><p> 需在这两个文件设置：<code>locale.gen</code> 与 <code>locale.conf</code>。 </p><p>编辑 <code>/etc/locale.gen</code>，然后取消掉 <code>en_US.UTF-8 UTF-8</code>，<code>zh_CN.UTF-8 UTF-8</code> 和其他需要的 <a href="https://wiki.archlinux.org/title/Locale_(%E7%AE%80%E4%BD%93%E4%B8%AD%E6%96%87)">地区</a> 前的注释（#）。</p><p>接着执行 <code>locale-gen</code> 以生成 locale 信息：</p><div class="code-wrapper"><pre><code class="hljs bash">locale-gen</code></pre></div><p> 编辑： /etc/locale.conf  </p><div class="code-wrapper"><pre><code class="hljs bash"><span class="hljs-built_in">echo</span> <span class="hljs-string">'LANG=en_US.UTF-8'</span>  &gt; /etc/locale.conf</code></pre></div><h3><span id="si-pei-zhi-zhu-ji-ming">四.配置主机名</span><a href="#si-pei-zhi-zhu-ji-ming" class="header-anchor">#</a></h3><p> 编辑<code>/etc/hostname</code>，写入<code>myhostname</code>  默认为archlinux </p><div class="code-wrapper"><pre><code class="hljs bash"><span class="hljs-built_in">echo</span> <span class="hljs-string">"archlinux"</span> &gt;&gt; /etc/hostname</code></pre></div><h3><span id="wu-pei-zhi-hosts">五.配置hosts</span><a href="#wu-pei-zhi-hosts" class="header-anchor">#</a></h3><p> 编辑<code>/etc/hosts</code>，把<code>myhostname</code>改为你自己的主机名 </p><div class="code-wrapper"><pre><code class="hljs bash">127.0.0.1   localhost::1         localhost127.0.1.1   archlinux.localdomain  archlinux</code></pre></div><h3><span id="liu-yin-dao-xi-tong">六.引导系统</span><a href="#liu-yin-dao-xi-tong" class="header-anchor">#</a></h3><h4><span id="1-grub-yin-dao-windows-huo-qi-ta-linux">1）Grub引导Windows或其他Linux</span><a href="#1-grub-yin-dao-windows-huo-qi-ta-linux" class="header-anchor">#</a></h4><div class="code-wrapper"><pre><code class="hljs bash">pacman -S os-prober</code></pre></div><h4><span id="2-zhu-ban-zhi-chi-uefi-yin-dao">2)    主板支持UEFI引导</span><a href="#2-zhu-ban-zhi-chi-uefi-yin-dao" class="header-anchor">#</a></h4><h3><span id="an-zhuang-wei-ma">|安装微码</span><a href="#an-zhuang-wei-ma" class="header-anchor">#</a></h3><div class="code-wrapper"><pre><code class="hljs bash">pacman -S intel-ucode   <span class="hljs-comment">#Intel</span>pacman -S amd-ucode     <span class="hljs-comment">#AMD</span></code></pre></div><h5><span id="2-1-xia-zai-grub-an-zhuang-shi-suo-bi-xu-de-wen-jian">2.1)    下载grub安装时所必需的文件</span><a href="#2-1-xia-zai-grub-an-zhuang-shi-suo-bi-xu-de-wen-jian" class="header-anchor">#</a></h5><div class="code-wrapper"><pre><code class="hljs bash">pacman -S grub efibootmgr</code></pre></div><h5><span id="2-2-an-zhuang-grub">2.2)    安装grub</span><a href="#2-2-an-zhuang-grub" class="header-anchor">#</a></h5><div class="code-wrapper"><pre><code class="hljs bash">grub-install --target=x86_64-efi --efi-directory=/efi --bootloader-id=GRUB</code></pre></div><p> 编辑/etc/default/grub 文件，去掉<code>GRUB_CMDLINE_LINUX_DEFAULT</code>一行中最后的 quiet 参数，同时把 log level 的数值从 3 改成 5。这样是为了后续如果出现系统错误，方便排错。同时加入 nowatchdog 参数，这可以显著提高开关机速度 </p><h5><span id="2-3-geng-xin-grub">2.3)     更新grub</span><a href="#2-3-geng-xin-grub" class="header-anchor">#</a></h5><div class="code-wrapper"><pre><code class="hljs bash">grub-mkconfig -o /boot/grub/grub.cfg</code></pre></div><h3><span id="qi-yong-hu-she-zhi">七.    用户设置</span><a href="#qi-yong-hu-she-zhi" class="header-anchor">#</a></h3><div class="code-wrapper"><pre><code class="hljs bash">vim /etc/hostname <span class="hljs-comment">#输入主机名，只能输入字母</span>passwd root <span class="hljs-comment">#设置root密码</span>useradd -m -g <span class="hljs-built_in">users</span> -G wheel -s /bin/bash username <span class="hljs-comment">#添加用户</span>passwd username <span class="hljs-comment">#设置用户密码</span>vim /etc/sudoers <span class="hljs-comment">#为用户添加sudo权限 反注释%wheel ALL=(ALL) ALL</span><span class="hljs-comment">#如果想在输入密码时显示星号，可以追加Defaults env_reset,pwfeedback</span></code></pre></div><h3><span id="ba-she-zhi-mo-ren-bian-ji-qi">八.设置默认编辑器</span><a href="#ba-she-zhi-mo-ren-bian-ji-qi" class="header-anchor">#</a></h3><div class="code-wrapper"><pre><code class="hljs bash"><span class="hljs-built_in">ln</span> -f /usr/bin/vim /usr/bin/vi</code></pre></div><h3><span id="jiu-an-zhuang-wang-luo-qu-dong">九.安装网络驱动</span><a href="#jiu-an-zhuang-wang-luo-qu-dong" class="header-anchor">#</a></h3><h4><span id="1-wifi">1）wifi</span><a href="#1-wifi" class="header-anchor">#</a></h4><div class="code-wrapper"><pre><code class="hljs bash">pacman -S netctl iw wpa_supplicant dialog networkmanagerpacman -S broadcom-wl <span class="hljs-comment">#博通无线网卡驱动</span></code></pre></div><h4><span id="2-you-xian-lian-jie-dhcp">2）有线连接dhcp</span><a href="#2-you-xian-lian-jie-dhcp" class="header-anchor">#</a></h4><div class="code-wrapper"><pre><code class="hljs bash">pacman -S dhcp dhcpcd</code></pre></div><h3><span id="shi-tui-chu-chroot-bing-chong-qi">十.退出chroot并重启</span><a href="#shi-tui-chu-chroot-bing-chong-qi" class="header-anchor">#</a></h3><div class="code-wrapper"><pre><code class="hljs bash"><span class="hljs-comment"># 退出chroot</span><span class="hljs-built_in">exit</span><span class="hljs-comment"># 卸载 /mnt</span>umount -R /mnt<span class="hljs-comment"># 重启电脑</span>reboot</code></pre></div><blockquote><p><strong>注意</strong><br>运行reboot命令后，请拔掉U盘<br>使用ssh或其他Linux发行版本安装的用户请在新系统中配置好ssh环境，重启后可以直接ssh连接（需要安装net-tools软件包，不然无法运行ifconfig命令）</p></blockquote><h2><span id="pei-zhi-xi-tong">配置系统</span><a href="#pei-zhi-xi-tong" class="header-anchor">#</a></h2><h2><span id="yi-wang-luo-pei-zhi">（一）网络配置</span><a href="#yi-wang-luo-pei-zhi" class="header-anchor">#</a></h2><h3><span id="1-wi-fi">1）Wi-Fi</span><a href="#1-wi-fi" class="header-anchor">#</a></h3><p> 最新版的arch可能没有wifi-menu命令 </p><div class="code-wrapper"><pre><code class="hljs bash">sudo wifi-menu</code></pre></div><h3><span id="2-dhcp">2）dhcp</span><a href="#2-dhcp" class="header-anchor">#</a></h3><p>有线连接</p><div class="code-wrapper"><pre><code class="hljs bash">sudo systemctl <span class="hljs-built_in">enable</span> --now dhcpcd</code></pre></div><h3><span id="3-timezone">3) timezone</span><a href="#3-timezone" class="header-anchor">#</a></h3><p>设置系统时区</p><div class="code-wrapper"><pre><code class="hljs bash">sudo timedatectl set-timezone Asia/Shanghai</code></pre></div><h3><span id="4-set-ntp">4) set-ntp</span><a href="#4-set-ntp" class="header-anchor">#</a></h3><p>网络时间同步</p><div class="code-wrapper"><pre><code class="hljs bash">sudo timedatectl set-ntp <span class="hljs-literal">true</span></code></pre></div><p>查看时间状态</p><div class="code-wrapper"><pre><code class="hljs bash">timedatectl status</code></pre></div><h3><span id="5-etc-skel-bashrc">5) /etc/skel/.bashrc</span><a href="#5-etc-skel-bashrc" class="header-anchor">#</a></h3><p>编辑用户配置文件.bashrc以在终端显示文件夹，以颜色</p><div class="code-wrapper"><pre><code class="hljs bash"><span class="hljs-built_in">cd</span> /etc/skel/<span class="hljs-built_in">ls</span> -lavim .bashrc</code></pre></div><p>在PS1之前添加如下文本</p><div class="code-wrapper"><pre><code class="hljs bash"><span class="hljs-built_in">export</span> EDITOR=vim<span class="hljs-built_in">alias</span> <span class="hljs-built_in">ls</span>=<span class="hljs-string">'ls --color=auto'</span><span class="hljs-built_in">alias</span> grep=<span class="hljs-string">'grep --color=auto'</span><span class="hljs-built_in">alias</span> egrep=<span class="hljs-string">'egrep --color=auto'</span><span class="hljs-built_in">alias</span> fgrep=<span class="hljs-string">'fgrep --color=auto'</span>[ ! -e ~/.dircolors ] &amp;&amp; <span class="hljs-built_in">eval</span> $(<span class="hljs-built_in">dircolors</span> -p &gt; ~/.dircolors)[ -e /bin/dircolors ] &amp;&amp; <span class="hljs-built_in">eval</span> $(<span class="hljs-built_in">dircolors</span> -b &gt; ~/.dircolors)</code></pre></div><p>覆盖家目录的文件</p><div class="code-wrapper"><pre><code class="hljs bash"><span class="hljs-built_in">cp</span> -a . ~</code></pre></div><h2><span id="er-an-zhuang-qu-dong">（二）安装驱动</span><a href="#er-an-zhuang-qu-dong" class="header-anchor">#</a></h2><h3><span id="1-xian-qia-qu-dong">1）显卡驱动</span><a href="#1-xian-qia-qu-dong" class="header-anchor">#</a></h3><p> 运行<code>lspci | grep VGA</code>查看显卡型号 按照自己的显卡型号安装相应驱动 </p><table><thead><tr><th align="center">显卡</th><th align="center">驱动名称</th></tr></thead><tbody><tr><td align="center">Intel</td><td align="center">xf86-video-intel vulkan-intel mesa</td></tr><tr><td align="center">NVIDIA</td><td align="center">nvidia nvidia-utils nvidia-settings opencl-nvidia lib32-opencl-nvidia lib32-nvidia-utils</td></tr><tr><td align="center"><del>开源NVIDIA(不推荐)</del></td><td align="center"><del>xf86-video-nouveau</del></td></tr><tr><td align="center">AMD</td><td align="center">xf86-video-amdgpu xf86-video-ati mesa vulkan-radeom</td></tr></tbody></table><p> <strong>FBI Warning</strong><br>千万不要安装nouveau，千万不要安装nouveau，千万不要安装nouveau！重要的事情说三遍。如果你不怕电脑莫名卡死，当我没说。（doge）<br>ps：博主受过nouveau的折磨 </p><h3><span id="2-hong-mo-ban-qu-dong">2）触摸板驱动</span><a href="#2-hong-mo-ban-qu-dong" class="header-anchor">#</a></h3><div class="code-wrapper"><pre><code class="hljs bash">sudo pacman -S xf86-input-synaptics //笔记本,外置触摸</code></pre></div><h3><span id="3-an-zhuang-sheng-qia-qu-dong">3）安装声卡驱动</span><a href="#3-an-zhuang-sheng-qia-qu-dong" class="header-anchor">#</a></h3><div class="code-wrapper"><pre><code class="hljs bash">pacman -S alsa-utils pulseaudio pulseaudio-bluetooth cups</code></pre></div><h2><span id="san-an-zhuang-zhuo-mian-yi-gnome-zhuo-mian-wei-li">（三）安装桌面（以gnome桌面为例）</span><a href="#san-an-zhuang-zhuo-mian-yi-gnome-zhuo-mian-wei-li" class="header-anchor">#</a></h2><p>安装x窗口系统</p><div class="code-wrapper"><pre><code class="hljs bash"><span class="hljs-comment">#安装英文字体</span>sudo pacman -S ttf-dejavu ttf-droid ttf-hack ttf-fonts-awesome otf-font-awesome ttf-lato ttf-liberation ttf-linux-libertine ttf-opensans ttf-roboto ttf-ubuntu-font-family <span class="hljs-comment">#安装中文字体</span>sudo pacman -S ttf-hannom noto-fonts noto-fonts-extra noto-fonts-cjk noto-fonts-emoji adobe-source-code-oro-fonts adobe-source-sans-fonts adobe-source-serif-fonts adobe-source-han-serif-cn-fonts adobe-source-han-sans-cn-fonts adobe-source-han-sans-hk-fonts adobe-source-han-sans-tw-fonts  wqy-zenhei wqy-microheisudo vim /etc/locale.conf <span class="hljs-comment">#将语言改成中文</span><span class="hljs-comment"># 将英语注释掉，添加以下内容LANG=zh_CN.UTF-8</span>locale-gensudo pacman -S xorg <span class="hljs-comment">#安装x窗口系统</span></code></pre></div><p>安装kde桌面</p><div class="code-wrapper"><pre><code class="hljs bash">sudo pacman -S plasma-meta plasma-nm konsole dolphin kde-connect firefox <span class="hljs-comment">#简洁的kde桌面</span>sudo pacman -S plasma plasma-nm kde-applications <span class="hljs-comment">#kde全家桶</span>sudo systemctl <span class="hljs-built_in">enable</span> sddm <span class="hljs-comment">#启动sddm服务</span>sudo systemctl <span class="hljs-built_in">enable</span> NetworkManager <span class="hljs-comment">#启动网络管理器</span>sudo reboot重启</code></pre></div><p>安装gnome桌面</p><div class="code-wrapper"><pre><code class="hljs bash">pacman -S gnome gnome-extra gdm<span class="hljs-comment">#(gdb是登陆管理器)</span>systemctl <span class="hljs-built_in">enable</span> gdm.servicereboot</code></pre></div><p>开启字体渲染引擎</p><div class="code-wrapper"><pre><code class="hljs bash">vim /etc/profile.d/freetype2.sh</code></pre></div><p>去掉 <code>#export FREETYPE_PROPERTIES="truetype:interpreter-version=40"</code> 的 <code>#</code> 号</p><p>清空无用缓存和语言</p><div class="code-wrapper"><pre><code class="hljs bash">pacman -Scc</code></pre></div><h2><span id="si-an-zhuang-aur-bao-ruan-jian-guan-li">（四）安装AUR包软件管理</span><a href="#si-an-zhuang-aur-bao-ruan-jian-guan-li" class="header-anchor">#</a></h2><div class="code-wrapper"><pre><code class="hljs bash">git <span class="hljs-built_in">clone</span> https://aur.archlinux.org/paru.git</code></pre></div><p>打包工具</p><div class="code-wrapper"><pre><code class="hljs bash">sudo vim /etc/makepkg.conf</code></pre></div><p>取消注释<code>#MAKEFLAGS="-j$(nproc)"</code></p><div class="code-wrapper"><pre><code class="hljs bash">makepkg -si</code></pre></div><p>此时<code>paru</code>已经被安装了</p><p>修改paru排序的相关性，倒序</p><div class="code-wrapper"><pre><code class="hljs bash">vim /etc/paru.conf<span class="hljs-comment"># 取消注释#BottomUp</span></code></pre></div><h2><span id="wu-arch-linux-gnome-zhuo-mian-huan-jing-guan-li-extensions">（五）Arch Linux Gnome桌面环境管理extensions</span><a href="#wu-arch-linux-gnome-zhuo-mian-huan-jing-guan-li-extensions" class="header-anchor">#</a></h2><p>Gnome桌面管理extensions是内置的，但主题较少，在archwiki可以用-theme搜索到想要的主题<br>然后用：</p><div class="code-wrapper"><pre><code class="hljs bash">sudo pacman -S 主题名</code></pre></div><h2><span id="liu-gnome-ying-yong-qi-dong-qi">（六）Gnome应用启动器</span><a href="#liu-gnome-ying-yong-qi-dong-qi" class="header-anchor">#</a></h2><p>要使用Gnome启动器要先安装connector,此文件在AUR里，所以要使用paru安装<br><code>https://extensions.gnome.org</code></p><div class="code-wrapper"><pre><code class="hljs bash">paru chrome-gnome-shell</code></pre></div><p>安装<code>dash to dock</code><br><code>blur my shell</code></p><p><code>ArcMenu</code></p><p><code>Vitals</code></p><p><code>Just Perfection</code></p><h2><span id="qi-shu-ru-fa-an-zhuang">（七）输入法安装</span><a href="#qi-shu-ru-fa-an-zhuang" class="header-anchor">#</a></h2><p>fcitx5</p><div class="code-wrapper"><pre><code class="hljs bash">sudo pacman -S fcitx5-im fcitx5-chinese-addons fcitx5-material-color</code></pre></div><p>环境变量与故障处理,wps和firefox无法正确输入<br>编辑<code>~/.pam_environment</code></p><div class="code-wrapper"><pre><code class="hljs bash">GTK_IM_MODULE DEFAULT=fcitxQT_IM_MODULE  DEFAULT=fcitxXMODIFIERS    DEFAULT=@im=fcitx</code></pre></div><p>主题安装</p><div class="code-wrapper"><pre><code class="hljs bash">sudo pacman -S fcitx5-nord</code></pre></div><p>输入法联想与准确度</p><ol><li>fcitx5-config-qt配置工具选择Input Method下Pinyin,选择Enable Cloud Pinyin，字库(Cloud Pinyin)来自Baidu。</li><li>离线字库Dictionaries<br>加入清华的源需要编辑<code>/etc/pacman.conf</code><div class="code-wrapper"><pre><code class="hljs bash">[archlinuxcn]Server = https://mirrors.tuna.tsinghua.edu.cn/archlinuxcn/<span class="hljs-variable">$arch</span></code></pre></div></li></ol><p>更新数据库</p><div class="code-wrapper"><pre><code class="hljs bash">sudo pacman -Syy</code></pre></div><p>安装拼音联想词库</p><div class="code-wrapper"><pre><code class="hljs bash">sudo pacman -S archlinuxcn-keyring fcitx5-pinyin-moegirl fcitx5-pinyin-zhwiki</code></pre></div><h1><span id="jian-pan-bu-ju-pei-zhi">键盘布局配置</span><a href="#jian-pan-bu-ju-pei-zhi" class="header-anchor">#</a></h1><p>编辑：</p><div class="code-wrapper"><pre><code class="hljs bash">/etc/vconsole.confKEYMAP=de-latin1</code></pre></div>]]></content>
    
    
    
    <tags>
      
      <tag>Linux</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C++线程池</title>
    <link href="/2021/12/24/C-%E7%BA%BF%E7%A8%8B%E6%B1%A0/"/>
    <url>/2021/12/24/C-%E7%BA%BF%E7%A8%8B%E6%B1%A0/</url>
    
    <content type="html"><![CDATA[<div class="toc"><!-- toc --><ul><li><a href="#c-xian-cheng-chi">C++线程池</a><ul><li><a href="#ren-wu-lei"><strong>任务类</strong></a></li><li><a href="#xian-cheng-chi-lei"><strong>线程池类</strong></a></li><li><a href="#ce-shi"><strong>测试</strong></a></li></ul></li></ul><!-- tocstop --></div><h1><span id="c-xian-cheng-chi">C++线程池</span><a href="#c-xian-cheng-chi" class="header-anchor">#</a></h1><h2><span id="ren-wu-lei"><strong>任务类</strong></span><a href="#ren-wu-lei" class="header-anchor">#</a></h2><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">pragma</span> once</span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;mutex&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;queue&gt;</span></span><span class="hljs-comment">// 定义任务结构体</span><span class="hljs-keyword">using</span> callback = <span class="hljs-built_in">void</span> (*)(<span class="hljs-type">void</span> *);<span class="hljs-keyword">struct</span> <span class="hljs-title class_">Task</span> {    <span class="hljs-built_in">Task</span>() {        <span class="hljs-keyword">this</span>-&gt;function = <span class="hljs-literal">nullptr</span>;        <span class="hljs-keyword">this</span>-&gt;arg = <span class="hljs-literal">nullptr</span>;    }    <span class="hljs-built_in">Task</span>(callback f, <span class="hljs-type">void</span> *arg) {        <span class="hljs-keyword">this</span>-&gt;function = f;        <span class="hljs-keyword">this</span>-&gt;arg = arg;    }    callback function;    <span class="hljs-type">void</span> *arg;};<span class="hljs-keyword">class</span> <span class="hljs-title class_">TaskQueue</span> {<span class="hljs-keyword">public</span>:    <span class="hljs-built_in">TaskQueue</span>();    ~<span class="hljs-built_in">TaskQueue</span>();    <span class="hljs-comment">// 添加任务</span>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">addTask</span><span class="hljs-params">(Task task)</span></span>;    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">addTask</span><span class="hljs-params">(callback f, <span class="hljs-type">void</span> *arg)</span></span>;    <span class="hljs-comment">// 取出一个任务</span>    <span class="hljs-function">Task <span class="hljs-title">getTask</span><span class="hljs-params">()</span></span>;    <span class="hljs-comment">// 判断队列任务是否为空</span>    <span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">bool</span> <span class="hljs-title">empty</span><span class="hljs-params">()</span> </span>{ <span class="hljs-keyword">return</span> m_taskQ.<span class="hljs-built_in">empty</span>(); }    <span class="hljs-comment">// 当前任务个数</span>    <span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">int</span> <span class="hljs-title">gettaskNumber</span><span class="hljs-params">()</span> </span>{ <span class="hljs-keyword">return</span> m_taskQ.<span class="hljs-built_in">size</span>(); }<span class="hljs-keyword">private</span>:    std::queue&lt;Task&gt; m_taskQ;    std::mutex m_mutex;};</code></pre></div><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">"TaskQueue.h"</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;mutex&gt;</span></span><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">TaskQueue::addTask</span><span class="hljs-params">(Task task)</span> </span>{    <span class="hljs-function">std::unique_lock&lt;std::mutex&gt; <span class="hljs-title">lk</span><span class="hljs-params">(m_mutex)</span></span>;    m_taskQ.<span class="hljs-built_in">push</span>(task);}<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">TaskQueue::addTask</span><span class="hljs-params">(callback f, <span class="hljs-type">void</span> *arg)</span> </span>{    <span class="hljs-function">std::unique_lock&lt;std::mutex&gt; <span class="hljs-title">lk</span><span class="hljs-params">(m_mutex)</span></span>;    m_taskQ.<span class="hljs-built_in">push</span>(<span class="hljs-built_in">Task</span>(f, arg));}<span class="hljs-function">Task <span class="hljs-title">TaskQueue::getTask</span><span class="hljs-params">()</span> </span>{    Task task;    <span class="hljs-keyword">if</span> (!m_taskQ.<span class="hljs-built_in">empty</span>()) {        <span class="hljs-function">std::unique_lock&lt;std::mutex&gt; <span class="hljs-title">lk</span><span class="hljs-params">(m_mutex)</span></span>;        task = m_taskQ.<span class="hljs-built_in">front</span>();        m_taskQ.<span class="hljs-built_in">pop</span>();    }    <span class="hljs-keyword">return</span> task;}TaskQueue::<span class="hljs-built_in">TaskQueue</span>() {}TaskQueue::~<span class="hljs-built_in">TaskQueue</span>() {}</code></pre></div><h2><span id="xian-cheng-chi-lei"><strong>线程池类</strong></span><a href="#xian-cheng-chi-lei" class="header-anchor">#</a></h2><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">pragma</span> once</span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">"TaskQueue.h"</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;atomic&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;condition_variable&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;mutex&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;thread&gt;</span></span><span class="hljs-keyword">class</span> <span class="hljs-title class_">ThreadPool</span> {<span class="hljs-keyword">public</span>:    <span class="hljs-comment">// 创建线程池并初始化</span>    <span class="hljs-built_in">ThreadPool</span>(<span class="hljs-type">int</span> min, <span class="hljs-type">int</span> max);    <span class="hljs-comment">// 给线程池添加任务</span>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">addTask</span><span class="hljs-params">(Task task)</span></span>;    <span class="hljs-comment">// 获取线程池中工作的线程的个数</span>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">getBusyNumber</span><span class="hljs-params">()</span></span>;    <span class="hljs-comment">// 获取线程池中活着的线程的个数</span>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">getAliveNumber</span><span class="hljs-params">()</span></span>;    <span class="hljs-comment">// static ThreadPool *instance();</span>    <span class="hljs-comment">// static ThreadPool &amp;Instance();</span>    <span class="hljs-comment">// 销毁线程池</span>    ~<span class="hljs-built_in">ThreadPool</span>();    <span class="hljs-built_in">ThreadPool</span>();<span class="hljs-keyword">private</span>:    <span class="hljs-comment">//////////////////////</span>    <span class="hljs-comment">// 工作的线程(消费者线程)任务函数</span>    <span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">void</span> *<span class="hljs-title">worker</span><span class="hljs-params">(<span class="hljs-type">void</span> *arg)</span></span>;    <span class="hljs-comment">// 管理者线程任务函数</span>    <span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">void</span> *<span class="hljs-title">manager</span><span class="hljs-params">(<span class="hljs-type">void</span> *arg)</span></span>;<span class="hljs-keyword">private</span>:    <span class="hljs-comment">// 任务队列</span>    TaskQueue *taskQ;    <span class="hljs-type">int</span> minNum;              <span class="hljs-comment">// 最小线程数量</span>    <span class="hljs-type">int</span> maxNum;              <span class="hljs-comment">// 最大线程数量</span>    <span class="hljs-type">int</span> busyNum;             <span class="hljs-comment">// 忙的线程的个数</span>    <span class="hljs-type">int</span> liveNum;             <span class="hljs-comment">// 存活的线程的个数</span>    std::atomic_int exitNum; <span class="hljs-comment">// 要销毁的线程个数</span>    std::condition_variable m_notEmpty;    std::mutex m_mutex;    <span class="hljs-type">static</span> <span class="hljs-type">const</span> <span class="hljs-type">int</span> NUMBER = <span class="hljs-number">2</span>;    <span class="hljs-type">int</span> shutdown; <span class="hljs-comment">// 是不是要销毁线程池, 销毁为1, 不销毁为0</span>};</code></pre></div><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">"ThreadPool.h"</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;chrono&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;mutex&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;thread&gt;</span></span><span class="hljs-comment">// 创建线程池并初始化</span>ThreadPool::<span class="hljs-built_in">ThreadPool</span>(<span class="hljs-type">int</span> min, <span class="hljs-type">int</span> max) {    <span class="hljs-keyword">do</span> {        taskQ = <span class="hljs-keyword">new</span> TaskQueue;        <span class="hljs-keyword">if</span> (<span class="hljs-literal">nullptr</span> == taskQ) {            std::cout &lt;&lt; <span class="hljs-string">"malloc taskQ fail..."</span> &lt;&lt; std::endl;            <span class="hljs-keyword">break</span>;        }        minNum = min;        maxNum = max;        busyNum = <span class="hljs-number">0</span>;        liveNum = min; <span class="hljs-comment">// 和最小个数相等</span>        exitNum = <span class="hljs-number">0</span>;        shutdown = <span class="hljs-literal">false</span>;        <span class="hljs-comment">// 管理者线程</span>        <span class="hljs-function">std::thread <span class="hljs-title">manager_thread</span><span class="hljs-params">(manager, <span class="hljs-keyword">this</span>)</span></span>;        std::cout &lt;&lt; <span class="hljs-string">"manager_thread created id: "</span> &lt;&lt; manager_thread.<span class="hljs-built_in">get_id</span>()            &lt;&lt; <span class="hljs-string">'\n'</span>;        manager_thread.<span class="hljs-built_in">detach</span>();        <span class="hljs-comment">// 工作者线程</span>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; min; ++i) {            <span class="hljs-function">std::thread <span class="hljs-title">worker_thread</span><span class="hljs-params">(worker, <span class="hljs-keyword">this</span>)</span></span>;            std::cout &lt;&lt; <span class="hljs-string">"worker_thread created "</span> &lt;&lt; worker_thread.<span class="hljs-built_in">get_id</span>() &lt;&lt; <span class="hljs-string">'\n'</span>;            worker_thread.<span class="hljs-built_in">detach</span>();        }        <span class="hljs-keyword">return</span>;    } <span class="hljs-keyword">while</span> (<span class="hljs-number">0</span>);    <span class="hljs-comment">// 释放资源</span>    <span class="hljs-keyword">if</span> (taskQ) {        <span class="hljs-keyword">delete</span> taskQ;        taskQ = <span class="hljs-literal">nullptr</span>;    }}ThreadPool::~<span class="hljs-built_in">ThreadPool</span>() {    <span class="hljs-comment">// 关闭线程池</span>    shutdown = <span class="hljs-literal">true</span>;    <span class="hljs-comment">// 唤醒阻塞的线程</span>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; liveNum; ++i) {        m_notEmpty.<span class="hljs-built_in">notify_all</span>();    }    <span class="hljs-comment">// 释放堆内存</span>    <span class="hljs-keyword">if</span> (taskQ) {        <span class="hljs-keyword">delete</span> taskQ;        taskQ = <span class="hljs-literal">nullptr</span>;    }}<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">ThreadPool::addTask</span><span class="hljs-params">(Task task)</span> </span>{    <span class="hljs-keyword">if</span> (shutdown) {        <span class="hljs-keyword">return</span>;    }    <span class="hljs-comment">// 添加任务</span>    taskQ-&gt;<span class="hljs-built_in">addTask</span>(task);    <span class="hljs-comment">// 唤醒一个工作者线程</span>    m_notEmpty.<span class="hljs-built_in">notify_one</span>();}<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">ThreadPool::getBusyNumber</span><span class="hljs-params">()</span> </span>{    <span class="hljs-function">std::unique_lock&lt;std::mutex&gt; <span class="hljs-title">lk</span><span class="hljs-params">(m_mutex)</span></span>;    <span class="hljs-type">int</span> busyNum_1 = <span class="hljs-keyword">this</span>-&gt;busyNum;    <span class="hljs-keyword">return</span> busyNum_1;}<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">ThreadPool::getAliveNumber</span><span class="hljs-params">()</span> </span>{    <span class="hljs-function">std::unique_lock&lt;std::mutex&gt; <span class="hljs-title">lk</span><span class="hljs-params">(m_mutex)</span></span>;    <span class="hljs-type">int</span> aliveNum = <span class="hljs-keyword">this</span>-&gt;liveNum;    <span class="hljs-keyword">return</span> aliveNum;}<span class="hljs-function"><span class="hljs-type">void</span> *<span class="hljs-title">ThreadPool::worker</span><span class="hljs-params">(<span class="hljs-type">void</span> *arg)</span> </span>{    ThreadPool *pool = <span class="hljs-built_in">static_cast</span>&lt;ThreadPool *&gt;(arg);    <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) {        <span class="hljs-function">std::unique_lock&lt;std::mutex&gt; <span class="hljs-title">lk</span><span class="hljs-params">(pool-&gt;m_mutex)</span></span>;        <span class="hljs-comment">// 当前任务队列是否为空</span>        <span class="hljs-keyword">if</span> (pool-&gt;taskQ-&gt;<span class="hljs-built_in">gettaskNumber</span>() == <span class="hljs-number">0</span> &amp;&amp; !pool-&gt;shutdown) {            <span class="hljs-comment">// 阻塞工作线程</span>            pool-&gt;m_notEmpty.<span class="hljs-built_in">wait</span>(lk, [&amp;] {                <span class="hljs-keyword">return</span> pool-&gt;exitNum || pool-&gt;shutdown || !pool-&gt;taskQ-&gt;<span class="hljs-built_in">empty</span>();            });        }        lk.<span class="hljs-built_in">unlock</span>();        <span class="hljs-comment">// 判断线程池是否被关闭了</span>        <span class="hljs-keyword">if</span> (pool-&gt;shutdown || pool-&gt;exitNum &gt; <span class="hljs-number">0</span>) {            pool-&gt;exitNum--;            std::cout &lt;&lt; <span class="hljs-string">"thread "</span> &lt;&lt; std::this_thread::<span class="hljs-built_in">get_id</span>() &lt;&lt; <span class="hljs-string">" exiting..."</span>                &lt;&lt; <span class="hljs-string">'\n'</span>;            <span class="hljs-keyword">break</span>;        }        <span class="hljs-comment">// 从任务队列中取出一个任务</span>        <span class="hljs-keyword">auto</span> task = std::<span class="hljs-built_in">move</span>(pool-&gt;taskQ-&gt;<span class="hljs-built_in">getTask</span>());        <span class="hljs-comment">// 解锁</span>        lk.<span class="hljs-built_in">lock</span>();        pool-&gt;busyNum++;        lk.<span class="hljs-built_in">unlock</span>();        std::cout &lt;&lt; <span class="hljs-string">"thread "</span> &lt;&lt; std::this_thread::<span class="hljs-built_in">get_id</span>() &lt;&lt; <span class="hljs-string">" start working..."</span>            &lt;&lt; <span class="hljs-string">'\n'</span>;        <span class="hljs-comment">// 消费任务</span>        task.<span class="hljs-built_in">function</span>(task.arg);        <span class="hljs-keyword">delete</span> task.arg;        task.arg = <span class="hljs-literal">nullptr</span>;        lk.<span class="hljs-built_in">lock</span>();        pool-&gt;busyNum--;        lk.<span class="hljs-built_in">unlock</span>();        std::cout &lt;&lt; <span class="hljs-string">"thread "</span> &lt;&lt; std::this_thread::<span class="hljs-built_in">get_id</span>() &lt;&lt; <span class="hljs-string">" end working..."</span>            &lt;&lt; <span class="hljs-string">'\n'</span>;    }    <span class="hljs-keyword">return</span> <span class="hljs-literal">nullptr</span>;}<span class="hljs-function"><span class="hljs-type">void</span> *<span class="hljs-title">ThreadPool::manager</span><span class="hljs-params">(<span class="hljs-type">void</span> *arg)</span> </span>{    ThreadPool *pool = <span class="hljs-built_in">static_cast</span>&lt;ThreadPool *&gt;(arg);    <span class="hljs-keyword">while</span> (!pool-&gt;shutdown) {        <span class="hljs-comment">// 每隔3s检测一次</span>        std::this_thread::<span class="hljs-built_in">sleep_for</span>(std::chrono::<span class="hljs-built_in">seconds</span>(<span class="hljs-number">1</span>));        <span class="hljs-function">std::unique_lock&lt;std::mutex&gt; <span class="hljs-title">lk</span><span class="hljs-params">(pool-&gt;m_mutex)</span></span>;        <span class="hljs-comment">// 取出线程池中任务的数量和当前线程的数量</span>        <span class="hljs-type">int</span> queueSize = pool-&gt;taskQ-&gt;<span class="hljs-built_in">gettaskNumber</span>();        <span class="hljs-comment">// 取出忙的线程的数量</span>        <span class="hljs-type">int</span> busyNum = pool-&gt;busyNum;        <span class="hljs-type">int</span> liveNum = pool-&gt;liveNum;        lk.<span class="hljs-built_in">unlock</span>();        <span class="hljs-comment">// 添加线程</span>        <span class="hljs-comment">// 任务的个数&gt;存活的线程个数 &amp;&amp; 存活的线程数&lt;最大线程数</span>        <span class="hljs-keyword">if</span> (queueSize &gt; liveNum &amp;&amp; liveNum &lt; pool-&gt;maxNum) {            lk.<span class="hljs-built_in">lock</span>();            <span class="hljs-type">int</span> counter = <span class="hljs-number">0</span>;            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;                 i &lt; pool-&gt;maxNum &amp;&amp; counter &lt; NUMBER &amp;&amp; pool-&gt;liveNum &lt; pool-&gt;maxNum;                 ++i) {                <span class="hljs-function">std::thread <span class="hljs-title">worker_thread</span><span class="hljs-params">(worker, pool)</span></span>;                std::cout &lt;&lt; <span class="hljs-string">"worker_thread created "</span> &lt;&lt; worker_thread.<span class="hljs-built_in">get_id</span>() &lt;&lt; <span class="hljs-string">'\n'</span>;                worker_thread.<span class="hljs-built_in">detach</span>();                pool-&gt;liveNum++;                counter++;            }            lk.<span class="hljs-built_in">unlock</span>();        }        <span class="hljs-comment">// 销毁线程</span>        <span class="hljs-comment">// 忙的线程*2 &lt; 存活的线程数 &amp;&amp; 存活的线程&gt;最小线程数</span>        <span class="hljs-keyword">if</span> (busyNum * <span class="hljs-number">2</span> &lt; liveNum &amp;&amp; liveNum &gt; pool-&gt;minNum) {            pool-&gt;exitNum = NUMBER;            <span class="hljs-comment">// 让工作的线程自杀</span>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; NUMBER; ++i) {                pool-&gt;m_notEmpty.<span class="hljs-built_in">notify_one</span>();            }        }    }    std::cout &lt;&lt; <span class="hljs-string">"manager_thread exiting..."</span> &lt;&lt; <span class="hljs-string">'\n'</span>;    <span class="hljs-keyword">return</span> <span class="hljs-literal">nullptr</span>;}</code></pre></div><h2><span id="ce-shi"><strong>测试</strong></span><a href="#ce-shi" class="header-anchor">#</a></h2><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-comment">/*************************************************************************</span><span class="hljs-comment">  &gt; File Name: main.cpp</span><span class="hljs-comment">  &gt; Author: txt1994</span><span class="hljs-comment">  &gt; Mail: txt1994s@163.com</span><span class="hljs-comment">  &gt; Created Time: Mon 08 Nov 2021 05:58:32 PM CST</span><span class="hljs-comment"> ************************************************************************/</span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">"ThreadPool.h"</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;chrono&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;memory&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;pthread.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;thread&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;utility&gt;</span></span><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">taskFunc</span><span class="hljs-params">(<span class="hljs-type">void</span> *arg)</span> </span>{    <span class="hljs-type">int</span> num = *(<span class="hljs-type">int</span> *)arg;    std::cout &lt;&lt; <span class="hljs-string">"thread id = "</span> &lt;&lt; std::this_thread::<span class="hljs-built_in">get_id</span>()        &lt;&lt; <span class="hljs-string">" number = "</span> &lt;&lt; num &lt;&lt; <span class="hljs-string">'\n'</span>;    std::this_thread::<span class="hljs-built_in">sleep_for</span>(std::chrono::<span class="hljs-built_in">seconds</span>(<span class="hljs-number">1</span>));}<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span> </span>{    <span class="hljs-comment">// 初始化线程池</span>    ThreadPool *pool = <span class="hljs-keyword">new</span> <span class="hljs-built_in">ThreadPool</span>(<span class="hljs-number">4</span>, <span class="hljs-number">10</span>);    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">100</span>; ++i) {        <span class="hljs-type">int</span> *num = <span class="hljs-keyword">new</span> <span class="hljs-type">int</span>;        *num = i + <span class="hljs-number">100</span>;        Task task;        task.arg = num;        task.function = taskFunc;        pool-&gt;<span class="hljs-built_in">addTask</span>(task);    }    std::this_thread::<span class="hljs-built_in">sleep_for</span>(std::chrono::<span class="hljs-built_in">seconds</span>(<span class="hljs-number">30</span>));    <span class="hljs-keyword">delete</span> pool;    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;}</code></pre></div>]]></content>
    
    
    
    <tags>
      
      <tag>C++11</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
