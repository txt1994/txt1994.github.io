

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=auto>



<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/logo.jpg">
  <link rel="icon" href="/img/logo.jpg">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
    <meta http-equiv="Content-Security-Policy" content="upgrade-insecure-requests">
  
  <meta name="theme-color" content="#6aa84f">
  <meta name="author" content="John Doe">
  <meta name="keywords" content="">
  
    <meta name="description" content="算法部分      推荐看👉 OI Wiki 算法部分#位图(bitmap)#通过一个bit位来表示某个元素对应的值或者状态，其中的key就是对应元素本身，value对应0或1，我们知道8个bit可以组成一个Byte，所以bitmap本身会极大的节省储存空间。 位图BitMap 字典(map)# 字典有什么特点呢?  字典的主要特点是一一对应的关系. 比如保存一个人的信息, 在合适的情">
<meta property="og:type" content="article">
<meta property="og:title" content="算法">
<meta property="og:url" content="https://txt1994.github.io/2022/01/01/%E7%AE%97%E6%B3%95/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:description" content="算法部分      推荐看👉 OI Wiki 算法部分#位图(bitmap)#通过一个bit位来表示某个元素对应的值或者状态，其中的key就是对应元素本身，value对应0或1，我们知道8个bit可以组成一个Byte，所以bitmap本身会极大的节省储存空间。 位图BitMap 字典(map)# 字典有什么特点呢?  字典的主要特点是一一对应的关系. 比如保存一个人的信息, 在合适的情">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://txt1994.github.io/img/t01f58cb18416af8e23.jpg">
<meta property="article:published_time" content="2022-01-01T11:32:29.000Z">
<meta property="article:modified_time" content="2022-03-18T16:34:52.188Z">
<meta property="article:author" content="John Doe">
<meta property="article:tag" content="algorithms">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="https://txt1994.github.io/img/t01f58cb18416af8e23.jpg">
  
  
  <title>算法 - Hexo</title>

  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4/dist/css/bootstrap.min.css" />


  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/github-markdown-css@4/github-markdown.min.css" />
  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/hint.css@2/hint.min.css" />

  
    
    
      
      <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@10/styles/github-gist.min.css" />
    
  

  
    <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3/dist/jquery.fancybox.min.css" />
  


<!-- 主题依赖的图标库，不要自行修改 -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_ba1fz6golrf.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_lbnruvf0jn.css">


<link  rel="stylesheet" href="/css/main.css" />

<!-- 自定义样式保持在最底部 -->

  
<link rel="stylesheet" href="/css/style.css">



  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    var CONFIG = {"hostname":"txt1994.github.io","root":"/","version":"1.8.14","typing":{"enable":true,"typeSpeed":70,"cursorChar":"_","loop":false},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"right","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"copy_btn":true,"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":false,"baidu":null,"google":null,"gtag":null,"tencent":{"sid":null,"cid":null},"woyaola":null,"cnzz":null,"leancloud":{"app_id":null,"app_key":null,"server_url":null,"path":"window.location.pathname","ignore_local":false}},"search_path":"/local-search.xml"};
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
<meta name="generator" content="Hexo 6.1.0">
<style>.github-emoji { position: relative; display: inline-block; width: 1.2em; min-height: 1.2em; overflow: hidden; vertical-align: top; color: transparent; }  .github-emoji > span { position: relative; z-index: 10; }  .github-emoji img, .github-emoji .fancybox { margin: 0 !important; padding: 0 !important; border: none !important; outline: none !important; text-decoration: none !important; user-select: none !important; cursor: auto !important; }  .github-emoji img { height: 1.2em !important; width: 1.2em !important; position: absolute !important; left: 50% !important; top: 50% !important; transform: translate(-50%, -50%) !important; user-select: none !important; cursor: auto !important; } .github-emoji-fallback { color: inherit; } .github-emoji-fallback img { opacity: 0 !important; }</style>
</head>


<body>
  <header style="height: 70vh;">
    <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/">
      <strong>txt1994s</strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/">
                <i class="iconfont icon-home-fill"></i>
                首页
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/">
                <i class="iconfont icon-archive-fill"></i>
                归档
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/">
                <i class="iconfont icon-tags-fill"></i>
                标签
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/">
                <i class="iconfont icon-user-fill"></i>
                关于
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/links/">
                <i class="iconfont icon-link-fill"></i>
                友联
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              &nbsp;<i class="iconfont icon-search"></i>&nbsp;
            </a>
          </li>
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">&nbsp;<i
                class="iconfont icon-dark" id="color-toggle-icon"></i>&nbsp;</a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

    <div class="banner" id="banner" parallax=true
         style="background: url('/img/default.png') no-repeat center center;
           background-size: cover;">
      <div class="full-bg-img">
        <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
          <div class="page-header text-center fade-in-up">
            <span class="h2" id="subtitle" title="算法">
              
            </span>

            
              <div class="mt-3">
  
  
    <span class="post-meta">
      <i class="iconfont icon-date-fill" aria-hidden="true"></i>
      <time datetime="2022-01-01 19:32" pubdate>
        2022年1月1日 晚上
      </time>
    </span>
  
</div>

<div class="mt-1">
  
    <span class="post-meta mr-2">
      <i class="iconfont icon-chart"></i>
      8.7k 字
    </span>
  

  
    <span class="post-meta mr-2">
      <i class="iconfont icon-clock-fill"></i>
      
      
      73 分钟
    </span>
  

  
  
</div>

            
          </div>

          
        </div>
      </div>
    </div>
  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="d-none d-lg-block col-lg-2"></div>
    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div class="py-5" id="board">
          <article class="post-content mx-auto">
            <!-- SEO header -->
            <h1 style="display: none">算法</h1>
            
              <p class="note note-info">
                
                  本文最后更新于：2022年3月19日 凌晨
                
              </p>
            
            <div class="markdown-body">
              <div class="toc">

<!-- toc -->

<ul>
<li><a href="#suan-fa-bu-fen">算法部分</a></li>
</ul>
<!-- tocstop -->

</div>

<p>推荐看👉 <a target="_blank" rel="noopener" href="https://oi-wiki.org/">OI Wiki</a></p>
<h1><span id="suan-fa-bu-fen">算法部分</span><a href="#suan-fa-bu-fen" class="header-anchor">#</a></h1><h5><span id="wei-tu-bitmap"><strong>位图(bitmap)</strong></span><a href="#wei-tu-bitmap" class="header-anchor">#</a></h5><p>通过一个bit位来表示某个元素对应的值或者状态，其中的key就是对应元素本身，value对应0或1，我们知道8个bit可以组成一个Byte，所以bitmap本身会极大的节省储存空间。</p>
<p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/chjxbt/p/10615304.html">位图BitMap</a></p>
<h5><span id="zi-dian-map"><strong>字典(map)</strong></span><a href="#zi-dian-map" class="header-anchor">#</a></h5><ul>
<li><p>字典有什么特点呢?</p>
<ul>
<li>字典的主要特点是一一对应的关系.</li>
<li>比如保存一个人的信息, 在合适的情况下取出这些信息.</li>
<li>使用数组的方式: [18, “Coderwhy”, 1.88]. 可以通过下标值取出信息.</li>
<li>使用字典的方式: {“age” : 18, “name” : “Coderwhy”, “height”: 1.88}. 可以通过key取出value</li>
</ul>
<p><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/c53460c9c8e4">字典(map)的详细解释</a></p>
</li>
</ul>
<h5><span id="kmp-suan-fa"><strong>kmp算法</strong></span><a href="#kmp-suan-fa" class="header-anchor">#</a></h5><p>kmp算法也就是字符串匹配算法。</p>
<p>比如：<br>在string str = “abc<code>ababc</code>ba”中匹配<br>string str2 = “<code>ababc</code>“字符串</p>
<p>最长公共前后缀：要匹配的字符串生成的数组</p>
<p>从一个字符开始到整个字符串，默认每行的公共前后缀最大值为全部字母数，然后判断是否符合其数字，如果不符合减一，一直判断到0结束。一行元素为1的数字为0，最后一行不统计</p>
<p>0    a</p>
<p>0    a    b</p>
<p>1    a    b    a</p>
<p>2    <code>a    b    a    b</code></p>
<p>0    a    b    a    b    c</p>
<p>得出的公共前后缀为</p>
<table>
<thead>
<tr>
<th align="left"></th>
<th align="left"></th>
<th align="left"></th>
<th align="left"></th>
<th align="left"></th>
</tr>
</thead>
<tbody><tr>
<td align="left">0</td>
<td align="left">0</td>
<td align="left">1</td>
<td align="left">2</td>
<td align="left">0</td>
</tr>
</tbody></table>
<p>然后整体向后移动一位，原最后一位被覆盖，下标为0的位置设为-1,最后的公共前后缀为</p>
<table>
<thead>
<tr>
<th></th>
<th></th>
<th></th>
<th></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td><code>-1</code></td>
<td>0</td>
<td>0</td>
<td>1</td>
<td>2</td>
</tr>
</tbody></table>
<p>kmp匹配过程</p>
<p>abc<code>ababc</code>ba</p>
<p>ababc</p>
<p><img src="https://gitee.com/txt1994/images/raw/master/img/algorithm/kmp.png" srcset="/img/loading.gif" lazyload></p>
<p>如果匹配到不相等元素，则通过next数组(P)决定next数组移动的位置，例如上图next数组(P)下标为2的元素与T字符串不相等，则看一下P数组下标2的next数组的值为0，则把next数组下标为0的位置移动到不匹配的地方</p>
<p><img src="https://gitee.com/txt1994/images/raw/master/img/algorithm/kmp_2.png" srcset="/img/loading.gif" lazyload></p>
<p>如果next数组的值为-1则next数组整体右移，或找到T字符串与子字符串第一个元素(如果找到的话)，然后把P移动到此位置(T的剩余的元素大于等于子字符串元素个数)；</p>
<p><strong>代码</strong></p>
<div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstring&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span>

<span class="hljs-comment">// 计算最长公共前后缀</span>
<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">prefix_table</span><span class="hljs-params">(<span class="hljs-type">char</span> pattern[], <span class="hljs-type">int</span> prefix[], <span class="hljs-type">int</span> n)</span> </span>{
     prefix[<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;
     <span class="hljs-type">int</span> len = <span class="hljs-number">0</span>;
     <span class="hljs-type">int</span> i = <span class="hljs-number">1</span>;
     <span class="hljs-keyword">while</span> (i &lt; n) {
         <span class="hljs-keyword">if</span> (pattern[i] == pattern[len]) {
             len++;
             prefix[i] = len;
             i++;
         } <span class="hljs-keyword">else</span> {
             <span class="hljs-keyword">if</span> (len &gt; <span class="hljs-number">0</span>) {
                 len = prefix[len - <span class="hljs-number">1</span>];
             } <span class="hljs-keyword">else</span> {
                 prefix[i] = len;
                 i++;
             }
         }
     }
}

<span class="hljs-comment">// 计算next数组</span>
<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">move_prefix_table</span><span class="hljs-params">(<span class="hljs-type">int</span> table[], <span class="hljs-type">int</span> n)</span> </span>{
    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = n - <span class="hljs-number">1</span>; i &gt; <span class="hljs-number">0</span>; --i) {
        table[i] = table[i - <span class="hljs-number">1</span>];
    }
    table[<span class="hljs-number">0</span>] = <span class="hljs-number">-1</span>;
}

<span class="hljs-comment">// kmp算法</span>
<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">kmp_search</span><span class="hljs-params">(<span class="hljs-type">char</span> text[], <span class="hljs-type">char</span> pattern[])</span> </span>{
    <span class="hljs-type">int</span> n = <span class="hljs-built_in">strlen</span>(pattern);
    <span class="hljs-type">int</span> m = <span class="hljs-built_in">strlen</span>(text);
    <span class="hljs-type">int</span> *prefix = <span class="hljs-keyword">new</span> <span class="hljs-type">int</span>[n];
 
    <span class="hljs-built_in">prefix_table</span>(pattern, prefix, n);
    <span class="hljs-built_in">move_prefix_table</span>(prefix, n);
  
    <span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;
    <span class="hljs-type">int</span> j = <span class="hljs-number">0</span>;
    <span class="hljs-keyword">while</span> (i &lt; m) {
        <span class="hljs-keyword">if</span> (j == n - <span class="hljs-number">1</span> &amp;&amp; text[i] == pattern[j]) {
            std::cout &lt;&lt; <span class="hljs-string">"Found pattern at "</span> &lt;&lt; i - j &lt;&lt; <span class="hljs-string">'\n'</span>;
            j = prefix[j];
        }
        <span class="hljs-keyword">if</span> (text[i] == pattern[j]) {
            i++;
            j++;
        } <span class="hljs-keyword">else</span> {
            j = prefix[j];
            <span class="hljs-keyword">if</span> (j == <span class="hljs-number">-1</span>) {
                i++;
                j++;
            }
        }
    }
 
    <span class="hljs-keyword">delete</span>[] prefix;
}

<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span> </span>{

    <span class="hljs-type">char</span> pattern[] = <span class="hljs-string">"ABABCABAA"</span>;
 
    <span class="hljs-type">char</span> text[] = <span class="hljs-string">"ABABABCABAABABABAAB"</span>;
    <span class="hljs-built_in">kmp_search</span>(text, pattern);
    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
}</code></pre></div>

<h5><span id="shuang-zhi-zhen"><strong>双指针</strong></span><a href="#shuang-zhi-zhen" class="header-anchor">#</a></h5><h5><span id="tong-xiang-shuang-zhi-zhen"><strong>同向双指针</strong></span><a href="#tong-xiang-shuang-zhi-zhen" class="header-anchor">#</a></h5><p>判断一个链表是否有<strong>环</strong></p>
<p>创建两个指针<code>ptr1,ptr2</code>,两个指针同时指向链表头结点。ptr1每次向后移动一个结点，ptr2每次移动2个结点，如果链表有环他们会指向同一个结点</p>
<div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> {
<span class="hljs-keyword">public</span>:
    <span class="hljs-comment">/**</span>
<span class="hljs-comment">     * @param circles: The value of 6 points on n rings</span>
<span class="hljs-comment">     * @return: Whether there are two same circles</span>
<span class="hljs-comment">     */</span>
    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">samecircle</span><span class="hljs-params">(Node head)</span> </span>{
        <span class="hljs-comment">// write your code here</span>
        Node ptr2 = head;
        Node ptr2 = head;
        <span class="hljs-keyword">while</span> (p1 != <span class="hljs-literal">nullptr</span> &amp;&amp; p2 != <span class="hljs-literal">nullptr</span>)
        {
            ptr1 = p1.next;
            ptr2 = p2.next.next;
            <span class="hljs-keyword">if</span> (ptr1 == ptr2) <span class="hljs-comment">// 结点相遇</span>
                <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
        }
        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
    }
};</code></pre></div>

<p><strong>判断环长</strong></p>
<p>第一次相遇代表有环，第二次相遇代表两个指针发生了套环，所以：</p>
<p>环长 = 速度差 * 移动次数</p>
<p><strong>判断入环点</strong></p>
<p>慢指针<strong>ptr1</strong>每次走一步，所以走的距离是：</p>
<p>d1 = D  + X * (S1 + S2) + S1</p>
<p>快指针ptr2走的距离是：</p>
<p>d2 = D + N * (S1 + S2) + S1</p>
<p>快指针速度是慢指针2倍。 即：</p>
<p>2 * d1 = d2</p>
<p>整理后的公式为</p>
<p>D = (n - 2X - 1)(S1 + S2) + S2</p>
<p>假设<code>n - 2X -1</code>的值为0，则<code>D = S2</code>;，那么我们就可以在首次相遇点的时候，定义一个指针指向链表的起点，一个指针指向首次相遇点，然后两个指针每次前进1步，当两个指针相遇的时候就是链表的入环点。</p>
<p>例子：</p>
<div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> {
<span class="hljs-keyword">public</span>:
    <span class="hljs-comment">/**</span>
<span class="hljs-comment">     * @param circles: The value of 6 points on n rings</span>
<span class="hljs-comment">     * @return: Whether there are two same circles</span>
<span class="hljs-comment">     */</span>
    <span class="hljs-function">Node <span class="hljs-title">find_node</span><span class="hljs-params">(Node head)</span></span>
<span class="hljs-function">    </span>{
        <span class="hljs-comment">// write your code here</span>
        Node ptr1 = head;
        Node ptr2 = head;
        Node ptr3 = <span class="hljs-literal">nullptr</span>;
        Node ptr4 = <span class="hljs-literal">nullptr</span>;
        <span class="hljs-keyword">while</span> (p1 != <span class="hljs-literal">nullptr</span> &amp;&amp; p2 != <span class="hljs-literal">nullptr</span>)
        {
            ptr1 = p1.next;
            ptr2 = p2.next.next;
            <span class="hljs-keyword">if</span> (ptr1 == ptr2) <span class="hljs-comment">// 结点相遇</span>
                ptr3 = head;
            	ptr4 = ptr1;
            	<span class="hljs-keyword">break</span>;
        }
        <span class="hljs-keyword">if</span> (ptr3 != <span class="hljs-literal">nullptr</span> &amp;&amp; != ptr4 != <span class="hljs-literal">nullptr</span>)
        {
            <span class="hljs-keyword">while</span>(ptr3 != ptr4)
            {
                ptr3 = ptr3.next;
                ptr4 = ptr4.next;
            }
            <span class="hljs-keyword">return</span> ptr4;
        }
        <span class="hljs-keyword">return</span> <span class="hljs-literal">nullptr</span>;
    }
};</code></pre></div>



<h5><span id="xiang-xiang-shuang-zhi-zhen"><strong>相向双指针</strong></span><a href="#xiang-xiang-shuang-zhi-zhen" class="header-anchor">#</a></h5><h5><span id="er-fen-fa"><strong>二分法</strong></span><a href="#er-fen-fa" class="header-anchor">#</a></h5><ul>
<li>又称折半搜索，期望时间复杂度为O(log2n)，最差为O(log2(n + 1))</li>
</ul>
<blockquote>
<p>二分法前提是数据已经有序</p>
<p>在A[0] … A[n]中搜索K。</p>
</blockquote>
<blockquote>
<p>步骤：<br>   \1. 令low = 0， high = n - 1，初始的查找区域为[low， high].<br>   \2. 取low和high的中间值mid = (low+high)/2。<br>   \3. 如果A[mid] = K，则返回mid, 如果不等，则重新确定查找区间。<br>   \4. 当low &gt; high 时，则表示区间已经失效，如果还未找到，则表示数组中不包含K的值，返回-1。</p>
</blockquote>
<div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span> T&gt;</span>
<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">binary_search</span><span class="hljs-params">(vector&lt;T&gt; &amp;A, T K)</span></span>
<span class="hljs-function"></span>{
    <span class="hljs-type">int</span> low = <span class="hljs-number">0</span>;
    <span class="hljs-type">int</span> high = A.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>;
    
    <span class="hljs-keyword">while</span>( low &lt; high )
    {
        <span class="hljs-type">int</span> mid = (low + high)/<span class="hljs-number">2</span>;

        <span class="hljs-keyword">if</span>( A[mid]  &lt; K )
            low = mid + <span class="hljs-number">1</span>;
        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>( A[mid] &gt; k )
            high = mid - <span class="hljs-number">1</span>;
        <span class="hljs-keyword">else</span>
            <span class="hljs-keyword">return</span> mid;
    }  

    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;      <span class="hljs-comment">/*返回-1表示数组不存在K的值*/</span>
 }</code></pre></div>



<h5><span id="er-fen-da-an"><strong>二分答案</strong></span><a href="#er-fen-da-an" class="header-anchor">#</a></h5><blockquote>
<p><code>二分答案</code>与<code>二分查找</code> 其实是不一样的</p>
<p><code>二分答案</code>: 即对你要求的答案进行二分<br><code>二分查找</code>: 对一个已知的有序数据集上进行二分的查找</p>
</blockquote>
<p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/Potassium/p/10125386.html">基础算法·二分答案 - Potassium - 博客园 (cnblogs.com)</a></p>
<h5><span id="fen-zhi-fa"><strong>分治法</strong></span><a href="#fen-zhi-fa" class="header-anchor">#</a></h5><blockquote>
<p>分治分治，即分而治之。分治，就是<strong>把一个复杂的问题分成两个或更多的相同或相似的子问题</strong>，再把子问题分成更小的子问题……直到最后子问题可以简单的直接求解，原问题的解即子问题的解的合并。这个技巧是很多高效算法的基础，如<strong>排序算法</strong>(快速排序，归并排序)，<strong>傅立叶变换</strong>(快速傅立叶变换)……直接说就是将一个难以直接解决的大问题，分割成一些规模比较小的相同的小问题，以便各个击破，分而治之。</p>
</blockquote>
<blockquote>
<p>分治法所能解决的问题一般具有以下几个特征：</p>
<p>\1) 该问题的规模缩小到一定的程度就可以容易地解决</p>
<p>\2) 该问题可以分解为若干个规模较小的相同问题，即该问题具有最优子结构性质。</p>
<p>\3) 利用该问题分解出的子问题的解可以合并为该问题的解；</p>
<p>\4) 该问题所分解出的各个子问题是相互独立的，即子问题之间不包含公共的子子问题。</p>
<p>第一条: 特征是绝大多数问题都可以满足的，因为问题的计算复杂性一般是随着问题规模的增加而增加；</p>
<p><strong>第二条: 特征是应用分治法的前提</strong>它也是大多数问题可以满足的，此特征反映了递归思想的应用；、</p>
<p><strong>第三条: 特征是关键，能否利用分治法完全取决于问题是否具有第三条特征</strong>，如果具备了第一条和第二条特征，而不具备第三条特征，则可以考虑用贪心法或动态规划法。</p>
<p><strong>第四条: 特征涉及到分治法的效率</strong>，如果各子问题是不独立的则分治法要做许多不必要的工作，重复地解公共的子问题，此时虽然可用分治法，但<strong>一般用动态规划法较好</strong>。</p>
</blockquote>
<p>经典问题:</p>
<p><strong>二分查找</strong></p>
<p><strong>棋盘覆盖</strong></p>
<p><strong>汉诺塔问题</strong></p>
<p><strong>归并排序/合并排序</strong></p>
<p><strong>快速排序</strong></p>
<h5><span id="kuan-du-you-xian-sou-suo-bfs"><strong>宽度优先搜索(BFS)</strong></span><a href="#kuan-du-you-xian-sou-suo-bfs" class="header-anchor">#</a></h5><blockquote>
<p>它并不考虑结果的可能位置，彻底地搜索整张图，直到找到结果为止。</p>
<p>基本过程，BFS 是从根节点开始，沿着树(图)的宽度遍历树(图)的节点。如果所有节点均被访问，则算法中止。一般用队列数据结构来辅助实现 BFS 算法。</p>
</blockquote>
<p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/huansky/p/12826857.html">广度优先搜索原理与实践 - huansky - 博客园 (cnblogs.com)</a></p>
<div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">private</span> Map&lt;String, Boolean&gt; status = <span class="hljs-keyword">new</span> <span class="hljs-built_in">HashMap</span>&lt;String, Boolean&gt;();
    <span class="hljs-keyword">private</span> Queue&lt;String&gt; queue = <span class="hljs-keyword">new</span> <span class="hljs-built_in">LinkedList</span>&lt;String&gt;();
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-type">void</span> <span class="hljs-title">BFSSearch</span><span class="hljs-params">(String startPoint)</span> </span>{
        <span class="hljs-comment">//1.把起始点放入queue；</span>
        queue.<span class="hljs-built_in">add</span>(startPoint);
        status.<span class="hljs-built_in">put</span>(startPoint, <span class="hljs-literal">false</span>);
        <span class="hljs-built_in">bfsLoop</span>();
    }
    
    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-type">void</span> <span class="hljs-title">bfsLoop</span><span class="hljs-params">()</span> </span>{
        <span class="hljs-keyword">while</span>(!queue.<span class="hljs-built_in">isEmpty</span>()) {
            <span class="hljs-comment">//  1) 从queue中取出队列头的点；更新状态为已经遍历。</span>
            String currentQueueHeader = queue.<span class="hljs-built_in">poll</span>(); <span class="hljs-comment">//出队</span>
            status.<span class="hljs-built_in">put</span>(currentQueueHeader, <span class="hljs-literal">true</span>);
            System.out.<span class="hljs-built_in">println</span>(currentQueueHeader);
            <span class="hljs-comment">//  2) 找出与此点邻接的且尚未遍历的点，进行标记，然后全部放入queue中。</span>
            List&lt;String&gt; neighborPoints = graph.<span class="hljs-built_in">get</span>(currentQueueHeader);
            <span class="hljs-keyword">for</span> (String poinit : neighborPoints) {
                <span class="hljs-keyword">if</span> (!status.<span class="hljs-built_in">getOrDefault</span>(poinit, <span class="hljs-literal">false</span>)) { <span class="hljs-comment">//未被遍历</span>
                    <span class="hljs-keyword">if</span> (queue.<span class="hljs-built_in">contains</span>(poinit)) <span class="hljs-keyword">continue</span>;
                    queue.<span class="hljs-built_in">add</span>(poinit);
                    status.<span class="hljs-built_in">put</span>(poinit, <span class="hljs-literal">false</span>);
                }
            }
        }
    }</code></pre></div>



<h5><span id="tuo-bu-pai-xu-fa"><strong>拓扑排序法</strong></span><a href="#tuo-bu-pai-xu-fa" class="header-anchor">#</a></h5><ul>
<li>拓扑排序指的是将有向无环<a target="_blank" rel="noopener" href="http://data.biancheng.net/view/200.html">图</a>（又称“DAG”图）中的顶点按照图中指定的先后顺序进行排序。</li>
</ul>
<p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/MrSaver/p/9994720.html">算法：拓扑排序 - 子烁爱学习 - 博客园 (cnblogs.com)</a></p>
<p><a target="_blank" rel="noopener" href="http://data.biancheng.net/view/43.html">拓扑排序算法及C语言实现 (biancheng.net)</a></p>
<h5><span id="shen-du-you-xian-sou-suo-hui-su-fa-dfs"><strong>深度优先搜索/回溯法 (DFS)</strong></span><a href="#shen-du-you-xian-sou-suo-hui-su-fa-dfs" class="header-anchor">#</a></h5><blockquote>
<p>深度优先搜索（缩写DFS）有点类似广度优先搜索，也是对一个连通图进行遍历的算法。它的思想是<strong>从一个顶点V0开始，沿着一条路一直走到底</strong>，如果发现不能到达目标解，那就返回到上一个节点，然后从另一条路开始走到底，这种尽量往深处走的概念即是深度优先的概念。</p>
</blockquote>
<div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-comment">/**</span>
<span class="hljs-comment"> * DFS核心伪代码</span>
<span class="hljs-comment"> * 前置条件是visit数组全部设置成false</span>
<span class="hljs-comment"> * @param n 当前开始搜索的节点</span>
<span class="hljs-comment"> * @param d 当前到达的深度，也即是路径长度</span>
<span class="hljs-comment"> * @return 是否有解</span>
<span class="hljs-comment"> */</span>
<span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">DFS</span><span class="hljs-params">(Node n, <span class="hljs-type">int</span> d)</span></span>{
    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">isEnd</span>(n, d)){<span class="hljs-comment">//路径长度为返回true，表示此次搜索有解</span>
        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
    }
 
    <span class="hljs-keyword">for</span> (Node nextNode in n){<span class="hljs-comment">//遍历跟节点n相邻的节点nextNode，</span>
        <span class="hljs-keyword">if</span> (!visit[nextNode]){<span class="hljs-comment">//未访问过的节点才能继续搜索</span>
 
            <span class="hljs-comment">//例如搜索到V1了，那么V1要设置成已访问</span>
            visit[nextNode] = <span class="hljs-literal">true</span>;
 
            <span class="hljs-comment">//接下来要从V1开始继续访问了，路径长度当然要加</span>
 
            <span class="hljs-keyword">if</span> (<span class="hljs-built_in">DFS</span>(nextNode, d+<span class="hljs-number">1</span>)){<span class="hljs-comment">//如果搜索出有解</span>
                <span class="hljs-comment">//例如到了V6，找到解了，你必须一层一层递归的告诉上层已经找到解</span>
                <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
            }
 
            <span class="hljs-comment">//重新设置成未访问，因为它有可能出现在下一次搜索的别的路径中</span>
            visit[nextNode] = <span class="hljs-literal">false</span>;
 
        }
        <span class="hljs-comment">//到这里，发现本次搜索还没找到解，那就要从当前节点的下一个节点开始搜索。</span>
    }
    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<span class="hljs-comment">//本次搜索无解</span>
}</code></pre></div>

<h5><span id="dong-tai-gui-hua"><strong>动态规划</strong></span><a href="#dong-tai-gui-hua" class="header-anchor">#</a></h5><blockquote>
<p>它将问题分成小问题，并先着手解决这些小问题</p>
</blockquote>
<h5><span id="bei-bao-xing-dp"><strong>背包型DP</strong></span><a href="#bei-bao-xing-dp" class="header-anchor">#</a></h5><p>假设有三种商品，分别是小汽车1吨，卡车3吨，起重机4吨.价格分别是：3000，4000，6000。</p>
<p>现在只能卖总共4吨的商品，怎么卖商品售价最高？</p>
<p>所有的组合为：</p>
<table>
<thead>
<tr>
<th align="left">组合</th>
<th align="left">价值</th>
</tr>
</thead>
<tbody><tr>
<td align="left">无</td>
<td align="left">0</td>
</tr>
<tr>
<td align="left">小汽车</td>
<td align="left">3000</td>
</tr>
<tr>
<td align="left">卡车</td>
<td align="left">4000</td>
</tr>
<tr>
<td align="left">起重机</td>
<td align="left">6000</td>
</tr>
<tr>
<td align="left">小汽车和起重机</td>
<td align="left">重量过大</td>
</tr>
<tr>
<td align="left">小汽车和卡车</td>
<td align="left">7000</td>
</tr>
<tr>
<td align="left">卡车和起重机</td>
<td align="left">重量过大</td>
</tr>
<tr>
<td align="left">小汽车,卡车，起重机</td>
<td align="left">重量过大</td>
</tr>
</tbody></table>
<p>可以看到随着商品种类增加组合也在飞速增长，时间复杂度为O(2^n),太慢了</p>
<p>动态规划算法可以用网格描述</p>
<p><img src="https://gitee.com/txt1994/images/raw/master/img/algorithm/DP-knapsack.png" srcset="/img/loading.gif" lazyload></p>
<p>填充这些表格最后就是背包问题的解法。</p>
<blockquote>
<p>当在小汽车一行时，其他种类的商品选不了，所以都是3000</p>
</blockquote>
<p><img src="https://gitee.com/txt1994/images/raw/master/img/algorithm/DP-knapsack%20-2.png" srcset="/img/loading.gif" lazyload></p>
<blockquote>
<p>当加入卡车时1-2吨放不下3吨的卡车，3吨可以放下卡车，所以为4000，4吨可以放下一个卡车和一个小汽车，共7000</p>
</blockquote>
<p><img src="https://gitee.com/txt1994/images/raw/master/img/algorithm/DP-knapsack%20-%203.png" srcset="/img/loading.gif" lazyload></p>
<blockquote>
<p>加入起重机时，1-2背包只能装小汽车，3吨可以装一辆卡车，4吨可以装起重机，但是价格低于7000所以不选起重机的价格，定位卡车加小汽车，价格为7000.</p>
</blockquote>
<p><img src="https://gitee.com/txt1994/images/raw/master/img/algorithm/DP-knapsack%20-%204.png" srcset="/img/loading.gif" lazyload></p>
<h5><span id="zuo-biao-xing-dp"><strong>坐标型DP</strong></span><a href="#zuo-biao-xing-dp" class="header-anchor">#</a></h5><blockquote>
<p>又被称为网格型动态规划</p>
<p>一个网格有m行n列，一个小动物从(0, 0)出发，每一步可以向下或向右走一步，最总到达(m - 1, n - 1)处</p>
</blockquote>
<ul>
<li>最简单的动态规划类型</li>
<li>给定一个序列或者网格</li>
<li>需要找到序列中某个/些子序列或网格中的某条路径<ul>
<li>某种性质最大/最小</li>
<li>计数</li>
<li>存在性</li>
</ul>
</li>
<li>动态规划方程 f[i] 中的下标i表示以ai为结尾的满足条件的子序列的性质，f[i][j] 中下标 i , j 表示以格子( i , j )为结尾的满足条件的路径的性质<ul>
<li>最大值/最小值</li>
<li>个数</li>
<li>存在性</li>
</ul>
</li>
<li>坐标型动态规划的初始条件f[0]就是指以a0为结尾的子序列的性质</li>
</ul>
<p><a target="_blank" rel="noopener" href="https://www.motongxue.cn/posts/1487252037/#D2-%E5%9D%90%E6%A0%87%E5%9E%8B%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92">D2-坐标型动态规划</a></p>
<div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> {
    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">uniquePathsWithObstacles</span><span class="hljs-params">(<span class="hljs-type">int</span>[][] obstacleGrid)</span> {
        <span class="hljs-keyword">if</span>(obstacleGrid==<span class="hljs-literal">null</span>||obstacleGrid.length==<span class="hljs-number">0</span>){
            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
        }
        <span class="hljs-type">int</span> [] [] dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[obstacleGrid.length][obstacleGrid[<span class="hljs-number">0</span>].length];
        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;obstacleGrid.length;i++){
            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;j&lt;obstacleGrid[i].length;j++){
                <span class="hljs-keyword">if</span>(obstacleGrid[i][j]==<span class="hljs-number">1</span>){<span class="hljs-comment">//有障碍</span>
                    dp[i][j]=<span class="hljs-number">0</span>;
                    <span class="hljs-keyword">continue</span>;
                }<span class="hljs-keyword">else</span>{
                    <span class="hljs-keyword">if</span>(i == <span class="hljs-number">0</span> &amp;&amp; j == <span class="hljs-number">0</span>) dp[i][j]=<span class="hljs-number">1</span>;<span class="hljs-comment">//没有障碍起点</span>
                    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(i==<span class="hljs-number">0</span>) dp[i][j]=dp[i][j-<span class="hljs-number">1</span>];<span class="hljs-comment">//在第一行,上一题在没有障碍情况下默认是1,但是有障碍就取决于该行前面是否有障碍了</span>
                    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(j==<span class="hljs-number">0</span>) dp[i][j]=dp[i-<span class="hljs-number">1</span>][j];<span class="hljs-comment">//第一列,没有障碍默认是1,有障碍就取决于该列前面是否有障碍了</span>
                    <span class="hljs-keyword">else</span>{
                         dp[i][j]=dp[i-<span class="hljs-number">1</span>][j]+dp[i][j-<span class="hljs-number">1</span>];
                    }
                }
                
            }
        }
        <span class="hljs-keyword">return</span> dp[obstacleGrid.length-<span class="hljs-number">1</span>][obstacleGrid[<span class="hljs-number">0</span>].length-<span class="hljs-number">1</span>];
    }
}</code></pre></div>

<h5><span id="xu-lie-xing-dp"><strong>序列型DP</strong></span><a href="#xu-lie-xing-dp" class="header-anchor">#</a></h5><p><a target="_blank" rel="noopener" href="https://www.motongxue.cn/posts/717263946/">D3-序列型动态规划</a></p>
<h5><span id="shuang-xu-lie-xing-dp"><strong>双序列型DP</strong></span><a href="#shuang-xu-lie-xing-dp" class="header-anchor">#</a></h5><p><a target="_blank" rel="noopener" href="https://www.motongxue.cn/posts/1999848756/">D7-双序列型动态规划</a></p>
<h5><span id="hua-fen-xing-dp"><strong>划分型DP</strong></span><a href="#hua-fen-xing-dp" class="header-anchor">#</a></h5><p>常见类型：</p>
<div class="code-wrapper"><pre><code class="hljs css"><span class="hljs-number">1</span>. 给定长度为N的序列或字符串，要求划分成若干段
   - 段数不限，或指定K段
   - 每一段满足一定的性质
<span class="hljs-number">2</span>. 做法
   - 类似于序列型动态规划，但是通常要加上段数信息
   - 一般用`f<span class="hljs-selector-attr">[i]</span><span class="hljs-selector-attr">[j]</span>`记录前<span class="hljs-selector-tag">i</span>个元素（元素<span class="hljs-number">0</span>~<span class="hljs-selector-tag">i</span>-<span class="hljs-number">1</span>）分成 j 段的性质，如最小代价</code></pre></div>

<p><a target="_blank" rel="noopener" href="https://www.motongxue.cn/posts/2930816015/">D4 划分型动态规划</a></p>
<h5><span id="ji-yi-hua-sou-suo"><strong>记忆化搜索</strong></span><a href="#ji-yi-hua-sou-suo" class="header-anchor">#</a></h5><p><a target="_blank" rel="noopener" href="https://oi-wiki.org/dp/memo/">记忆化搜索 - OI Wiki (oi-wiki.org)</a></p>
<h5><span id="qu-jian-xing-dp"><strong>区间型DP</strong></span><a href="#qu-jian-xing-dp" class="header-anchor">#</a></h5><p><a target="_blank" rel="noopener" href="https://www.motongxue.cn/posts/1906695755/">D6-区间型动态规划</a></p>
<h5><span id="zhuang-tai-ya-suo-dp"><strong>状态压缩DP</strong></span><a href="#zhuang-tai-ya-suo-dp" class="header-anchor">#</a></h5><p><a target="_blank" rel="noopener" href="https://oi-wiki.org/dp/state/">状压 DP - OI Wiki (oi-wiki.org)</a></p>
<h5><span id="bo-yi-xing-dp"><strong>博弈型DP</strong></span><a href="#bo-yi-xing-dp" class="header-anchor">#</a></h5><p><a target="_blank" rel="noopener" href="https://www.motongxue.cn/posts/2506571106/">D4-博弈型动态规划</a></p>
<h5><span id="pi-pei-xing-dp"><strong>匹配型DP</strong></span><a href="#pi-pei-xing-dp" class="header-anchor">#</a></h5><h5><span id="shu-wei-dp">数位 DP</span><a href="#shu-wei-dp" class="header-anchor">#</a></h5><p><a target="_blank" rel="noopener" href="https://oi-wiki.org/dp/number/">数位 DP - OI Wiki (oi-wiki.org)</a></p>
<h5><span id="shu-xing-dp"><strong>树形DP</strong></span><a href="#shu-xing-dp" class="header-anchor">#</a></h5><p><a target="_blank" rel="noopener" href="https://oi-wiki.org/dp/tree/">树形 DP - OI Wiki (oi-wiki.org)</a></p>
<h5><span id="cha-tou-dp">插头 DP</span><a href="#cha-tou-dp" class="header-anchor">#</a></h5><p><a target="_blank" rel="noopener" href="https://oi-wiki.org/dp/plug/">插头 DP - OI Wiki (oi-wiki.org)</a></p>
<h5><span id="gai-lu-dp">概率 DP</span><a href="#gai-lu-dp" class="header-anchor">#</a></h5><p><a target="_blank" rel="noopener" href="https://oi-wiki.org/dp/probability/">概率 DP - OI Wiki (oi-wiki.org)</a></p>
<h5><span id="dong-tai-dp">动态 DP</span><a href="#dong-tai-dp" class="header-anchor">#</a></h5><p><a target="_blank" rel="noopener" href="https://oi-wiki.org/dp/dynamic/">动态 DP - OI Wiki (oi-wiki.org)</a></p>
<h5><span id="pai-xu-suan-fa"><strong>排序算法</strong></span><a href="#pai-xu-suan-fa" class="header-anchor">#</a></h5><p><a target="_blank" rel="noopener" href="https://oi-wiki.org/basic/sort-intro/">排序简介 - OI Wiki (oi-wiki.org)</a></p>
<h5><span id="wai-pai-xu-suan-fa"><strong>外排序算法</strong></span><a href="#wai-pai-xu-suan-fa" class="header-anchor">#</a></h5><p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/codeMedita/p/7425291.html">排序之外部排序 - Judy518 - 博客园 (cnblogs.com)</a></p>
<h5><span id="kuai-su-pai-xu-suan-fa"><strong>快速排序算法</strong></span><a href="#kuai-su-pai-xu-suan-fa" class="header-anchor">#</a></h5><p><a target="_blank" rel="noopener" href="https://oi-wiki.org/basic/quick-sort/">快速排序 - OI Wiki (oi-wiki.org)</a></p>
<h5><span id="ou-la-lu-jing"><strong>欧拉路径</strong></span><a href="#ou-la-lu-jing" class="header-anchor">#</a></h5><blockquote>
<p>什么是欧拉路径？欧拉路径就是一条能够不重不漏地经过图上的每一条边的路径，即小学奥数中的一笔画问题。而若这条路径的起点和终点相同，则将这条路径称为欧拉回路。</p>
</blockquote>
<p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/TEoS/p/11376707.html">欧拉路径详解 - TEoS - 博客园 (cnblogs.com)</a></p>
<h5><span id="mo-ni-fa"><strong>模拟法</strong></span><a href="#mo-ni-fa" class="header-anchor">#</a></h5><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_36257171/article/details/95651331">模拟算法（C++）_1只小弛的博客-CSDN博客_c++模拟</a></p>
<p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/wugu-2333/p/13439938.html">C++算法：模拟 - 无咕 - 博客园 (cnblogs.com)</a></p>
<h5><span id="sao-miao-xian-suan-fa"><strong>扫描线算法</strong></span><a href="#sao-miao-xian-suan-fa" class="header-anchor">#</a></h5><blockquote>
<p>扫描线是一种用于求矩阵面积并或者周长并的算法，可以使用 <code>线段树</code> 来优化。假设给定了平面上若干个可能相交的矩阵，需要求出它们的面积并（面积之和减去相交部分）或者周长并（外轮廓的长度）。我们可以虚拟出一条按顺序扫描整个平面的线段，通过对平行或垂直于 <em>[Math Processing Error]x</em> 轴的线段进行处理得到答案。</p>
</blockquote>
<p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/lingspace/p/scan-line.html">扫描线 - Ling_Lover - 博客园 (cnblogs.com)</a></p>
<h5><span id="mei-ju-fa"><strong>枚举法</strong></span><a href="#mei-ju-fa" class="header-anchor">#</a></h5><p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/jhpy/articles/11567665.html">枚举法 - Huise.J - 博客园 (cnblogs.com)</a></p>
<h5><span id="zui-duan-lu-jing"><strong>最短路径</strong></span><a href="#zui-duan-lu-jing" class="header-anchor">#</a></h5><p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/thousfeet/p/9229395.html">看完就懂了！一篇搞定图论最短路径问题 - thousfeet - 博客园 (cnblogs.com)</a></p>
<h5><span id="tan-xin-fa"><strong>贪心法</strong></span><a href="#tan-xin-fa" class="header-anchor">#</a></h5><p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/goWithHappy/p/greedy-algorithm.html">贪心算法原理及其应用 - vcjmhg - 博客园 (cnblogs.com)</a></p>
<h5><span id="zui-xiao-sheng-cheng-shu"><strong>最小生成树</strong></span><a href="#zui-xiao-sheng-cheng-shu" class="header-anchor">#</a></h5><p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/SeanOcean/p/10975694.html">最小生成树 - SeanOcean - 博客园 (cnblogs.com)</a></p>
<h5><span id="di-ke-si-te-la-suan-fa"><strong>狄克斯特拉算法</strong></span><a href="#di-ke-si-te-la-suan-fa" class="header-anchor">#</a></h5><p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/skywang12345/p/3711512.html">Dijkstra算法(一)之 C语言详解 - 如果天空不死 - 博客园 (cnblogs.com)</a></p>
<h5><span id="jin-si-suan-fa"><strong>近似算法</strong></span><a href="#jin-si-suan-fa" class="header-anchor">#</a></h5><p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/f91og/p/6257739.html">算法课堂笔记6—近似算法 - f91og - 博客园 (cnblogs.com)</a></p>
<h5><span id="gao-jing-du-ji-suan">高精度计算</span><a href="#gao-jing-du-ji-suan" class="header-anchor">#</a></h5><p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/wugu-2333/p/13436997.html">高精度计算</a></p>
<h5><span id="lru-suan-fa">LRU算法</span><a href="#lru-suan-fa" class="header-anchor">#</a></h5><blockquote>
<p>缓存淘汰算法</p>
<p>长期不被使用的数据，在未来被用到的几率也不大。如果缓存到达了预设值就要删除一些内容，给新的内容腾位置</p>
</blockquote>
<p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/kyoner/p/11179766.html">如何实现LRU算法？ - murphy_gb - 博客园 (cnblogs.com)</a></p>
<h5><span id="a-xing-xun-lu-suan-fa">A星寻路算法</span><a href="#a-xing-xun-lu-suan-fa" class="header-anchor">#</a></h5><p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/szmtjs10/p/15741514.html">A星寻路算法 - szmtjs10 - 博客园 (cnblogs.com)</a></p>
<p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/zhoug2020/p/3468167.html">A星寻路算法介绍 - 莫水千流 - 博客园 (cnblogs.com)</a></p>
<p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/385733813">A-Star（A*）寻路算法原理与实现 - 知乎 (zhihu.com)</a></p>

            </div>
            <hr>
            <div>
              <div class="post-metas mb-3">
                
                
                  <div class="post-meta">
                    <i class="iconfont icon-tags"></i>
                    
                      <a class="hover-with-bg" href="/tags/algorithms/">algorithms</a>
                    
                  </div>
                
              </div>
              
                <p class="note note-warning">
                  
                    本博客所有文章除特别声明外，均采用 <a target="_blank" href="https://creativecommons.org/licenses/by-sa/4.0/deed.zh" rel="nofollow noopener noopener">CC BY-SA 4.0 协议</a> ，转载请注明出处！
                  
                </p>
              
              
                <div class="post-prevnext">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/2022/01/01/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">数据结构</span>
                        <span class="visible-mobile">上一篇</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2021/12/27/C-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%88%9B%E5%BB%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F/">
                        <span class="hidden-mobile">C++设计模式-创建型模式</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
              <!-- Comments -->
              <article class="comments" id="comments" lazyload>
                
                  
                
                
  <div id="lv-container" data-id="city" data-uid="MTAyMC81NTMzMi8zMTc5OQ==">
    <script type="text/javascript">
      Fluid.utils.loadComments('#lv-container', function() {
        Fluid.utils.createScript('https://cdn-city.livere.com/js/embed.dist.js');
      });
    </script>
    <noscript>Please enable JavaScript to view the comments</noscript>
  </div>


              </article>
            
          </article>
        </div>
      </div>
    </div>
    
      <div class="d-none d-lg-block col-lg-2 toc-container" id="toc-ctn">
        <div id="toc">
  <p class="toc-header"><i class="iconfont icon-list"></i>&nbsp;目录</p>
  <div class="toc-body" id="toc-body"></div>
</div>

      </div>
    
  </div>
</div>

<!-- Custom -->


    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v"
                 for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>
    

    
  </main>

  <footer class="text-center mt-5 py-3">
  <div class="footer-content">
     <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> 
  </div>
  

  

  
</footer>


  <!-- SCRIPTS -->
  
  <script  src="https://cdn.jsdelivr.net/npm/nprogress@0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/nprogress@0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js" ></script>
<script  src="https://cdn.jsdelivr.net/npm/bootstrap@4/dist/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>

<!-- Plugins -->


  <script  src="/js/local-search.js" ></script>



  
    <script  src="/js/img-lazyload.js" ></script>
  



  



  
    <script  src="https://cdn.jsdelivr.net/npm/tocbot@4/dist/tocbot.min.js" ></script>
  
  
    <script  src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3/dist/jquery.fancybox.min.js" ></script>
  
  
    <script  src="https://cdn.jsdelivr.net/npm/anchor-js@4/anchor.min.js" ></script>
  
  
    <script defer src="https://cdn.jsdelivr.net/npm/clipboard@2/dist/clipboard.min.js" ></script>
  






  <script  src="https://cdn.jsdelivr.net/npm/typed.js@2/lib/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var title = document.getElementById('subtitle').title;
      
        typing(title);
      
    })(window, document);
  </script>















<!-- 主题的启动项 保持在最底部 -->
<script  src="/js/boot.js" ></script>


</body>
</html>
