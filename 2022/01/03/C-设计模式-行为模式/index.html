

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=auto>



<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/logo.jpg">
  <link rel="icon" href="/img/logo.jpg">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
    <meta http-equiv="Content-Security-Policy" content="upgrade-insecure-requests">
  
  <meta name="theme-color" content="#6aa84f">
  <meta name="author" content="John Doe">
  <meta name="keywords" content="">
  
    <meta name="description" content="è§‚å¯Ÿè€…æ¨¡å¼ è®¿é—®è€…æ¨¡å¼ è´£ä»»é“¾æ¨¡å¼ å‘½ä»¤æ¨¡å¼ è¿­ä»£å™¨æ¨¡å¼ ä¸­ä»‹è€…æ¨¡å¼ å¤‡å¿˜å½•æ¨¡å¼ çŠ¶æ€æ¨¡å¼ ç­–ç•¥æ¨¡å¼ æ¨¡æ¿æ–¹æ³•æ¨¡å¼      æ¨èçœ‹ğŸ‘‰å¸¸ç”¨è®¾è®¡æ¨¡å¼æœ‰å“ªäº›ï¼Ÿ (refactoringguru.cn) è§‚å¯Ÿè€…æ¨¡å¼#è§‚å¯Ÿè€…æ¨¡å¼æ˜¯ä¸€ç§è¡Œä¸ºè®¾è®¡æ¨¡å¼ï¼Œ å…è®¸ä½ å®šä¹‰ä¸€ç§è®¢é˜…æœºåˆ¶ï¼Œ å¯åœ¨å¯¹è±¡äº‹ä»¶å‘ç”Ÿæ—¶é€šçŸ¥å¤šä¸ª â€œè§‚å¯Ÿâ€ è¯¥å¯¹è±¡çš„å…¶ä»–å¯¹è±¡ã€‚ é€‚ç”¨åœºæ™¯:  å½“ä¸€ä¸ªå¯¹è±¡çŠ¶æ€çš„æ”¹å˜éœ€è¦æ”¹å˜å…¶ä»–å¯¹è±¡ï¼Œ æˆ–å®é™…å¯¹">
<meta property="og:type" content="article">
<meta property="og:title" content="C++è®¾è®¡æ¨¡å¼-è¡Œä¸ºæ¨¡å¼">
<meta property="og:url" content="https://txt1994.github.io/2022/01/03/C-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E8%A1%8C%E4%B8%BA%E6%A8%A1%E5%BC%8F/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:description" content="è§‚å¯Ÿè€…æ¨¡å¼ è®¿é—®è€…æ¨¡å¼ è´£ä»»é“¾æ¨¡å¼ å‘½ä»¤æ¨¡å¼ è¿­ä»£å™¨æ¨¡å¼ ä¸­ä»‹è€…æ¨¡å¼ å¤‡å¿˜å½•æ¨¡å¼ çŠ¶æ€æ¨¡å¼ ç­–ç•¥æ¨¡å¼ æ¨¡æ¿æ–¹æ³•æ¨¡å¼      æ¨èçœ‹ğŸ‘‰å¸¸ç”¨è®¾è®¡æ¨¡å¼æœ‰å“ªäº›ï¼Ÿ (refactoringguru.cn) è§‚å¯Ÿè€…æ¨¡å¼#è§‚å¯Ÿè€…æ¨¡å¼æ˜¯ä¸€ç§è¡Œä¸ºè®¾è®¡æ¨¡å¼ï¼Œ å…è®¸ä½ å®šä¹‰ä¸€ç§è®¢é˜…æœºåˆ¶ï¼Œ å¯åœ¨å¯¹è±¡äº‹ä»¶å‘ç”Ÿæ—¶é€šçŸ¥å¤šä¸ª â€œè§‚å¯Ÿâ€ è¯¥å¯¹è±¡çš„å…¶ä»–å¯¹è±¡ã€‚ é€‚ç”¨åœºæ™¯:  å½“ä¸€ä¸ªå¯¹è±¡çŠ¶æ€çš„æ”¹å˜éœ€è¦æ”¹å˜å…¶ä»–å¯¹è±¡ï¼Œ æˆ–å®é™…å¯¹">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://txt1994.github.io/img/R-C.png">
<meta property="article:published_time" content="2022-01-03T07:48:22.000Z">
<meta property="article:modified_time" content="2022-03-18T16:02:30.000Z">
<meta property="article:author" content="John Doe">
<meta property="article:tag" content="è®¾è®¡æ¨¡å¼">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="https://txt1994.github.io/img/R-C.png">
  
  
  <title>C++è®¾è®¡æ¨¡å¼-è¡Œä¸ºæ¨¡å¼ - Hexo</title>

  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4/dist/css/bootstrap.min.css" />


  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/github-markdown-css@4/github-markdown.min.css" />
  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/hint.css@2/hint.min.css" />

  
    
    
      
      <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@10/styles/github-gist.min.css" />
    
  

  
    <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3/dist/jquery.fancybox.min.css" />
  


<!-- ä¸»é¢˜ä¾èµ–çš„å›¾æ ‡åº“ï¼Œä¸è¦è‡ªè¡Œä¿®æ”¹ -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_ba1fz6golrf.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_lbnruvf0jn.css">


<link  rel="stylesheet" href="/css/main.css" />

<!-- è‡ªå®šä¹‰æ ·å¼ä¿æŒåœ¨æœ€åº•éƒ¨ -->

  
<link rel="stylesheet" href="/css/style.css">



  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    var CONFIG = {"hostname":"txt1994.github.io","root":"/","version":"1.8.14","typing":{"enable":true,"typeSpeed":70,"cursorChar":"_","loop":false},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"right","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"copy_btn":true,"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":false,"baidu":null,"google":null,"gtag":null,"tencent":{"sid":null,"cid":null},"woyaola":null,"cnzz":null,"leancloud":{"app_id":null,"app_key":null,"server_url":null,"path":"window.location.pathname","ignore_local":false}},"search_path":"/local-search.xml"};
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
<meta name="generator" content="Hexo 6.1.0">
<style>.github-emoji { position: relative; display: inline-block; width: 1.2em; min-height: 1.2em; overflow: hidden; vertical-align: top; color: transparent; }  .github-emoji > span { position: relative; z-index: 10; }  .github-emoji img, .github-emoji .fancybox { margin: 0 !important; padding: 0 !important; border: none !important; outline: none !important; text-decoration: none !important; user-select: none !important; cursor: auto !important; }  .github-emoji img { height: 1.2em !important; width: 1.2em !important; position: absolute !important; left: 50% !important; top: 50% !important; transform: translate(-50%, -50%) !important; user-select: none !important; cursor: auto !important; } .github-emoji-fallback { color: inherit; } .github-emoji-fallback img { opacity: 0 !important; }</style>
</head>


<body>
  <header style="height: 70vh;">
    <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/">
      <strong>txt1994s</strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/">
                <i class="iconfont icon-home-fill"></i>
                é¦–é¡µ
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/">
                <i class="iconfont icon-archive-fill"></i>
                å½’æ¡£
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/">
                <i class="iconfont icon-tags-fill"></i>
                æ ‡ç­¾
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/">
                <i class="iconfont icon-user-fill"></i>
                å…³äº
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/links/">
                <i class="iconfont icon-link-fill"></i>
                å‹è”
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              &nbsp;<i class="iconfont icon-search"></i>&nbsp;
            </a>
          </li>
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">&nbsp;<i
                class="iconfont icon-dark" id="color-toggle-icon"></i>&nbsp;</a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

    <div class="banner" id="banner" parallax=true
         style="background: url('/img/default.png') no-repeat center center;
           background-size: cover;">
      <div class="full-bg-img">
        <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
          <div class="page-header text-center fade-in-up">
            <span class="h2" id="subtitle" title="C++è®¾è®¡æ¨¡å¼-è¡Œä¸ºæ¨¡å¼">
              
            </span>

            
              <div class="mt-3">
  
  
    <span class="post-meta">
      <i class="iconfont icon-date-fill" aria-hidden="true"></i>
      <time datetime="2022-01-03 15:48" pubdate>
        2022å¹´1æœˆ3æ—¥ ä¸‹åˆ
      </time>
    </span>
  
</div>

<div class="mt-1">
  
    <span class="post-meta mr-2">
      <i class="iconfont icon-chart"></i>
      35k å­—
    </span>
  

  
    <span class="post-meta mr-2">
      <i class="iconfont icon-clock-fill"></i>
      
      
      295 åˆ†é’Ÿ
    </span>
  

  
  
</div>

            
          </div>

          
        </div>
      </div>
    </div>
  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="d-none d-lg-block col-lg-2"></div>
    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div class="py-5" id="board">
          <article class="post-content mx-auto">
            <!-- SEO header -->
            <h1 style="display: none">C++è®¾è®¡æ¨¡å¼-è¡Œä¸ºæ¨¡å¼</h1>
            
              <p class="note note-info">
                
                  æœ¬æ–‡æœ€åæ›´æ–°äºï¼š2022å¹´3æœˆ19æ—¥ å‡Œæ™¨
                
              </p>
            
            <div class="markdown-body">
              <div class="toc">

<!-- toc -->

<ul>
<li><a href="#guan-cha-zhe-mo-shi">è§‚å¯Ÿè€…æ¨¡å¼</a></li>
<li><a href="#fang-wen-zhe-mo-shi">è®¿é—®è€…æ¨¡å¼</a></li>
<li><a href="#ze-ren-lian-mo-shi">è´£ä»»é“¾æ¨¡å¼</a></li>
<li><a href="#ming-ling-mo-shi">å‘½ä»¤æ¨¡å¼</a></li>
<li><a href="#die-dai-qi-mo-shi">è¿­ä»£å™¨æ¨¡å¼</a></li>
<li><a href="#zhong-jie-zhe-mo-shi">ä¸­ä»‹è€…æ¨¡å¼</a></li>
<li><a href="#bei-wang-lu-mo-shi">å¤‡å¿˜å½•æ¨¡å¼</a></li>
<li><a href="#zhuang-tai-mo-shi">çŠ¶æ€æ¨¡å¼</a></li>
<li><a href="#ce-lue-mo-shi">ç­–ç•¥æ¨¡å¼</a></li>
<li><a href="#mo-ban-fang-fa-mo-shi">æ¨¡æ¿æ–¹æ³•æ¨¡å¼</a></li>
</ul>
<!-- tocstop -->

</div>

<p>æ¨èçœ‹ğŸ‘‰<a target="_blank" rel="noopener" href="https://refactoringguru.cn/design-patterns">å¸¸ç”¨è®¾è®¡æ¨¡å¼æœ‰å“ªäº›ï¼Ÿ (refactoringguru.cn)</a></p>
<h1><span id="guan-cha-zhe-mo-shi">è§‚å¯Ÿè€…æ¨¡å¼</span><a href="#guan-cha-zhe-mo-shi" class="header-anchor">#</a></h1><p><strong>è§‚å¯Ÿè€…æ¨¡å¼</strong>æ˜¯ä¸€ç§è¡Œä¸ºè®¾è®¡æ¨¡å¼ï¼Œ å…è®¸ä½ å®šä¹‰ä¸€ç§è®¢é˜…æœºåˆ¶ï¼Œ å¯åœ¨å¯¹è±¡äº‹ä»¶å‘ç”Ÿæ—¶é€šçŸ¥å¤šä¸ª â€œè§‚å¯Ÿâ€ è¯¥å¯¹è±¡çš„å…¶ä»–å¯¹è±¡ã€‚</p>
<p>é€‚ç”¨åœºæ™¯:</p>
<ul>
<li><p><strong>å½“ä¸€ä¸ªå¯¹è±¡çŠ¶æ€çš„æ”¹å˜éœ€è¦æ”¹å˜å…¶ä»–å¯¹è±¡ï¼Œ æˆ–å®é™…å¯¹è±¡æ˜¯äº‹å…ˆæœªçŸ¥çš„æˆ–åŠ¨æ€å˜åŒ–çš„æ—¶ï¼Œ å¯ä½¿ç”¨è§‚å¯Ÿè€…æ¨¡å¼ã€‚</strong></p>
</li>
<li><p>å½“ä½ ä½¿ç”¨å›¾å½¢ç”¨æˆ·ç•Œé¢ç±»æ—¶é€šå¸¸ä¼šé‡åˆ°ä¸€ä¸ªé—®é¢˜ã€‚ æ¯”å¦‚ï¼Œ ä½ åˆ›å»ºäº†è‡ªå®šä¹‰æŒ‰é’®ç±»å¹¶å…è®¸å®¢æˆ·ç«¯åœ¨æŒ‰é’®ä¸­æ³¨å…¥è‡ªå®šä¹‰ä»£ç ï¼Œ è¿™æ ·å½“ç”¨æˆ·æŒ‰ä¸‹æŒ‰é’®æ—¶å°±ä¼šè§¦å‘è¿™äº›ä»£ç ã€‚</p>
</li>
<li><p>è§‚å¯Ÿè€…æ¨¡å¼å…è®¸ä»»ä½•å®ç°äº†è®¢é˜…è€…æ¥å£çš„å¯¹è±¡è®¢é˜…å‘å¸ƒè€…å¯¹è±¡çš„äº‹ä»¶é€šçŸ¥ã€‚ ä½ å¯åœ¨æŒ‰é’®ä¸­æ·»åŠ è®¢é˜…æœºåˆ¶ï¼Œ å…è®¸å®¢æˆ·ç«¯é€šè¿‡è‡ªå®šä¹‰è®¢é˜…ç±»æ³¨å…¥è‡ªå®šä¹‰ä»£ç ã€‚</p>
</li>
<li><p><strong>å½“åº”ç”¨ä¸­çš„ä¸€äº›å¯¹è±¡å¿…é¡»è§‚å¯Ÿå…¶ä»–å¯¹è±¡æ—¶ï¼Œ å¯ä½¿ç”¨è¯¥æ¨¡å¼ã€‚ ä½†ä»…èƒ½åœ¨æœ‰é™æ—¶é—´å†…æˆ–ç‰¹å®šæƒ…å†µä¸‹ä½¿ç”¨ã€‚</strong></p>
</li>
<li><p>è®¢é˜…åˆ—è¡¨æ˜¯åŠ¨æ€çš„ï¼Œ å› æ­¤è®¢é˜…è€…å¯éšæ—¶åŠ å…¥æˆ–ç¦»å¼€è¯¥åˆ—è¡¨ã€‚</p>
</li>
</ul>
<div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-comment">/**</span>
<span class="hljs-comment"> * Observer Design Pattern</span>
<span class="hljs-comment"> *</span>
<span class="hljs-comment"> * Intent: Lets you define a subscription mechanism to notify multiple objects</span>
<span class="hljs-comment"> * about any events that happen to the object they're observing.</span>
<span class="hljs-comment"> *</span>
<span class="hljs-comment"> * Note that there's a lot of different terms with similar meaning associated</span>
<span class="hljs-comment"> * with this pattern. Just remember that the Subject is also called the</span>
<span class="hljs-comment"> * Publisher and the Observer is often called the Subscriber and vice versa.</span>
<span class="hljs-comment"> * Also the verbs "observe", "listen" or "track" usually mean the same thing.</span>
<span class="hljs-comment"> */</span>

<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;list&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span>

<span class="hljs-keyword">class</span> <span class="hljs-title class_">IObserver</span> {
<span class="hljs-keyword">public</span>:
    <span class="hljs-keyword">virtual</span> ~<span class="hljs-built_in">IObserver</span>(){};
    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">Update</span><span class="hljs-params">(<span class="hljs-type">const</span> std::string &amp;message_from_subject)</span> </span>= <span class="hljs-number">0</span>;
};

<span class="hljs-keyword">class</span> <span class="hljs-title class_">ISubject</span> {
<span class="hljs-keyword">public</span>:
    <span class="hljs-keyword">virtual</span> ~<span class="hljs-built_in">ISubject</span>(){};
    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">Attach</span><span class="hljs-params">(IObserver *observer)</span> </span>= <span class="hljs-number">0</span>;
    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">Detach</span><span class="hljs-params">(IObserver *observer)</span> </span>= <span class="hljs-number">0</span>;
    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">Notify</span><span class="hljs-params">()</span> </span>= <span class="hljs-number">0</span>;
};

<span class="hljs-comment">/**</span>
<span class="hljs-comment"> * The Subject owns some important state and notifies observers when the state</span>
<span class="hljs-comment"> * changes.</span>
<span class="hljs-comment"> */</span>

<span class="hljs-keyword">class</span> <span class="hljs-title class_">Subject</span> : <span class="hljs-keyword">public</span> ISubject {
<span class="hljs-keyword">public</span>:
    <span class="hljs-keyword">virtual</span> ~<span class="hljs-built_in">Subject</span>() {
        std::cout &lt;&lt; <span class="hljs-string">"Goodbye, I was the Subject.\n"</span>;
    }

    <span class="hljs-comment">/**</span>
<span class="hljs-comment">       * The subscription management methods.</span>
<span class="hljs-comment">       */</span>
    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Attach</span><span class="hljs-params">(IObserver *observer)</span> <span class="hljs-keyword">override</span> </span>{
        list_observer_.<span class="hljs-built_in">push_back</span>(observer);
    }
    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Detach</span><span class="hljs-params">(IObserver *observer)</span> <span class="hljs-keyword">override</span> </span>{
        list_observer_.<span class="hljs-built_in">remove</span>(observer);
    }
    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Notify</span><span class="hljs-params">()</span> <span class="hljs-keyword">override</span> </span>{
        std::list&lt;IObserver *&gt;::iterator iterator = list_observer_.<span class="hljs-built_in">begin</span>();
        <span class="hljs-built_in">HowManyObserver</span>();
        <span class="hljs-keyword">while</span> (iterator != list_observer_.<span class="hljs-built_in">end</span>()) {
            (*iterator)-&gt;<span class="hljs-built_in">Update</span>(message_);
            ++iterator;
        }
    }

    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">CreateMessage</span><span class="hljs-params">(std::string message = <span class="hljs-string">"Empty"</span>)</span> </span>{
        <span class="hljs-keyword">this</span>-&gt;message_ = message;
        <span class="hljs-built_in">Notify</span>();
    }
    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">HowManyObserver</span><span class="hljs-params">()</span> </span>{
        std::cout &lt;&lt; <span class="hljs-string">"There are "</span> &lt;&lt; list_observer_.<span class="hljs-built_in">size</span>() &lt;&lt; <span class="hljs-string">" observers in the list.\n"</span>;
    }

    <span class="hljs-comment">/**</span>
<span class="hljs-comment">       * Usually, the subscription logic is only a fraction of what a Subject can</span>
<span class="hljs-comment">       * really do. Subjects commonly hold some important business logic, that</span>
<span class="hljs-comment">       * triggers a notification method whenever something important is about to</span>
<span class="hljs-comment">       * happen (or after it).</span>
<span class="hljs-comment">       */</span>
    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">SomeBusinessLogic</span><span class="hljs-params">()</span> </span>{
        <span class="hljs-keyword">this</span>-&gt;message_ = <span class="hljs-string">"change message message"</span>;
        <span class="hljs-built_in">Notify</span>();
        std::cout &lt;&lt; <span class="hljs-string">"I'm about to do some thing important\n"</span>;
    }

<span class="hljs-keyword">private</span>:
    std::list&lt;IObserver *&gt; list_observer_;
    std::string message_;
};

<span class="hljs-keyword">class</span> <span class="hljs-title class_">Observer</span> : <span class="hljs-keyword">public</span> IObserver {
<span class="hljs-keyword">public</span>:
    <span class="hljs-built_in">Observer</span>(Subject &amp;subject) : <span class="hljs-built_in">subject_</span>(subject) {
        <span class="hljs-keyword">this</span>-&gt;subject_.<span class="hljs-built_in">Attach</span>(<span class="hljs-keyword">this</span>);
        std::cout &lt;&lt; <span class="hljs-string">"Hi, I'm the Observer \""</span> &lt;&lt; ++Observer::static_number_ &lt;&lt; <span class="hljs-string">"\".\n"</span>;
        <span class="hljs-keyword">this</span>-&gt;number_ = Observer::static_number_;
    }
    <span class="hljs-keyword">virtual</span> ~<span class="hljs-built_in">Observer</span>() {
        std::cout &lt;&lt; <span class="hljs-string">"Goodbye, I was the Observer \""</span> &lt;&lt; <span class="hljs-keyword">this</span>-&gt;number_ &lt;&lt; <span class="hljs-string">"\".\n"</span>;
    }

    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Update</span><span class="hljs-params">(<span class="hljs-type">const</span> std::string &amp;message_from_subject)</span> <span class="hljs-keyword">override</span> </span>{
        message_from_subject_ = message_from_subject;
        <span class="hljs-built_in">PrintInfo</span>();
    }
    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">RemoveMeFromTheList</span><span class="hljs-params">()</span> </span>{
        subject_.<span class="hljs-built_in">Detach</span>(<span class="hljs-keyword">this</span>);
        std::cout &lt;&lt; <span class="hljs-string">"Observer \""</span> &lt;&lt; number_ &lt;&lt; <span class="hljs-string">"\" removed from the list.\n"</span>;
    }
    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">PrintInfo</span><span class="hljs-params">()</span> </span>{
        std::cout &lt;&lt; <span class="hljs-string">"Observer \""</span> &lt;&lt; <span class="hljs-keyword">this</span>-&gt;number_ &lt;&lt; <span class="hljs-string">"\": a new message is available --&gt; "</span> &lt;&lt; <span class="hljs-keyword">this</span>-&gt;message_from_subject_ &lt;&lt; <span class="hljs-string">"\n"</span>;
    }

<span class="hljs-keyword">private</span>:
    std::string message_from_subject_;
    Subject &amp;subject_;
    <span class="hljs-type">static</span> <span class="hljs-type">int</span> static_number_;
    <span class="hljs-type">int</span> number_;
};

<span class="hljs-type">int</span> Observer::static_number_ = <span class="hljs-number">0</span>;

<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">ClientCode</span><span class="hljs-params">()</span> </span>{
    Subject *subject = <span class="hljs-keyword">new</span> Subject;
    Observer *observer1 = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Observer</span>(*subject);
    Observer *observer2 = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Observer</span>(*subject);
    Observer *observer3 = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Observer</span>(*subject);
    Observer *observer4;
    Observer *observer5;

    subject-&gt;<span class="hljs-built_in">CreateMessage</span>(<span class="hljs-string">"Hello World! :D"</span>);
    observer3-&gt;<span class="hljs-built_in">RemoveMeFromTheList</span>();

    subject-&gt;<span class="hljs-built_in">CreateMessage</span>(<span class="hljs-string">"The weather is hot today! :p"</span>);
    observer4 = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Observer</span>(*subject);

    observer2-&gt;<span class="hljs-built_in">RemoveMeFromTheList</span>();
    observer5 = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Observer</span>(*subject);

    subject-&gt;<span class="hljs-built_in">CreateMessage</span>(<span class="hljs-string">"My new car is great! ;)"</span>);
    observer5-&gt;<span class="hljs-built_in">RemoveMeFromTheList</span>();

    observer4-&gt;<span class="hljs-built_in">RemoveMeFromTheList</span>();
    observer1-&gt;<span class="hljs-built_in">RemoveMeFromTheList</span>();

    <span class="hljs-keyword">delete</span> observer5;
    <span class="hljs-keyword">delete</span> observer4;
    <span class="hljs-keyword">delete</span> observer3;
    <span class="hljs-keyword">delete</span> observer2;
    <span class="hljs-keyword">delete</span> observer1;
    <span class="hljs-keyword">delete</span> subject;
}

<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>{
    <span class="hljs-built_in">ClientCode</span>();
    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
}</code></pre></div>

<h1><span id="fang-wen-zhe-mo-shi">è®¿é—®è€…æ¨¡å¼</span><a href="#fang-wen-zhe-mo-shi" class="header-anchor">#</a></h1><p><strong>é—®è€…æ¨¡å¼</strong>æ˜¯ä¸€ç§è¡Œä¸ºè®¾è®¡æ¨¡å¼ï¼Œ å®ƒèƒ½å°†ç®—æ³•ä¸å…¶æ‰€ä½œç”¨çš„å¯¹è±¡éš”ç¦»å¼€æ¥ã€‚</p>
<p>é€‚ç”¨åœºæ™¯:</p>
<ul>
<li><p><strong>å¦‚æœä½ éœ€è¦å¯¹ä¸€ä¸ªå¤æ‚å¯¹è±¡ç»“æ„ ï¼ˆä¾‹å¦‚å¯¹è±¡æ ‘ï¼‰ ä¸­çš„æ‰€æœ‰å…ƒç´ æ‰§è¡ŒæŸäº›æ“ä½œï¼Œ å¯ä½¿ç”¨è®¿é—®è€…æ¨¡å¼ã€‚</strong></p>
</li>
<li><p>è®¿é—®è€…æ¨¡å¼é€šè¿‡åœ¨è®¿é—®è€…å¯¹è±¡ä¸­ä¸ºå¤šä¸ªç›®æ ‡ç±»æä¾›ç›¸åŒæ“ä½œçš„å˜ä½“ï¼Œ è®©ä½ èƒ½åœ¨å±äºä¸åŒç±»çš„ä¸€ç»„å¯¹è±¡ä¸Šæ‰§è¡ŒåŒä¸€æ“ä½œã€‚</p>
</li>
<li><p><strong>å¯ä½¿ç”¨è®¿é—®è€…æ¨¡å¼æ¥æ¸…ç†è¾…åŠ©è¡Œä¸ºçš„ä¸šåŠ¡é€»è¾‘ã€‚</strong></p>
</li>
<li><p>è¯¥æ¨¡å¼ä¼šå°†æ‰€æœ‰éä¸»è¦çš„è¡Œä¸ºæŠ½å–åˆ°ä¸€ç»„è®¿é—®è€…ç±»ä¸­ï¼Œ ä½¿å¾—ç¨‹åºçš„ä¸»è¦ç±»èƒ½æ›´ä¸“æ³¨äºä¸»è¦çš„å·¥ä½œã€‚</p>
</li>
<li><p><strong>å½“æŸä¸ªè¡Œä¸ºä»…åœ¨ç±»å±‚æ¬¡ç»“æ„ä¸­çš„ä¸€äº›ç±»ä¸­æœ‰æ„ä¹‰ï¼Œ è€Œåœ¨å…¶ä»–ç±»ä¸­æ²¡æœ‰æ„ä¹‰æ—¶ï¼Œ å¯ä½¿ç”¨è¯¥æ¨¡å¼ã€‚</strong></p>
</li>
<li><p>ä½ å¯å°†è¯¥è¡Œä¸ºæŠ½å–åˆ°å•ç‹¬çš„è®¿é—®è€…ç±»ä¸­ï¼Œ åªéœ€å®ç°æ¥æ”¶ç›¸å…³ç±»çš„å¯¹è±¡ä½œä¸ºå‚æ•°çš„è®¿é—®è€…æ–¹æ³•å¹¶å°†å…¶ä»–æ–¹æ³•ç•™ç©ºå³å¯ã€‚</p>
</li>
</ul>
<div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-comment">/**</span>
<span class="hljs-comment"> * The Visitor Interface declares a set of visiting methods that correspond to</span>
<span class="hljs-comment"> * component classes. The signature of a visiting method allows the visitor to</span>
<span class="hljs-comment"> * identify the exact class of the component that it's dealing with.</span>
<span class="hljs-comment"> */</span>
<span class="hljs-keyword">class</span> <span class="hljs-title class_">ConcreteComponentA</span>;
<span class="hljs-keyword">class</span> <span class="hljs-title class_">ConcreteComponentB</span>;

<span class="hljs-keyword">class</span> <span class="hljs-title class_">Visitor</span> {
<span class="hljs-keyword">public</span>:
    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">VisitConcreteComponentA</span><span class="hljs-params">(<span class="hljs-type">const</span> ConcreteComponentA *element)</span> <span class="hljs-type">const</span> </span>= <span class="hljs-number">0</span>;
    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">VisitConcreteComponentB</span><span class="hljs-params">(<span class="hljs-type">const</span> ConcreteComponentB *element)</span> <span class="hljs-type">const</span> </span>= <span class="hljs-number">0</span>;
};

<span class="hljs-comment">/**</span>
<span class="hljs-comment"> * The Component interface declares an `accept` method that should take the base</span>
<span class="hljs-comment"> * visitor interface as an argument.</span>
<span class="hljs-comment"> */</span>

<span class="hljs-keyword">class</span> <span class="hljs-title class_">Component</span> {
<span class="hljs-keyword">public</span>:
    <span class="hljs-keyword">virtual</span> ~<span class="hljs-built_in">Component</span>() {}
    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">Accept</span><span class="hljs-params">(Visitor *visitor)</span> <span class="hljs-type">const</span> </span>= <span class="hljs-number">0</span>;
};

<span class="hljs-comment">/**</span>
<span class="hljs-comment"> * Each Concrete Component must implement the `Accept` method in such a way that</span>
<span class="hljs-comment"> * it calls the visitor's method corresponding to the component's class.</span>
<span class="hljs-comment"> */</span>
<span class="hljs-keyword">class</span> <span class="hljs-title class_">ConcreteComponentA</span> : <span class="hljs-keyword">public</span> Component {
  <span class="hljs-comment">/**</span>
<span class="hljs-comment">   * Note that we're calling `visitConcreteComponentA`, which matches the</span>
<span class="hljs-comment">   * current class name. This way we let the visitor know the class of the</span>
<span class="hljs-comment">   * component it works with.</span>
<span class="hljs-comment">   */</span>
<span class="hljs-keyword">public</span>:
    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Accept</span><span class="hljs-params">(Visitor *visitor)</span> <span class="hljs-type">const</span> <span class="hljs-keyword">override</span> </span>{
        visitor-&gt;<span class="hljs-built_in">VisitConcreteComponentA</span>(<span class="hljs-keyword">this</span>);
    }
    <span class="hljs-comment">/**</span>
<span class="hljs-comment">       * Concrete Components may have special methods that don't exist in their base</span>
<span class="hljs-comment">       * class or interface. The Visitor is still able to use these methods since</span>
<span class="hljs-comment">       * it's aware of the component's concrete class.</span>
<span class="hljs-comment">       */</span>
    <span class="hljs-function">std::string <span class="hljs-title">ExclusiveMethodOfConcreteComponentA</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>{
        <span class="hljs-keyword">return</span> <span class="hljs-string">"A"</span>;
    }
};

<span class="hljs-keyword">class</span> <span class="hljs-title class_">ConcreteComponentB</span> : <span class="hljs-keyword">public</span> Component {
  <span class="hljs-comment">/**</span>
<span class="hljs-comment">   * Same here: visitConcreteComponentB =&gt; ConcreteComponentB</span>
<span class="hljs-comment">   */</span>
<span class="hljs-keyword">public</span>:
    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Accept</span><span class="hljs-params">(Visitor *visitor)</span> <span class="hljs-type">const</span> <span class="hljs-keyword">override</span> </span>{
        visitor-&gt;<span class="hljs-built_in">VisitConcreteComponentB</span>(<span class="hljs-keyword">this</span>);
    }
    <span class="hljs-function">std::string <span class="hljs-title">SpecialMethodOfConcreteComponentB</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>{
        <span class="hljs-keyword">return</span> <span class="hljs-string">"B"</span>;
    }
};

<span class="hljs-comment">/**</span>
<span class="hljs-comment"> * Concrete Visitors implement several versions of the same algorithm, which can</span>
<span class="hljs-comment"> * work with all concrete component classes.</span>
<span class="hljs-comment"> *</span>
<span class="hljs-comment"> * You can experience the biggest benefit of the Visitor pattern when using it</span>
<span class="hljs-comment"> * with a complex object structure, such as a Composite tree. In this case, it</span>
<span class="hljs-comment"> * might be helpful to store some intermediate state of the algorithm while</span>
<span class="hljs-comment"> * executing visitor's methods over various objects of the structure.</span>
<span class="hljs-comment"> */</span>
<span class="hljs-keyword">class</span> <span class="hljs-title class_">ConcreteVisitor1</span> : <span class="hljs-keyword">public</span> Visitor {
<span class="hljs-keyword">public</span>:
    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">VisitConcreteComponentA</span><span class="hljs-params">(<span class="hljs-type">const</span> ConcreteComponentA *element)</span> <span class="hljs-type">const</span> <span class="hljs-keyword">override</span> </span>{
        std::cout &lt;&lt; element-&gt;<span class="hljs-built_in">ExclusiveMethodOfConcreteComponentA</span>() &lt;&lt; <span class="hljs-string">" + ConcreteVisitor1\n"</span>;
    }

    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">VisitConcreteComponentB</span><span class="hljs-params">(<span class="hljs-type">const</span> ConcreteComponentB *element)</span> <span class="hljs-type">const</span> <span class="hljs-keyword">override</span> </span>{
        std::cout &lt;&lt; element-&gt;<span class="hljs-built_in">SpecialMethodOfConcreteComponentB</span>() &lt;&lt; <span class="hljs-string">" + ConcreteVisitor1\n"</span>;
    }
};

<span class="hljs-keyword">class</span> <span class="hljs-title class_">ConcreteVisitor2</span> : <span class="hljs-keyword">public</span> Visitor {
<span class="hljs-keyword">public</span>:
    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">VisitConcreteComponentA</span><span class="hljs-params">(<span class="hljs-type">const</span> ConcreteComponentA *element)</span> <span class="hljs-type">const</span> <span class="hljs-keyword">override</span> </span>{
        std::cout &lt;&lt; element-&gt;<span class="hljs-built_in">ExclusiveMethodOfConcreteComponentA</span>() &lt;&lt; <span class="hljs-string">" + ConcreteVisitor2\n"</span>;
    }
    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">VisitConcreteComponentB</span><span class="hljs-params">(<span class="hljs-type">const</span> ConcreteComponentB *element)</span> <span class="hljs-type">const</span> <span class="hljs-keyword">override</span> </span>{
        std::cout &lt;&lt; element-&gt;<span class="hljs-built_in">SpecialMethodOfConcreteComponentB</span>() &lt;&lt; <span class="hljs-string">" + ConcreteVisitor2\n"</span>;
    }
};
<span class="hljs-comment">/**</span>
<span class="hljs-comment"> * The client code can run visitor operations over any set of elements without</span>
<span class="hljs-comment"> * figuring out their concrete classes. The accept operation directs a call to</span>
<span class="hljs-comment"> * the appropriate operation in the visitor object.</span>
<span class="hljs-comment"> */</span>
<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">ClientCode</span><span class="hljs-params">(std::array&lt;<span class="hljs-type">const</span> Component *, <span class="hljs-number">2</span>&gt; components, Visitor *visitor)</span> </span>{
    <span class="hljs-comment">// ...</span>
    <span class="hljs-keyword">for</span> (<span class="hljs-type">const</span> Component *comp : components) {
        comp-&gt;<span class="hljs-built_in">Accept</span>(visitor);
    }
    <span class="hljs-comment">// ...</span>
}

<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>{
    std::array&lt;<span class="hljs-type">const</span> Component *, 2&gt; components = {<span class="hljs-keyword">new</span> ConcreteComponentA, <span class="hljs-keyword">new</span> ConcreteComponentB};
    std::cout &lt;&lt; <span class="hljs-string">"The client code works with all visitors via the base Visitor interface:\n"</span>;
    ConcreteVisitor1 *visitor1 = <span class="hljs-keyword">new</span> ConcreteVisitor1;
    <span class="hljs-built_in">ClientCode</span>(components, visitor1);
    std::cout &lt;&lt; <span class="hljs-string">"\n"</span>;
    std::cout &lt;&lt; <span class="hljs-string">"It allows the same client code to work with different types of visitors:\n"</span>;
    ConcreteVisitor2 *visitor2 = <span class="hljs-keyword">new</span> ConcreteVisitor2;
    <span class="hljs-built_in">ClientCode</span>(components, visitor2);

    <span class="hljs-keyword">for</span> (<span class="hljs-type">const</span> Component *comp : components) {
        <span class="hljs-keyword">delete</span> comp;
    }
    <span class="hljs-keyword">delete</span> visitor1;
    <span class="hljs-keyword">delete</span> visitor2;

    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
}</code></pre></div>

<h1><span id="ze-ren-lian-mo-shi">è´£ä»»é“¾æ¨¡å¼</span><a href="#ze-ren-lian-mo-shi" class="header-anchor">#</a></h1><p><strong>è´£ä»»é“¾æ¨¡å¼</strong>æ˜¯ä¸€ç§è¡Œä¸ºè®¾è®¡æ¨¡å¼ï¼Œ å…è®¸ä½ å°†è¯·æ±‚æ²¿ç€å¤„ç†è€…é“¾è¿›è¡Œå‘é€ã€‚ æ”¶åˆ°è¯·æ±‚åï¼Œ æ¯ä¸ªå¤„ç†è€…å‡å¯å¯¹è¯·æ±‚è¿›è¡Œå¤„ç†ï¼Œ æˆ–å°†å…¶ä¼ é€’ç»™é“¾ä¸Šçš„ä¸‹ä¸ªå¤„ç†è€…ã€‚</p>
<p>é€‚åˆåº”ç”¨åœºæ™¯:</p>
<ul>
<li><p><strong>å½“ç¨‹åºéœ€è¦ä½¿ç”¨ä¸åŒæ–¹å¼å¤„ç†ä¸åŒç§ç±»è¯·æ±‚ï¼Œ è€Œä¸”è¯·æ±‚ç±»å‹å’Œé¡ºåºé¢„å…ˆæœªçŸ¥æ—¶ï¼Œ å¯ä»¥ä½¿ç”¨è´£ä»»é“¾æ¨¡å¼ã€‚</strong></p>
</li>
<li><p>è¯¥æ¨¡å¼èƒ½å°†å¤šä¸ªå¤„ç†è€…è¿æ¥æˆä¸€æ¡é“¾ã€‚ æ¥æ”¶åˆ°è¯·æ±‚åï¼Œ å®ƒä¼š â€œè¯¢é—®â€ æ¯ä¸ªå¤„ç†è€…æ˜¯å¦èƒ½å¤Ÿå¯¹å…¶è¿›è¡Œå¤„ç†ã€‚ è¿™æ ·æ‰€æœ‰å¤„ç†è€…éƒ½æœ‰æœºä¼šæ¥å¤„ç†è¯·æ±‚ã€‚</p>
</li>
<li><p><strong>å½“å¿…é¡»æŒ‰é¡ºåºæ‰§è¡Œå¤šä¸ªå¤„ç†è€…æ—¶ï¼Œ å¯ä»¥ä½¿ç”¨è¯¥æ¨¡å¼ã€‚</strong></p>
</li>
<li><p>æ— è®ºä½ ä»¥ä½•ç§é¡ºåºå°†å¤„ç†è€…è¿æ¥æˆä¸€æ¡é“¾ï¼Œ æ‰€æœ‰è¯·æ±‚éƒ½ä¼šä¸¥æ ¼æŒ‰ç…§é¡ºåºé€šè¿‡é“¾ä¸Šçš„å¤„ç†è€…ã€‚</p>
</li>
<li><p>å¦‚<strong>æœæ‰€éœ€å¤„ç†è€…åŠå…¶é¡ºåºå¿…é¡»åœ¨è¿è¡Œæ—¶è¿›è¡Œæ”¹å˜ï¼Œ å¯ä»¥ä½¿ç”¨è´£ä»»é“¾æ¨¡å¼ã€‚</strong></p>
</li>
<li><p>å¦‚æœåœ¨å¤„ç†è€…ç±»ä¸­æœ‰å¯¹å¼•ç”¨æˆå‘˜å˜é‡çš„è®¾å®šæ–¹æ³•ï¼Œ ä½ å°†èƒ½åŠ¨æ€åœ°æ’å…¥å’Œç§»é™¤å¤„ç†è€…ï¼Œ æˆ–è€…æ”¹å˜å…¶é¡ºåºã€‚</p>
</li>
</ul>
<div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-comment">/**</span>
<span class="hljs-comment"> * The Handler interface declares a method for building the chain of handlers.</span>
<span class="hljs-comment"> * It also declares a method for executing a request.</span>
<span class="hljs-comment"> */</span>
<span class="hljs-keyword">class</span> <span class="hljs-title class_">Handler</span> {
<span class="hljs-keyword">public</span>:
    <span class="hljs-function"><span class="hljs-keyword">virtual</span> Handler *<span class="hljs-title">SetNext</span><span class="hljs-params">(Handler *handler)</span> </span>= <span class="hljs-number">0</span>;
    <span class="hljs-function"><span class="hljs-keyword">virtual</span> std::string <span class="hljs-title">Handle</span><span class="hljs-params">(std::string request)</span> </span>= <span class="hljs-number">0</span>;
};
<span class="hljs-comment">/**</span>
<span class="hljs-comment"> * The default chaining behavior can be implemented inside a base handler class.</span>
<span class="hljs-comment"> */</span>
<span class="hljs-keyword">class</span> <span class="hljs-title class_">AbstractHandler</span> : <span class="hljs-keyword">public</span> Handler {
  <span class="hljs-comment">/**</span>
<span class="hljs-comment">   * @var Handler</span>
<span class="hljs-comment">   */</span>
<span class="hljs-keyword">private</span>:
  	Handler *next_handler_;

<span class="hljs-keyword">public</span>:
    <span class="hljs-built_in">AbstractHandler</span>() : <span class="hljs-built_in">next_handler_</span>(<span class="hljs-literal">nullptr</span>) {
    }
    <span class="hljs-function">Handler *<span class="hljs-title">SetNext</span><span class="hljs-params">(Handler *handler)</span> <span class="hljs-keyword">override</span> </span>{
        <span class="hljs-keyword">this</span>-&gt;next_handler_ = handler;
        <span class="hljs-comment">// Returning a handler from here will let us link handlers in a convenient</span>
        <span class="hljs-comment">// way like this:</span>
        <span class="hljs-comment">// $monkey-&gt;setNext($squirrel)-&gt;setNext($dog);</span>
        <span class="hljs-keyword">return</span> handler;
    }
    <span class="hljs-function">std::string <span class="hljs-title">Handle</span><span class="hljs-params">(std::string request)</span> <span class="hljs-keyword">override</span> </span>{
        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>-&gt;next_handler_) {
            <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>-&gt;next_handler_-&gt;<span class="hljs-built_in">Handle</span>(request);
        }

        <span class="hljs-keyword">return</span> {};
    }
};
<span class="hljs-comment">/**</span>
<span class="hljs-comment"> * All Concrete Handlers either handle a request or pass it to the next handler</span>
<span class="hljs-comment"> * in the chain.</span>
<span class="hljs-comment"> */</span>
<span class="hljs-keyword">class</span> <span class="hljs-title class_">MonkeyHandler</span> : <span class="hljs-keyword">public</span> AbstractHandler {
<span class="hljs-keyword">public</span>:
    <span class="hljs-function">std::string <span class="hljs-title">Handle</span><span class="hljs-params">(std::string request)</span> <span class="hljs-keyword">override</span> </span>{
        <span class="hljs-keyword">if</span> (request == <span class="hljs-string">"Banana"</span>) {
            <span class="hljs-keyword">return</span> <span class="hljs-string">"Monkey: I'll eat the "</span> + request + <span class="hljs-string">".\n"</span>;
        } <span class="hljs-keyword">else</span> {
            <span class="hljs-keyword">return</span> AbstractHandler::<span class="hljs-built_in">Handle</span>(request);
        }
    }
};
<span class="hljs-keyword">class</span> <span class="hljs-title class_">SquirrelHandler</span> : <span class="hljs-keyword">public</span> AbstractHandler {
<span class="hljs-keyword">public</span>:
    <span class="hljs-function">std::string <span class="hljs-title">Handle</span><span class="hljs-params">(std::string request)</span> <span class="hljs-keyword">override</span> </span>{
        <span class="hljs-keyword">if</span> (request == <span class="hljs-string">"Nut"</span>) {
            <span class="hljs-keyword">return</span> <span class="hljs-string">"Squirrel: I'll eat the "</span> + request + <span class="hljs-string">".\n"</span>;
        } <span class="hljs-keyword">else</span> {
            <span class="hljs-keyword">return</span> AbstractHandler::<span class="hljs-built_in">Handle</span>(request);
        }
    }
};
<span class="hljs-keyword">class</span> <span class="hljs-title class_">DogHandler</span> : <span class="hljs-keyword">public</span> AbstractHandler {
<span class="hljs-keyword">public</span>:
    <span class="hljs-function">std::string <span class="hljs-title">Handle</span><span class="hljs-params">(std::string request)</span> <span class="hljs-keyword">override</span> </span>{
        <span class="hljs-keyword">if</span> (request == <span class="hljs-string">"MeatBall"</span>) {
            <span class="hljs-keyword">return</span> <span class="hljs-string">"Dog: I'll eat the "</span> + request + <span class="hljs-string">".\n"</span>;
        } <span class="hljs-keyword">else</span> {
            <span class="hljs-keyword">return</span> AbstractHandler::<span class="hljs-built_in">Handle</span>(request);
        }
    }
};
<span class="hljs-comment">/**</span>
<span class="hljs-comment"> * The client code is usually suited to work with a single handler. In most</span>
<span class="hljs-comment"> * cases, it is not even aware that the handler is part of a chain.</span>
<span class="hljs-comment"> */</span>
<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">ClientCode</span><span class="hljs-params">(Handler &amp;handler)</span> </span>{
    std::vector&lt;std::string&gt; food = {<span class="hljs-string">"Nut"</span>, <span class="hljs-string">"Banana"</span>, <span class="hljs-string">"Cup of coffee"</span>};
    <span class="hljs-keyword">for</span> (<span class="hljs-type">const</span> std::string &amp;f : food) {
        std::cout &lt;&lt; <span class="hljs-string">"Client: Who wants a "</span> &lt;&lt; f &lt;&lt; <span class="hljs-string">"?\n"</span>;
        <span class="hljs-type">const</span> std::string result = handler.<span class="hljs-built_in">Handle</span>(f);
        <span class="hljs-keyword">if</span> (!result.<span class="hljs-built_in">empty</span>()) {
            std::cout &lt;&lt; <span class="hljs-string">"  "</span> &lt;&lt; result;
        } <span class="hljs-keyword">else</span> {
            std::cout &lt;&lt; <span class="hljs-string">"  "</span> &lt;&lt; f &lt;&lt; <span class="hljs-string">" was left untouched.\n"</span>;
        }
    }
}
<span class="hljs-comment">/**</span>
<span class="hljs-comment"> * The other part of the client code constructs the actual chain.</span>
<span class="hljs-comment"> */</span>
<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>{
    MonkeyHandler *monkey = <span class="hljs-keyword">new</span> MonkeyHandler;
    SquirrelHandler *squirrel = <span class="hljs-keyword">new</span> SquirrelHandler;
    DogHandler *dog = <span class="hljs-keyword">new</span> DogHandler;
    monkey-&gt;<span class="hljs-built_in">SetNext</span>(squirrel)-&gt;<span class="hljs-built_in">SetNext</span>(dog);

    <span class="hljs-comment">/**</span>
<span class="hljs-comment">       * The client should be able to send a request to any handler, not just the</span>
<span class="hljs-comment">       * first one in the chain.</span>
<span class="hljs-comment">       */</span>
    std::cout &lt;&lt; <span class="hljs-string">"Chain: Monkey &gt; Squirrel &gt; Dog\n\n"</span>;
    <span class="hljs-built_in">ClientCode</span>(*monkey);
    std::cout &lt;&lt; <span class="hljs-string">"\n"</span>;
    std::cout &lt;&lt; <span class="hljs-string">"Subchain: Squirrel &gt; Dog\n\n"</span>;
    <span class="hljs-built_in">ClientCode</span>(*squirrel);

    <span class="hljs-keyword">delete</span> monkey;
    <span class="hljs-keyword">delete</span> squirrel;
    <span class="hljs-keyword">delete</span> dog;

    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
}</code></pre></div>

<h1><span id="ming-ling-mo-shi">å‘½ä»¤æ¨¡å¼</span><a href="#ming-ling-mo-shi" class="header-anchor">#</a></h1><p><strong>å‘½ä»¤æ¨¡å¼</strong>æ˜¯ä¸€ç§è¡Œä¸ºè®¾è®¡æ¨¡å¼ï¼Œ å®ƒå¯å°†è¯·æ±‚è½¬æ¢ä¸ºä¸€ä¸ªåŒ…å«ä¸è¯·æ±‚ç›¸å…³çš„æ‰€æœ‰ä¿¡æ¯çš„ç‹¬ç«‹å¯¹è±¡ã€‚ è¯¥è½¬æ¢è®©ä½ èƒ½æ ¹æ®ä¸åŒçš„è¯·æ±‚å°†æ–¹æ³•å‚æ•°åŒ–ã€ å»¶è¿Ÿè¯·æ±‚æ‰§è¡Œæˆ–å°†å…¶æ”¾å…¥é˜Ÿåˆ—ä¸­ï¼Œ ä¸”èƒ½å®ç°å¯æ’¤é”€æ“ä½œã€‚</p>
<p>é€‚åˆåº”ç”¨åœºæ™¯:</p>
<ul>
<li><p><strong>å¦‚æœä½ éœ€è¦é€šè¿‡æ“ä½œæ¥å‚æ•°åŒ–å¯¹è±¡ï¼Œ å¯ä½¿ç”¨å‘½ä»¤æ¨¡å¼ã€‚</strong></p>
</li>
<li><p>å‘½ä»¤æ¨¡å¼å¯å°†ç‰¹å®šçš„æ–¹æ³•è°ƒç”¨è½¬åŒ–ä¸ºç‹¬ç«‹å¯¹è±¡ã€‚ è¿™ä¸€æ”¹å˜ä¹Ÿå¸¦æ¥äº†è®¸å¤šæœ‰è¶£çš„åº”ç”¨ï¼š ä½ å¯ä»¥å°†å‘½ä»¤ä½œä¸ºæ–¹æ³•çš„å‚æ•°è¿›è¡Œä¼ é€’ã€ å°†å‘½ä»¤ä¿å­˜åœ¨å…¶ä»–å¯¹è±¡ä¸­ï¼Œ æˆ–è€…åœ¨è¿è¡Œæ—¶åˆ‡æ¢å·²è¿æ¥çš„å‘½ä»¤ç­‰ã€‚</p>
</li>
<li><p>ä¸¾ä¸ªä¾‹å­ï¼š ä½ æ­£åœ¨å¼€å‘ä¸€ä¸ª GUI ç»„ä»¶ ï¼ˆä¾‹å¦‚ä¸Šä¸‹æ–‡èœå•ï¼‰ï¼Œ ä½ å¸Œæœ›ç”¨æˆ·èƒ½å¤Ÿé…ç½®èœå•é¡¹ï¼Œ å¹¶åœ¨ç‚¹å‡»èœå•é¡¹æ—¶è§¦å‘æ“ä½œã€‚</p>
</li>
</ul>
<p> <strong>å¦‚æœä½ æƒ³è¦å°†æ“ä½œæ”¾å…¥é˜Ÿåˆ—ä¸­ã€ æ“ä½œçš„æ‰§è¡Œæˆ–è€…è¿œç¨‹æ‰§è¡Œæ“ä½œï¼Œ å¯ä½¿ç”¨å‘½ä»¤æ¨¡å¼ã€‚</strong></p>
<ul>
<li><p>åŒå…¶ä»–å¯¹è±¡ä¸€æ ·ï¼Œ å‘½ä»¤ä¹Ÿå¯ä»¥å®ç°åºåˆ—åŒ– ï¼ˆåºåˆ—åŒ–çš„æ„æ€æ˜¯è½¬åŒ–ä¸ºå­—ç¬¦ä¸²ï¼‰ï¼Œ ä»è€Œèƒ½æ–¹ä¾¿åœ°å†™å…¥æ–‡ä»¶æˆ–æ•°æ®åº“ä¸­ã€‚ ä¸€æ®µæ—¶é—´åï¼Œ è¯¥å­—ç¬¦ä¸²å¯è¢«æ¢å¤æˆä¸ºæœ€åˆçš„å‘½ä»¤å¯¹è±¡ã€‚ å› æ­¤ï¼Œ ä½ å¯ä»¥å»¶è¿Ÿæˆ–è®¡åˆ’å‘½ä»¤çš„æ‰§è¡Œã€‚ ä½†å…¶åŠŸèƒ½è¿œä¸æ­¢å¦‚æ­¤ï¼ ä½¿ç”¨åŒæ ·çš„æ–¹å¼ï¼Œ ä½ è¿˜å¯ä»¥å°†å‘½ä»¤æ”¾å…¥é˜Ÿåˆ—ã€ è®°å½•å‘½ä»¤æˆ–è€…é€šè¿‡ç½‘ç»œå‘é€å‘½ä»¤ã€‚</p>
</li>
<li><p><strong>å¦‚æœä½ æƒ³è¦å®ç°æ“ä½œå›æ»šåŠŸèƒ½ï¼Œ å¯ä½¿ç”¨å‘½ä»¤æ¨¡å¼ã€‚</strong></p>
</li>
<li><p>å°½ç®¡æœ‰å¾ˆå¤šæ–¹æ³•å¯ä»¥å®ç°æ’¤é”€å’Œæ¢å¤åŠŸèƒ½ï¼Œ ä½†å‘½ä»¤æ¨¡å¼å¯èƒ½æ˜¯å…¶ä¸­æœ€å¸¸ç”¨çš„ä¸€ç§ã€‚</p>
</li>
<li><p>ä¸ºäº†èƒ½å¤Ÿå›æ»šæ“ä½œï¼Œ ä½ éœ€è¦å®ç°å·²æ‰§è¡Œæ“ä½œçš„å†å²è®°å½•åŠŸèƒ½ã€‚ å‘½ä»¤å†å²è®°å½•æ˜¯ä¸€ç§åŒ…å«æ‰€æœ‰å·²æ‰§è¡Œå‘½ä»¤å¯¹è±¡åŠå…¶ç›¸å…³ç¨‹åºçŠ¶æ€å¤‡ä»½çš„æ ˆç»“æ„ã€‚</p>
</li>
<li><p>è¿™ç§æ–¹æ³•æœ‰ä¸¤ä¸ªç¼ºç‚¹ã€‚ é¦–å…ˆï¼Œ ç¨‹åºçŠ¶æ€çš„ä¿å­˜åŠŸèƒ½å¹¶ä¸å®¹æ˜“å®ç°ï¼Œ å› ä¸ºéƒ¨åˆ†çŠ¶æ€å¯èƒ½æ˜¯ç§æœ‰çš„ã€‚ ä½ å¯ä»¥ä½¿ç”¨<a target="_blank" rel="noopener" href="https://refactoringguru.cn/design-patterns/memento">å¤‡å¿˜å½•</a>æ¨¡å¼æ¥åœ¨ä¸€å®šç¨‹åº¦ä¸Šè§£å†³è¿™ä¸ªé—®é¢˜ã€‚</p>
</li>
<li><p>å…¶æ¬¡ï¼Œ å¤‡ä»½çŠ¶æ€å¯èƒ½ä¼šå ç”¨å¤§é‡å†…å­˜ã€‚ å› æ­¤ï¼Œ æœ‰æ—¶ä½ éœ€è¦å€ŸåŠ©å¦ä¸€ç§å®ç°æ–¹å¼ï¼š å‘½ä»¤æ— éœ€æ¢å¤åŸå§‹çŠ¶æ€ï¼Œ è€Œæ˜¯æ‰§è¡Œåå‘æ“ä½œã€‚ åå‘æ“ä½œä¹Ÿæœ‰ä»£ä»·ï¼š å®ƒå¯èƒ½ä¼šå¾ˆéš¾ç”šè‡³æ˜¯æ— æ³•å®ç°ã€‚</p>
</li>
</ul>
<div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-comment">/**</span>
<span class="hljs-comment"> * The Command interface declares a method for executing a command.</span>
<span class="hljs-comment"> */</span>
<span class="hljs-keyword">class</span> <span class="hljs-title class_">Command</span> {
<span class="hljs-keyword">public</span>:
    <span class="hljs-keyword">virtual</span> ~<span class="hljs-built_in">Command</span>() {
    }
    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">Execute</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>= <span class="hljs-number">0</span>;
};
<span class="hljs-comment">/**</span>
<span class="hljs-comment"> * Some commands can implement simple operations on their own.</span>
<span class="hljs-comment"> */</span>
<span class="hljs-keyword">class</span> <span class="hljs-title class_">SimpleCommand</span> : <span class="hljs-keyword">public</span> Command {
<span class="hljs-keyword">private</span>:
  	std::string pay_load_;

<span class="hljs-keyword">public</span>:
    <span class="hljs-function"><span class="hljs-keyword">explicit</span> <span class="hljs-title">SimpleCommand</span><span class="hljs-params">(std::string pay_load)</span> : pay_load_(pay_load) {</span>
    }
    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Execute</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> <span class="hljs-keyword">override</span> </span>{
        std::cout &lt;&lt; <span class="hljs-string">"SimpleCommand: See, I can do simple things like printing ("</span> &lt;&lt; <span class="hljs-keyword">this</span>-&gt;pay_load_ &lt;&lt; <span class="hljs-string">")\n"</span>;
    }
};

<span class="hljs-comment">/**</span>
<span class="hljs-comment"> * The Receiver classes contain some important business logic. They know how to</span>
<span class="hljs-comment"> * perform all kinds of operations, associated with carrying out a request. In</span>
<span class="hljs-comment"> * fact, any class may serve as a Receiver.</span>
<span class="hljs-comment"> */</span>
<span class="hljs-keyword">class</span> <span class="hljs-title class_">Receiver</span> {
<span class="hljs-keyword">public</span>:
    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">DoSomething</span><span class="hljs-params">(<span class="hljs-type">const</span> std::string &amp;a)</span> </span>{
        std::cout &lt;&lt; <span class="hljs-string">"Receiver: Working on ("</span> &lt;&lt; a &lt;&lt; <span class="hljs-string">".)\n"</span>;
    }
    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">DoSomethingElse</span><span class="hljs-params">(<span class="hljs-type">const</span> std::string &amp;b)</span> </span>{
        std::cout &lt;&lt; <span class="hljs-string">"Receiver: Also working on ("</span> &lt;&lt; b &lt;&lt; <span class="hljs-string">".)\n"</span>;
    }
};

<span class="hljs-comment">/**</span>
<span class="hljs-comment"> * However, some commands can delegate more complex operations to other objects,</span>
<span class="hljs-comment"> * called "receivers."</span>
<span class="hljs-comment"> */</span>
<span class="hljs-keyword">class</span> <span class="hljs-title class_">ComplexCommand</span> : <span class="hljs-keyword">public</span> Command {
  <span class="hljs-comment">/**</span>
<span class="hljs-comment">   * @var Receiver</span>
<span class="hljs-comment">   */</span>
<span class="hljs-keyword">private</span>:
    Receiver *receiver_;
    <span class="hljs-comment">/**</span>
<span class="hljs-comment">       * Context data, required for launching the receiver's methods.</span>
<span class="hljs-comment">       */</span>
    std::string a_;
    std::string b_;
    <span class="hljs-comment">/**</span>
<span class="hljs-comment">       * Complex commands can accept one or several receiver objects along with any</span>
<span class="hljs-comment">       * context data via the constructor.</span>
<span class="hljs-comment">       */</span>
<span class="hljs-keyword">public</span>:
    <span class="hljs-built_in">ComplexCommand</span>(Receiver *receiver, std::string a, std::string b) : <span class="hljs-built_in">receiver_</span>(receiver), <span class="hljs-built_in">a_</span>(a), <span class="hljs-built_in">b_</span>(b) {
    }
    <span class="hljs-comment">/**</span>
<span class="hljs-comment">       * Commands can delegate to any methods of a receiver.</span>
<span class="hljs-comment">       */</span>
    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Execute</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> <span class="hljs-keyword">override</span> </span>{
        std::cout &lt;&lt; <span class="hljs-string">"ComplexCommand: Complex stuff should be done by a receiver object.\n"</span>;
        <span class="hljs-keyword">this</span>-&gt;receiver_-&gt;<span class="hljs-built_in">DoSomething</span>(<span class="hljs-keyword">this</span>-&gt;a_);
        <span class="hljs-keyword">this</span>-&gt;receiver_-&gt;<span class="hljs-built_in">DoSomethingElse</span>(<span class="hljs-keyword">this</span>-&gt;b_);
    }
};

<span class="hljs-comment">/**</span>
<span class="hljs-comment"> * The Invoker is associated with one or several commands. It sends a request to</span>
<span class="hljs-comment"> * the command.</span>
<span class="hljs-comment"> */</span>
<span class="hljs-keyword">class</span> <span class="hljs-title class_">Invoker</span> {
  <span class="hljs-comment">/**</span>
<span class="hljs-comment">   * @var Command</span>
<span class="hljs-comment">   */</span>
<span class="hljs-keyword">private</span>:
    Command *on_start_;
    <span class="hljs-comment">/**</span>
<span class="hljs-comment">       * @var Command</span>
<span class="hljs-comment">       */</span>
    Command *on_finish_;
    <span class="hljs-comment">/**</span>
<span class="hljs-comment">       * Initialize commands.</span>
<span class="hljs-comment">       */</span>
<span class="hljs-keyword">public</span>:
    ~<span class="hljs-built_in">Invoker</span>() {
        <span class="hljs-keyword">delete</span> on_start_;
        <span class="hljs-keyword">delete</span> on_finish_;
    }

    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">SetOnStart</span><span class="hljs-params">(Command *command)</span> </span>{
        <span class="hljs-keyword">this</span>-&gt;on_start_ = command;
    }
    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">SetOnFinish</span><span class="hljs-params">(Command *command)</span> </span>{
        <span class="hljs-keyword">this</span>-&gt;on_finish_ = command;
    }
    <span class="hljs-comment">/**</span>
<span class="hljs-comment">       * The Invoker does not depend on concrete command or receiver classes. The</span>
<span class="hljs-comment">       * Invoker passes a request to a receiver indirectly, by executing a command.</span>
<span class="hljs-comment">       */</span>
    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">DoSomethingImportant</span><span class="hljs-params">()</span> </span>{
        std::cout &lt;&lt; <span class="hljs-string">"Invoker: Does anybody want something done before I begin?\n"</span>;
        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>-&gt;on_start_) {
            <span class="hljs-keyword">this</span>-&gt;on_start_-&gt;<span class="hljs-built_in">Execute</span>();
        }
        std::cout &lt;&lt; <span class="hljs-string">"Invoker: ...doing something really important...\n"</span>;
        std::cout &lt;&lt; <span class="hljs-string">"Invoker: Does anybody want something done after I finish?\n"</span>;
        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>-&gt;on_finish_) {
            <span class="hljs-keyword">this</span>-&gt;on_finish_-&gt;<span class="hljs-built_in">Execute</span>();
        }
    }
};
<span class="hljs-comment">/**</span>
<span class="hljs-comment"> * The client code can parameterize an invoker with any commands.</span>
<span class="hljs-comment"> */</span>

<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>{
    Invoker *invoker = <span class="hljs-keyword">new</span> Invoker;
    invoker-&gt;<span class="hljs-built_in">SetOnStart</span>(<span class="hljs-keyword">new</span> <span class="hljs-built_in">SimpleCommand</span>(<span class="hljs-string">"Say Hi!"</span>));
    Receiver *receiver = <span class="hljs-keyword">new</span> Receiver;
    invoker-&gt;<span class="hljs-built_in">SetOnFinish</span>(<span class="hljs-keyword">new</span> <span class="hljs-built_in">ComplexCommand</span>(receiver, <span class="hljs-string">"Send email"</span>, <span class="hljs-string">"Save report"</span>));
    invoker-&gt;<span class="hljs-built_in">DoSomethingImportant</span>();

    <span class="hljs-keyword">delete</span> invoker;
    <span class="hljs-keyword">delete</span> receiver;

    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
}</code></pre></div>

<h1><span id="die-dai-qi-mo-shi">è¿­ä»£å™¨æ¨¡å¼</span><a href="#die-dai-qi-mo-shi" class="header-anchor">#</a></h1><p><strong>è¿­ä»£å™¨æ¨¡å¼</strong>æ˜¯ä¸€ç§è¡Œä¸ºè®¾è®¡æ¨¡å¼ï¼Œ è®©ä½ èƒ½åœ¨ä¸æš´éœ²é›†åˆåº•å±‚è¡¨ç°å½¢å¼ ï¼ˆåˆ—è¡¨ã€ æ ˆå’Œæ ‘ç­‰ï¼‰ çš„æƒ…å†µä¸‹éå†é›†åˆä¸­æ‰€æœ‰çš„å…ƒç´ ã€‚</p>
<p>é€‚åˆåº”ç”¨åœºæ™¯:</p>
<ul>
<li><p><strong>å½“é›†åˆèƒŒåä¸ºå¤æ‚çš„æ•°æ®ç»“æ„ï¼Œ ä¸”ä½ å¸Œæœ›å¯¹å®¢æˆ·ç«¯éšè—å…¶å¤æ‚æ€§æ—¶ ï¼ˆå‡ºäºä½¿ç”¨ä¾¿åˆ©æ€§æˆ–å®‰å…¨æ€§çš„è€ƒè™‘ï¼‰ï¼Œ å¯ä»¥ä½¿ç”¨è¿­ä»£å™¨æ¨¡å¼ã€‚</strong></p>
</li>
<li><p>è¿­ä»£å™¨å°è£…äº†ä¸å¤æ‚æ•°æ®ç»“æ„è¿›è¡Œäº¤äº’çš„ç»†èŠ‚ï¼Œ ä¸ºå®¢æˆ·ç«¯æä¾›å¤šä¸ªè®¿é—®é›†åˆå…ƒç´ çš„ç®€å•æ–¹æ³•ã€‚ è¿™ç§æ–¹å¼ä¸ä»…å¯¹å®¢æˆ·ç«¯æ¥è¯´éå¸¸æ–¹ä¾¿ï¼Œ è€Œä¸”èƒ½é¿å…å®¢æˆ·ç«¯åœ¨ç›´æ¥ä¸é›†åˆäº¤äº’æ—¶æ‰§è¡Œé”™è¯¯æˆ–æœ‰å®³çš„æ“ä½œï¼Œ ä»è€Œèµ·åˆ°ä¿æŠ¤é›†åˆçš„ä½œç”¨ã€‚</p>
</li>
<li><p><strong>ä½¿ç”¨è¯¥æ¨¡å¼å¯ä»¥å‡å°‘ç¨‹åºä¸­é‡å¤çš„éå†ä»£ç ã€‚</strong></p>
</li>
<li><p>é‡è¦è¿­ä»£ç®—æ³•çš„ä»£ç å¾€å¾€ä½“ç§¯éå¸¸åºå¤§ã€‚ å½“è¿™äº›ä»£ç è¢«æ”¾ç½®åœ¨ç¨‹åºä¸šåŠ¡é€»è¾‘ä¸­æ—¶ï¼Œ å®ƒä¼šè®©åŸå§‹ä»£ç çš„èŒè´£æ¨¡ç³Šä¸æ¸…ï¼Œ é™ä½å…¶å¯ç»´æŠ¤æ€§ã€‚ å› æ­¤ï¼Œ å°†éå†ä»£ç ç§»åˆ°ç‰¹å®šçš„è¿­ä»£å™¨ä¸­å¯ä½¿ç¨‹åºä»£ç æ›´åŠ ç²¾ç‚¼å’Œç®€æ´ã€‚</p>
</li>
<li><p><strong>å¦‚æœä½ å¸Œæœ›ä»£ç èƒ½å¤Ÿéå†ä¸åŒçš„ç”šè‡³æ˜¯æ— æ³•é¢„çŸ¥çš„æ•°æ®ç»“æ„ï¼Œ å¯ä»¥ä½¿ç”¨è¿­ä»£å™¨æ¨¡å¼ã€‚</strong></p>
</li>
<li><p>è¯¥æ¨¡å¼ä¸ºé›†åˆå’Œè¿­ä»£å™¨æä¾›äº†ä¸€äº›é€šç”¨æ¥å£ã€‚ å¦‚æœä½ åœ¨ä»£ç ä¸­ä½¿ç”¨äº†è¿™äº›æ¥å£ï¼Œ é‚£ä¹ˆå°†å…¶ä»–å®ç°äº†è¿™äº›æ¥å£çš„é›†åˆå’Œè¿­ä»£å™¨ä¼ é€’ç»™å®ƒæ—¶ï¼Œ å®ƒä»å°†å¯ä»¥æ­£å¸¸è¿è¡Œã€‚</p>
</li>
</ul>
<div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-comment">/**</span>
<span class="hljs-comment"> * Iterator Design Pattern</span>
<span class="hljs-comment"> *</span>
<span class="hljs-comment"> * Intent: Lets you traverse elements of a collection without exposing its</span>
<span class="hljs-comment"> * underlying representation (list, stack, tree, etc.).</span>
<span class="hljs-comment"> */</span>

<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span>

<span class="hljs-comment">/**</span>
<span class="hljs-comment"> * C++ has its own implementation of iterator that works with a different</span>
<span class="hljs-comment"> * generics containers defined by the standard library.</span>
<span class="hljs-comment"> */</span>

<span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T, <span class="hljs-keyword">typename</span> U&gt;
<span class="hljs-keyword">class</span> <span class="hljs-title class_">Iterator</span> {
<span class="hljs-keyword">public</span>:
    <span class="hljs-keyword">typedef</span> <span class="hljs-keyword">typename</span> std::vector&lt;T&gt;::iterator iter_type;
    <span class="hljs-built_in">Iterator</span>(U *p_data, <span class="hljs-type">bool</span> reverse = <span class="hljs-literal">false</span>) : <span class="hljs-built_in">m_p_data_</span>(p_data) {
        m_it_ = m_p_data_-&gt;m_data_.<span class="hljs-built_in">begin</span>();
    }

    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">First</span><span class="hljs-params">()</span> </span>{
        m_it_ = m_p_data_-&gt;m_data_.<span class="hljs-built_in">begin</span>();
    }

    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Next</span><span class="hljs-params">()</span> </span>{
        m_it_++;
    }

    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">IsDone</span><span class="hljs-params">()</span> </span>{
        <span class="hljs-keyword">return</span> (m_it_ == m_p_data_-&gt;m_data_.<span class="hljs-built_in">end</span>());
    }

    <span class="hljs-function">iter_type <span class="hljs-title">Current</span><span class="hljs-params">()</span> </span>{
        <span class="hljs-keyword">return</span> m_it_;
    }

<span class="hljs-keyword">private</span>:
    U *m_p_data_;
    iter_type m_it_;
};

<span class="hljs-comment">/**</span>
<span class="hljs-comment"> * Generic Collections/Containers provides one or several methods for retrieving</span>
<span class="hljs-comment"> * fresh iterator instances, compatible with the collection class.</span>
<span class="hljs-comment"> */</span>

<span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">T</span>&gt;
<span class="hljs-keyword">class</span> <span class="hljs-title class_">Container</span> {
  	<span class="hljs-keyword">friend</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Iterator</span>&lt;T, Container&gt;;

<span class="hljs-keyword">public</span>:
    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Add</span><span class="hljs-params">(T a)</span> </span>{
        m_data_.<span class="hljs-built_in">push_back</span>(a);
    }

    <span class="hljs-function">Iterator&lt;T, Container&gt; *<span class="hljs-title">CreateIterator</span><span class="hljs-params">()</span> </span>{
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Iterator</span>&lt;T, Container&gt;(<span class="hljs-keyword">this</span>);
    }

<span class="hljs-keyword">private</span>:
  	std::vector&lt;T&gt; m_data_;
};

<span class="hljs-keyword">class</span> <span class="hljs-title class_">Data</span> {
<span class="hljs-keyword">public</span>:
    <span class="hljs-built_in">Data</span>(<span class="hljs-type">int</span> a = <span class="hljs-number">0</span>) : <span class="hljs-built_in">m_data_</span>(a) {}

    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">set_data</span><span class="hljs-params">(<span class="hljs-type">int</span> a)</span> </span>{
        m_data_ = a;
    }

    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">data</span><span class="hljs-params">()</span> </span>{
        <span class="hljs-keyword">return</span> m_data_;
    }

<span class="hljs-keyword">private</span>:
  	<span class="hljs-type">int</span> m_data_;
};

<span class="hljs-comment">/**</span>
<span class="hljs-comment"> * The client code may or may not know about the Concrete Iterator or Collection</span>
<span class="hljs-comment"> * classes, for this implementation the container is generic so you can used</span>
<span class="hljs-comment"> * with an int or with a custom class.</span>
<span class="hljs-comment"> */</span>
<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">ClientCode</span><span class="hljs-params">()</span> </span>{
    std::cout &lt;&lt; <span class="hljs-string">"________________Iterator with int______________________________________"</span> &lt;&lt; std::endl;
    Container&lt;<span class="hljs-type">int</span>&gt; cont;

    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++) {
        cont.<span class="hljs-built_in">Add</span>(i);
    }

    Iterator&lt;<span class="hljs-type">int</span>, Container&lt;<span class="hljs-type">int</span>&gt;&gt; *it = cont.<span class="hljs-built_in">CreateIterator</span>();
    <span class="hljs-keyword">for</span> (it-&gt;<span class="hljs-built_in">First</span>(); !it-&gt;<span class="hljs-built_in">IsDone</span>(); it-&gt;<span class="hljs-built_in">Next</span>()) {
        std::cout &lt;&lt; *it-&gt;<span class="hljs-built_in">Current</span>() &lt;&lt; std::endl;
    }

    Container&lt;Data&gt; cont2;
    <span class="hljs-function">Data <span class="hljs-title">a</span><span class="hljs-params">(<span class="hljs-number">100</span>)</span>, <span class="hljs-title">b</span><span class="hljs-params">(<span class="hljs-number">1000</span>)</span>, <span class="hljs-title">c</span><span class="hljs-params">(<span class="hljs-number">10000</span>)</span></span>;
    cont2.<span class="hljs-built_in">Add</span>(a);
    cont2.<span class="hljs-built_in">Add</span>(b);
    cont2.<span class="hljs-built_in">Add</span>(c);

    std::cout &lt;&lt; <span class="hljs-string">"________________Iterator with custom Class______________________________"</span> &lt;&lt; std::endl;
    Iterator&lt;Data, Container&lt;Data&gt;&gt; *it2 = cont2.<span class="hljs-built_in">CreateIterator</span>();
    <span class="hljs-keyword">for</span> (it2-&gt;<span class="hljs-built_in">First</span>(); !it2-&gt;<span class="hljs-built_in">IsDone</span>(); it2-&gt;<span class="hljs-built_in">Next</span>()) {
        std::cout &lt;&lt; it2-&gt;<span class="hljs-built_in">Current</span>()-&gt;<span class="hljs-built_in">data</span>() &lt;&lt; std::endl;
    }
    <span class="hljs-keyword">delete</span> it;
    <span class="hljs-keyword">delete</span> it2;
}

<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>{
    <span class="hljs-built_in">ClientCode</span>();
    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
}</code></pre></div>

<h1><span id="zhong-jie-zhe-mo-shi">ä¸­ä»‹è€…æ¨¡å¼</span><a href="#zhong-jie-zhe-mo-shi" class="header-anchor">#</a></h1><p><strong>ä¸­ä»‹è€…æ¨¡å¼</strong>æ˜¯ä¸€ç§è¡Œä¸ºè®¾è®¡æ¨¡å¼ï¼Œ èƒ½è®©ä½ å‡å°‘å¯¹è±¡ä¹‹é—´æ··ä¹±æ— åºçš„ä¾èµ–å…³ç³»ã€‚ è¯¥æ¨¡å¼ä¼šé™åˆ¶å¯¹è±¡ä¹‹é—´çš„ç›´æ¥äº¤äº’ï¼Œ è¿«ä½¿å®ƒä»¬é€šè¿‡ä¸€ä¸ªä¸­ä»‹è€…å¯¹è±¡è¿›è¡Œåˆä½œã€‚</p>
<p>é€‚åˆåº”ç”¨åœºæ™¯:</p>
<ul>
<li><p><strong>å½“ä¸€äº›å¯¹è±¡å’Œå…¶ä»–å¯¹è±¡ç´§å¯†è€¦åˆä»¥è‡´éš¾ä»¥å¯¹å…¶è¿›è¡Œä¿®æ”¹æ—¶ï¼Œ å¯ä½¿ç”¨ä¸­ä»‹è€…æ¨¡å¼ã€‚</strong></p>
</li>
<li><p>è¯¥æ¨¡å¼è®©ä½ å°†å¯¹è±¡é—´çš„æ‰€æœ‰å…³ç³»æŠ½å–æˆä¸ºä¸€ä¸ªå•ç‹¬çš„ç±»ï¼Œ ä»¥ä½¿å¯¹äºç‰¹å®šç»„ä»¶çš„ä¿®æ”¹å·¥ä½œç‹¬ç«‹äºå…¶ä»–ç»„ä»¶ã€‚</p>
</li>
<li><p><strong>å½“ç»„ä»¶å› è¿‡äºä¾èµ–å…¶ä»–ç»„ä»¶è€Œæ— æ³•åœ¨ä¸åŒåº”ç”¨ä¸­å¤ç”¨æ—¶ï¼Œ å¯ä½¿ç”¨ä¸­ä»‹è€…æ¨¡å¼ã€‚</strong></p>
</li>
<li><p>åº”ç”¨ä¸­ä»‹è€…æ¨¡å¼åï¼Œ æ¯ä¸ªç»„ä»¶ä¸å†çŸ¥æ™“å…¶ä»–ç»„ä»¶çš„æƒ…å†µã€‚ å°½ç®¡è¿™äº›ç»„ä»¶æ— æ³•ç›´æ¥äº¤æµï¼Œ ä½†å®ƒä»¬ä»å¯é€šè¿‡ä¸­ä»‹è€…å¯¹è±¡è¿›è¡Œé—´æ¥äº¤æµã€‚ å¦‚æœä½ å¸Œæœ›åœ¨ä¸åŒåº”ç”¨ä¸­å¤ç”¨ä¸€ä¸ªç»„ä»¶ï¼Œ åˆ™éœ€è¦ä¸ºå…¶æä¾›ä¸€ä¸ªæ–°çš„ä¸­ä»‹è€…ç±»ã€‚</p>
</li>
<li><p><strong>å¦‚æœä¸ºäº†èƒ½åœ¨ä¸åŒæƒ…æ™¯ä¸‹å¤ç”¨ä¸€äº›åŸºæœ¬è¡Œä¸ºï¼Œ å¯¼è‡´ä½ éœ€è¦è¢«è¿«åˆ›å»ºå¤§é‡ç»„ä»¶å­ç±»æ—¶ï¼Œ å¯ä½¿ç”¨ä¸­ä»‹è€…æ¨¡å¼ã€‚</strong></p>
</li>
<li><p>ç”±äºæ‰€æœ‰ç»„ä»¶é—´å…³ç³»éƒ½è¢«åŒ…å«åœ¨ä¸­ä»‹è€…ä¸­ï¼Œ å› æ­¤ä½ æ— éœ€ä¿®æ”¹ç»„ä»¶å°±èƒ½æ–¹ä¾¿åœ°æ–°å»ºä¸­ä»‹è€…ç±»ä»¥å®šä¹‰æ–°çš„ç»„ä»¶åˆä½œæ–¹å¼ã€‚</p>
</li>
</ul>
<div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span>
<span class="hljs-comment">/**</span>
<span class="hljs-comment"> * The Mediator interface declares a method used by components to notify the</span>
<span class="hljs-comment"> * mediator about various events. The Mediator may react to these events and</span>
<span class="hljs-comment"> * pass the execution to other components.</span>
<span class="hljs-comment"> */</span>
<span class="hljs-keyword">class</span> <span class="hljs-title class_">BaseComponent</span>;
<span class="hljs-keyword">class</span> <span class="hljs-title class_">Mediator</span> {
<span class="hljs-keyword">public</span>:
  	<span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">Notify</span><span class="hljs-params">(BaseComponent *sender, std::string event)</span> <span class="hljs-type">const</span> </span>= <span class="hljs-number">0</span>;
};

<span class="hljs-comment">/**</span>
<span class="hljs-comment"> * The Base Component provides the basic functionality of storing a mediator's</span>
<span class="hljs-comment"> * instance inside component objects.</span>
<span class="hljs-comment"> */</span>
<span class="hljs-keyword">class</span> <span class="hljs-title class_">BaseComponent</span> {
<span class="hljs-keyword">protected</span>:
  	Mediator *mediator_;

<span class="hljs-keyword">public</span>:
    <span class="hljs-built_in">BaseComponent</span>(Mediator *mediator = <span class="hljs-literal">nullptr</span>) : <span class="hljs-built_in">mediator_</span>(mediator) {
    }
    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">set_mediator</span><span class="hljs-params">(Mediator *mediator)</span> </span>{
        <span class="hljs-keyword">this</span>-&gt;mediator_ = mediator;
    }
};

<span class="hljs-comment">/**</span>
<span class="hljs-comment"> * Concrete Components implement various functionality. They don't depend on</span>
<span class="hljs-comment"> * other components. They also don't depend on any concrete mediator classes.</span>
<span class="hljs-comment"> */</span>
<span class="hljs-keyword">class</span> <span class="hljs-title class_">Component1</span> : <span class="hljs-keyword">public</span> BaseComponent {
<span class="hljs-keyword">public</span>:
    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">DoA</span><span class="hljs-params">()</span> </span>{
        std::cout &lt;&lt; <span class="hljs-string">"Component 1 does A.\n"</span>;
        <span class="hljs-keyword">this</span>-&gt;mediator_-&gt;<span class="hljs-built_in">Notify</span>(<span class="hljs-keyword">this</span>, <span class="hljs-string">"A"</span>);
    }
    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">DoB</span><span class="hljs-params">()</span> </span>{
        std::cout &lt;&lt; <span class="hljs-string">"Component 1 does B.\n"</span>;
        <span class="hljs-keyword">this</span>-&gt;mediator_-&gt;<span class="hljs-built_in">Notify</span>(<span class="hljs-keyword">this</span>, <span class="hljs-string">"B"</span>);
    }
};

<span class="hljs-keyword">class</span> <span class="hljs-title class_">Component2</span> : <span class="hljs-keyword">public</span> BaseComponent {
<span class="hljs-keyword">public</span>:
    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">DoC</span><span class="hljs-params">()</span> </span>{
        std::cout &lt;&lt; <span class="hljs-string">"Component 2 does C.\n"</span>;
        <span class="hljs-keyword">this</span>-&gt;mediator_-&gt;<span class="hljs-built_in">Notify</span>(<span class="hljs-keyword">this</span>, <span class="hljs-string">"C"</span>);
    }
    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">DoD</span><span class="hljs-params">()</span> </span>{
        std::cout &lt;&lt; <span class="hljs-string">"Component 2 does D.\n"</span>;
        <span class="hljs-keyword">this</span>-&gt;mediator_-&gt;<span class="hljs-built_in">Notify</span>(<span class="hljs-keyword">this</span>, <span class="hljs-string">"D"</span>);
    }
};

<span class="hljs-comment">/**</span>
<span class="hljs-comment"> * Concrete Mediators implement cooperative behavior by coordinating several</span>
<span class="hljs-comment"> * components.</span>
<span class="hljs-comment"> */</span>
<span class="hljs-keyword">class</span> <span class="hljs-title class_">ConcreteMediator</span> : <span class="hljs-keyword">public</span> Mediator {
<span class="hljs-keyword">private</span>:
    Component1 *component1_;
    Component2 *component2_;

<span class="hljs-keyword">public</span>:
    <span class="hljs-built_in">ConcreteMediator</span>(Component1 *c1, Component2 *c2) : <span class="hljs-built_in">component1_</span>(c1), <span class="hljs-built_in">component2_</span>(c2) {
        <span class="hljs-keyword">this</span>-&gt;component1_-&gt;<span class="hljs-built_in">set_mediator</span>(<span class="hljs-keyword">this</span>);
        <span class="hljs-keyword">this</span>-&gt;component2_-&gt;<span class="hljs-built_in">set_mediator</span>(<span class="hljs-keyword">this</span>);
    }
    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Notify</span><span class="hljs-params">(BaseComponent *sender, std::string event)</span> <span class="hljs-type">const</span> <span class="hljs-keyword">override</span> </span>{
        <span class="hljs-keyword">if</span> (event == <span class="hljs-string">"A"</span>) {
            std::cout &lt;&lt; <span class="hljs-string">"Mediator reacts on A and triggers following operations:\n"</span>;
            <span class="hljs-keyword">this</span>-&gt;component2_-&gt;<span class="hljs-built_in">DoC</span>();
        }
        <span class="hljs-keyword">if</span> (event == <span class="hljs-string">"D"</span>) {
            std::cout &lt;&lt; <span class="hljs-string">"Mediator reacts on D and triggers following operations:\n"</span>;
            <span class="hljs-keyword">this</span>-&gt;component1_-&gt;<span class="hljs-built_in">DoB</span>();
            <span class="hljs-keyword">this</span>-&gt;component2_-&gt;<span class="hljs-built_in">DoC</span>();
        }
    }
};

<span class="hljs-comment">/**</span>
<span class="hljs-comment"> * The client code.</span>
<span class="hljs-comment"> */</span>

<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">ClientCode</span><span class="hljs-params">()</span> </span>{
    Component1 *c1 = <span class="hljs-keyword">new</span> Component1;
    Component2 *c2 = <span class="hljs-keyword">new</span> Component2;
    ConcreteMediator *mediator = <span class="hljs-keyword">new</span> <span class="hljs-built_in">ConcreteMediator</span>(c1, c2);
    std::cout &lt;&lt; <span class="hljs-string">"Client triggers operation A.\n"</span>;
    c1-&gt;<span class="hljs-built_in">DoA</span>();
    std::cout &lt;&lt; <span class="hljs-string">"\n"</span>;
    std::cout &lt;&lt; <span class="hljs-string">"Client triggers operation D.\n"</span>;
    c2-&gt;<span class="hljs-built_in">DoD</span>();

    <span class="hljs-keyword">delete</span> c1;
    <span class="hljs-keyword">delete</span> c2;
    <span class="hljs-keyword">delete</span> mediator;
}

<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>{
    <span class="hljs-built_in">ClientCode</span>();
    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
}</code></pre></div>

<h1><span id="bei-wang-lu-mo-shi">å¤‡å¿˜å½•æ¨¡å¼</span><a href="#bei-wang-lu-mo-shi" class="header-anchor">#</a></h1><p><strong>å¤‡å¿˜å½•æ¨¡å¼</strong>æ˜¯ä¸€ç§è¡Œä¸ºè®¾è®¡æ¨¡å¼ï¼Œ å…è®¸åœ¨ä¸æš´éœ²å¯¹è±¡å®ç°ç»†èŠ‚çš„æƒ…å†µä¸‹ä¿å­˜å’Œæ¢å¤å¯¹è±¡ä¹‹å‰çš„çŠ¶æ€ã€‚</p>
<p>é€‚åˆåº”ç”¨åœºæ™¯ï¼š</p>
<ul>
<li><p><strong>å½“ä½ éœ€è¦åˆ›å»ºå¯¹è±¡çŠ¶æ€å¿«ç…§æ¥æ¢å¤å…¶ä¹‹å‰çš„çŠ¶æ€æ—¶ï¼Œ å¯ä»¥ä½¿ç”¨å¤‡å¿˜å½•æ¨¡å¼ã€‚</strong></p>
</li>
<li><p>å¤‡å¿˜å½•æ¨¡å¼å…è®¸ä½ å¤åˆ¶å¯¹è±¡ä¸­çš„å…¨éƒ¨çŠ¶æ€ ï¼ˆåŒ…æ‹¬ç§æœ‰æˆå‘˜å˜é‡ï¼‰ï¼Œ å¹¶å°†å…¶ç‹¬ç«‹äºå¯¹è±¡è¿›è¡Œä¿å­˜ã€‚ å°½ç®¡å¤§éƒ¨åˆ†äººå› ä¸º â€œæ’¤é”€â€ è¿™ä¸ªç”¨ä¾‹æ‰è®°å¾—è¯¥æ¨¡å¼ï¼Œ ä½†å…¶å®å®ƒåœ¨å¤„ç†äº‹åŠ¡ ï¼ˆæ¯”å¦‚éœ€è¦åœ¨å‡ºç°é”™è¯¯æ—¶å›æ»šä¸€ä¸ªæ“ä½œï¼‰ çš„è¿‡ç¨‹ä¸­ä¹Ÿå¿…ä¸å¯å°‘ã€‚</p>
</li>
<li><p><strong>å½“ç›´æ¥è®¿é—®å¯¹è±¡çš„æˆå‘˜å˜é‡ã€ è·å–å™¨æˆ–è®¾ç½®å™¨å°†å¯¼è‡´å°è£…è¢«çªç ´æ—¶ï¼Œ å¯ä»¥ä½¿ç”¨è¯¥æ¨¡å¼ã€‚</strong></p>
</li>
<li><p>å¤‡å¿˜å½•è®©å¯¹è±¡è‡ªè¡Œè´Ÿè´£åˆ›å»ºå…¶çŠ¶æ€çš„å¿«ç…§ã€‚ ä»»ä½•å…¶ä»–å¯¹è±¡éƒ½ä¸èƒ½è¯»å–å¿«ç…§ï¼Œ è¿™æœ‰æ•ˆåœ°ä¿éšœäº†æ•°æ®çš„å®‰å…¨æ€§ã€‚</p>
</li>
</ul>
<div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-comment">/**</span>
<span class="hljs-comment"> * The Memento interface provides a way to retrieve the memento's metadata, such</span>
<span class="hljs-comment"> * as creation date or name. However, it doesn't expose the Originator's state.</span>
<span class="hljs-comment"> */</span>
<span class="hljs-keyword">class</span> <span class="hljs-title class_">Memento</span> {
<span class="hljs-keyword">public</span>:
    <span class="hljs-function"><span class="hljs-keyword">virtual</span> std::string <span class="hljs-title">GetName</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>= <span class="hljs-number">0</span>;
    <span class="hljs-function"><span class="hljs-keyword">virtual</span> std::string <span class="hljs-title">date</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>= <span class="hljs-number">0</span>;
    <span class="hljs-function"><span class="hljs-keyword">virtual</span> std::string <span class="hljs-title">state</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>= <span class="hljs-number">0</span>;
};

<span class="hljs-comment">/**</span>
<span class="hljs-comment"> * The Concrete Memento contains the infrastructure for storing the Originator's</span>
<span class="hljs-comment"> * state.</span>
<span class="hljs-comment"> */</span>
<span class="hljs-keyword">class</span> <span class="hljs-title class_">ConcreteMemento</span> : <span class="hljs-keyword">public</span> Memento {
<span class="hljs-keyword">private</span>:
    std::string state_;
    std::string date_;

<span class="hljs-keyword">public</span>:
    <span class="hljs-built_in">ConcreteMemento</span>(std::string state) : <span class="hljs-built_in">state_</span>(state) {
        <span class="hljs-keyword">this</span>-&gt;state_ = state;
        std::<span class="hljs-type">time_t</span> now = std::<span class="hljs-built_in">time</span>(<span class="hljs-number">0</span>);
        <span class="hljs-keyword">this</span>-&gt;date_ = std::<span class="hljs-built_in">ctime</span>(&amp;now);
    }
    <span class="hljs-comment">/**</span>
<span class="hljs-comment">       * The Originator uses this method when restoring its state.</span>
<span class="hljs-comment">       */</span>
    <span class="hljs-function">std::string <span class="hljs-title">state</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> <span class="hljs-keyword">override</span> </span>{
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>-&gt;state_;
    }
    <span class="hljs-comment">/**</span>
<span class="hljs-comment">       * The rest of the methods are used by the Caretaker to display metadata.</span>
<span class="hljs-comment">       */</span>
    <span class="hljs-function">std::string <span class="hljs-title">GetName</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> <span class="hljs-keyword">override</span> </span>{
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>-&gt;date_ + <span class="hljs-string">" / ("</span> + <span class="hljs-keyword">this</span>-&gt;state_.<span class="hljs-built_in">substr</span>(<span class="hljs-number">0</span>, <span class="hljs-number">9</span>) + <span class="hljs-string">"...)"</span>;
    }
    <span class="hljs-function">std::string <span class="hljs-title">date</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> <span class="hljs-keyword">override</span> </span>{
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>-&gt;date_;
    }
};

<span class="hljs-comment">/**</span>
<span class="hljs-comment"> * The Originator holds some important state that may change over time. It also</span>
<span class="hljs-comment"> * defines a method for saving the state inside a memento and another method for</span>
<span class="hljs-comment"> * restoring the state from it.</span>
<span class="hljs-comment"> */</span>
<span class="hljs-keyword">class</span> <span class="hljs-title class_">Originator</span> {
  <span class="hljs-comment">/**</span>
<span class="hljs-comment">   * @var string For the sake of simplicity, the originator's state is stored</span>
<span class="hljs-comment">   * inside a single variable.</span>
<span class="hljs-comment">   */</span>
<span class="hljs-keyword">private</span>:
    std::string state_;

    <span class="hljs-function">std::string <span class="hljs-title">GenerateRandomString</span><span class="hljs-params">(<span class="hljs-type">int</span> length = <span class="hljs-number">10</span>)</span> </span>{
        <span class="hljs-type">const</span> <span class="hljs-type">char</span> alphanum[] =
            <span class="hljs-string">"0123456789"</span>
            <span class="hljs-string">"ABCDEFGHIJKLMNOPQRSTUVWXYZ"</span>
            <span class="hljs-string">"abcdefghijklmnopqrstuvwxyz"</span>;
        <span class="hljs-type">int</span> stringLength = <span class="hljs-built_in">sizeof</span>(alphanum) - <span class="hljs-number">1</span>;

        std::string random_string;
        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; length; i++) {
            random_string += alphanum[std::<span class="hljs-built_in">rand</span>() % stringLength];
        }
        <span class="hljs-keyword">return</span> random_string;
    }

<span class="hljs-keyword">public</span>:
    <span class="hljs-built_in">Originator</span>(std::string state) : <span class="hljs-built_in">state_</span>(state) {
        std::cout &lt;&lt; <span class="hljs-string">"Originator: My initial state is: "</span> &lt;&lt; <span class="hljs-keyword">this</span>-&gt;state_ &lt;&lt; <span class="hljs-string">"\n"</span>;
    }
    <span class="hljs-comment">/**</span>
<span class="hljs-comment">       * The Originator's business logic may affect its internal state. Therefore,</span>
<span class="hljs-comment">       * the client should backup the state before launching methods of the business</span>
<span class="hljs-comment">       * logic via the save() method.</span>
<span class="hljs-comment">       */</span>
    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">DoSomething</span><span class="hljs-params">()</span> </span>{
        std::cout &lt;&lt; <span class="hljs-string">"Originator: I'm doing something important.\n"</span>;
        <span class="hljs-keyword">this</span>-&gt;state_ = <span class="hljs-keyword">this</span>-&gt;<span class="hljs-built_in">GenerateRandomString</span>(<span class="hljs-number">30</span>);
        std::cout &lt;&lt; <span class="hljs-string">"Originator: and my state has changed to: "</span> &lt;&lt; <span class="hljs-keyword">this</span>-&gt;state_ &lt;&lt; <span class="hljs-string">"\n"</span>;
    }

    <span class="hljs-comment">/**</span>
<span class="hljs-comment">       * Saves the current state inside a memento.</span>
<span class="hljs-comment">       */</span>
    <span class="hljs-function">Memento *<span class="hljs-title">Save</span><span class="hljs-params">()</span> </span>{
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">ConcreteMemento</span>(<span class="hljs-keyword">this</span>-&gt;state_);
    }
    <span class="hljs-comment">/**</span>
<span class="hljs-comment">       * Restores the Originator's state from a memento object.</span>
<span class="hljs-comment">       */</span>
    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Restore</span><span class="hljs-params">(Memento *memento)</span> </span>{
        <span class="hljs-keyword">this</span>-&gt;state_ = memento-&gt;<span class="hljs-built_in">state</span>();
        std::cout &lt;&lt; <span class="hljs-string">"Originator: My state has changed to: "</span> &lt;&lt; <span class="hljs-keyword">this</span>-&gt;state_ &lt;&lt; <span class="hljs-string">"\n"</span>;
    }
};

<span class="hljs-comment">/**</span>
<span class="hljs-comment"> * The Caretaker doesn't depend on the Concrete Memento class. Therefore, it</span>
<span class="hljs-comment"> * doesn't have access to the originator's state, stored inside the memento. It</span>
<span class="hljs-comment"> * works with all mementos via the base Memento interface.</span>
<span class="hljs-comment"> */</span>
<span class="hljs-keyword">class</span> <span class="hljs-title class_">Caretaker</span> {
  <span class="hljs-comment">/**</span>
<span class="hljs-comment">   * @var Memento[]</span>
<span class="hljs-comment">   */</span>
<span class="hljs-keyword">private</span>:
    std::vector&lt;Memento *&gt; mementos_;

    <span class="hljs-comment">/**</span>
<span class="hljs-comment">       * @var Originator</span>
<span class="hljs-comment">       */</span>
    Originator *originator_;

<span class="hljs-keyword">public</span>:
    <span class="hljs-built_in">Caretaker</span>(Originator *originator) : <span class="hljs-built_in">originator_</span>(originator) {
        <span class="hljs-keyword">this</span>-&gt;originator_ = originator;
    }

    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Backup</span><span class="hljs-params">()</span> </span>{
        std::cout &lt;&lt; <span class="hljs-string">"\nCaretaker: Saving Originator's state...\n"</span>;
        <span class="hljs-keyword">this</span>-&gt;mementos_.<span class="hljs-built_in">push_back</span>(<span class="hljs-keyword">this</span>-&gt;originator_-&gt;<span class="hljs-built_in">Save</span>());
    }
    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Undo</span><span class="hljs-params">()</span> </span>{
        <span class="hljs-keyword">if</span> (!<span class="hljs-keyword">this</span>-&gt;mementos_.<span class="hljs-built_in">size</span>()) {
            <span class="hljs-keyword">return</span>;
        }
        Memento *memento = <span class="hljs-keyword">this</span>-&gt;mementos_.<span class="hljs-built_in">back</span>();
        <span class="hljs-keyword">this</span>-&gt;mementos_.<span class="hljs-built_in">pop_back</span>();
        std::cout &lt;&lt; <span class="hljs-string">"Caretaker: Restoring state to: "</span> &lt;&lt; memento-&gt;<span class="hljs-built_in">GetName</span>() &lt;&lt; <span class="hljs-string">"\n"</span>;
        <span class="hljs-keyword">try</span> {
            <span class="hljs-keyword">this</span>-&gt;originator_-&gt;<span class="hljs-built_in">Restore</span>(memento);
        } <span class="hljs-built_in">catch</span> (...) {
            <span class="hljs-keyword">this</span>-&gt;<span class="hljs-built_in">Undo</span>();
        }
    }
    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">ShowHistory</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>{
        std::cout &lt;&lt; <span class="hljs-string">"Caretaker: Here's the list of mementos:\n"</span>;
        <span class="hljs-keyword">for</span> (Memento *memento : <span class="hljs-keyword">this</span>-&gt;mementos_) {
            std::cout &lt;&lt; memento-&gt;<span class="hljs-built_in">GetName</span>() &lt;&lt; <span class="hljs-string">"\n"</span>;
        }
    }
};
<span class="hljs-comment">/**</span>
<span class="hljs-comment"> * Client code.</span>
<span class="hljs-comment"> */</span>

<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">ClientCode</span><span class="hljs-params">()</span> </span>{
    Originator *originator = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Originator</span>(<span class="hljs-string">"Super-duper-super-puper-super."</span>);
    Caretaker *caretaker = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Caretaker</span>(originator);
    caretaker-&gt;<span class="hljs-built_in">Backup</span>();
    originator-&gt;<span class="hljs-built_in">DoSomething</span>();
    caretaker-&gt;<span class="hljs-built_in">Backup</span>();
    originator-&gt;<span class="hljs-built_in">DoSomething</span>();
    caretaker-&gt;<span class="hljs-built_in">Backup</span>();
    originator-&gt;<span class="hljs-built_in">DoSomething</span>();
    std::cout &lt;&lt; <span class="hljs-string">"\n"</span>;
    caretaker-&gt;<span class="hljs-built_in">ShowHistory</span>();
    std::cout &lt;&lt; <span class="hljs-string">"\nClient: Now, let's rollback!\n\n"</span>;
    caretaker-&gt;<span class="hljs-built_in">Undo</span>();
    std::cout &lt;&lt; <span class="hljs-string">"\nClient: Once more!\n\n"</span>;
    caretaker-&gt;<span class="hljs-built_in">Undo</span>();

    <span class="hljs-keyword">delete</span> originator;
    <span class="hljs-keyword">delete</span> caretaker;
}

<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>{
    std::<span class="hljs-built_in">srand</span>(<span class="hljs-built_in">static_cast</span>&lt;<span class="hljs-type">unsigned</span> <span class="hljs-type">int</span>&gt;(std::<span class="hljs-built_in">time</span>(<span class="hljs-literal">NULL</span>)));
    <span class="hljs-built_in">ClientCode</span>();
    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
}</code></pre></div>

<h1><span id="zhuang-tai-mo-shi">çŠ¶æ€æ¨¡å¼</span><a href="#zhuang-tai-mo-shi" class="header-anchor">#</a></h1><p><strong>çŠ¶æ€æ¨¡å¼</strong>æ˜¯ä¸€ç§è¡Œä¸ºè®¾è®¡æ¨¡å¼ï¼Œ è®©ä½ èƒ½åœ¨ä¸€ä¸ªå¯¹è±¡çš„å†…éƒ¨çŠ¶æ€å˜åŒ–æ—¶æ”¹å˜å…¶è¡Œä¸ºï¼Œ ä½¿å…¶çœ‹ä¸Šå»å°±åƒæ”¹å˜äº†è‡ªèº«æ‰€å±çš„ç±»ä¸€æ ·ã€‚</p>
<p>é€‚åˆåº”ç”¨åœºæ™¯:</p>
<ul>
<li><p><strong>å¦‚æœå¯¹è±¡éœ€è¦æ ¹æ®è‡ªèº«å½“å‰çŠ¶æ€è¿›è¡Œä¸åŒè¡Œä¸ºï¼Œ åŒæ—¶çŠ¶æ€çš„æ•°é‡éå¸¸å¤šä¸”ä¸çŠ¶æ€ç›¸å…³çš„ä»£ç ä¼šé¢‘ç¹å˜æ›´çš„è¯ï¼Œ å¯ä½¿ç”¨çŠ¶æ€æ¨¡å¼ã€‚</strong></p>
</li>
<li><p>æ¨¡å¼å»ºè®®ä½ å°†æ‰€æœ‰ç‰¹å®šäºçŠ¶æ€çš„ä»£ç æŠ½å–åˆ°ä¸€ç»„ç‹¬ç«‹çš„ç±»ä¸­ã€‚ è¿™æ ·ä¸€æ¥ï¼Œ ä½ å¯ä»¥åœ¨ç‹¬ç«‹äºå…¶ä»–çŠ¶æ€çš„æƒ…å†µä¸‹æ·»åŠ æ–°çŠ¶æ€æˆ–ä¿®æ”¹å·²æœ‰çŠ¶æ€ï¼Œ ä»è€Œå‡å°‘ç»´æŠ¤æˆæœ¬ã€‚</p>
</li>
<li><p><strong>å¦‚æœæŸä¸ªç±»éœ€è¦æ ¹æ®æˆå‘˜å˜é‡çš„å½“å‰å€¼æ”¹å˜è‡ªèº«è¡Œä¸ºï¼Œ ä»è€Œéœ€è¦ä½¿ç”¨å¤§é‡çš„æ¡ä»¶è¯­å¥æ—¶ï¼Œ å¯ä½¿ç”¨è¯¥æ¨¡å¼ã€‚</strong></p>
</li>
<li><p>çŠ¶æ€æ¨¡å¼ä¼šå°†è¿™äº›æ¡ä»¶è¯­å¥çš„åˆ†æ”¯æŠ½å–åˆ°ç›¸åº”çŠ¶æ€ç±»çš„æ–¹æ³•ä¸­ã€‚ åŒæ—¶ï¼Œ ä½ è¿˜å¯ä»¥æ¸…é™¤ä¸»è¦ç±»ä¸­ä¸ç‰¹å®šçŠ¶æ€ç›¸å…³çš„ä¸´æ—¶æˆå‘˜å˜é‡å’Œå¸®æ‰‹æ–¹æ³•ä»£ç ã€‚</p>
</li>
<li><p><strong>å½“ç›¸ä¼¼çŠ¶æ€å’ŒåŸºäºæ¡ä»¶çš„çŠ¶æ€æœºè½¬æ¢ä¸­å­˜åœ¨è®¸å¤šé‡å¤ä»£ç æ—¶ï¼Œ å¯ä½¿ç”¨çŠ¶æ€æ¨¡å¼ã€‚</strong></p>
</li>
<li><p>çŠ¶æ€æ¨¡å¼è®©ä½ èƒ½å¤Ÿç”ŸæˆçŠ¶æ€ç±»å±‚æ¬¡ç»“æ„ï¼Œ é€šè¿‡å°†å…¬ç”¨ä»£ç æŠ½å–åˆ°æŠ½è±¡åŸºç±»ä¸­æ¥<code>å‡å°‘é‡å¤</code>ã€‚</p>
</li>
</ul>
<div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;typeinfo&gt;</span></span>
<span class="hljs-comment">/**</span>
<span class="hljs-comment"> * The base State class declares methods that all Concrete State should</span>
<span class="hljs-comment"> * implement and also provides a backreference to the Context object, associated</span>
<span class="hljs-comment"> * with the State. This backreference can be used by States to transition the</span>
<span class="hljs-comment"> * Context to another State.</span>
<span class="hljs-comment"> */</span>

<span class="hljs-keyword">class</span> <span class="hljs-title class_">Context</span>;

<span class="hljs-keyword">class</span> <span class="hljs-title class_">State</span> {
  <span class="hljs-comment">/**</span>
<span class="hljs-comment">   * @var Context</span>
<span class="hljs-comment">   */</span>
<span class="hljs-keyword">protected</span>:
  	Context *context_;

<span class="hljs-keyword">public</span>:
    <span class="hljs-keyword">virtual</span> ~<span class="hljs-built_in">State</span>() {
    }

    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">set_context</span><span class="hljs-params">(Context *context)</span> </span>{
        <span class="hljs-keyword">this</span>-&gt;context_ = context;
    }

    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">Handle1</span><span class="hljs-params">()</span> </span>= <span class="hljs-number">0</span>;
    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">Handle2</span><span class="hljs-params">()</span> </span>= <span class="hljs-number">0</span>;
};

<span class="hljs-comment">/**</span>
<span class="hljs-comment"> * The Context defines the interface of interest to clients. It also maintains a</span>
<span class="hljs-comment"> * reference to an instance of a State subclass, which represents the current</span>
<span class="hljs-comment"> * state of the Context.</span>
<span class="hljs-comment"> */</span>
<span class="hljs-keyword">class</span> <span class="hljs-title class_">Context</span> {
  <span class="hljs-comment">/**</span>
<span class="hljs-comment">   * @var State A reference to the current state of the Context.</span>
<span class="hljs-comment">   */</span>
<span class="hljs-keyword">private</span>:
  	State *state_;

<span class="hljs-keyword">public</span>:
    <span class="hljs-built_in">Context</span>(State *state) : <span class="hljs-built_in">state_</span>(<span class="hljs-literal">nullptr</span>) {
        <span class="hljs-keyword">this</span>-&gt;<span class="hljs-built_in">TransitionTo</span>(state);
    }
    ~<span class="hljs-built_in">Context</span>() {
        <span class="hljs-keyword">delete</span> state_;
    }
    <span class="hljs-comment">/**</span>
<span class="hljs-comment">       * The Context allows changing the State object at runtime.</span>
<span class="hljs-comment">       */</span>
    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">TransitionTo</span><span class="hljs-params">(State *state)</span> </span>{
        std::cout &lt;&lt; <span class="hljs-string">"Context: Transition to "</span> &lt;&lt; <span class="hljs-built_in">typeid</span>(*state).<span class="hljs-built_in">name</span>() &lt;&lt; <span class="hljs-string">".\n"</span>;
        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>-&gt;state_ != <span class="hljs-literal">nullptr</span>)
            <span class="hljs-keyword">delete</span> <span class="hljs-keyword">this</span>-&gt;state_;
        <span class="hljs-keyword">this</span>-&gt;state_ = state;
        <span class="hljs-keyword">this</span>-&gt;state_-&gt;<span class="hljs-built_in">set_context</span>(<span class="hljs-keyword">this</span>);
    }
    <span class="hljs-comment">/**</span>
<span class="hljs-comment">       * The Context delegates part of its behavior to the current State object.</span>
<span class="hljs-comment">       */</span>
    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Request1</span><span class="hljs-params">()</span> </span>{
        <span class="hljs-keyword">this</span>-&gt;state_-&gt;<span class="hljs-built_in">Handle1</span>();
    }
    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Request2</span><span class="hljs-params">()</span> </span>{
        <span class="hljs-keyword">this</span>-&gt;state_-&gt;<span class="hljs-built_in">Handle2</span>();
    }
};

<span class="hljs-comment">/**</span>
<span class="hljs-comment"> * Concrete States implement various behaviors, associated with a state of the</span>
<span class="hljs-comment"> * Context.</span>
<span class="hljs-comment"> */</span>

<span class="hljs-keyword">class</span> <span class="hljs-title class_">ConcreteStateA</span> : <span class="hljs-keyword">public</span> State {
<span class="hljs-keyword">public</span>:
    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Handle1</span><span class="hljs-params">()</span> <span class="hljs-keyword">override</span></span>;

    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Handle2</span><span class="hljs-params">()</span> <span class="hljs-keyword">override</span> </span>{
        std::cout &lt;&lt; <span class="hljs-string">"ConcreteStateA handles request2.\n"</span>;
    }
};

<span class="hljs-keyword">class</span> <span class="hljs-title class_">ConcreteStateB</span> : <span class="hljs-keyword">public</span> State {
<span class="hljs-keyword">public</span>:
    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Handle1</span><span class="hljs-params">()</span> <span class="hljs-keyword">override</span> </span>{
        std::cout &lt;&lt; <span class="hljs-string">"ConcreteStateB handles request1.\n"</span>;
    }
    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Handle2</span><span class="hljs-params">()</span> <span class="hljs-keyword">override</span> </span>{
        std::cout &lt;&lt; <span class="hljs-string">"ConcreteStateB handles request2.\n"</span>;
        std::cout &lt;&lt; <span class="hljs-string">"ConcreteStateB wants to change the state of the context.\n"</span>;
        <span class="hljs-keyword">this</span>-&gt;context_-&gt;<span class="hljs-built_in">TransitionTo</span>(<span class="hljs-keyword">new</span> ConcreteStateA);
    }
};

<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">ConcreteStateA::Handle1</span><span class="hljs-params">()</span> </span>{
    std::cout &lt;&lt; <span class="hljs-string">"ConcreteStateA handles request1.\n"</span>;
    std::cout &lt;&lt; <span class="hljs-string">"ConcreteStateA wants to change the state of the context.\n"</span>;

    <span class="hljs-keyword">this</span>-&gt;context_-&gt;<span class="hljs-built_in">TransitionTo</span>(<span class="hljs-keyword">new</span> ConcreteStateB);
}

<span class="hljs-comment">/**</span>
<span class="hljs-comment"> * The client code.</span>
<span class="hljs-comment"> */</span>
<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">ClientCode</span><span class="hljs-params">()</span> </span>{
    Context *context = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Context</span>(<span class="hljs-keyword">new</span> ConcreteStateA);
    context-&gt;<span class="hljs-built_in">Request1</span>();
    context-&gt;<span class="hljs-built_in">Request2</span>();
    <span class="hljs-keyword">delete</span> context;
}

<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>{
    <span class="hljs-built_in">ClientCode</span>();
    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
}</code></pre></div>

<h1><span id="ce-lue-mo-shi">ç­–ç•¥æ¨¡å¼</span><a href="#ce-lue-mo-shi" class="header-anchor">#</a></h1><p><strong>ç­–ç•¥æ¨¡å¼</strong>æ˜¯ä¸€ç§è¡Œä¸ºè®¾è®¡æ¨¡å¼ï¼Œ å®ƒèƒ½è®©ä½ å®šä¹‰ä¸€ç³»åˆ—ç®—æ³•ï¼Œ å¹¶å°†æ¯ç§ç®—æ³•åˆ†åˆ«æ”¾å…¥ç‹¬ç«‹çš„ç±»ä¸­ï¼Œ ä»¥ä½¿ç®—æ³•çš„å¯¹è±¡èƒ½å¤Ÿç›¸äº’æ›¿æ¢ã€‚</p>
<p>é€‚åˆåº”ç”¨åœºæ™¯:</p>
<ul>
<li><p><strong>å½“ä½ æƒ³ä½¿ç”¨å¯¹è±¡ä¸­å„ç§ä¸åŒçš„ç®—æ³•å˜ä½“ï¼Œ å¹¶å¸Œæœ›èƒ½åœ¨è¿è¡Œæ—¶åˆ‡æ¢ç®—æ³•æ—¶ï¼Œ å¯ä½¿ç”¨ç­–ç•¥æ¨¡å¼ã€‚</strong></p>
</li>
<li><p>ç­–ç•¥æ¨¡å¼è®©ä½ èƒ½å¤Ÿå°†å¯¹è±¡å…³è”è‡³å¯ä»¥ä¸åŒæ–¹å¼æ‰§è¡Œç‰¹å®šå­ä»»åŠ¡çš„ä¸åŒå­å¯¹è±¡ï¼Œ ä»è€Œä»¥é—´æ¥æ–¹å¼åœ¨è¿è¡Œæ—¶æ›´æ”¹å¯¹è±¡è¡Œä¸ºã€‚</p>
</li>
<li><p><strong>å½“ä½ æœ‰è®¸å¤šä»…åœ¨æ‰§è¡ŒæŸäº›è¡Œä¸ºæ—¶ç•¥æœ‰ä¸åŒçš„ç›¸ä¼¼ç±»æ—¶ï¼Œ å¯ä½¿ç”¨ç­–ç•¥æ¨¡å¼ã€‚</strong></p>
</li>
<li><p>ç­–ç•¥æ¨¡å¼è®©ä½ èƒ½å°†ä¸åŒè¡Œä¸ºæŠ½å–åˆ°ä¸€ä¸ªç‹¬ç«‹ç±»å±‚æ¬¡ç»“æ„ä¸­ï¼Œ å¹¶å°†åŸå§‹ç±»ç»„åˆæˆåŒä¸€ä¸ªï¼Œ ä»è€Œå‡å°‘é‡å¤ä»£ç ã€‚</p>
</li>
<li><p><strong>å¦‚æœç®—æ³•åœ¨ä¸Šä¸‹æ–‡çš„é€»è¾‘ä¸­ä¸æ˜¯ç‰¹åˆ«é‡è¦ï¼Œ ä½¿ç”¨è¯¥æ¨¡å¼èƒ½å°†ç±»çš„ä¸šåŠ¡é€»è¾‘ä¸å…¶ç®—æ³•å®ç°ç»†èŠ‚éš”ç¦»å¼€æ¥ã€‚</strong></p>
</li>
<li><p>ç­–ç•¥æ¨¡å¼è®©ä½ èƒ½å°†å„ç§ç®—æ³•çš„ä»£ç ã€ å†…éƒ¨æ•°æ®å’Œä¾èµ–å…³ç³»ä¸å…¶ä»–ä»£ç éš”ç¦»å¼€æ¥ã€‚ ä¸åŒå®¢æˆ·ç«¯å¯é€šè¿‡ä¸€ä¸ªç®€å•æ¥å£æ‰§è¡Œç®—æ³•ï¼Œ å¹¶èƒ½åœ¨è¿è¡Œæ—¶è¿›è¡Œåˆ‡æ¢ã€‚</p>
</li>
<li><p><strong>å½“ç±»ä¸­ä½¿ç”¨äº†å¤æ‚æ¡ä»¶è¿ç®—ç¬¦ä»¥åœ¨åŒä¸€ç®—æ³•çš„ä¸åŒå˜ä½“ä¸­åˆ‡æ¢æ—¶ï¼Œ å¯ä½¿ç”¨è¯¥æ¨¡å¼ã€‚</strong></p>
</li>
<li><p>ç­–ç•¥æ¨¡å¼å°†æ‰€æœ‰ç»§æ‰¿è‡ªåŒæ ·æ¥å£çš„ç®—æ³•æŠ½å–åˆ°ç‹¬ç«‹ç±»ä¸­ï¼Œ å› æ­¤ä¸å†éœ€è¦æ¡ä»¶è¯­å¥ã€‚ åŸå§‹å¯¹è±¡å¹¶ä¸å®ç°æ‰€æœ‰ç®—æ³•çš„å˜ä½“ï¼Œ è€Œæ˜¯å°†æ‰§è¡Œå·¥ä½œå§”æ´¾ç»™å…¶ä¸­çš„ä¸€ä¸ªç‹¬ç«‹ç®—æ³•å¯¹è±¡ã€‚</p>
</li>
</ul>
<div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-comment">/**</span>
<span class="hljs-comment"> * The Strategy interface declares operations common to all supported versions</span>
<span class="hljs-comment"> * of some algorithm.</span>
<span class="hljs-comment"> *</span>
<span class="hljs-comment"> * The Context uses this interface to call the algorithm defined by Concrete</span>
<span class="hljs-comment"> * Strategies.</span>
<span class="hljs-comment"> */</span>
<span class="hljs-keyword">class</span> <span class="hljs-title class_">Strategy</span>
{
<span class="hljs-keyword">public</span>:
    <span class="hljs-keyword">virtual</span> ~<span class="hljs-built_in">Strategy</span>() {}
    <span class="hljs-function"><span class="hljs-keyword">virtual</span> std::string <span class="hljs-title">DoAlgorithm</span><span class="hljs-params">(<span class="hljs-type">const</span> std::vector&lt;std::string&gt; &amp;data)</span> <span class="hljs-type">const</span> </span>= <span class="hljs-number">0</span>;
};

<span class="hljs-comment">/**</span>
<span class="hljs-comment"> * The Context defines the interface of interest to clients.</span>
<span class="hljs-comment"> */</span>

<span class="hljs-keyword">class</span> <span class="hljs-title class_">Context</span>
{
    <span class="hljs-comment">/**</span>
<span class="hljs-comment">     * @var Strategy The Context maintains a reference to one of the Strategy</span>
<span class="hljs-comment">     * objects. The Context does not know the concrete class of a strategy. It</span>
<span class="hljs-comment">     * should work with all strategies via the Strategy interface.</span>
<span class="hljs-comment">     */</span>
<span class="hljs-keyword">private</span>:
    Strategy *strategy_;
    <span class="hljs-comment">/**</span>
<span class="hljs-comment">     * Usually, the Context accepts a strategy through the constructor, but also</span>
<span class="hljs-comment">     * provides a setter to change it at runtime.</span>
<span class="hljs-comment">     */</span>
<span class="hljs-keyword">public</span>:
    <span class="hljs-built_in">Context</span>(Strategy *strategy = <span class="hljs-literal">nullptr</span>) : <span class="hljs-built_in">strategy_</span>(strategy)
    {
    }
    ~<span class="hljs-built_in">Context</span>()
    {
        <span class="hljs-keyword">delete</span> <span class="hljs-keyword">this</span>-&gt;strategy_;
    }
    <span class="hljs-comment">/**</span>
<span class="hljs-comment">     * Usually, the Context allows replacing a Strategy object at runtime.</span>
<span class="hljs-comment">     */</span>
    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">set_strategy</span><span class="hljs-params">(Strategy *strategy)</span></span>
<span class="hljs-function">    </span>{
        <span class="hljs-keyword">delete</span> <span class="hljs-keyword">this</span>-&gt;strategy_;
        <span class="hljs-keyword">this</span>-&gt;strategy_ = strategy;
    }
    <span class="hljs-comment">/**</span>
<span class="hljs-comment">     * The Context delegates some work to the Strategy object instead of</span>
<span class="hljs-comment">     * implementing +multiple versions of the algorithm on its own.</span>
<span class="hljs-comment">     */</span>
    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">DoSomeBusinessLogic</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span>
<span class="hljs-function">    </span>{
        <span class="hljs-comment">// ...</span>
        std::cout &lt;&lt; <span class="hljs-string">"Context: Sorting data using the strategy (not sure how it'll do it)\n"</span>;
        std::string result = <span class="hljs-keyword">this</span>-&gt;strategy_-&gt;<span class="hljs-built_in">DoAlgorithm</span>(std::vector&lt;std::string&gt;{<span class="hljs-string">"a"</span>, <span class="hljs-string">"e"</span>, <span class="hljs-string">"c"</span>, <span class="hljs-string">"b"</span>, <span class="hljs-string">"d"</span>});
        std::cout &lt;&lt; result &lt;&lt; <span class="hljs-string">"\n"</span>;
        <span class="hljs-comment">// ...</span>
    }
};

<span class="hljs-comment">/**</span>
<span class="hljs-comment"> * Concrete Strategies implement the algorithm while following the base Strategy</span>
<span class="hljs-comment"> * interface. The interface makes them interchangeable in the Context.</span>
<span class="hljs-comment"> */</span>
<span class="hljs-keyword">class</span> <span class="hljs-title class_">ConcreteStrategyA</span> : <span class="hljs-keyword">public</span> Strategy
{
<span class="hljs-keyword">public</span>:
    <span class="hljs-function">std::string <span class="hljs-title">DoAlgorithm</span><span class="hljs-params">(<span class="hljs-type">const</span> std::vector&lt;std::string&gt; &amp;data)</span> <span class="hljs-type">const</span> <span class="hljs-keyword">override</span></span>
<span class="hljs-function">    </span>{
        std::string result;
        std::for_each(std::<span class="hljs-built_in">begin</span>(data), std::<span class="hljs-built_in">end</span>(data), [&amp;result](<span class="hljs-type">const</span> std::string &amp;letter) {
            result += letter;
        });
        std::<span class="hljs-built_in">sort</span>(std::<span class="hljs-built_in">begin</span>(result), std::<span class="hljs-built_in">end</span>(result));

        <span class="hljs-keyword">return</span> result;
    }
};
<span class="hljs-keyword">class</span> <span class="hljs-title class_">ConcreteStrategyB</span> : <span class="hljs-keyword">public</span> Strategy
{
    <span class="hljs-function">std::string <span class="hljs-title">DoAlgorithm</span><span class="hljs-params">(<span class="hljs-type">const</span> std::vector&lt;std::string&gt; &amp;data)</span> <span class="hljs-type">const</span> <span class="hljs-keyword">override</span></span>
<span class="hljs-function">    </span>{
        std::string result;
        std::for_each(std::<span class="hljs-built_in">begin</span>(data), std::<span class="hljs-built_in">end</span>(data), [&amp;result](<span class="hljs-type">const</span> std::string &amp;letter) {
            result += letter;
        });
        std::<span class="hljs-built_in">sort</span>(std::<span class="hljs-built_in">begin</span>(result), std::<span class="hljs-built_in">end</span>(result));
        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; result.<span class="hljs-built_in">size</span>() / <span class="hljs-number">2</span>; i++)
        {
            std::<span class="hljs-built_in">swap</span>(result[i], result[result.<span class="hljs-built_in">size</span>() - i - <span class="hljs-number">1</span>]);
        }

        <span class="hljs-keyword">return</span> result;
    }
};
<span class="hljs-comment">/**</span>
<span class="hljs-comment"> * The client code picks a concrete strategy and passes it to the context. The</span>
<span class="hljs-comment"> * client should be aware of the differences between strategies in order to make</span>
<span class="hljs-comment"> * the right choice.</span>
<span class="hljs-comment"> */</span>

<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">ClientCode</span><span class="hljs-params">()</span></span>
<span class="hljs-function"></span>{
    Context *context = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Context</span>(<span class="hljs-keyword">new</span> ConcreteStrategyA);
    std::cout &lt;&lt; <span class="hljs-string">"Client: Strategy is set to normal sorting.\n"</span>;
    context-&gt;<span class="hljs-built_in">DoSomeBusinessLogic</span>();
    std::cout &lt;&lt; <span class="hljs-string">"\n"</span>;
    std::cout &lt;&lt; <span class="hljs-string">"Client: Strategy is set to reverse sorting.\n"</span>;
    context-&gt;<span class="hljs-built_in">set_strategy</span>(<span class="hljs-keyword">new</span> ConcreteStrategyB);
    context-&gt;<span class="hljs-built_in">DoSomeBusinessLogic</span>();
    <span class="hljs-keyword">delete</span> context;
}

<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>
<span class="hljs-function"></span>{
    <span class="hljs-built_in">ClientCode</span>();
    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
}</code></pre></div>

<h1><span id="mo-ban-fang-fa-mo-shi">æ¨¡æ¿æ–¹æ³•æ¨¡å¼</span><a href="#mo-ban-fang-fa-mo-shi" class="header-anchor">#</a></h1><p><strong>æ¨¡æ¿æ–¹æ³•æ¨¡å¼</strong>æ˜¯ä¸€ç§è¡Œä¸ºè®¾è®¡æ¨¡å¼ï¼Œ å®ƒåœ¨è¶…ç±»ä¸­å®šä¹‰äº†ä¸€ä¸ªç®—æ³•çš„æ¡†æ¶ï¼Œ å…è®¸å­ç±»åœ¨ä¸ä¿®æ”¹ç»“æ„çš„æƒ…å†µä¸‹é‡å†™ç®—æ³•çš„ç‰¹å®šæ­¥éª¤ã€‚</p>
<p>é€‚åˆåº”ç”¨åœºæ™¯:</p>
<ul>
<li><p><strong>å½“ä½ åªå¸Œæœ›å®¢æˆ·ç«¯æ‰©å±•æŸä¸ªç‰¹å®šç®—æ³•æ­¥éª¤ï¼Œ è€Œä¸æ˜¯æ•´ä¸ªç®—æ³•æˆ–å…¶ç»“æ„æ—¶ï¼Œ å¯ä½¿ç”¨æ¨¡æ¿æ–¹æ³•æ¨¡å¼ã€‚</strong></p>
</li>
<li><p>æ¨¡æ¿æ–¹æ³•å°†æ•´ä¸ªç®—æ³•è½¬æ¢ä¸ºä¸€ç³»åˆ—ç‹¬ç«‹çš„æ­¥éª¤ï¼Œ ä»¥ä¾¿å­ç±»èƒ½å¯¹å…¶è¿›è¡Œæ‰©å±•ï¼Œ åŒæ—¶è¿˜å¯è®©è¶…ç±»ä¸­æ‰€å®šä¹‰çš„ç»“æ„ä¿æŒå®Œæ•´ã€‚</p>
</li>
<li><p><strong>å½“å¤šä¸ªç±»çš„ç®—æ³•é™¤ä¸€äº›ç»†å¾®ä¸åŒä¹‹å¤–å‡ ä¹å®Œå…¨ä¸€æ ·æ—¶ï¼Œ ä½ å¯ä½¿ç”¨è¯¥æ¨¡å¼ã€‚ ä½†å…¶åæœå°±æ˜¯ï¼Œ åªè¦ç®—æ³•å‘ç”Ÿå˜åŒ–ï¼Œ ä½ å°±å¯èƒ½éœ€è¦ä¿®æ”¹æ‰€æœ‰çš„ç±»ã€‚</strong></p>
</li>
<li><p>åœ¨å°†ç®—æ³•è½¬æ¢ä¸ºæ¨¡æ¿æ–¹æ³•æ—¶ï¼Œ ä½ å¯å°†ç›¸ä¼¼çš„å®ç°æ­¥éª¤æå–åˆ°è¶…ç±»ä¸­ä»¥å»é™¤é‡å¤ä»£ç ã€‚ å­ç±»é—´å„ä¸åŒçš„ä»£ç å¯ç»§ç»­ä¿ç•™åœ¨å­ç±»ä¸­ã€‚</p>
</li>
</ul>
<div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-comment">/**</span>
<span class="hljs-comment"> * The Abstract Class defines a template method that contains a skeleton of some</span>
<span class="hljs-comment"> * algorithm, composed of calls to (usually) abstract primitive operations.</span>
<span class="hljs-comment"> *</span>
<span class="hljs-comment"> * Concrete subclasses should implement these operations, but leave the template</span>
<span class="hljs-comment"> * method itself intact.</span>
<span class="hljs-comment"> */</span>
<span class="hljs-keyword">class</span> <span class="hljs-title class_">AbstractClass</span> {
  <span class="hljs-comment">/**</span>
<span class="hljs-comment">   * The template method defines the skeleton of an algorithm.</span>
<span class="hljs-comment">   */</span>
<span class="hljs-keyword">public</span>:
    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">TemplateMethod</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>{
        <span class="hljs-keyword">this</span>-&gt;<span class="hljs-built_in">BaseOperation1</span>();
        <span class="hljs-keyword">this</span>-&gt;<span class="hljs-built_in">RequiredOperations1</span>();
        <span class="hljs-keyword">this</span>-&gt;<span class="hljs-built_in">BaseOperation2</span>();
        <span class="hljs-keyword">this</span>-&gt;<span class="hljs-built_in">Hook1</span>();
        <span class="hljs-keyword">this</span>-&gt;<span class="hljs-built_in">RequiredOperation2</span>();
        <span class="hljs-keyword">this</span>-&gt;<span class="hljs-built_in">BaseOperation3</span>();
        <span class="hljs-keyword">this</span>-&gt;<span class="hljs-built_in">Hook2</span>();
    }
  <span class="hljs-comment">/**</span>
<span class="hljs-comment">   * These operations already have implementations.</span>
<span class="hljs-comment">   */</span>
<span class="hljs-keyword">protected</span>:
    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">BaseOperation1</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>{
        std::cout &lt;&lt; <span class="hljs-string">"AbstractClass says: I am doing the bulk of the work\n"</span>;
    }
    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">BaseOperation2</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>{
        std::cout &lt;&lt; <span class="hljs-string">"AbstractClass says: But I let subclasses override some operations\n"</span>;
    }
    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">BaseOperation3</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>{
        std::cout &lt;&lt; <span class="hljs-string">"AbstractClass says: But I am doing the bulk of the work anyway\n"</span>;
    }
    <span class="hljs-comment">/**</span>
<span class="hljs-comment">       * These operations have to be implemented in subclasses.</span>
<span class="hljs-comment">       */</span>
    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">RequiredOperations1</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>= <span class="hljs-number">0</span>;
    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">RequiredOperation2</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>= <span class="hljs-number">0</span>;
    <span class="hljs-comment">/**</span>
<span class="hljs-comment">       * These are "hooks." Subclasses may override them, but it's not mandatory</span>
<span class="hljs-comment">       * since the hooks already have default (but empty) implementation. Hooks</span>
<span class="hljs-comment">       * provide additional extension points in some crucial places of the</span>
<span class="hljs-comment">       * algorithm.</span>
<span class="hljs-comment">       */</span>
    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">Hook1</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>{}
    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">Hook2</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>{}
};
<span class="hljs-comment">/**</span>
<span class="hljs-comment"> * Concrete classes have to implement all abstract operations of the base class.</span>
<span class="hljs-comment"> * They can also override some operations with a default implementation.</span>
<span class="hljs-comment"> */</span>
<span class="hljs-keyword">class</span> <span class="hljs-title class_">ConcreteClass1</span> : <span class="hljs-keyword">public</span> AbstractClass {
<span class="hljs-keyword">protected</span>:
    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">RequiredOperations1</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> <span class="hljs-keyword">override</span> </span>{
        std::cout &lt;&lt; <span class="hljs-string">"ConcreteClass1 says: Implemented Operation1\n"</span>;
    }
    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">RequiredOperation2</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> <span class="hljs-keyword">override</span> </span>{
        std::cout &lt;&lt; <span class="hljs-string">"ConcreteClass1 says: Implemented Operation2\n"</span>;
    }
};
<span class="hljs-comment">/**</span>
<span class="hljs-comment"> * Usually, concrete classes override only a fraction of base class' operations.</span>
<span class="hljs-comment"> */</span>
<span class="hljs-keyword">class</span> <span class="hljs-title class_">ConcreteClass2</span> : <span class="hljs-keyword">public</span> AbstractClass {
<span class="hljs-keyword">protected</span>:
    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">RequiredOperations1</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> <span class="hljs-keyword">override</span> </span>{
        std::cout &lt;&lt; <span class="hljs-string">"ConcreteClass2 says: Implemented Operation1\n"</span>;
    }
    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">RequiredOperation2</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> <span class="hljs-keyword">override</span> </span>{
        std::cout &lt;&lt; <span class="hljs-string">"ConcreteClass2 says: Implemented Operation2\n"</span>;
    }
    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Hook1</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> <span class="hljs-keyword">override</span> </span>{
        std::cout &lt;&lt; <span class="hljs-string">"ConcreteClass2 says: Overridden Hook1\n"</span>;
    }
};
<span class="hljs-comment">/**</span>
<span class="hljs-comment"> * The client code calls the template method to execute the algorithm. Client</span>
<span class="hljs-comment"> * code does not have to know the concrete class of an object it works with, as</span>
<span class="hljs-comment"> * long as it works with objects through the interface of their base class.</span>
<span class="hljs-comment"> */</span>
<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">ClientCode</span><span class="hljs-params">(AbstractClass *class_)</span> </span>{
    <span class="hljs-comment">// ...</span>
    class_-&gt;<span class="hljs-built_in">TemplateMethod</span>();
    <span class="hljs-comment">// ...</span>
}

<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>{
    std::cout &lt;&lt; <span class="hljs-string">"Same client code can work with different subclasses:\n"</span>;
    ConcreteClass1 *concreteClass1 = <span class="hljs-keyword">new</span> ConcreteClass1;
    <span class="hljs-built_in">ClientCode</span>(concreteClass1);
    std::cout &lt;&lt; <span class="hljs-string">"\n"</span>;
    std::cout &lt;&lt; <span class="hljs-string">"Same client code can work with different subclasses:\n"</span>;
    ConcreteClass2 *concreteClass2 = <span class="hljs-keyword">new</span> ConcreteClass2;
    <span class="hljs-built_in">ClientCode</span>(concreteClass2);
    <span class="hljs-keyword">delete</span> concreteClass1;
    <span class="hljs-keyword">delete</span> concreteClass2;
    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
}</code></pre></div>


            </div>
            <hr>
            <div>
              <div class="post-metas mb-3">
                
                
                  <div class="post-meta">
                    <i class="iconfont icon-tags"></i>
                    
                      <a class="hover-with-bg" href="/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/">è®¾è®¡æ¨¡å¼</a>
                    
                  </div>
                
              </div>
              
                <p class="note note-warning">
                  
                    æœ¬åšå®¢æ‰€æœ‰æ–‡ç« é™¤ç‰¹åˆ«å£°æ˜å¤–ï¼Œå‡é‡‡ç”¨ <a target="_blank" href="https://creativecommons.org/licenses/by-sa/4.0/deed.zh" rel="nofollow noopener noopener">CC BY-SA 4.0 åè®®</a> ï¼Œè½¬è½½è¯·æ³¨æ˜å‡ºå¤„ï¼
                  
                </p>
              
              
                <div class="post-prevnext">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/2022/01/03/Cmake%E7%9A%84%E5%AE%89%E8%A3%85%E4%B8%8ECMakeLists-txt%E7%9A%84%E7%BC%96%E5%86%99/">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">Cmakeçš„å®‰è£…ä¸CMakeLists.txtçš„ç¼–å†™</span>
                        <span class="visible-mobile">ä¸Šä¸€ç¯‡</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2022/01/03/C-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E7%BB%93%E6%9E%84%E5%9E%8B%E6%A8%A1%E5%BC%8F/">
                        <span class="hidden-mobile">C++è®¾è®¡æ¨¡å¼-ç»“æ„å‹æ¨¡å¼</span>
                        <span class="visible-mobile">ä¸‹ä¸€ç¯‡</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
              <!-- Comments -->
              <article class="comments" id="comments" lazyload>
                
                  
                
                
  <div id="lv-container" data-id="city" data-uid="MTAyMC81NTMzMi8zMTc5OQ==">
    <script type="text/javascript">
      Fluid.utils.loadComments('#lv-container', function() {
        Fluid.utils.createScript('https://cdn-city.livere.com/js/embed.dist.js');
      });
    </script>
    <noscript>Please enable JavaScript to view the comments</noscript>
  </div>


              </article>
            
          </article>
        </div>
      </div>
    </div>
    
      <div class="d-none d-lg-block col-lg-2 toc-container" id="toc-ctn">
        <div id="toc">
  <p class="toc-header"><i class="iconfont icon-list"></i>&nbsp;ç›®å½•</p>
  <div class="toc-body" id="toc-body"></div>
</div>

      </div>
    
  </div>
</div>

<!-- Custom -->


    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">æœç´¢</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v"
                 for="local-search-input">å…³é”®è¯</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>
    

    
  </main>

  <footer class="text-center mt-5 py-3">
  <div class="footer-content">
     <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> 
  </div>
  

  

  
</footer>


  <!-- SCRIPTS -->
  
  <script  src="https://cdn.jsdelivr.net/npm/nprogress@0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/nprogress@0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js" ></script>
<script  src="https://cdn.jsdelivr.net/npm/bootstrap@4/dist/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>

<!-- Plugins -->


  <script  src="/js/local-search.js" ></script>



  
    <script  src="/js/img-lazyload.js" ></script>
  



  



  
    <script  src="https://cdn.jsdelivr.net/npm/tocbot@4/dist/tocbot.min.js" ></script>
  
  
    <script  src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3/dist/jquery.fancybox.min.js" ></script>
  
  
    <script  src="https://cdn.jsdelivr.net/npm/anchor-js@4/anchor.min.js" ></script>
  
  
    <script defer src="https://cdn.jsdelivr.net/npm/clipboard@2/dist/clipboard.min.js" ></script>
  






  <script  src="https://cdn.jsdelivr.net/npm/typed.js@2/lib/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var title = document.getElementById('subtitle').title;
      
        typing(title);
      
    })(window, document);
  </script>















<!-- ä¸»é¢˜çš„å¯åŠ¨é¡¹ ä¿æŒåœ¨æœ€åº•éƒ¨ -->
<script  src="/js/boot.js" ></script>


</body>
</html>
