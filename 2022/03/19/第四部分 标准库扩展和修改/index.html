

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=auto>



<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/logo.jpg">
  <link rel="icon" href="/img/logo.jpg">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
    <meta http-equiv="Content-Security-Policy" content="upgrade-insecure-requests">
  
  <meta name="theme-color" content="#6aa84f">
  <meta name="author" content="John Doe">
  <meta name="keywords" content="">
  
    <meta name="description" content="第四部分 标准库扩展和修改#这一部分介绍了用C++17对现有库组件的扩展和修改。 21类型特征扩展#关于类型特征（标准类型函数），C++17扩展了使用它们的一般能力，并且 引入了一些新的类型特征。 21.1 类型特征的Suffix _v#从C++17开始，你可以对所有产生数值的类型特征使用后缀_v（因为你可以对所有产生类型的类型特征使用后缀_t）。例如，对于任何类型的T，而不是 std::is_c">
<meta property="og:type" content="article">
<meta property="og:title" content="第四部分-标准库扩展和修改">
<meta property="og:url" content="https://txt1994.github.io/2022/03/19/%E7%AC%AC%E5%9B%9B%E9%83%A8%E5%88%86%20%E6%A0%87%E5%87%86%E5%BA%93%E6%89%A9%E5%B1%95%E5%92%8C%E4%BF%AE%E6%94%B9/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:description" content="第四部分 标准库扩展和修改#这一部分介绍了用C++17对现有库组件的扩展和修改。 21类型特征扩展#关于类型特征（标准类型函数），C++17扩展了使用它们的一般能力，并且 引入了一些新的类型特征。 21.1 类型特征的Suffix _v#从C++17开始，你可以对所有产生数值的类型特征使用后缀_v（因为你可以对所有产生类型的类型特征使用后缀_t）。例如，对于任何类型的T，而不是 std::is_c">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://gitee.com/txt1994/images/raw/master/img/Cpp17TheCompleteGuideChinese/Figure_25.1.png">
<meta property="article:published_time" content="2022-03-18T16:01:15.000Z">
<meta property="article:modified_time" content="2022-03-18T17:20:11.613Z">
<meta property="article:author" content="John Doe">
<meta property="article:tag" content="C++17">
<meta property="article:tag" content="STL">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="https://gitee.com/txt1994/images/raw/master/img/Cpp17TheCompleteGuideChinese/Figure_25.1.png">
  
  
  <title>第四部分-标准库扩展和修改 - Hexo</title>

  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4/dist/css/bootstrap.min.css" />


  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/github-markdown-css@4/github-markdown.min.css" />
  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/hint.css@2/hint.min.css" />

  
    
    
      
      <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@10/styles/github-gist.min.css" />
    
  

  
    <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3/dist/jquery.fancybox.min.css" />
  


<!-- 主题依赖的图标库，不要自行修改 -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_ba1fz6golrf.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_lbnruvf0jn.css">


<link  rel="stylesheet" href="/css/main.css" />

<!-- 自定义样式保持在最底部 -->

  
<link rel="stylesheet" href="/css/style.css">



  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    var CONFIG = {"hostname":"txt1994.github.io","root":"/","version":"1.8.14","typing":{"enable":true,"typeSpeed":70,"cursorChar":"_","loop":false},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"right","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"copy_btn":true,"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":false,"baidu":null,"google":null,"gtag":null,"tencent":{"sid":null,"cid":null},"woyaola":null,"cnzz":null,"leancloud":{"app_id":null,"app_key":null,"server_url":null,"path":"window.location.pathname","ignore_local":false}},"search_path":"/local-search.xml"};
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
<meta name="generator" content="Hexo 6.1.0">
<style>.github-emoji { position: relative; display: inline-block; width: 1.2em; min-height: 1.2em; overflow: hidden; vertical-align: top; color: transparent; }  .github-emoji > span { position: relative; z-index: 10; }  .github-emoji img, .github-emoji .fancybox { margin: 0 !important; padding: 0 !important; border: none !important; outline: none !important; text-decoration: none !important; user-select: none !important; cursor: auto !important; }  .github-emoji img { height: 1.2em !important; width: 1.2em !important; position: absolute !important; left: 50% !important; top: 50% !important; transform: translate(-50%, -50%) !important; user-select: none !important; cursor: auto !important; } .github-emoji-fallback { color: inherit; } .github-emoji-fallback img { opacity: 0 !important; }</style>
</head>


<body>
  <header style="height: 70vh;">
    <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/">
      <strong>txt1994s</strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/">
                <i class="iconfont icon-home-fill"></i>
                首页
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/">
                <i class="iconfont icon-archive-fill"></i>
                归档
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/">
                <i class="iconfont icon-tags-fill"></i>
                标签
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/">
                <i class="iconfont icon-user-fill"></i>
                关于
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/links/">
                <i class="iconfont icon-link-fill"></i>
                友联
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              &nbsp;<i class="iconfont icon-search"></i>&nbsp;
            </a>
          </li>
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">&nbsp;<i
                class="iconfont icon-dark" id="color-toggle-icon"></i>&nbsp;</a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

    <div class="banner" id="banner" parallax=true
         style="background: url('/img/default.png') no-repeat center center;
           background-size: cover;">
      <div class="full-bg-img">
        <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
          <div class="page-header text-center fade-in-up">
            <span class="h2" id="subtitle" title="第四部分-标准库扩展和修改">
              
            </span>

            
              <div class="mt-3">
  
  
    <span class="post-meta">
      <i class="iconfont icon-date-fill" aria-hidden="true"></i>
      <time datetime="2022-03-19 00:01" pubdate>
        2022年3月19日 凌晨
      </time>
    </span>
  
</div>

<div class="mt-1">
  
    <span class="post-meta mr-2">
      <i class="iconfont icon-chart"></i>
      44k 字
    </span>
  

  
    <span class="post-meta mr-2">
      <i class="iconfont icon-clock-fill"></i>
      
      
      369 分钟
    </span>
  

  
  
</div>

            
          </div>

          
        </div>
      </div>
    </div>
  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="d-none d-lg-block col-lg-2"></div>
    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div class="py-5" id="board">
          <article class="post-content mx-auto">
            <!-- SEO header -->
            <h1 style="display: none">第四部分-标准库扩展和修改</h1>
            
              <p class="note note-info">
                
                  本文最后更新于：2022年3月19日 凌晨
                
              </p>
            
            <div class="markdown-body">
              <h2><span id="di-si-bu-fen-biao-zhun-ku-kuo-zhan-he-xiu-gai">第四部分 标准库扩展和修改</span><a href="#di-si-bu-fen-biao-zhun-ku-kuo-zhan-he-xiu-gai" class="header-anchor">#</a></h2><p>这一部分介绍了用C++17对现有库组件的扩展和修改。</p>
<h3><span id="21-lei-xing-te-zheng-kuo-zhan">21类型特征扩展</span><a href="#21-lei-xing-te-zheng-kuo-zhan" class="header-anchor">#</a></h3><p>关于类型特征（标准类型函数），C++17扩展了使用它们的一般能力，并且 引入了一些新的类型特征。</p>
<h4><span id="21-1-lei-xing-te-zheng-de-suffix-v">21.1 类型特征的<code>Suffix _v</code></span><a href="#21-1-lei-xing-te-zheng-de-suffix-v" class="header-anchor">#</a></h4><p>从C++17开始，你可以对所有产生数值的类型特征使用后缀<code>_v</code>（因为你可以对所有产生类型的类型特征使用后缀<code>_t</code>）。例如，对于任何类型的T，而不是</p>
<div class="code-wrapper"><pre><code class="hljs c++">std::is_const&lt;T&gt;::value</code></pre></div>

<p>你现在可以写:</p>
<div class="code-wrapper"><pre><code class="hljs c++">std::is_const_v&lt;T&gt; <span class="hljs-comment">// since C++17</span></code></pre></div>

<p>这适用于所有类型特征。其方法是，为每个标准类型特征定义一个相应的 变量模板。比如说:</p>
<div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">namespace</span> std {
    <span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;
    <span class="hljs-keyword">constexpr</span> <span class="hljs-type">bool</span> is_const_v = is_const&lt;T&gt;::value;
}</code></pre></div>

<p>通常，这有助于制定布尔条件，你可以在运行时使用:</p>
<div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">if</span> (std::is_signed_v&lt;<span class="hljs-type">char</span>&gt;) {
    ...
}</code></pre></div>

<p>但由于类型特征是在编译时评估的，所以你可以在编译时使用编译时的结果，即compile-time if:</p>
<div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">if</span> <span class="hljs-title">constexpr</span> <span class="hljs-params">(std::is_signed_v&lt;<span class="hljs-type">char</span>&gt;)</span> </span>{
    ...
}</code></pre></div>

<p>或在实例化模板时:</p>
<div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-comment">// C&lt;T&gt;类的主要模板</span>
<span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T, <span class="hljs-type">bool</span> = std::is_pointer_v&lt;T&gt;&gt;
<span class="hljs-keyword">class</span> C {
    ...
};
<span class="hljs-comment">// 指针类型的部分特殊化。</span>
<span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;
<span class="hljs-keyword">class</span> <span class="hljs-title class_">C</span>&lt;T, <span class="hljs-literal">true</span>&gt; {
    ...
};</code></pre></div>

<p>在这里，以C类为例，它为指针类型提供了一个特殊的实现。<br>但是如果类型特征产生一个非布尔值，后缀_v也可以使用，比如std::extreme&lt;&gt;。它产生的是一个原始数组的维度大小:</p>
<div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-type">int</span> a[<span class="hljs-number">5</span>][<span class="hljs-number">7</span>];
std::cout &lt;&lt; std::extent_v&lt;<span class="hljs-keyword">decltype</span>(a)&gt; &lt;&lt; <span class="hljs-string">'\n'</span>; <span class="hljs-comment">// prints 5</span>
std::cout &lt;&lt; std::extent_v&lt;<span class="hljs-keyword">decltype</span>(a),<span class="hljs-number">1</span>&gt; &lt;&lt; <span class="hljs-string">'\n'</span>; <span class="hljs-comment">// prints 7</span></code></pre></div>

<h4><span id="21-2-xin-lei-xing-te-zheng">21.2 新类型特征</span><a href="#21-2-xin-lei-xing-te-zheng" class="header-anchor">#</a></h4><p>C++17 引入了几个新的类型特征。<br>此外， is_literal_type&lt;&gt; 和 result_of&lt;&gt; 自 C++17 起已弃用。<br>正在建设中的详细说明</p>
<h6><span id="is-aggregate-lt-gt">is_aggregate&lt;&gt;</span><a href="#is-aggregate-lt-gt" class="header-anchor">#</a></h6><p>std::is_aggregate<t> 评估 T 是否为聚合类型：</t></p>
<div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;
<span class="hljs-keyword">struct</span> <span class="hljs-title class_">D</span> : std::string, std::complex&lt;T&gt; {
    std::string data;
};
D&lt;<span class="hljs-type">float</span>&gt; s{{<span class="hljs-string">"hello"</span>}, {<span class="hljs-number">4.5</span>,<span class="hljs-number">6.7</span>}, <span class="hljs-string">"world"</span>}; <span class="hljs-comment">// OK since C++17</span>
std::cout &lt;&lt; std::is_aggregate&lt;<span class="hljs-keyword">decltype</span>(s)&gt;::value; <span class="hljs-comment">// outputs: 1 (true)</span></code></pre></div>

<h4><span id="21-3-std-bool-constant-lt-gt">21.3 std::bool_constant&lt; &gt;。</span><a href="#21-3-std-bool-constant-lt-gt" class="header-anchor">#</a></h4><p>如果特征产生布尔值，它们现在使用别名模板 bool_constant&lt;&gt;：</p>
<div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">namespace</span> std {
    <span class="hljs-keyword">template</span>&lt;<span class="hljs-type">bool</span> B&gt;
    <span class="hljs-keyword">using</span> bool_constant = integral_constant&lt;<span class="hljs-type">bool</span>, B&gt;; <span class="hljs-comment">// since C++17</span>
    <span class="hljs-keyword">using</span> true_type = bool_constant&lt;<span class="hljs-literal">true</span>&gt;;
    <span class="hljs-keyword">using</span> false_type = bool_constant&lt;<span class="hljs-literal">false</span>&gt;;
}</code></pre></div>

<table>
<thead>
<tr>
<th>特征</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>is_aggregate<t></t></td>
<td>是聚合类型</td>
</tr>
<tr>
<td>has_unique_object_representations<t></t></td>
<td>任何两个具有相同值的对象在内存中具有相同的表示</td>
</tr>
<tr>
<td>is_invocable&lt;T,Args…&gt;</td>
<td>可用作 Args 的可调用对象…</td>
</tr>
<tr>
<td>is_nothrow_invocable&lt;T,Args…&gt;</td>
<td>可用作 Args… 的可调用对象…无需抛出</td>
</tr>
<tr>
<td>is_invocable_r&lt;RT,T,Args…&gt;</td>
<td>可用作 Args 的可调用… 返回 RT</td>
</tr>
<tr>
<td>is_nothrow_invocable_r&lt;RT,T,Args…&gt;</td>
<td>可用作 Args 的可调用对象…返回 RT 而不抛出</td>
</tr>
<tr>
<td>invoke_result&lt;T,Args…&gt;</td>
<td>如果用作 Args 的可调用结果类型…</td>
</tr>
<tr>
<td>is_swappable<t></t></td>
<td>is_swappable<t> 可以为此类型调用 swap()</t></td>
</tr>
<tr>
<td>is_nothrow_swappable<t></t></td>
<td>可以为此类型调用 swap() 并且该操作不能抛出</td>
</tr>
<tr>
<td>is_swappable_with&lt;T,T2&gt;</td>
<td>可以为这两种具有特定值类别的类型调用 swap()</td>
</tr>
<tr>
<td>is_nothrow_swappable_with&lt;T,T2&gt;</td>
<td>可以为这两种具有特定值类别的类型调用 swap() 并且该操作不能抛出</td>
</tr>
<tr>
<td>conjunction&lt;B…&gt;</td>
<td>逻辑和布尔特征 B…</td>
</tr>
<tr>
<td>disjunction&lt;B… &gt;</td>
<td>逻辑或布尔特征 B…</td>
</tr>
<tr>
<td>negation<b></b></td>
<td>逻辑不用于布尔特征 B</td>
</tr>
</tbody></table>
<p>在C++17之前，std::true_type和std::false_type分别被直接定义为std::integral_constant&lt;bool,true&gt;和std::integral_constant&lt;bool,false&gt;的别名定义。<br>尽管如此，如果一个特定的属性适用，布尔特性通常继承自std::true_type，如果不适用则继承自std::false_type。比如说:</p>
<div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-comment">// 主模板：通常 T 不是 void 类型</span>
<span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;
<span class="hljs-keyword">struct</span> <span class="hljs-title class_">IsVoid</span> : std::false_type {
};
<span class="hljs-comment">// void 类型的特化:</span>
<span class="hljs-keyword">template</span>&lt;&gt;
<span class="hljs-keyword">struct</span> <span class="hljs-title class_">IsVoid</span>&lt;<span class="hljs-type">void</span>&gt; : std::true_type {
};</code></pre></div>

<p>但是现在你可以通过派生自bool_constant&lt;&gt;来定义你自己的类型特质，如果你能够把相应的编译时表达式表述为布尔条件的话。比如说:</p>
<div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;
<span class="hljs-keyword">struct</span> <span class="hljs-title class_">IsLargerThanInt</span>
    : <span class="hljs-function">std::bool_constant&lt;<span class="hljs-params">(<span class="hljs-keyword">sizeof</span>(T) &gt; <span class="hljs-keyword">sizeof</span>(<span class="hljs-type">int</span>))</span>&gt; </span>{
    }</code></pre></div>

<p>这样你就可以使用这样一个特性，根据一个类型是否大于int来进行编译:</p>
<div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;</span>
<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">foo</span><span class="hljs-params">(T x)</span></span>
<span class="hljs-function"></span>{
    <span class="hljs-function"><span class="hljs-keyword">if</span> <span class="hljs-title">constexpr</span><span class="hljs-params">(IsLargerThanInt&lt;T&gt;::value)</span> </span>{
        ...
    }
}</code></pre></div>

<p>通过添加后缀_v的相应变量模板作为内联变量:</p>
<div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;
<span class="hljs-keyword">inline</span> <span class="hljs-type">static</span> <span class="hljs-keyword">constexpr</span> <span class="hljs-keyword">auto</span> IsLargerThanInt_v = IsLargerThanInt&lt;T&gt;::value;</code></pre></div>

<p>你也可以缩短该特性的用法，如下所示:</p>
<div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;</span>
<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">foo</span><span class="hljs-params">(T x)</span></span>
<span class="hljs-function"></span>{
    <span class="hljs-function"><span class="hljs-keyword">if</span> <span class="hljs-title">constexpr</span><span class="hljs-params">(IsLargerThanInt_v&lt;T&gt;)</span> </span>{
        ...
    }
}</code></pre></div>

<p>作为另一个例子，我们可以定义一个特质，检查一个类型T的移动构造函数是否保证不抛出，大致如下:</p>
<div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;
<span class="hljs-keyword">struct</span> <span class="hljs-title class_">IsNothrowMoveConstructibleT</span>
    : std::bool_constant&lt;<span class="hljs-built_in">noexcept</span>(<span class="hljs-built_in">T</span>(std::<span class="hljs-built_in">declval</span>&lt;T&gt;()))&gt; {
    };</code></pre></div>

<h4><span id="21-4-std-void-t-lt-gt">21.4 std::void_t&lt; &gt;</span><a href="#21-4-std-void-t-lt-gt" class="header-anchor">#</a></h4><p>在C++17中，一个小小的，但令人难以置信的有用的定义类型特征的辅助工具被标准化了：std::void_t&lt;&gt;。<br>它被简单地定义如下：</p>
<div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">namespace</span> std {
    <span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span>...&gt; <span class="hljs-keyword">using</span> <span class="hljs-type">void_t</span> = <span class="hljs-type">void</span>;
}</code></pre></div>

<p>也就是说，它对任何模板参数的变量列表都会产生无效。这很有帮助，我们只想在参数列表中处理类型。<br>主要的应用是在定义新的类型特征时检查条件的能力。下面的例子演示了这个帮助器的应用：</p>
<div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;utility&gt;</span> <span class="hljs-comment">// 对于declval&lt;&gt;来说</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;type_traits&gt;</span> <span class="hljs-comment">// 为true_type，false_type，和void_t</span></span>
<span class="hljs-comment">// 主模板:</span>
<span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span>, <span class="hljs-keyword">typename</span> = std::<span class="hljs-type">void_t</span>&lt;&gt;&gt;
<span class="hljs-keyword">struct</span> HasVarious : std::false_type {
};

<span class="hljs-comment">// 部分专业（可能会被SFINAE所取代）:</span>
<span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;
<span class="hljs-keyword">struct</span> <span class="hljs-title class_">HasVarious</span>&lt;T, std::<span class="hljs-type">void_t</span>&lt;<span class="hljs-keyword">decltype</span>(std::<span class="hljs-built_in">declval</span>&lt;T&gt;().<span class="hljs-built_in">begin</span>()),
<span class="hljs-keyword">typename</span> T::difference_type,
<span class="hljs-keyword">typename</span> T::iterator&gt;&gt;
    : std::true_type {
    };</code></pre></div>

<p>在这里，我们定义了一个新的类型特质HasVariousT&lt;&gt;，它检查三件事。</p>
<ul>
<li><p>该类型是否有一个成员函数begin()？</p>
</li>
<li><p>该类型是否有一个类型成员 difference_type？</p>
</li>
<li><p>该类型是否有一个类型成员迭代器？<br>只有当所有相应的表达式都对一个类型T有效时，才会使用部分专业化。那么它就比主模板更具体，而且由于我们从std::true_type派生出来，对这个特征的值进行检查会得到true。</p>
<div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">if</span> <span class="hljs-title">constexpr</span> <span class="hljs-params">(HasVarious&lt;T&gt;::value)</span> </span>{
    ...
}</code></pre></div></li>
</ul>
<p>如果任何一个表达式的结果是无效的代码（即T没有begin()，或者没有类型成员difference_type，或者没有类型成员iterator），部分专业化就会被SFINAE’d掉，这意味着由于替换失败不是错误的规则，它被忽略。然后，只有主模板是可用的，它派生自std::false_type，所以对这个特质的值进行检查会产生false。<br>同样地，你可以使用std::void_t轻松地定义其他特质来检查一个或多个条件，其中一个成员或操作的存在/能力很重要。</p>
<h4><span id="21-5-hou-ji">21.5 后记</span><a href="#21-5-hou-ji" class="header-anchor">#</a></h4><p>标准类型性状的变量模板最早是由Stephan T. Lavavej在2014年提出的 <a target="_blank" rel="noopener" href="https://wg21.link/n3854%E3%80%82%E5%AE%83%E4%BB%AC%E6%9C%80%E7%BB%88%E8%A2%AB%E9%87%87%E7%BA%B3%E4%B8%BA%E5%9B%BE%E4%B9%A6%E9%A6%86%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86TS%E7%9A%84%E4%B8%80%E9%83%A8%E5%88%86">https://wg21.link/n3854。它们最终被采纳为图书馆基本原理TS的一部分</a> 的一部分，由Alisdair Meredith在<a target="_blank" rel="noopener" href="https://wg21.link/p0006r0%E3%80%82">https://wg21.link/p0006r0。</a></p>
<p>类型特质std::is_aggregate&lt;&gt;是作为美国国家机构的评论引入的，用于C++17的标准化。C++17的标准化而引入的（见<a target="_blank" rel="noopener" href="https://wg21.link/lwg2911%EF%BC%89%E3%80%82">https://wg21.link/lwg2911）。</a></p>
<p>std::bool_constant&lt;&gt;是由袁志豪在<a target="_blank" rel="noopener" href="https://wg21.link/n4334">https://wg21.link/n4334</a> 中首次提出的。它们最终被采纳为袁志豪在<a target="_blank" rel="noopener" href="https://wg21.link/n4389">https://wg21.link/n4389</a> 中的提议。</p>
<p>std::void_t_&lt;&gt;是由Walter E. Brown在<a target="_blank" rel="noopener" href="https://wg21.link/n3911">https://wg21.link/n3911</a> 中提出的，被采用。建设中</p>
<h3><span id="22-bing-xing-stl-suan-fa">22 并行STL算法</span><a href="#22-bing-xing-stl-suan-fa" class="header-anchor">#</a></h3><p>为了从现代多核架构中获益，C++17标准库引入了让STL标准算法使用多线程运行的能力，以并行处理不同的元素。</p>
<p>许多算法通过一个新的第一参数进行了扩展，以指定是否以及如何在并行线程中运行算法（当然，没有这个参数的老方法仍然被支持）。此外，还引入了一些专门支持并行处理的补充算法。</p>
<h6><span id="yi-ge-jian-dan-de-ji-shi-qi-zhu-shou">一个简单的计时器助手</span><a href="#yi-ge-jian-dan-de-ji-shi-qi-zhu-shou" class="header-anchor">#</a></h6><p>在本章的例子中，有时我们需要一个定时器来测量算法的速度。为此，我们使用了一个简单的辅助类，它初始化了一个定时器，并提供了printDiff()来打印消耗的毫秒数并重新初始化定时器:</p>
<p><code>lib/timer.hpp </code></p>
<div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">ifndef</span> TIMER_HPP</span>
<span class="hljs-meta">#<span class="hljs-keyword">define</span> TIMER_HPP</span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;chrono&gt;</span></span>
<span class="hljs-comment">/********************************************</span>
<span class="hljs-comment">* timer to print elapsed time</span>
<span class="hljs-comment">********************************************/</span>
<span class="hljs-keyword">class</span> <span class="hljs-title class_">Timer</span>
{
<span class="hljs-keyword">private</span>:
    std::chrono::steady_clock::time_point last;
<span class="hljs-keyword">public</span>:
    <span class="hljs-built_in">Timer</span>()
        : la st{std::chrono::steady_clock::<span class="hljs-built_in">now</span>()} {
        }
    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">printDiff</span><span class="hljs-params">(<span class="hljs-type">const</span> std::string&amp; msg = <span class="hljs-string">"Timer diff: "</span>)</span> </span>{
        <span class="hljs-keyword">auto</span> now{std::chrono::steady_clock::<span class="hljs-built_in">now</span>()};
        std::chrono::duration&lt;<span class="hljs-type">double</span>, std::milli&gt; diff{now - last};
        std::cout &lt;&lt; msg &lt;&lt; diff.<span class="hljs-built_in">count</span>() &lt;&lt; <span class="hljs-string">"ms\n"</span>;
        last = std::chrono::steady_clock::<span class="hljs-built_in">now</span>();
    }
};
<span class="hljs-meta">#<span class="hljs-keyword">endif</span> <span class="hljs-comment">// TIMER_HPP</span></span></code></pre></div>

<h4><span id="22-1-shi-yong-bing-xing-suan-fa">22.1 使用并行算法</span><a href="#22-1-shi-yong-bing-xing-suan-fa" class="header-anchor">#</a></h4><p>让我们从一些例子程序开始，展示让现有算法并行运行和使用新的并行算法的能力。</p>
<h5><span id="22-1-1-shi-yong-bing-xing-de-for-each">22.1.1 使用并行的for_each()</span><a href="#22-1-1-shi-yong-bing-xing-de-for-each" class="header-anchor">#</a></h5><p>这是并行运行标准算法 for_each() 的第一个非常简单的示例：</p>
<p><code>lib/parforeach.cpp </code></p>
<div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;numeric&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;execution&gt;</span> <span class="hljs-comment">// 对于执行策略</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">"timer.hpp"</span></span>
<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>
<span class="hljs-function"></span>{
    <span class="hljs-type">int</span> numElems = <span class="hljs-number">1000</span>;
    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">Data</span> {
        <span class="hljs-type">double</span> value; <span class="hljs-comment">// 初始值</span>
        <span class="hljs-type">double</span> sqrt; <span class="hljs-comment">// 并行计算平方根</span>
    };
    <span class="hljs-comment">// 初始化没有平方根的 NumElems 值:</span>
    std::vector&lt;Data&gt; coll;
    coll.<span class="hljs-built_in">reserve</span>(numElems);
    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>; i&lt;numElems; ++i) {
        coll.<span class="hljs-built_in">push_back</span>(Data{i * <span class="hljs-number">4.37</span>, <span class="hljs-number">0</span>});
    }
    <span class="hljs-comment">// 平方根的并行计算:</span>
    for_each(std::execution::par,
             coll.<span class="hljs-built_in">begin</span>(), coll.<span class="hljs-built_in">end</span>(),
             [](<span class="hljs-keyword">auto</span>&amp; val) {
                 val.sqrt = std::<span class="hljs-built_in">sqrt</span>(val.value);
             });
}</code></pre></div>

<p>正如你所看到的，使用并行算法在原则上是非常容易的。</p>
<ul>
<li>包括头文件<execution>。</execution></li>
<li>按照你通常调用算法的方式来调用算法，并附加一个第一个参数，这个参数通常是简单的std::execution::par。</li>
</ul>
<p>在这种情况下，我们使用标准算法for_each()来计算传递的向量coll中所有元素的成员值的平方根。由于额外的第一个参数std::execution::par，我们要求该算法以并行模式运行:</p>
<div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;execution&gt;</span></span>
...
for_each(std::execution::par,
         coll.<span class="hljs-built_in">begin</span>(), coll.<span class="hljs-built_in">end</span>(),
         [](<span class="hljs-keyword">auto</span>&amp; val) {
             val.sqrt = std::<span class="hljs-built_in">sqrt</span>(val.value);
         });</code></pre></div>

<p>像往常一样，coll在这里可以是任何范围。但是请注意，所有的并行算法都要求迭代器至少是前向迭代器（我们在不同的线程中迭代相同的元素，如果迭代器不迭代相同的值，那就没有意义）。<br>算法并行运行的方式是具体实现的。当然，使用多线程也不一定更快，因为启动和处理多线程也需要时间。</p>
<h6><span id="xing-neng-you-shi">性能优势</span><a href="#xing-neng-you-shi" class="header-anchor">#</a></h6><p>为了找到如何、是否以及何时值得并行运行这个算法，让我们把这个例子修改如下。<br><code>lib/parforeach.cpp</code> </p>
<div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;numeric&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;execution&gt;</span> <span class="hljs-comment">// for the execution policy</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">"timer.hpp"</span></span>
<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>
<span class="hljs-function"></span>{
    <span class="hljs-type">int</span> numElems = <span class="hljs-number">1000</span>;
    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">Data</span> {
        <span class="hljs-type">double</span> value; <span class="hljs-comment">// 初始值</span>
        <span class="hljs-type">double</span> sqrt; <span class="hljs-comment">// 并行计算平方根</span>
    };
    <span class="hljs-comment">// 初始化没有平方根的 NumElems 值:</span>
    std::vector&lt;Data&gt; coll;
    coll.<span class="hljs-built_in">reserve</span>(numElems);
    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>; i&lt;numElems; ++i) {
        coll.<span class="hljs-built_in">push_back</span>(Data{i * <span class="hljs-number">4.37</span>, <span class="hljs-number">0</span>});
    }
    <span class="hljs-comment">// 平方根的并行计算:</span>
    for_each(std::execution::par,
             coll.<span class="hljs-built_in">begin</span>(), coll.<span class="hljs-built_in">end</span>(),
             [](<span class="hljs-keyword">auto</span>&amp; val) {
                 val.sqrt = std::<span class="hljs-built_in">sqrt</span>(val.value);
             });
}</code></pre></div>

<p>关键的修改是。</p>
<ul>
<li>我们可以通过命令行传递我们操作的数值的多少。</li>
<li>我们使用类Timer来测量调用算法的持续时间。</li>
<li>我们在一个循环中进行多次测量，以使持续时间更加成熟。<br>结果在很大程度上取决于所使用的硬件、C++编译器和C++库。在我的笔记本电脑上（在英特尔i7上使用Visual C++，带有2个核心和超线程），我们得到的结果如下。</li>
<li>在100个元素的情况下，顺序算法要快10倍以上。这是因为启动和管理线程需要太多的时间，对于几个元素来说不值得。</li>
<li>对于10,000个元素，我们接近于收支平衡。</li>
<li>对于1,000,000个元素，并行执行的速度大约是3倍。</li>
</ul>
<p>同样，这也不是一个一般性的证明，在什么地方和什么时候并行算法是值得的。但它表明，即使对于非微不足道的数字运算，也值得使用它们。关键是，它值得用在</p>
<ul>
<li>长操作</li>
<li>许多许多元素<br>例如，使用并行版本的算法count_if()计算一个ints vector中的偶数元素的数量是不值得的。元素的并行版本是不值得的；即使有1,000,000,000个元素也不值得。<div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">auto</span> num = std::<span class="hljs-built_in">count_if</span>(std::execution::par, <span class="hljs-comment">// execute policy</span>
                         coll.<span class="hljs-built_in">cbegin</span>(), coll.<span class="hljs-built_in">cend</span>(), <span class="hljs-comment">// 范围</span>
                         [](<span class="hljs-type">int</span> elem){ <span class="hljs-comment">//准则</span>
                             <span class="hljs-keyword">return</span> elem % <span class="hljs-number">2</span> == <span class="hljs-number">0</span>;
                         });</code></pre></div>
事实上，对于本例中具有快速谓词的简单算法，并行运行可能永远不会有回报。每个元素都应该发生一些需要大量时间的事情，并且与其他元素的处理无关。<br>但你无法预测任何事情，因为何时以及如何使用并行线程，都取决于C++标准库的实现者。事实上，无法控制使用多少线程，实现者可能会决定只在一定数量的元素上使用多线程。<br>测量! 用你的目标平台上的典型场景。</li>
</ul>
<h5><span id="22-1-2-shi-yong-bing-xing-de-sort">22.1.2 使用并行的sort()</span><a href="#22-1-2-shi-yong-bing-xing-de-sort" class="header-anchor">#</a></h5><p>排序是另一个例子，并行算法可以提供帮助。因为排序标准对每个元素的使用不只一次，你可以节省大量时间。<br>例如，考虑一下，我们初始化一个字符串的向量如下:</p>
<div class="code-wrapper"><pre><code class="hljs c++">std::vector&lt;std::string&gt; coll;
<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>; i &lt; numElems / <span class="hljs-number">2</span>; ++i) {
    coll.<span class="hljs-built_in">emplace_back</span>(<span class="hljs-string">"id"</span> + std::<span class="hljs-built_in">to_string</span>(i));
    coll.<span class="hljs-built_in">emplace_back</span>(<span class="hljs-string">"ID"</span> + std::<span class="hljs-built_in">to_string</span>(i));
}</code></pre></div>

<p>也就是说，我们创建一个以 “id “或 “ID “开头的元素向量，后面是一个整数:</p>
<div class="code-wrapper"><pre><code class="hljs bash">id0 ID0 id1 ID1 id2 ID2 id3 ... id99 ID99 id100 ID100 ...</code></pre></div>

<p>我们可以像往常一样按以下顺序对元素进行排序:</p>
<div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-built_in">sort</span>(coll.<span class="hljs-built_in">begin</span>(), coll.<span class="hljs-built_in">end</span>());</code></pre></div>

<p>现在也可以通过明确传递一个 “顺序 “执行策略来实现:</p>
<div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-built_in">sort</span>(std::execution::seq, coll.<span class="hljs-built_in">begin</span>(), coll.<span class="hljs-built_in">end</span>());</code></pre></div>

<p>如果在运行时决定是顺序运行还是并行运行，并且你不想有不同的函数调用，那么将顺序执行作为参数传递会很有用。<br>要求用并行排序来代替是很容易的:</p>
<div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-built_in">sort</span>(std::execution::par, coll.<span class="hljs-built_in">begin</span>(), coll.<span class="hljs-built_in">end</span>());</code></pre></div>

<p>请注意，还有另一个并行执行策略：</p>
<div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-built_in">sort</span>(std::execution::par_seq, coll.<span class="hljs-built_in">begin</span>(), coll.<span class="hljs-built_in">end</span>());</code></pre></div>

<p>我稍后将解释其中的区别。<br>所以，问题又来了，（什么时候）使用并行排序更好？在我的笔记本电脑上，只有10,000个字符串，你可以看到排序的时间是顺序排序的一半。而且，即使是对1000个字符串进行排序，使用并行执行也略胜一筹。</p>
<h6><span id="yu-qi-ta-gai-jin-cuo-shi-xiang-jie-he">与其他改进措施相结合</span><a href="#yu-qi-ta-gai-jin-cuo-shi-xiang-jie-he" class="header-anchor">#</a></h6><p>请注意，还有其他的修改可能会给你带来更多或额外的好处。例如，如果我们只按数字排序，使用没有两个前导字符的子串，我们可以在谓词中使用字符串操作，并再次看到并行执行的2倍的改进:</p>
<div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-built_in">sort</span>(std::execution::par,
     coll.<span class="hljs-built_in">begin</span>(), coll.<span class="hljs-built_in">end</span>(),
     [] (<span class="hljs-type">const</span> <span class="hljs-keyword">auto</span>&amp; a, <span class="hljs-type">const</span> <span class="hljs-keyword">auto</span>&amp; b) {
         <span class="hljs-keyword">return</span> a.<span class="hljs-built_in">substr</span>(<span class="hljs-number">2</span>) &lt; b.<span class="hljs-built_in">substr</span>(<span class="hljs-number">2</span>);
     });</code></pre></div>

<p>然而，substr()对于字符串来说是一个相当昂贵的成员函数，因为它创建并返回一个新的临时字符串。通过使用string_view类，我们甚至在连续执行的情况下，也会比以前好3倍。顺序执行的情况下，我们的速度也会提高3倍:</p>
<div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-built_in">sort</span>(coll.<span class="hljs-built_in">begin</span>(), coll.<span class="hljs-built_in">end</span>(),
     [] (<span class="hljs-type">const</span> <span class="hljs-keyword">auto</span>&amp; a, <span class="hljs-type">const</span> <span class="hljs-keyword">auto</span>&amp; b) {
         <span class="hljs-keyword">return</span> std::string_view{a}.<span class="hljs-built_in">substr</span>(<span class="hljs-number">2</span>) &lt; std::string_view{b}.<span class="hljs-built_in">substr</span>(<span class="hljs-number">2</span>);
     });</code></pre></div>

<p>结合使用并行算法，我们的速度提高了多达 10 倍：</p>
<div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-built_in">sort</span>(std::execution::par,
     coll.<span class="hljs-built_in">begin</span>(), coll.<span class="hljs-built_in">end</span>(),
     [] (<span class="hljs-type">const</span> <span class="hljs-keyword">auto</span>&amp; a, <span class="hljs-type">const</span> <span class="hljs-keyword">auto</span>&amp; b) {
         <span class="hljs-keyword">return</span> std::string_view{a}.<span class="hljs-built_in">substr</span>(<span class="hljs-number">2</span>) &lt; std::string_view{b}.<span class="hljs-built_in">substr</span>(<span class="hljs-number">2</span>);
     });</code></pre></div>

<p>与使用字符串的 substr() 成员的顺序执行相比：</p>
<div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-built_in">sort</span>(coll.<span class="hljs-built_in">begin</span>(), coll.<span class="hljs-built_in">end</span>(),
     [] (<span class="hljs-type">const</span> <span class="hljs-keyword">auto</span>&amp; a, <span class="hljs-type">const</span> <span class="hljs-keyword">auto</span>&amp; b) {
         <span class="hljs-keyword">return</span> a.<span class="hljs-built_in">substr</span>(<span class="hljs-number">2</span>) &lt; b.<span class="hljs-built_in">substr</span>(<span class="hljs-number">2</span>);</code></pre></div>

<h4><span id="22-2-zhi-xing-ce-lue">22.2 执行策略</span><a href="#22-2-zhi-xing-ce-lue" class="header-anchor">#</a></h4><p>你可以把不同的执行策略作为第一个参数传递给并行STL算法。它们被定义在头文件<execution>中。表Execution Policies列出了标准化的执行策略。</execution></p>
<table>
<thead>
<tr>
<th>策略</th>
<th>意义</th>
</tr>
</thead>
<tbody><tr>
<td>std::execution::seq</td>
<td>顺序执行</td>
</tr>
<tr>
<td>std::execution::par</td>
<td>并行顺序执行</td>
</tr>
<tr>
<td>std::execution::par_unseq</td>
<td>并行无序列（矢量）执行</td>
</tr>
</tbody></table>
<p>让我们详细讨论一下执行策略。</p>
<ul>
<li>使用seq的顺序执行<br>意味着和非并行算法一样，当前的执行线程按顺序逐个元素执行必要的操作。使用这个策略的行为应该和使用非并行方式调用算法一样，根本不需要传递任何执行策略。然而，对于接受这个参数的并行算法，可能会有额外的限制，比如for_each()不返回任何值，或者所有的迭代器必须至少是前向迭代器。<br>提供这个策略是为了能够通过传递一个不同的参数而不是使用一个不同的签名来请求顺序执行。但是请注意，采用这种策略的并行算法的行为可能与相应的非并行算法略有不同。</li>
<li>使用par的并行顺序执行<br>意味着多个线程可能依次执行元素的必要操作。当一个算法开始执行必要的操作时，它在处理其他元素之前完成这一执行。<br>与par_unseq相比，这可以确保没有问题或死锁发生，因为在处理完一个元素的步骤后，需要在同一个线程对另一个元素执行第一步之前调用另一个步骤。</li>
<li>使用par_unseq的并行无序执行<br>意味着多个线程可能为多个元素执行必要的操作，但不能保证一个线程执行该元素的所有步骤而不切换到其他 元素。这特别是使矢量执行成为可能，在这种情况下，一个线程可能首先执行多个元素的第一步 在执行下一个步骤之前，一个线程可能首先执行多个元素的执行步骤。</li>
</ul>
<p>并行的无序执行需要编译器/硬件的特别支持，以检测哪里和如何操作可以被矢量化。操作如何被矢量化。</p>
<h4><span id="22-3-yi-chang-chu-li">22.3 异常处理</span><a href="#22-3-yi-chang-chu-li" class="header-anchor">#</a></h4><p>所有的并行算法都会调用std::terminate()，如果元素访问函数通过一个未捕获的异常退出。<br>请注意，如果选择的是顺序执行策略，这也适用。如果不能接受这种情况，使用算法的非并行版本可能是更好的选择。<br>还要注意的是，并行算法仍有可能被抛出。如果它们不能为并行执行获得临时的内存资源，它们会抛出std::bad_alloc。然而，没有其他 可能会被抛出。</p>
<h4><span id="22-4-bu-shi-yong-bing-xing-suan-fa-de-hao-chu">22.4 不使用并行算法的好处</span><a href="#22-4-bu-shi-yong-bing-xing-suan-fa-de-hao-chu" class="header-anchor">#</a></h4><p>有了调用并行算法的能力，以及它们甚至提供了一个顺序执行策略的事实，可能会出现这样的问题：我们是否还需要非并行算法。<br>然而，除了向后兼容之外，使用非并行算法可能有很大的好处。</p>
<ul>
<li>可以使用输入和输出迭代器。</li>
<li>算法不会在异常情况下terminate()。</li>
<li>算法可以避免由于非故意使用元素而产生的副作用。</li>
<li>算法可能提供额外的功能，例如for_each()返回传递的可调用，以便能够处理其结果状态。</li>
</ul>
<h4><span id="22-5-bing-xing-suan-fa-de-gai-shu">22.5 并行算法的概述</span><a href="#22-5-bing-xing-suan-fa-de-gai-shu" class="header-anchor">#</a></h4><p>表Unmodified Parallel STL Algorithms列出了标准化的算法，可以不加任何修改地支持并行处理。<br>表Modified Parallel STL Algorithms列出了经过一些修改的支持并行处理的标准化算法。<br>表STL算法无并行化列出了不支持并行处理的算法。<br>请注意，对于 accumulate() 和 inner_product() ，新的并行算法被提供了宽松的要求。放宽了要求。</p>
<table>
<thead>
<tr>
<th>算法</th>
<th>备注</th>
</tr>
</thead>
<tbody><tr>
<td>find_end(), adjacent_find()</td>
<td>除了搜索者</td>
</tr>
<tr>
<td>search(), search_n()</td>
<td></td>
</tr>
<tr>
<td>swap_ranges()</td>
<td></td>
</tr>
<tr>
<td>replace(), replace_if()</td>
<td></td>
</tr>
<tr>
<td>fill()</td>
<td></td>
</tr>
<tr>
<td>generate()</td>
<td></td>
</tr>
<tr>
<td>remove(), remove_if()</td>
<td></td>
</tr>
<tr>
<td>unique()</td>
<td></td>
</tr>
<tr>
<td>reverse()</td>
<td></td>
</tr>
<tr>
<td>rotate()</td>
<td></td>
</tr>
<tr>
<td>partition(), stable_partition()</td>
<td></td>
</tr>
<tr>
<td>sort(), stable_sort(), partial_sort()</td>
<td></td>
</tr>
<tr>
<td>is_sorted(), is_sorted_until()</td>
<td></td>
</tr>
<tr>
<td>nth_element()</td>
<td></td>
</tr>
<tr>
<td>inplace_merge()</td>
<td></td>
</tr>
<tr>
<td>is_heap(), is_heap_until()</td>
<td></td>
</tr>
<tr>
<td>min_element(), max_element(), min_max_element()</td>
<td>除了搜索者</td>
</tr>
<tr>
<td>for_each()</td>
<td>前向迭代器和返回类型 void</td>
</tr>
<tr>
<td>all_of(), any_of(), none_of()</td>
<td>前向迭代器</td>
</tr>
<tr>
<td>for_each_n()</td>
<td></td>
</tr>
<tr>
<td>find(), find_if(), find_if_not()</td>
<td></td>
</tr>
<tr>
<td>find_first_of()</td>
<td></td>
</tr>
<tr>
<td>count(), count_if()</td>
<td></td>
</tr>
<tr>
<td>mismatch()</td>
<td></td>
</tr>
<tr>
<td>equal()</td>
<td></td>
</tr>
<tr>
<td>is_partitioned()</td>
<td></td>
</tr>
<tr>
<td>partial_sort_copy()</td>
<td></td>
</tr>
<tr>
<td>includes()</td>
<td></td>
</tr>
<tr>
<td>lexicographical_compare()</td>
<td></td>
</tr>
<tr>
<td>fill_n()</td>
<td></td>
</tr>
<tr>
<td>generate_n()</td>
<td></td>
</tr>
<tr>
<td>reverse_copy()</td>
<td></td>
</tr>
<tr>
<td>rotate_copy()</td>
<td></td>
</tr>
<tr>
<td>copy(), copy_n(), copy_if()</td>
<td></td>
</tr>
<tr>
<td>move()</td>
<td></td>
</tr>
<tr>
<td>transform()</td>
<td></td>
</tr>
<tr>
<td>replace_copy(), replace_copy_if()</td>
<td></td>
</tr>
<tr>
<td>remove_copy(), remove_copy_if()</td>
<td></td>
</tr>
<tr>
<td>unique_copy()</td>
<td></td>
</tr>
<tr>
<td>partition_copy()</td>
<td></td>
</tr>
<tr>
<td>merge()</td>
<td></td>
</tr>
<tr>
<td>set_union(), set_intersection()</td>
<td></td>
</tr>
<tr>
<td>set_difference(), set_symmetric_difference()</td>
<td></td>
</tr>
<tr>
<td>exclusive_scan(), inclusive_scan()</td>
<td>前向迭代器</td>
</tr>
<tr>
<td>accumulate(), inner_product(), partial_sum()</td>
<td>改用 reduce() 和 transform_reduce()</td>
</tr>
<tr>
<td>search() with searcher</td>
<td></td>
</tr>
<tr>
<td>copy_backward() move_backward()</td>
<td></td>
</tr>
<tr>
<td>sample(), shuffle()</td>
<td></td>
</tr>
<tr>
<td>partition_point()</td>
<td></td>
</tr>
<tr>
<td>lower_bound(), upper_bound(), equal_range()</td>
<td></td>
</tr>
<tr>
<td>binary_search()</td>
<td></td>
</tr>
<tr>
<td>is_permutation(), next_permutation(), prev_permutation()</td>
<td></td>
</tr>
<tr>
<td>push_heap(), pop_heap(), make_heap(), sort_heap()</td>
<td>改用 reduce() 和 transform_reduce()</td>
</tr>
</tbody></table>
<h4><span id="22-6-bing-xing-chu-li-de-xin-suan-fa">22.6 并行处理的新算法</span><a href="#22-6-bing-xing-chu-li-de-xin-suan-fa" class="header-anchor">#</a></h4><p>一些补充算法被引入，以处理自C++98以来可用的标准算法的并行处理。</p>
<h5><span id="22-6-1-reduce">22.6.1 reduce()</span><a href="#22-6-1-reduce" class="header-anchor">#</a></h5><p>例如，reduce()是作为 accumulate()的平行形式引入的，它 “累积 “所有元素（你可以定义，哪个操作执行 “累积”）。例如，考虑以下 accumulate() 的用法。</p>
<p><code>lib/accumulate.cpp </code></p>
<div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;numeric&gt;</span> <span class="hljs-comment">// for accumulate()</span></span>
<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">printSum</span><span class="hljs-params">(<span class="hljs-type">long</span> num)</span></span>
<span class="hljs-function"></span>{
    <span class="hljs-comment">// 用 1 2 3 4 的 num 个序列创建 coll:</span>
    std::vector&lt;<span class="hljs-type">long</span>&gt; coll;
    coll.<span class="hljs-built_in">reserve</span>(num * <span class="hljs-number">4</span>);
    <span class="hljs-keyword">for</span> (<span class="hljs-type">long</span> i=<span class="hljs-number">0</span>; i &lt; num; ++i) {
        coll.<span class="hljs-built_in">insert</span>(coll.<span class="hljs-built_in">end</span>(), {<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>});
    }
    <span class="hljs-keyword">auto</span> sum = std::<span class="hljs-built_in">accumulate</span>(coll.<span class="hljs-built_in">begin</span>(), coll.<span class="hljs-built_in">end</span>(),
                               <span class="hljs-number">0L</span>);
    std::cout &lt;&lt; <span class="hljs-string">"accumulate(): "</span> &lt;&lt; sum &lt;&lt; <span class="hljs-string">'\n'</span>;
}
<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>
<span class="hljs-function"></span>{
    <span class="hljs-built_in">printSum</span>(<span class="hljs-number">1</span>);
    <span class="hljs-built_in">printSum</span>(<span class="hljs-number">1000</span>);
    <span class="hljs-built_in">printSum</span>(<span class="hljs-number">1000000</span>);
    <span class="hljs-built_in">printSum</span>(<span class="hljs-number">10000000</span>);
}</code></pre></div>

<p>我们计算所有元素的总和，输出：</p>
<div class="code-wrapper"><pre><code class="hljs bash">accumulate(): 10
accumulate(): 10000
accumulate(): 10000000</code></pre></div>

<h6><span id="huan-suan-yun-suan-de-ping-xing-hua">换算运算的平行化</span><a href="#huan-suan-yun-suan-de-ping-xing-hua" class="header-anchor">#</a></h6><p>这个程序可以通过改用reduce()来实现并行化:</p>
<p><code>lib/reduce.cpp</code></p>
<div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;numeric&gt;</span> <span class="hljs-comment">// for reduce()</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;execution&gt;</span></span>
<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">printSum</span><span class="hljs-params">(<span class="hljs-type">long</span> num)</span></span>
<span class="hljs-function"></span>{
    <span class="hljs-comment">// 用 1 2 3 4 的 num 个序列创建 coll:</span>
    std::vector&lt;<span class="hljs-type">long</span>&gt; coll;
    coll.<span class="hljs-built_in">reserve</span>(num * <span class="hljs-number">4</span>);
    <span class="hljs-keyword">for</span> (<span class="hljs-type">long</span> i=<span class="hljs-number">0</span>; i &lt; num; ++i) {
        coll.<span class="hljs-built_in">insert</span>(coll.<span class="hljs-built_in">end</span>(), {<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>});
    }
    <span class="hljs-keyword">auto</span> sum = std::<span class="hljs-built_in">reduce</span>(std::execution::par,
                           coll.<span class="hljs-built_in">begin</span>(), coll.<span class="hljs-built_in">end</span>(),
                           <span class="hljs-number">0L</span>);
    std::cout &lt;&lt; <span class="hljs-string">"reduce(): "</span> &lt;&lt; sum &lt;&lt; <span class="hljs-string">'\n'</span>;
}
<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>
<span class="hljs-function"></span>{
    <span class="hljs-built_in">printSum</span>(<span class="hljs-number">1</span>);
    <span class="hljs-built_in">printSum</span>(<span class="hljs-number">1000</span>);
    <span class="hljs-built_in">printSum</span>(<span class="hljs-number">1000000</span>);
    <span class="hljs-built_in">printSum</span>(<span class="hljs-number">10000000</span>);
}</code></pre></div>

<p>在输出相同的情况下，现在的程序可能运行得更快或更慢（取决于是否支持启动多线程，以及所花费的时间是否比我们并行运行算法所节省的时间多）。<br>这里使用的操作是+，它是换元的，所以加入积分元素的顺序并不重要。</p>
<h6><span id="fei-gong-e-yun-suan-de-bing-xing-hua">非共轭运算的并行化</span><a href="#fei-gong-e-yun-suan-de-bing-xing-hua" class="header-anchor">#</a></h6><p>然而，对于浮点值来说，顺序很重要，这就证明了以下程序:</p>
<p><code>lib/reducefloat.cpp </code></p>
<div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;numeric&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;execution&gt;</span></span>
<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">printSum</span><span class="hljs-params">(<span class="hljs-type">long</span> num)</span></span>
<span class="hljs-function"></span>{
    <span class="hljs-comment">// 用 0.1 0.3 0.0001 的 num 个序列创建 coll:</span>
    std::vector&lt;<span class="hljs-type">double</span>&gt; coll;
    coll.<span class="hljs-built_in">reserve</span>(num * <span class="hljs-number">4</span>);
    <span class="hljs-keyword">for</span> (<span class="hljs-type">long</span> i=<span class="hljs-number">0</span>; i &lt; num; ++i) {
        coll.<span class="hljs-built_in">insert</span>(coll.<span class="hljs-built_in">end</span>(), {<span class="hljs-number">0.1</span>, <span class="hljs-number">0.3</span>, <span class="hljs-number">0.00001</span>});
    }
    <span class="hljs-keyword">auto</span> sum1 = std::<span class="hljs-built_in">accumulate</span>(coll.<span class="hljs-built_in">begin</span>(), coll.<span class="hljs-built_in">end</span>(),
                                <span class="hljs-number">0.0</span>);
    std::cout &lt;&lt; <span class="hljs-string">"accumulate(): "</span> &lt;&lt; sum1 &lt;&lt; <span class="hljs-string">'\n'</span>;
    <span class="hljs-keyword">auto</span> sum2 = std::<span class="hljs-built_in">reduce</span>(std::execution::par,
                            coll.<span class="hljs-built_in">begin</span>(), coll.<span class="hljs-built_in">end</span>(),
                            <span class="hljs-number">0.0</span>);
    std::cout &lt;&lt; <span class="hljs-string">"reduce(): "</span> &lt;&lt; sum2 &lt;&lt; <span class="hljs-string">'\n'</span>;
    std::cout &lt;&lt; (sum1==sum2 ? <span class="hljs-string">"equal\n"</span> : <span class="hljs-string">"differ\n"</span>);
}
<span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iomanip&gt;</span></span>
<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>
<span class="hljs-function"></span>{
    std::cout &lt;&lt; std::<span class="hljs-built_in">setprecision</span>(<span class="hljs-number">20</span>);
    <span class="hljs-built_in">printSum</span>(<span class="hljs-number">1</span>);
    <span class="hljs-built_in">printSum</span>(<span class="hljs-number">1000</span>);
    <span class="hljs-built_in">printSum</span>(<span class="hljs-number">1000000</span>);
    <span class="hljs-built_in">printSum</span>(<span class="hljs-number">10000000</span>);
}</code></pre></div>

<p>这里我们同时使用 accumulate() 和 reduce() 并比较结果。一个可能的输出是:</p>
<div class="code-wrapper"><pre><code class="hljs bash">accumulate(): 0.40001
reduce(): 0.40001
equal
accumulate(): 400.01
reduce(): 400.01
differ
accumulate(): 400010
reduce(): 400010
differ
accumulate(): 4.0001e+06
reduce(): 4.0001e+06
differ</code></pre></div>

<p>虽然结果看起来是一样的，但有时会有差异。这可能是以不同的顺序添加 的顺序不同而造成的。<br>如果我们改变打印浮点值的精度:</p>
<div class="code-wrapper"><pre><code class="hljs c++">std::cout &lt;&lt; std::<span class="hljs-built_in">setprecision</span>(<span class="hljs-number">20</span>);</code></pre></div>

<p>我们可以看到结果值略有不同：</p>
<div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-built_in">accumulate</span>(): <span class="hljs-number">0.40001000000000003221</span>
<span class="hljs-built_in">reduce</span>(): <span class="hljs-number">0.40001000000000003221</span>
<span class="hljs-function">equal</span>
<span class="hljs-function"><span class="hljs-title">accumulate</span><span class="hljs-params">()</span>: <span class="hljs-number">400.01000000000533419</span></span>
<span class="hljs-function">reduce(): <span class="hljs-number">400.01000000000010459</span></span>
<span class="hljs-function">differ</span>
<span class="hljs-function">accumulate(): <span class="hljs-number">400009.99999085225863</span></span>
<span class="hljs-function">reduce(): <span class="hljs-number">400009.9999999878346</span></span>
<span class="hljs-function">differ</span>
<span class="hljs-function">accumulate(): <span class="hljs-number">4000100.0004483023658</span></span>
<span class="hljs-function">reduce(): <span class="hljs-number">4000100.0000019222498</span></span>
<span class="hljs-function">differ</span></code></pre></div>

<p>由于没有定义是否、何时以及如何实现并行算法，因此在某些平台上的结果可能看起来是一样的（达到一定数量的元素）。</p>
<h6><span id="fei-guan-lian-xing-cao-zuo-de-bing-xing-hua">非关联性操作的并行化</span><a href="#fei-guan-lian-xing-cao-zuo-de-bing-xing-hua" class="header-anchor">#</a></h6><p>现在让我们改变一下操作，通过总是添加每个值的平方来累积值:</p>
<p><code>lib/accumulate2.cpp</code></p>
<div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;numeric&gt;</span> <span class="hljs-comment">// 对于 accumulate()</span></span>
<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">printSum</span><span class="hljs-params">(<span class="hljs-type">long</span> num)</span></span>
<span class="hljs-function"></span>{
    <span class="hljs-comment">// 用 1 2 3 4 的 num 个序列创建 coll：</span>
    std::vector&lt;<span class="hljs-type">long</span>&gt; coll;
    coll.<span class="hljs-built_in">reserve</span>(num * <span class="hljs-number">4</span>);
    <span class="hljs-keyword">for</span> (<span class="hljs-type">long</span> i=<span class="hljs-number">0</span>; i &lt; num; ++i) {
        coll.<span class="hljs-built_in">insert</span>(coll.<span class="hljs-built_in">end</span>(), {<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>});
    }
    <span class="hljs-keyword">auto</span> squaredSum = [] (<span class="hljs-keyword">auto</span> sum, <span class="hljs-keyword">auto</span> val) {
        <span class="hljs-keyword">return</span> sum + val * val;
    };
    <span class="hljs-keyword">auto</span> sum = std::<span class="hljs-built_in">accumulate</span>(coll.<span class="hljs-built_in">begin</span>(), coll.<span class="hljs-built_in">end</span>(),
                               <span class="hljs-number">0L</span>,
                               squaredSum);
    std::cout &lt;&lt; <span class="hljs-string">"accumulate(): "</span> &lt;&lt; sum &lt;&lt; <span class="hljs-string">'\n'</span>;
}
<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>
<span class="hljs-function"></span>{
    <span class="hljs-built_in">printSum</span>(<span class="hljs-number">1</span>);
    <span class="hljs-built_in">printSum</span>(<span class="hljs-number">1000</span>);
    <span class="hljs-built_in">printSum</span>(<span class="hljs-number">1000000</span>);
    <span class="hljs-built_in">printSum</span>(<span class="hljs-number">10000000</span>);
}</code></pre></div>

<p>在这里，我们传递一个lambda，对于每一个值，都要取当前的和，并加上新值的平方:</p>
<div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">auto</span> squaredSum = [] (<span class="hljs-keyword">auto</span> sum, <span class="hljs-keyword">auto</span> val) {
    <span class="hljs-keyword">return</span> sum + val * val;
};</code></pre></div>

<p>使用 accumulate() 输出看起来很好:</p>
<div class="code-wrapper"><pre><code class="hljs bash">accumulate(): 30
accumulate(): 30000
accumulate(): 30000000
accumulate(): 300000000</code></pre></div>

<p>但是，让我们使用 reduce() 切换到并行处理：</p>
<p> <code>lib/reduce2.cpp</code> </p>
<div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;numeric&gt;</span> <span class="hljs-comment">// 对于reduce()</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;execution&gt;</span></span>
<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">printSum</span><span class="hljs-params">(<span class="hljs-type">long</span> num)</span></span>
<span class="hljs-function"></span>{
    <span class="hljs-comment">// 用 1 2 3 4 的 num 个序列创建 coll：</span>
    std::vector&lt;<span class="hljs-type">long</span>&gt; coll;
    coll.<span class="hljs-built_in">reserve</span>(num * <span class="hljs-number">4</span>);
    <span class="hljs-keyword">for</span> (<span class="hljs-type">long</span> i=<span class="hljs-number">0</span>; i &lt; num; ++i) {
        coll.<span class="hljs-built_in">insert</span>(coll.<span class="hljs-built_in">end</span>(), {<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>});
    }
    <span class="hljs-keyword">auto</span> squaredSum = [] (<span class="hljs-keyword">auto</span> sum, <span class="hljs-keyword">auto</span> val) {
        <span class="hljs-keyword">return</span> sum + val * val;
    };
    <span class="hljs-keyword">auto</span> sum = std::<span class="hljs-built_in">reduce</span>(std::execution::par,
                           coll.<span class="hljs-built_in">begin</span>(), coll.<span class="hljs-built_in">end</span>(),
                           <span class="hljs-number">0L</span>,
                           squaredSum);
    std::cout &lt;&lt; <span class="hljs-string">"reduce(): "</span> &lt;&lt; sum &lt;&lt; <span class="hljs-string">'\n'</span>;
}
<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>
<span class="hljs-function"></span>{
    <span class="hljs-built_in">printSum</span>(<span class="hljs-number">1</span>);
    <span class="hljs-built_in">printSum</span>(<span class="hljs-number">1000</span>);
    <span class="hljs-built_in">printSum</span>(<span class="hljs-number">1000000</span>);
    <span class="hljs-built_in">printSum</span>(<span class="hljs-number">10000000</span>);
}</code></pre></div>

<p>输出可能会变成这样：</p>
<div class="code-wrapper"><pre><code class="hljs bash">reduce(): 30
reduce(): 30000
reduce(): -425251612
reduce(): 705991074</code></pre></div>

<p>是的，结果有时可能是错误的。问题是，该操作不是关联性的。例如，如果我们对元素1、2和3应用这个操作，我们可能先计算0+1<em>1和2+3</em>3，但当我们把中间的结果结合起来时，我们又把3平方了，基本上是 计算:</p>
<div class="code-wrapper"><pre><code class="hljs bash">(0+1*1) + (2+3*3) * (2+3*3)</code></pre></div>

<p>但为什么这里的结果有时是正确的呢？嗯，似乎在这个平台上，reduce()只在一定数量的元素中并行运行。而这是完全可以的。因此，使用有足够多元素的测试案例来检测这样的问题。<br>解决这个问题的方法是使用另一种新的算法，transform_reduce()。它把我们要对每个元素进行的修改（这是我们可以并行化的一件事）和结果的累积分开，只要它是换元的（这是我们可以并行化的另一件事）。</p>
<p><code>lib/transformreduce.cpp </code></p>
<div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;numeric&gt;</span> <span class="hljs-comment">// for transform_reduce()</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;execution&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;functional&gt;</span></span>
<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">printSum</span><span class="hljs-params">(<span class="hljs-type">long</span> num)</span></span>
<span class="hljs-function"></span>{
    <span class="hljs-comment">// 用 1 2 3 4 的 num 个序列创建 coll:</span>
    std::vector&lt;<span class="hljs-type">long</span>&gt; coll;
    coll.<span class="hljs-built_in">reserve</span>(num * <span class="hljs-number">4</span>);
    <span class="hljs-keyword">for</span> (<span class="hljs-type">long</span> i=<span class="hljs-number">0</span>; i &lt; num; ++i) {
        coll.<span class="hljs-built_in">insert</span>(coll.<span class="hljs-built_in">end</span>(), {<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>});
    }
    <span class="hljs-keyword">auto</span> sum = std::<span class="hljs-built_in">transform_reduce</span>(std::execution::par,
                                     coll.<span class="hljs-built_in">begin</span>(), coll.<span class="hljs-built_in">end</span>(),
                                     <span class="hljs-number">0L</span>,
                                     std::plus{},
                                     [] (<span class="hljs-keyword">auto</span> val) {
                                         <span class="hljs-keyword">return</span> val * val;
                                     });
    std::cout &lt;&lt; <span class="hljs-string">"transform_reduce(): "</span> &lt;&lt; sum &lt;&lt; <span class="hljs-string">'\n'</span>;
}
<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>
<span class="hljs-function"></span>{
    <span class="hljs-built_in">printSum</span>(<span class="hljs-number">1</span>);
    <span class="hljs-built_in">printSum</span>(<span class="hljs-number">1000</span>);
    <span class="hljs-built_in">printSum</span>(<span class="hljs-number">1000000</span>);
    <span class="hljs-built_in">printSum</span>(<span class="hljs-number">10000000</span>);
}</code></pre></div>

<p>在调用transform_reduce()时，我们传递了</p>
<ul>
<li>执行策略，以便（允许）并行地运行这个程序</li>
<li>要处理的值的范围</li>
<li>0L作为外部累加的初始值</li>
<li>操作+作为外部累加的操作</li>
<li>一个lambda，用于在累加之前处理每个值</li>
</ul>
<p>transform_reduce()可能是迄今为止最重要的并行算法，因为我们经常在合并数值之前修改它们（也称为map reduce原则）。</p>
<h6><span id="yong-yu-wen-jian-xi-tong-cao-zuo-de-transform-reduce-han-shu">用于文件系统操作的transform_reduce()函数</span><a href="#yong-yu-wen-jian-xi-tong-cao-zuo-de-transform-reduce-han-shu" class="header-anchor">#</a></h6><p>下面是另一个并行运行transform_reduce()的例子:</p>
<p><code>lib/dirsize.cpp</code></p>
<div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;numeric&gt;</span> <span class="hljs-comment">// for transform_reduce()</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;execution&gt;</span> <span class="hljs-comment">// 对于执行策略</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;filesystem&gt;</span> <span class="hljs-comment">// filesystem library</span></span>
<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span>* argv[])</span></span>
<span class="hljs-function"></span>{
    <span class="hljs-comment">// 根目录作为命令行参数被传递:</span>
    <span class="hljs-keyword">if</span> (argc &lt; <span class="hljs-number">2</span>) {
        std::cout &lt;&lt; <span class="hljs-string">"Usage: "</span> &lt;&lt; argv[<span class="hljs-number">0</span>] &lt;&lt; <span class="hljs-string">" &lt;path&gt; \n"</span>;
        <span class="hljs-keyword">return</span> EXIT_FAILURE;
    }
    std::filesystem::path root{argv[<span class="hljs-number">1</span>]};
    <span class="hljs-comment">// 在通过的文件树中启动所有文件路径的列表:</span>
    std::vector&lt;std::filesystem::path&gt; paths;
    <span class="hljs-keyword">try</span> {
        std::filesystem::recursive_directory_iterator dirpos{root};
        std::<span class="hljs-built_in">copy</span>(<span class="hljs-built_in">begin</span>(dirpos), <span class="hljs-built_in">end</span>(dirpos),
                  std::<span class="hljs-built_in">back_inserter</span>(paths));
    }
    <span class="hljs-built_in">catch</span> (<span class="hljs-type">const</span> std::exception&amp; e) {
        std::cerr &lt;&lt; <span class="hljs-string">"EXCEPTION: "</span> &lt;&lt; e.<span class="hljs-built_in">what</span>() &lt;&lt; std::endl;
        <span class="hljs-keyword">return</span> EXIT_FAILURE;
    }
    <span class="hljs-comment">// 累积所有常规文件的大小:</span>
    <span class="hljs-keyword">auto</span> sz = std::<span class="hljs-built_in">transform_reduce</span>(
        std::execution::par, <span class="hljs-comment">// 并行执行</span>
        paths.<span class="hljs-built_in">cbegin</span>(), paths.<span class="hljs-built_in">cend</span>(), <span class="hljs-comment">// range</span>
        std::<span class="hljs-type">uintmax_t</span>{<span class="hljs-number">0</span>}, <span class="hljs-comment">// 初始值</span>
        std::plus&lt;&gt;(), <span class="hljs-comment">// accumulate ...</span>
        [](<span class="hljs-type">const</span> std::filesystem::path&amp; p) { <span class="hljs-comment">// 如果是普通文件，文件大小</span>
            <span class="hljs-keyword">return</span> <span class="hljs-built_in">is_regular_file</span>(p) ? <span class="hljs-built_in">file_size</span>(p)
                : std::<span class="hljs-type">uintmax_t</span>{<span class="hljs-number">0</span>};
        });
    std::cout &lt;&lt; <span class="hljs-string">"size of all "</span> &lt;&lt; paths.<span class="hljs-built_in">size</span>()
        &lt;&lt; <span class="hljs-string">" regular files: "</span> &lt;&lt; sz &lt;&lt; <span class="hljs-string">'\n'</span>;
}</code></pre></div>

<p>首先，我们递归地收集作为命令行参数的目录中的所有文件系统路径:</p>
<div class="code-wrapper"><pre><code class="hljs c++">std::filesystem::path root{argv[<span class="hljs-number">1</span>]};
std::vector&lt;std::filesystem::path&gt; paths;
std::filesystem::recursive_directory_iterator dirpos{root};
std::<span class="hljs-built_in">copy</span>(<span class="hljs-built_in">begin</span>(dirpos), <span class="hljs-built_in">end</span>(dirpos),
std::<span class="hljs-built_in">back_inserter</span>(paths));</code></pre></div>

<p>请注意，由于我们可能会传递一个无效的路径，可能的（文件系统）异常会被捕获。<br>然后，我们遍历文件系统路径的集合，积累它们的大小，如果它们是 正常的文件:</p>
<div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">auto</span> sz = std::<span class="hljs-built_in">transform_reduce</span>(
    std::execution::par, <span class="hljs-comment">// 并行执行</span>
    paths.<span class="hljs-built_in">cbegin</span>(), paths.<span class="hljs-built_in">cend</span>(), <span class="hljs-comment">// range</span>
    std::<span class="hljs-type">uintmax_t</span>{<span class="hljs-number">0</span>}, <span class="hljs-comment">// initial value</span>
    std::plus&lt;&gt;(), <span class="hljs-comment">// accumulate ...</span>
    [](<span class="hljs-type">const</span> std::filesystem::path&amp; p) { <span class="hljs-comment">// 文件大小（如果是常规文件）</span>
        <span class="hljs-keyword">return</span> <span class="hljs-built_in">is_regular_file</span>(p) ? <span class="hljs-built_in">file_size</span>(p)
            : std::<span class="hljs-type">uintmax_t</span>{<span class="hljs-number">0</span>};
    });</code></pre></div>

<p>新的标准算法transform_reduce()的操作方法如下。</p>
<ul>
<li>最后一个参数被应用于每个元素。在这里，对每个路径元素调用传递的lambda，如果它是一个普通文件，则查询其大小。</li>
<li>第二个但也是最后一个参数是合并所有大小的操作。因为我们要累积大小，所以我们使用标准函数对象std::plus&lt;&gt;。</li>
<li>第三个但也是最后一个参数是合并所有大小的操作的初始值。因此，如果路径列表是空的，我们从0开始。我们使用与file_size()的返回值相同的类型，std::uintmax_t。</li>
</ul>
<p>请注意，询问文件的大小是一个相当昂贵的操作，因为它需要一个操作系统调用。由于这个原因，使用一个算法来调用这个转换（从路径到大小），并以任何顺序与多个线程并行，并计算出总和，是非常快的回报。第一次测量显示了一个明显的胜利（程序的速度提高了一倍）。<br>还要注意的是，你不能把目录迭代器所迭代的路径直接传递给并行的 算法，因为目录迭代器是输入迭代器，而并行算法需要正向的 迭代器。<br>最后请注意，transform_reduce()被定义在头文件<numeric>中，而不是<algorithm>。<br>(就像 accumulate() 一样，它也算作数字算法。</algorithm></numeric></p>
<h4><span id="22-7-bing-xing-suan-fa-de-xiang-xi-jie-shao">22.7 并行算法的详细介绍</span><a href="#22-7-bing-xing-suan-fa-de-xiang-xi-jie-shao" class="header-anchor">#</a></h4><h4><span id="22-8-hou-ji">22.8 后记</span><a href="#22-8-hou-ji" class="header-anchor">#</a></h4><p>2012 年，Jared Hoberock Michael Garland Olivier Giroux Vinod Grover、Ujval Kapasi 和 Jaydeep Marathe 在 <a target="_blank" rel="noopener" href="https://wg21.link/n3408">https://wg21.link/n3408</a> 中首次提出了并行化 STL 算法。 它成为了一个正式的 beta 标准，即并行 C++ 扩展技术规范（参见 <a target="_blank" rel="noopener" href="https://wg21.link/n3850%EF%BC%89%E3%80%82">https://wg21.link/n3850）。</a> Jared Hoberock、Grant Mercer、Agustin Berge 和 Harmut Kaiser 在 <a target="_blank" rel="noopener" href="https://wg21.link/n4276">https://wg21.link/n4276</a> 中添加了其他算法。 通过 <a target="_blank" rel="noopener" href="https://wg21.link/p0024r2%EF%BC%8CJared">https://wg21.link/p0024r2，Jared</a> Hoberock 提出的标准库采用了 C++ 并行扩展技术规范。 JF Bastien 和 Bryce Adelstein Lelbach 在 <a target="_blank" rel="noopener" href="https://wg21.link/p0394r4">https://wg21.link/p0394r4</a> 中提出的异常处理被接受。</p>
<h3><span id="23-zi-zi-fu-chuan-he-zi-xu-lie-sou-suo">23  子字符串和子序列搜索</span><a href="#23-zi-zi-fu-chuan-he-zi-xu-lie-sou-suo" class="header-anchor">#</a></h3><p>自C++98以来，C++标准库提供了一种搜索算法来寻找一个范围内元素的子序列。然而，存在着不同的搜索算法。例如，通过预先计算关于要搜索的模式的统计数据，这些算法对于特殊的任务，如在一个大文本中寻找子串，可以有明显的表现。<br>因此，C++17引入了Boyer-Moore和Boyer-Moore-Horspool搜索算法以及使用它们的各种接口。它们特别适用于搜索大文本中的子串，但也可以改进寻找容器或范围中的子序列。</p>
<h4><span id="23-1-shi-yong-zi-chuan-sou-suo-qi">23.1 使用子串搜索器</span><a href="#23-1-shi-yong-zi-chuan-sou-suo-qi" class="header-anchor">#</a></h4><p>新的搜索器是专门为搜索大型文本中的字符串（例如，单词或短语）而开发的。<br>因此，让我们首先演示一下在这种情况下如何使用它们，以及你如何利用它们来获益。</p>
<h5><span id="23-1-1-tong-guo-search-shi-yong-sou-suo-qi">23.1.1 通过search()使用搜索器</span><a href="#23-1-1-tong-guo-search-shi-yong-sou-suo-qi" class="header-anchor">#</a></h5><p>我们现在有以下选项来搜索一个字符串文本中的子串子:</p>
<ol>
<li>字符串成员 find():<div class="code-wrapper"><pre><code class="hljs c++">std::size_type idx = text.<span class="hljs-built_in">find</span>(sub)。</code></pre></div></li>
<li>算法搜索()。<div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">auto</span> pos = std::<span class="hljs-built_in">search</span>(text.<span class="hljs-built_in">begin</span>(), text.<span class="hljs-built_in">end</span>(),
sub.<span class="hljs-built_in">begin</span>(), sub.<span class="hljs-built_in">end</span>())。</code></pre></div></li>
<li>并行算法 search():<div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">auto</span> pos = std::<span class="hljs-built_in">search</span>(std::execution::par,
text.<span class="hljs-built_in">begin</span>(), text.<span class="hljs-built_in">end</span>(), sub.<span class="hljs-built_in">begin</span>(), sub.<span class="hljs-built_in">end</span>()）。</code></pre></div></li>
<li>使用 default_searcher:<div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">auto</span> pos = std::<span class="hljs-built_in">search</span>(text.<span class="hljs-built_in">begin</span>(), text.<span class="hljs-built_in">end</span>(),
std::default_searcher{sub.<span class="hljs-built_in">begin</span>(), sub.<span class="hljs-built_in">end</span>()})。</code></pre></div></li>
<li>使用boyer_moore_searcher:<div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">auto</span> pos = std::<span class="hljs-built_in">search</span>(text.<span class="hljs-built_in">begin</span>(), text.<span class="hljs-built_in">end</span>(),
std::boyer_moore_searcher{sub.<span class="hljs-built_in">begin</span>(), sub.<span class="hljs-built_in">end</span>()}）。</code></pre></div></li>
<li>使用boyer_moore_horspool_searcher:<div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">auto</span> pos = std::<span class="hljs-built_in">search</span>(text.<span class="hljs-built_in">begin</span>(), text.<span class="hljs-built_in">end</span>(),
std::boyer_moore_horspool_searcher{sub.<span class="hljs-built_in">begin</span>(),
sub.<span class="hljs-built_in">end</span>()}）。</code></pre></div>
新的搜索器被定义在<functional>中。<br>Boyer-Moore和Boyer-Moore-Horspool搜索器是众所周知的算法，在搜索开始前预先计算表格（哈希值），以提高搜索的速度，如果搜索覆盖了相当大的文本和/或子串。使用它们，算法需要随机访问的迭代器（而不是正向迭代器，这对于天真的搜索（）来说已经足够了）。</functional></li>
</ol>
<p>在lib/searcher1.cpp中，你可以找到一个完整的程序，演示如何使用这些不同的方式来搜索子串。<br>请注意，所有search()的应用都会产生一个指向匹配子串的第一个字符的迭代器。如果没有，则返回文本的末端。这样我们就可以搜索到一个子串的所有出现，如下所示。</p>
<div class="code-wrapper"><pre><code class="hljs c++">std::boyer_moore_searcher bm{sub.<span class="hljs-built_in">begin</span>(), sub.<span class="hljs-built_in">end</span>()};
<span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> pos = std::<span class="hljs-built_in">search</span>(text.<span class="hljs-built_in">begin</span>(), text.<span class="hljs-built_in">end</span>(), bm);
pos != text.<span class="hljs-built_in">end</span>();
pos = std::<span class="hljs-built_in">search</span>(pos+sub.<span class="hljs-built_in">size</span>(), text.<span class="hljs-built_in">end</span>(), bm)) {
std::cout &lt;&lt; <span class="hljs-string">"Found '"</span> &lt;&lt; sub &lt;&lt; <span class="hljs-string">"' at index "</span> &lt;&lt; pos - text.<span class="hljs-built_in">begin</span>() &lt;&lt; <span class="hljs-string">'\n'</span>;
}</code></pre></div>

<h6><span id="sou-suo-qi-de-xing-neng">搜索器的性能</span><a href="#sou-suo-qi-de-xing-neng" class="header-anchor">#</a></h6><p>哪一种是搜索子字符串的最佳方法（最快和/或最少的内存）？ 这个问题的一个特殊方面是我们现在也可以在并行模式下使用传统的 search() （使用新的搜索器时这是不可能的）。<br>答案取决于具体情况：</p>
<ul>
<li><p>仅使用（非并行）search() 通常是最慢的，因为对于文本中的每个字符，我们开始找出子字符串是否匹配。</p>
</li>
<li><p>使用 default_searcher 应该是等价的，但我看到更糟糕的运行时间高达 3 倍。</p>
</li>
<li><p>使用find()可能会更快，但这取决于库中实现的质量。在我所做的测量中，我看到与search()相比，运行时间提高了20%到100倍之间。</p>
</li>
<li><p>对于文本和相当大小的子串，boyer_moore_searcher应该是最快的。与search()相比，我看到了50倍甚至100倍的改进。在有大量子串的大文本中，这始终是最快的搜索。</p>
</li>
<li><p>boyer_moore__horspool_searcher以空间换时间。它通常比boyer_moore_searcher慢，但不应该使用那么多内存。我看到的改进在不同的平台上确实有很大的不同。在一个平台上，它接近boyer_moore（比search()好50倍，比find()好10倍），而在其他平台上，对search()的改进只有2或3倍，而使用find()则快得多。</p>
</li>
<li><p>使用并行的search()与普通的search()相比，我得到了3倍的支持，看起来使用Boyer-Moore搜索器通常还是要快很多。</p>
</li>
</ul>
<p>所以我只能给出一个建议。测量! 在你的目标平台上测试典型场景。<br>这是值得的，因为你可能会得到100倍的改进（例如，我在一个有1000万个字符的字符串中搜索一个接近结尾的1000个字符的子串）。<br><code>lib/searcher1.cpp</code>中的代码还打印了不同搜索选项的测量值，这样你就可以比较你的平台上的数字。</p>
<h5><span id="23-1-2-zhi-jie-shi-yong-sou-suo-qi">23.1.2 直接使用搜索器</span><a href="#23-1-2-zhi-jie-shi-yong-sou-suo-qi" class="header-anchor">#</a></h5><p>或者，你可以使用搜索器的函数调用操作，它返回一对开始和结束的一对子序列。<br>代码看起来如下。</p>
<div class="code-wrapper"><pre><code class="hljs c++">std::boyer_moore_searcher bm{sub.<span class="hljs-built_in">begin</span>(), sub.<span class="hljs-built_in">end</span>()};
...;
<span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> begend = <span class="hljs-built_in">bm</span>(text.<span class="hljs-built_in">begin</span>(), text.<span class="hljs-built_in">end</span>());
     begend.first != text.<span class="hljs-built_in">end</span>();
     begend = <span class="hljs-built_in">bm</span>(begend.second, text.<span class="hljs-built_in">end</span>())) {
    std::cout &lt;&lt; <span class="hljs-string">"found '"</span> &lt;&lt; sub &lt;&lt; <span class="hljs-string">"' at index "</span>
        &lt;&lt; begend.first - text.<span class="hljs-built_in">begin</span>() &lt;&lt; <span class="hljs-string">'-'</span>
        &lt;&lt; begend.second - text.<span class="hljs-built_in">begin</span>() &lt;&lt; <span class="hljs-string">'\n'</span>;
}</code></pre></div>

<p>然而，由于你可以使用std::tie()将新的值重新分配给结构化绑定的 std::pair&lt;&gt;，你可以将代码简化如下:</p>
<div class="code-wrapper"><pre><code class="hljs c++">std::boyer_moore_searcher bm{sub.<span class="hljs-built_in">begin</span>(), sub.<span class="hljs-built_in">end</span>()};
...;
<span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> [beg, end] = <span class="hljs-built_in">bm</span>(text.<span class="hljs-built_in">begin</span>(), text.<span class="hljs-built_in">end</span>());
     beg != text.<span class="hljs-built_in">end</span>();
     std::<span class="hljs-built_in">tie</span>(beg,end) = <span class="hljs-built_in">bm</span>(end, text.<span class="hljs-built_in">end</span>())) {
    std::cout &lt;&lt; <span class="hljs-string">"found '"</span> &lt;&lt; sub &lt;&lt; <span class="hljs-string">"' at index "</span>
        &lt;&lt; beg - text.<span class="hljs-built_in">begin</span>() &lt;&lt; <span class="hljs-string">'-'</span>
        &lt;&lt; end - text.<span class="hljs-built_in">begin</span>() &lt;&lt; <span class="hljs-string">'\n'</span>;
}</code></pre></div>

<p>只是直接使用搜索器寻找子串的第一次出现，你可以使用如果与 初始化和结构化绑定:</p>
<div class="code-wrapper"><pre><code class="hljs c++">std::boyer_moore_searcher bm{sub.<span class="hljs-built_in">begin</span>(), sub.<span class="hljs-built_in">end</span>()};
...;
<span class="hljs-keyword">if</span> (<span class="hljs-keyword">auto</span> [beg, end] = <span class="hljs-built_in">bm</span>(text.<span class="hljs-built_in">begin</span>(), text.<span class="hljs-built_in">end</span>()); beg != text.<span class="hljs-built_in">end</span>()) {
    std::cout &lt;&lt; <span class="hljs-string">"found '"</span> &lt;&lt; sub &lt;&lt; <span class="hljs-string">"' first at index "</span>
        &lt;&lt; beg - text.<span class="hljs-built_in">begin</span>() &lt;&lt; <span class="hljs-string">'-'</span>
        &lt;&lt; end - text.<span class="hljs-built_in">begin</span>() &lt;&lt; <span class="hljs-string">'\n'</span>;
}</code></pre></div>

<h4><span id="23-2-shi-yong-tong-yong-zi-xu-lie-sou-suo-qi">23.2 使用通用子序列搜索器</span><a href="#23-2-shi-yong-tong-yong-zi-xu-lie-sou-suo-qi" class="header-anchor">#</a></h4><p>Boyer-Moore 和 Boyer-Moore-Horspool 是作为字符串搜索器开发的。 但是，C++17 采用它们作为通用算法，以便您可以使用它们在容器或范围中查找元素的子序列。<br>也就是说，您现在可以实现以下内容：</p>
<div class="code-wrapper"><pre><code class="hljs c++">std::vector&lt;<span class="hljs-type">int</span>&gt; coll;
...;
std::deque&lt;<span class="hljs-type">int</span>&gt; sub{<span class="hljs-number">0</span>, <span class="hljs-number">8</span>, <span class="hljs-number">15</span>, ...};
pos = std::<span class="hljs-built_in">search</span>(coll.<span class="hljs-built_in">begin</span>(), coll.<span class="hljs-built_in">end</span>(),
                  std::boyer_moore_searcher{sub.<span class="hljs-built_in">begin</span>(), sub.<span class="hljs-built_in">end</span>()});</code></pre></div>

<p>同样，您还可以使用搜索器的函数调用运算符：</p>
<div class="code-wrapper"><pre><code class="hljs c++">std::vector&lt;<span class="hljs-type">int</span>&gt; coll;
...;
std::deque&lt;<span class="hljs-type">int</span>&gt; sub{<span class="hljs-number">0</span>, <span class="hljs-number">8</span>, <span class="hljs-number">15</span>, ...};
std::boyer_moore_searcher bm{sub.<span class="hljs-built_in">begin</span>(), sub.<span class="hljs-built_in">end</span>()};
<span class="hljs-keyword">auto</span> [beg, end] = <span class="hljs-built_in">bm</span>(coll.<span class="hljs-built_in">begin</span>(), coll.<span class="hljs-built_in">end</span>());
<span class="hljs-keyword">if</span> (beg != coll.end) {
    std::cout &lt;&lt; <span class="hljs-string">"found subsequence at &lt;&lt; "</span> beg - coll.<span class="hljs-built_in">begin</span>() &lt;&lt; <span class="hljs-string">'\n'</span>;
}</code></pre></div>

<p>为了实现这一点，元素必须能够在哈希表中使用（即必须提供一个默认的哈希函数，并且必须支持用==来比较两个元素）。如果不是这种情况，你可以使用谓词（如下所述）。<br>再说一遍。测量发现你在性能（速度和内存）方面的好处。在尝试一些例子时，我看到了更多不同的因素。例如，使用boyer_moore_searcher可以将搜索的速度再次提高100倍（这又比使用并行算法快多了）。但是使用boyer_moore_horspool_searcher可以使搜索速度提高50倍，但也会慢2倍。<br><code>lib/searcher2.cpp</code>中的代码演示了对一个向量中的子序列的不同搜索，还打印了不同搜索选项的测量结果，这样你就可以比较 在你的平台上进行比较。</p>
<h4><span id="23-3-shi-yong-sou-suo-qi-de-wei-ci">23.3 使用搜索器的谓词</span><a href="#23-3-shi-yong-sou-suo-qi-de-wei-ci" class="header-anchor">#</a></h4><p>使用搜索时，您可以使用谓词，这可能是必要的，原因有两个：</p>
<ol>
<li><p>您想定义自己的方式来比较两个元素。</p>
</li>
<li><p>你想提供一个哈希函数，这对于 Boyer-Moore(-Horspool) 搜索器是必需的。<br> 您必须将谓词作为附加参数提供给搜索器的构造函数。 例如，这里我们不区分大小写地搜索子字符串：</p>
</li>
</ol>
  <div class="code-wrapper"><pre><code class="hljs c++">std::boyer_moore_searcher bmic{substr.<span class="hljs-built_in">begin</span>(), substr.<span class="hljs-built_in">end</span>(),
                               [](<span class="hljs-type">char</span> c){
                                   <span class="hljs-keyword">return</span> std::hash&lt;<span class="hljs-type">char</span>&gt;{}(std::<span class="hljs-built_in">toupper</span>(c));
                               },
                               [](<span class="hljs-type">char</span> c1, <span class="hljs-type">char</span> c2){
                                   <span class="hljs-keyword">return</span> std::<span class="hljs-built_in">toupper</span>(c1)==std::<span class="hljs-built_in">toupper</span>(c2);
                               }
                              };
<span class="hljs-keyword">auto</span> begend = <span class="hljs-built_in">bmic</span>(sub.<span class="hljs-built_in">begin</span>(), sub.<span class="hljs-built_in">end</span>());</code></pre></div>

<p>  在散列值之前不要忘记调用 toupper()，否则你违反了散列值对于所有值必须相同的要求，其中 operator== 产生 true。<br>  在这里，如果我们有一个类 Customer 定义如下：</p>
  <div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Customer</span> {
    ...;
    <span class="hljs-keyword">public</span>:
    <span class="hljs-built_in">Customer</span>() = <span class="hljs-keyword">default</span>;
    <span class="hljs-function">std::string <span class="hljs-title">getID</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>{
        <span class="hljs-keyword">return</span> id;
    }
    <span class="hljs-keyword">friend</span> <span class="hljs-type">bool</span> <span class="hljs-keyword">operator</span>== (<span class="hljs-type">const</span> Customer&amp; c1, <span class="hljs-type">const</span> Customer&amp; c2) {
        <span class="hljs-keyword">return</span> c1.id == c2.id;
    }
};</code></pre></div>

<p>  我们可以在Customer vector中搜索客户子序列，如下所示：</p>
  <div class="code-wrapper"><pre><code class="hljs c++">std::vector&lt;Customer&gt; customers;
...;
std::vector&lt;Customer&gt; sub{...};
...;
<span class="hljs-function">std::boyer_moore_searcher <span class="hljs-title">bmcust</span><span class="hljs-params">(sub.begin(), sub.end(),</span></span>
<span class="hljs-params"><span class="hljs-function">                                 [](<span class="hljs-type">const</span> Customer&amp; c) {</span></span>
<span class="hljs-params"><span class="hljs-function">                                     <span class="hljs-keyword">return</span> std::hash&lt;std::string&gt;{}(c.getID());</span></span>
<span class="hljs-params"><span class="hljs-function">                                 })</span></span>;
<span class="hljs-keyword">auto</span> pos = <span class="hljs-built_in">bmcust</span>(customers.<span class="hljs-built_in">begin</span>(), customers.<span class="hljs-built_in">end</span>());
<span class="hljs-keyword">if</span> (pos.first != customers.<span class="hljs-built_in">end</span>()) {
    ...;
}</code></pre></div>

<p>  但是请注意，使用谓词可能会给使用搜索器带来很大的开销，所以只有当你有大量的元素并搜索一个相当大的子序列时才值得使用它们（例如，在100万个客户的集合中寻找1000个客户的子序列）。<br>  再次强调。要有大的思维，要有大的度量。</p>
<h4><span id="23-4-hou-ji">23.4 后记</span><a href="#23-4-hou-ji" class="header-anchor">#</a></h4><p>这些搜索最初是由 Marshall Clow 在 <a target="_blank" rel="noopener" href="https://wg21.link/n3411">https://wg21.link/n3411</a> 中提出的，将 Boost.Algorithm 作为参考实现。 它们成为第一个图书馆基础 TS 的一部分。 对于 C++17，它们随后与 Beman Dawes 和 Alisdair Meredith 在 <a target="_blank" rel="noopener" href="https://wg21.link/p0220r1">https://wg21.link/p0220r1</a> 中提出的其他组件一起采用，包括 Marshall Clow 在 <a target="_blank" rel="noopener" href="https://wg21.link/p0253R1">https://wg21.link/p0253R1</a> 中提出的接口修复。</p>
<h3><span id="24-qi-ta-gong-ju-han-shu-he-suan-fa">24 其他工具函数和算法</span><a href="#24-qi-ta-gong-ju-han-shu-he-suan-fa" class="header-anchor">#</a></h3><p>C++17 提供了一些新的实用函数和算法，本章将对其进行介绍。</p>
<h4><span id="24-1-size-empty-and-data">24.1 size(), empty(), and data()</span><a href="#24-1-size-empty-and-data" class="header-anchor">#</a></h4><p>为了支持通用代码的灵活性，C++标准库提供了三个新的辅助函数：size()、empty()和data()。<br>正如其他用于泛型代码迭代范围和集合的全局辅助函数std::begin(), std::end(), 和std::advance()一样，这些函数被定义在头文件<iterator>中。</iterator></p>
<h5><span id="24-1-1-tong-yong-de-size-han-shu">24.1.1 通用的size()函数</span><a href="#24-1-1-tong-yong-de-size-han-shu" class="header-anchor">#</a></h5><p>通用的std::size()函数允许我们询问任何范围的大小，只要它有一个迭代器接口或者是一个原始数组。有了它，你可以写这样的代码:</p>
<p><code>lib/last5.hpp</code></p>
<div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">ifndef</span> LAST5_HPP</span>
<span class="hljs-meta">#<span class="hljs-keyword">define</span> LAST5_HPP</span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iterator&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span>
<span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;</span>
<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">printLast5</span><span class="hljs-params">(<span class="hljs-type">const</span> T&amp; coll)</span></span>
<span class="hljs-function"></span>{
    <span class="hljs-comment">// 计算大小:</span>
    <span class="hljs-keyword">auto</span> size{std::<span class="hljs-built_in">size</span>(coll)};
    <span class="hljs-comment">// 前进到从最后 5 个元素开始的位置</span>
    std::cout &lt;&lt; size &lt;&lt; <span class="hljs-string">" elems: "</span>;
    <span class="hljs-keyword">auto</span> pos{std::<span class="hljs-built_in">begin</span>(coll)};
    <span class="hljs-keyword">if</span> (size &gt; <span class="hljs-number">5</span>) {
        std::<span class="hljs-built_in">advance</span>(pos, size - <span class="hljs-number">5</span>);
        std::cout &lt;&lt; <span class="hljs-string">"... "</span>;
    }
    <span class="hljs-comment">// 打印剩余元素:</span>
    <span class="hljs-keyword">for</span> ( ; pos != std::<span class="hljs-built_in">end</span>(coll); ++pos) {
        std::cout &lt;&lt; *pos &lt;&lt; <span class="hljs-string">' '</span>;
    }
    std::cout &lt;&lt; <span class="hljs-string">'\n'</span>;
}
<span class="hljs-meta">#<span class="hljs-keyword">endif</span> <span class="hljs-comment">// LAST5_HPP</span></span></code></pre></div>

<p>在这里，与</p>
<div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">auto</span> size{std::<span class="hljs-built_in">size</span>(coll)};</code></pre></div>

<p>我们用传递的集合的大小来初始化 size，它要么映射到 coll.size() 要么映射到传递的原始数组的大小。 因此，如果我们调用：</p>
<div class="code-wrapper"><pre><code class="hljs c++">std::array arr{<span class="hljs-number">27</span>, <span class="hljs-number">3</span>, <span class="hljs-number">5</span>, <span class="hljs-number">8</span>, <span class="hljs-number">7</span>, <span class="hljs-number">12</span>, <span class="hljs-number">22</span>, <span class="hljs-number">0</span>, <span class="hljs-number">55</span>};
std::vector v{<span class="hljs-number">0.0</span>, <span class="hljs-number">8.8</span>, <span class="hljs-number">15.15</span>};
std::initializer_list&lt;std::string&gt; il{<span class="hljs-string">"just"</span>, <span class="hljs-string">"five"</span>, <span class="hljs-string">"small"</span>, <span class="hljs-string">"string"</span>,
                                      <span class="hljs-string">"literals"</span>};
<span class="hljs-built_in">printLast5</span>(arr);
<span class="hljs-built_in">printLast5</span>(v);
<span class="hljs-built_in">printLast5</span>(il);</code></pre></div>

<p>输出是：</p>
<div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-number">9</span> elems: ... <span class="hljs-number">7</span> <span class="hljs-number">12</span> <span class="hljs-number">22</span> <span class="hljs-number">0</span> <span class="hljs-number">55</span>
<span class="hljs-number">3</span> elems: <span class="hljs-number">0</span> <span class="hljs-number">8.8</span> <span class="hljs-number">15.15</span>
<span class="hljs-number">5</span> elems: just five small string literal</code></pre></div>

<p>并且因为支持原始 C 数组，我们也可以调用:</p>
<div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-built_in">printLast5</span>(<span class="hljs-string">"hello world"</span>);</code></pre></div>

<p>打印:</p>
<div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-number">12</span> elems: ... o r l d</code></pre></div>

<p>请注意，此函数模板因此替换了使用 countof 或 ARRAYSIZE 定义为类似以下内容的计算数组大小的常用方法：</p>
<div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">define</span> ARRAYSIZE(a) (sizeof(a)/sizeof(*(a)))</span></code></pre></div>

<p>另请注意，您不能将内联定义的初始化列表传递给 last5&lt;&gt;()。 原因是模板参数不能推导出 std::initializer_list()。 为此，您必须使用以下声明重载 last5()：</p>
<div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;</span>
<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">printLast5</span><span class="hljs-params">(<span class="hljs-type">const</span> std::initializer_list&lt;T&gt;&amp; coll)</span></span></code></pre></div>

<p>最后，请注意此代码不适用于 forward_list&lt;&gt;，因为转发列表没有成员函数 size()。 所以，如果你只想检查集合是否为空，你最好使用std::empty()，这将在后面讨论。</p>
<h5><span id="24-1-2-tong-yong-de-empty-han-shu">24.1.2 通用的empty()函数</span><a href="#24-1-2-tong-yong-de-empty-han-shu" class="header-anchor">#</a></h5><p>与新的全局 size() 类似，新的通用 std::empty() 允许我们检查容器、原始 C 数组或 std::initializer_list&lt;&gt; 是否为空。<br>因此，与上面的示例类似，您可以一般地检查传递的集合是否为空：</p>
<div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">if</span> (std::<span class="hljs-built_in">empty</span>(coll)) {
    <span class="hljs-keyword">return</span>;
}</code></pre></div>

<p>与 std::size() 相比，std::empty() 也适用于前向列表/</p>
<h5><span id="24-1-3-tong-yong-de-data-han-shu">24.1.3 通用的data()函数</span><a href="#24-1-3-tong-yong-de-data-han-shu" class="header-anchor">#</a></h5><p>最后，新的通用 std::data() 函数允许我们访问具有 data() 成员和原始数组的容器的原始数据。 容器、原始 C 数组或 std::initializer_list&lt;&gt;。<br>例如，以下代码每隔一个元素打印一次：</p>
<p><code>lib/data.hpp </code></p>
<div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">ifndef</span> DATA_HPP</span>
<span class="hljs-meta">#<span class="hljs-keyword">define</span> DATA_HPP</span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iterator&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span>
<span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;</span>
<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">printData</span><span class="hljs-params">(<span class="hljs-type">const</span> T&amp; coll)</span></span>
<span class="hljs-function"></span>{
    <span class="hljs-comment">// 每隔一个元素打印一次:</span>
    <span class="hljs-keyword">for</span> (std::<span class="hljs-type">size_t</span> idx{<span class="hljs-number">0</span>}; idx &lt; std::<span class="hljs-built_in">size</span>(coll); ++idx) {
        <span class="hljs-keyword">if</span> (idx % <span class="hljs-number">2</span> == <span class="hljs-number">0</span>) {
            std::cout &lt;&lt; std::<span class="hljs-built_in">data</span>(coll)[idx] &lt;&lt; <span class="hljs-string">' '</span>;
        }
    }
    std::cout &lt;&lt; <span class="hljs-string">'\n'</span>;
}
<span class="hljs-meta">#<span class="hljs-keyword">endif</span> <span class="hljs-comment">// DATA_HPP</span></span></code></pre></div>

<p>因此，如果我们调用：</p>
<div class="code-wrapper"><pre><code class="hljs c++">std::array arr{<span class="hljs-number">27</span>, <span class="hljs-number">3</span>, <span class="hljs-number">5</span>, <span class="hljs-number">8</span>, <span class="hljs-number">7</span>, <span class="hljs-number">12</span>, <span class="hljs-number">22</span>, <span class="hljs-number">0</span>, <span class="hljs-number">55</span>};
std::vector v{<span class="hljs-number">0.0</span>, <span class="hljs-number">8.8</span>, <span class="hljs-number">15.15</span>};
std::initializer_list&lt;std::string&gt; il{<span class="hljs-string">"just"</span>, <span class="hljs-string">"five"</span>, <span class="hljs-string">"small"</span>, <span class="hljs-string">"string"</span>,
                                      <span class="hljs-string">"literals"</span>};
<span class="hljs-built_in">printData</span>(arr);
<span class="hljs-built_in">printData</span>(v);
<span class="hljs-built_in">printData</span>(il);
<span class="hljs-built_in">printData</span>(<span class="hljs-string">"hello world"</span>);</code></pre></div>

<p>输出：</p>
<div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-number">27</span> <span class="hljs-number">5</span> <span class="hljs-number">7</span> <span class="hljs-number">22</span> <span class="hljs-number">55</span>
<span class="hljs-number">0</span> <span class="hljs-number">15.15</span>
just small literals
h l o w r d</code></pre></div>

<h4><span id="24-2-as-const">24.2 as_const()</span><a href="#24-2-as-const" class="header-anchor">#</a></h4><p>新的辅助函数 std::as_const() 将值转换为相应的 const 值，而不使用 static_cast&lt;&gt; 或 add_const_t&lt;&gt; 类型特征。<br>它允许我们强制为非 const 对象调用函数的 const 重载，以防万一：</p>
<div class="code-wrapper"><pre><code class="hljs c++">std::vector&lt;std::string&gt; coll;
<span class="hljs-built_in">foo</span>(coll); <span class="hljs-comment">// 喜欢非常量重载</span>
<span class="hljs-built_in">foo</span>(std::<span class="hljs-built_in">as_const</span>(coll)); <span class="hljs-comment">// 强制使用 const 重载</span></code></pre></div>

<p>如果 foo() 是一个函数模板，这也将强制将模板实例化为 const 类型而不是原始的非常量类型。</p>
<h5><span id="24-2-1-tong-guo-chang-liang-yin-yong-jin-xing-bu-huo">24.2.1 通过常量引用进行捕获</span><a href="#24-2-1-tong-guo-chang-liang-yin-yong-jin-xing-bu-huo" class="header-anchor">#</a></h5><p>as_const() 的一种应用是通过 const 引用捕获 lambda 参数的能力。 例如：</p>
<div class="code-wrapper"><pre><code class="hljs c++">std::vector&lt;<span class="hljs-type">int</span>&gt; coll {<span class="hljs-number">8</span>, <span class="hljs-number">15</span>, <span class="hljs-number">7</span>, <span class="hljs-number">42</span>};
<span class="hljs-keyword">auto</span> printColl = [&amp;coll = std::<span class="hljs-built_in">as_const</span>(coll)] {
    std::cout &lt;&lt; <span class="hljs-string">"coll: "</span>;
    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> elem : coll) {
        std::cout &lt;&lt; elem &lt;&lt; <span class="hljs-string">' '</span>;
    }
    std::cout &lt;&lt; <span class="hljs-string">'\n'</span>;
};</code></pre></div>

<p>现在调用:</p>
<div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-built_in">printColl</span>();</code></pre></div>

<p>将打印 coll 的当前状态，而不会有意外修改其值的危险。</p>
<h4><span id="24-3-clamp">24.3 clamp()</span><a href="#24-3-clamp" class="header-anchor">#</a></h4><p>C++17 提供了一个新的实用函数clamp()，它可以在传递的最小值和最大值之间“钳制”一个值。 它是 min() 和 max() 的组合调用。 例如：<br><code>lib/clamp.cpp</code></p>
<div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span> <span class="hljs-comment">// for sample()</span></span>
<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>
<span class="hljs-function"></span>{
    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i : {<span class="hljs-number">-7</span>, <span class="hljs-number">0</span>, <span class="hljs-number">8</span>, <span class="hljs-number">15</span>}) {
        std::cout &lt;&lt; std::<span class="hljs-built_in">clamp</span>(i, <span class="hljs-number">5</span>, <span class="hljs-number">13</span>) &lt;&lt; <span class="hljs-string">'\n'</span>;
    }
}</code></pre></div>

<p>调用clamp(i, 5, 13) 与调用std::min(std::max(i, 5), 13) 的效果相同，因此程序具有以下输出：</p>
<div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-number">5</span>
<span class="hljs-number">5</span>
<span class="hljs-number">8</span>
<span class="hljs-number">13</span></code></pre></div>

<p>至于 min() 和 max()，clamp() 要求所有通过 const 引用传递的参数都具有相同的类型 T：</p>
<div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">namespace</span> std {
    <span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;</span>
<span class="hljs-function">    <span class="hljs-keyword">constexpr</span> <span class="hljs-type">const</span> T&amp; <span class="hljs-title">clamp</span><span class="hljs-params">(<span class="hljs-type">const</span> T&amp; value, <span class="hljs-type">const</span> T&amp; min, <span class="hljs-type">const</span> T&amp; max)</span></span>;
}</code></pre></div>

<p>返回值是对传递参数之一的 const 引用。<br>如果传递不同类型的参数，则可以显式指定模板参数 T：</p>
<div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-type">double</span> d{<span class="hljs-number">4.3</span>};
<span class="hljs-type">int</span> max{<span class="hljs-number">13</span>};
...
std::<span class="hljs-built_in">clamp</span>(d, <span class="hljs-number">0</span>, max); <span class="hljs-comment">// 编译时错误</span>
std::<span class="hljs-built_in">clamp</span>&lt;<span class="hljs-type">double</span>&gt;(d, <span class="hljs-number">0</span>, max); <span class="hljs-comment">// OK</span></code></pre></div>

<p>你也可以传递浮点值，只要它们没有 NaN 值。<br>至于 min() 和 max() 你可以传递一个谓词作为比较操作。 例如：</p>
<div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i : {<span class="hljs-number">-7</span>, <span class="hljs-number">0</span>, <span class="hljs-number">8</span>, <span class="hljs-number">15</span>}) {
    std::cout &lt;&lt; std::<span class="hljs-built_in">clamp</span>(i, <span class="hljs-number">5</span>, <span class="hljs-number">13</span>,
                            [] (<span class="hljs-keyword">auto</span> a, <span class="hljs-keyword">auto</span> b) {
                                <span class="hljs-keyword">return</span> std::<span class="hljs-built_in">abs</span>(a) &lt; std::<span class="hljs-built_in">abs</span>(b);
                            })
        &lt;&lt; <span class="hljs-string">'\n'</span>;
}</code></pre></div>

<p>具有以下输出：</p>
<div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-number">-7</span>
<span class="hljs-number">5</span>
<span class="hljs-number">8</span>
<span class="hljs-number">13</span></code></pre></div>

<p>因为 -7 的绝对值介于 5 和 13 的绝对值之间，所以在这种情况下，clamp() 产生 -7。<br>没有采用值的初始化列表（如 min() 和 max() 所具有的）的 clamp() 的重载。</p>
<h4><span id="24-4-sample">24.4 sample()</span><a href="#24-4-sample" class="header-anchor">#</a></h4><p>通过sample()，C++17提供了一种算法，可以从一个给定的数值范围（群体）中提取一个随机子集（样本）。这有时被称为蓄水池采样或选择采样。<br>考虑一下下面的例子程序。</p>
<p><code>lib/sample1.cpp </code></p>
<div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iterator&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span> <span class="hljs-comment">// for clamp()</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;random&gt;</span> <span class="hljs-comment">// for default_random_engine</span></span>
<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>
<span class="hljs-function"></span>{
    <span class="hljs-comment">// 初始化一个包含 10,000 个字符串值的vector:</span>
    std::vector&lt;std::string&gt; coll;
    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10000</span>; ++i) {
        coll.<span class="hljs-built_in">push_back</span>(<span class="hljs-string">"value"</span> + std::<span class="hljs-built_in">to_string</span>(i));
    }
    <span class="hljs-comment">// 打印此集合的 10 个随机选择的值:</span>
    <span class="hljs-built_in">sample</span>(coll.<span class="hljs-built_in">begin</span>(), coll.<span class="hljs-built_in">end</span>(),
           std::ostream_iterator&lt;std::string&gt;{std::cout, <span class="hljs-string">"\n"</span>},
           <span class="hljs-number">10</span>,
           std::default_random_engine{});
}</code></pre></div>

<p>在使用大量字符串值（value0、value1、…）初始化向量后，我们使用 sample() 来提取这些字符串值的随机子集：</p>
<div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-comment">// 打印此集合的 10 个随机选择的值:</span>
<span class="hljs-built_in">sample</span>(coll.<span class="hljs-built_in">begin</span>(), coll.<span class="hljs-built_in">end</span>(),
       std::ostream_iterator&lt;std::string&gt;{std::cout, <span class="hljs-string">"\n"</span>},
       <span class="hljs-number">10</span>,
       std::default_random_engine{});</code></pre></div>

<p>我们通过：</p>
<ul>
<li>我们从中提取值子集的范围的开始和结束，</li>
<li>一个迭代器，用于将提取的值写入（这里是一个 ostream 迭代器将它们写入标准输出）</li>
<li>要提取的值的最大数量（我们可能会提取较少的值，范围太小）</li>
<li>用于计算随机子集的随机引擎</li>
</ul>
<p>结果，我们打印了 coll 的 10 个元素的随机子集。 输出可能是：</p>
<div class="code-wrapper"><pre><code class="hljs c++">value0
value488
value963
value1994
value2540
value2709
value2835
value3518
value5172
value7996</code></pre></div>

<p>如您所见，元素的顺序是稳定的（与它们在 coll 中的顺序相匹配）。 但是，只有在传递范围的迭代器至少是前向迭代器时，才能保证这一点。<br>算法声明如下：</p>
<div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">namespace</span> std {
    <span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> InputIterator, <span class="hljs-keyword">typename</span> OutputIterator,</span>
<span class="hljs-function">    <span class="hljs-keyword">typename</span> Distance, <span class="hljs-keyword">typename</span> UniformRandomBitGenerator&gt;</span>
<span class="hljs-function">        OutputIterator <span class="hljs-title">sample</span><span class="hljs-params">(InputIterator sourceBeg, InputIterator sourceEnd,</span></span>
<span class="hljs-params"><span class="hljs-function">                              OutputIterator destBeg,</span></span>
<span class="hljs-params"><span class="hljs-function">                              Distance num,</span></span>
<span class="hljs-params"><span class="hljs-function">                              UniformRandomBitGenerator&amp;&amp; eng)</span></span>;
}</code></pre></div>

<p>它具有以下规范和约束：</p>
<ul>
<li>源范围的迭代器必须至少是输入迭代器，目标范围的迭代器必须至少是输出迭代器。 但是，两者都不可能。 如果源迭代器不是最小前向迭代器，则目标迭代器必须是随机访问迭代器。</li>
<li>像往常一样，目标迭代器会覆盖，如果没有足够的元素可以覆盖并且没有使用插入器，则会导致未定义的行为。</li>
<li>该算法返回最后一个复制元素之后的位置。</li>
<li>目标迭代器不得在传递的源范围内。</li>
<li>num 可以是整数类型。 如果源范围内的元素不足，则提取源范围内的所有元素。</li>
<li>提取元素的顺序是稳定的，除非源范围内的迭代器是纯输入迭代器。</li>
</ul>
<p>这是另一个演示 sample() 用法的示例：</p>
<p><code>lib/sample2.cpp </code></p>
<div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iterator&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span> <span class="hljs-comment">// for clamp()</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;random&gt;</span> <span class="hljs-comment">// for default_random_engine</span></span>
<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>
<span class="hljs-function"></span>{
    <span class="hljs-comment">// initialize a vector of 10,000 string values:</span>
    std::vector&lt;std::string&gt; coll;
    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10000</span>; ++i) {
        coll.<span class="hljs-built_in">push_back</span>(<span class="hljs-string">"value"</span> + std::<span class="hljs-built_in">to_string</span>(i));
    }
    <span class="hljs-comment">// 使用随机种子初始化 Mersenne Twister 引擎:</span>
    std::random_device rd; <span class="hljs-comment">// 随机种子（如果支持）</span>
    std::mt19937 eng{<span class="hljs-built_in">rd</span>()}; <span class="hljs-comment">// Mersenne twister engine</span>
    <span class="hljs-comment">// 初始化目标范围（必须足够大以容纳 10 个元素）:</span>
    std::vector&lt;std::string&gt; subset;
    subset.<span class="hljs-built_in">resize</span>(<span class="hljs-number">100</span>);
    <span class="hljs-comment">// 将 10 个随机选择的值从源范围复制到目标范围:</span>
    <span class="hljs-keyword">auto</span> end = <span class="hljs-built_in">sample</span>(coll.<span class="hljs-built_in">begin</span>(), coll.<span class="hljs-built_in">end</span>(),
                      subset.<span class="hljs-built_in">begin</span>(),
                      <span class="hljs-number">10</span>,
                      eng);
    <span class="hljs-comment">// 打印提取的元素（使用返回值作为新的结束）:</span>
    for_each(subset.<span class="hljs-built_in">begin</span>(), end,
             [] (<span class="hljs-type">const</span> <span class="hljs-keyword">auto</span>&amp; s) {
                 std::cout &lt;&lt; <span class="hljs-string">"random elem: "</span> &lt;&lt; s &lt;&lt; <span class="hljs-string">'\n'</span>;
             });
}</code></pre></div>

<p>在再次用大量字符串值（value0，value1，…）初始化一个vector之后，我们初始化一个用随机种子初始化的随机数引擎：</p>
<div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-comment">// 用一个随机种子初始化一个Mersenne Twister引擎:</span>
std::random_device rd; <span class="hljs-comment">// 随机种子（如果支持）</span>
std::mt19937 eng{<span class="hljs-built_in">rd</span>()}; <span class="hljs-comment">// Mersenne Twister引擎 </span></code></pre></div>

<p>和一个目标范围:</p>
<div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-comment">// 初始化目标范围（必须足够大以容纳 10 个元素）:</span>
std::vector&lt;std::string&gt; subset;
subset.<span class="hljs-built_in">resize</span>(<span class="hljs-number">100</span>);</code></pre></div>

<p>sample() 的调用现在将源范围的 10 个元素复制到目标范围：</p>
<div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-comment">// 将 10 个随机选择的值从源范围复制到目标范围:</span>
<span class="hljs-keyword">auto</span> end = <span class="hljs-built_in">sample</span>(coll.<span class="hljs-built_in">begin</span>(), coll.<span class="hljs-built_in">end</span>(),
                  subset.<span class="hljs-built_in">begin</span>(),
                  <span class="hljs-number">10</span>,
                  eng);</code></pre></div>

<p>返回值 end 初始化为包含最后一个随机提取的元素后面的位置，之后可以使用该位置，例如，打印提取的元素：</p>
<div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-comment">// 打印提取的元素（使用返回值作为新的结束）：</span>
for_each(subset.<span class="hljs-built_in">begin</span>(), end,
         [] (<span class="hljs-type">const</span> <span class="hljs-keyword">auto</span>&amp; s) {
             std::cout &lt;&lt; <span class="hljs-string">"random elem: "</span> &lt;&lt; s &lt;&lt; <span class="hljs-string">'\n'</span>;
         });</code></pre></div>

<h4><span id="24-5-for-each-n">24.5 for_each_n()</span><a href="#24-5-for-each-n" class="header-anchor">#</a></h4><p>作为并行 STL 算法的一部分，提出了一种新算法 for_each_n()，该算法从 C++17 开始也以传统的非并行形式提供。 与 copy_n()、fill_n() 和 generate_n() 类似，它需要一个整数参数来将传递的可调用对象应用于给定范围的 n 个元素。<br>例如：<br><code>lib/foreachn.cpp</code></p>
<div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span> <span class="hljs-comment">// for for_each_n()</span></span>
<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>
<span class="hljs-function"></span>{
    <span class="hljs-comment">// 初始化一个包含 10,000 个字符串值的vector:</span>
    std::vector&lt;std::string&gt; coll;
    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10000</span>; ++i) {
        coll.<span class="hljs-built_in">push_back</span>(std::<span class="hljs-built_in">to_string</span>(i));
    }
    <span class="hljs-comment">// 修改前 5 个元素：</span>
    for_each_n(coll.<span class="hljs-built_in">begin</span>(), <span class="hljs-number">5</span>,
               [] (<span class="hljs-keyword">auto</span>&amp; elem) {
                   elem = <span class="hljs-string">"value"</span> + elem;
               });
    <span class="hljs-comment">// 打印前 10 个元素：</span>
    for_each_n(coll.<span class="hljs-built_in">begin</span>(), <span class="hljs-number">10</span>,
               [] (<span class="hljs-type">const</span> <span class="hljs-keyword">auto</span>&amp; elem) {
                   std::cout &lt;&lt; elem &lt;&lt; <span class="hljs-string">'\n'</span>;
               });
}</code></pre></div>

<p>在用大量字符串值（value0、value1、…）初始化一个vector后，我们首先修改前 5 个字符串：</p>
<div class="code-wrapper"><pre><code class="hljs c++">for_each_n(coll.<span class="hljs-built_in">begin</span>(), <span class="hljs-number">5</span>,
           [] (<span class="hljs-keyword">auto</span>&amp; elem) {
               elem = <span class="hljs-string">"value"</span> + elem;
           });</code></pre></div>

<p>然后打印前 10 个字符串：</p>
<div class="code-wrapper"><pre><code class="hljs c++">for_each_n(coll.<span class="hljs-built_in">begin</span>(), <span class="hljs-number">10</span>,
           [] (<span class="hljs-type">const</span> <span class="hljs-keyword">auto</span>&amp; elem) {
               std::cout &lt;&lt; elem &lt;&lt; <span class="hljs-string">'\n'</span>;
           });</code></pre></div>

<p>因此，该程序具有以下输出：</p>
<div class="code-wrapper"><pre><code class="hljs bash">value0
value1
value2
value3
value4
5
6
7
8
9</code></pre></div>

<p>算法声明如下：</p>
<div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">namespace</span> std {
    <span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> InputIterator, <span class="hljs-keyword">typename</span> Size, <span class="hljs-keyword">typename</span> Function&gt;</span>
<span class="hljs-function">    InputIterator <span class="hljs-title">for_each_n</span><span class="hljs-params">(InputIterator first, Size n, Function f)</span></span>;
}</code></pre></div>

<p>请注意以下事项：</p>
<ul>
<li>for_each_n() 的非并行版本保证为每个元素按顺序调用传递的可调用对象。</li>
<li>for_each_n() 算法作为迭代器返回最后处理的元素后面的位置。</li>
<li>由调用者确保给定范围有足够的元素。</li>
<li>传递的可调用对象的任何返回值都将被忽略。</li>
</ul>
<p>该算法也可用作并行 STL 算法，它允许我们将任何函数应用于前 n 个元素，而无需保证任何顺序。</p>
<h4><span id="24-6-hou-ji">24.6 后记</span><a href="#24-6-hou-ji" class="header-anchor">#</a></h4><p>size()、empty() 和 data() 最早由 Riccardo Marcangelo 在 <a target="_blank" rel="noopener" href="https://wg21.link/n4017">https://wg21.link/n4017</a> 中提出。 最终接受的措辞由 Riccardo Marcangelo 在 <a target="_blank" rel="noopener" href="https://wg21.link/n4280">https://wg21.link/n4280</a> 中制定。<br>as_const() 由 ADAM David Alan Martin 和 Alisdair Meredith 在 <a target="_blank" rel="noopener" href="https://wg21.link/n4380">https://wg21.link/n4380</a> 中首次提出。 最终接受的措辞由 ADAM David Alan Martin 和 Alisdair Meredith 在 <a target="_blank" rel="noopener" href="https://wg21.link/p0007r1">https://wg21.link/p0007r1</a> 中制定。<br>clamp() 由 Martin Moene 和 Niels Dekker 在 <a target="_blank" rel="noopener" href="https://wg21.link/n4536">https://wg21.link/n4536</a> 中首次提出。 最终接受的措辞由 Martin Moene 和 Niels Dekker 在 <a target="_blank" rel="noopener" href="https://wg21.link/p002501">https://wg21.link/p002501</a> 中制定。</p>
<p>sample() 由 Walter E. Brown 在 <a target="_blank" rel="noopener" href="https://wg21.link/n3842">https://wg21.link/n3842</a> 中首次提出。 最终接受的措辞由 Walter E. Brown 在 <a target="_blank" rel="noopener" href="https://wg21.link/n3925">https://wg21.link/n3925</a> 中制定。</p>
<h3><span id="25-rong-qi-kuo-zhan">25  容器扩展</span><a href="#25-rong-qi-kuo-zhan" class="header-anchor">#</a></h3><p>C++ 标准库的标准容器有一些细微的变化，本章将对此进行描述。</p>
<h4><span id="25-1-zhi-chi-bu-wan-zheng-de-rong-qi-lei-xing">25.1 支持不完整的容器类型</span><a href="#25-1-zhi-chi-bu-wan-zheng-de-rong-qi-lei-xing" class="header-anchor">#</a></h4><p>由于 C++17 需要 std::vector、std::list 和 std__forward_list 来支持不完整类型。<br>这样做的主要动机在 Matt Austern 的一篇名为“标准图书馆员：不完整类型的容器”的文章中进行了描述（参见 <a target="_blank" rel="noopener" href="http://drdobbs.com/184403814%EF%BC%89%EF%BC%9A%E6%82%A8%E7%8E%B0%E5%9C%A8%E5%8F%AF%E4%BB%A5%E6%8B%A5%E6%9C%89%E4%B8%80%E4%B8%AA%E7%B1%BB%E5%9E%8B%EF%BC%8C%E5%AE%83%E9%80%92%E5%BD%92%E5%9C%B0%E6%8B%A5%E6%9C%89%E4%B8%80%E4%B8%AA%E6%88%90%E5%91%98">http://drdobbs.com/184403814）：您现在可以拥有一个类型，它递归地拥有一个成员</a> 其类型的容器。 例如：</p>
<div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Node</span>
{
    std::string value;
    std::vector&lt;Node&gt; children; <span class="hljs-comment">// 好的，因为 C++17（节点在这里是不完整的类型）</span>
};</code></pre></div>

<p>这也适用于具有私有成员和公共 API 的类。 这是一个完整的例子：</p>
<p><code>lib/incomplete.hpp</code></p>
<div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">ifndef</span> NODE_HPP</span>
<span class="hljs-meta">#<span class="hljs-keyword">define</span> NODE_HPP</span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span>
<span class="hljs-keyword">class</span> <span class="hljs-title class_">Node</span>
{
<span class="hljs-keyword">private</span>:
    std::string value;
    std::vector&lt;Node&gt; children; <span class="hljs-comment">// 好的，因为 C++17（节点在这里是不完整的类型）</span>
<span class="hljs-keyword">public</span>:
    <span class="hljs-comment">// 创建一个带值的节点:</span>
    <span class="hljs-built_in">Node</span>(std::string s) : value{std::<span class="hljs-built_in">move</span>(s)}, children{} {
    }
    <span class="hljs-comment">// 添加子节点:</span>
    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">add</span><span class="hljs-params">(Node n)</span> </span>{
        children.<span class="hljs-built_in">push_back</span>(std::<span class="hljs-built_in">move</span>(n));
    }
    <span class="hljs-comment">// 访问子节点:</span>
    Node&amp; <span class="hljs-keyword">operator</span>[](std::<span class="hljs-type">size_t</span> idx) {
        <span class="hljs-keyword">return</span> children.<span class="hljs-built_in">at</span>(idx);
    }
    <span class="hljs-comment">// 递归打印节点树:</span>
    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">print</span><span class="hljs-params">(<span class="hljs-type">int</span> indent = <span class="hljs-number">0</span>)</span> <span class="hljs-type">const</span> </span>{
        std::cout &lt;&lt; std::<span class="hljs-built_in">string</span>(indent, <span class="hljs-string">' '</span>) &lt;&lt; value &lt;&lt; <span class="hljs-string">'\n'</span>;
        <span class="hljs-keyword">for</span> (<span class="hljs-type">const</span> <span class="hljs-keyword">auto</span>&amp; n : children) {
            n.<span class="hljs-built_in">print</span>(indent+<span class="hljs-number">2</span>);
        }
    }
    ...;
};
<span class="hljs-meta">#<span class="hljs-keyword">endif</span> <span class="hljs-comment">// NODE_HPP</span></span></code></pre></div>

<p>您可以使用此类，例如，如下所示：</p>
<p><code>lib/incomplete.cpp</code></p>
<div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">"incomplete.hpp"</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span>
<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>
<span class="hljs-function"></span>{
    <span class="hljs-comment">// 创建节点树:</span>
    Node root{<span class="hljs-string">"top"</span>};
    root.<span class="hljs-built_in">add</span>(Node{<span class="hljs-string">"elem1"</span>});
    root.<span class="hljs-built_in">add</span>(Node{<span class="hljs-string">"elem2"</span>});
    root[<span class="hljs-number">0</span>].<span class="hljs-built_in">add</span>(Node{<span class="hljs-string">"elem1.1"</span>});
    <span class="hljs-comment">// print node tree:</span>
    root.<span class="hljs-built_in">print</span>();
}</code></pre></div>

<p>该程序具有以下输出：</p>
<div class="code-wrapper"><pre><code class="hljs bash">top
elem1
elem1.1
elem2</code></pre></div>

<h4><span id="25-2-jie-dian-chu-li-cheng-xu">25.2 节点处理程序</span><a href="#25-2-jie-dian-chu-li-cheng-xu" class="header-anchor">#</a></h4><p>通过引入从关联或无序容器中拼接节点的能力，你可以轻松地：</p>
<ul>
<li>修改键或（无序）maps或maps或（无序）集合。</li>
<li>在（无序） sets 和 maps中使用移动语义，以及</li>
<li>在（无序）sets 和 maps之间移动元素。</li>
</ul>
<p>例如，在定义和初始化一个map后，如下所示。</p>
<div class="code-wrapper"><pre><code class="hljs c++">std::map&lt;<span class="hljs-type">int</span>, std::string&gt; m{{<span class="hljs-number">1</span>,<span class="hljs-string">"mango"</span>},
                             {<span class="hljs-number">2</span>,<span class="hljs-string">"papaya"</span>},
                             {<span class="hljs-number">3</span>,<span class="hljs-string">"guava"</span>}};</code></pre></div>

<p>您可以使用键 2 修改元素，如下所示：</p>
<div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">auto</span> nh = m.<span class="hljs-built_in">extract</span>(<span class="hljs-number">2</span>); <span class="hljs-comment">// nh 的类型为 decltype(m)::node_type</span>
nh.<span class="hljs-built_in">key</span>() = <span class="hljs-number">4</span>;
m.<span class="hljs-built_in">insert</span>(std::<span class="hljs-built_in">move</span>(nh));</code></pre></div>

<p>代码将键为 2 的元素的节点从容器中取出，修改键，然后将其移回，如图 25.1 中所述。<br>请注意，不使用内存（取消）分配，并且对元素的指针和引用保持有效。 但是，在元素保存在节点句柄中时使用指针和引用会导致未定义的行为。</p>
<p>节点句柄的类型是 container::node_type。 它为会员提供</p>
<ul>
<li>所有（无序）集合类型的value()</li>
<li>所有（无序）map类型的成员 key() 和 mapped()</li>
</ul>
<p>您还可以使用节点句柄将元素从一个容器移动到另一个容器。 容器甚至可以通过以下方式有所不同：</p>
<ul>
<li>一个支持重复，而另一个不支持（例如，您可以将元素从多地图移动到地图）</li>
<li>比较函数和散列函数可能不同</li>
</ul>
<p><img src="https://gitee.com/txt1994/images/raw/master/img/Cpp17TheCompleteGuideChinese/Figure_25.1.png" srcset="/img/loading.gif" lazyload> )</p>
<p>例子：</p>
<div class="code-wrapper"><pre><code class="hljs c++">std::multimap&lt;<span class="hljs-type">double</span>, std::string&gt; src {{<span class="hljs-number">1.1</span>,<span class="hljs-string">"one"</span>},
                                        {<span class="hljs-number">2.2</span>,<span class="hljs-string">"two"</span>},
                                        {<span class="hljs-number">3.3</span>,<span class="hljs-string">"three"</span>}};
std::map&lt;<span class="hljs-type">double</span>, std::string&gt; dst {{<span class="hljs-number">3.3</span>,<span class="hljs-string">"old data"</span>}};
<span class="hljs-comment">// 将一些元素从 multimap src 移动到 map dst:</span>
dst.<span class="hljs-built_in">insert</span>(src.<span class="hljs-built_in">extract</span>(src.<span class="hljs-built_in">find</span>(<span class="hljs-number">1.1</span>))); <span class="hljs-comment">// 使用迭代器拼接</span>
dst.<span class="hljs-built_in">insert</span>(src.<span class="hljs-built_in">extract</span>(<span class="hljs-number">2.2</span>)); <span class="hljs-comment">// 使用键拼接</span></code></pre></div>

<p>请注意， insert() 函数返回一个包含三个元素的结构（按以下顺序）：</p>
<ul>
<li>如果无法插入，则为现有元素的迭代器位置。</li>
<li>插入一个布尔值，表示插入是否成功。</li>
<li>如果无法插入，则带有节点句柄的 mode_type 节点。</li>
</ul>
<p>即，关键信息是插入的第二个成员。 使用结构化绑定，您可以按如下方式使用返回值：</p>
<div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">auto</span> [pos,done,node] = dst.<span class="hljs-built_in">insert</span>(src.<span class="hljs-built_in">extract</span>(<span class="hljs-number">3.3</span>));
<span class="hljs-keyword">if</span> (!done) {
    std::cout &lt;&lt; <span class="hljs-string">"insert() of node handle failed:"</span>
        &lt;&lt; <span class="hljs-string">" tried to insert key '"</span> &lt;&lt; node.<span class="hljs-built_in">key</span>()
        &lt;&lt; <span class="hljs-string">"' with value '"</span> &lt;&lt; node.<span class="hljs-built_in">mapped</span>()
        &lt;&lt; <span class="hljs-string">"' but key exists with value '"</span> &lt;&lt; pos-&gt;second &lt;&lt; <span class="hljs-string">"'\n"</span>;
}</code></pre></div>

<h4><span id="25-3-hou-ji">25.3 后记</span><a href="#25-3-hou-ji" class="header-anchor">#</a></h4><p>容器对不完整类型的支持首先是由 Matt Austern 在 <a target="_blank" rel="noopener" href="http://drdobbs.com/184403814">http://drdobbs.com/184403814</a> 中讨论的，最初是由袁志豪在 <a target="_blank" rel="noopener" href="https://wg21.link/n3890">https://wg21.link/n3890</a> 中提出的。 最终接受的措辞由袁志豪在 <a target="_blank" rel="noopener" href="https://wg21.link/n4510">https://wg21.link/n4510</a> 中制定。</p>
<p>节点句柄首先由 Alan Talbot 间接提出，请求拼接操作作为库问题 <a target="_blank" rel="noopener" href="https://wg21.link/lwg839">https://wg21.link/lwg839</a> 和 Alisdair Meredith 请求对节点元素的移动支持作为库问题 <a target="_blank" rel="noopener" href="https://wg21.link/lwg1041%E3%80%82">https://wg21.link/lwg1041。</a> 最终接受的措辞由 Alan Talbot、Jonathan Wakely、Howard Hinnant 和 James Dennett 在 <a target="_blank" rel="noopener" href="https://wg21.link/p0083r3">https://wg21.link/p0083r3</a> 中制定。 最终，Howard E. Hinnant 在 <a target="_blank" rel="noopener" href="https://wg21.link/p0508r0">https://wg21.link/p0508r0</a> 中稍微澄清了 API。</p>
<h3><span id="26-duo-xian-cheng-he-bing-fa">26 多线程和并发</span><a href="#26-duo-xian-cheng-he-bing-fa" class="header-anchor">#</a></h3><p>在多线程和并发领域引入了一些小的扩展和改进。</p>
<h4><span id="26-1-bu-chong-de-hu-chi-he-suo">26.1 补充的互斥和锁</span><a href="#26-1-bu-chong-de-hu-chi-he-suo" class="header-anchor">#</a></h4><h5><span id="26-1-1-std-scoped-lock">26.1.1 std::scoped_lock</span><a href="#26-1-1-std-scoped-lock" class="header-anchor">#</a></h5><p>C++11 引入了一个简单的 std::lock_guard 来以一种简单的 RAII 风格的方式来锁定互斥锁：</p>
<ul>
<li>构造函数锁</li>
<li>析构函数解锁（可能由异常引起）</li>
</ul>
<p>不幸的是，这没有标准化为可变参数模板，以便能够通过单个声明锁定多个互斥锁。<br>std::scoped_lock&lt;&gt; 弥补了这一差距。 它允许我们锁定一个或多个互斥锁。 互斥锁可能有不同的互斥锁类型。<br>例如：</p>
<div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;mutex&gt;</span></span>
...;
std::vector&lt;std::string&gt; allIssues;
std::mutex allIssuesMx;
std::vector&lt;std::string&gt; openIssues;
std::timed_mutex openIssuesMx;
<span class="hljs-comment">// lock both issue lists:</span>
{
    <span class="hljs-function">std::scoped_lock <span class="hljs-title">lg</span><span class="hljs-params">(allIssuesMx, openIssuesMx)</span></span>
<span class="hljs-function">    ...</span>; <span class="hljs-comment">// 操作 allIssues 和 openIssues</span>
}</code></pre></div>

<p>请注意，由于类模板参数推导，您在声明 lg 时不必指定互斥锁的类型。<br>此示例用法等价于以下代码，从 C++11 开始可以调用：</p>
<div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-comment">// 锁定两个问题清单:</span>
{
	std::<span class="hljs-built_in">lock</span>(allIssuesMx, openIssuesMx); <span class="hljs-comment">// 避免死锁的锁</span>
	<span class="hljs-function">std::lock_guard&lt;std::mutex&gt; <span class="hljs-title">lg1</span><span class="hljs-params">(allIssuesMx, std::adopt_lock)</span></span>;
	<span class="hljs-function">std::lock_guard&lt;std::mutex&gt; <span class="hljs-title">lg2</span><span class="hljs-params">(openIssuesMx, std::adopt_lock)</span></span>;
	... <span class="hljs-comment">// 同时操作allIssues和openIssues</span>
}</code></pre></div>

<p>因此，如果传递了多个互斥锁，则 scoped_lock 的构造函数使用可变参数便利函数 lock(…)，它保证调用不会导致死锁（标准注释：“死锁避免算法，例如 因为必须使用try-and-back-off，但没有指定具体算法以避免过度约束实现”）。<br>如果只将一个互斥锁传递给 scoped_lock 的构造函数，它只会锁定互斥锁。 因此，在具有单个构造函数参数的 scoped_lock 中，其作用类似于 lock_guard）。 然后它甚至定义了没有为多个互斥锁定义的成员 mutex_type。1 因此，您可以将 lock_guard 的所有用法替换为 scoped_lock。<br>如果没有传递互斥体，则锁守卫不起作用。<br>请注意，您还可以采用多个锁：</p>
<div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-comment">// 锁定两个问题清单:</span>
{
	std::<span class="hljs-built_in">lock</span>(allIssuesMx, openIssuesMx); <span class="hljs-comment">// 注意：使用的死锁避免算法</span>
	<span class="hljs-function">std::scoped_lock <span class="hljs-title">lg</span><span class="hljs-params">(std::adopt_lock, allIssuesMx, openIssuesMx)</span></span>;
	... <span class="hljs-comment">// 同时操作allIssues和openIssues</span>
}</code></pre></div>

<p>然而，请注意，采用锁的构造函数现在在前面有 adopt_lock 参数。</p>
<h5><span id="26-1-2-std-shared-mutex">26.1.2 std::shared_mutex</span><a href="#26-1-2-std-shared-mutex" class="header-anchor">#</a></h5><p>C++14添加了shared_timed_mutex来支持读/写锁，即多个线程同时读取一个值，而不时地有线程可能会更新这个值。因为在一些平台上，不支持定时锁的mutex可以更有效地实现，现在引入了shared_mutex类型（就像自C++11以来，除了std::timed_mutex之外，还有std::mutex存在）。<br>shared_mutex定义在头文件<shared_mutex>中，支持以下操作。</shared_mutex></p>
<ul>
<li>对于独占锁：lock(), try_lock(), unlock()</li>
<li>对于共享的读访问：lock_shared(), try_lock_shared(), unlock_shared()</li>
<li>native_handle()</li>
</ul>
<p>也就是说，与shared_times_mutex不同，它不支持try_lock_for()、try_lock_until()。try_lock_shared_for(), and try_lock_shared_until()。</p>
<h6><span id="shi-yong-shared-mutex">使用 shared_mutex</span><a href="#shi-yong-shared-mutex" class="header-anchor">#</a></h6><p>使用shared_mutex的方法如下。假设你有一个共享vector，它通常被多个线程读取，但不时地被修改：</p>
<div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;shared_mutex&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;mutex&gt;</span></span>
...
std::vector&lt;<span class="hljs-type">double</span>&gt; v; <span class="hljs-comment">// 共享资源</span>
std::shared_mutex vMutex; <span class="hljs-comment">// 控制对 v 的访问（C++14 中的 shared_timed_mutex）</span></code></pre></div>

<p>要进行共享读取访问（以便多个读取器不会相互阻塞），请使用 shared_lock，它是共享读取访问的锁保护（在 C++14 中引入）。 例如：</p>
<div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">if</span> (std::shared_lock <span class="hljs-built_in">sl</span>(vMutex); v.<span class="hljs-built_in">size</span>() &gt; <span class="hljs-number">0</span>) {
    ... <span class="hljs-comment">// （共享）对vector v 元素的读取访问</span>
}</code></pre></div>

<p>只有在排他性的写访问中，你才会使用排他性的锁防护，这可能是一个简单的lock_guard或scoped_lock（如刚刚介绍的），或者是一个复杂的unique_lock。比如说:</p>
<div class="code-wrapper"><pre><code class="hljs c++">{
    <span class="hljs-function">std::scoped_lock <span class="hljs-title">sl</span><span class="hljs-params">(vMutex)</span></span>;
    ... <span class="hljs-comment">// 对vector 的独占写读访问</span>
}</code></pre></div>

<h4><span id="26-2-yuan-zi-de-is-always-lock-free">26.2 原子的 is_always_lock_free()</span><a href="#26-2-yuan-zi-de-is-always-lock-free" class="header-anchor">#</a></h4><p>你现在可以通过一个C++库的功能来检查一个特定的原子类型是否总是可以在没有锁的情况下使用不加锁。比如说：</p>
<div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">if</span> <span class="hljs-title">constexpr</span><span class="hljs-params">(std::atomic&lt;<span class="hljs-type">int</span>&gt;::is_always_lock_free)</span> </span>{
    ...
}
<span class="hljs-keyword">else</span> {
    ...
}</code></pre></div>

<p>如果该值为真，那么对于相应的原子类型的任何对象来说，is_lock_free()产生真:</p>
<div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">if</span> <span class="hljs-title">constexpr</span><span class="hljs-params">(atomic&lt;T&gt;::is_always_lock_free)</span> </span>{
    <span class="hljs-built_in">static_assert</span>(<span class="hljs-built_in">atomic</span>&lt;T&gt;().<span class="hljs-built_in">is_lock_free</span>()); <span class="hljs-comment">// 从未失败</span>
}</code></pre></div>

<p>如果有的话，这个值与相应的宏的值相匹配，在C++17之前必须使用。<br>例如，如果且仅当ATOMIC_INT_LOCK_FREE产生2（代表 “总是”），那么std::atomic<int>::is_always_lock_free()产生true。:</int></p>
<div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">if</span> <span class="hljs-title">constexpr</span><span class="hljs-params">(std::atomic&lt;<span class="hljs-type">int</span>&gt;::is_always_lock_free)</span> </span>{
    <span class="hljs-comment">// ATOMIC_INT_LOCK_FREE == 2</span>
    ...
}
<span class="hljs-keyword">else</span> {
    <span class="hljs-comment">// ATOMIC_INT_LOCK_FREE == 0 || ATOMIC_INT_LOCK_FREE == 1</span>
    ...
}</code></pre></div>

<p>用静态成员代替宏的原因是为了有更多的类型安全，并支持在棘手的通用代码中使用这种检查（例如，使用SFINAE）。<br>请记住，std::atomic&lt;&gt;也可以用于琐碎的可复制类型。因此，你也可以检查，如果你自己的结构在原子上使用，是否需要锁。比如说：</p>
<div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">auto</span> SZ&gt;
<span class="hljs-keyword">struct</span> <span class="hljs-title class_">Data</span> {
    <span class="hljs-type">bool</span> set;
    <span class="hljs-type">int</span> values[SZ];
    <span class="hljs-type">double</span> average;
};
<span class="hljs-function"><span class="hljs-keyword">if</span> <span class="hljs-title">constexpr</span><span class="hljs-params">(std::atomic&lt;Data&lt;<span class="hljs-number">4</span>&gt;&gt;::is_always_lock_free)</span> </span>{
    ...
}
<span class="hljs-keyword">else</span> {
    ...
}</code></pre></div>

<h4><span id="26-3-huan-cun-xian-de-da-xiao">26.3 缓存线的大小</span><a href="#26-3-huan-cun-xian-de-da-xiao" class="header-anchor">#</a></h4><p>有时对于一个程序来说，处理缓存线的大小是很重要的。</p>
<ul>
<li>一方面，不同线程访问的不同对象不属于同一个缓存线，这对并发性很重要。否则，当不同的线程同时访问时，同样数量的内存必须在它们之间进行同步。</li>
<li>另一方面，你的目标可能是将多个对象放在同一个缓存线中，这样访问第一个对象就可以直接访问其他对象，而不是将它们加载到缓存中。</li>
</ul>
<p>为此，C++标准库在头文件<new>中引入了两个内联变量。</new></p>
<div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">namespace</span> std {
    <span class="hljs-keyword">inline</span> <span class="hljs-keyword">constexpr</span> <span class="hljs-type">size_t</span> hardware_destructive_interference_size;
    <span class="hljs-keyword">inline</span> <span class="hljs-keyword">constexpr</span> <span class="hljs-type">size_t</span> hardware_constructive_interference_size;
}</code></pre></div>

<p>这些对象有以下执行定义的值。</p>
<ul>
<li>hardware_destructive_interference_size是推荐的两个可能被不同线程同时访问的对象之间的最小偏移量，以避免因为同一L1缓存线受到影响而导致性能下降。</li>
<li>hardware_constructive_interference_size是推荐的两个对象放在同一L1缓存行内的最大连续内存大小。</li>
</ul>
<p>这两个值只是提示，因为理想的值可能取决于具体的架构。这些常数是编译器在处理生成的代码所支持的各种平台时所能提供的最佳值。所以，如果你知道的更多，请使用特定的值，但对于支持多种平台的代码来说，使用这些值比任何假定的固定尺寸要好。<br>这些值至少都是alignof(std::max_align_t)。通常情况下，值是相同的。然而，从语义上讲，它们代表了使用不同对象的不同目的，所以你应该使用它们 相应地使用它们，</p>
<p>如下所示: </p>
<ul>
<li>如果你想通过不同的线程访问两个不同的（原子）对象。<div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Data</span> {
    <span class="hljs-built_in">alignas</span>(std::hardware_destructive_interference_size) <span class="hljs-type">int</span> valueForOneThread;
    <span class="hljs-built_in">alignas</span>(std::hardware_destructive_interference_size) <span class="hljs-type">int</span> valueForAnotherThread;
};</code></pre></div></li>
<li>如果你想通过同一个线程访问两个不同的（原子）对象。<div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Data</span> {
    <span class="hljs-type">int</span> valueForOneThread;
    <span class="hljs-type">int</span> valueForTheSameThread;
};
<span class="hljs-comment">// 仔细检查，由于共享缓存线，我们有最好的性能。</span>
<span class="hljs-built_in">static_assert</span>(<span class="hljs-built_in">sizeof</span>(Data) &lt;= std::hardware_constructive_interference_size);
<span class="hljs-comment">// 确保对象被正确对齐。</span>
<span class="hljs-built_in">alignas</span>(<span class="hljs-built_in">sizeof</span>(Data)) Data myDataForAThread;</code></pre></div></li>
</ul>
<h4><span id="26-4-hou-ji">26.4 后记</span><a href="#26-4-hou-ji" class="header-anchor">#</a></h4><p>scoped_locks 最初是由 Mike Spertus 在 <a target="_blank" rel="noopener" href="https://wg21.link/n4470">https://wg21.link/n4470</a> 中将 lock_guard 修改为可变参数，被接受为 <a target="_blank" rel="noopener" href="https://wg21.link/p0156r0%E3%80%82%E7%84%B6%E8%80%8C%EF%BC%8C%E5%9B%A0%E4%B8%BA%E8%BF%99%E8%A2%AB%E8%AF%81%E6%98%8E%E6%98%AF">https://wg21.link/p0156r0。然而，因为这被证明是</a> ABI 破坏，新名称 scoped_lock 由 Mike Spertus 用 <a target="_blank" rel="noopener" href="https://wg21.link/p0156r2">https://wg21.link/p0156r2</a> 引入并最终被接受。 Mike Spertus、Walter E. Brown 和 Stephan T. Lavavej 后来通过 <a target="_blank" rel="noopener" href="https://wg21.link/p0739r0">https://wg21.link/p0739r0</a> 将构造函数的顺序更改为针对 C++17 的缺陷：</p>
<p>shared_mutex 最初是由 Howard Hinnant 在 <a target="_blank" rel="noopener" href="https://wg21.link/n2406">https://wg21.link/n2406</a> 中与 C++11 的所有其他互斥体一起提出的。然而，要让 C++ 标准化委员会相信所有提议的互斥锁都是有用的，需要时间。因此，最终接受的措辞是由 Gor Nishanov 在 <a target="_blank" rel="noopener" href="https://wg21.link/n4508">https://wg21.link/n4508</a> 中为 C++17 制定的。</p>
<p>std::atomic&lt;&gt; 静态成员 std::is_always_lock_free 由 Olivier Giroux、JF Bastien 和 Jeff Snyder 在 <a target="_blank" rel="noopener" href="https://wg21.link/n4509">https://wg21.link/n4509</a> 中首次提出。最终接受的措辞也是由 Olivier Giroux、JF Bastien 和 Jeff Snyder 在 <a target="_blank" rel="noopener" href="https://wg21.link/p0152r1">https://wg21.link/p0152r1</a> 中制定的。</p>
<p>JF Bastien 和 Olivier Giroux 在 <a target="_blank" rel="noopener" href="https://wg21.link/n4523">https://wg21.link/n4523</a> 中首次提出了硬件干扰（缓存线）大小。最终接受的措辞也是由 JF Bastien 和 Olivier Giroux 在 <a target="_blank" rel="noopener" href="https://wg21.link/p0154r1">https://wg21.link/p0154r1</a> 中制定的。</p>

            </div>
            <hr>
            <div>
              <div class="post-metas mb-3">
                
                
                  <div class="post-meta">
                    <i class="iconfont icon-tags"></i>
                    
                      <a class="hover-with-bg" href="/tags/C-17/">C++17</a>
                    
                      <a class="hover-with-bg" href="/tags/STL/">STL</a>
                    
                  </div>
                
              </div>
              
                <p class="note note-warning">
                  
                    本博客所有文章除特别声明外，均采用 <a target="_blank" href="https://creativecommons.org/licenses/by-sa/4.0/deed.zh" rel="nofollow noopener noopener">CC BY-SA 4.0 协议</a> ，转载请注明出处！
                  
                </p>
              
              
                <div class="post-prevnext">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/2022/03/19/%E7%AC%AC%E4%B8%80%E9%83%A8%E5%88%86%EF%BC%9A%E5%9F%BA%E6%9C%AC%E8%AF%AD%E8%A8%80%E7%89%B9%E5%BE%81/">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">第一部分-基本语言特征</span>
                        <span class="visible-mobile">上一篇</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2022/03/19/%E7%AC%AC%E4%BA%94%E9%83%A8%E5%88%86%20%E4%B8%93%E4%B8%9A%E5%B7%A5%E5%85%B7%20/">
                        <span class="hidden-mobile">第五部分-专业工具</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
              <!-- Comments -->
              <article class="comments" id="comments" lazyload>
                
                  
                
                
  <div id="lv-container" data-id="city" data-uid="MTAyMC81NTMzMi8zMTc5OQ==">
    <script type="text/javascript">
      Fluid.utils.loadComments('#lv-container', function() {
        Fluid.utils.createScript('https://cdn-city.livere.com/js/embed.dist.js');
      });
    </script>
    <noscript>Please enable JavaScript to view the comments</noscript>
  </div>


              </article>
            
          </article>
        </div>
      </div>
    </div>
    
      <div class="d-none d-lg-block col-lg-2 toc-container" id="toc-ctn">
        <div id="toc">
  <p class="toc-header"><i class="iconfont icon-list"></i>&nbsp;目录</p>
  <div class="toc-body" id="toc-body"></div>
</div>

      </div>
    
  </div>
</div>

<!-- Custom -->


    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v"
                 for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>
    

    
  </main>

  <footer class="text-center mt-5 py-3">
  <div class="footer-content">
     <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> 
  </div>
  

  

  
</footer>


  <!-- SCRIPTS -->
  
  <script  src="https://cdn.jsdelivr.net/npm/nprogress@0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/nprogress@0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js" ></script>
<script  src="https://cdn.jsdelivr.net/npm/bootstrap@4/dist/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>

<!-- Plugins -->


  <script  src="/js/local-search.js" ></script>



  
    <script  src="/js/img-lazyload.js" ></script>
  



  



  
    <script  src="https://cdn.jsdelivr.net/npm/tocbot@4/dist/tocbot.min.js" ></script>
  
  
    <script  src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3/dist/jquery.fancybox.min.js" ></script>
  
  
    <script  src="https://cdn.jsdelivr.net/npm/anchor-js@4/anchor.min.js" ></script>
  
  
    <script defer src="https://cdn.jsdelivr.net/npm/clipboard@2/dist/clipboard.min.js" ></script>
  






  <script  src="https://cdn.jsdelivr.net/npm/typed.js@2/lib/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var title = document.getElementById('subtitle').title;
      
        typing(title);
      
    })(window, document);
  </script>















<!-- 主题的启动项 保持在最底部 -->
<script  src="/js/boot.js" ></script>


</body>
</html>
