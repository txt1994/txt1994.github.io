

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=auto>



<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/logo.jpg">
  <link rel="icon" href="/img/logo.jpg">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
    <meta http-equiv="Content-Security-Policy" content="upgrade-insecure-requests">
  
  <meta name="theme-color" content="#6aa84f">
  <meta name="author" content="John Doe">
  <meta name="keywords" content="">
  
    <meta name="description" content="第二部分: 模板特性#9 类模板参数推导#C++17之前，你必须显式指定类模板的所有模板参数类型。比如，你不能忽略这里的double： std::complex&lt;double&gt; c{5.1,3.3};  也不能忽略第二次的std::mutex： std::mutex mx; std::lock_guard&lt;std::mutex&gt; lg(mx);  C++17开始，必须显式指">
<meta property="og:type" content="article">
<meta property="og:title" content="第二部分-模板特性">
<meta property="og:url" content="https://txt1994.github.io/2022/03/19/%E7%AC%AC%E4%BA%8C%E9%83%A8%E5%88%86%20%E6%A8%A1%E6%9D%BF%E7%89%B9%E6%80%A7/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:description" content="第二部分: 模板特性#9 类模板参数推导#C++17之前，你必须显式指定类模板的所有模板参数类型。比如，你不能忽略这里的double： std::complex&lt;double&gt; c{5.1,3.3};  也不能忽略第二次的std::mutex： std::mutex mx; std::lock_guard&lt;std::mutex&gt; lg(mx);  C++17开始，必须显式指">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2022-03-18T16:01:14.000Z">
<meta property="article:modified_time" content="2022-03-18T17:19:52.000Z">
<meta property="article:author" content="John Doe">
<meta property="article:tag" content="C++17">
<meta property="article:tag" content="Template">
<meta name="twitter:card" content="summary_large_image">
  
  
  <title>第二部分-模板特性 - Hexo</title>

  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4/dist/css/bootstrap.min.css" />


  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/github-markdown-css@4/github-markdown.min.css" />
  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/hint.css@2/hint.min.css" />

  
    
    
      
      <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@10/styles/github-gist.min.css" />
    
  

  
    <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3/dist/jquery.fancybox.min.css" />
  


<!-- 主题依赖的图标库，不要自行修改 -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_ba1fz6golrf.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_lbnruvf0jn.css">


<link  rel="stylesheet" href="/css/main.css" />

<!-- 自定义样式保持在最底部 -->

  
<link rel="stylesheet" href="/css/style.css">



  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    var CONFIG = {"hostname":"txt1994.github.io","root":"/","version":"1.8.14","typing":{"enable":true,"typeSpeed":70,"cursorChar":"_","loop":false},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"right","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"copy_btn":true,"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":false,"baidu":null,"google":null,"gtag":null,"tencent":{"sid":null,"cid":null},"woyaola":null,"cnzz":null,"leancloud":{"app_id":null,"app_key":null,"server_url":null,"path":"window.location.pathname","ignore_local":false}},"search_path":"/local-search.xml"};
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
<meta name="generator" content="Hexo 6.1.0">
<style>.github-emoji { position: relative; display: inline-block; width: 1.2em; min-height: 1.2em; overflow: hidden; vertical-align: top; color: transparent; }  .github-emoji > span { position: relative; z-index: 10; }  .github-emoji img, .github-emoji .fancybox { margin: 0 !important; padding: 0 !important; border: none !important; outline: none !important; text-decoration: none !important; user-select: none !important; cursor: auto !important; }  .github-emoji img { height: 1.2em !important; width: 1.2em !important; position: absolute !important; left: 50% !important; top: 50% !important; transform: translate(-50%, -50%) !important; user-select: none !important; cursor: auto !important; } .github-emoji-fallback { color: inherit; } .github-emoji-fallback img { opacity: 0 !important; }</style>
</head>


<body>
  <header style="height: 70vh;">
    <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/">
      <strong>txt1994s</strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/">
                <i class="iconfont icon-home-fill"></i>
                首页
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/">
                <i class="iconfont icon-archive-fill"></i>
                归档
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/">
                <i class="iconfont icon-tags-fill"></i>
                标签
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/">
                <i class="iconfont icon-user-fill"></i>
                关于
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/links/">
                <i class="iconfont icon-link-fill"></i>
                友联
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              &nbsp;<i class="iconfont icon-search"></i>&nbsp;
            </a>
          </li>
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">&nbsp;<i
                class="iconfont icon-dark" id="color-toggle-icon"></i>&nbsp;</a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

    <div class="banner" id="banner" parallax=true
         style="background: url('/img/default.png') no-repeat center center;
           background-size: cover;">
      <div class="full-bg-img">
        <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
          <div class="page-header text-center fade-in-up">
            <span class="h2" id="subtitle" title="第二部分-模板特性">
              
            </span>

            
              <div class="mt-3">
  
  
    <span class="post-meta">
      <i class="iconfont icon-date-fill" aria-hidden="true"></i>
      <time datetime="2022-03-19 00:01" pubdate>
        2022年3月19日 凌晨
      </time>
    </span>
  
</div>

<div class="mt-1">
  
    <span class="post-meta mr-2">
      <i class="iconfont icon-chart"></i>
      44k 字
    </span>
  

  
    <span class="post-meta mr-2">
      <i class="iconfont icon-clock-fill"></i>
      
      
      364 分钟
    </span>
  

  
  
</div>

            
          </div>

          
        </div>
      </div>
    </div>
  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="d-none d-lg-block col-lg-2"></div>
    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div class="py-5" id="board">
          <article class="post-content mx-auto">
            <!-- SEO header -->
            <h1 style="display: none">第二部分-模板特性</h1>
            
              <p class="note note-info">
                
                  本文最后更新于：2022年3月19日 凌晨
                
              </p>
            
            <div class="markdown-body">
              <h2><span id="di-er-bu-fen-mo-ban-te-xing">第二部分: 模板特性</span><a href="#di-er-bu-fen-mo-ban-te-xing" class="header-anchor">#</a></h2><h3><span id="9-lei-mo-ban-can-shu-tui-dao">9 类模板参数推导</span><a href="#9-lei-mo-ban-can-shu-tui-dao" class="header-anchor">#</a></h3><p>C++17之前，你必须显式指定类模板的所有模板参数类型。比如，你不能忽略这里的double：</p>
<div class="code-wrapper"><pre><code class="hljs c++">std::complex&lt;<span class="hljs-type">double</span>&gt; c{<span class="hljs-number">5.1</span>,<span class="hljs-number">3.3</span>};</code></pre></div>

<p>也不能忽略第二次的<code>std::mutex</code>：</p>
<div class="code-wrapper"><pre><code class="hljs c++">std::mutex mx;
<span class="hljs-function">std::lock_guard&lt;std::mutex&gt; <span class="hljs-title">lg</span><span class="hljs-params">(mx)</span></span>;</code></pre></div>

<p>C++17开始，必须显式指定类模板的所有模板参数类型这个限制变得宽松了。有了类模板参数推导（class template argument deduction，CTAD）技术，如果构造函数可以推导出所有模板参数，那么你可以跳过显式指定模板实参。</p>
<p>比如：</p>
<ul>
<li>你可以这样声明：</li>
</ul>
<div class="code-wrapper"><pre><code class="hljs c++">std::complex c{<span class="hljs-number">5.1</span>,<span class="hljs-number">3.3</span>}; <span class="hljs-comment">// 好的：推断出 std::complex&lt;double&gt;</span></code></pre></div>

<ul>
<li>你可以这样实现：</li>
</ul>
<div class="code-wrapper"><pre><code class="hljs c++">std::mutex mx;
std::lock_guard lg{mx}; <span class="hljs-comment">// OK: 推断出 std::lock_guard&lt;std_mutex&gt;</span></code></pre></div>

<ul>
<li>你甚至可以让容器推导其元素的类型：</li>
</ul>
<div class="code-wrapper"><pre><code class="hljs c++">std::vector v1 {<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>} <span class="hljs-comment">// OK: 推断出 std::vector&lt;int&gt;</span>
std::vector v2 {<span class="hljs-string">"hello"</span>, <span class="hljs-string">"world"</span>}; <span class="hljs-comment">// OK: 推断出 std::vector&lt;const char*&gt; </span></code></pre></div>

<h4><span id="9-1-lei-mo-ban-can-shu-tui-dao-de-shi-yong">9.1 类模板参数推导的使用</span><a href="#9-1-lei-mo-ban-can-shu-tui-dao-de-shi-yong" class="header-anchor">#</a></h4><p>只要传给构造函数的实参可以用来推导类型模板参数，那么就可以使用类模板参数推导技术。该技术支持所有初始化方式：</p>
<div class="code-wrapper"><pre><code class="hljs c++">std::complex c1{<span class="hljs-number">1.1</span>, <span class="hljs-number">2.2</span>}; <span class="hljs-comment">// 推断出  std::complex&lt;double&gt;</span>
<span class="hljs-function">std::complex <span class="hljs-title">c2</span><span class="hljs-params">(<span class="hljs-number">2.2</span>, <span class="hljs-number">3.3</span>)</span></span>; <span class="hljs-comment">// 推断出  std::complex&lt;double&gt;</span>
std::complex c3 = <span class="hljs-number">3.3</span>; <span class="hljs-comment">// 推断出  std::complex&lt;double&gt;</span>
std::complex c4 = {<span class="hljs-number">4.4</span>}; <span class="hljs-comment">// 推断出  std::complex&lt;double&gt;</span></code></pre></div>

<p>c3和c4的初始化方式是可行的，因为你可以传递一个值来初始化<code>std::complex&lt;&gt;</code>，这对于推导出模板参数T来说足够了，它会被用于实数和虚数部分：</p>
<div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">namespace</span> std {
    <span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;
    <span class="hljs-keyword">class</span> <span class="hljs-title class_">complex</span> {
        <span class="hljs-function"><span class="hljs-keyword">constexpr</span> <span class="hljs-title">complex</span><span class="hljs-params">(<span class="hljs-type">const</span> T&amp; re = T(), <span class="hljs-type">const</span> T&amp; im = T())</span></span>;
        ...
    }
};</code></pre></div>

<p>假设有如下声明</p>
<div class="code-wrapper"><pre><code class="hljs c++">std::complex c1{<span class="hljs-number">1.1</span>, <span class="hljs-number">2.2</span>};</code></pre></div>

<p>编译器会在调用的地方找到构造函数</p>
<div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">constexpr</span> <span class="hljs-title">complex</span><span class="hljs-params">(<span class="hljs-type">const</span> T&amp; re = T(), <span class="hljs-type">const</span> T&amp; im = T())</span></span>;</code></pre></div>

<p>因为两个参数T都是double，所以编译器推导出T是double，然后编译下面的代码：</p>
<div class="code-wrapper"><pre><code class="hljs c++">complex&lt;<span class="hljs-type">double</span>&gt;::<span class="hljs-built_in">complex</span>(<span class="hljs-type">const</span> <span class="hljs-type">double</span>&amp; re = <span class="hljs-built_in">double</span>(),
                         <span class="hljs-type">const</span> <span class="hljs-type">double</span>&amp; im = <span class="hljs-built_in">double</span>());</code></pre></div>

<p>注意模板参数必须是无歧义、可推导的。因此，下面的初始化是有问题的：</p>
<div class="code-wrapper"><pre><code class="hljs c++">std::complex c5{<span class="hljs-number">5</span>,<span class="hljs-number">3.3</span>}; <span class="hljs-comment">// 错误：尝试将 int 和 double 作为 T</span></code></pre></div>

<p>对于模板来说，不会在推导模板参数的时候做类型转换。</p>
<p>对于可变参数模板的类模板参数推导也是支持的。比如，<code>std::tuple&lt;&gt;</code>定义如下：</p>
<div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">namespace</span> std {
  <span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span>... Types&gt;
  <span class="hljs-keyword">class</span> <span class="hljs-title class_">tuple</span>;
    <span class="hljs-keyword">public</span>:
    <span class="hljs-function"><span class="hljs-keyword">constexpr</span> <span class="hljs-title">tuple</span><span class="hljs-params">(<span class="hljs-type">const</span> Types&amp;...)</span></span>;
    ...
  };
};</code></pre></div>

<p>这个声明：</p>
<div class="code-wrapper"><pre><code class="hljs c++">std::tuple t{<span class="hljs-number">42</span>, <span class="hljs-string">'x'</span>, <span class="hljs-literal">nullptr</span>};</code></pre></div>

<p>推导出的类型是<code>std::tuple</code>。</p>
<p>你也可以推导出非类型模板参数。举个例子，像下面例子中传递一个数组，在推导模板参数的时候可以同时推导出元素类型和数组大小：</p>
<div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T, <span class="hljs-type">int</span> SZ&gt;
<span class="hljs-keyword">class</span> <span class="hljs-title class_">MyClass</span> {
    <span class="hljs-keyword">public</span>:
    <span class="hljs-built_in">MyClass</span> (<span class="hljs-built_in">T</span>(&amp;)[SZ]) {
        ...
    }
};
<span class="hljs-function">MyClass <span class="hljs-title">mc</span><span class="hljs-params">(<span class="hljs-string">"hello"</span>)</span></span>; <span class="hljs-comment">// 将 T 推导出为 const char 并将 SZ 推导出为 6</span></code></pre></div>

<p>SZ推导为6，因为模板参数类型传递了一个六个字符的字符串字面值。</p>
<p>你甚至可以推导出<strong>用作基类的lambda</strong>的类型，或者推导出<strong>auto模板参数</strong>类型。</p>
<h5><span id="9-1-1-mo-ren-fu-zhi">9.1.1 默认复制</span><a href="#9-1-1-mo-ren-fu-zhi" class="header-anchor">#</a></h5><p>如果类模板参数推导发现一个行为更像是拷贝初始化，它就倾向于这么认为。比如，在用一个元素初始化<code>std::vector</code>后：</p>
<div class="code-wrapper"><pre><code class="hljs c++">std::vector v1{<span class="hljs-number">42</span>}; <span class="hljs-comment">// 带有一个元素的vector&lt;int&gt;</span></code></pre></div>

<p>用这个vector去初始化另一个vector：</p>
<div class="code-wrapper"><pre><code class="hljs c++">std::vector v2{v1}; <span class="hljs-comment">// v2 也是 vector&lt;int&gt;</span></code></pre></div>

<p>v2会被解释为<code>vector</code>而不是<code>vector&gt;</code></p>
<p>又比如，这个规则适用于下面所有初始化形式：</p>
<div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-function">std::vector <span class="hljs-title">v3</span><span class="hljs-params">(v1)</span></span>; <span class="hljs-comment">// v3 也是 vector&lt;int&gt;</span>
std::vector v4 = {v1}; <span class="hljs-comment">// v4 也是 vector&lt;int&gt;</span>
<span class="hljs-keyword">auto</span> v5 = std::vector{v1}; <span class="hljs-comment">// v5 也是 vector&lt;int&gt;</span></code></pre></div>

<p>如果传递多个元素时，就不能被解释为拷贝初始化，此时initializer list的类型会成为新vector的元素类型：</p>
<div class="code-wrapper"><pre><code class="hljs c++">std::vector vv{v, v}; <span class="hljs-comment">// vv vector&lt;vector&lt;int&gt;&gt;</span></code></pre></div>

<p>那么问题来了，如果传递可变参数模板，那么类模板参数推导会发生什么：</p>
<div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span>... Args&gt;</span>
<span class="hljs-function"><span class="hljs-keyword">auto</span> <span class="hljs-title">make_vector</span><span class="hljs-params">(<span class="hljs-type">const</span> Args&amp;... elems)</span> </span>{
    <span class="hljs-keyword">return</span> std::vector{elems...};
}

std::vector&lt;<span class="hljs-type">int</span>&gt; v{<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>};
<span class="hljs-keyword">auto</span> x1 = <span class="hljs-built_in">make_vector</span>(v, v); <span class="hljs-comment">// vector&lt;vector&lt;int&gt;&gt;</span>
<span class="hljs-keyword">auto</span> x2 = <span class="hljs-built_in">make_vector</span>(v); <span class="hljs-comment">// vector&lt;int&gt; 或vector&lt;vector&lt;int&gt;&gt; ?</span></code></pre></div>

<p>当前，不同的编译器有不同的处理方式，这个问题还在讨论中。</p>
<h5><span id="9-1-2-tui-dao-lambda-de-lei-xing">9.1.2 推导 Lambda 的类型</span><a href="#9-1-2-tui-dao-lambda-de-lei-xing" class="header-anchor">#</a></h5><p>有了类模板参数推导，我们现在终于可以用lambda的类型实例化类模板类。举个例子，我们可以提供一个泛型类，然后包装一下callback，并统计调用了多少次callback：</p>
<div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-comment">// tmpl/classarglambda.hpp</span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;utility&gt;</span> <span class="hljs-comment">// for std::forward()</span></span>

<span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> CB&gt;
<span class="hljs-keyword">class</span> <span class="hljs-title class_">CountCalls</span>
{
<span class="hljs-keyword">private</span>:
  CB callback; <span class="hljs-comment">// callback to call</span>
  <span class="hljs-type">long</span> calls = <span class="hljs-number">0</span>; <span class="hljs-comment">// counter for calls</span>
<span class="hljs-keyword">public</span>:
  <span class="hljs-built_in">CountCalls</span>(CB cb) : <span class="hljs-built_in">callback</span>(cb) {
  }
  <span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span>... Args&gt;</span>
<span class="hljs-function">  <span class="hljs-keyword">auto</span> <span class="hljs-title">operator</span><span class="hljs-params">()</span> <span class="hljs-params">(Args&amp;&amp;... args)</span> </span>{
    ++calls;
    <span class="hljs-keyword">return</span> <span class="hljs-built_in">callback</span>(std::forward&lt;Args&gt;(args)...);
  }
  <span class="hljs-function"><span class="hljs-type">long</span> <span class="hljs-title">count</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>{
    <span class="hljs-keyword">return</span> calls;
  }
};</code></pre></div>

<p>这里，构造函数接受一个callback，然后包装一下，用它的类型来推导出模板参数CB。比如，我们可以传一个lambda：</p>
<div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-function">CountCalls <span class="hljs-title">sc</span><span class="hljs-params">([](<span class="hljs-keyword">auto</span> x, <span class="hljs-keyword">auto</span> y) {</span></span>
<span class="hljs-params"><span class="hljs-function">    <span class="hljs-keyword">return</span> x &gt; y;</span></span>
<span class="hljs-params"><span class="hljs-function">})</span></span>;</code></pre></div>

<p>这意味着sc的类型被推导为<code>CountCalls</code>。</p>
<p>通过这种方式，我们可以计算传递给排序函数的sc的调用次数：</p>
<div class="code-wrapper"><pre><code class="hljs c++">std::<span class="hljs-built_in">sort</span>(v.<span class="hljs-built_in">begin</span>(), v.<span class="hljs-built_in">end</span>(),
          td::<span class="hljs-built_in">ref</span>(sc));
std::cout &lt;&lt; <span class="hljs-string">"sorted with "</span> &lt;&lt; sc.<span class="hljs-built_in">count</span>() &lt;&lt; <span class="hljs-string">" calls\n"</span>;</code></pre></div>

<p>包装后的lambda通过引用的方式传递给排序函数，因为如若不然<code>std::sort()</code>只会计算传递给他的lambda的拷贝的调用，毕竟是传值的方式。</p>
<p>然而，我没可以传递包装后的lambda给<code>std::for_each</code>，因为这个算法可以返回传递给他的callback的拷贝：</p>
<div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">auto</span> fo = std::for_each(v.<span class="hljs-built_in">begin</span>(), v.<span class="hljs-built_in">end</span>(),
                        <span class="hljs-built_in">CountCalls</span>([](<span class="hljs-keyword">auto</span> i) {
                                      std::cout &lt;&lt; <span class="hljs-string">"elem: "</span> &lt;&lt; i &lt;&lt; <span class="hljs-string">'\n'</span>;
                        }));
std::cout &lt;&lt; <span class="hljs-string">"output with "</span> &lt;&lt; fo.<span class="hljs-built_in">count</span>() &lt;&lt; <span class="hljs-string">" calls\n"</span>;</code></pre></div>

<h5><span id="9-1-3-fei-bu-fen-lei-mo-ban-can-shu-tui-dao">9.1.3 非部分类模板参数推导</span><a href="#9-1-3-fei-bu-fen-lei-mo-ban-can-shu-tui-dao" class="header-anchor">#</a></h5><p>不像函数模板那样，类模板参数不能部分推导（显示模板参数的一部分）。比如：</p>
<div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T1, <span class="hljs-keyword">typename</span> T2, <span class="hljs-keyword">typename</span> T3 = T2&gt;
<span class="hljs-keyword">class</span> C {
    <span class="hljs-keyword">public</span>:
    <span class="hljs-built_in">C</span> (T1 x = T1{}, T2 y = T2{}, T3 z = T3{}) {
        ...
    }
    ...
};
<span class="hljs-comment">// all deduced:</span>
<span class="hljs-function">C <span class="hljs-title">c1</span><span class="hljs-params">(<span class="hljs-number">22</span>, <span class="hljs-number">44.3</span>, <span class="hljs-string">"hi"</span>)</span></span>; <span class="hljs-comment">// OK：T1 是 int，T2 是 double，T3 是 const char*</span>
<span class="hljs-function">C <span class="hljs-title">c2</span><span class="hljs-params">(<span class="hljs-number">22</span>, <span class="hljs-number">44.3</span>)</span></span>; <span class="hljs-comment">// OK: T1 是 int，T2 和 T3 是 double</span>
<span class="hljs-function">C <span class="hljs-title">c3</span><span class="hljs-params">(<span class="hljs-string">"hi"</span>, <span class="hljs-string">"guy"</span>)</span></span>; <span class="hljs-comment">// OK: T1、T2 和 T3 是 const char*</span>
<span class="hljs-comment">// only some deduced:</span>
<span class="hljs-function">C&lt;string&gt; <span class="hljs-title">c4</span><span class="hljs-params">(<span class="hljs-string">"hi"</span>, <span class="hljs-string">"my"</span>)</span></span>; <span class="hljs-comment">// ERROR: 只有 T1 明确定义</span>
C&lt;&gt; <span class="hljs-built_in">c5</span>(<span class="hljs-number">22</span>, <span class="hljs-number">44.3</span>); <span class="hljs-comment">// ERROR: 既不是 T1 也不是 T2 明确定义</span>
C&lt;&gt; <span class="hljs-built_in">c6</span>(<span class="hljs-number">22</span>, <span class="hljs-number">44.3</span>, <span class="hljs-number">42</span>); <span class="hljs-comment">// ERROR: T1 和 T2 都没有明确定义</span>
<span class="hljs-comment">// all specified:</span>
C&lt;string,string,<span class="hljs-type">int</span>&gt; c7; <span class="hljs-comment">// OK: T1,T2 是字符串，T3 是整数</span>
<span class="hljs-function">C&lt;<span class="hljs-type">int</span>,string&gt; <span class="hljs-title">c8</span><span class="hljs-params">(<span class="hljs-number">52</span>, <span class="hljs-string">"my"</span>)</span></span>; <span class="hljs-comment">// OK: T1 是 int，T2 和 T3 是字符串</span>
<span class="hljs-function">C&lt;string,string&gt; <span class="hljs-title">c9</span><span class="hljs-params">(<span class="hljs-string">"a"</span>, <span class="hljs-string">"b"</span>, <span class="hljs-string">"c"</span>)</span></span>; <span class="hljs-comment">// OK: T1,T2,T3 是字符串</span></code></pre></div>

<p>因为第三个模板参数类型有默认值，所以如果已经指定了第二个就可以省略第三个。</p>
<p>如果i想知道为什么不支持偏特化，下面是造成这个抉择的原因：</p>
<div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-function">std::tuple&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">t</span><span class="hljs-params">(<span class="hljs-number">42</span>, <span class="hljs-number">43</span>)</span></span>; <span class="hljs-comment">// still ERROR</span></code></pre></div>

<p><code>std::tuple</code>是一个可变参数模板，所以你可以指定任意数量的参数。在这种情况下，到底是认为这是只指定了一个类型的而导致的错误还是有意为之很难说清。看起来是有问题的。后期有更多考量后，偏特化也有可能加入C++标准。尽管目前没有。</p>
<p>不幸的是，缺少部分特化就不能解决一个常见代码需求。对于关联容器的排序规则，或者无序容器的hash函数，我们仍然不能简单的传一个lambda：</p>
<div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-function">std::set&lt;Cust&gt; <span class="hljs-title">coll</span><span class="hljs-params">([](<span class="hljs-type">const</span> Cust&amp; x, <span class="hljs-type">const</span> Cust&amp; y) { <span class="hljs-comment">// still ERROR</span></span></span>
<span class="hljs-params"><span class="hljs-function">    <span class="hljs-keyword">return</span> x.name() &gt; y.name();</span></span>
<span class="hljs-params"><span class="hljs-function">})</span></span>;</code></pre></div>

<p>我们还是得指定lambda的类型，因此需要像下面这样写：</p>
<div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">auto</span> sortcrit = [](<span class="hljs-type">const</span> Cust&amp; x, <span class="hljs-type">const</span> Cust&amp; y) {
    <span class="hljs-keyword">return</span> x.<span class="hljs-built_in">name</span>() &gt; y.<span class="hljs-built_in">name</span>();
};
<span class="hljs-function">std::set&lt;Cust, <span class="hljs-title">decltype</span><span class="hljs-params">(sortcrit)</span>&gt; <span class="hljs-title">coll</span><span class="hljs-params">(sortcrit)</span></span>; <span class="hljs-comment">// OK</span></code></pre></div>

<h5><span id="9-1-4-lei-mo-ban-can-shu-tui-dao-dai-ti-bian-jie-de-gong-ju-han-shu">9.1.4 类模板参数推导代替便捷的工具函数。</span><a href="#9-1-4-lei-mo-ban-can-shu-tui-dao-dai-ti-bian-jie-de-gong-ju-han-shu" class="header-anchor">#</a></h5><p>有了类模板参数推导，我们可以不再使用那些目的仅是推导传的参数的类型的便捷工具函数。</p>
<p>最明显的是<code>make_pair</code>，他允许我们不指定传的参数的类型。比如，对于v：</p>
<div class="code-wrapper"><pre><code class="hljs c++">std::vector&lt;<span class="hljs-type">int</span>&gt; v;</code></pre></div>

<p>我们可以使用:</p>
<div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">auto</span> p = std::<span class="hljs-built_in">make_pair</span>(v.<span class="hljs-built_in">begin</span>(), v.<span class="hljs-built_in">end</span>());</code></pre></div>

<p>来代替</p>
<div class="code-wrapper"><pre><code class="hljs c++">std::pair&lt;<span class="hljs-keyword">typename</span> std::vector&lt;<span class="hljs-type">int</span>&gt;::iterator,<span class="hljs-keyword">typename</span> std::vector&lt;<span class="hljs-type">int</span>&gt;::iterator&gt; <span class="hljs-built_in">p</span>(v.<span class="hljs-built_in">begin</span>(), v.<span class="hljs-built_in">end</span>());</code></pre></div>

<p>现在，<code>make_pair()</code>不再需要了，可以直接这么写：</p>
<div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-function">std::pair <span class="hljs-title">p</span><span class="hljs-params">(v.begin(), v.end())</span></span>;</code></pre></div>

<p>然而，std::make_pair() 也是一个很好的例子，它证明了有时便利函数不仅仅是推导模板参数。 事实上，std::make_pair()<br>也会衰减，这尤其意味着传递的字符串文字的类型被转换为 const<br> char *：</p>
<div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">auto</span> q = std::<span class="hljs-built_in">make_pair</span>(<span class="hljs-string">"hi"</span>, <span class="hljs-string">"world"</span>); <span class="hljs-comment">// 一对指针</span></code></pre></div>

<p>在这种情况下，q 的类型为 std::pair&lt;const char*, const char*&gt;。<br>通过使用类模板参数推导，事情变得更加复杂。 让我们看看像 std::pair 这样的简单类声明的相关部分：</p>
<div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T1, <span class="hljs-keyword">typename</span> T2&gt;
<span class="hljs-keyword">struct</span> <span class="hljs-title class_">Pair1</span> {
    T1 first;
    T2 second;
    <span class="hljs-built_in">Pair1</span>(<span class="hljs-type">const</span> T1&amp; x, <span class="hljs-type">const</span> T2&amp; y) : first{x}, second{y} {
    }
};</code></pre></div>

<p>关键是元素是通过引用传递的。 并且根据语言规则，当通过引用传递模板类型的参数时，参数类型不会衰减，这就是<br>将原始数组类型转换为相应的原始指针类型的机制。 因此，在调用时：</p>
<div class="code-wrapper"><pre><code class="hljs c++">Pair1 p1{<span class="hljs-string">"hi"</span>, <span class="hljs-string">"world"</span>}; <span class="hljs-comment">// 推导出一对不同大小的数组，但是......</span></code></pre></div>

<p>T1 推导出为 char[3]，T2 推导为 char[6]。 原则上，这样的推导是有效的。<br>但是，我们使用 T1 和 T2 来声明成员 first 和 second。 结果，他们是<br>声明为：</p>
<div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-type">char</span> first[<span class="hljs-number">3</span>];
<span class="hljs-type">char</span> second[<span class="hljs-number">6</span>];</code></pre></div>

<p>并且不允许从数组的左值初始化数组。 这就像尝试编译：</p>
<div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-type">const</span> <span class="hljs-type">char</span> x[<span class="hljs-number">3</span>] = <span class="hljs-string">"hi"</span>;
<span class="hljs-type">const</span> <span class="hljs-type">char</span> y[<span class="hljs-number">6</span>] = <span class="hljs-string">"world"</span>;
<span class="hljs-type">char</span> first[<span class="hljs-number">3</span>] {x}; <span class="hljs-comment">// ERROR</span>
<span class="hljs-type">char</span> second[<span class="hljs-number">6</span>] {y}; <span class="hljs-comment">// ERROR</span></code></pre></div>

<p>请注意，在声明要按值传递的参数时，我们不会遇到这个问题：</p>
<div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T1, <span class="hljs-keyword">typename</span> T2&gt;
<span class="hljs-keyword">struct</span> <span class="hljs-title class_">Pair2</span> {
    T1 first;
    T2 second;
    <span class="hljs-built_in">Pair2</span>(T1 x, T2 y) : first{x}, second{y} {
    }
};</code></pre></div>

<p> 如果对于这种类型，我们会调用：</p>
<div class="code-wrapper"><pre><code class="hljs c++">Pair2 p2{<span class="hljs-string">"hi"</span>, <span class="hljs-string">"world"</span>}; <span class="hljs-comment">// 推导出一对指针</span></code></pre></div>

<p>T1 和 T2 都将被推导出为 const char*。<br>因为声明了类 std::pair&lt;&gt; 以便构造函数通过引用获取参数，<br>您现在可能期望以下初始化不会编译：</p>
<div class="code-wrapper"><pre><code class="hljs c++">std::pair p{<span class="hljs-string">"hi"</span>, <span class="hljs-string">"world"</span>}; <span class="hljs-comment">// 似乎推断出一对不同大小的数组，但是......</span></code></pre></div>

<p>但它编译。 原因是我们使用推到。</p>
<h4><span id="9-2-tui-dao-zhi-nan">9.2 推导指南</span><a href="#9-2-tui-dao-zhi-nan" class="header-anchor">#</a></h4><p>您可以定义特定的推导指南以提供额外的类模板参数推导<br>或修复构造函数定义的现有扣除。 例如，您可以定义每当<br>推导出 Pair3 的类型，类型推导应该像类型被传递一样操作<br>价值：</p>
<div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T1, <span class="hljs-keyword">typename</span> T2&gt;
<span class="hljs-keyword">struct</span> <span class="hljs-title class_">Pair3</span> {
    T1 first;
    T2 second;
    <span class="hljs-built_in">Pair3</span>(<span class="hljs-type">const</span> T1&amp; x, <span class="hljs-type">const</span> T2&amp; y) : first{x}, second{y} {
    }
};
<span class="hljs-comment">// 构造函数的推导指南：</span>
<span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T1, <span class="hljs-keyword">typename</span> T2&gt;</span>
<span class="hljs-function"><span class="hljs-title">Pair3</span><span class="hljs-params">(T1, T2)</span> -&gt; Pair3&lt;T1, T2&gt;</span>;</code></pre></div>

<p>在这里，在-&gt;的左边，我们声明我们要推导的东西。在这个例子中，它是由两个任意类型的对象T1和T2通过值创建一个<br>Pair3，由两个任意类型的T1和T2的对象通过值传递。在”-&gt;”的右边，我们<br>的右边定义了所产生的推理。在这个例子中，Pair3被实例化为两个类型的T1和T2。<br>你可能会说，这就是构造函数已经做的事情。然而，构造函数采用<br>参数的引用，这是不一样的。一般来说，即使在模板之外，参数<br>衰减，而通过引用传递的参数不会衰减。衰减意味着，原始<br>数组转换为指针，而顶级限定符，如const和引用，则被忽略。<br>如果没有推导指南，例如，在声明以下内容时：</p>
<div class="code-wrapper"><pre><code class="hljs c++">Pair3 p3{<span class="hljs-string">"hi"</span>, <span class="hljs-string">"world"</span>};</code></pre></div>

<p>参数 x 的类型，因此 T1 是 const char[3] 和参数 y 的类型，因此<br>T2 是 const char[6]。<br>由于推导，模板参数衰减，这意味着传递的数组或<br>字符串文字衰减为相应的指针类型。 现在，当声明以下内容时：</p>
<div class="code-wrapper"><pre><code class="hljs c++">Pair3 p3{<span class="hljs-string">"hi"</span>, <span class="hljs-string">"world"</span>};</code></pre></div>

<p>使用推导指南，它按值获取参数，以便两种类型都衰减为 const<br>char*。 声明的效果就好像我们已经声明了：</p>
<div class="code-wrapper"><pre><code class="hljs c++">Pair3&lt;<span class="hljs-type">const</span> <span class="hljs-type">char</span>*, <span class="hljs-type">const</span> <span class="hljs-type">char</span>*&gt; p3{<span class="hljs-string">"hi"</span>, <span class="hljs-string">"world"</span>};</code></pre></div>

<p>请注意，构造函数仍然通过引用获取参数。 推导指南只重要<br>用于推导模板类型。 这与类型之后的实际构造函数调用无关<br>推导出 T1 和 T2。</p>
<h5><span id="9-2-1-shi-yong-tui-dao-yin-dao-qiang-zhi-shuai-jian">9.2.1 使用推导引导强制衰减</span><a href="#9-2-1-shi-yong-tui-dao-yin-dao-qiang-zhi-shuai-jian" class="header-anchor">#</a></h5><p>正如前面的例子所展示的，一般来说，这些重载的一个非常有用的应用<br>规则是确保模板参数 T 在推导时衰减。考虑一个典型的类模板：</p>
<div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;
<span class="hljs-keyword">struct</span> <span class="hljs-title class_">C</span> {
    <span class="hljs-built_in">C</span>(<span class="hljs-type">const</span> T&amp;) {
    }
    ...
};</code></pre></div>

<p>如果我们在这里传递一个字符串字面量“hello”，则推导出 T 为字符串字面量的类型，即 const char[6]：</p>
<div class="code-wrapper"><pre><code class="hljs c++">C x{<span class="hljs-string">"hello"</span>}; <span class="hljs-comment">// T 推导出为 const char[6]</span></code></pre></div>

<p>原因是模板参数推导没有衰减到对应的指针类型，当参数通过引用传递时。<br>有一个简单的推导指南</p>
<div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt; <span class="hljs-title">C</span><span class="hljs-params">(T)</span> -&gt; C&lt;T&gt;</span>;</code></pre></div>

<p>我们解决了这个问题：</p>
<div class="code-wrapper"><pre><code class="hljs c++">C x{<span class="hljs-string">"hello"</span>}; <span class="hljs-comment">// T 推导出为 const char*</span></code></pre></div>

<p>现在，因为推导指南按值接受它，它的类型衰减了，所以”hello”<br>推导出 T 为 const char* 类型。<br>因此，对于任何类模板，相应的推导指南听起来都非常合理<br>有一个构造函数通过引用获取其模板参数的对象。 C++ 标准<br>库提供了 pair 和 tuple 的相应推导指南。</p>
<h5><span id="9-2-2-fei-mo-ban-tui-dao">9.2.2 非模板推导</span><a href="#9-2-2-fei-mo-ban-tui-dao" class="header-anchor">#</a></h5><p>推导指南不必是模板，也不必适用于构造函数。 例如，<br>给定以下结构和推导指南：</p>
<div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;
<span class="hljs-keyword">struct</span> <span class="hljs-title class_">S</span> {
    T val;
};
<span class="hljs-built_in">S</span>(<span class="hljs-type">const</span> <span class="hljs-type">char</span>*) -&gt; S&lt;std::string&gt;; <span class="hljs-comment">// 将字符串文字的 S&lt;&gt; 映射到 S&lt;std::string&gt;</span>
</code></pre></div>

<p>以下声明是可能的，其中 std::string 从 const 推导出为 T 的类型<br>char* 因为传递的字符串文字隐式转换为它：</p>
<div class="code-wrapper"><pre><code class="hljs c++">S s1{<span class="hljs-string">"hello"</span>}; <span class="hljs-comment">// OK, 等同于： S&lt;std::string&gt; s1{"hello"};</span>
S s2 = {<span class="hljs-string">"hello"</span>}; <span class="hljs-comment">// OK, 等同于: S&lt;std::string&gt; s2 = {"hello"};</span>
S s3 = S{<span class="hljs-string">"hello"</span>}; <span class="hljs-comment">// OK, 两个 S 都推断为 S&lt;std::string&gt;</span>
</code></pre></div>

<p>请注意，聚合需要列表初始化（推导有效，但不允许初始化）：</p>
<p>S s4 = “hello”;  // 错误（不能以这种方式初始化聚合）</p>
<h5><span id="9-2-3-tui-dao-yu-gou-zao-han-shu">9.2.3 推导与构造函数</span><a href="#9-2-3-tui-dao-yu-gou-zao-han-shu" class="header-anchor">#</a></h5><p>推导指南与类的构造函数竞争。类模板参数推导使用根据重载决议具有最高优先级的构造函数/指南。如果构造函数和推导指南同样匹配，则优选推导指南。</p>
<p>考虑我们有以下定义：</p>
<div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;
<span class="hljs-keyword">struct</span> <span class="hljs-title class_">C1</span> {
    <span class="hljs-built_in">C1</span>(<span class="hljs-type">const</span> T&amp;) {
    }
};
<span class="hljs-built_in">C1</span>(<span class="hljs-type">int</span>) -&gt; C1&lt;<span class="hljs-type">long</span>&gt;;</code></pre></div>

<p>当传递一个int时，使用推导指南，因为它被重载解析所青睐。<br>因此，T被推导为long：</p>
<div class="code-wrapper"><pre><code class="hljs c++">C1 x1{<span class="hljs-number">42</span>}; <span class="hljs-comment">// T 被推导为 long</span></code></pre></div>

<p>但是如果我们传递一个char，构造函数是更好的匹配（因为不需要类型转换），所以<br>我们将 T 推导出为 char：</p>
<div class="code-wrapper"><pre><code class="hljs c++">C1 x3{<span class="hljs-string">'x'</span>}; <span class="hljs-comment">// T 被推导为 char</span></code></pre></div>

<p>因为通过值匹配取参数与通过引用取参数和演绎指南同样适用于同样好的匹配，所以通常让演绎指南取<br>价值论据（这也有衰减的优势）。</p>
<h5><span id="9-2-4-xian-shi-tui-dao">9.2.4 显式推导</span><a href="#9-2-4-xian-shi-tui-dao" class="header-anchor">#</a></h5><p>一个推导指南可以被声明为是明确的。然后它只在以下情况下被忽略，即<br>显式会使初始化或转换失效。例如，鉴于:</p>
<div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;
<span class="hljs-keyword">struct</span> <span class="hljs-title class_">S</span> {
    T val;
};
<span class="hljs-function"><span class="hljs-keyword">explicit</span> <span class="hljs-title">S</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span>*)</span> -&gt; S&lt;std::string&gt;</span>;</code></pre></div>

<p>传递推导指南参数类型的 S 对象的复制初始化（使用 =）忽略<br>扣除指南。 在这里，这意味着初始化变得无效：</p>
<div class="code-wrapper"><pre><code class="hljs c++">S s1 = {<span class="hljs-string">"hello"</span>}; <span class="hljs-comment">// ERROR (推导指南被忽略，否则无效)</span></code></pre></div>

<p>直接初始化或在右侧进行显式推导仍然是可能的：</p>
<div class="code-wrapper"><pre><code class="hljs c++">S s2{<span class="hljs-string">"hello"</span>}; <span class="hljs-comment">// OK, same as: S&lt;std::string&gt; s1{"hello"};</span>
S s3 = S{<span class="hljs-string">"hello"</span>}; <span class="hljs-comment">// OK</span>
S s4 = {S{<span class="hljs-string">"hello"</span>}}; <span class="hljs-comment">// OK</span></code></pre></div>

<p>作为另一个示例，我们可以执行以下操作：</p>
<div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;
<span class="hljs-keyword">struct</span> <span class="hljs-title class_">Ptr</span>
{
    <span class="hljs-built_in">Ptr</span>(T) { std::cout &lt;&lt; <span class="hljs-string">"Ptr(T)\n"</span>; }
    <span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> U&gt;</span>
<span class="hljs-function">    <span class="hljs-title">Ptr</span><span class="hljs-params">(U)</span> </span>{ std::cout &lt;&lt; <span class="hljs-string">"Ptr(U)\n"</span>; }
};
<span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;</span>
<span class="hljs-function"><span class="hljs-keyword">explicit</span> <span class="hljs-title">Ptr</span><span class="hljs-params">(T)</span> -&gt; Ptr&lt;T*&gt;</span>;</code></pre></div>

<p>这将产生以下效果：</p>
<div class="code-wrapper"><pre><code class="hljs c++">Ptr p1{<span class="hljs-number">42</span>}; <span class="hljs-comment">// 由于推导引导推导 Ptr&lt;int*&gt;</span>
Ptr p2 = <span class="hljs-number">42</span>; <span class="hljs-comment">// 由于构造函数推导出 Ptr&lt;int&gt;</span>
<span class="hljs-type">int</span> i = <span class="hljs-number">42</span>;
Ptr p3{&amp;i}; <span class="hljs-comment">// 由于推导引导推导 Ptr&lt;int**&gt;</span>
Ptr p4 = &amp;i; <span class="hljs-comment">// 由于构造函数推导出 Ptr&lt;int*&gt;</span></code></pre></div>

<h5><span id="9-2-5-ji-he-ti-tui-dao">9.2.5 集合体推导</span><a href="#9-2-5-ji-he-ti-tui-dao" class="header-anchor">#</a></h5><p>推导指南可用于通用聚合以启用类模板参数推导<br>那里。 例如，对于：</p>
<div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;
<span class="hljs-keyword">struct</span> <span class="hljs-title class_">A</span> {
    T val;
};</code></pre></div>

<p>任何没有推导指南的类模板参数推导试验都是错误的：</p>
<div class="code-wrapper"><pre><code class="hljs c++">A i1{<span class="hljs-number">42</span>}; <span class="hljs-comment">// ERROR</span>
<span class="hljs-function">A <span class="hljs-title">s1</span><span class="hljs-params">(<span class="hljs-string">"hi"</span>)</span></span>; <span class="hljs-comment">// ERROR</span>
A s2{<span class="hljs-string">"hi"</span>}; <span class="hljs-comment">// ERROR</span>
A s3 = <span class="hljs-string">"hi"</span>; <span class="hljs-comment">// ERROR</span>
A s4 = {<span class="hljs-string">"hi"</span>}; <span class="hljs-comment">// ERROR</span></code></pre></div>

<p>您必须显式传递类型 T 的参数：</p>
<div class="code-wrapper"><pre><code class="hljs c++">A&lt;<span class="hljs-type">int</span>&gt; i2{<span class="hljs-number">42</span>};
A&lt;std::string&gt; s5 = {<span class="hljs-string">"hi"</span>};</code></pre></div>

<p>但经过推导如：</p>
<div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-built_in">A</span>(<span class="hljs-type">const</span> <span class="hljs-type">char</span>*) -&gt; A&lt;std::string&gt;;</code></pre></div>

<p>您可以按如下方式初始化聚合：</p>
<div class="code-wrapper"><pre><code class="hljs c++">A s2{<span class="hljs-string">"hi"</span>}; <span class="hljs-comment">// OK</span>
A s4 = {<span class="hljs-string">"hi"</span>}; <span class="hljs-comment">// OK</span></code></pre></div>

<p>但是，与聚合一样，您仍然需要花括号。 否则，类型 T 成功<br>推导出来，但初始化是错误的：</p>
<div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-function">A <span class="hljs-title">s1</span><span class="hljs-params">(<span class="hljs-string">"hi"</span>)</span></span>; <span class="hljs-comment">// 错误：T 是字符串，但没有聚合初始化</span>
A s3 = <span class="hljs-string">"hi"</span>; <span class="hljs-comment">// 错误：T 是字符串，但没有聚合初始化</span></code></pre></div>

<p>std::array 的推导指南是聚合推导指南的另一个示例。</p>
<h5><span id="9-2-6-biao-zhun-tui-dao">9.2.6 标准推导</span><a href="#9-2-6-biao-zhun-tui-dao" class="header-anchor">#</a></h5><p>C++ 标准库在 C++17 中引入了一些推导指南。<br>Pairs 和 Tuples 推导指南<br>正如在推导指南的动机中所介绍的那样，std::pair 需要推导指南来确保<br>类模板参数推导使用传入参数的衰减类型：</p>
<div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">namespace</span> std {
    <span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T1, <span class="hljs-keyword">typename</span> T2&gt;
    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">pair</span> {
        ...
    <span class="hljs-function"><span class="hljs-keyword">constexpr</span> <span class="hljs-title">pair</span><span class="hljs-params">(<span class="hljs-type">const</span> T1&amp; x, <span class="hljs-type">const</span> T2&amp; y)</span></span>; <span class="hljs-comment">// 引用参数</span>
        ...
    };
    <span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T1, <span class="hljs-keyword">typename</span> T2&gt;</span>
<span class="hljs-function">    <span class="hljs-title">pair</span><span class="hljs-params">(T1, T2)</span> -&gt; pair&lt;T1, T2&gt;</span>; <span class="hljs-comment">// 按值推断参数类型</span>
}
</code></pre></div>

<p>因此，声明</p>
<div class="code-wrapper"><pre><code class="hljs C++">std::pair p{<span class="hljs-string">"hi"</span>, <span class="hljs-string">"world"</span>}; <span class="hljs-comment">// 采用 const char[3] 和 const char[6] 等价于:</span>
std::pair&lt;<span class="hljs-type">const</span> <span class="hljs-type">char</span>*, <span class="hljs-type">const</span> <span class="hljs-type">char</span>*&gt; p{<span class="hljs-string">"hi"</span>, <span class="hljs-string">"world"</span>};</code></pre></div>

<p>对于可变参数类模板 std::tuple，使用相同的方法：</p>
<div class="code-wrapper"><pre><code class="hljs C++"><span class="hljs-keyword">namespace</span> std {
    <span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span>... Types&gt;
    <span class="hljs-keyword">class</span> <span class="hljs-title class_">tuple</span> {
    <span class="hljs-keyword">public</span>:
    	<span class="hljs-function"><span class="hljs-keyword">constexpr</span> <span class="hljs-title">tuple</span><span class="hljs-params">(<span class="hljs-type">const</span> Types&amp;...)</span></span>; <span class="hljs-comment">// 通过引用获取参数</span>
        <span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span>... UTypes&gt; <span class="hljs-keyword">constexpr</span> <span class="hljs-title">tuple</span><span class="hljs-params">(UTypes&amp;&amp;...)</span></span>;
        ...
    };
    <span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span>... Types&gt;</span>
<span class="hljs-function">    <span class="hljs-title">tuple</span><span class="hljs-params">(Types...)</span> -&gt; tuple&lt;Types...&gt;</span>; <span class="hljs-comment">// 按值推断参数类型</span>
};</code></pre></div>

<p>因此，声明：</p>
<div class="code-wrapper"><pre><code class="hljs c++">std::tuple t{<span class="hljs-number">42</span>, <span class="hljs-string">"hello"</span>, <span class="hljs-literal">nullptr</span>};</code></pre></div>

<p>将 t 的类型推导出为 std::tuple&lt;int, const char*, std::nullptr_t&gt;。</p>
<p>迭代器的推导：<br>为了能够从定义初始化范围的迭代器中推断出元素的类型，<br>容器对 std::vector&lt;&gt; 有如下推导指南：</p>
<div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-comment">// let std::vector&lt;&gt; 从初始化迭代器推断元素类型:</span>
<span class="hljs-keyword">namespace</span> std {
    <span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> Iterator&gt;</span>
<span class="hljs-function">    <span class="hljs-title">vector</span><span class="hljs-params">(Iterator, Iterator)</span></span>
<span class="hljs-function">    -&gt; vector&lt;<span class="hljs-keyword">typename</span> iterator_traits&lt;Iterator&gt;::value_type&gt;</span>;
}</code></pre></div>

<p>例如，这允许：</p>
<div class="code-wrapper"><pre><code class="hljs c++">std::set&lt;<span class="hljs-type">float</span>&gt; s;
<span class="hljs-function">std::vector <span class="hljs-title">v1</span><span class="hljs-params">(s.begin(), s.end())</span></span>; <span class="hljs-comment">// OK, 推导出 std::vector&lt;float&gt;</span></code></pre></div>

<p>请注意，此处使用带括号的初始化很重要。 如果使用花括号：</p>
<div class="code-wrapper"><pre><code class="hljs c++">std::vector v2{s.<span class="hljs-built_in">begin</span>(), s.<span class="hljs-built_in">end</span>()}; <span class="hljs-comment">// 注意：不推断 std::vector&lt;float&gt;</span></code></pre></div>

<p>这两个参数被视为初始化列表的元素（根据<br>重载决议规则）。 也就是说，相当于：</p>
<div class="code-wrapper"><pre><code class="hljs c++">std::vector&lt;std::set&lt;<span class="hljs-type">float</span>&gt;::iterator&gt; v2{s.<span class="hljs-built_in">begin</span>(), s.<span class="hljs-built_in">end</span>()};</code></pre></div>

<p>这样我们就初始化了一个包含两个元素的向量，第一个引用第一个元素，第二个引用表示最后一个元素后面的位置。<br>另一方面，考虑：</p>
<div class="code-wrapper"><pre><code class="hljs c++">std::vector v3{<span class="hljs-string">"hi"</span>, <span class="hljs-string">"world"</span>}; <span class="hljs-comment">// OK, 推导std::vector&lt;const char*&gt;</span>
<span class="hljs-function">std::vector <span class="hljs-title">v4</span><span class="hljs-params">(<span class="hljs-string">"hi"</span>, <span class="hljs-string">"world"</span>)</span></span>; <span class="hljs-comment">// OOPS：致命的运行时错误</span></code></pre></div>

<p>虽然 v3 的声明还使用两个元素（都是 C 字符串）初始化向量，但<br>第二个导致致命的运行时错误，这可能会导致核心转储。 问题是那个字符串<br>文字转换为字符指针，这是有效的迭代器。 因此，我们传递了两个迭代器<br>不指向同一个对象。 换句话说：我们传递了一个无效的范围。 取决于两者在哪里<br>文字被存储，你会得到一个带有任意数量元素的 std::vector<const char> 。 如果<br>它太大了你得到一个 bad_alloc 异常，或者你得到一个核心转储，因为没有距离<br>全部，或者你会得到一些存储在它们之间的未定义字符的范围。<br>因此，在初始化向量的元素时，使用花括号总是最好的。 唯一的<br>例外是传递单个向量时（首选复制构造函数）。 通过时<br>别的东西，使用括号更好。</const></p>
<h6><span id="std-array-lt-gt-tui-dao">std::array&lt;&gt; 推导</span><a href="#std-array-lt-gt-tui-dao" class="header-anchor">#</a></h6><p>一个更有趣的例子提供了 std::array&lt;&gt; 类：为了能够推导出这两个元素<br>类型和元素数量：</p>
<div class="code-wrapper"><pre><code class="hljs c++">std::array a{<span class="hljs-number">42</span>,<span class="hljs-number">45</span>,<span class="hljs-number">77</span>}; <span class="hljs-comment">// OK, 推导出 std::array&lt;int,3&gt;</span></code></pre></div>

<p>定义了以下推导指南：</p>
<div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-comment">// let std::array&lt;&gt; 推断它们的元素数量（必须具有相同的类型）:</span>
<span class="hljs-keyword">namespace</span> std {
    <span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T, <span class="hljs-keyword">typename</span>... U&gt;</span>
<span class="hljs-function">    <span class="hljs-title">array</span><span class="hljs-params">(T, U...)</span></span>
<span class="hljs-function">    -&gt; array&lt;<span class="hljs-type">enable_if_t</span>&lt;<span class="hljs-params">(is_same_v&lt;T,U&gt; &amp;&amp; ...)</span>, T&gt;,</span>
<span class="hljs-function">    <span class="hljs-params">(<span class="hljs-number">1</span> + <span class="hljs-keyword">sizeof</span>...(U))</span>&gt;</span>;
}
</code></pre></div>

<p>演绎指南使用折叠表达式</p>
<div class="code-wrapper"><pre><code class="hljs c++">(is_same_v&lt;T,U&gt; &amp;&amp; ...)</code></pre></div>

<p>确保所有传递的参数的类型相同。 因此，以下是不可能的：</p>
<div class="code-wrapper"><pre><code class="hljs c++">std::array a{<span class="hljs-number">42</span>,<span class="hljs-number">45</span>,<span class="hljs-number">77.7</span>}; <span class="hljs-comment">// ERROR: 类型不同</span></code></pre></div>

<h6><span id="wu-xu-map-tui-dao">(无序)Map推导</span><a href="#wu-xu-map-tui-dao" class="header-anchor">#</a></h6><p>可以证明获得行为正确的演绎指南所涉及的复杂性<br>通过试验为具有 key/value 对（map、multimap、<br>unordered_map，unordered_multimap）。<br>这些容器的元素具有 std::pair&lt;const keytype, valuetype&gt; 类型。 常量<br>是必要的，因为元素的位置取决于键的值，因此能够<br>修改密钥可能会在容器内产生不一致。<br>因此，C++17 标准中用于 std::map 的方法：</p>
<div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">namespace</span> std {
    <span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> Key, <span class="hljs-keyword">typename</span> T,
    <span class="hljs-keyword">typename</span> Compare = less&lt;Key&gt;,
    <span class="hljs-keyword">typename</span> Allocator = allocator&lt;pair&lt;<span class="hljs-type">const</span> Key, T&gt;&gt;&gt;
        <span class="hljs-keyword">class</span> map {
            ...
        };
}</code></pre></div>

<p>例如，为以下构造函数定义：</p>
<div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-built_in">map</span>(initializer_list&lt;pair&lt;<span class="hljs-type">const</span> Key, T&gt;&gt;,
    <span class="hljs-type">const</span> Compare&amp; = <span class="hljs-built_in">Compare</span>(),
    <span class="hljs-type">const</span> Allocator&amp; = <span class="hljs-built_in">Allocator</span>());</code></pre></div>

<p>以下推导指南：</p>
<div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">namespace</span> std {
    <span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> Key, <span class="hljs-keyword">typename</span> T,
    <span class="hljs-keyword">typename</span> Compare = less&lt;Key&gt;,
    <span class="hljs-keyword">typename</span> Allocator = allocator&lt;pair&lt;<span class="hljs-type">const</span> Key, T&gt;&gt;&gt;
        <span class="hljs-built_in">map</span>(initializer_list&lt;pair&lt;<span class="hljs-type">const</span> Key, T&gt;&gt;,
            Compare = <span class="hljs-built_in">Compare</span>(),
            Allocator = <span class="hljs-built_in">Allocator</span>())
        -&gt; map&lt;Key, T, Compare, Allocator&gt;;
}</code></pre></div>

<p>由于所有参数都是按值传递的，因此本推导指南允许传递的比较器或分配器的类型如所讨论的那样衰减。 然而，我们天真地使用了相同的参数类型，<br>意味着初始化列表采用 const 键类型。 但结果是，以下不起作用<br>正如 Ville Voutilainen 在 <a target="_blank" rel="noopener" href="https://wg21.link/lwg3025">https://wg21.link/lwg3025</a> 中指出的那样：</p>
<div class="code-wrapper"><pre><code class="hljs c++">std::pair elem1{<span class="hljs-number">1</span>,<span class="hljs-number">2</span>};
std::pair elem2{<span class="hljs-number">3</span>,<span class="hljs-number">4</span>};
...
std::map m1{elem1, elem2}; <span class="hljs-comment">// 与原始 C++17 指南有关的错误</span></code></pre></div>

<p>因为这里的元素被推导为 std::pair&lt;int,int&gt;，这与需要 const 类型作为第一对类型的推导指南不匹配。 因此，您仍然必须编写以下内容：</p>
<div class="code-wrapper"><pre><code class="hljs c++">std::map&lt;<span class="hljs-type">int</span>,<span class="hljs-type">int</span>&gt; m1{elem1, elem2}; <span class="hljs-comment">// OK, 因此，在推导指南中，应该删除 const：</span>
<span class="hljs-keyword">namespace</span> std {
    <span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> Key, <span class="hljs-keyword">typename</span> T,
    <span class="hljs-keyword">typename</span> Compare = less&lt;Key&gt;,
    <span class="hljs-keyword">typename</span> Allocator = allocator&lt;pair&lt;<span class="hljs-type">const</span> Key, T&gt;&gt;&gt;
        <span class="hljs-built_in">map</span>(initializer_list&lt;pair&lt;Key, T&gt;&gt;,
            Compare = <span class="hljs-built_in">Compare</span>(),
            Allocator = <span class="hljs-built_in">Allocator</span>())
        -&gt; map&lt;Key, T, Compare, Allocator&gt;;
}</code></pre></div>

<p>然而，为了仍然支持比较器和分配器的衰减，我们还必须重载<br>具有 const 键类型的对的推导指南。 否则将使用构造函数，以便<br>当与 const 和配对时，类模板参数推导的行为会略有不同<br>非常量键被传递。</p>
<h6><span id="zhi-neng-zhi-zhen-wu-tui-dao-zhi-nan">智能指针无推导指南</span><a href="#zhi-neng-zhi-zhen-wu-tui-dao-zhi-nan" class="header-anchor">#</a></h6><p>请注意，C++ 标准库中的某些地方没有推导指南，尽管您可能<br>期望它们可用。<br>例如，您可能希望有共享和唯一指针的推导指南，以便<br>代替：</p>
<div class="code-wrapper"><pre><code class="hljs c++">std::shared_ptr&lt;<span class="hljs-type">int</span>&gt; sp{<span class="hljs-keyword">new</span> <span class="hljs-built_in">int</span>(<span class="hljs-number">7</span>)};</code></pre></div>

<p>你可以写：</p>
<div class="code-wrapper"><pre><code class="hljs c++">std::shared_ptr sp{<span class="hljs-keyword">new</span> <span class="hljs-built_in">int</span>(<span class="hljs-number">7</span>)}; <span class="hljs-comment">// 不支持</span></code></pre></div>

<p>这不会自动工作，因为对应的构造函数是一个模板，所以没有<br>隐式推导指南适用：</p>
<div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">namespace</span> std {
    <span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt; 
    <span class="hljs-keyword">class</span> <span class="hljs-title class_">shared_ptr</span> {
        <span class="hljs-keyword">public</span>:
        ...
        <span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> Y&gt; <span class="hljs-keyword">explicit</span> <span class="hljs-title">shared_ptr</span><span class="hljs-params">(Y* p)</span></span>;
        ...
    };
}</code></pre></div>

<p>Y 是与 T 不同的模板参数，因此从构造函数推导出 Y 并不意味着<br>我们可以推导出类型 T。这是一个能够调用类似以下内容的功能：</p>
<div class="code-wrapper"><pre><code class="hljs c++">std::shared_ptr&lt;Base&gt; sp{<span class="hljs-keyword">new</span> <span class="hljs-built_in">Derived</span>(...)};</code></pre></div>

<p>相应的推导指南将很容易提供：</p>
<div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">namespace</span> std{
    <span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> Y&gt; <span class="hljs-title">shared_ptr</span><span class="hljs-params">(Y*)</span> -&gt; shared_ptr&lt;Y&gt;</span>;
}
</code></pre></div>

<p>但是，这也意味着在分配数组时会采用本指南：</p>
<div class="code-wrapper"><pre><code class="hljs c++">std::shared_ptr sp{<span class="hljs-keyword">new</span> <span class="hljs-type">int</span>[<span class="hljs-number">10</span>]}; <span class="hljs-comment">// OOPS：会推导出 shared_ptr&lt;int&gt;</span></code></pre></div>

<p>在 C++ 中，我们经常遇到令人讨厌的 C 问题，即指向一个对象的指针的类型和<br>对象数组具有或衰减为相同类型。<br>因为这个问题看起来很危险，所以 C++ 标准委员会决定不支持<br>(还没完成）。 您仍然需要调用单个对象：</p>
<div class="code-wrapper"><pre><code class="hljs c++">std::shared_ptr&lt;<span class="hljs-type">int</span>&gt; sp1{<span class="hljs-keyword">new</span> <span class="hljs-type">int</span>}; <span class="hljs-comment">// OK</span>
<span class="hljs-keyword">auto</span> sp2 = std::<span class="hljs-built_in">make_shared</span>&lt;<span class="hljs-type">int</span>&gt;(); <span class="hljs-comment">// OK</span></code></pre></div>

<p>对于数组：</p>
<div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-function">std::shared_ptr&lt;std::string&gt; <span class="hljs-title">p</span><span class="hljs-params">(<span class="hljs-keyword">new</span> std::string[<span class="hljs-number">10</span>],</span></span>
<span class="hljs-params"><span class="hljs-function">                               [](std::string* p) {</span></span>
<span class="hljs-params"><span class="hljs-function">                                   <span class="hljs-keyword">delete</span>[] p;</span></span>
<span class="hljs-params"><span class="hljs-function">                               })</span></span>;</code></pre></div>

<p>或者：</p>
<div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-function">std::shared_ptr&lt;std::string&gt; <span class="hljs-title">p</span><span class="hljs-params">(<span class="hljs-keyword">new</span> std::string[<span class="hljs-number">10</span>],</span></span>
<span class="hljs-params"><span class="hljs-function">std::default_delete&lt;std::string[]&gt;())</span></span>;</code></pre></div>

<h4><span id="9-3-hou-ji">9.3 后记</span><a href="#9-3-hou-ji" class="header-anchor">#</a></h4><p>类模板参数推导由 Michael Spertus 于 2007 年在 https 中首次提出：<br>//wg21.link/n2332。 该提案于 2013 年由 Michael Spertus 和 David Vandevoorde 在 <a target="_blank" rel="noopener" href="https://wg21.link/n3602">https://wg21.link/n3602</a> 中提出。 最终接受的措辞由迈克尔制定<br>Spertus、Faisal Vali 和 Richard Smith 在 <a target="_blank" rel="noopener" href="https://wg21.link/p0091r3">https://wg21.link/p0091r3</a> 中进行了修改<br><a target="_blank" rel="noopener" href="https://wg21.link/p0512r0">https://wg21.link/p0512r0</a> 中的 Michael Spertus、Faisal Vali 和 Richard Smith，<a target="_blank" rel="noopener" href="https://wg21.link/p0620r0">https://wg21.link/p0620r0</a> 中的 Jason Merrill，以及 Michael Spertus 和 Jason Merrill（作为缺陷报告）<br>反对 C++17) 在 <a target="_blank" rel="noopener" href="https://wg21.link/p702r1%E3%80%82">https://wg21.link/p702r1。</a><br>Michael 添加了对标准库中类模板参数推导的支持<br>Spertus、Walter E. Brown 和 Stephan T. Lavavej 在 <a target="_blank" rel="noopener" href="https://wg21.link/p0433r2">https://wg21.link/p0433r2</a> 和（作为<br><a target="_blank" rel="noopener" href="https://wg21.link/p0739r0">https://wg21.link/p0739r0</a> 中针对 C++17 的缺陷报告。 </p>
<h3><span id="10-bian-yi-shi-if">10 编译时<code>if</code></span><a href="#10-bian-yi-shi-if" class="header-anchor">#</a></h3><p>使用 if constexpr(. . . ) 语法，编译器使用编译时表达式在编译时决定是使用 if 语句的 then 部分还是 else 部分（如果有）。 另一部分（如果<br>any) 被丢弃，因此不会生成任何代码。 这并不意味着它是丢弃的部分.<br>不过，完全忽略了。 它将像未使用模板的代码一样进行检查。<br>例如：</p>
<div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span>
<span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;
<span class="hljs-function">std::string <span class="hljs-title">asString</span><span class="hljs-params">(T x)</span></span>
<span class="hljs-function"></span>{
    <span class="hljs-function"><span class="hljs-keyword">if</span> <span class="hljs-title">constexpr</span><span class="hljs-params">(std::is_same_v&lt;T, std::string&gt;)</span> </span>{
        <span class="hljs-keyword">return</span> x; <span class="hljs-comment">// 语句无效，如果没有转换为字符串</span>
    }
    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> <span class="hljs-built_in">constexpr</span>(std::is_arithmetic_v&lt;T&gt;) {
        <span class="hljs-keyword">return</span> std::<span class="hljs-built_in">to_string</span>(x); <span class="hljs-comment">// 声明无效，如果 x 不是数字</span>
    }
    <span class="hljs-keyword">else</span> {
        <span class="hljs-keyword">return</span> std::<span class="hljs-built_in">string</span>(x); <span class="hljs-comment">// 语句无效，如果没有转换为字符串</span>
    }
}</code></pre></div>

<p>在这里，我们使用这个特性在编译时决定是否只返回一个传递的字符串，调用<br>std::to_string() 获取传递的整数或浮点值，或尝试将传递的参数转换为 std::string。 因为无效调用被丢弃，下面的代码编译（其中<br>如果使用常规运行时，则不会出现这种情况）：</p>
<div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">"ifcomptime.hpp"</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span>
<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>
<span class="hljs-function"></span>{
    std::cout &lt;&lt; <span class="hljs-built_in">asString</span>(<span class="hljs-number">42</span>) &lt;&lt; <span class="hljs-string">'\n'</span>;
    std::cout &lt;&lt; <span class="hljs-built_in">asString</span>(std::<span class="hljs-built_in">string</span>(<span class="hljs-string">"hello"</span>)) &lt;&lt; <span class="hljs-string">'\n'</span>;
    std::cout &lt;&lt; <span class="hljs-built_in">asString</span>(<span class="hljs-string">"hello"</span>) &lt;&lt; <span class="hljs-string">'\n'</span>;
}</code></pre></div>

<h4><span id="10-1-bian-yi-shi-if-de-shi-ji">10.1 编译时<code>if</code>的时机</span><a href="#10-1-bian-yi-shi-if-de-shi-ji" class="header-anchor">#</a></h4><p>如果我们在刚刚介绍的示例中使用运行时 if：</p>
<div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span>
<span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;
<span class="hljs-function">std::string <span class="hljs-title">asString</span><span class="hljs-params">(T x)</span></span>
<span class="hljs-function"></span>{
    <span class="hljs-keyword">if</span> (std::is_same_v&lt;T, std::string&gt;) {
        <span class="hljs-keyword">return</span> x; <span class="hljs-comment">// ERROR, 如果没有转换为字符串</span>
    }
    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (std::is_numeric_v&lt;T&gt;) {
        <span class="hljs-keyword">return</span> std::<span class="hljs-built_in">to_string</span>(x); <span class="hljs-comment">// ERROR, 如果 x 不是数字</span>
    }
    <span class="hljs-keyword">else</span> {
        <span class="hljs-keyword">return</span> std::<span class="hljs-built_in">string</span>(x); <span class="hljs-comment">// ERROR, 如果没有转换为字符串</span>
    }
}</code></pre></div>

<p>相应的代码永远不会编译。 这是函数模板通常不编译或作为一个整体编译的规则的结果。 if 条件的检查是<br>运行时功能。 即使在编译时很明显条件必须为假，那么<br>部分必须能够编译。 因此，当传递 std::string 或字符串文字时，编译失败，<br>因为对传递的参数调用 std::to_string() 无效。 当通过一个<br>数值，编译失败，因为第三个和第三个返回语句无效。<br>现在且仅通过使用编译时 if，无法使用的 then 和 else 部分变成<br>丢弃的语句：</p>
<ul>
<li><p>当传递一个std::string 值时，第一个if 的else 部分被丢弃。</p>
</li>
<li><p>当传递一个数值时，第一个if 的then 部分和最后一个else 部分被丢弃。</p>
</li>
<li><p>当传递一个字符串文字（即类型 const char*）时，第一个和第二个 if 的 then 部分<br>被丢弃。</p>
</li>
</ul>
<p>因此，每个无效组合在编译时都不会再出现，代码编译成功。<br>请注意，丢弃的语句不会被忽略。 效果是它没有被实例化，当<br>取决于模板参数。 语法必须正确，不依赖模板参数的调用必须有效。 实际上，执行第一个翻译阶段（定义时间），<br>它检查正确的语法和所有不依赖于模板参数的名称的使用。<br>所有 static_asserts 也必须有效，即使在未编译的分支中也是如此。<br>例如：</p>
<div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;</span>
<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">foo</span><span class="hljs-params">(T t)</span></span>
<span class="hljs-function"></span>{
    <span class="hljs-function"><span class="hljs-keyword">if</span> <span class="hljs-title">constexpr</span><span class="hljs-params">(std::is_integral_v&lt;T&gt;)</span> </span>{
        <span class="hljs-keyword">if</span> (t &gt; <span class="hljs-number">0</span>) {
            <span class="hljs-built_in">foo</span>(t<span class="hljs-number">-1</span>); <span class="hljs-comment">// OK</span>
        }
    }
    <span class="hljs-keyword">else</span> {
        <span class="hljs-built_in">undeclared</span>(t); <span class="hljs-comment">// 如果未声明且未丢弃则错误（即 T 不是整数）</span>
        <span class="hljs-built_in">undeclared</span>(); <span class="hljs-comment">// 如果未声明则错误（即使已丢弃）</span>
        <span class="hljs-built_in">static_assert</span>(<span class="hljs-literal">false</span>, <span class="hljs-string">"no integral"</span>); <span class="hljs-comment">// 总是断言（即使被丢弃）</span>
    }
}</code></pre></div>

<p> 使用符合标准的编译器，此示例永远不会编译，原因有两个：</p>
<p>即使 T 是整数类型，调用</p>
<div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-built_in">undeclared</span>(); <span class="hljs-comment">// 如果未声明则错误（即使已丢弃）</span></code></pre></div>

<p>如果没有声明这样的函数，则丢弃的 else 部分是一个错误，因为这个调用没有<br>依赖于模板参数</p>
<p>调用：</p>
<div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-built_in">static_assert</span>(<span class="hljs-literal">false</span>, <span class="hljs-string">"no integral"</span>); <span class="hljs-comment">// 总是断言（即使被丢弃）</span></code></pre></div>

<p>即使它是被丢弃的 else 部分的一部分，它也总是会下降，因为这个调用再次不依赖于<br>模板参数。 重复编译时条件的静态断言会很好：</p>
<div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-built_in">static_assert</span>(!std::is_integral_v&lt;T&gt;, <span class="hljs-string">"no integral"</span>);</code></pre></div>

<p>请注意，某些编译器（例如，Visual C++ 2013 和 2015）没有正确实现或执行模板的两阶段转换。 它们将第一阶段（定义时间）的大部分时间推迟到第二阶段（实例化时间），因此无效的函数调用甚至一些语法错误都可能编译。</p>
<h4><span id="10-2-shi-yong-bian-yi-shi-if">10.2 使用编译时<code>if</code></span><a href="#10-2-shi-yong-bian-yi-shi-if" class="header-anchor">#</a></h4><p>原则上，如果条件是<br>编译时表达式。 在以下情况下，您还可以混合编译时和运行时：</p>
<div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">if</span> <span class="hljs-title">constexpr</span> <span class="hljs-params">(std::is_integral_v&lt;std::<span class="hljs-type">remove_reference_t</span>&lt;T&gt;&gt;)</span> </span>{
    <span class="hljs-keyword">if</span> (val &gt; <span class="hljs-number">10</span>) {
        <span class="hljs-function"><span class="hljs-keyword">if</span> <span class="hljs-title">constexpr</span> <span class="hljs-params">(std::numeric_limits&lt;<span class="hljs-type">char</span>&gt;::is_signed)</span> </span>{
            ...
        }
        <span class="hljs-keyword">else</span> {
            ...
        }
    }
    <span class="hljs-keyword">else</span> {
        ...
    }
}
<span class="hljs-keyword">else</span> {
    ...
}</code></pre></div>

<p>请注意，您不能在函数体之外使用 if constexpr。 因此，你不能用它来代替<br>条件预处理器指令。</p>
<h5><span id="10-2-1-bian-yi-shi-if-de-zhu-yi-shi-xiang">10.2.1 编译时<code>if</code>的注意事项</span><a href="#10-2-1-bian-yi-shi-if-de-zhu-yi-shi-xiang" class="header-anchor">#</a></h5><p>即使有可能使用 <code>compile-time if</code> ，如果可能有一些后果不是<br>很明显，这将在以下小节中讨论。</p>
<h6><span id="compile-time-if-ying-xiang-fan-hui-lei-xing"><code>compile-time if</code> 影响返回类型</span><a href="#compile-time-if-ying-xiang-fan-hui-lei-xing" class="header-anchor">#</a></h6><p><code>compile-time if</code>可能影响函数的返回类型。例如，下面的代码总是可以编译，但返回类型可能不同:</p>
<div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">auto</span> <span class="hljs-title">foo</span><span class="hljs-params">()</span></span>
<span class="hljs-function"></span>{
    <span class="hljs-function"><span class="hljs-keyword">if</span> <span class="hljs-title">constexpr</span> <span class="hljs-params">(<span class="hljs-keyword">sizeof</span>(<span class="hljs-type">int</span>) &gt; <span class="hljs-number">4</span>)</span> </span>{
        <span class="hljs-keyword">return</span> <span class="hljs-number">42</span>;
    }
    <span class="hljs-keyword">else</span> {
        <span class="hljs-keyword">return</span> <span class="hljs-number">42u</span>;
    }
}</code></pre></div>

<p>在这里，由于我们使用了auto，函数的返回类型取决于返回语句，而返回语句则<br>取决于int的大小。</p>
<ul>
<li>如果大小大于4，只有一个有效的返回语句返回42，所以返回<br>类型是int。</li>
<li>否则，只有一个返回语句返回42u，所以返回类型变成了<br>unsigned int.。</li>
</ul>
<p>这样一来，带有if constexpr的函数的返回类型可能会有更大的差别例如，如果我们跳过else部分，返回类型可能是int或void。</p>
<div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">auto</span> <span class="hljs-title">foo</span><span class="hljs-params">()</span> <span class="hljs-comment">// 返回类型可能是int或void</span></span>
<span class="hljs-function"></span>{
    <span class="hljs-function"><span class="hljs-keyword">if</span> <span class="hljs-title">constexpr</span> <span class="hljs-params">(<span class="hljs-keyword">sizeof</span>(<span class="hljs-type">int</span>) &gt; <span class="hljs-number">4</span>)</span> </span>{ 
        <span class="hljs-keyword">return</span> <span class="hljs-number">42</span>;
    }
}</code></pre></div>

<p>请注意，如果这里使用了<code>compile-time if</code>，这段代码永远不会被编译，因为那样的话，两个返回语句都会被考虑在内，这样一来，对返回类型的推断就会变得模糊不清了。</p>
<h6><span id="else-matters-even-if-then-returns">else Matters Even if then Returns</span><a href="#else-matters-even-if-then-returns" class="header-anchor">#</a></h6><p>对于<code>compile-time if</code>语句，有一种模式不适用于<code>compile-time if</code>语句。如果<br>代码的then和else部分都有返回语句，你可以跳过<code>compile-time if</code>语句中的else语句。也就是说，不要用:</p>
<div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">if</span> (...) {
    <span class="hljs-keyword">return</span> a;
}
<span class="hljs-keyword">else</span> {
    <span class="hljs-keyword">return</span> b;
}</code></pre></div>

<p>你总是可以写:</p>
<div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">if</span> (...) {
    <span class="hljs-keyword">return</span> a;
}
<span class="hljs-keyword">return</span> b;</code></pre></div>

<p>如果条件为真（int的大小大于4），编译器会推断出两种不同的返回类型，这是不成立的。否则，我们只有一个重要的返回语句，这样代码就可以编译了。</p>
<h6><span id="duan-hui-lu-compile-time-tiao-jian">短回路<code>compile-time</code>条件</span><a href="#duan-hui-lu-compile-time-tiao-jian" class="header-anchor">#</a></h6><p>考虑以下代码：</p>
<div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;</span>
<span class="hljs-function"><span class="hljs-keyword">constexpr</span> <span class="hljs-keyword">auto</span> <span class="hljs-title">foo</span><span class="hljs-params">(<span class="hljs-type">const</span> T&amp; val)</span></span>
<span class="hljs-function"></span>{
    <span class="hljs-function"><span class="hljs-keyword">if</span> <span class="hljs-title">constexpr</span> <span class="hljs-params">(std::is_integral&lt;T&gt;::value)</span> </span>{ 
        <span class="hljs-function"><span class="hljs-keyword">if</span> <span class="hljs-title">constexpr</span> <span class="hljs-params">(T{} &lt; <span class="hljs-number">10</span>)</span> </span>{
            <span class="hljs-keyword">return</span> val * <span class="hljs-number">2</span>;
        }
    }
    <span class="hljs-keyword">return</span> val;
}</code></pre></div>

<p>这里我们有两个compile-time条件来决定是按原样返回传递的值还是加倍。</p>
<p>这为两者编译：</p>
<div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">constexpr</span> <span class="hljs-keyword">auto</span> x1 = <span class="hljs-built_in">foo</span>(<span class="hljs-number">42</span>); <span class="hljs-comment">// yields 84</span>
<span class="hljs-keyword">constexpr</span> <span class="hljs-keyword">auto</span> x2 = <span class="hljs-built_in">foo</span>(<span class="hljs-string">"hi"</span>); <span class="hljs-comment">// OK, yields ”hi”</span></code></pre></div>

<p>运行时ifs中的条件是短路的（评估带有&amp;&amp;的条件只到第一个<code>false</code>，评估带有||的条件只到第一个<code>true</code>）。这可能会导致人们期望<code>compile-time if</code>也是这种情况:</p>
<div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;</span>
<span class="hljs-function"><span class="hljs-keyword">constexpr</span> <span class="hljs-keyword">auto</span> <span class="hljs-title">bar</span><span class="hljs-params">(<span class="hljs-type">const</span> T&amp; val)</span></span>
<span class="hljs-function"></span>{
    <span class="hljs-function"><span class="hljs-keyword">if</span> <span class="hljs-title">constexpr</span> <span class="hljs-params">(std::is_integral&lt;T&gt;::value &amp;&amp; T{} &lt; <span class="hljs-number">10</span>)</span> </span>{ 
        <span class="hljs-keyword">return</span> val * <span class="hljs-number">2</span>;                                 
    }
    <span class="hljs-keyword">return</span> val;
}</code></pre></div>

<p>然而，<code>compile-time if</code>的条件总是被实例化的，并且需要整体有效，因此，传递一个不支持&lt;10的类型不再能编译:</p>
<div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">constexpr</span> <span class="hljs-keyword">auto</span> x2 = <span class="hljs-built_in">bar</span>(<span class="hljs-string">"hi"</span>); <span class="hljs-comment">// compile-time ERROR</span></code></pre></div>

<p>因此，<code>compile-time if</code>不会使实例化short-circuit。 如果编译时条件的有效性依赖于较早的编译时条件，则必须像在 foo() 中那样嵌套它们。 作为另一个例子，你必须写：</p>
<div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">if</span> <span class="hljs-title">constexpr</span> <span class="hljs-params">(std::is_same_v&lt;MyType, T&gt;)</span> </span>{ 
    <span class="hljs-function"><span class="hljs-keyword">if</span> <span class="hljs-title">constexpr</span> <span class="hljs-params">(T::i == <span class="hljs-number">42</span>)</span> </span>{
        ...
    }
}</code></pre></div>

<p>而不仅仅是：</p>
<div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">if</span> <span class="hljs-title">constexpr</span> <span class="hljs-params">(std::is_same_v&lt;MyType, T&gt; &amp;&amp; T::i == <span class="hljs-number">42</span>)</span> </span>{
    ...
}</code></pre></div>

<h5><span id="10-2-2-qi-ta-bian-yi-shi-if-de-li-zi">10.2.2 其他编译时<code>if</code>的例子</span><a href="#10-2-2-qi-ta-bian-yi-shi-if-de-li-zi" class="header-anchor">#</a></h5><p>编译时的一种应用是返回值的完美转发，当它们必须得到处理才能返回时。 因为 void 不能推导出 decltype(auto) （因为 void 是一个不完整的类型），所以你必须编写如下内容：</p>
<div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;functional&gt;</span> <span class="hljs-comment">// for std::forward()</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;type_traits&gt;</span> <span class="hljs-comment">// for std::is_same&lt;&gt; and std::invoke_result&lt;&gt;</span></span>
<span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> Callable, <span class="hljs-keyword">typename</span>... Args&gt;</span>
<span class="hljs-function"><span class="hljs-keyword">decltype</span>(<span class="hljs-keyword">auto</span>) <span class="hljs-title">call</span><span class="hljs-params">(Callable op, Args&amp;&amp;... args)</span></span>
<span class="hljs-function"></span>{
    <span class="hljs-function"><span class="hljs-keyword">if</span> <span class="hljs-title">constexpr</span><span class="hljs-params">(std::is_void_v&lt;std::<span class="hljs-type">invoke_result_t</span>&lt;Callable, Args...&gt;&gt;)</span> </span>{
        <span class="hljs-comment">// return type is void:</span>
        <span class="hljs-built_in">op</span>(std::forward&lt;Args&gt;(args)...);
        ... <span class="hljs-comment">// do something before we return</span>
        <span class="hljs-keyword">return</span>;
    }
    <span class="hljs-keyword">else</span> {
        <span class="hljs-comment">// return type is not void:</span>
        <span class="hljs-keyword">decltype</span>(<span class="hljs-keyword">auto</span>) ret{<span class="hljs-built_in">op</span>(std::forward&lt;Args&gt;(args)...)};
        ... <span class="hljs-comment">// do something (with ret) before we return</span>
        <span class="hljs-keyword">return</span> ret;
    }
}</code></pre></div>

<h6><span id="compile-time-if-yong-yu-biao-qian-diao-du">Compile-Time if用于标签调度</span><a href="#compile-time-if-yong-yu-biao-qian-diao-du" class="header-anchor">#</a></h6><p>编译时 if 的一个典型应用是标签调度。 在 C+17 之前，您必须提供<br>为您要处理的每种类型设置一个单独的函数的重载。 现在，在编译时<br>如果，您可以将所有逻辑放在一个函数中。<br>例如，不要重载 std::advance() 算法：</p>
<div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> Iterator, <span class="hljs-keyword">typename</span> Distance&gt;</span>
<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">advance</span><span class="hljs-params">(Iterator&amp; pos, Distance n)</span> </span>{
    <span class="hljs-keyword">using</span> cat = std::iterator_traits&lt;Iterator&gt;::iterator_category;
    <span class="hljs-built_in">advanceImpl</span>(pos, n, cat); <span class="hljs-comment">// 迭代器类别上的标签调度</span>
}

<span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> Iterator, <span class="hljs-keyword">typename</span> Distance&gt;</span>
<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">advanceImpl</span><span class="hljs-params">(Iterator&amp; pos, Distance n, std::random_access_iterator_tag)</span> </span>{
    pos += n;
}

<span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> Iterator, <span class="hljs-keyword">typename</span> Distance&gt;</span>
<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">advanceImpl</span><span class="hljs-params">(Iterator&amp; pos, Distance n, std::bidirectional_iterator_tag)</span> </span>{
    <span class="hljs-keyword">if</span> (n &gt;= <span class="hljs-number">0</span>) {
        <span class="hljs-keyword">while</span> (n--) {
            ++pos;
        }
    }
    <span class="hljs-keyword">else</span> {
        <span class="hljs-keyword">while</span> (n++) {
            --pos;
        }
    }
}

<span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> Iterator, <span class="hljs-keyword">typename</span> Distance&gt;</span>
<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">advanceImpl</span><span class="hljs-params">(Iterator&amp; pos, Distance n, std::input_iterator_tag)</span> </span>{
    <span class="hljs-keyword">while</span> (n--) {
        ++pos;
    }
}</code></pre></div>

<p>我们现在可以在一个函数中实现所有行为：</p>
<div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> Iterator, <span class="hljs-keyword">typename</span> Distance&gt;</span>
<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">advance</span><span class="hljs-params">(Iterator&amp; pos, Distance n)</span> </span>{
    <span class="hljs-keyword">using</span> cat = std::iterator_traits&lt;Iterator&gt;::iterator_category;
    <span class="hljs-function"><span class="hljs-keyword">if</span> <span class="hljs-title">constexpr</span> <span class="hljs-params">(std::is_same_v&lt;cat, std::random_access_iterator_tag&gt;)</span> </span>{
        pos += n;
    }
    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> <span class="hljs-built_in">constexpr</span> (std::is_same_v&lt;cat,
                       std::bidirectional_access_iterator_tag&gt;) {
        <span class="hljs-keyword">if</span> (n &gt;= <span class="hljs-number">0</span>) {
            <span class="hljs-keyword">while</span> (n--) {
                ++pos;
            }
        }
        <span class="hljs-keyword">else</span> {
            <span class="hljs-keyword">while</span> (n++) {
                --pos;
            }
        }
    }
    <span class="hljs-keyword">else</span> { <span class="hljs-comment">// input_iterator_tag</span>
        <span class="hljs-keyword">while</span> (n--) {
            ++pos;
        }
    }
}</code></pre></div>

<p>所以，在某种程度上，我们现在有一个compile-time切换，不同的情况必须在这里得到 但是，由 if constexpr 子句制定。 但是，请注意一个可能很重要的区别：</p>
<ul>
<li><p>重载函数集为您提供最佳匹配语义。</p>
</li>
<li><p>编译时if 的实现为您提供了第一个匹配语义。</p>
</li>
</ul>
<p>标签调度的另一个例子是使用编译时 if for get&lt;&gt;() 重载来实现结构绑定接口。 </p>
<p>第三个例子是通用 lambda 中不同类型的处理，如 <code>std::variant&lt;&gt; visitors</code>。</p>
<h4><span id="10-3-dai-you-chu-shi-hua-de-bian-yi-shi-if">10.3 带有初始化的编译时<code>if</code></span><a href="#10-3-dai-you-chu-shi-hua-de-bian-yi-shi-if" class="header-anchor">#</a></h4><p>请注意，compile-time if 也可以使用新形式的 if with 初始化。 例如，如果<br>有一个 constexpr 函数 foo()，你可以使用：</p>
<div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;</span>
<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">bar</span><span class="hljs-params">(<span class="hljs-type">const</span> T x)</span></span>
<span class="hljs-function"></span>{
    <span class="hljs-function"><span class="hljs-keyword">if</span> <span class="hljs-title">constexpr</span> <span class="hljs-params">(<span class="hljs-keyword">auto</span> obj = foo(x); std::is_same_v&lt;<span class="hljs-keyword">decltype</span>(obj), T&gt;)</span> </span>{
        std::cout &lt;&lt; <span class="hljs-string">"foo(x) yields same type\n"</span>;
        ...
    }
    <span class="hljs-keyword">else</span> {
        std::cout &lt;&lt; <span class="hljs-string">"foo(x) yields different type\n"</span>;
        ...
    }
}</code></pre></div>

<p>如果传递的类型有 constexpr 函数 foo()，您可以使用此代码提供不同的<br>关于 foo(x) 是否产生与 x 相同类型的行为。<br>要确定 foo(x) 返回的值，您可以编写：</p>
<div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">constexpr</span> <span class="hljs-keyword">auto</span> c = ...;
<span class="hljs-function"><span class="hljs-keyword">if</span> <span class="hljs-title">constexpr</span> <span class="hljs-params">(<span class="hljs-keyword">constexpr</span> <span class="hljs-keyword">auto</span> obj = foo(c); obj == <span class="hljs-number">0</span>)</span> </span>{
    std::cout &lt;&lt; <span class="hljs-string">"foo() == 0\n"</span>;
    ...
}</code></pre></div>

<p>请注意，必须将 obj 声明为 constexpr 才能在条件中使用其值。</p>
<h4><span id="10-4-zai-mo-ban-zhi-wai-shi-yong-bian-yi-shi-if">10.4 在模板之外使用编译时<code>if</code></span><a href="#10-4-zai-mo-ban-zhi-wai-shi-yong-bian-yi-shi-if" class="header-anchor">#</a></h4><p>if constexpr 可以在任何函数中使用，而不仅仅是在模板中。 我们只需要一个编译时表达式，它会产生可转换为 bool 的东西。 但是，在那种情况下，在 then 和 the<br>else 部分即使被丢弃，所有语句也必须始终有效。</p>
<p>例如，下面的代码总是会编译失败，因为 undeclared() 的调用必须是有效的，即使 chars 被签名并且 else 部分被丢弃：</p>
<div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;limits&gt;</span></span>
<span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;</span>
<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">foo</span><span class="hljs-params">(T t)</span></span>;
<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>
<span class="hljs-function"></span>{
    <span class="hljs-function"><span class="hljs-keyword">if</span> <span class="hljs-title">constexpr</span><span class="hljs-params">(std::numeric_limits&lt;<span class="hljs-type">char</span>&gt;::is_signed)</span> </span>{
        <span class="hljs-built_in">foo</span>(<span class="hljs-number">42</span>); <span class="hljs-comment">// OK</span>
    }
    <span class="hljs-keyword">else</span> {
        <span class="hljs-built_in">undeclared</span>(<span class="hljs-number">42</span>); <span class="hljs-comment">// 如果没有声明总是错误（即使被丢弃）</span>
    }
}</code></pre></div>

<p>此外，以下代码永远无法成功编译，因为其中一个静态断言将始终失败：</p>
<div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">if</span> <span class="hljs-title">constexpr</span><span class="hljs-params">(std::numeric_limits&lt;<span class="hljs-type">char</span>&gt;::is_signed)</span> </span>{
    <span class="hljs-built_in">static_assert</span>(std::numeric_limits&lt;<span class="hljs-type">char</span>&gt;::is_signed);
}
<span class="hljs-keyword">else</span> {
    <span class="hljs-built_in">static_assert</span>(!std::numeric_limits&lt;<span class="hljs-type">char</span>&gt;::is_signed);
}</code></pre></div>

<p>如果在泛型代码之外，编译时的（唯一）好处是被丢弃语句中的代码，尽管它必须是有效的，但不会成为结果程序的一部分，这减少了生成的可执行文件。 例如，在这个程序中：</p>
<div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;limits&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;array&gt;</span></span>
<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>
<span class="hljs-function"></span>{
    <span class="hljs-keyword">if</span> (!std::numeric_limits&lt;<span class="hljs-type">char</span>&gt;::is_signed) {
        <span class="hljs-type">static</span> std::array&lt;std::string,1000&gt; arr1;
        ...
    }
    <span class="hljs-keyword">else</span> {
        <span class="hljs-type">static</span> std::array&lt;std::string,<span class="hljs-number">1000</span>&gt; arr2;
        ...
    }
}</code></pre></div>

<p>arr1或arr2是最终可执行文件的一部分，但不是两者都是。</p>
<h4><span id="10-5-hou-ji">10.5 后记</span><a href="#10-5-hou-ji" class="header-anchor">#</a></h4><p>Compile-time if最初是由Walter Bright, Herb Sutter, 和Andrei Alexandrescu在 <a target="_blank" rel="noopener" href="https://wg21.link/n3329%EF%BC%8C%E4%BB%A5%E5%8F%8AVille">https://wg21.link/n3329，以及Ville</a> Voutilainen在<a target="_blank" rel="noopener" href="https://wg21.link/n4461%EF%BC%8C%E6%8F%90%E5%87%BA%E4%BA%86%E9%9D%99%E6%80%81%E7%9A%84if%E8%AF%AD%E8%A8%80%E7%89%B9%E6%80%A7%E3%80%82">https://wg21.link/n4461，提出了静态的if语言特性。</a><br>一个静态的if语言特性。在<a target="_blank" rel="noopener" href="https://wg21.link/p0128r0%EF%BC%8CVille">https://wg21.link/p0128r0，Ville</a> Voutilainen提出了这个 该特性首次被称为constexpr_if（该特性的名称由此而来）。最终被接受的 措辞是由Jens Maurer <a target="_blank" rel="noopener" href="https://wg21.link/p0292r2%E3%80%82">https://wg21.link/p0292r2。</a></p>
<h3><span id="11-zhe-die-biao-da-shi">11 折叠表达式</span><a href="#11-zhe-die-biao-da-shi" class="header-anchor">#</a></h3><p>从C++17开始，有一个功能是计算在一个参数包的所有参数上使用二元运算符的结果（有一个可选的初始值）。<br>例如，下面的函数返回所有传递参数的总和:</p>
<div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span>... T&gt;</span>
<span class="hljs-function"><span class="hljs-keyword">auto</span> <span class="hljs-title">foldSum</span> <span class="hljs-params">(T... args)</span> </span>{
    <span class="hljs-keyword">return</span> (... + args); <span class="hljs-comment">// ((arg1 + arg2) + arg3) ...</span>
}</code></pre></div>

<p>注意，返回表达式周围的括号是折叠表达式的一部分，不能省略。</p>
<p>调用函数时要注意</p>
<div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-built_in">foldSum</span>(<span class="hljs-number">47</span>, <span class="hljs-number">11</span>, val, <span class="hljs-number">-1</span>);</code></pre></div>

<p>实例化要执行的模板：</p>
<div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">return</span> <span class="hljs-number">47</span> + <span class="hljs-number">11</span> + val + <span class="hljs-number">-1</span>;</code></pre></div>

<p>调用它:</p>
<div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-built_in">foldSum</span>(std::<span class="hljs-built_in">string</span>(<span class="hljs-string">"hello"</span>), <span class="hljs-string">"world"</span>, <span class="hljs-string">"!"</span>);</code></pre></div>

<p>实例化模板：</p>
<div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">return</span> std::<span class="hljs-built_in">string</span>(<span class="hljs-string">"hello"</span>) + <span class="hljs-string">"world"</span> + <span class="hljs-string">"!"</span>;</code></pre></div>

<p>另请注意，折叠表达式参数的顺序可能不同且很重要（并且可能看起来有点违反直觉）：如所写，</p>
<div class="code-wrapper"><pre><code class="hljs c++">(... + args)</code></pre></div>

<p>结果是</p>
<div class="code-wrapper"><pre><code class="hljs c++">((arg1 + arg2) + arg3) ...</code></pre></div>

<p>这意味着它会反复“添加”东西。 你也可以写</p>
<div class="code-wrapper"><pre><code class="hljs c++">(args + ...)</code></pre></div>

<p>它反复“预添加”事物，因此结果表达式为：</p>
<div class="code-wrapper"><pre><code class="hljs c++">(arg1 + (arg2 + arg3)) ...</code></pre></div>

<h4><span id="11-1-zhe-die-biao-da-shi-de-dong-yin">11.1 折叠表达式的动因</span><a href="#11-1-zhe-die-biao-da-shi-de-dong-yin" class="header-anchor">#</a></h4><p>折叠表达式避免了递归实例化模板以对参数包的所有参数执行操作的需要。 在 C++17 之前，您必须实现：</p>
<div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;</span>
<span class="hljs-function"><span class="hljs-keyword">auto</span> <span class="hljs-title">foldSumRec</span> <span class="hljs-params">(T arg)</span> </span>{
    <span class="hljs-keyword">return</span> arg;
}
<span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T1, <span class="hljs-keyword">typename</span>... Ts&gt;</span>
<span class="hljs-function"><span class="hljs-keyword">auto</span> <span class="hljs-title">foldSumRec</span> <span class="hljs-params">(T1 arg1, Ts... otherArgs)</span> </span>{
    <span class="hljs-keyword">return</span> arg1 + <span class="hljs-built_in">foldSumRec</span>(otherArgs...);
}</code></pre></div>

<p>这样的实现不仅写起来麻烦，而且对 C++ 编译器也有压力。 和</p>
<div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span>... T&gt;</span>
<span class="hljs-function"><span class="hljs-keyword">auto</span> <span class="hljs-title">foldSum</span> <span class="hljs-params">(T... args)</span> </span>{
    <span class="hljs-keyword">return</span> (... + args); <span class="hljs-comment">// arg1 + arg2 + arg3 ...</span>
}</code></pre></div>

<p>程序员和编译器的工作量都大大减少了。</p>
<h4><span id="11-2-shi-yong-zhe-die-biao-da-shi">11.2 使用折叠表达式</span><a href="#11-2-shi-yong-zhe-die-biao-da-shi" class="header-anchor">#</a></h4><p>给定参数 args 和运算符 op，C++17 允许我们编写</p>
<ul>
<li><p>要么是一元左折叠</p>
<div class="code-wrapper"><pre><code class="hljs c++">( ... op args )</code></pre></div>

<p>扩展为： ((arg1 op arg2) op arg3) op . . .</p>
</li>
<li><p>或一元右折叠</p>
<div class="code-wrapper"><pre><code class="hljs c++">( args op ... )
</code></pre></div>

<p>扩展为：arg1 op (arg2 op . . . (argN-1 op argN))</p>
</li>
</ul>
<p>括号是必需的。 但是，括号和省略号 (…) 不必用空格分隔。<br>左右折叠之间的差异比预期的更重要。 例如，即使使用 operator + 也可能会有不同的效果。 使用左折叠表达式时：</p>
<div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span>... T&gt;</span>
<span class="hljs-function"><span class="hljs-keyword">auto</span> <span class="hljs-title">foldSumL</span><span class="hljs-params">(T... args)</span></span>{
    <span class="hljs-keyword">return</span> (... + args); <span class="hljs-comment">// ((arg1 + arg2) + arg3) ...</span>
}</code></pre></div>

<p>调用</p>
<div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-built_in">foldSumL</span>(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>)</code></pre></div>

<p>计算结果为：</p>
<div class="code-wrapper"><pre><code class="hljs bash">(1 + 2) + 3)</code></pre></div>

<p>这也意味着以下示例可以编译：</p>
<div class="code-wrapper"><pre><code class="hljs c++">std::cout &lt;&lt; <span class="hljs-built_in">foldSumL</span>(std::<span class="hljs-built_in">string</span>(<span class="hljs-string">"hello"</span>), <span class="hljs-string">"world"</span>, <span class="hljs-string">"!"</span>) &lt;&lt; <span class="hljs-string">'\n'</span>; <span class="hljs-comment">// OK</span></code></pre></div>

<p>请记住，运算符 + 是为标准字符串定义的，前提是至少有一个操作数是 std::string。<br>因为使用了左折叠，所以调用首先计算:</p>
<div class="code-wrapper"><pre><code class="hljs c++">std::<span class="hljs-built_in">string</span>(<span class="hljs-string">"hello"</span>) + <span class="hljs-string">"world"</span></code></pre></div>

<p>它返回一个 std::string，以便添加字符串文字”!” 那么也是有效的。</p>
<p>但是，诸如:</p>
<div class="code-wrapper"><pre><code class="hljs c++">std::cout &lt;&lt; <span class="hljs-built_in">foldSumL</span>(<span class="hljs-string">"hello"</span>, <span class="hljs-string">"world"</span>, std::<span class="hljs-built_in">string</span>(<span class="hljs-string">"!"</span>)) &lt;&lt; <span class="hljs-string">'\n'</span>; <span class="hljs-comment">// ERROR</span></code></pre></div>

<p>不会编译，因为它的计算结果为:</p>
<div class="code-wrapper"><pre><code class="hljs bash">(<span class="hljs-string">"hello"</span> + <span class="hljs-string">"world"</span>) + std::string(<span class="hljs-string">"!"</span>)</code></pre></div>

<p>并且不允许添加两个字符串文字。</p>
<p>但是，如果我们将实现更改为：</p>
<div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span>... T&gt;</span>
<span class="hljs-function"><span class="hljs-keyword">auto</span> <span class="hljs-title">foldSumR</span><span class="hljs-params">(T... args)</span></span>{
    <span class="hljs-keyword">return</span> (args + ...); <span class="hljs-comment">// (arg1 + (arg2 + arg3)) ...</span>
}</code></pre></div>

<p>调用：</p>
<div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-built_in">foldSumR</span>(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>)</code></pre></div>

<p>计算结果为：</p>
<div class="code-wrapper"><pre><code class="hljs bash">(1 + (2 + 3)</code></pre></div>

<p>这意味着以下示例不再编译：</p>
<div class="code-wrapper"><pre><code class="hljs c++">std::cout &lt;&lt; <span class="hljs-built_in">foldSumR</span>(std::<span class="hljs-built_in">string</span>(<span class="hljs-string">"hello"</span>), <span class="hljs-string">"world"</span>, <span class="hljs-string">"!"</span>) &lt;&lt; <span class="hljs-string">'\n'</span>; <span class="hljs-comment">// ERROR</span></code></pre></div>

<p>而下面的调用现在编译：</p>
<div class="code-wrapper"><pre><code class="hljs c++">std::cout &lt;&lt; <span class="hljs-built_in">foldSumR</span>(<span class="hljs-string">"hello"</span>, <span class="hljs-string">"world"</span>, std::<span class="hljs-built_in">string</span>(<span class="hljs-string">"!"</span>)) &lt;&lt; <span class="hljs-string">'\n'</span>; <span class="hljs-comment">// OK</span></code></pre></div>

<p>因为在几乎所有情况下，从左到右的评估都是意图，通常应该首选带有参数包的左折叠语法（除非这不起作用）：</p>
<div class="code-wrapper"><pre><code class="hljs c++">(... + args); <span class="hljs-comment">// 折叠表达式的首选语法</span></code></pre></div>

<h5><span id="11-2-1-chu-li-kong-can-shu-bao">11.2.1 处理空参数包</span><a href="#11-2-1-chu-li-kong-can-shu-bao" class="header-anchor">#</a></h5><p>如果折叠表达式使用了一个空的参数包，那么以下规则适用。</p>
<ul>
<li><p>如果使用了操作符&amp;&amp;，其值为真。</p>
</li>
<li><p>如果使用了操作符||，则值为假。</p>
</li>
<li><p>如果使用了逗号运算符，值是void()。</p>
</li>
<li><p>对于所有其他的操作符来说，调用是不符合格式的。<br>对于所有其他情况（以及一般情况下），你可以添加一个初始值。给定一个参数包args，一个初始值值和一个运算符op，C++17还允许我们写出以下两种情况</p>
</li>
<li><p>或者二元左折叠</p>
<div class="code-wrapper"><pre><code class="hljs c++">( value op ... op args )</code></pre></div>

<p>扩展为： (((value op arg1) op arg2) op arg3) op . . .</p>
</li>
<li><p>或二元右折叠</p>
<div class="code-wrapper"><pre><code class="hljs c++">( args op ... op value )</code></pre></div></li>
</ul>
<p>省略号两边的运算符 op 必须相同。<br>  例如，以下定义允许在添加值时传递一个空参数包：</p>
<div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span>... T&gt;</span>
<span class="hljs-function"><span class="hljs-keyword">auto</span> <span class="hljs-title">foldSum</span> <span class="hljs-params">(T... s)</span></span>{
    <span class="hljs-keyword">return</span> (<span class="hljs-number">0</span> + ... + s); <span class="hljs-comment">// 如果 sizeof...(s)==0 甚至可以工作</span>
}</code></pre></div>

<p>从概念上讲，我们是否将 0 添加为第一个或最后一个操作数并不重要：</p>
<div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span>... T&gt;</span>
<span class="hljs-function"><span class="hljs-keyword">auto</span> <span class="hljs-title">foldSum</span> <span class="hljs-params">(T... s)</span></span>{
    <span class="hljs-keyword">return</span> (s + ... + <span class="hljs-number">0</span>); <span class="hljs-comment">// 如果 sizeof...(s)==0 甚至可以工作</span>
}</code></pre></div>

<p>但是对于一元折叠表达式，不同的评估顺序比想象的更重要，应该首选二元左折叠：</p>
<div class="code-wrapper"><pre><code class="hljs c++">(val + ... + args); <span class="hljs-comment">// 二进制折叠表达式的首选语法</span></code></pre></div>

<p>此外，第一个操作数可能是特殊的，例如在此示例中：</p>
<div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span>... T&gt;</span>
<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">print</span> <span class="hljs-params">(<span class="hljs-type">const</span> T&amp;... args)</span></span>
<span class="hljs-function"></span>{
    (std::cout &lt;&lt; ... &lt;&lt; args) &lt;&lt; <span class="hljs-string">'\n'</span>;
}</code></pre></div>

<p>在这里，重要的是第一个调用是第一个传递给 print() 的参数的输出，它返回流以执行其他输出调用。 其他实现可能无法编译甚至做一些意想不到的事情。 例如，与</p>
<div class="code-wrapper"><pre><code class="hljs c++">std::cout &lt;&lt; (args &lt;&lt; ... &lt;&lt; <span class="hljs-string">'\n'</span>);
</code></pre></div>

<p>像 print(1) 这样的调用将编译但打印值 1 左移了 ‘\n’ 的值，通常为 10，因此结果输出为 1024。<br>请注意，在此 print() 示例中，没有空格将参数包的所有元素彼此分开。 诸如 print(“hello”, 42, “world”) 之类的调用将打印：</p>
<div class="code-wrapper"><pre><code class="hljs bash">hello42world</code></pre></div>

<p>要通过空格分隔传递的元素，您需要一个帮助器来确保除第一个参数之外的任何输出都由前导空格扩展。 例如，这可以使用辅助函数模板 spaceBefore() 来完成：</p>
<div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;</span>
<span class="hljs-function"><span class="hljs-type">const</span> T&amp; <span class="hljs-title">spaceBefore</span><span class="hljs-params">(<span class="hljs-type">const</span> T&amp; arg)</span> </span>{
    std::cout &lt;&lt; <span class="hljs-string">' '</span>;
    <span class="hljs-keyword">return</span> arg;
}
<span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> First, <span class="hljs-keyword">typename</span>... Args&gt;
<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">print</span> <span class="hljs-params">(<span class="hljs-type">const</span> First&amp; firstarg, <span class="hljs-type">const</span> Args&amp;... args)</span> </span>{
    std::cout &lt;&lt; firstarg;
    (std::cout &lt;&lt; ... &lt;&lt; <span class="hljs-built_in">spaceBefore</span>(args)) &lt;&lt; <span class="hljs-string">'\n'</span>;
}</code></pre></div>

<p>这里，</p>
<div class="code-wrapper"><pre><code class="hljs c++">(std::cout &lt;&lt; ... &lt;&lt; <span class="hljs-built_in">spaceBefore</span>(args))</code></pre></div>

<p>是一个折叠表达式，展开为：</p>
<div class="code-wrapper"><pre><code class="hljs c++">std::cout &lt;&lt; <span class="hljs-built_in">spaceBefore</span>(arg1) &lt;&lt; <span class="hljs-built_in">spaceBefore</span>(arg2) &lt;&lt; ...</code></pre></div>

<p>因此，对于参数包 args 中的每个元素，它调用一个辅助函数，在返回传递的参数之前打印出一个空格字符，并将其写入 std::cout。 为了确保这不适用于第一个参数，我们添加了一个不使用 spaceBefore() 的附加第一个参数。<br>请注意，参数包输出的评估要求左侧的所有输出都在为实际元素调用 spaceBefore() 之前完成。 由于定义了运算符 &lt;&lt; 和函数调用的评估顺序，这保证从 C++17 开始就可以工作。<br>我们还可以使用 lambda 在 print() 中定义 spaceBefore()：</p>
<div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> First, <span class="hljs-keyword">typename</span>... Args&gt;</span>
<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">print</span> <span class="hljs-params">(<span class="hljs-type">const</span> First&amp; firstarg, <span class="hljs-type">const</span> Args&amp;... args)</span> </span>{
    std::cout &lt;&lt; firstarg;
    <span class="hljs-keyword">auto</span> spaceBefore = [](<span class="hljs-type">const</span> <span class="hljs-keyword">auto</span>&amp; arg) {
        std::cout &lt;&lt; <span class="hljs-string">' '</span>;
        <span class="hljs-keyword">return</span> arg;
    };
    (std::cout &lt;&lt; ... &lt;&lt; <span class="hljs-built_in">spaceBefore</span>(args)) &lt;&lt; <span class="hljs-string">'\n'</span>;
}</code></pre></div>

<p>但是，请注意 lambdas 默认按值返回对象，这意味着这将创建传递参数的不必要副本。 避免这种情况的方法是将 lambda 的返回类型显式声明为 const auto&amp; 或 decltype(auto)：</p>
<div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> First, <span class="hljs-keyword">typename</span>... Args&gt;</span>
<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">print</span> <span class="hljs-params">(<span class="hljs-type">const</span> First&amp; firstarg, <span class="hljs-type">const</span> Args&amp;... args)</span> </span>{
    std::cout &lt;&lt; firstarg;
    <span class="hljs-keyword">auto</span> spaceBefore = [](<span class="hljs-type">const</span> <span class="hljs-keyword">auto</span>&amp; arg) -&gt; <span class="hljs-type">const</span> <span class="hljs-keyword">auto</span>&amp; {
        std::cout &lt;&lt; <span class="hljs-string">' '</span>;
        <span class="hljs-keyword">return</span> arg;
    };
    (std::cout &lt;&lt; ... &lt;&lt; <span class="hljs-built_in">spaceBefore</span>(args)) &lt;&lt; <span class="hljs-string">'\n'</span>;
}</code></pre></div>

<p>如果你不能将这一切结合在一个语句中，C++ 就不会是 C++：</p>
<div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> First, <span class="hljs-keyword">typename</span>... Args&gt;</span>
<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">print</span> <span class="hljs-params">(<span class="hljs-type">const</span> First&amp; firstarg, <span class="hljs-type">const</span> Args&amp;... args)</span> </span>{
    std::cout &lt;&lt; firstarg;
    (std::cout &lt;&lt; ... &lt;&lt; [](<span class="hljs-type">const</span> <span class="hljs-keyword">auto</span>&amp; arg) -&gt; <span class="hljs-keyword">decltype</span>(<span class="hljs-keyword">auto</span>) {
        std::cout &lt;&lt; <span class="hljs-string">' '</span>;
        <span class="hljs-keyword">return</span> arg;
    }(args)) &lt;&lt; <span class="hljs-string">'\n'</span>;
}</code></pre></div>

<p>然而，实现 print() 的一种更简单的方法是使用 lambda 打印空间和参数并将其传递给一元折叠：</p>
<div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> First, <span class="hljs-keyword">typename</span>... Args&gt;</span>
<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">print</span><span class="hljs-params">(First first, <span class="hljs-type">const</span> Args&amp;... args)</span> </span>{
    std::cout &lt;&lt; first;
    <span class="hljs-keyword">auto</span> outWithSpace = [](<span class="hljs-type">const</span> <span class="hljs-keyword">auto</span>&amp; arg) {
        std::cout &lt;&lt; <span class="hljs-string">' '</span> &lt;&lt; arg;
    };
    (... , <span class="hljs-built_in">outWithSpace</span>(args));
    std::cout &lt;&lt; <span class="hljs-string">'\n'</span>;
}</code></pre></div>

<p>通过使用使用 auto 声明的附加模板参数，我们可以使 print() 更加灵活，可以将分隔符参数化为字符、字符串或任何其他可打印类型。</p>
<h5><span id="11-2-2-zhi-chi-de-cao-zuo-fu">11.2.2 支持的操作符</span><a href="#11-2-2-zhi-chi-de-cao-zuo-fu" class="header-anchor">#</a></h5><p>您可以将所有二元运算符用于折叠表达式，除了 ., -&gt;, and []。</p>
<h6><span id="zhe-die-han-shu-diao-yong">折叠函数调用</span><a href="#zhe-die-han-shu-diao-yong" class="header-anchor">#</a></h6><p>折叠表达式也可以用于逗号运算符，将多个表达式组合成一个语句。 例如，您可以折叠逗号运算符，它可以执行对可变数量的基类的成员函数的函数调用：</p>
<p><code>tmpl/foldcalls.cpp </code></p>
<div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span>
<span class="hljs-comment">// template fo ame... Bases&gt;</span>
<span class="hljs-keyword">class</span> <span class="hljs-title class_">MultiBase</span> : <span class="hljs-keyword">private</span> Bases...
{
    <span class="hljs-keyword">public</span>:
    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">print</span><span class="hljs-params">()</span> </span>{
        <span class="hljs-comment">// call print() of all base classes:</span>
        (... , Bases::<span class="hljs-built_in">print</span>());
    }
};
<span class="hljs-keyword">struct</span> <span class="hljs-title class_">A</span> {
    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">print</span><span class="hljs-params">()</span> </span>{ std::cout &lt;&lt; <span class="hljs-string">"A::print()\n"</span>; }
};
<span class="hljs-keyword">struct</span> <span class="hljs-title class_">B</span> {
    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">print</span><span class="hljs-params">()</span> </span>{ std::cout &lt;&lt; <span class="hljs-string">"B::print()\n"</span>; }
};
<span class="hljs-keyword">struct</span> <span class="hljs-title class_">C</span> {
    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">print</span><span class="hljs-params">()</span> </span>{ std::cout &lt;&lt; <span class="hljs-string">"C::print()\n"</span>; }
};
<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>
<span class="hljs-function"></span>{
    MultiBase&lt;A,B,C&gt; mb;
    mb.<span class="hljs-built_in">print</span>();
}</code></pre></div>

<p>这里，</p>
<div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span>... Bases&gt;
<span class="hljs-keyword">class</span> <span class="hljs-title class_">MultiBase</span> : <span class="hljs-keyword">private</span> Bases...
{
    ...
};
</code></pre></div>

<p>允许我们使用可变数量的基类来初始化对象：</p>
<div class="code-wrapper"><pre><code class="hljs c++">MultiBase&lt;A,B,C&gt; mb;
</code></pre></div>

<p>并与</p>
<div class="code-wrapper"><pre><code class="hljs c++">(... , Bases::<span class="hljs-built_in">print</span>());</code></pre></div>

<p>折叠表达式用于扩展它以调用每个基类的打印。 也就是说，带有折叠表达式的语句扩展为以下内容：</p>
<div class="code-wrapper"><pre><code class="hljs c++">(A::<span class="hljs-built_in">print</span>() , B::<span class="hljs-built_in">print</span>()) , C::<span class="hljs-built_in">print</span>();</code></pre></div>

<p>但是，请注意，由于逗号运算符的性质，我们使用左折叠运算符还是右折叠运算符并不重要。 函数总是从左到右调用。 和</p>
<div class="code-wrapper"><pre><code class="hljs c++">(Bases::<span class="hljs-built_in">print</span>() , ...);</code></pre></div>

<p>括号仅对调用进行分组，以便第一个 print() 调用与其他两个 print() 调用的结果组合如下：</p>
<div class="code-wrapper"><pre><code class="hljs c++">A::<span class="hljs-built_in">print</span>() , (B::<span class="hljs-built_in">print</span>() , C::<span class="hljs-built_in">print</span>());</code></pre></div>

<p>但是因为逗号运算符的计算顺序总是从左到右，所以第一个调用发生在括号内的两个调用组之前，其中中间调用仍然发生在右调用之前。<br>尽管如此，由于左折叠表达式与结果求值顺序匹配，因此在将左折叠表达式用于多个函数调用时，再次建议使用左折叠表达式。</p>
<h6><span id="jie-he-ha-xi-han-shu">结合哈希函数</span><a href="#jie-he-ha-xi-han-shu" class="header-anchor">#</a></h6><p>使用逗号运算符的一个示例是组合散列值。 这可以按如下方式完成：</p>
<div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;</span>
<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">hashCombine</span> <span class="hljs-params">(std::<span class="hljs-type">size_t</span>&amp; seed, <span class="hljs-type">const</span> T&amp; val)</span></span>
<span class="hljs-function"></span>{
    seed ^= std::<span class="hljs-built_in">hash</span>&lt;T&gt;()(val) + <span class="hljs-number">0x9e3779b9</span> + (seed&lt;&lt;<span class="hljs-number">6</span>) + (seed&gt;&gt;<span class="hljs-number">2</span>);
}
<span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span>... Types&gt;</span>
<span class="hljs-function">std::<span class="hljs-type">size_t</span> <span class="hljs-title">combinedHashValue</span> <span class="hljs-params">(<span class="hljs-type">const</span> Types&amp;... args)</span></span>
<span class="hljs-function"></span>{
    std::<span class="hljs-type">size_t</span> seed = <span class="hljs-number">0</span>; <span class="hljs-comment">// initial seed</span>
    (... , <span class="hljs-built_in">hashCombine</span>(seed,args)); <span class="hljs-comment">// chain of hashCombine() calls</span>
    <span class="hljs-keyword">return</span> seed;
}</code></pre></div>

<p>通过调用</p>
<div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-function">std::<span class="hljs-type">size_t</span> <span class="hljs-title">combinedHashValue</span> <span class="hljs-params">(<span class="hljs-string">"Hello"</span>, <span class="hljs-string">"World"</span>, <span class="hljs-number">42</span>,)</span></span>;</code></pre></div>

<p>中间的语句扩展为：</p>
<div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-built_in">hashCombine</span>(seed,<span class="hljs-string">"Hello"</span>), (<span class="hljs-built_in">hashCombine</span>(seed,<span class="hljs-string">"World"</span>), <span class="hljs-built_in">hashCombine</span>(seed,<span class="hljs-number">42</span>);</code></pre></div>

<p>通过这个定义，我们可以轻松地为诸如 Customer 的类型定义一个新的散列函数对象：</p>
<div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">CustomerHash</span>
{
    <span class="hljs-function">std::<span class="hljs-type">size_t</span> <span class="hljs-title">operator</span><span class="hljs-params">()</span> <span class="hljs-params">(<span class="hljs-type">const</span> Customer&amp; c)</span> <span class="hljs-type">const</span> </span>{
        <span class="hljs-keyword">return</span> <span class="hljs-built_in">combinedHashValue</span>(c.<span class="hljs-built_in">getFirstname</span>(), c.<span class="hljs-built_in">getLastname</span>(), c.<span class="hljs-built_in">getValue</span>());
    }
};</code></pre></div>

<p>我们可以用它来把客户放在一个无序的集合中：</p>
<div class="code-wrapper"><pre><code class="hljs c++">std::unordered_set&lt;Customer, CustomerHash&gt; coll;</code></pre></div>

<p>折叠路径遍历</p>
<p>您还可以使用折叠表达式通过运算符 -&gt;* 遍历二叉树中的路径：</p>
<p><code>tmpl/foldtraverse.cpp</code></p>
<div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-comment">// 定义二叉树结构和遍历辅助函数:</span>
<span class="hljs-keyword">struct</span> <span class="hljs-title class_">Node</span> {
    <span class="hljs-type">int</span> value;
    Node* left;
    Node* right;
    <span class="hljs-built_in">Node</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>) : <span class="hljs-built_in">value</span>(i), <span class="hljs-built_in">left</span>(<span class="hljs-literal">nullptr</span>), <span class="hljs-built_in">right</span>(<span class="hljs-literal">nullptr</span>) {
    }
    ...
};
<span class="hljs-keyword">auto</span> left = &amp;Node::left;
<span class="hljs-keyword">auto</span> right = &amp;Node::right;
<span class="hljs-comment">// 遍历树，使用折叠表达式:</span>
<span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T, <span class="hljs-keyword">typename</span>... TP&gt;</span>
<span class="hljs-function">Node* <span class="hljs-title">traverse</span> <span class="hljs-params">(T np, TP... paths)</span> </span>{
    <span class="hljs-keyword">return</span> (np -&gt;* ... -&gt;* paths); <span class="hljs-comment">// np -&gt;* paths1 -&gt;* paths2 ...</span>
}
<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>
<span class="hljs-function"></span>{
    <span class="hljs-comment">// 初始化二叉树结构:</span>
    Node* root = <span class="hljs-keyword">new</span> Node{<span class="hljs-number">0</span>};
    root-&gt;left = <span class="hljs-keyword">new</span> Node{<span class="hljs-number">1</span>};
    root-&gt;left-&gt;right = <span class="hljs-keyword">new</span> Node{<span class="hljs-number">2</span>};
    ...
    <span class="hljs-comment">// 遍历二叉树:</span>
    Node* node = <span class="hljs-built_in">traverse</span>(root, left, right);
    ...
}</code></pre></div>

<p>这里，</p>
<div class="code-wrapper"><pre><code class="hljs c++">(np -&gt;* ... -&gt;* paths)</code></pre></div>

<p>使用折叠表达式来遍历来自 np 的路径的可变参数元素。 调用时</p>
<div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-built_in">traverse</span>(root, left, right);</code></pre></div>

<p>fold 表达式的调用扩展为：</p>
<div class="code-wrapper"><pre><code class="hljs bash">root -&gt; left -&gt; right</code></pre></div>

<h5><span id="11-2-3-wei-lei-xing-shi-yong-zhe-die-biao-da-shi">11.2.3 为类型使用折叠表达式</span><a href="#11-2-3-wei-lei-xing-shi-yong-zhe-die-biao-da-shi" class="header-anchor">#</a></h5><p>通过使用类型特征，我们还可以使用折叠表达式来处理模板参数包（作为模板参数传递的任意数量的类型）。 例如，您可以使用折叠表达式来确定类型列表是否是齐次的：</p>
<p><code>tmpl/ishomogeneous.hpp</code></p>
<div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;type_traits&gt;</span></span>
<span class="hljs-comment">// 检查传递的类型是否是同质的:</span>
<span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T1, <span class="hljs-keyword">typename</span>... TN&gt;
<span class="hljs-keyword">struct</span> <span class="hljs-title class_">IsHomogeneous</span> {
    <span class="hljs-type">static</span> <span class="hljs-keyword">constexpr</span> <span class="hljs-type">bool</span> value = (std::is_same&lt;T1,TN&gt;::value &amp;&amp; ...);
};
<span class="hljs-comment">// 检查传递的参数是否具有相同的类型:</span>
<span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T1, <span class="hljs-keyword">typename</span>... TN&gt;</span>
<span class="hljs-function"><span class="hljs-keyword">constexpr</span> <span class="hljs-type">bool</span> <span class="hljs-title">isHomogeneous</span><span class="hljs-params">(T1, TN...)</span></span>
<span class="hljs-function"></span>{
    <span class="hljs-keyword">return</span> (std::is_same&lt;T1,TN&gt;::value &amp;&amp; ...);
}</code></pre></div>

<p>可以使用类型特征 IsHomogeneous&lt;&gt;，例如，如下所示：</p>
<div class="code-wrapper"><pre><code class="hljs c++">IsHomogeneous&lt;<span class="hljs-type">int</span>, Size, <span class="hljs-keyword">decltype</span>(<span class="hljs-number">42</span>)&gt;::value</code></pre></div>

<p>在这种情况下，初始化成员值的折叠表达式扩展为：</p>
<div class="code-wrapper"><pre><code class="hljs c++">std::is_same&lt;<span class="hljs-type">int</span>,MyType&gt;::value &amp;&amp; std::is_same&lt;<span class="hljs-type">int</span>,<span class="hljs-keyword">decltype</span>(<span class="hljs-number">42</span>)&gt;::value</code></pre></div>

<p>可以使用函数模板isHomogeneous&lt;&gt;()，例如如下：</p>
<div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-built_in">isHomogeneous</span>(<span class="hljs-number">43</span>, <span class="hljs-number">-1</span>, <span class="hljs-string">"hello"</span>, <span class="hljs-literal">nullptr</span>)</code></pre></div>

<p>在这种情况下，初始化成员值的折叠表达式扩展为：</p>
<div class="code-wrapper"><pre><code class="hljs c++">std::is_same&lt;<span class="hljs-type">int</span>,<span class="hljs-type">int</span>&gt;::value &amp;&amp; std::is_same&lt;<span class="hljs-type">int</span>,<span class="hljs-type">const</span> <span class="hljs-type">char</span>*&gt;::value
    &amp;&amp; std::is_same&lt;<span class="hljs-type">int</span>,std::<span class="hljs-type">nullptr_t</span>&gt;::value</code></pre></div>

<p>像往常一样，操作符&amp;&amp;是短 循环的（在第一个假的之后中止评估）。<br>std::array&lt;&gt;的推导指南在标准库中使用了这个特性。</p>
<h4><span id="11-3-hou-ji">11.3 后记</span><a href="#11-3-hou-ji" class="header-anchor">#</a></h4><p>折叠表达式首先由 Andrew Sutton 和 Richard Smith 在 <a target="_blank" rel="noopener" href="https://wg21.link/n4191">https://wg21.link/n4191</a> 中提出。 最终接受的措辞由 Andrew Sutton 和 Richard Smith 在 <a target="_blank" rel="noopener" href="https://wg21.link/n4295">https://wg21.link/n4295</a> 中制定。 后来删除了对运算符 *、+、&amp; 和 | 的空序列支持 正如 Thibaut Le Jehan 在 <a target="_blank" rel="noopener" href="https://wg21.link/p0036">https://wg21.link/p0036</a> 中提出的那样。</p>
<h3><span id="12-jiang-zi-fu-chuan-zuo-wei-mo-ban-can-shu-chu-li">12 将字符串作为模板参数处理</span><a href="#12-jiang-zi-fu-chuan-zuo-wei-mo-ban-can-shu-chu-li" class="header-anchor">#</a></h3><p>随着时间的推移，不同版本的 C++ 放宽了可用作模板参数的规则，而在 C++17 中，这种情况再次发生。 现在可以使用模板，而无需在当前范围之外定义它们。</p>
<h4><span id="12-1-zai-mo-ban-zhong-shi-yong-zi-fu-chuan">12.1 在模板中使用字符串</span><a href="#12-1-zai-mo-ban-zhong-shi-yong-zi-fu-chuan" class="header-anchor">#</a></h4><p>非类型模板参数只能是常量整数值（包括枚举）、指向对象/函数/成员的指针、对对象或函数的左值引用或 std::nullptr_t（nullptr 的类型）。<br>对于指针，链接是必需的，这意味着您不能直接传递字符串文字。 但是，从 C++17 开始，您可以拥有带有内部链接的指针。 例如：</p>
<div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">template</span>&lt;<span class="hljs-type">const</span> <span class="hljs-type">char</span>* str&gt;
<span class="hljs-keyword">class</span> <span class="hljs-title class_">Message</span> {
    ...
};
<span class="hljs-keyword">extern</span> <span class="hljs-type">const</span> <span class="hljs-type">char</span> hello[] = <span class="hljs-string">"Hello World!"</span>; <span class="hljs-comment">// 外联</span>
<span class="hljs-type">const</span> <span class="hljs-type">char</span> hello11[] = <span class="hljs-string">"Hello World!"</span>; <span class="hljs-comment">// 内部链接</span>
<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">foo</span><span class="hljs-params">()</span></span>
<span class="hljs-function"></span>{
    Message&lt;hello&gt; msg; <span class="hljs-comment">// OK (all C++ versions)</span>
    Message&lt;hello11&gt; msg11; <span class="hljs-comment">// OK since C++11</span>
    <span class="hljs-type">static</span> <span class="hljs-type">const</span> <span class="hljs-type">char</span> hello17[] = <span class="hljs-string">"Hello World!"</span>; <span class="hljs-comment">// 无联动</span>
    Message&lt;hello17&gt; msg17; <span class="hljs-comment">// OK since C++17</span>
}</code></pre></div>

<p>也就是说，从 C++17 开始，您仍然需要两行来将字符串文字传递给模板。 但是您可以将第一行放在与类实例化相同的范围内。<br>这种能力也解决了一个不幸的限制：虽然你可以将指针传递给自 C++11 以来的类模板：</p>
<div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">template</span>&lt;<span class="hljs-type">int</span>* p&gt; <span class="hljs-keyword">struct</span> <span class="hljs-title class_">A</span> {
};
<span class="hljs-type">int</span> num;
A&lt;&amp;num&gt; a; <span class="hljs-comment">// OK since C++11</span></code></pre></div>

<p>您不能使用返回地址的编译时函数，现在支持：</p>
<div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-type">int</span> num;
...
<span class="hljs-function"><span class="hljs-keyword">constexpr</span> <span class="hljs-type">int</span>* <span class="hljs-title">pNum</span><span class="hljs-params">()</span> </span>{
    <span class="hljs-keyword">return</span> &amp;num;
}
A&lt;<span class="hljs-built_in">pNum</span>()&gt; b; <span class="hljs-comment">// ERROR before C++17, now OK</span></code></pre></div>

<h4><span id="12-2-hou-ji">12.2 后记</span><a href="#12-2-hou-ji" class="header-anchor">#</a></h4><p>允许对所有非类型模板参数进行持续评估是由 Richard Smith 在 <a target="_blank" rel="noopener" href="https://wg21.link/n4198">https://wg21.link/n4198</a> 中首次提出的。 最终接受的措辞由 Richard Smith 在 <a target="_blank" rel="noopener" href="https://wg21.link/n4268">https://wg21.link/n4268</a> 中制定。</p>
<h3><span id="13-zhan-wei-fu-lei-xing-li-ru-auto-zuo-wei-mo-ban-can-shu">13 占位符类型（例如 auto）作为模板参数</span><a href="#13-zhan-wei-fu-lei-xing-li-ru-auto-zuo-wei-mo-ban-can-shu" class="header-anchor">#</a></h3><p>从 C++17 开始，您可以使用占位符类型（auto 和 decltype(auto)）作为非类型模板参数类型。 这意味着，我们可以为不同类型的非类型参数编写通用代码。</p>
<h4><span id="13-1-shi-yong-auto-zuo-wei-mo-ban-can-shu">13.1 使用auto作为模板参数</span><a href="#13-1-shi-yong-auto-zuo-wei-mo-ban-can-shu" class="header-anchor">#</a></h4><p>从 C++17 开始，您可以使用 auto 来声明非类型模板参数。 例如：</p>
<div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">auto</span> N&gt; <span class="hljs-keyword">class</span> <span class="hljs-title class_">S</span> {
    ...
};</code></pre></div>

<p>这允许我们为不同类型实例化非类型模板参数 N：</p>
<div class="code-wrapper"><pre><code class="hljs c++">S&lt;<span class="hljs-number">42</span>&gt; s1; <span class="hljs-comment">// OK: S 中 N 的类型是 int</span>
S&lt;<span class="hljs-string">'a'</span>&gt; s2; <span class="hljs-comment">// OK: S 中 N 的类型是 char</span></code></pre></div>

<p>但是，您不能使用此功能来获取通常不允许作为模板参数的类型的实例化：</p>
<div class="code-wrapper"><pre><code class="hljs c++">S&lt;<span class="hljs-number">2.5</span>&gt; s3； <span class="hljs-comment">// 错误：模板参数类型仍然不能为双精度</span></code></pre></div>

<p>我们甚至可以有一个特定的类型作为部分特化：</p>
<div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">template</span>&lt;<span class="hljs-type">int</span> N&gt; <span class="hljs-keyword">class</span> <span class="hljs-title class_">S</span>&lt;N&gt; {
    ...
};</code></pre></div>

<p>甚至支持类模板参数推导。 例如：</p>
<div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T, <span class="hljs-keyword">auto</span> N&gt;
<span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span> {
<span class="hljs-keyword">public</span>:
    <span class="hljs-built_in">A</span>(<span class="hljs-type">const</span> std::array&lt;T,N&gt;&amp;) {
    }
    <span class="hljs-built_in">A</span>(<span class="hljs-built_in">T</span>(&amp;)[N]) {
    }
    ...
};
</code></pre></div>

<p>这个类可以推导出T的类型，N的类型，N的值：</p>
<div class="code-wrapper"><pre><code class="hljs c++">A a2{<span class="hljs-string">"hello"</span>}; <span class="hljs-comment">// OK, 推导出 A&lt;const char, 6&gt; 其中 N 为 int</span>
std::array&lt;<span class="hljs-type">double</span>,10&gt; sa1;
A a1{sa1}; <span class="hljs-comment">// OK, 推导出 A&lt;double, 10&gt; 其中 N 为 std::size_t</span></code></pre></div>

<p>您还可以限定 auto，例如，要求模板参数的类型是指针：</p>
<div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">template</span>&lt;<span class="hljs-type">const</span> <span class="hljs-keyword">auto</span>* P&gt; <span class="hljs-keyword">struct</span> <span class="hljs-title class_">S</span>;</code></pre></div>

<p> 通过使用可变参数模板，您可以参数化模板以使用异构常量模板参数列表：</p>
<div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">auto</span>... VS&gt; <span class="hljs-keyword">class</span> <span class="hljs-title class_">HeteroValueList</span> {
};</code></pre></div>

<p>或同质常量模板参数列表：</p>
<div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">auto</span> V1, <span class="hljs-keyword">decltype</span>(V1)... VS&gt; <span class="hljs-keyword">class</span> <span class="hljs-title class_">HomoValueList</span> {
};</code></pre></div>

<p>例如：</p>
<div class="code-wrapper"><pre><code class="hljs c++">HeteroValueList&lt;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>&gt; vals1; <span class="hljs-comment">// OK</span>
HeteroValueList&lt;<span class="hljs-number">1</span>, <span class="hljs-string">'a'</span>, <span class="hljs-literal">true</span>&gt; vals2; <span class="hljs-comment">// OK</span>
HomoValueList&lt;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>&gt; vals3; <span class="hljs-comment">// OK</span>
HomoValueList&lt;<span class="hljs-number">1</span>, <span class="hljs-string">'a'</span>, <span class="hljs-literal">true</span>&gt; vals4; <span class="hljs-comment">// ERROR</span></code></pre></div>

<h5><span id="13-1-1-zi-fu-he-zi-fu-chuan-de-can-shu-hua-mo-ban">13.1.1 字符和字符串的参数化模板</span><a href="#13-1-1-zi-fu-he-zi-fu-chuan-de-can-shu-hua-mo-ban" class="header-anchor">#</a></h5><p>此功能的一个应用是允许将字符或字符串作为模板参数传递。<br>例如，我们可以改进使用折叠表达式输出任意数量参数的方式，如下所示：</p>
<div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span>
<span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">auto</span> Sep </span>= <span class="hljs-string">' '</span>, <span class="hljs-keyword">typename</span> First, <span class="hljs-keyword">typename</span>... Args&gt;
<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">print</span><span class="hljs-params">(<span class="hljs-type">const</span> First&amp; first, <span class="hljs-type">const</span> Args&amp;... args)</span> </span>{
    std::cout &lt;&lt; first;
    <span class="hljs-keyword">auto</span> outWithSep = [](<span class="hljs-type">const</span> <span class="hljs-keyword">auto</span>&amp; arg) {
        std::cout &lt;&lt; Sep &lt;&lt; arg;
    };
    (... , <span class="hljs-built_in">outWithSep</span>(args));
    std::cout &lt;&lt; <span class="hljs-string">'\n'</span>;
}</code></pre></div>

<p>尽管如此，我们可以打印带有空格的参数作为模板参数的默认参数<br> Sep:  </p>
<div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">auto</span> Sep </span>= <span class="hljs-string">' '</span>, <span class="hljs-keyword">typename</span> First, <span class="hljs-keyword">typename</span>... Args&gt;
<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">print</span> <span class="hljs-params">(<span class="hljs-type">const</span> First&amp; firstarg, <span class="hljs-type">const</span> Args&amp;... args)</span> </span>{
    ...
}</code></pre></div>

<p>也就是说，我们仍然可以调用：</p>
<div class="code-wrapper"><pre><code class="hljs c++">std::string s{<span class="hljs-string">"world"</span>};
<span class="hljs-built_in">print</span>(<span class="hljs-number">7.5</span>, <span class="hljs-string">"hello"</span>, s); <span class="hljs-comment">// prints: 7.5 hello world</span></code></pre></div>

<p>但是通过为分隔符 Sep 参数化 print()，我们现在可以显式传递一个不同的字符作为第一个模板参数：</p>
<div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-built_in">print</span>&lt;<span class="hljs-string">'-'</span>&gt;(<span class="hljs-number">7.5</span>, <span class="hljs-string">"hello"</span>, s); <span class="hljs-comment">// prints: 7.5-hello-world</span></code></pre></div>

<p>由于使用了 auto，我们甚至可以传递一个字符串文字，我们必须将其声明为没有链接的对象，不过：</p>
<div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-type">static</span> <span class="hljs-type">const</span> <span class="hljs-type">char</span> sep[] = <span class="hljs-string">", "</span>;
<span class="hljs-built_in">print</span>&lt;sep&gt;(<span class="hljs-number">7.5</span>, <span class="hljs-string">"hello"</span>, s); <span class="hljs-comment">// prints: 7.5, hello, world</span></code></pre></div>

<p>或者我们可以传递可用作模板参数的任何其他类型的分隔符（这比这里更有意义）：</p>
<div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-built_in">print</span>&lt;<span class="hljs-number">-11</span>&gt;(<span class="hljs-number">7.5</span>, <span class="hljs-string">"hello"</span>, s); <span class="hljs-comment">// prints: 7.5-11hello-11world</span></code></pre></div>

<h5><span id="13-1-2-ding-yi-yuan-bian-cheng-chang-liang">13.1.2 定义元编程常量</span><a href="#13-1-2-ding-yi-yuan-bian-cheng-chang-liang" class="header-anchor">#</a></h5><p>模板参数自动特性的另一个应用是更容易定义编译时常量。 而不是定义：</p>
<div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T, T v&gt;
<span class="hljs-keyword">struct</span> <span class="hljs-title class_">constant</span>
{
    <span class="hljs-type">static</span> <span class="hljs-keyword">constexpr</span> T value = v;
};
<span class="hljs-keyword">using</span> i = constant&lt;<span class="hljs-type">int</span>, <span class="hljs-number">42</span>&gt;;
<span class="hljs-keyword">using</span> c = constant&lt;<span class="hljs-type">char</span>, <span class="hljs-string">'x'</span>&gt;;
<span class="hljs-keyword">using</span> b = constant&lt;<span class="hljs-type">bool</span>, <span class="hljs-literal">true</span>&gt;;</code></pre></div>

<p>您现在可以执行以下操作：</p>
<div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">auto</span> v&gt;
<span class="hljs-keyword">struct</span> <span class="hljs-title class_">constant</span>
{
    <span class="hljs-type">static</span> <span class="hljs-keyword">constexpr</span> <span class="hljs-keyword">auto</span> value = v;
};
<span class="hljs-keyword">using</span> i = constant&lt;<span class="hljs-number">42</span>&gt;;
<span class="hljs-keyword">using</span> c = constant&lt;<span class="hljs-string">'x'</span>&gt;;
<span class="hljs-keyword">using</span> b = constant&lt;<span class="hljs-literal">true</span>&gt;;</code></pre></div>

<p>而不是：</p>
<div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T, T... Elements&gt;
<span class="hljs-keyword">struct</span> <span class="hljs-title class_">sequence</span> {
};
<span class="hljs-keyword">using</span> indexes = sequence&lt;<span class="hljs-type">int</span>, <span class="hljs-number">0</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>&gt;;</code></pre></div>

<p>你现在可以实现：</p>
<div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">auto</span>... Elements&gt;
<span class="hljs-keyword">struct</span> <span class="hljs-title class_">sequence</span> {
};
<span class="hljs-keyword">using</span> indexes = sequence&lt;<span class="hljs-number">0</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>&gt;;</code></pre></div>

<p>您现在甚至可以定义表示异构值列表的编译时对象（类似于压缩元组）：</p>
<div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">using</span> tuple = sequence&lt;<span class="hljs-number">0</span>, <span class="hljs-string">'h'</span>, <span class="hljs-literal">true</span>&gt;;
</code></pre></div>

<h4><span id="13-2-shi-yong-auto-zuo-wei-ke-bian-mo-ban-can-shu">13.2 使用 auto 作为可变模板参数</span><a href="#13-2-shi-yong-auto-zuo-wei-ke-bian-mo-ban-can-shu" class="header-anchor">#</a></h4><p>您还可以将 auto 用作带有变量模板的模板参数。 例如，以下可能出现在头文件中的声明定义了一个变量模板 arr 参数化为元素的类型以及元素数量的磁带和值：</p>
<div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T, <span class="hljs-keyword">auto</span> N&gt; std::array&lt;T,N&gt; arr;</code></pre></div>

<p>在每个翻译单元中， arr&lt;int,10&gt; 的所有用法共享同一个全局对象，而 arr&lt;long,10&gt; 和 arr&lt;int,10u&gt; 将是不同的全局对象（同样，它们都可用于所有翻译单元）。</p>
<p>作为一个完整的示例，请考虑以下头文件：</p>
<p><code>tmpl/vartmplauto.hpp</code></p>
<div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">ifndef</span> VARTMPLAUTO_HPP</span>
<span class="hljs-meta">#<span class="hljs-keyword">define</span> VARTMPLAUTO_HPP</span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;array&gt;</span></span>
<span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T, <span class="hljs-keyword">auto</span> N&gt; std::array&lt;T,N&gt; arr{};
<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">printArr</span><span class="hljs-params">()</span></span>;
<span class="hljs-meta">#<span class="hljs-keyword">endif</span> <span class="hljs-comment">// VARTMPLAUTO_HPP</span></span></code></pre></div>

<p>在这里，一个翻译单元可以修改这个变量模板的两个不同实例的值</p>
<p><code>tmpl/vartmplauto1.cpp </code></p>
<div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">"vartmplauto.hpp"</span></span>
<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>
<span class="hljs-function"></span>{
    arr&lt;<span class="hljs-type">int</span>,<span class="hljs-number">5</span>&gt;[<span class="hljs-number">0</span>] = <span class="hljs-number">17</span>;
    arr&lt;<span class="hljs-type">int</span>,<span class="hljs-number">5</span>&gt;[<span class="hljs-number">3</span>] = <span class="hljs-number">42</span>;
    arr&lt;<span class="hljs-type">int</span>,<span class="hljs-number">5u</span>&gt;[<span class="hljs-number">1</span>] = <span class="hljs-number">11</span>;
    arr&lt;<span class="hljs-type">int</span>,<span class="hljs-number">5u</span>&gt;[<span class="hljs-number">3</span>] = <span class="hljs-number">33</span>;
    <span class="hljs-built_in">printArr</span>();
}</code></pre></div>

<p>另一个翻译单元可以打印这两个变量：</p>
<p><code>tmpl/vartmplauto2.cpp </code></p>
<div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">"vartmplauto.hpp"</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span>
<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">printArr</span><span class="hljs-params">()</span></span>
<span class="hljs-function"></span>{
    std::cout &lt;&lt; <span class="hljs-string">"arr&lt;int,5&gt;: "</span>;
    <span class="hljs-keyword">for</span> (<span class="hljs-type">const</span> <span class="hljs-keyword">auto</span>&amp; elem : arr&lt;<span class="hljs-type">int</span>,<span class="hljs-number">5</span>&gt;) {
        std::cout &lt;&lt; elem &lt;&lt; <span class="hljs-string">' '</span>;
    }
    std::cout &lt;&lt; <span class="hljs-string">"\narr&lt;int,5u&gt;: "</span>;
    <span class="hljs-keyword">for</span> (<span class="hljs-type">const</span> <span class="hljs-keyword">auto</span>&amp; elem : arr&lt;<span class="hljs-type">int</span>,<span class="hljs-number">5u</span>&gt;) {
        std::cout &lt;&lt; elem &lt;&lt; <span class="hljs-string">' '</span>;
    }
    std::cout &lt;&lt; <span class="hljs-string">'\n'</span>;
}</code></pre></div>

<p>该程序的输出将是：</p>
<div class="code-wrapper"><pre><code class="hljs c++">arr&lt;<span class="hljs-type">int</span>,<span class="hljs-number">5</span>&gt;: <span class="hljs-number">17</span> <span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">42</span> <span class="hljs-number">0</span>
arr&lt;<span class="hljs-type">int</span>,<span class="hljs-number">5u</span>&gt;: <span class="hljs-number">0</span> <span class="hljs-number">11</span> <span class="hljs-number">0</span> <span class="hljs-number">33</span> <span class="hljs-number">0</span></code></pre></div>

<p>与声明从其初始值推导出的任意类型的常量变量相同的方式：</p>
<div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">auto</span> N&gt; <span class="hljs-keyword">constexpr</span> <span class="hljs-keyword">auto</span> val = N; <span class="hljs-comment">// OK since C++17</span></code></pre></div>

<p>并在以后使用它，例如，如下：</p>
<div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">auto</span> v1 = val&lt;<span class="hljs-number">5</span>&gt;; <span class="hljs-comment">// v1 == 5, v1 is int</span>
<span class="hljs-keyword">auto</span> v2 = val&lt;<span class="hljs-literal">true</span>&gt;; <span class="hljs-comment">// v2 == true, v2 is bool</span>
<span class="hljs-keyword">auto</span> v3 = val&lt;<span class="hljs-string">'a'</span>&gt;; <span class="hljs-comment">// v3 == ’a’, v3 is char</span></code></pre></div>

<p>为了澄清这里发生了什么：</p>
<div class="code-wrapper"><pre><code class="hljs c++">std::is_same_v&lt;<span class="hljs-keyword">decltype</span>(val&lt;<span class="hljs-number">5</span>&gt;), <span class="hljs-type">int</span>&gt; <span class="hljs-comment">// yields false</span>
std::is_same_v&lt;<span class="hljs-keyword">decltype</span>(val&lt;<span class="hljs-number">5</span>&gt;), <span class="hljs-type">const</span> <span class="hljs-type">int</span>&gt; <span class="hljs-comment">// yields true</span>
std::is_same_v&lt;<span class="hljs-keyword">decltype</span>(v1), <span class="hljs-type">int</span>&gt;; <span class="hljs-comment">// yields true (because auto decays)</span></code></pre></div>

<h4><span id="13-3-shi-yong-decltype-auto-zuo-wei-mo-ban-can-shu">13.3 使用decltype(auto)作为模板参数</span><a href="#13-3-shi-yong-decltype-auto-zuo-wei-mo-ban-can-shu" class="header-anchor">#</a></h4><p>您还可以使用 C++14 引入的其他占位符类型 decltype(auto)。 但是请注意，这种类型有非常特殊的规则来推断类型。 根据decltype，如果传递的是表达式而不是名称，它会根据表达式的值类别推导类型：</p>
<ul>
<li>纯右值的类型（例如，临时值）</li>
<li>type&amp; 用于左值（例如，具有名称的对象）</li>
<li>xvalue 的类型&amp;&amp;（例如，转换为右值引用的对象，与 std::move() 一样。<br>这意味着，您可以轻松地将模板参数推导出为引用，这可能会产生令人惊讶的效果。<br>例如：</li>
</ul>
<p><code>tmpl/decltypeauto.cpp </code></p>
<div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span>
<span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">decltype</span>(<span class="hljs-keyword">auto</span>) N&gt;
<span class="hljs-keyword">struct</span> <span class="hljs-title class_">S</span> {
    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">printN</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>{
        std::cout &lt;&lt; <span class="hljs-string">"N: "</span> &lt;&lt; N &lt;&lt; <span class="hljs-string">'\n'</span>;
    }
};
<span class="hljs-type">static</span> <span class="hljs-type">const</span> <span class="hljs-type">int</span> c = <span class="hljs-number">42</span>;
<span class="hljs-type">static</span> <span class="hljs-type">int</span> v = <span class="hljs-number">42</span>;
<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>
<span class="hljs-function"></span>{
    S&lt;c&gt; s1; <span class="hljs-comment">// 将 N 推导出为 const int 42</span>
    S&lt;(c)&gt; s2; <span class="hljs-comment">// 将 N 推导出为 const int&amp; 引用 c</span>
    s1.<span class="hljs-built_in">printN</span>();
    s2.<span class="hljs-built_in">printN</span>();
    S&lt;(v)&gt; s3; <span class="hljs-comment">// 将 N 推导出为 int&amp; 引用 v</span>
    v = <span class="hljs-number">77</span>;
    s3.<span class="hljs-built_in">printN</span>(); <span class="hljs-comment">// prints: N: 77</span>
}</code></pre></div>

<h4><span id="13-4-hou-ji">13.4 后记</span><a href="#13-4-hou-ji" class="header-anchor">#</a></h4><p>非类型模板参数的占位符类型最早由 James Touton 和 Michael 提出<br>Spertus 作为 <a target="_blank" rel="noopener" href="https://wg21.link/n4469">https://wg21.link/n4469</a> 的一部分。 最终接受的措辞是由<br><a target="_blank" rel="noopener" href="https://wg21.link/p0127r2">https://wg21.link/p0127r2</a> 中的 James Touton 和 Michael Spertus。</p>
<h3><span id="14-kuo-zhan-using-sheng-ming">14  扩展Using声明</span><a href="#14-kuo-zhan-using-sheng-ming" class="header-anchor">#</a></h3><p>使用声明被扩展为允许以逗号分隔的声明列表，以允许它们在包扩展中使用。<br>例如，您现在可以编程：</p>
<div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Base</span> {
    <span class="hljs-keyword">public</span>:
    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">a</span><span class="hljs-params">()</span></span>;
    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">b</span><span class="hljs-params">()</span></span>;
    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">c</span><span class="hljs-params">()</span></span>;
};
<span class="hljs-keyword">class</span> <span class="hljs-title class_">Derived</span> : <span class="hljs-keyword">private</span> Base {
    <span class="hljs-keyword">public</span>:
    <span class="hljs-keyword">using</span> Base::a, Base::b, Base::c;
};</code></pre></div>

<p>在 C++17 之前，您需要三种不同的 using 声明。</p>
<h4><span id="14-1-shi-yong-ke-bian-can-shu-using-sheng-ming">14.1 使用可变参数using声明</span><a href="#14-1-shi-yong-ke-bian-can-shu-using-sheng-ming" class="header-anchor">#</a></h4><p>使用逗号分隔的声明提供了从基类的可变参数列表中一般派生所有同类操作的能力。<br>这种技术的一个非常酷的应用是创建一组 lambda 重载。 通过定义以下内容：</p>
<p> <code>tmpl/overload.hpp</code></p>
<div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-comment">// ”inherit” all function call operators of passed base types:</span>
<span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span>... Ts&gt;
<span class="hljs-keyword">struct</span> <span class="hljs-title class_">overload</span> : Ts...
{
    <span class="hljs-function"><span class="hljs-keyword">using</span> <span class="hljs-title">Ts::operator</span><span class="hljs-params">()</span>...</span>;
};
<span class="hljs-comment">// base types are deduced from passed arguments:</span>
<span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span>... Ts&gt;</span>
<span class="hljs-function"><span class="hljs-title">overload</span><span class="hljs-params">(Ts...)</span> -&gt; overload&lt;Ts...&gt;</span>;</code></pre></div>

<p>您可以重载两个 lambda，如下所示：</p>
<div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">auto</span> twice = overload {
    [](std::string&amp; s) { s += s; },
    [](<span class="hljs-keyword">auto</span>&amp; v) { v *= <span class="hljs-number">2</span>; }
};</code></pre></div>

<p>这里我们创建了一个类型重载的对象，我们使用推导指南将 lambdas 的类型推导出为模板类型重载的基类，并使用聚合初始化来初始化具有闭包类型的复制构造函数的基类的子对象 ，每个 lambda 都有。<br>然后 using 声明使两个函数调用运算符都可用于类型重载。 如果没有 using 声明，基类将具有同一成员的两个不同重载<br>函数 operator()，这是模棱两可的。<br>因此，您可以传递一个字符串，它调用第一个重载或传递另一个类型，它（假设运算符 *= 有效）使用第二个重载：</p>
<div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-type">int</span> i = <span class="hljs-number">42</span>;
<span class="hljs-built_in">twice</span>(i);
std::cout &lt;&lt; <span class="hljs-string">"i: "</span> &lt;&lt; i &lt;&lt; <span class="hljs-string">'\n'</span>; <span class="hljs-comment">// prints: 84</span>
std::string s = <span class="hljs-string">"hi"</span>;
<span class="hljs-built_in">twice</span>(s);
std::cout &lt;&lt; <span class="hljs-string">"s: "</span> &lt;&lt; s &lt;&lt; <span class="hljs-string">'\n'</span>; <span class="hljs-comment">// prints: hihi</span></code></pre></div>

<p>这种技术的一个应用是 std::variant 访问者。</p>
<h4><span id="14-2-shi-yong-sheng-ming-ji-cheng-gou-zao-han-shu-de-ke-bian-can-shu">14.2 使用声明继承构造函数的可变参数</span><a href="#14-2-shi-yong-sheng-ming-ji-cheng-gou-zao-han-shu-de-ke-bian-can-shu" class="header-anchor">#</a></h4><p>除了对继承构造函数的一些说明外，现在还可以进行以下操作：您可以声明一个可变参数类模板 Multi，该模板派生自其每个传递的类型的基类：</p>
<p><code>tmpl/using2.hpp </code></p>
<div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;
<span class="hljs-keyword">class</span> <span class="hljs-title class_">Base</span> {
    T value{};
    <span class="hljs-keyword">public</span>:
    <span class="hljs-built_in">Base</span>() {
        ...
    }
    <span class="hljs-built_in">Base</span>(T v) : value{v} {
        ...
    }
    ...
};
<span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span>... Types&gt;
<span class="hljs-keyword">class</span> <span class="hljs-title class_">Multi</span> : <span class="hljs-keyword">private</span> Base&lt;Types&gt;...
{
    <span class="hljs-keyword">public</span>:
    <span class="hljs-comment">// derive all constructors:</span>
    <span class="hljs-keyword">using</span> Base&lt;Types&gt;::Base...;
    ...
};</code></pre></div>

<p>使用所有基类构造函数的 using 声明，您可以为每种类型派生一个对应的构造函数.</p>
<p>现在，当为三种不同类型的值声明 Multi&lt;&gt; 类型时：</p>
<div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">using</span> MultiISB = Multi&lt;<span class="hljs-type">int</span>,std::string,<span class="hljs-type">bool</span>&gt;;</code></pre></div>

<p>您可以使用每个相应的构造函数来声明对象：</p>
<div class="code-wrapper"><pre><code class="hljs c++">MultiISB m1 = <span class="hljs-number">42</span>;
MultiISB m2 = std::<span class="hljs-built_in">string</span>(<span class="hljs-string">"hello"</span>);
MultiISB m3 = <span class="hljs-literal">true</span>;</code></pre></div>

<p>根据新的语言规则，每次初始化都会为匹配的基类调用相应的构造函数，并为所有其他基类调用默认构造函数。 因此:</p>
<div class="code-wrapper"><pre><code class="hljs c++">MultiISB m2 = std::<span class="hljs-built_in">string</span>(<span class="hljs-string">"hello"</span>);</code></pre></div>

<p>调用 Base<int> 的默认构造函数、Base<a href="std::string">std::string</a> 的字符串构造函数和 Base<bool> 的默认构造函数。<br>原则上，您还可以通过指定启用 Multi&lt;&gt; 中的所有赋值运算符：</bool></int></p>
<div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span>... Types&gt;
<span class="hljs-keyword">class</span> <span class="hljs-title class_">Multi</span> : <span class="hljs-keyword">private</span> Base&lt;Types&gt;...
{
    ...
    <span class="hljs-comment">// 导出所有赋值运算符:</span>
    <span class="hljs-keyword">using</span> Base&lt;Types&gt;::<span class="hljs-keyword">operator</span>=...;
}</code></pre></div>

<h4><span id="14-3-hou-ji">14.3 后记</span><a href="#14-3-hou-ji" class="header-anchor">#</a></h4><p>逗号分隔的 using 声明由 Robert Haberlach 在 <a target="_blank" rel="noopener" href="https://wg21.link/p0195r0">https://wg21.link/p0195r0</a> 中提出。 最终接受的措辞由 Robert Haberlach 和 Richard Smith 在 <a target="_blank" rel="noopener" href="https://wg21.link/p0195r2">https://wg21.link/p0195r2</a> 中制定。<br>各种核心问题要求对继承构造函数进行澄清。 最终接受的修复它们的措辞由 Richard Smith 在 <a target="_blank" rel="noopener" href="https://wg21.link/n4429">https://wg21.link/n4429</a> 中制定。<br>Vicente J. Botet Escriba 提出了一个建议，即添加一个泛型重载函数来重载 lambda，以及普通函数和成员函数。 然而，这篇论文并没有进入 C++17。 有关详细信息，请参阅 <a target="_blank" rel="noopener" href="https://wg21.link/p0051r1%E3%80%82">https://wg21.link/p0051r1。</a></p>

            </div>
            <hr>
            <div>
              <div class="post-metas mb-3">
                
                
                  <div class="post-meta">
                    <i class="iconfont icon-tags"></i>
                    
                      <a class="hover-with-bg" href="/tags/C-17/">C++17</a>
                    
                      <a class="hover-with-bg" href="/tags/Template/">Template</a>
                    
                  </div>
                
              </div>
              
                <p class="note note-warning">
                  
                    本博客所有文章除特别声明外，均采用 <a target="_blank" href="https://creativecommons.org/licenses/by-sa/4.0/deed.zh" rel="nofollow noopener noopener">CC BY-SA 4.0 协议</a> ，转载请注明出处！
                  
                </p>
              
              
                <div class="post-prevnext">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/2022/03/19/%E7%AC%AC%E4%B8%89%E9%83%A8%E5%88%86%20%E6%96%B0%E7%9A%84%E6%A0%87%E5%87%86%E5%BA%93%E7%BB%84%E4%BB%B6/">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">第三部分-新的标准库组件</span>
                        <span class="visible-mobile">上一篇</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2022/03/18/hello-world/">
                        <span class="hidden-mobile">Hello World</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
              <!-- Comments -->
              <article class="comments" id="comments" lazyload>
                
                  
                
                
  <div id="lv-container" data-id="city" data-uid="MTAyMC81NTMzMi8zMTc5OQ==">
    <script type="text/javascript">
      Fluid.utils.loadComments('#lv-container', function() {
        Fluid.utils.createScript('https://cdn-city.livere.com/js/embed.dist.js');
      });
    </script>
    <noscript>Please enable JavaScript to view the comments</noscript>
  </div>


              </article>
            
          </article>
        </div>
      </div>
    </div>
    
      <div class="d-none d-lg-block col-lg-2 toc-container" id="toc-ctn">
        <div id="toc">
  <p class="toc-header"><i class="iconfont icon-list"></i>&nbsp;目录</p>
  <div class="toc-body" id="toc-body"></div>
</div>

      </div>
    
  </div>
</div>

<!-- Custom -->


    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v"
                 for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>
    

    
  </main>

  <footer class="text-center mt-5 py-3">
  <div class="footer-content">
     <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> 
  </div>
  

  

  
</footer>


  <!-- SCRIPTS -->
  
  <script  src="https://cdn.jsdelivr.net/npm/nprogress@0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/nprogress@0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js" ></script>
<script  src="https://cdn.jsdelivr.net/npm/bootstrap@4/dist/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>

<!-- Plugins -->


  <script  src="/js/local-search.js" ></script>



  
    <script  src="/js/img-lazyload.js" ></script>
  



  



  
    <script  src="https://cdn.jsdelivr.net/npm/tocbot@4/dist/tocbot.min.js" ></script>
  
  
    <script  src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3/dist/jquery.fancybox.min.js" ></script>
  
  
    <script  src="https://cdn.jsdelivr.net/npm/anchor-js@4/anchor.min.js" ></script>
  
  
    <script defer src="https://cdn.jsdelivr.net/npm/clipboard@2/dist/clipboard.min.js" ></script>
  






  <script  src="https://cdn.jsdelivr.net/npm/typed.js@2/lib/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var title = document.getElementById('subtitle').title;
      
        typing(title);
      
    })(window, document);
  </script>















<!-- 主题的启动项 保持在最底部 -->
<script  src="/js/boot.js" ></script>


</body>
</html>
