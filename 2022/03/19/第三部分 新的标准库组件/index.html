

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=auto>



<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/logo.jpg">
  <link rel="icon" href="/img/logo.jpg">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
    <meta http-equiv="Content-Security-Policy" content="upgrade-insecure-requests">
  
  <meta name="theme-color" content="#6aa84f">
  <meta name="author" content="John Doe">
  <meta name="keywords" content="">
  
    <meta name="description" content="第三部分 新的标准库组件#本部分介绍了 C++17 的新库组件。 15 std::optional&lt;&gt;#在编程中，我们经常遇到可能返回&#x2F;传递&#x2F;使用某种类型的对象的情况。也就是说，我们可以有一个特定类型的值，或者我们可能根本没有任何值。因此，我们需要一种模拟类似于指针的语义的方法，我们可以通过使用 nullptr 来表示没有值。处理这个问题的方法是定义一个特定类型的对象，带有一个额外的布">
<meta property="og:type" content="article">
<meta property="og:title" content="第三部分-新的标准库组件">
<meta property="og:url" content="https://txt1994.github.io/2022/03/19/%E7%AC%AC%E4%B8%89%E9%83%A8%E5%88%86%20%E6%96%B0%E7%9A%84%E6%A0%87%E5%87%86%E5%BA%93%E7%BB%84%E4%BB%B6/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:description" content="第三部分 新的标准库组件#本部分介绍了 C++17 的新库组件。 15 std::optional&lt;&gt;#在编程中，我们经常遇到可能返回&#x2F;传递&#x2F;使用某种类型的对象的情况。也就是说，我们可以有一个特定类型的值，或者我们可能根本没有任何值。因此，我们需要一种模拟类似于指针的语义的方法，我们可以通过使用 nullptr 来表示没有值。处理这个问题的方法是定义一个特定类型的对象，带有一个额外的布">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="c:/string_view.png">
<meta property="article:published_time" content="2022-03-18T16:01:15.000Z">
<meta property="article:modified_time" content="2022-03-18T17:20:02.171Z">
<meta property="article:author" content="John Doe">
<meta property="article:tag" content="C++17">
<meta property="article:tag" content="STL">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="c:/string_view.png">
  
  
  <title>第三部分-新的标准库组件 - Hexo</title>

  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4/dist/css/bootstrap.min.css" />


  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/github-markdown-css@4/github-markdown.min.css" />
  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/hint.css@2/hint.min.css" />

  
    
    
      
      <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@10/styles/github-gist.min.css" />
    
  

  
    <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3/dist/jquery.fancybox.min.css" />
  


<!-- 主题依赖的图标库，不要自行修改 -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_ba1fz6golrf.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_lbnruvf0jn.css">


<link  rel="stylesheet" href="/css/main.css" />

<!-- 自定义样式保持在最底部 -->

  
<link rel="stylesheet" href="/css/style.css">



  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    var CONFIG = {"hostname":"txt1994.github.io","root":"/","version":"1.8.14","typing":{"enable":true,"typeSpeed":70,"cursorChar":"_","loop":false},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"right","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"copy_btn":true,"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":false,"baidu":null,"google":null,"gtag":null,"tencent":{"sid":null,"cid":null},"woyaola":null,"cnzz":null,"leancloud":{"app_id":null,"app_key":null,"server_url":null,"path":"window.location.pathname","ignore_local":false}},"search_path":"/local-search.xml"};
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
<meta name="generator" content="Hexo 6.1.0">
<style>.github-emoji { position: relative; display: inline-block; width: 1.2em; min-height: 1.2em; overflow: hidden; vertical-align: top; color: transparent; }  .github-emoji > span { position: relative; z-index: 10; }  .github-emoji img, .github-emoji .fancybox { margin: 0 !important; padding: 0 !important; border: none !important; outline: none !important; text-decoration: none !important; user-select: none !important; cursor: auto !important; }  .github-emoji img { height: 1.2em !important; width: 1.2em !important; position: absolute !important; left: 50% !important; top: 50% !important; transform: translate(-50%, -50%) !important; user-select: none !important; cursor: auto !important; } .github-emoji-fallback { color: inherit; } .github-emoji-fallback img { opacity: 0 !important; }</style>
</head>


<body>
  <header style="height: 70vh;">
    <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/">
      <strong>txt1994s</strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/">
                <i class="iconfont icon-home-fill"></i>
                首页
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/">
                <i class="iconfont icon-archive-fill"></i>
                归档
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/">
                <i class="iconfont icon-tags-fill"></i>
                标签
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/">
                <i class="iconfont icon-user-fill"></i>
                关于
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/links/">
                <i class="iconfont icon-link-fill"></i>
                友联
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              &nbsp;<i class="iconfont icon-search"></i>&nbsp;
            </a>
          </li>
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">&nbsp;<i
                class="iconfont icon-dark" id="color-toggle-icon"></i>&nbsp;</a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

    <div class="banner" id="banner" parallax=true
         style="background: url('/img/default.png') no-repeat center center;
           background-size: cover;">
      <div class="full-bg-img">
        <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
          <div class="page-header text-center fade-in-up">
            <span class="h2" id="subtitle" title="第三部分-新的标准库组件">
              
            </span>

            
              <div class="mt-3">
  
  
    <span class="post-meta">
      <i class="iconfont icon-date-fill" aria-hidden="true"></i>
      <time datetime="2022-03-19 00:01" pubdate>
        2022年3月19日 凌晨
      </time>
    </span>
  
</div>

<div class="mt-1">
  
    <span class="post-meta mr-2">
      <i class="iconfont icon-chart"></i>
      106k 字
    </span>
  

  
    <span class="post-meta mr-2">
      <i class="iconfont icon-clock-fill"></i>
      
      
      886 分钟
    </span>
  

  
  
</div>

            
          </div>

          
        </div>
      </div>
    </div>
  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="d-none d-lg-block col-lg-2"></div>
    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div class="py-5" id="board">
          <article class="post-content mx-auto">
            <!-- SEO header -->
            <h1 style="display: none">第三部分-新的标准库组件</h1>
            
              <p class="note note-info">
                
                  本文最后更新于：2022年3月19日 凌晨
                
              </p>
            
            <div class="markdown-body">
              <h2><span id="di-san-bu-fen-xin-de-biao-zhun-ku-zu-jian">第三部分 新的标准库组件</span><a href="#di-san-bu-fen-xin-de-biao-zhun-ku-zu-jian" class="header-anchor">#</a></h2><p>本部分介绍了 C++17 的新库组件。</p>
<h3><span id="15-std-optional-lt-gt">15 std::optional&lt;&gt;</span><a href="#15-std-optional-lt-gt" class="header-anchor">#</a></h3><p>在编程中，我们经常遇到可能返回/传递/使用某种类型的对象的情况。也就是说，我们可以有一个特定类型的值，或者我们可能根本没有任何值。因此，我们需要一种模拟类似于指针的语义的方法，我们可以通过使用 nullptr 来表示没有值。处理这个问题的方法是定义一个特定类型的对象，带有一个额外的布尔成员/标志，表明一个值是否存在。 std::optional&lt;&gt; 以类型安全的方式提供此类对象。</p>
<p>可选对象仅具有包含对象的内部存储器以及布尔标志。因此，大小通常比包含的对象大一个字节。对于某些包含的类型，甚至可能根本没有大小开销，前提是可以将附加信息放置在包含的对象中。没有分配堆内存。对象使用与包含类型相同的对齐方式。</p>
<p>但是，可选对象不仅仅是将布尔标志的功能添加到值成员的结构。例如，如果没有值，则不会为包含的类型调用构造函数（因此，您可以为对象提供没有的默认状态）。</p>
<p>与 std::variant&lt;&gt; 和 std::any 一样，结果对象具有值语义。也就是说，复制被实现为深度复制，创建一个独立的对象，带有标志和包含的值（如果有的话）在它自己的内存中。复制没有包含值的 std::optional&lt;&gt; 很便宜；复制带有包含值的 std::optional&lt;&gt; 与复制包含的类型/值一样便宜/昂贵。支持移动语义。</p>
<h4><span id="15-1-shi-yong-std-optional-lt-gt">15.1 使用 std::optional&lt;&gt;</span><a href="#15-1-shi-yong-std-optional-lt-gt" class="header-anchor">#</a></h4><p>std::optional&lt;&gt;模型是一个任意类型的可忽略的实例。这个实例可能是一个成员，一个参数，或者一个返回值。你也可以说，std::optional&lt;&gt;是一个容纳零或一个元素的容器。</p>
<h5><span id="15-1-1-ke-xuan-de-fan-hui-zhi">15.1.1 可选的返回值</span><a href="#15-1-1-ke-xuan-de-fan-hui-zhi" class="header-anchor">#</a></h5><p>以下程序演示了 std::optional&lt;&gt; 用作返回值的能力：<br><code>lib/optional.cpp</code></p>
<div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;optional&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span>
<span class="hljs-comment">// 如果可能，将字符串转换为 int:</span>
<span class="hljs-function">std::optional&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">asInt</span><span class="hljs-params">(<span class="hljs-type">const</span> std::string&amp; s)</span></span>
<span class="hljs-function"></span>{
    <span class="hljs-keyword">try</span> {
        <span class="hljs-keyword">return</span> std::<span class="hljs-built_in">stoi</span>(s);
    }
    <span class="hljs-built_in">catch</span> (...) {
        <span class="hljs-keyword">return</span> std::<span class="hljs-literal">nullopt</span>;
    }
}
<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>
<span class="hljs-function"></span>{
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> s : {<span class="hljs-string">"42"</span>, <span class="hljs-string">" 077"</span>, <span class="hljs-string">"hello"</span>, <span class="hljs-string">"0x33"</span>} ) {
        <span class="hljs-comment">// 如果可能，尝试将 s 转换为 int 并打印结果:</span>
        std::optional&lt;<span class="hljs-type">int</span>&gt; oi = <span class="hljs-built_in">asInt</span>(s);
        <span class="hljs-keyword">if</span> (oi) {
            std::cout &lt;&lt; <span class="hljs-string">"convert '"</span> &lt;&lt; s &lt;&lt; <span class="hljs-string">"' to int: "</span> &lt;&lt; *oi &lt;&lt; <span class="hljs-string">"\n"</span>;
        }
        <span class="hljs-keyword">else</span> {
            std::cout &lt;&lt; <span class="hljs-string">"can't convert '"</span> &lt;&lt; s &lt;&lt; <span class="hljs-string">"' to int\n"</span>;
        }
    }
}</code></pre></div>

<p>在程序中 asInt() 是将传递的字符串转换为整数的函数。 但是，这可能不会成功。 出于这个原因，使用了 std::optional&lt;&gt; 以便我们可以返回”no int”并避免为其定义一个特殊的 int 值或向调用者抛出异常。<br>因此，我们要么返回调用 stoi() 的结果，它用一个 int 初始化返回值，要么我们返回 std::nullopt，表明我们没有一个 int 值。 我们可以实现如下相同的行为：</p>
<div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-function">std::optional&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">asInt</span><span class="hljs-params">(<span class="hljs-type">const</span> std::string&amp; s)</span></span>
<span class="hljs-function"></span>{
    std::optional&lt;<span class="hljs-type">int</span>&gt; ret; <span class="hljs-comment">// 最初没有值</span>
    <span class="hljs-keyword">try</span> {
        ret = std::<span class="hljs-built_in">stoi</span>(s);
    }
    <span class="hljs-built_in">catch</span> (...) {
    }
    <span class="hljs-keyword">return</span> ret;
}</code></pre></div>

<p>在 main() 中，我们为不同的字符串调用此函数。</p>
<div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> s : {<span class="hljs-string">"42"</span>, <span class="hljs-string">" 077"</span>, <span class="hljs-string">"hello"</span>, <span class="hljs-string">"0x33"</span>} ) {
    <span class="hljs-comment">// 将 s 转换为 int 并尽可能使用结果:</span>
    std::optional&lt;<span class="hljs-type">int</span>&gt; oi = <span class="hljs-built_in">asInt</span>(s);
    ...
}</code></pre></div>

<p>对于我们评估的每个返回的 std::optional<int> oi，我们是否有一个值（通过将对象评估为布尔表达式）并通过“取消引用”可选对象来访问该值：</int></p>
<div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">if</span> (oi) {
    std::cout &lt;&lt; <span class="hljs-string">"convert '"</span> &lt;&lt; s &lt;&lt; <span class="hljs-string">"' to int: "</span> &lt;&lt; *oi &lt;&lt; <span class="hljs-string">"\n"</span>;
}</code></pre></div>

<p>请注意，对于字符串“0x33”，asInt() 产生 0，因为 stoi() 不会将字符串解析为十六进制值。<br>有其他方法可以实现对返回值的处理，例如：</p>
<div class="code-wrapper"><pre><code class="hljs c++">std::optional&lt;<span class="hljs-type">int</span>&gt; oi = <span class="hljs-built_in">asInt</span>(s);
<span class="hljs-keyword">if</span> (oi.<span class="hljs-built_in">has_value</span>()) {
    std::cout &lt;&lt; <span class="hljs-string">"convert '"</span> &lt;&lt; s &lt;&lt; <span class="hljs-string">"' to int: "</span> &lt;&lt; oi.<span class="hljs-built_in">value</span>() &lt;&lt; <span class="hljs-string">"\n"</span>;
}</code></pre></div>

<p>在这里，has_value() 用于检查是否返回了一个值，并使用 value() 访问它。 value() 比 operator * 更安全：如果不存在值，它会抛出异常。 运算符 * 仅应在您确定可选项包含值时使用； 否则你的程序将有未定义的行为。<br>请注意，我们可以通过使用新类型 std::string_view 来改进 asInt()。</p>
<h5><span id="15-1-2-ke-xuan-can-shu-he-shu-ju-cheng-yuan">15.1.2 可选参数和数据成员</span><a href="#15-1-2-ke-xuan-can-shu-he-shu-ju-cheng-yuan" class="header-anchor">#</a></h5><p>另一个使用 std::optional&lt;&gt; 的例子是参数的可选传递 and/or 数据成员的可选设置：</p>
<p><code>lib/optionalmember.cpp</code></p>
<div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;optional&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span>
<span class="hljs-keyword">class</span> <span class="hljs-title class_">Name</span>
{
<span class="hljs-keyword">private</span>:
    std::string first;
    std::optional&lt;std::string&gt; middle;
    std::string last;
<span class="hljs-keyword">public</span>:
    <span class="hljs-built_in">Name</span> (std::string f, std::optional&lt;std::string&gt; m, std::string l)
        : first{std::<span class="hljs-built_in">move</span>(f)}, middle{std::<span class="hljs-built_in">move</span>(m)}, last{std::<span class="hljs-built_in">move</span>(l)} 
    {}
    <span class="hljs-keyword">friend</span> std::ostream&amp; <span class="hljs-keyword">operator</span> &lt;&lt; (std::ostream&amp; strm, <span class="hljs-type">const</span> Name&amp; n) {
        strm &lt;&lt; n.first &lt;&lt; <span class="hljs-string">' '</span>;
        <span class="hljs-keyword">if</span> (n.middle) {
            strm &lt;&lt; *n.middle &lt;&lt; <span class="hljs-string">' '</span>;
        }
        <span class="hljs-keyword">return</span> strm &lt;&lt; n.last;
    }
};
<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>
<span class="hljs-function"></span>{
    Name n{<span class="hljs-string">"Jim"</span>, std::<span class="hljs-literal">nullopt</span>, <span class="hljs-string">"Knopf"</span>};
    std::cout &lt;&lt; n &lt;&lt; <span class="hljs-string">'\n'</span>;
    Name m{<span class="hljs-string">"Donald"</span>, <span class="hljs-string">"Ervin"</span>, <span class="hljs-string">"Knuth"</span>};
    std::cout &lt;&lt; m &lt;&lt; <span class="hljs-string">'\n'</span>;
}</code></pre></div>

<p>类名表示由名字、可选的中间名和姓氏组成的名称。 成员 middle 被相应地定义，并且构造函数允许在没有中间名时传递 std::nullopt 。 这是与中间名是空字符串不同的状态。</p>
<p>请注意，与通常具有值语义的类型一样，定义初始化相应成员的构造函数的最佳方法是按值获取参数并将参数移动到成员：</p>
<p>还要注意 std::optional&lt;&gt; 改变了对成员中间值的访问。 使用 middle 作为布尔表达式会产生是否存在中间名，必须使用 *middle 来访问当前值（如果有）。</p>
<p>访问该值的另一个选项是使用成员函数 value_or()，它可以在不存在值的情况下指定一个备用值。 例如，在类 Name 中，我们还可以实现：</p>
<div class="code-wrapper"><pre><code class="hljs c++">std::cout &lt;&lt; middle.<span class="hljs-built_in">value_or</span>(<span class="hljs-string">""</span>); <span class="hljs-comment">// 打印中间名或什么都没有</span></code></pre></div>

<h4><span id="15-2-std-optional-lt-gt-lei-xing-he-cao-zuo">15.2 std::optional&lt;&gt; 类型和操作</span><a href="#15-2-std-optional-lt-gt-lei-xing-he-cao-zuo" class="header-anchor">#</a></h4><p>本节详细介绍 std::optional&lt;&gt; 的类型和操作。</p>
<h5><span id="15-2-1-std-optional-lt-gt-lei-xing">15.2.1 std::optional&lt;&gt; 类型</span><a href="#15-2-1-std-optional-lt-gt-lei-xing" class="header-anchor">#</a></h5><p>在头文件 <optional> 中，C++ 标准库定义类 std::optional&lt;&gt; 如下：</optional></p>
<div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">namespace</span> std {
    <span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt; <span class="hljs-keyword">class</span> <span class="hljs-title class_">optional</span>;
}</code></pre></div>

<p>此外，还定义了以下类型和对象：</p>
<ul>
<li>std::nullopt_t 类型的 nullopt 作为没有值的可选对象的“值”。</li>
<li>异常类std::bad_optional_access，它派生自std::exception，用于没有值的值访问。</li>
</ul>
<p>可选对象还使用 <utility> 中定义的对象 std::in_place（std::in_place_t 类型）来初始化具有多个参数的可选对象的值（见下文）。</utility></p>
<h5><span id="15-2-2-std-optional-lt-gt-cao-zuo">15.2.2 std::optional&lt;&gt; 操作</span><a href="#15-2-2-std-optional-lt-gt-cao-zuo" class="header-anchor">#</a></h5><p>表 std::optional Operations 列出了为 std::optional&lt;&gt; 提供的所有操作。</p>
<h6><span id="jian-zao">建造</span><a href="#jian-zao" class="header-anchor">#</a></h6><p>特殊构造函数可以将参数直接传递给包含的类型。</p>
<ul>
<li><p>您可以创建一个没有值的可选对象。 在这种情况下，您必须指定包含的<br>类型：</p>
<div class="code-wrapper"><pre><code class="hljs c++">std::optional&lt;<span class="hljs-type">int</span>&gt; o1;
<span class="hljs-function">std::optional&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">o2</span><span class="hljs-params">(std::<span class="hljs-literal">nullopt</span>)</span></span>;</code></pre></div>

<p>这不会调用包含类型的任何构造函数.</p>
</li>
<li><p>您可以传递一个值来初始化包含的类型。 由于推导指南，您不必指定包含的类型，然后：</p>
<div class="code-wrapper"><pre><code class="hljs c++">std::optional o3{<span class="hljs-number">42</span>}; <span class="hljs-comment">// 推导出optional&lt;int&gt;</span>
std::optional&lt;std::string&gt; o4{<span class="hljs-string">"hello"</span>};
std::optional o5{<span class="hljs-string">"hello"</span>}; <span class="hljs-comment">// 推导出 optional&lt;const char*&gt;</span></code></pre></div></li>
</ul>
<table>
<thead>
<tr>
<th>操作</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>constructors</td>
<td>创建一个可选对象（可能为包含的调用构造函数类型）</td>
</tr>
<tr>
<td>make_optional&lt;&gt;()</td>
<td>创建一个可选对象（传递值来初始化它）</td>
</tr>
<tr>
<td>destructor</td>
<td>销毁一个可选对象</td>
</tr>
<tr>
<td>=</td>
<td>分配一个新值</td>
</tr>
<tr>
<td>emplace()</td>
<td>为包含的类型分配一个新值</td>
</tr>
<tr>
<td>reset()</td>
<td>销毁任何值（使对象为空）</td>
</tr>
<tr>
<td>has_value()</td>
<td>返回对象是否有值</td>
</tr>
<tr>
<td>conversion to bool</td>
<td>返回对象是否有值</td>
</tr>
<tr>
<td>*</td>
<td>值访问（如果没有值，则为未定义行为）</td>
</tr>
<tr>
<td>-&gt;</td>
<td>访问值的成员（如果没有值，则行为未定义）</td>
</tr>
<tr>
<td>value()</td>
<td>值访问（如果没有值则例外）</td>
</tr>
<tr>
<td>value_or()</td>
<td>值访问（如果没有值，则为后备参数）</td>
</tr>
<tr>
<td>swap()</td>
<td>在两个对象之间交换值</td>
</tr>
<tr>
<td>==, !=, &lt;, &lt;=, &gt;, &gt;=</td>
<td>比较可选对象</td>
</tr>
<tr>
<td>hash&lt;&gt;</td>
<td>计算哈希值的函数对象类型</td>
</tr>
</tbody></table>
<ul>
<li><p>要使用多个参数初始化可选对象，您必须创建对象或添加 std::in_place 作为第一个参数（无法推断包含的类型）：</p>
<div class="code-wrapper"><pre><code class="hljs c++">std::optional o6{std::complex{<span class="hljs-number">3.0</span>, <span class="hljs-number">4.0</span>}};
std::optional&lt;std::complex&lt;<span class="hljs-type">double</span>&gt;&gt; o7{std::in_place, <span class="hljs-number">3.0</span>, <span class="hljs-number">4.0</span>};</code></pre></div>

<p>请注意，后一种形式避免了创建临时对象。 通过使用这种形式，你甚至可以传递一个初始化列表和额外的参数：</p>
<div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-comment">// 使用 lambda 作为排序标准初始化集合:</span>
<span class="hljs-keyword">auto</span> sc = [] (<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y) {
    <span class="hljs-keyword">return</span> std::<span class="hljs-built_in">abs</span>(x) &lt; std::<span class="hljs-built_in">abs</span>(y);
};

std::optional&lt;std::set&lt;<span class="hljs-type">int</span>,<span class="hljs-keyword">decltype</span>(sc)&gt;&gt; o8{std::in_place,
                                             {<span class="hljs-number">4</span>, <span class="hljs-number">8</span>, <span class="hljs-number">-7</span>, <span class="hljs-number">-2</span>, <span class="hljs-number">0</span>, <span class="hljs-number">5</span>}, 
                                             sc
                                            };</code></pre></div>
</li>
<li><p>您可以复制可选对象（包括类型转换）。</p>
<div class="code-wrapper"><pre><code class="hljs c++">std::optional o5{<span class="hljs-string">"hello"</span>}; <span class="hljs-comment">// 推导出 optional&lt;const char*&gt;</span>
std::optional&lt;std::string&gt; o9{o5}; <span class="hljs-comment">// OK</span></code></pre></div></li>
</ul>
<p>请注意，还有一个便利函数 make_optional&lt;&gt;()，它允许使用单个或多个参数进行初始化（不需要 in_place 参数）。 像往常一样 make… 函数它会衰减：</p>
<div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">auto</span> o10 = std::<span class="hljs-built_in">make_optional</span>(<span class="hljs-number">3.0</span>); <span class="hljs-comment">// optional&lt;double&gt;</span>
<span class="hljs-keyword">auto</span> o11 = std::<span class="hljs-built_in">make_optional</span>(<span class="hljs-string">"hello"</span>); <span class="hljs-comment">// optional&lt;const char*&gt;</span>
<span class="hljs-keyword">auto</span> o12 = std::make_optional&lt;std::complex&lt;<span class="hljs-type">double</span>&gt;&gt;(<span class="hljs-number">3.0</span>, <span class="hljs-number">4.0</span>);</code></pre></div>

<p>但是，请注意，没有构造函数获取值并根据其值来决定是使用值初始化可选项还是 nullopt。 为此，必须使用运算符 ?:。 例如：</p>
<div class="code-wrapper"><pre><code class="hljs c++">std::multimap&lt;std::string, std::string&gt; englishToGerman;
...
<span class="hljs-keyword">auto</span> pos = englishToGerman.<span class="hljs-built_in">find</span>(<span class="hljs-string">"wisdom"</span>);
<span class="hljs-keyword">auto</span> o13 = pos != englishToGerman.<span class="hljs-built_in">end</span>()
    		? std::optional{pos-&gt;second}
			: std::<span class="hljs-literal">nullopt</span>;</code></pre></div>

<p>在这里，由于 std::optional{pos-&gt;second} 的类模板参数推导，o13 被初始化为 std::optional<a href="std::string">std::string</a>。 对于 std::nullopt 类模板参数推导不起作用，但 operator ?: 在推导表达式的结果类型时也将其转换为这种类型。</p>
<h6><span id="fang-wen-zhi">访问值</span><a href="#fang-wen-zhi" class="header-anchor">#</a></h6><p>要检查可选对象是否具有值，您可以在布尔表达式中使用它或调用 has_value()：</p>
<div class="code-wrapper"><pre><code class="hljs c++">std::optional o{<span class="hljs-number">42</span>};
<span class="hljs-keyword">if</span> (o) ... <span class="hljs-comment">// true</span>
<span class="hljs-keyword">if</span> (!o) ... <span class="hljs-comment">// false</span>
<span class="hljs-keyword">if</span> (o.<span class="hljs-built_in">has_value</span>()) ... <span class="hljs-comment">// true</span></code></pre></div>

<p>然后，为了访问该值，提供了一种指针语法。 也就是说，使用 operator* 您可以直接访问它的值，而 operator-&gt; 可以访问该值的成员：</p>
<div class="code-wrapper"><pre><code class="hljs c++">std::optional o{std::pair{<span class="hljs-number">42</span>, <span class="hljs-string">"hello"</span>}};
<span class="hljs-keyword">auto</span> p = *o; <span class="hljs-comment">// 将 p 初始化为 pair&lt;int,string&gt;</span>
std::cout &lt;&lt; o-&gt;first; <span class="hljs-comment">// prints 42</span></code></pre></div>

<p>请注意，这些运算符要求可选项包含一个值。 在没有值的情况下使用它们是未定义的行为：</p>
<div class="code-wrapper"><pre><code class="hljs c++">std::optional&lt;std::string&gt; o{<span class="hljs-string">"hello"</span>};
std::cout &lt;&lt; *o; <span class="hljs-comment">// OK: prints ”hello”</span>
o = std::<span class="hljs-literal">nullopt</span>;
std::cout &lt;&lt; *o; <span class="hljs-comment">// 未定义的行为</span></code></pre></div>

<p>请注意，实际上第二个输出仍然会编译并执行一些输出，例如再次打印“hello”，因为可选对象的值的底层内存没有被修改。</p>
<p>但是，您不能也不应该依赖它。 如果您不知道可选对象是否有值，则必须调用以下代码：</p>
<div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">if</span> (o) std::cout &lt;&lt; *o; <span class="hljs-comment">// OK (可能什么也不输出)</span></code></pre></div>

<p>或者，您可以使用 value()，如果没有包含值，则会引发 std::bad_optional_access 异常：</p>
<div class="code-wrapper"><pre><code class="hljs c++">std::cout &lt;&lt; o.<span class="hljs-built_in">value</span>(); <span class="hljs-comment">// OK (如果没有值则抛出)</span></code></pre></div>

<p>std::bad_optional_access 直接派生自 std::exception。</p>
<p>最后，您可以请求该值并传递一个备用值，如果可选对象没有值，则使用该值：</p>
<div class="code-wrapper"><pre><code class="hljs c++">std::cout &lt;&lt; o.<span class="hljs-built_in">value_or</span>(<span class="hljs-string">"fallback"</span>); <span class="hljs-comment">// OK (如果没有值则输出fallback)</span></code></pre></div>

<p>后备参数作为右值引用传递，因此如果不使用后备，它不会花费任何成本，并且如果使用它，它支持移动语义。<br>请注意，operator* 和 value() 都通过引用返回包含的对象。 因此，在直接调用这些操作以获取临时返回值时，您必须小心。 例如：</p>
<div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-function">std::optional&lt;std::string&gt; <span class="hljs-title">getString</span><span class="hljs-params">()</span></span>;
...;
<span class="hljs-keyword">auto</span> a = <span class="hljs-built_in">getString</span>().<span class="hljs-built_in">value</span>(); <span class="hljs-comment">// OK: 包含对象的副本</span>
<span class="hljs-keyword">auto</span> b = *<span class="hljs-built_in">getString</span>(); <span class="hljs-comment">// ERROR: 如果 std::nullopt 的行为未定义</span>
<span class="hljs-type">const</span> <span class="hljs-keyword">auto</span>&amp; r1 = <span class="hljs-built_in">getString</span>().<span class="hljs-built_in">value</span>(); <span class="hljs-comment">// ERROR: 引用已删除的包含对象</span>
<span class="hljs-keyword">auto</span>&amp;&amp; r2 = <span class="hljs-built_in">getString</span>().<span class="hljs-built_in">value</span>(); <span class="hljs-comment">// ERROR: 引用已删除的包含对象</span></code></pre></div>

<p>一个示例可能是基于范围的 for 循环的以下用法：</p>
<div class="code-wrapper"><pre><code class="hljs c++">std::optional&lt;std::vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">getVector</span>();
...;
<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i : <span class="hljs-built_in">getVector</span>().<span class="hljs-built_in">value</span>()) { <span class="hljs-comment">// ERROR: 迭代已删除的vector</span>
    std::cout &lt;&lt; i &lt;&lt; <span class="hljs-string">'\n'</span>;
}</code></pre></div>

<p>请注意，迭代返回的 int 向量是可行的。 所以，不要盲目地将函数 foo() 的返回类型替换为相应的可选类型，而是调用 foo().value() 。</p>
<h6><span id="dui-bi">对比</span><a href="#dui-bi" class="header-anchor">#</a></h6><p>您可以使用通常的比较运算符。 操作数可以是可选对象，<br>包含类型和 std::nullopt。</p>
<ul>
<li>如果两个操作数都是具有值的对象，则使用包含类型的相应运算符。</li>
<li>如果两个操作数都是没有值的对象，则它们被认为是相等的（== 产生 true 并且<br>所有其他比较结果为假）。</li>
<li>如果只有一个操作数是具有值的对象，则认为没有值的操作数小于另一个操作数。</li>
</ul>
<p>例如：</p>
<div class="code-wrapper"><pre><code class="hljs c++">std::optional&lt;<span class="hljs-type">int</span>&gt; o0;
std::optional&lt;<span class="hljs-type">int</span>&gt; o1{<span class="hljs-number">42</span>};

<span class="hljs-comment">/*</span>
<span class="hljs-comment">	o0 == std::nullopt // yields true</span>
<span class="hljs-comment">	o0 == 42 // yields false</span>
<span class="hljs-comment">	o0 &lt; 42 // yields true</span>
<span class="hljs-comment">	o0 &gt; 42 // yields false</span>
<span class="hljs-comment">	o1 == 42 // yields true</span>
<span class="hljs-comment">	o0 &lt; o1 // yields true</span>
<span class="hljs-comment">*/</span></code></pre></div>

<p>这意味着对于 unsigned int 的可选对象，有一个小于 0 的值，对于 bool 的可选对象，有一个小于 0 的值：</p>
<div class="code-wrapper"><pre><code class="hljs c++">std::optional&lt;<span class="hljs-type">unsigned</span>&gt; uo;
uo &lt; <span class="hljs-number">0</span> <span class="hljs-comment">// yields true</span>
std::optional&lt;<span class="hljs-type">bool</span>&gt; bo;
bo &lt; <span class="hljs-literal">false</span> <span class="hljs-comment">// yields true</span></code></pre></div>

<p>同样，支持底层类型的隐式类型转换：</p>
<div class="code-wrapper"><pre><code class="hljs c++">std::optional&lt;<span class="hljs-type">int</span>&gt; o1{<span class="hljs-number">42</span>};
std::optional&lt;<span class="hljs-type">double</span>&gt; o2{<span class="hljs-number">42.0</span>};

<span class="hljs-comment">/*</span>
<span class="hljs-comment">	o2 == 42 // yields true</span>
<span class="hljs-comment">	o1 == o2 // yields true</span>
<span class="hljs-comment">*/</span></code></pre></div>

<p>请注意，可选的布尔值或原始指针值可能会导致一些意外。</p>
<h6><span id="geng-gai-zhi">更改值</span><a href="#geng-gai-zhi" class="header-anchor">#</a></h6><p>赋值和 emplace() 操作对应于初始化存在：</p>
<div class="code-wrapper"><pre><code class="hljs c++">std::optional&lt;std::complex&lt;<span class="hljs-type">double</span>&gt;&gt; o; <span class="hljs-comment">// 没有值</span>
std::optional ox{<span class="hljs-number">77</span>}; <span class="hljs-comment">// optional&lt;int&gt; with value 77</span>
o = <span class="hljs-number">42</span>; <span class="hljs-comment">// 值变为 complex(42.0, 0.0)</span>
o = {<span class="hljs-number">9.9</span>, <span class="hljs-number">4.4</span>}; <span class="hljs-comment">// 值变为 complex(9.9, 4.4)</span>
o = ox; <span class="hljs-comment">// OK, 因为 int 转换为 complex&lt;double&gt;</span>
o = std::<span class="hljs-literal">nullopt</span>; <span class="hljs-comment">// o 不再具有值</span>
o.<span class="hljs-built_in">emplace</span>(<span class="hljs-number">5.5</span>, <span class="hljs-number">7.7</span>); <span class="hljs-comment">// 值变为 complex(5.5, 7.7)</span></code></pre></div>

<p>分配 std::nullopt 会删除该值，如果之前有值，则调用包含类型的析构函数。 您可以通过调用 reset() 来获得相同的效果：</p>
<div class="code-wrapper"><pre><code class="hljs c++">o.<span class="hljs-built_in">reset</span>(); <span class="hljs-comment">// o 不再具有值</span></code></pre></div>

<p>或分配空花括号：</p>
<div class="code-wrapper"><pre><code class="hljs c++">o = {}; <span class="hljs-comment">// o 不再具有值</span></code></pre></div>

<p>最后，我们还可以使用 operator* 来修改值，因为它通过引用产生值。<br>但是，请注意，这需要有一个值要修改：</p>
<div class="code-wrapper"><pre><code class="hljs c++">std::optional&lt;std::complex&lt;<span class="hljs-type">double</span>&gt;&gt; o;
*o = <span class="hljs-number">42</span>; <span class="hljs-comment">// 未定义的行为</span>
...;
<span class="hljs-keyword">if</span> (o) {
    *o = <span class="hljs-number">88</span>; <span class="hljs-comment">// OK: 值变为 complex(88.0, 0.0)</span>
    *o = {<span class="hljs-number">1.2</span>, <span class="hljs-number">3.4</span>}; <span class="hljs-comment">// OK: 值变为 complex(1.2, 3.4)</span>
}</code></pre></div>

<h6><span id="yi-dong-yu-yi">移动语义</span><a href="#yi-dong-yu-yi" class="header-anchor">#</a></h6><p>std::optional&lt;&gt; 也支持移动语义。 如果将对象作为一个整体移动，则将复制状态并移动包含的对象（如果有）。 结果，移出的对象仍然具有相同的状态，但任何值都未指定。</p>
<p>​    但是您也可以将值移入或移出包含的对象。 例如：</p>
<div class="code-wrapper"><pre><code class="hljs c++">std::optional&lt;std::string&gt; os;
std::string s = <span class="hljs-string">"a very very very long string"</span>;
os = std::<span class="hljs-built_in">move</span>(s); <span class="hljs-comment">// OK, 移动</span>
std::string s2 = *os; <span class="hljs-comment">// OK 拷贝</span>
std::string s3 = std::<span class="hljs-built_in">move</span>(*os); <span class="hljs-comment">// OK, 移动</span></code></pre></div>

<p>请注意，在最后一次调用之后 os 仍然有一个字符串值，但对于已移动的对象，该值通常是未指定的。 因此，只要您不对它的值做任何假设，您就可以使用它。 您甚至可以在那里分配一个新的字符串值。</p>
<h6><span id="san-lie">散列</span><a href="#san-lie" class="header-anchor">#</a></h6><p>可选对象的哈希值是包含的非常量类型（如果有）的哈希值。</p>
<h4><span id="15-3-te-shu-qing-kuang">15.3 特殊情况</span><a href="#15-3-te-shu-qing-kuang" class="header-anchor">#</a></h4><p>特定的可选值类型可能会导致特殊或意外行为。</p>
<h5><span id="15-3-1-ke-xuan-de-bu-er-zhi-huo-yuan-shi-zhi-zhen-zhi">15.3.1 可选的布尔值或原始指针值</span><a href="#15-3-1-ke-xuan-de-bu-er-zhi-huo-yuan-shi-zhi-zhen-zhi" class="header-anchor">#</a></h5><p>请注意，使用比较运算符与使用可选对象作为布尔值具有不同的语义。 如果包含的类型是 bool 或指针类型，这可能会变得令人困惑：例如：</p>
<div class="code-wrapper"><pre><code class="hljs c++">std::optional&lt;<span class="hljs-type">bool</span>&gt; ob{<span class="hljs-literal">false</span>}; <span class="hljs-comment">// 有值，为假</span>
<span class="hljs-keyword">if</span> (!ob) ... <span class="hljs-comment">// 产生错误</span>
<span class="hljs-keyword">if</span> (ob == <span class="hljs-literal">false</span>) ... <span class="hljs-comment">// yields true</span>
std::optional&lt;<span class="hljs-type">int</span>*&gt; op{<span class="hljs-literal">nullptr</span>};
<span class="hljs-keyword">if</span> (!op) ... <span class="hljs-comment">// yields false</span>
<span class="hljs-keyword">if</span> (op == <span class="hljs-literal">nullptr</span>) ... <span class="hljs-comment">// yields true</span></code></pre></div>

<h5><span id="15-3-2-optional-de-optional">15.3.2 Optional 的 Optional</span><a href="#15-3-2-optional-de-optional" class="header-anchor">#</a></h5><p>原则上，您还可以定义可选值的可选：</p>
<div class="code-wrapper"><pre><code class="hljs c++">std::optional&lt;std::optional&lt;std::string&gt;&gt; oos1;
std::optional&lt;std::optional&lt;std::string&gt;&gt; oos2 = <span class="hljs-string">"hello"</span>;
std::optional&lt;std::optional&lt;std::string&gt;&gt;
    oos3{std::in_place, std::in_place, <span class="hljs-string">"hello"</span>};
std::optional&lt;std::optional&lt;std::complex&lt;<span class="hljs-type">double</span>&gt;&gt;&gt;
    ooc{std::in_place, std::in_place, <span class="hljs-number">4.2</span>, <span class="hljs-number">5.3</span>};</code></pre></div>

<p>即使使用隐式转换，您也可以分配新值：</p>
<div class="code-wrapper"><pre><code class="hljs c++">oos1 = <span class="hljs-string">"hello"</span>; <span class="hljs-comment">// OK: 分配新值</span>
ooc.<span class="hljs-built_in">emplace</span>(std::in_place, <span class="hljs-number">7.2</span>, <span class="hljs-number">8.3</span>);</code></pre></div>

<p>由于没有值的两个层次，可选的可选使得在外部或内部具有“无值”，这可以具有不同的语义含义：</p>
<div class="code-wrapper"><pre><code class="hljs c++">*oos1 = std::<span class="hljs-literal">nullopt</span>; <span class="hljs-comment">// 内部可选没有值</span>
oos1 = std::<span class="hljs-literal">nullopt</span>; <span class="hljs-comment">// 外部可选没有值</span></code></pre></div>

<p>但是您必须特别注意处理可选值：</p>
<div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">if</span> (!oos1) std::cout &lt;&lt; <span class="hljs-string">"no value\n"</span>;
<span class="hljs-keyword">if</span> (oos1 &amp;&amp; !*oos1) std::cout &lt;&lt; <span class="hljs-string">"no inner value\n"</span>;
<span class="hljs-keyword">if</span> (oos1 &amp;&amp; *oos1) std::cout &lt;&lt; <span class="hljs-string">"value: "</span> &lt;&lt; **oos1 &lt;&lt; <span class="hljs-string">'\n'</span>;</code></pre></div>

<p>但是，因为这在语义上更像是一个具有两个不同状态的值，表示没有值，所以具有两个布尔或单态替代方案的 std::variant&lt;&gt; 可能更合适。</p>
<h4><span id="15-4-hou-ji">15.4 后记</span><a href="#15-4-hou-ji" class="header-anchor">#</a></h4><p>可选对象于 2005 年由 Fernando Cacciola 在 <a target="_blank" rel="noopener" href="https://wg21.link/n1878">https://wg21.link/n1878</a> 中首次提出，将 Boost.Optional 作为参考实现。 正如 Fernando Cacciola 和 Andrzej Krzemienski 在 <a target="_blank" rel="noopener" href="https://wg21.link/n3793">https://wg21.link/n3793</a> 中提出的，该课程被采纳为图书馆基础知识 TS 的一部分。</p>
<p>正如 Beman Dawes 和 Alisdair Meredith 在 <a target="_blank" rel="noopener" href="https://wg21.link/p0220r1">https://wg21.link/p0220r1</a> 中提出的，该类与 C++17 的其他组件一起采用。</p>
<p>Tony van Eerd 使用 <a target="_blank" rel="noopener" href="https://wg21.link/n3765">https://wg21.link/n3765</a> 和 <a target="_blank" rel="noopener" href="https://wg21.link/p0307r2">https://wg21.link/p0307r2</a> 显着改进了比较运算符的语义。 Vicente J. Botet Escriba 将 API 与 std::variant&lt;&gt; 和 std::any 与 <a target="_blank" rel="noopener" href="https://wg21.link/p0032r3">https://wg21.link/p0032r3</a> 进行了协调。 Jonathan Wakely 使用 <a target="_blank" rel="noopener" href="https://wg21.link/p0504r0">https://wg21.link/p0504r0</a> 修复了 in_place 标记类型的行为。</p>
<h3><span id="16-std-variant-lt-gt">16 std::variant&lt;&gt;</span><a href="#16-std-variant-lt-gt" class="header-anchor">#</a></h3><p>借助 std::variant&lt;&gt;，C++ 标准库提供了一个新的联合类，其中包括支持多态性和处理非同质集合的新方法。 也就是说，它允许我们处理不同数据类型的元素，而无需公共基类和指针（原始或智能）。</p>
<h4><span id="16-1-std-variant-lt-gt-de-shi-ji">16.1 std::variant&lt;&gt; 的时机</span><a href="#16-1-std-variant-lt-gt-de-shi-ji" class="header-anchor">#</a></h4><p>从 C 中采用，C++ 提供对联合的支持，联合是能够保存可能类型列表之一的对象。但是，此语言功能存在一些缺点：</p>
<ul>
<li>对象不知道它们当前持有哪种类型的值。</li>
<li>出于这个原因，您不能拥有非平凡的成员，例如 std::string （无需特别努力）。</li>
<li>你不能从工会派生。<br>使用 std::variant&lt;&gt;，C++ 标准库提供了一个封闭的可区分联合（这意味着有一个指定的可能类型列表，您可以指定您的意思），其中</li>
<li>当前值的类型总是已知的，</li>
<li>可以有任何指定类型的成员，并且</li>
<li>你可以从中得到。<br>事实上，一个 std::variant&lt;&gt; 保存着各种选择的值，这些选择通常有不同的类型。但是两个替代也可以具有相同的类型，如果具有不同语义含义的替代具有相同的类型，这很有用（例如，持有两个字符串，它们代表不同的数据库列，以便您仍然知道该值代表哪些列） .</li>
</ul>
<p>变体只是具有用于基础类型的最大大小的内部存储器以及一些固定的开销来管理使用哪个替代方案。 没有分配堆内存。</p>
<p>一般来说，变量不能为空，除非您使用特定的替代信号来表示空虚。 但是，在极少数情况下（例如由于在分配不同的新值期间出现异常）<br>type) 变体可以进入一个没有任何价值的状态。</p>
<p>与 std::optional&lt;&gt; 和 std::any 一样，结果对象具有值语义。 通过在自己的内存中创建一个具有当前替代项的当前值的独立对象来进行深度复制。 因此，复制 std::variant&lt;&gt; 与复制当前替代的 type/value 一样便宜/昂贵。 支持移动语义。</p>
<h4><span id="16-2-shi-yong-std-variant-lt-gt">16.2 使用 std::variant&lt;&gt;</span><a href="#16-2-shi-yong-std-variant-lt-gt" class="header-anchor">#</a></h4><p>以下示例演示了 std::variant&lt;&gt; 的核心功能：</p>
<p><code>lib/variant.cpp </code></p>
<div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;variant&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span>
<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>
<span class="hljs-function"></span>{
    std::variant&lt;<span class="hljs-type">int</span>, std::string&gt; var{<span class="hljs-string">"hi"</span>}; <span class="hljs-comment">// 用字符串替代初始化</span>
    std::cout &lt;&lt; var.<span class="hljs-built_in">index</span>() &lt;&lt; <span class="hljs-string">'\n'</span>; <span class="hljs-comment">// prints 1</span>
    var = <span class="hljs-number">42</span>; <span class="hljs-comment">// 现在持有 int 替代品</span>
    std::cout &lt;&lt; var.<span class="hljs-built_in">index</span>() &lt;&lt; <span class="hljs-string">'\n'</span>; <span class="hljs-comment">// prints 0</span>
    ...;
    <span class="hljs-keyword">try</span> {
        <span class="hljs-type">int</span> i = std::<span class="hljs-built_in">get</span>&lt;<span class="hljs-number">0</span>&gt;(var); <span class="hljs-comment">// 按索引访问</span>
        std::string s = std::<span class="hljs-built_in">get</span>&lt;std::string&gt;(var); <span class="hljs-comment">// 按类型访问（在这种情况下抛出异常）</span>
        ...;
    }
    <span class="hljs-built_in">catch</span> (<span class="hljs-type">const</span> std::bad_variant_access&amp; e) { <span class="hljs-comment">// 如果使用了错误的type/index</span>
        std::cerr &lt;&lt; <span class="hljs-string">"EXCEPTION: "</span> &lt;&lt; e.<span class="hljs-built_in">what</span>() &lt;&lt; <span class="hljs-string">'\n'</span>;
        ...;
    }
}</code></pre></div>

<p>成员函数 index() 可用于找出当前设置了哪个备选方案（第一个备选方案的索引为 0）。</p>
<p>初始化和赋值总是使用最佳匹配来找出新的替代方案。 如果类型不完全适合，可能会出现意外。</p>
<p>请注意，不允许使用空变体、具有引用成员的变体、具有 C 样式数组成员的变体以及具有不完整类型（例如 void）的变体。</p>
<p>没有空状态。 这意味着对于每个构造对象，必须调用至少一个构造函数。 默认构造函数使用默认构造函数初始化第一个类型：</p>
<div class="code-wrapper"><pre><code class="hljs c++">std::variant&lt;std::string, <span class="hljs-type">int</span>&gt; var; <span class="hljs-comment">// =&gt; var.index() == 0, value == ””</span></code></pre></div>

<p>如果没有为第一种类型定义默认构造函数，则调用变体的默认构造函数是编译时错误：</p>
<div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">NoDefConstr</span> {
    <span class="hljs-built_in">NoDefConstr</span>(<span class="hljs-type">int</span> i) {
        std::cout &lt;&lt; <span class="hljs-string">"NoDefConstr::NoDefConstr(int) called\n"</span>;
    }
};
std::variant&lt;NoDefConstr, <span class="hljs-type">int</span>&gt; v1; <span class="hljs-comment">// ERROR: 不能默认构造第一类型</span></code></pre></div>

<p>辅助类型 std::monostate 提供了处理这种情况的能力，也提供了模拟空状态的能力。</p>
<h6><span id="std-monostate">std::monostate</span><a href="#std-monostate" class="header-anchor">#</a></h6><p>为了支持第一种类型没有默认构造函数的变体，提供了一个特殊的辅助类型：std::monostate。 std::monostate 类型的对象始终具有相同的状态。 因此，它们总是比较相等。 他们自己的目的是表示一个替代类型，以便该变体没有任何其他类型的值。</p>
<p>也就是说，struct std::monostate 可以作为第一个替代类型，以使变体类型默认可构造。 例如：</p>
<div class="code-wrapper"><pre><code class="hljs c++">std::variant&lt;std::monostate, NoDefConstr&gt; v2; <span class="hljs-comment">// OK</span>
std::cout &lt;&lt; <span class="hljs-string">"index: "</span> &lt;&lt; v2.<span class="hljs-built_in">index</span>() &lt;&lt; <span class="hljs-string">'\n'</span>; <span class="hljs-comment">// prints 0</span></code></pre></div>

<p>在某种程度上，您可以将状态解释为表示空虚。 有多种方法可以检查单态，这也演示了其他一些操作，您可以调用变体：</p>
<div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">if</span> (v2.<span class="hljs-built_in">index</span>() == <span class="hljs-number">0</span>) {
    std::cout &lt;&lt; <span class="hljs-string">"has monostate\n"</span>;
}
<span class="hljs-keyword">if</span> (!v2.<span class="hljs-built_in">index</span>()) {
    std::cout &lt;&lt; <span class="hljs-string">"has monostate\n"</span>;
}
<span class="hljs-keyword">if</span> (std::<span class="hljs-built_in">holds_alternative</span>&lt;std::monostate&gt;(v2)) {
    std::cout &lt;&lt; <span class="hljs-string">"has monostate\n"</span>;
}
<span class="hljs-keyword">if</span> (std::<span class="hljs-built_in">get_if</span>&lt;<span class="hljs-number">0</span>&gt;(&amp;v2)) {
    std::cout &lt;&lt; <span class="hljs-string">"has monostate\n"</span>;
}
<span class="hljs-keyword">if</span> (std::<span class="hljs-built_in">get_if</span>&lt;std::monostate&gt;(&amp;v2)) {
    std::cout &lt;&lt; <span class="hljs-string">"has monostate\n"</span>;
}</code></pre></div>

<p>get_if&lt;&gt;() 使用指向变体的指针，如果当前备选方案是 T，则返回指向当前备选方案的指针。否则返回 nullptr。 这与 get<t>() 不同，get<t>() 采用对变体的引用，如果提供的类型正确，则按值返回当前替代项，否则抛出。</t></t></p>
<p>像往常一样，您可以分配另一个替代的值，甚至分配单态，再次表示空虚：</p>
<div class="code-wrapper"><pre><code class="hljs c++">v2 = <span class="hljs-number">42</span>;
std::cout &lt;&lt; <span class="hljs-string">"index: "</span> &lt;&lt; v2.<span class="hljs-built_in">index</span>() &lt;&lt; <span class="hljs-string">'\n'</span>; <span class="hljs-comment">// index: 1</span>
v2 = std::monostate{};
std::cout &lt;&lt; <span class="hljs-string">"index: "</span> &lt;&lt; v2.<span class="hljs-built_in">index</span>() &lt;&lt; <span class="hljs-string">'\n'</span>; <span class="hljs-comment">// index: 0</span></code></pre></div>

<h6><span id="cong-bian-ti-pai-sheng">从变体派生</span><a href="#cong-bian-ti-pai-sheng" class="header-anchor">#</a></h6><p>您可以从 std::variant 派生。 例如，您可以定义从 std::variant&lt;&gt; 派生的聚合，如下所示：</p>
<div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Derived</span> : <span class="hljs-keyword">public</span> std::variant&lt;<span class="hljs-type">int</span>, std::string&gt; {
};
Derived d = {{<span class="hljs-string">"hello"</span>}};
std::cout &lt;&lt; d.<span class="hljs-built_in">index</span>() &lt;&lt; <span class="hljs-string">'\n'</span>; <span class="hljs-comment">// prints: 1</span>
std::cout &lt;&lt; std::<span class="hljs-built_in">get</span>&lt;<span class="hljs-number">1</span>&gt;(d) &lt;&lt; <span class="hljs-string">'\n'</span>; <span class="hljs-comment">// prints: hello</span>
d.<span class="hljs-built_in">emplace</span>&lt;<span class="hljs-number">0</span>&gt;(<span class="hljs-number">77</span>); <span class="hljs-comment">// 初始化 int，销毁字符串</span>
std::cout &lt;&lt; std::<span class="hljs-built_in">get</span>&lt;<span class="hljs-number">0</span>&gt;(d) &lt;&lt; <span class="hljs-string">'\n'</span>; <span class="hljs-comment">// prints: 77</span></code></pre></div>

<h4><span id="16-3-std-variant-lt-gt-lei-xing-he-cao-zuo">16.3 std::variant&lt;&gt; 类型和操作</span><a href="#16-3-std-variant-lt-gt-lei-xing-he-cao-zuo" class="header-anchor">#</a></h4><p>本节详细介绍 std::variant&lt;&gt; 的类型和操作。</p>
<h5><span id="16-3-1-std-variant-lt-gt-lei-xing">16.3.1 std::variant&lt;&gt; 类型</span><a href="#16-3-1-std-variant-lt-gt-lei-xing" class="header-anchor">#</a></h5><p>在头文件 <variant> 中，C++ 标准库定义类 std::variant&lt;&gt; 如下：</variant></p>
<div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">namespace</span> std {
    <span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> Types...&gt; <span class="hljs-keyword">class</span> <span class="hljs-title class_">variant</span>;
}</code></pre></div>

<p>也就是说，std::variant&lt;&gt; 是一个可变参数类模板（C++11 引入的一个特性，允许处理任意数量的类型）。<br>此外，还定义了以下类型和对象：</p>
<ul>
<li><p>类型 std::variant_size</p>
</li>
<li><p>类型 std::variant_alternative</p>
</li>
<li><p>值 std::variant_npos</p>
</li>
<li><p>类型 std::monostate</p>
</li>
<li><p>异常类 std::bad_variant_access，派生自 std::exception。</p>
</li>
</ul>
<p>变体还使用在 utility&gt; 中定义的两个对象 std::in_place_type（std::in_place_type_t 类型）和 std::in_place_index（std::in_place_index_t 类型）。</p>
<h5><span id="16-3-2-std-variant-lt-gt-cao-zuo">16.3.2 std::variant&lt;&gt; 操作</span><a href="#16-3-2-std-variant-lt-gt-cao-zuo" class="header-anchor">#</a></h5><p>表 std::variant Operations 列出了为 std::variant&lt;&gt; 提供的所有操作.</p>
<h6><span id="gou-zao">构造</span><a href="#gou-zao" class="header-anchor">#</a></h6><p>默认情况下，变体的默认构造函数调用第一个替代的默认构造函数：</p>
<div class="code-wrapper"><pre><code class="hljs c++">std::variant&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>, std::string&gt; v1; <span class="hljs-comment">// 将第一个 int 设置为 0，index()==0</span></code></pre></div>

<p>另一种方法是值初始化，这意味着对于基本类型，它是 0、false 或 nullptr。<br>如果为初始化传递了一个值，则使用最佳匹配类型：</p>
<div class="code-wrapper"><pre><code class="hljs c++">std::variant&lt;<span class="hljs-type">long</span>, <span class="hljs-type">int</span>&gt; v2{<span class="hljs-number">42</span>};
std::cout &lt;&lt; v2.<span class="hljs-built_in">index</span>() &lt;&lt; <span class="hljs-string">'\n'</span>; <span class="hljs-comment">// prints 1</span></code></pre></div>

<p>但是，如果两种类型匹配得一样好，则调用是模棱两可的：</p>
<div class="code-wrapper"><pre><code class="hljs c++">std::variant&lt;<span class="hljs-type">long</span>, <span class="hljs-type">long</span>&gt; v3{<span class="hljs-number">42</span>}; <span class="hljs-comment">// ERROR: 模糊的</span>
std::variant&lt;<span class="hljs-type">int</span>, <span class="hljs-type">float</span>&gt; v4{<span class="hljs-number">42.3</span>}; <span class="hljs-comment">// ERROR: 模糊的</span>
std::variant&lt;<span class="hljs-type">int</span>, <span class="hljs-type">double</span>&gt; v5{<span class="hljs-number">42.3</span>}; <span class="hljs-comment">// OK</span>
std::variant&lt;<span class="hljs-type">int</span>, <span class="hljs-type">long</span> <span class="hljs-type">double</span>&gt; v6{<span class="hljs-number">42.3</span>}; <span class="hljs-comment">// ERROR: 模糊的</span>
std::variant&lt;std::string, std::string_view&gt; v7{<span class="hljs-string">"hello"</span>}; <span class="hljs-comment">// ERROR: 模糊的</span>
std::variant&lt;std::string, std::string_view, <span class="hljs-type">const</span> <span class="hljs-type">char</span>*&gt; v8{<span class="hljs-string">"hello"</span>}; <span class="hljs-comment">// OK</span>
std::cout &lt;&lt; v8.<span class="hljs-built_in">index</span>() &lt;&lt; <span class="hljs-string">'\n'</span>; <span class="hljs-comment">// prints 2</span></code></pre></div>

<table>
<thead>
<tr>
<th>操作</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>constructors</td>
<td>创建一个变体对象（可能调用底层类型的构造函数）</td>
</tr>
<tr>
<td>destructor</td>
<td>销毁一个变体对象</td>
</tr>
<tr>
<td>=</td>
<td>分配一个新值</td>
</tr>
<tr>
<td>emplace<t>()</t></td>
<td>为具有类型 T 的替代项分配一个新值</td>
</tr>
<tr>
<td>emplace<idx>()</idx></td>
<td>为索引 Idx 的替代项分配一个新值</td>
</tr>
<tr>
<td>valueless_by_exception()</td>
<td>返回变量是否由于异常而没有值</td>
</tr>
<tr>
<td>index()</td>
<td>返回当前替代的索引</td>
</tr>
<tr>
<td>swap()</td>
<td>在两个对象之间交换值</td>
</tr>
<tr>
<td>==, !=, &lt;, &lt;=, &gt;, &gt;=</td>
<td>比较不同的对象</td>
</tr>
<tr>
<td>hash&lt;&gt;</td>
<td>计算哈希值的函数对象类型</td>
</tr>
<tr>
<td>holds_alternative<t>()</t></td>
<td>返回是否有类型 T 的值</td>
</tr>
<tr>
<td>get<t>()</t></td>
<td>返回类型为 T 或 throws 的替代项的值</td>
</tr>
<tr>
<td>ge<idx>t()</idx></td>
<td>返回具有索引 Idx 或 throws 的替代项的值</td>
</tr>
<tr>
<td>get_if<t>()</t></td>
<td>返回指向 T 或 nullptr 类型的替代值的指针</td>
</tr>
<tr>
<td>get_if<idx>()</idx></td>
<td>返回指向具有索引 Idx 或 nullptr 的替代项的值的指针</td>
</tr>
<tr>
<td>visit()</td>
<td>对当前备选方案执行操作</td>
</tr>
</tbody></table>
<p>要为初始化传递多个值，您必须使用 in_place_type 或 in_place_index 标签：</p>
<div class="code-wrapper"><pre><code class="hljs c++">std::variant&lt;std::complex&lt;<span class="hljs-type">double</span>&gt;&gt; v9{<span class="hljs-number">3.0</span>, <span class="hljs-number">4.0</span>}; <span class="hljs-comment">// ERROR</span>
std::variant&lt;std::complex&lt;<span class="hljs-type">double</span>&gt;&gt; v10{{<span class="hljs-number">3.0</span>, <span class="hljs-number">4.0</span>}}; <span class="hljs-comment">// ERROR</span>
std::variant&lt;std::complex&lt;<span class="hljs-type">double</span>&gt;&gt; v11{std::in_place_type&lt;std::complex&lt;<span class="hljs-type">double</span>&gt;&gt;,
                                       <span class="hljs-number">3.0</span>, <span class="hljs-number">4.0</span>};
std::variant&lt;std::complex&lt;<span class="hljs-type">double</span>&gt;&gt; v12{std::in_place_index&lt;<span class="hljs-number">0</span>&gt;, <span class="hljs-number">3.0</span>, <span class="hljs-number">4.0</span>};</code></pre></div>

<p>您还可以在初始化期间使用 in_place_index 标记来解决歧义或否决优先级：</p>
<div class="code-wrapper"><pre><code class="hljs c++">std::variant&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt; v13{std::in_place_index&lt;<span class="hljs-number">1</span>&gt;, <span class="hljs-number">77</span>}; <span class="hljs-comment">// 初始化第二个 int</span>
std::variant&lt;<span class="hljs-type">int</span>, <span class="hljs-type">long</span>&gt; v14{std::in_place_index&lt;<span class="hljs-number">1</span>&gt;, <span class="hljs-number">77</span>}; <span class="hljs-comment">// 初始化长，而不是 int</span>
std::cout &lt;&lt; v14.<span class="hljs-built_in">index</span>() &lt;&lt; <span class="hljs-string">'\n'</span>; <span class="hljs-comment">// prints 1</span></code></pre></div>

<p>你甚至可以传递一个初始化列表，后跟其他参数：</p>
<div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-comment">// initialize variant with a set with lambda as sorting criterion:</span>
<span class="hljs-keyword">auto</span> sc = [] (<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y) {
    <span class="hljs-keyword">return</span> std::<span class="hljs-built_in">abs</span>(x) &lt; std::<span class="hljs-built_in">abs</span>(y);
};
std::variant&lt;std::vector&lt;<span class="hljs-type">int</span>&gt;, std::set&lt;<span class="hljs-type">int</span>,<span class="hljs-keyword">decltype</span>(sc)&gt;&gt; v15{std::in_place_index&lt;<span class="hljs-number">1</span>&gt;,
                                                               {<span class="hljs-number">4</span>, <span class="hljs-number">8</span>, <span class="hljs-number">-7</span>, <span class="hljs-number">-2</span>, <span class="hljs-number">0</span>, <span class="hljs-number">5</span>},
                                                               sc
                                                              };</code></pre></div>

<p>你不能对 std::variant&lt;&gt; 使用类模板参数推导。 并且没有 make_variant&lt;&gt;() 便利函数（与 std::optional&lt;&gt; 和 std::any 不同）。 两者都没有意义，因为变体的整个目标是处理多种选择。</p>
<h6><span id="fang-wen-zhi">访问值</span><a href="#fang-wen-zhi" class="header-anchor">#</a></h6><p>访问该值的常用方法是调用 get&lt;&gt;() 以获得相应的替代方法。 您可以传递它的索引，或者，如果一个类型不被多次使用，它的类型。 例如：</p>
<div class="code-wrapper"><pre><code class="hljs c++">std::variant&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>, std::string&gt; var; <span class="hljs-comment">// 将第一个 int 设置为 0，index()==0</span>
<span class="hljs-keyword">auto</span> a = std::<span class="hljs-built_in">get</span>&lt;<span class="hljs-type">double</span>&gt;(var); <span class="hljs-comment">// compile-time 错误：没有双精度</span>
<span class="hljs-keyword">auto</span> b = std::<span class="hljs-built_in">get</span>&lt;<span class="hljs-number">4</span>&gt;(var); <span class="hljs-comment">// compile-time 错误: 没有第四选择</span>
<span class="hljs-keyword">auto</span> c = std::<span class="hljs-built_in">get</span>&lt;<span class="hljs-type">int</span>&gt;(var); <span class="hljs-comment">// compile-time 错误: int 两次</span>
<span class="hljs-keyword">try</span> {
    <span class="hljs-keyword">auto</span> s = std::<span class="hljs-built_in">get</span>&lt;std::string&gt;(var); <span class="hljs-comment">// 抛出异常（当前设置的第一个 int）</span>
    <span class="hljs-keyword">auto</span> i = std::<span class="hljs-built_in">get</span>&lt;<span class="hljs-number">0</span>&gt;(var); <span class="hljs-comment">// OK, i==0</span>
    <span class="hljs-keyword">auto</span> j = std::<span class="hljs-built_in">get</span>&lt;<span class="hljs-number">1</span>&gt;(var); <span class="hljs-comment">// 抛出异常（当前设置的其他 int）</span>
}
<span class="hljs-built_in">catch</span> (<span class="hljs-type">const</span> std::bad_variant_access&amp; e) { <span class="hljs-comment">// 在无效访问的情况下</span>
    std::cout &lt;&lt; <span class="hljs-string">"Exception: "</span> &lt;&lt; e.<span class="hljs-built_in">what</span>() &lt;&lt; <span class="hljs-string">'\n'</span>;
}</code></pre></div>

<p>还有一个 API 可以通过选项检查它是否存在来访问该值：</p>
<div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">if</span> (<span class="hljs-keyword">auto</span> ip = std::<span class="hljs-built_in">get_if</span>&lt;<span class="hljs-number">1</span>&gt;(&amp;var); ip) {
    std::cout &lt;&lt; *ip &lt;&lt; <span class="hljs-string">'\n'</span>;
}
<span class="hljs-keyword">else</span> {
    std::cout &lt;&lt; <span class="hljs-string">"alternative with index 1 not set\n"</span>;
}</code></pre></div>

<p>您必须将指向变体的指针传递给 get_if&lt;&gt;()，它要么返回指向当前值的指针，要么返回 nullptr。 请注意，如果使用 with 初始化，则可以检查刚刚初始化的值。<br>访问不同选项值的另一种方法是变体访问者。</p>
<h6><span id="geng-gai-zhi">更改值</span><a href="#geng-gai-zhi" class="header-anchor">#</a></h6><p>赋值和 emplace() 操作对应于初始化存在：</p>
<div class="code-wrapper"><pre><code class="hljs c++">std::variant&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>, std::string&gt; var; <span class="hljs-comment">// 将第一个 int 设置为 0，index()==0</span>
var = <span class="hljs-string">"hello"</span>; <span class="hljs-comment">// 设置字符串，index()==2</span>
var.<span class="hljs-built_in">emplace</span>&lt;<span class="hljs-number">1</span>&gt;(<span class="hljs-number">42</span>); <span class="hljs-comment">// 设置第二个 int，index()==1</span></code></pre></div>

<p>您还可以使用 get&lt;&gt;() 或 get_if&lt;&gt;() 为当前替代项分配一个新值：</p>
<div class="code-wrapper"><pre><code class="hljs c++">std::variant&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>, std::string&gt; var; <span class="hljs-comment">// 将第一个 int 设置为 0，index()==0</span>
std::<span class="hljs-built_in">get</span>&lt;<span class="hljs-number">0</span>&gt;(var) = <span class="hljs-number">77</span>; <span class="hljs-comment">// OK,因为第一个 int 已经设置</span>
std::<span class="hljs-built_in">get</span>&lt;<span class="hljs-number">1</span>&gt;(var) = <span class="hljs-number">99</span>; <span class="hljs-comment">// 抛出异常（当前设置的其他 int）</span>
<span class="hljs-keyword">if</span> (<span class="hljs-keyword">auto</span> p = std::<span class="hljs-built_in">get_if</span>&lt;<span class="hljs-number">1</span>&gt;(&amp;var); p) { <span class="hljs-comment">// 如果第二个 int 设置</span>
    *p = <span class="hljs-number">42</span>; <span class="hljs-comment">// 修改它</span>
}</code></pre></div>

<p>修改不同选项值的另一种方法是变体访问者</p>
<h6><span id="bi-jiao">比较</span><a href="#bi-jiao" class="header-anchor">#</a></h6><p>对于相同类型的两个变体（即具有相同顺序的相同替代项），您可以使用通常的比较运算符。 运营商按照以下规则行事：</p>
<ul>
<li>具有较早替代值的变体小于具有较晚替代值的变体。</li>
<li>如果两个变体具有相同的备选方案，则评估备选方案类型的相应运算符。 注意 std::monostate 类型的所有对象总是相等的。</li>
<li>特殊状态 valueless_by_exception() 为 true 的两个变体是相等的。 否则，任何 valueless_by_exception() 为 true 的变体都小于任何其他变体。</li>
</ul>
<p>例如：</p>
<div class="code-wrapper"><pre><code class="hljs c++">std::variant&lt;std::monostate, <span class="hljs-type">int</span>, std::string&gt; v1, v2{<span class="hljs-string">"hello"</span>}, v3{<span class="hljs-number">42</span>};
std::variant&lt;std::monostate, std::string, <span class="hljs-type">int</span>&gt; v4;
<span class="hljs-comment">/*</span>
<span class="hljs-comment">    v1 == v4 // COMPILE-TIME ERROR</span>
<span class="hljs-comment">    v1 == v2 // yields false</span>
<span class="hljs-comment">    v1 &lt; v2 // yields true</span>
<span class="hljs-comment">    v1 &lt; v3 // yields true</span>
<span class="hljs-comment">    v2 &lt; v3 // yields false</span>
<span class="hljs-comment">    v1 = "hello";</span>
<span class="hljs-comment">    v1 == v2 // yields true</span>
<span class="hljs-comment">    v2 = 41;</span>
<span class="hljs-comment">    v2 &lt; v3 // yields true</span>
<span class="hljs-comment">*/</span></code></pre></div>

<h6><span id="yi-dong-yu-yi">移动语义</span><a href="#yi-dong-yu-yi" class="header-anchor">#</a></h6><p>std::variant&lt;&gt; 也支持移动语义。 如果您将对象作为一个整体移动，则将复制状态并移动当前替代项的值。 结果，移出的对象仍然具有相同的选择，但任何值都变得未指定。<br>您还可以将值移入或移出包含的对象。</p>
<h6><span id="san-lie">散列</span><a href="#san-lie" class="header-anchor">#</a></h6><p>当且仅当每个成员类型都可以提供哈希值时，才启用变体对象的哈希值。 请注意，哈希值不是当前备选方案的哈希值。</p>
<h5><span id="16-3-3-fang-ke">16.3.3 访客</span><a href="#16-3-3-fang-ke" class="header-anchor">#</a></h5><p>他们必须明确地为每种可能的类型提供函数调用运算符。 然后，使用相应的重载来处理当前的替代方案。</p>
<h6><span id="shi-yong-han-shu-dui-xiang-zuo-wei-fang-wen-zhe">使用函数对象作为访问者</span><a href="#shi-yong-han-shu-dui-xiang-zuo-wei-fang-wen-zhe" class="header-anchor">#</a></h6><p>例子：</p>
<p><code>lib/variantvisit.cpp </code></p>
<div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;variant&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span>
<span class="hljs-keyword">struct</span> <span class="hljs-title class_">MyVisitor</span>
{
    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">operator</span><span class="hljs-params">()</span> <span class="hljs-params">(<span class="hljs-type">int</span> i)</span> <span class="hljs-type">const</span> </span>{
        std::cout &lt;&lt; <span class="hljs-string">"int: "</span> &lt;&lt; i &lt;&lt; <span class="hljs-string">'\n'</span>;
    }
    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">operator</span><span class="hljs-params">()</span> <span class="hljs-params">(std::string s)</span> <span class="hljs-type">const</span> </span>{
        std::cout &lt;&lt; <span class="hljs-string">"string: "</span> &lt;&lt; s &lt;&lt; <span class="hljs-string">'\n'</span>;
    }
    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">operator</span><span class="hljs-params">()</span> <span class="hljs-params">(<span class="hljs-type">long</span> <span class="hljs-type">double</span> d)</span> <span class="hljs-type">const</span> </span>{
        std::cout &lt;&lt; <span class="hljs-string">"double: "</span> &lt;&lt; d &lt;&lt; <span class="hljs-string">'\n'</span>;
    }
};
<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>
<span class="hljs-function"></span>{
    <span class="hljs-function">std::variant&lt;<span class="hljs-type">int</span>, std::string, <span class="hljs-type">double</span>&gt; <span class="hljs-title">var</span><span class="hljs-params">(<span class="hljs-number">42</span>)</span></span>;
    std::<span class="hljs-built_in">visit</span>(<span class="hljs-built_in">MyVisitor</span>(), var); <span class="hljs-comment">// 为 int 调用 operator()</span>
    var = <span class="hljs-string">"hello"</span>;
    std::<span class="hljs-built_in">visit</span>(<span class="hljs-built_in">MyVisitor</span>(), var); <span class="hljs-comment">// 为string调用 operator()</span>
    var = <span class="hljs-number">42.7</span>;
    std::<span class="hljs-built_in">visit</span>(<span class="hljs-built_in">MyVisitor</span>(), var); <span class="hljs-comment">// 为long double调用 operator()</span>
}</code></pre></div>

<p>如果 operator() 不支持所有可能的类型或调用不明确，则 visit() 调用是编译时错误。 此处的示例运行良好，因为 long double 比 int 更适合 double 值。<br>您还可以使用访问者来修改当前替代的值（但不能分配新的替代）。 例如：</p>
<div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Twice</span>
{
    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">operator</span><span class="hljs-params">()</span><span class="hljs-params">(<span class="hljs-type">double</span>&amp; d)</span> <span class="hljs-type">const</span> </span>{
        d *= <span class="hljs-number">2</span>;
    }
    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">operator</span><span class="hljs-params">()</span><span class="hljs-params">(<span class="hljs-type">int</span>&amp; i)</span> <span class="hljs-type">const</span> </span>{
        i *= <span class="hljs-number">2</span>;
    }
    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">operator</span><span class="hljs-params">()</span><span class="hljs-params">(std::string&amp; s)</span> <span class="hljs-type">const</span> </span>{
        s = s + s;
    }
};
std::<span class="hljs-built_in">visit</span>(<span class="hljs-built_in">Twice</span>(), var); <span class="hljs-comment">// calls operator() for matching type</span>
</code></pre></div>

<p>因为只有类型很重要，所以对于具有相同类型的替代方案，您不能有不同的行为。<br>请注意，函数调用运算符应标记为 const，因为它们是无状态的（它们不会改变行为，只会改变传递的值）。</p>
<h6><span id="shi-yong-tong-yong-lambda-zuo-wei-fang-wen-zhe">使用通用 Lambda 作为访问者</span><a href="#shi-yong-tong-yong-lambda-zuo-wei-fang-wen-zhe" class="header-anchor">#</a></h6><p>使用此功能的最简单方法是使用通用 lambda，它是任意类型的函数对象：</p>
<div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">auto</span> printvariant = [](<span class="hljs-type">const</span> <span class="hljs-keyword">auto</span>&amp; val) {
    std::cout &lt;&lt; val &lt;&lt; <span class="hljs-string">'\n'</span>;
};
...;
std::<span class="hljs-built_in">visit</span>(printvariant, var);</code></pre></div>

<p>在这里，通用 lambda 定义了一个闭包类型，其中函数调用运算符作为成员模板：</p>
<div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">CompilerSpecifyClosureTypeName</span> {
<span class="hljs-keyword">public</span>:
    <span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;</span>
<span class="hljs-function">    <span class="hljs-keyword">auto</span> <span class="hljs-title">operator</span><span class="hljs-params">()</span> <span class="hljs-params">(<span class="hljs-type">const</span> T&amp; val)</span> <span class="hljs-type">const</span> </span>{
        std::cout &lt;&lt; val &lt;&lt; <span class="hljs-string">'\n'</span>;
    }
};
</code></pre></div>

<p>因此，如果生成的函数调用运算符中的语句有效（即调用输出运算符有效），则传递给 std::visit() 的 lambda 调用将编译。<br>您还可以使用 lambda 来修改当前替代项的值：</p>
<div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-comment">// 将当前替代品的值翻倍:</span>
std::<span class="hljs-built_in">visit</span>([](<span class="hljs-keyword">auto</span>&amp; val) {
    val = val + val;
},
var);</code></pre></div>

<p>或者：</p>
<div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-comment">// 恢复为当前替代的默认值;</span>
std::<span class="hljs-built_in">visit</span>([](<span class="hljs-keyword">auto</span>&amp; val) {
val = std::<span class="hljs-type">remove_reference_t</span>&lt;<span class="hljs-keyword">decltype</span>(val)&gt;{};
},
var);</code></pre></div>

<p>您甚至可以使用编译时语言功能以不同方式处理不同的替代方案。 例如：</p>
<div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">auto</span> dblvar = [](<span class="hljs-keyword">auto</span>&amp; val) {
    <span class="hljs-keyword">if</span> <span class="hljs-built_in">constexpr</span>(std::is_convertible_v&lt;<span class="hljs-keyword">decltype</span>(val),
                 std::string&gt;) {
        val = val + val;
    }
    <span class="hljs-keyword">else</span> {
        val *= <span class="hljs-number">2</span>;
    }
};
...;
std::<span class="hljs-built_in">visit</span>(dblvar, var);</code></pre></div>

<p>在这里，对于 std::string 替代方案，通用 lambda 的调用实例化其通用函数调用模板以进行计算：</p>
<div class="code-wrapper"><pre><code class="hljs c++">val = val + val;</code></pre></div>

<p>而对于其他替代方案，例如 int 或 double，lambda 的调用实例化其通用函数调用模板来计算：</p>
<div class="code-wrapper"><pre><code class="hljs c++">val *= <span class="hljs-number">2</span>;</code></pre></div>

<h6><span id="shi-yong-chong-zai-de-lambda-zuo-wei-fang-wen-zhe">使用重载的 Lambda 作为访问者</span><a href="#shi-yong-chong-zai-de-lambda-zuo-wei-fang-wen-zhe" class="header-anchor">#</a></h6><p>通过对函数对象和 lambda 使用重载器，您还可以定义一组 lambda，其中最佳匹配用作访问者。<br>假设重载器是重载定义如下：</p>
<p><code>tmpl/overload.hpp </code></p>
<div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-comment">// “继承”传递的基类型的所有函数调用运算符:</span>
<span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span>... Ts&gt;
<span class="hljs-keyword">struct</span> <span class="hljs-title class_">overload</span> : Ts...
{
    <span class="hljs-function"><span class="hljs-keyword">using</span> <span class="hljs-title">Ts::operator</span><span class="hljs-params">()</span>...</span>;
};
<span class="hljs-comment">// 基类型是从传递的参数推导出来的:</span>
<span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span>... Ts&gt;</span>
<span class="hljs-function"><span class="hljs-title">overload</span><span class="hljs-params">(Ts...)</span> -&gt; overload&lt;Ts...&gt;</span>;</code></pre></div>

<p>您可以通过为每个替代方案提供 lambdas 来使用重载来访问变体：</p>
<div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-function">std::variant&lt;<span class="hljs-type">int</span>, std::string&gt; <span class="hljs-title">var</span><span class="hljs-params">(<span class="hljs-number">42</span>)</span></span>;
...;
std::<span class="hljs-built_in">visit</span>(overload{ <span class="hljs-comment">// 调用当前替代的最佳匹配 lambda</span>
    [](<span class="hljs-type">int</span> i) { std::cout &lt;&lt; <span class="hljs-string">"int: "</span> &lt;&lt; i &lt;&lt; <span class="hljs-string">'\n'</span>; },
    [](<span class="hljs-type">const</span> std::string&amp; s) {
        std::cout &lt;&lt; <span class="hljs-string">"string: "</span> &lt;&lt; s &lt;&lt; <span class="hljs-string">'\n'</span>; },
},
var);</code></pre></div>

<p>您还可以使用通用 lambda。 始终使用最佳匹配。 例如，要修改变体的当前替代项，您可以使用重载将字符串和其他类型的值“加倍”：</p>
<div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">auto</span> twice = overload{
    [](std::string&amp; s) { s += s; },
    [](<span class="hljs-keyword">auto</span>&amp; i) { i *= <span class="hljs-number">2</span>; },
};</code></pre></div>

<p>有了这个重载，对于字符串替代，当前值被附加，而对于所有其他类型，该值乘以 2，这演示了以下变体的应用：</p>
<div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-function">std::variant&lt;<span class="hljs-type">int</span>, std::string&gt; <span class="hljs-title">var</span><span class="hljs-params">(<span class="hljs-number">42</span>)</span></span>;
std::<span class="hljs-built_in">visit</span>(twice, var); <span class="hljs-comment">// value 42 becomes 84</span>
...;
var = <span class="hljs-string">"hi"</span>;
std::<span class="hljs-built_in">visit</span>(twice, var); <span class="hljs-comment">// value "hi" becomes "hihi"</span>
</code></pre></div>

<h5><span id="16-3-4-li-wai-qing-kuang-xia-wu-zhi">16.3.4 例外情况下无值</span><a href="#16-3-4-li-wai-qing-kuang-xia-wu-zhi" class="header-anchor">#</a></h5><p>当修改变体以获取新值并且此修改引发异常时，变体可能会进入一个非常特殊的状态：变体已经失去了旧值，但没有获得新值。 例如：</p>
<div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">S</span> {
    <span class="hljs-function"><span class="hljs-keyword">operator</span> <span class="hljs-title">int</span><span class="hljs-params">()</span> </span>{ <span class="hljs-keyword">throw</span> <span class="hljs-string">"EXCEPTION"</span>; } <span class="hljs-comment">// 任何到 int 的转换都会抛出</span>
};
std::variant&lt;<span class="hljs-type">double</span>,<span class="hljs-type">int</span>&gt; var{<span class="hljs-number">12.2</span>}; <span class="hljs-comment">// 初始化为 double</span>
var.<span class="hljs-built_in">emplace</span>&lt;<span class="hljs-number">1</span>&gt;(S{}); <span class="hljs-comment">// OOPS: 设置为 int 时抛出</span></code></pre></div>

<p>如果发生这种情况，那么：</p>
<ul>
<li>var.valueless_by_exception() 返回真</li>
<li>var.index() 返回 std::variant_npos<br>这表明该变体根本没有任何价值。<br>具体保证如下：</li>
<li>如果 emplace() 抛出 valueless_by_exception() 总是设置为 true。</li>
<li>如果 operator=() 抛出并且修改不会改变替代 valueless_by_exception() 并且 index() 保持它们的旧状态。值的状态取决于值类型的异常保证。</li>
<li>如果 operator=() 抛出并且新值将设置不同的替代项，则该变体可能没有值（valueless_by_exception() 可能变为 true）。这取决于何时抛出异常。如果它发生在值的实际修改开始之前的类型转换期间，则变体仍将保留其旧值。</li>
</ul>
<p>通常，只要您不再使用您尝试修改的变体，这种行为应该没有问题。如果你仍然想使用一个变体，尽管使用它会导致异常，你最好检查它的状态。例如：</p>
<div class="code-wrapper"><pre><code class="hljs c++">std::variant&lt;<span class="hljs-type">double</span>,<span class="hljs-type">int</span>&gt; var{<span class="hljs-number">12.2</span>}; <span class="hljs-comment">// 初始化为 double</span>
<span class="hljs-keyword">try</span> {
    var.<span class="hljs-built_in">emplace</span>&lt;<span class="hljs-number">1</span>&gt;(S{}); <span class="hljs-comment">// OOPS: 设置为 int 时抛出</span>
}
<span class="hljs-built_in">catch</span> (...) {
    <span class="hljs-keyword">if</span> (!var.<span class="hljs-built_in">valueless_by_exception</span>()) {
        ...;
    }
}</code></pre></div>

<h4><span id="16-4-shi-yong-std-variant-de-duo-tai-xing-he-fei-tong-zhi-hua-de-ji-he">16.4 使用std::variant的多态性和非同质化的集合</span><a href="#16-4-shi-yong-std-variant-de-duo-tai-xing-he-fei-tong-zhi-hua-de-ji-he" class="header-anchor">#</a></h4><p>具有 std::variant 的多态性和非同质集合</p>
<p>std::variant 启用了一种新形式的多态性并处理非同质集合。 它是一种具有一组紧密数据类型的 compile-time 多态性形式。</p>
<p>也就是说，通过使用 variant&lt;&gt;，您可以定义一个对象是多种可能的类型之一。 然后，该对象具有值语义，您可以将这些对象插入到非同质集合中。 因为每个变体都知道它拥有哪个替代方案，并且由于访问者界面，我们可以在运行时针对不同类型进行编程，调用不同的函数/方法（不需要任何虚函数、引用和指针）。 </p>
<h5><span id="16-4-1-shi-yong-std-variant-de-ji-he-dui-xiang">16.4.1 使用std::variant的几何对象</span><a href="#16-4-1-shi-yong-std-variant-de-ji-he-dui-xiang" class="header-anchor">#</a></h5><p>例如，假设我们必须对几何对象系统进行编程：</p>
<p><code>lib/variantpoly1.cpp </code></p>
<div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;variant&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">"coord.hpp"</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">"line.hpp"</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">"circle.hpp"</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">"rectangle.hpp"</span></span>
<span class="hljs-comment">// 所有几何对象类型的通用类型:</span>
<span class="hljs-keyword">using</span> GeoObj = std::variant&lt;Line, Circle, Rectangle&gt;;
<span class="hljs-comment">// 创建和初始化几何对象的集合:</span>
<span class="hljs-function">std::vector&lt;GeoObj&gt; <span class="hljs-title">createFigure</span><span class="hljs-params">()</span></span>
<span class="hljs-function"></span>{
    std::vector&lt;GeoObj&gt; f;
    f.<span class="hljs-built_in">push_back</span>(Line{Coord{<span class="hljs-number">1</span>,<span class="hljs-number">2</span>},Coord{<span class="hljs-number">3</span>,<span class="hljs-number">4</span>}});
    f.<span class="hljs-built_in">push_back</span>(Circle{Coord{<span class="hljs-number">5</span>,<span class="hljs-number">5</span>},<span class="hljs-number">2</span>});
    f.<span class="hljs-built_in">push_back</span>(Rectangle{Coord{<span class="hljs-number">3</span>,<span class="hljs-number">3</span>},Coord{<span class="hljs-number">6</span>,<span class="hljs-number">4</span>}});
    <span class="hljs-keyword">return</span> f;
}
<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>
<span class="hljs-function"></span>{
    std::vector&lt;GeoObj&gt; figure = <span class="hljs-built_in">createFigure</span>();
    <span class="hljs-keyword">for</span> (<span class="hljs-type">const</span> GeoObj&amp; geoobj : figure) {
        std::<span class="hljs-built_in">visit</span>([] (<span class="hljs-type">const</span> <span class="hljs-keyword">auto</span>&amp; obj) {
            obj.<span class="hljs-built_in">draw</span>(); <span class="hljs-comment">// draw() 的多态调用</span>
        },
        geoobj);
    }
}</code></pre></div>

<p>首先，我们为所有可能的类型定义一个通用数据类型：</p>
<div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">using</span> GeoObj = std::variant&lt;Line, Circle, Rectangle&gt;;</code></pre></div>

<p>这三种类型不需要任何特殊关系。 事实上，它们不必有一个通用的基类，没有虚函数，它们的接口甚至可能不同。 例如：</p>
<p><code>lib/circle.hpp</code></p>
<div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">ifndef</span> CIRCLE_HPP</span>
<span class="hljs-meta">#<span class="hljs-keyword">define</span> CIRCLE_HPP</span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">"coord.hpp"</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span>
<span class="hljs-keyword">class</span> <span class="hljs-title class_">Circle</span> {
    <span class="hljs-keyword">private</span>:
    Coord center;
    <span class="hljs-type">int</span> rad;
    <span class="hljs-keyword">public</span>:
    <span class="hljs-built_in">Circle</span> (Coord c, <span class="hljs-type">int</span> r)
        : center{c}, rad{r} {
        }
    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">move</span><span class="hljs-params">(<span class="hljs-type">const</span> Coord&amp; c)</span> </span>{
        center += c;
    }
    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">draw</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>{
        std::cout &lt;&lt; <span class="hljs-string">"circle at "</span> &lt;&lt; center
            &lt;&lt; <span class="hljs-string">" with radius "</span> &lt;&lt; rad &lt;&lt; <span class="hljs-string">'\n'</span>;
    }
};
<span class="hljs-meta">#<span class="hljs-keyword">endif</span></span></code></pre></div>

<p>现在我们可以通过创建相应的对象并将它们按值传递到容器中来将这些类型的元素放入一个集合中：</p>
<div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-function">std::vector&lt;GeoObj&gt; <span class="hljs-title">createFigure</span><span class="hljs-params">()</span></span>
<span class="hljs-function"></span>{
    std::vector&lt;GeoObj&gt; f;
    f.<span class="hljs-built_in">push_back</span>(Line{Coord{<span class="hljs-number">1</span>,<span class="hljs-number">2</span>},Coord{<span class="hljs-number">3</span>,<span class="hljs-number">4</span>}});
    f.<span class="hljs-built_in">push_back</span>(Circle{Coord{<span class="hljs-number">5</span>,<span class="hljs-number">5</span>},<span class="hljs-number">2</span>});
    f.<span class="hljs-built_in">push_back</span>(Rectangle{Coord{<span class="hljs-number">3</span>,<span class="hljs-number">3</span>},Coord{<span class="hljs-number">6</span>,<span class="hljs-number">4</span>}});
    <span class="hljs-keyword">return</span> f;
}
</code></pre></div>

<p>这段代码在运行时多态下是不可能的，因为那样的话类型必须将 GeoObj 作为一个公共基类，我们需要一个 GeoObj 元素的指针向量，并且由于指针，我们必须使用 new 创建对象，这样 我们必须跟踪何时调用 delete 或使用智能指针（unique_ptr 或 shared_ptr）。<br>通过使用访问者，我们可以遍历元素并根据元素类型“做正确的事”：</p>
<div class="code-wrapper"><pre><code class="hljs c++">std::vector&lt;GeoObj&gt; figure = <span class="hljs-built_in">createFigure</span>();
<span class="hljs-keyword">for</span> (<span class="hljs-type">const</span> GeoObj&amp; geoobj : figure) {
    std::<span class="hljs-built_in">visit</span>([] (<span class="hljs-type">const</span> <span class="hljs-keyword">auto</span>&amp; obj) {
        obj.<span class="hljs-built_in">draw</span>(); <span class="hljs-comment">// polymorphic call of draw()</span>
    },
    geoobj);
}
</code></pre></div>

<p>在这里，visit() 使用通用 lambda 来为每个可能的 GeoObj 类型实例化。 也就是说，在编译 visit() 调用时，lambda 被实例化并编译为三个函数：</p>
<ul>
<li><p>编译 Line 类型的代码：</p>
<div class="code-wrapper"><pre><code class="hljs c++">[] (<span class="hljs-type">const</span> Line&amp; obj) {
    obj.<span class="hljs-built_in">draw</span>(); <span class="hljs-comment">// call of Line::draw()</span>
}
</code></pre></div>
</li>
<li><p>编译 Circle 类型的代码：</p>
<div class="code-wrapper"><pre><code class="hljs c++">[] (<span class="hljs-type">const</span> Circle&amp; obj) {
    obj.<span class="hljs-built_in">draw</span>(); <span class="hljs-comment">// call of Circle::draw()</span>
}</code></pre></div>
</li>
<li><p>编译 Rectangle 类型的代码：</p>
<div class="code-wrapper"><pre><code class="hljs c++">[] (<span class="hljs-type">const</span> Rectangle&amp; obj) {
    obj.<span class="hljs-built_in">draw</span>(); <span class="hljs-comment">// call of Rectangle::draw()</span>
}</code></pre></div></li>
</ul>
<p>如果这些实例之一没有编译，则 visit() 的调用根本不会编译。 如果全部编译，则为每种元素类型生成调用相应函数的代码。 请注意，生成的代码没有 if-else 链。 该标准保证调用的性能不依赖于备选方案的数量。<br>也就是说，实际上我们得到了与虚函数表相同的行为（每个 visit() 都有一个本地虚函数表）。 请注意，调用的 draw() 函数不必是虚拟的。</p>
<p>如果类型接口不同，我们可以使用编译时 if 或访问者重载来处理这种情况（参见下面的第二个示例）。</p>
<h5><span id="16-4-2-qi-ta-shi-yong-std-variant-de-fei-tong-zhi-ji-he">16.4.2 其他使用std::variant的非同质集合</span><a href="#16-4-2-qi-ta-shi-yong-std-variant-de-fei-tong-zhi-ji-he" class="header-anchor">#</a></h5><p>作为将非同质集合与 std::variant&lt;&gt; 一起使用的另一个示例，请考虑以下示例：</p>
<p><code>lib/variantpoly2.cpp</code></p>
<div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;variant&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;type_traits&gt;</span></span>
<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>
<span class="hljs-function"></span>{
    <span class="hljs-keyword">using</span> Var = std::variant&lt;<span class="hljs-type">int</span>, <span class="hljs-type">double</span>, std::string&gt;;
    std::vector&lt;Var&gt; values {<span class="hljs-number">42</span>, <span class="hljs-number">0.19</span>, <span class="hljs-string">"hello world"</span>, <span class="hljs-number">0.815</span>};
    
    <span class="hljs-keyword">for</span> (<span class="hljs-type">const</span> Var&amp; val : values) {
        std::<span class="hljs-built_in">visit</span>([] (<span class="hljs-type">const</span> <span class="hljs-keyword">auto</span>&amp; v) {
            <span class="hljs-keyword">if</span> <span class="hljs-built_in">constexpr</span>(std::is_same_v&lt;<span class="hljs-keyword">decltype</span>(v),
                         <span class="hljs-type">const</span> std::string&amp;&gt;) {
                std::cout &lt;&lt; <span class="hljs-string">'"'</span> &lt;&lt; v &lt;&lt; <span class="hljs-string">"\" "</span>;
            }
            <span class="hljs-keyword">else</span> {
                std::cout &lt;&lt; v &lt;&lt; <span class="hljs-string">' '</span>;
            }
        },
        val);
    }
}</code></pre></div>

<p>同样，我们为表示多种可能类型之一的对象定义自己的类型：</p>
<div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">using</span> Var = std::variant&lt;<span class="hljs-type">int</span>, <span class="hljs-type">double</span>, std::string&gt;;
</code></pre></div>

<p>我们可以用它们创建一个初始化非同质集合：</p>
<div class="code-wrapper"><pre><code class="hljs c++">std::vector&lt;Var&gt; values {<span class="hljs-number">42</span>, <span class="hljs-number">0.19</span>, <span class="hljs-string">"hello world"</span>, <span class="hljs-number">0.815</span>};</code></pre></div>

<p>请注意，我们可以使用不均匀的元素集合来初始化vector，因为它们都转换为变体类型。 只有当我们传递一个 long 时，编译器才会知道是将它转换为 int 还是 double，这样就不会编译。</p>
<p>当我们迭代时，我们使用访问者为他们调用不同的函数。 然而，因为在这里我们想做不同的事情（如果值是字符串，则在值周围加上引号），我们使用compile-time if：</p>
<div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">for</span> (<span class="hljs-type">const</span> Var&amp; val : values) {
    std::<span class="hljs-built_in">visit</span>([] (<span class="hljs-type">const</span> <span class="hljs-keyword">auto</span>&amp; v) {
        <span class="hljs-keyword">if</span> <span class="hljs-built_in">constexpr</span>(std::is_same_v&lt;<span class="hljs-keyword">decltype</span>(v),
                     <span class="hljs-type">const</span> std::string&amp;&gt;) {
            std::cout &lt;&lt; <span class="hljs-string">'"'</span> &lt;&lt; v &lt;&lt; <span class="hljs-string">"\" "</span>;
        }
        <span class="hljs-keyword">else</span> {
            std::cout &lt;&lt; v &lt;&lt; <span class="hljs-string">' '</span>;
        }
    },
    val);
}</code></pre></div>

<p>这样输出就变成了：</p>
<div class="code-wrapper"><pre><code class="hljs bash">42 0.19 <span class="hljs-string">"hello world"</span> 0.815</code></pre></div>

<p>通过使用访问者重载，我们还可以如下实现：</p>
<div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">for</span> (<span class="hljs-type">const</span> <span class="hljs-keyword">auto</span>&amp; val : values) {
    std::<span class="hljs-built_in">visit</span>(overload{
        [] (<span class="hljs-keyword">auto</span> v) {
            std::cout &lt;&lt; v &lt;&lt; <span class="hljs-string">' '</span>;
        },
        [] (<span class="hljs-type">const</span> std::string&amp; v) {
            std::cout &lt;&lt; <span class="hljs-string">'"'</span> &lt;&lt; v &lt;&lt; <span class="hljs-string">"\" "</span>;
        }
    },
               val);
}</code></pre></div>

<h5><span id="16-4-3-bi-jiao-bian-ti-duo-tai-xing">16.4.3 比较变体多态性</span><a href="#16-4-3-bi-jiao-bian-ti-duo-tai-xing" class="header-anchor">#</a></h5><p>让我们总结一下使用 std::variant&lt;&gt; 处理多态性和非同质集合的优缺点。<br>好处是：</p>
<ul>
<li>您不需要常见的基本类型（非侵入式）。</li>
<li>您不必为非同质集合使用指针。</li>
<li>不需要虚拟成员函数。</li>
<li>值语义（无法访问已释放的内存或内存泄漏）。</li>
<li>向量中的元素位于一起（而不是通过堆内存中的指针分布）。</li>
</ul>
<p>限制和缺点是：</p>
<ul>
<li>关闭类型集（您必须在编译时了解所有替代方案）。</li>
<li>元素都具有最大元素类型的大小（如果元素类型大小差异很大，则会出现问题）。</li>
<li>复制元素可能更昂贵。</li>
</ul>
<p>一般来说，我现在建议默认使用 std::variant&lt;&gt; 来编程多态，因为它通常更快（没有 new 和 delete，没有用于非多态使用的虚函数），更安全（没有指针），并且 通常所有类型在所有代码的编译时都是已知的。<br>就在您必须处理引用语义（在多个地方使用相同的对象）或传递对象变得昂贵（即使使用移动语义）时，运行时多态性<br>继承可能仍然是合适的。</p>
<h4><span id="16-5-std-variant-lt-gt-de-te-shu-qing-kuang">16.5 std::variant&lt;&gt; 的特殊情况</span><a href="#16-5-std-variant-lt-gt-de-te-shu-qing-kuang" class="header-anchor">#</a></h4><p>特定变体可能导致特殊或意外行为</p>
<h5><span id="16-5-1-tong-shi-yong-you-bool-he-std-string-de-xuan-ze">16.5.1 同时拥有bool和std::string的选择</span><a href="#16-5-1-tong-shi-yong-you-bool-he-std-string-de-xuan-ze" class="header-anchor">#</a></h5><p>如果 std::variant&lt;&gt; 同时具有 bool 和 std::string 替代项，则分配字符串文字可能会变得令人惊讶，因为字符串文字转换为 bool 比转换为 std::string 更好。 例如：</p>
<div class="code-wrapper"><pre><code class="hljs c++">std::variant&lt;<span class="hljs-type">bool</span>, std::string&gt; v;
v = <span class="hljs-string">"hi"</span>; <span class="hljs-comment">// OOPS: sets the bool alternative</span>
std::cout &lt;&lt; <span class="hljs-string">"index: "</span> &lt;&lt; v.<span class="hljs-built_in">index</span>() &lt;&lt; <span class="hljs-string">'\n'</span>;
std::<span class="hljs-built_in">visit</span>([](<span class="hljs-type">const</span> <span class="hljs-keyword">auto</span>&amp; val) {
    std::cout &lt;&lt; <span class="hljs-string">"value: "</span> &lt;&lt; val &lt;&lt; <span class="hljs-string">'\n'</span>;
}, v);
</code></pre></div>

<p>此代码段将具有以下输出：</p>
<div class="code-wrapper"><pre><code class="hljs c++">index: <span class="hljs-number">0</span>
value: <span class="hljs-literal">true</span></code></pre></div>

<p>因此，字符串文字被解释为通过布尔值 true 初始化变量（因为指针不为 0，所以为 true）。<br>这里有几个选项可以“修复”分配：</p>
<div class="code-wrapper"><pre><code class="hljs c++">v.<span class="hljs-built_in">emplace</span>&lt;<span class="hljs-number">1</span>&gt;(<span class="hljs-string">"hello"</span>); <span class="hljs-comment">// 明确分配给第二个备选方案</span>
v.<span class="hljs-built_in">emplace</span>&lt;std::string&gt;(<span class="hljs-string">"hello"</span>); <span class="hljs-comment">// 显式分配给字符串替代</span>
v = std::string{<span class="hljs-string">"hello"</span>}; <span class="hljs-comment">// 确保分配了一个字符串</span>
<span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std::literals; <span class="hljs-comment">// 确保分配了一个字符串</span>
v = <span class="hljs-string">"hello"</span>s;</code></pre></div>

<h4><span id="16-6-hou-ji">16.6 后记</span><a href="#16-6-hou-ji" class="header-anchor">#</a></h4><p>变体对象于 2005 年由 Axel Naumann 在 <a target="_blank" rel="noopener" href="https://wg21.link/n4218">https://wg21.link/n4218</a> 中首次提出，将 Boost.Variant 作为参考实现。 制定了最终接受的措辞 Axel Naumann 在 <a target="_blank" rel="noopener" href="https://wg21.link/p0088r3">https://wg21.link/p0088r3</a> 中。</p>
<p>Tony van Eerd 使用 <a target="_blank" rel="noopener" href="https://wg21.link/p0393r3">https://wg21.link/p0393r3</a> 显着改进了比较运算符的语义。 Vicente J. Botet Escriba 将 API 与 std::optional&lt;&gt; 和 std::any 与 <a target="_blank" rel="noopener" href="https://wg21.link/p0032r3">https://wg21.link/p0032r3</a> 进行了协调。 Jonathan Wakely 使用 <a target="_blank" rel="noopener" href="https://wg21.link/p0504r0">https://wg21.link/p0504r0</a> 修复了 in_place 标记类型的行为。 Erich Keane 与 <a target="_blank" rel="noopener" href="https://wg21.link/p0510r0">https://wg21.link/p0510r0</a> 制定了禁止引用、不完整类型和数组以及空变体的限制。 在 C++17 发布后，Mike Spertus、Walter E. Brown 和 Stephan T. Lavavej 使用 <a target="_blank" rel="noopener" href="https://wg21.link/p0739r0">https://wg21.link/p0739r0</a> 修复了一个小缺陷。</p>
<h3><span id="17-std-any">17 std::any</span><a href="#17-std-any" class="header-anchor">#</a></h3><p>一般来说，C++ 是一种具有类型绑定和类型安全性的语言。值对象被声明为具有特定类型，它定义了哪些操作是可能的以及它们的行为方式。并且值对象不能改变它们的类型。</p>
<p>std::any 是一种能够改变其类型的值类型，同时仍具有类型安全性。也就是说，对象可以保存任意类型的值，但它们知道当前保存的值是哪种类型。声明此类型的对象时无需指定可能的类型。</p>
<p>诀窍是对象既包含包含的值，也包含使用 typeid 的包含值的类型。因为该值可以具有任何大小，所以内存可能会在堆上分配。但是，实现应避免将堆内存用于包含的小值，例如 int。</p>
<p>也就是说，如果您分配一个字符串，该对象会为该值分配内存并复制该字符串，同时还在内部存储分配的字符串。稍后，可以进行运行时检查以找出当前值具有哪种类型，并将该值用作其类型，any_cast&lt;&gt; 是必要的。</p>
<p>至于 std::optional&lt;&gt; 和 std::variant&lt;&gt; 结果对象具有值语义。也就是说，通过在自己的内存中创建一个具有当前包含值及其类型的独立对象来进行深度复制。因为可能涉及堆内存，所以复制 std::any 通常很昂贵，您应该更喜欢通过引用传递对象或移动值。部分支持移动语义。</p>
<h4><span id="17-1-shi-yong-std-any">17.1 使用 std::any</span><a href="#17-1-shi-yong-std-any" class="header-anchor">#</a></h4><p>以下示例演示了 std::any 的核心功能：</p>
<div class="code-wrapper"><pre><code class="hljs c++">std::any a; <span class="hljs-comment">// a 为空</span>
std::any b = <span class="hljs-number">4.3</span>; <span class="hljs-comment">// b 具有 double 类型的值 4.3</span>
a = <span class="hljs-number">42</span>; <span class="hljs-comment">// a 具有 int 类型的值 42</span>
b = std::string{<span class="hljs-string">"hi"</span>}; <span class="hljs-comment">// b 具有 std::string 类型的值 "hi"</span>
<span class="hljs-keyword">if</span> (a.<span class="hljs-built_in">type</span>() == <span class="hljs-built_in">typeid</span>(std::string)) {
    std::string s = std::<span class="hljs-built_in">any_cast</span>&lt;std::string&gt;(a);
    <span class="hljs-built_in">useString</span>(s);
}
<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (a.<span class="hljs-built_in">type</span>() == <span class="hljs-built_in">typeid</span>(<span class="hljs-type">int</span>)) {
    <span class="hljs-built_in">useInt</span>(std::<span class="hljs-built_in">any_cast</span>&lt;<span class="hljs-type">int</span>&gt;(a));
}</code></pre></div>

<p>您可以将 std::any 声明为空或由特定类型的值初始化。 初始值的类型成为包含值的类型。</p>
<p>通过使用成员函数 type()，您可以根据任何类型的类型 ID 检查包含值的类型。 如果对象为空，则类型 ID 为 typeid(void)。</p>
<p>要访问包含的值，您必须使用 std::any_cast&lt;&gt; 将其转换为它的类型：</p>
<div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">auto</span> s = std::<span class="hljs-built_in">any_cast</span>&lt;std::string&gt;(a);</code></pre></div>

<p>如果转换失败，因为对象为空或包含的类型不适合，则抛出 std::bad_any_cast。 因此，在不检查或不知道类型的情况下，您最好实现以下内容：</p>
<div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">try</span> {
    <span class="hljs-keyword">auto</span> s = std::<span class="hljs-built_in">any_cast</span>&lt;std::string&gt;(a);
    ...
}
<span class="hljs-built_in">catch</span> (std::bad_any_cast&amp; e) {
    std::cerr &lt;&lt; <span class="hljs-string">"EXCEPTION: "</span> &lt;&lt; e.<span class="hljs-built_in">what</span>() &lt;&lt; <span class="hljs-string">'\n'</span>;
}</code></pre></div>

<p>注意 std::any_cast&lt;&gt; 创建一个传递类型的对象。 如果您将 std::string 作为模板参数传递给 std::any_cast&lt;&gt;，它会创建一个临时字符串（prvalue），然后用于初始化新对象 s。 如果没有这样的初始化，通常最好转换为引用类型以避免创建临时对象：</p>
<div class="code-wrapper"><pre><code class="hljs c++">std::cout &lt;&lt; std::<span class="hljs-built_in">any_cast</span>&lt;<span class="hljs-type">const</span> std::string&amp;&gt;(a);</code></pre></div>

<p>为了能够修改该值，您需要强制转换为相应的引用类型：</p>
<div class="code-wrapper"><pre><code class="hljs c++">std::<span class="hljs-built_in">any_cast</span>&lt;std::string&amp;&gt;(a) = <span class="hljs-string">"world"</span>;</code></pre></div>

<p>您还可以调用 std::any_cast 以获得 std::any 对象的地址。 在这种情况下，如果类型适合，则强制转换返回相应的指针，否则返回 nullptr：</p>
<div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">auto</span> p = std::<span class="hljs-built_in">any_cast</span>&lt;std::string&gt;(&amp;a);
<span class="hljs-keyword">if</span> (p) {
    ...
}
</code></pre></div>

<p>要清空现有的 std::any 对象，您可以调用：</p>
<div class="code-wrapper"><pre><code class="hljs c++">a.<span class="hljs-built_in">reset</span>(); <span class="hljs-comment">// 使其为空</span>
</code></pre></div>

<p>或者：</p>
<div class="code-wrapper"><pre><code class="hljs c++">a = std::any{};
</code></pre></div>

<p>要不就：</p>
<div class="code-wrapper"><pre><code class="hljs c++">a = {};
</code></pre></div>

<p>您可以直接检查对象是否为空：</p>
<div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">if</span> (a.<span class="hljs-built_in">has_value</span>()) {
    ...
}
</code></pre></div>

<p>另请注意，值是使用其衰减类型存储的（数组转换为指针，顶级引用和 const 被忽略）。 对于字符串文字，这意味着值类型是 const char*。</p>
<p>要检查 type() 并使用 std::any_cast&lt;&gt; 您必须完全使用这种类型：</p>
<div class="code-wrapper"><pre><code class="hljs c++">std::any a = <span class="hljs-string">"hello"</span>; <span class="hljs-comment">// type() is const char*</span>
<span class="hljs-keyword">if</span> (a.<span class="hljs-built_in">type</span>() == <span class="hljs-built_in">typeid</span>(<span class="hljs-type">const</span> <span class="hljs-type">char</span>*)) { <span class="hljs-comment">// true</span>
    ...
}
<span class="hljs-keyword">if</span> (a.<span class="hljs-built_in">type</span>() == <span class="hljs-built_in">typeid</span>(std::string)) { <span class="hljs-comment">// false</span>
    ...
}
std::cout &lt;&lt; std::<span class="hljs-built_in">any_cast</span>&lt;<span class="hljs-type">const</span> <span class="hljs-type">char</span>*&gt;(v[<span class="hljs-number">1</span>]) &lt;&lt; <span class="hljs-string">'\n'</span>; <span class="hljs-comment">// OK</span>
std::cout &lt;&lt; std::<span class="hljs-built_in">any_cast</span>&lt;std::string&gt;(v[<span class="hljs-number">1</span>]) &lt;&lt; <span class="hljs-string">'\n'</span>; <span class="hljs-comment">// EXCEPTION</span></code></pre></div>

<p>这些或多或少都是所有操作。 没有定义比较运算符（因此，您不能比较或排序对象），没有定义散列函数，也没有定义 value() 成员函数。 并且因为类型只在运行时才知道，所以不能使用通用 lambda 来处理独立于其类型的当前值。 您总是需要运行时函数 std::any_cast&lt;&gt; 才能处理当前值，这意味着在处理值时需要一些特定于类型的代码来重新进入 C++ 类型系统。</p>
<p>但是，可以将 std::any 对象放入容器中。 例如：</p>
<div class="code-wrapper"><pre><code class="hljs c++">std::vector&lt;std::any&gt; v;
v.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">42</span>);
std::string s = <span class="hljs-string">"hello"</span>;
v.<span class="hljs-built_in">push_back</span>(s);
<span class="hljs-keyword">for</span> (<span class="hljs-type">const</span> <span class="hljs-keyword">auto</span>&amp; a : v) {
    <span class="hljs-keyword">if</span> (a.<span class="hljs-built_in">type</span>() == <span class="hljs-built_in">typeid</span>(std::string)) {
        std::cout &lt;&lt; <span class="hljs-string">"string: "</span> &lt;&lt; std::<span class="hljs-built_in">any_cast</span>&lt;<span class="hljs-type">const</span> std::string&amp;&gt;(a) &lt;&lt; <span class="hljs-string">'\n'</span>;
    }
    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (a.<span class="hljs-built_in">type</span>() == <span class="hljs-built_in">typeid</span>(<span class="hljs-type">int</span>)) {
        std::cout &lt;&lt; <span class="hljs-string">"int: "</span> &lt;&lt; std::<span class="hljs-built_in">any_cast</span>&lt;<span class="hljs-type">int</span>&gt;(a) &lt;&lt; <span class="hljs-string">'\n'</span>;
    }
}</code></pre></div>

<h4><span id="17-2-std-any-lei-xing-he-cao-zuo">17.2 std::any 类型和操作</span><a href="#17-2-std-any-lei-xing-he-cao-zuo" class="header-anchor">#</a></h4><p>本节详细介绍 std::any 的类型和操作。</p>
<h5><span id="17-2-1-any-lei-xing">17.2.1 Any 类型</span><a href="#17-2-1-any-lei-xing" class="header-anchor">#</a></h5><p>在头文件 <any> 中，C++ 标准库定义类 std::any 如下：</any></p>
<div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">namespace</span> std {
    <span class="hljs-keyword">class</span> <span class="hljs-title class_">any</span>;
}
</code></pre></div>

<p>也就是说， std::any 根本不是类模板。<br>此外，还定义了以下类型和对象：</p>
<ul>
<li>异常类std::bad_any_cast，派生自std::bad_cast，派生自std::exception，如果类型转换失败。</li>
</ul>
<p>任何对象也使用 <utility> 中定义的对象 std::in_place_type（类型为 std::in_place_type_t）。</utility></p>
<h5><span id="17-2-2-any-cao-zuo">17.2.2 Any 操作</span><a href="#17-2-2-any-cao-zuo" class="header-anchor">#</a></h5><p>表 std::any 操作列出了为 std::any 提供的所有操作。</p>
<table>
<thead>
<tr>
<th>Operation</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>constructors</td>
<td>创建一个任意对象（可能调用底层类型的构造函数）</td>
</tr>
<tr>
<td>make_any()</td>
<td>创建一个任意对象（传递值来初始化它）</td>
</tr>
<tr>
<td>destructor</td>
<td>销毁任何对象</td>
</tr>
<tr>
<td>=</td>
<td>分配一个新值</td>
</tr>
<tr>
<td>emplace<t>()</t></td>
<td>分配一个类型为 T 的新值</td>
</tr>
<tr>
<td>reset()</td>
<td>销毁任何值（使对象为空）</td>
</tr>
<tr>
<td>has_value()</td>
<td>返回对象是否有值</td>
</tr>
<tr>
<td>type()</td>
<td>将当前类型作为 std::type_info 对象返回</td>
</tr>
<tr>
<td>any_cast<t>()</t></td>
<td>使用当前值作为类型 T 的值（其他类型除外）</td>
</tr>
<tr>
<td>swap()</td>
<td>在两个对象之间交换值</td>
</tr>
</tbody></table>
<h6><span id="gou-zao">构造</span><a href="#gou-zao" class="header-anchor">#</a></h6><p>默认情况下， std::any 初始化为空。</p>
<div class="code-wrapper"><pre><code class="hljs c++">std::any a1; <span class="hljs-comment">// a1 为空</span></code></pre></div>

<p>如果一个值被传递给初始化，它的衰减类型被用作包含值的类型：</p>
<div class="code-wrapper"><pre><code class="hljs c++">std::any a2 = <span class="hljs-number">42</span>; <span class="hljs-comment">// a2 包含 int 类型的值</span>
std::any a3 = <span class="hljs-string">"hello"</span>; <span class="hljs-comment">// a2 包含 const char* 类型的值</span></code></pre></div>

<p>要保存与初始值类型不同的类型，您必须使用 in_place_type<br>标签：</p>
<div class="code-wrapper"><pre><code class="hljs c++">std::any a4{std::in_place_type&lt;<span class="hljs-type">long</span>&gt;, <span class="hljs-number">42</span>};
std::any a5{std::in_place_type&lt;std::string&gt;, <span class="hljs-string">"hello"</span>};</code></pre></div>

<p>甚至传递给 in_place_type 的类型也会衰减。 以下声明包含一个 const char*：</p>
<div class="code-wrapper"><pre><code class="hljs c++">std::any a5b{std::in_place_type&lt;<span class="hljs-type">const</span> <span class="hljs-type">char</span>[<span class="hljs-number">6</span>]&gt;, <span class="hljs-string">"hello"</span>};</code></pre></div>

<p>要通过多个参数初始化可选对象，您必须创建对象或添加 std::in_place_type 作为第一个参数（无法推断包含的类型）：</p>
<div class="code-wrapper"><pre><code class="hljs c++">std::any a6{std::complex{<span class="hljs-number">3.0</span>, <span class="hljs-number">4.0</span>}};
std::any a7{std::in_place_type&lt;std::complex&lt;<span class="hljs-type">double</span>&gt;&gt;, <span class="hljs-number">3.0</span>, <span class="hljs-number">4.0</span>};</code></pre></div>

<p>你甚至可以传递一个初始化列表，后跟其他参数：</p>
<div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-comment">// initialize a std::any with a set with lambda as sorting criterion:</span>
<span class="hljs-keyword">auto</span> sc = [] (<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y) {
    <span class="hljs-keyword">return</span> std::<span class="hljs-built_in">abs</span>(x) &lt; std::<span class="hljs-built_in">abs</span>(y);
};
std::any a8{std::in_place_type&lt;std::set&lt;<span class="hljs-type">int</span>,<span class="hljs-keyword">decltype</span>(sc)&gt;&gt;,
            {<span class="hljs-number">4</span>, <span class="hljs-number">8</span>, <span class="hljs-number">-7</span>, <span class="hljs-number">-2</span>, <span class="hljs-number">0</span>, <span class="hljs-number">5</span>},
            sc};
</code></pre></div>

<p>请注意，还有一个便利函数 make_any&lt;&gt;()，可用于单个或多个参数（不需要 in_place_type 参数）。 您始终必须明确指定初始化类型（如果仅传递一个参数，则不会推导出）：</p>
<div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">auto</span> a10 = std::<span class="hljs-built_in">make_any</span>&lt;<span class="hljs-type">float</span>&gt;(<span class="hljs-number">3.0</span>);
<span class="hljs-keyword">auto</span> a11 = std::<span class="hljs-built_in">make_any</span>&lt;std::string&gt;(<span class="hljs-string">"hello"</span>);
<span class="hljs-keyword">auto</span> a13 = std::make_any&lt;std::complex&lt;<span class="hljs-type">double</span>&gt;&gt;(<span class="hljs-number">3.0</span>, <span class="hljs-number">4.0</span>);
<span class="hljs-keyword">auto</span> a14 = std::make_any&lt;std::set&lt;<span class="hljs-type">int</span>,<span class="hljs-keyword">decltype</span>(sc)&gt;&gt;({<span class="hljs-number">4</span>, <span class="hljs-number">8</span>, <span class="hljs-number">-7</span>, <span class="hljs-number">-2</span>, <span class="hljs-number">0</span>, <span class="hljs-number">5</span>},
                                                     sc);
</code></pre></div>

<h6><span id="geng-gai-zhi">更改值</span><a href="#geng-gai-zhi" class="header-anchor">#</a></h6><p>存在相应的赋值和 emplace() 操作。 例如：</p>
<div class="code-wrapper"><pre><code class="hljs c++">std::any a;
a = <span class="hljs-number">42</span>; <span class="hljs-comment">// a 包含 int 类型的值</span>
a = <span class="hljs-string">"hello"</span>; <span class="hljs-comment">// a 包含 const char* 类型的值</span>
a.emplace{std::in_place_type&lt;std::string&gt;, <span class="hljs-string">"hello"</span>};
<span class="hljs-comment">// a 包含 std::string 类型的值</span>
a.emplace{std::in_place_type&lt;std::complex&lt;<span class="hljs-type">double</span>&gt;&gt;, <span class="hljs-number">4.4</span>, <span class="hljs-number">5.5</span>};
<span class="hljs-comment">// a 包含 std::complex&lt;double&gt; 类型的值</span></code></pre></div>

<h6><span id="fang-wen-zhi">访问值</span><a href="#fang-wen-zhi" class="header-anchor">#</a></h6><p>要访问包含的值，您必须使用 std::any_cast&lt;&gt; 将其转换为它的类型。 要将值转换为字符串，您有几个选项：</p>
<div class="code-wrapper"><pre><code class="hljs c++">std::<span class="hljs-built_in">any_cast</span>&lt;std::string&gt;(a) <span class="hljs-comment">// 生成值的副本</span>
std::<span class="hljs-built_in">any_cast</span>&lt;std::string&amp;&gt;(a); <span class="hljs-comment">// 通过引用写入值</span>
std::<span class="hljs-built_in">any_cast</span>&lt;<span class="hljs-type">const</span> std::string&amp;&gt;(a); <span class="hljs-comment">// 引用读访问</span></code></pre></div>

<p>在这里，如果转换失败，则抛出 std::bad_any_cast 异常。<br>如果删除了顶级引用的传递类型具有相同的类型 ID，则该类型适合。<br>如果转换失败，您可以传递一个地址来获取 nullptr，因为当前类型不适合：</p>
<div class="code-wrapper"><pre><code class="hljs c++">std::<span class="hljs-built_in">any_cast</span>&lt;std::string&gt;(&amp;a) <span class="hljs-comment">// 通过指针写访问</span>
std::<span class="hljs-built_in">any_cast</span>&lt;<span class="hljs-type">const</span> std::string&gt;(&amp;a); <span class="hljs-comment">// 通过指针读取访问</span></code></pre></div>

<p>请注意，此处转换为引用会导致运行时错误：</p>
<div class="code-wrapper"><pre><code class="hljs c++">std::<span class="hljs-built_in">any_cast</span>&lt;std::string&amp;&gt;(&amp;a); <span class="hljs-comment">// RUN-TIME ERROR</span></code></pre></div>

<h6><span id="yi-dong-yu-yi">移动语义</span><a href="#yi-dong-yu-yi" class="header-anchor">#</a></h6><p>std::any 还支持移动语义。 但是，请注意，仅具有复制语义的类型才支持移动语义。 也就是说，不支持将仅移动类型作为包含值类型。</p>
<p>处理移动语义的最佳方式可能并不明显。 所以，这里是你应该怎么做：</p>
<div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-function">std::string <span class="hljs-title">s</span><span class="hljs-params">(<span class="hljs-string">"hello, world!"</span>)</span></span>;
std::any a;
a = std::<span class="hljs-built_in">move</span>(s); <span class="hljs-comment">// move s into a</span>
s = std::<span class="hljs-built_in">move</span>(std::<span class="hljs-built_in">any_cast</span>&lt;string&amp;&gt;(a)); <span class="hljs-comment">// 将 a 中的分配字符串移动到 s</span></code></pre></div>

<p>像往常一样，对于移出对象，在最后一次调用之后，a 的包含值是未指定的。 因此，只要不假设包含的字符串值具有哪个值，就可以将 a 用作字符串。 以下语句的输出可能是空字符串，而不是“NIL”：</p>
<div class="code-wrapper"><pre><code class="hljs c++">std::cout &lt;&lt; (a.<span class="hljs-built_in">has_value</span>() ? std::<span class="hljs-built_in">any_cast</span>&lt;std::string&gt;(a) : std::<span class="hljs-built_in">string</span>(<span class="hljs-string">"NIL"</span>));</code></pre></div>

<p>注意：</p>
<div class="code-wrapper"><pre><code class="hljs c++">s = std::<span class="hljs-built_in">any_cast</span>&lt;string&gt;(std::<span class="hljs-built_in">move</span>(a));</code></pre></div>

<p>也可以，但需要额外的动作。</p>
<p>直接转换为右值引用不会编译：</p>
<div class="code-wrapper"><pre><code class="hljs c++">s = std::<span class="hljs-built_in">any_cast</span>&lt;std::string&amp;&amp;&gt;(a); <span class="hljs-comment">// compile-time error</span></code></pre></div>

<p>请注意，而不是调用</p>
<div class="code-wrapper"><pre><code class="hljs c++">a = std::<span class="hljs-built_in">move</span>(s); <span class="hljs-comment">// 将 s 移动到 a</span></code></pre></div>

<p>以下可能并不总是有效（尽管它是 C++ 标准中的一个示例）：</p>
<div class="code-wrapper"><pre><code class="hljs c++">std::<span class="hljs-built_in">any_cast</span>&lt;string&amp;&gt;(a) = std::<span class="hljs-built_in">move</span>(s); <span class="hljs-comment">// OOPS: a 必须持有一个字符串</span></code></pre></div>

<p>这仅在 a 已经包含 std::string 类型的值时才有效。 如果不是，则在我们移动分配新值之前，演员表会抛出一个 std::bad_any_cast 异常。</p>
<h4><span id="17-3-hou-ji">17.3 后记</span><a href="#17-3-hou-ji" class="header-anchor">#</a></h4><p>2006 年，Kevlin Henney 和 Beman Dawes 在 <a target="_blank" rel="noopener" href="https://wg21.link/n1939">https://wg21.link/n1939</a> 中首次提出任何对象，将 Boost.Any 作为参考实现。 正如 Beman Dawes、Kevlin Henney 和 Daniel Krugler 在 <a target="_blank" rel="noopener" href="https://wg21.link/n3804">https://wg21.link/n3804</a> 中提出的，该课程被采纳为图书馆基础知识 TS 的一部分。</p>
<p>正如 Beman Dawes 和 Alisdair Meredith 在 <a target="_blank" rel="noopener" href="https://wg21.link/p0220r1">https://wg21.link/p0220r1</a> 中提出的，该类与 C++17 的其他组件一起采用。</p>
<p>Vicente J. Botet Escriba 将 API 与 std::variant&lt;&gt; 和 std::optional&lt;&gt; 与 <a target="_blank" rel="noopener" href="https://wg21.link/p0032r3">https://wg21.link/p0032r3</a> 进行了协调。 Jonathan Wakely 使用 <a target="_blank" rel="noopener" href="https://wg21.link/p0504r0">https://wg21.link/p0504r0</a> 修复了 in_place 标记类型的行为。  </p>
<h3><span id="18-std-byte">18 std::byte</span><a href="#18-std-byte" class="header-anchor">#</a></h3><p>程序将数据保存在内存中。 对于 std::byte，C++17 为它引入了一种类型，它确实代表了内存元素字节的“自然”类型。 与 char 或 int 等类型的主要区别在于，这种类型不能（容易）（ab）用作整数值或字符类型。 对于数字计算或字符序列不是目标的情况，这会带来更多的类型安全性。</p>
<p>唯一支持的“计算”操作是按位运算符。</p>
<h4><span id="18-1-shi-yong-std-byte">18.1 使用 std::byte</span><a href="#18-1-shi-yong-std-byte" class="header-anchor">#</a></h4><p>以下示例演示了 std::byte 的核心功能：</p>
<div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstddef&gt;</span> <span class="hljs-comment">// for std::byte</span></span>
std::byte b1{<span class="hljs-number">0x3F</span>};
std::byte b2{<span class="hljs-number">0b1111</span>’<span class="hljs-number">0000</span>};
std::byte b3[<span class="hljs-number">4</span>] {b1, b2, std::byte{<span class="hljs-number">1</span>}}; <span class="hljs-comment">// 4 bytes (last is 0)</span>
<span class="hljs-keyword">if</span> (b1 == b3[<span class="hljs-number">0</span>]) {
    b1 &lt;&lt;= <span class="hljs-number">1</span>;
}
std::cout &lt;&lt; std::<span class="hljs-built_in">to_integer</span>&lt;<span class="hljs-type">int</span>&gt;(b1) &lt;&lt; <span class="hljs-string">'\n'</span>; <span class="hljs-comment">// outputs: 126</span></code></pre></div>

<p>在这里，我们定义了两个具有两个不同初始值的字节。 b2 使用自 C++14 以来可用的两个功能进行初始化：</p>
<ul>
<li>前缀 0b 可以定义二进制文字。</li>
<li>数字分隔符 ‘ 允许使数字文字在源代码中更具可读性（它可以放在数字文字的任意两位之间）。</li>
</ul>
<p>请注意，列表初始化（使用花括号）是您可以直接初始化 std::byte 对象的单个值的唯一方法。 所有其他形式不编译：</p>
<div class="code-wrapper"><pre><code class="hljs c++">std::byte b1{<span class="hljs-number">42</span>}; <span class="hljs-comment">// ok（对于自 C++17 以来具有固定基础类型的所有枚举）</span>
<span class="hljs-function">std::byte <span class="hljs-title">b2</span><span class="hljs-params">(<span class="hljs-number">42</span>)</span></span>; <span class="hljs-comment">// ERROR</span>
std::byte b3 = <span class="hljs-number">42</span>; <span class="hljs-comment">// ERROR</span>
std::byte b4 = {<span class="hljs-number">42</span>}; <span class="hljs-comment">// ERROR</span>
</code></pre></div>

<p>这是 std::byte 被实现为枚举类型这一事实的直接结果，使用可以用整数值初始化作用域枚举的新方式。<br>也没有隐式转换，因此您必须使用显式转换的整数文字来初始化字节数组：</p>
<div class="code-wrapper"><pre><code class="hljs c++">std::byte b5[] {<span class="hljs-number">1</span>}; <span class="hljs-comment">// ERROR</span>
std::byte b6[] {std::byte{<span class="hljs-number">1</span>}}; <span class="hljs-comment">// OK</span>
</code></pre></div>

<p>在没有任何初始化的情况下，堆栈上的对象的 std::byte 的值是未定义的：</p>
<div class="code-wrapper"><pre><code class="hljs c++">std::byte b; <span class="hljs-comment">// 未定义的值</span>
</code></pre></div>

<p>像往常一样（除了原子），您可以通过列表初始化强制将所有位设置为零的初始化：</p>
<div class="code-wrapper"><pre><code class="hljs c++">std::byte b{}; <span class="hljs-comment">// 与b{0}一样 </span>
</code></pre></div>

<p>std::to_integer&lt;&gt;() 提供将字节对象用作整数值（包括 bool 和 char）的能力。 如果没有转换，输出运算符将无法编译。 请注意，因为它是一个模板，您甚至需要使用 std:: 完全限定的转换</p>
<div class="code-wrapper"><pre><code class="hljs c++">std::cout &lt;&lt; b1; <span class="hljs-comment">// ERROR</span>
std::cout &lt;&lt; <span class="hljs-built_in">to_integer</span>&lt;<span class="hljs-type">int</span>&gt;(b1); <span class="hljs-comment">// ERROR (ADL 在这里不起作用)</span>
std::cout &lt;&lt; std::<span class="hljs-built_in">to_integer</span>&lt;<span class="hljs-type">int</span>&gt;(b1); <span class="hljs-comment">// OK</span></code></pre></div>

<p>这样的转换对于使用 std::byte 作为布尔值也是必要的。 例如：</p>
<div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">if</span> (b2) ... <span class="hljs-comment">// ERROR</span>
<span class="hljs-keyword">if</span> (b2 != std::byte{<span class="hljs-number">0</span>}) ... <span class="hljs-comment">// OK</span>
<span class="hljs-keyword">if</span> (<span class="hljs-built_in">to_integer</span>&lt;<span class="hljs-type">bool</span>&gt;(b2)) ... <span class="hljs-comment">// ERROR (ADL 在这里不起作用)</span>
<span class="hljs-keyword">if</span> (std::<span class="hljs-built_in">to_integer</span>&lt;<span class="hljs-type">bool</span>&gt;(b2)) ... <span class="hljs-comment">// OK</span></code></pre></div>

<p>因为 std::byte 被定义为枚举类型，底层类型为 unsigned char，所以 std::byte 的大小始终为 1：</p>
<div class="code-wrapper"><pre><code class="hljs c++">std::cout &lt;&lt; <span class="hljs-built_in">sizeof</span>(b); <span class="hljs-comment">// always 1</span></code></pre></div>

<p>位数取决于 unsigned char 类型的位数，您可以通过标准数字限制找到：</p>
<div class="code-wrapper"><pre><code class="hljs c++">std::cout &lt;&lt; std::numeric_limits&lt;<span class="hljs-type">unsigned</span> <span class="hljs-type">char</span>&gt;::digits; <span class="hljs-comment">// std::byte 的位数</span></code></pre></div>

<p>大多数时候是 8，但有些平台并非如此。</p>
<h4><span id="18-2-std-byte-lei-xing-he-cao-zuo">18.2 std::byte 类型和操作</span><a href="#18-2-std-byte-lei-xing-he-cao-zuo" class="header-anchor">#</a></h4><p>本节详细介绍 std::byte 的类型和操作。</p>
<h5><span id="18-2-1-std-byte-lei-xing">18.2.1 std::byte 类型</span><a href="#18-2-1-std-byte-lei-xing" class="header-anchor">#</a></h5><p>在头文件 <cstddef> 中，C++ 标准库定义类型 std::byte 如下：</cstddef></p>
<div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">namespace</span> std {
    <span class="hljs-keyword">enum class</span> <span class="hljs-title class_">byte</span> : <span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> {
    };
}</code></pre></div>

<p>也就是说，std::byte 只不过是一个范围枚举类型，其中定义了一些补充的按位运算符：</p>
<div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">namespace</span> std {
    ...
    <span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> IntType&gt;
    <span class="hljs-keyword">constexpr</span> byte <span class="hljs-keyword">operator</span>&lt;&lt; (byte b, IntType shift) <span class="hljs-keyword">noexcept</span>;
    <span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> IntType&gt;
    <span class="hljs-keyword">constexpr</span> byte&amp; <span class="hljs-keyword">operator</span>&lt;&lt;= (byte&amp; b, IntType shift) <span class="hljs-keyword">noexcept</span>;
    <span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> IntType&gt;
    <span class="hljs-keyword">constexpr</span> byte <span class="hljs-keyword">operator</span>&gt;&gt; (byte b, IntType shift) <span class="hljs-keyword">noexcept</span>;
    <span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> IntType&gt;
    <span class="hljs-keyword">constexpr</span> byte&amp; <span class="hljs-keyword">operator</span>&gt;&gt;= (byte&amp; b, IntType shift) <span class="hljs-keyword">noexcept</span>;
    <span class="hljs-keyword">constexpr</span> byte&amp; <span class="hljs-keyword">operator</span>|= (byte&amp; l, byte r) <span class="hljs-keyword">noexcept</span>;
    <span class="hljs-keyword">constexpr</span> byte <span class="hljs-keyword">operator</span>| (byte l, byte r) <span class="hljs-keyword">noexcept</span>;
    <span class="hljs-keyword">constexpr</span> byte&amp; <span class="hljs-keyword">operator</span>&amp;= (byte&amp; l, byte r) <span class="hljs-keyword">noexcept</span>;
    <span class="hljs-keyword">constexpr</span> byte <span class="hljs-keyword">operator</span>&amp; (byte l, byte r) <span class="hljs-keyword">noexcept</span>;
    <span class="hljs-keyword">constexpr</span> byte&amp; <span class="hljs-keyword">operator</span>^= (byte&amp; l, byte r) <span class="hljs-keyword">noexcept</span>;
    <span class="hljs-keyword">constexpr</span> byte <span class="hljs-keyword">operator</span>^ (byte l, byte r) <span class="hljs-keyword">noexcept</span>;
    <span class="hljs-keyword">constexpr</span> byte <span class="hljs-keyword">operator</span>~ (byte b) <span class="hljs-keyword">noexcept</span>;
    <span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> IntType&gt;</span>
<span class="hljs-function">    <span class="hljs-keyword">constexpr</span> IntType <span class="hljs-title">to_integer</span> <span class="hljs-params">(byte b)</span> <span class="hljs-keyword">noexcept</span></span>;
}</code></pre></div>

<h5><span id="18-2-2-std-byte-cao-zuo">18.2.2 std::byte 操作</span><a href="#18-2-2-std-byte-cao-zuo" class="header-anchor">#</a></h5><p>表 std::byte 操作列出了为 std::byte 提供的所有操作。</p>
<table>
<thead>
<tr>
<th>Operation</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>constructors</td>
<td>创建一个字节对象（使用默认构造函数未定义的值）</td>
</tr>
<tr>
<td>destructor</td>
<td>销毁一个字节对象（什么都不做）</td>
</tr>
<tr>
<td>=</td>
<td>分配一个新值</td>
</tr>
<tr>
<td>==, !=, &lt;, &lt;=, &gt;, &gt;=</td>
<td>比较字节对象</td>
</tr>
<tr>
<td>`&lt;&lt;, &gt;&gt;,</td>
<td>, &amp;, ^, ~`</td>
</tr>
<tr>
<td>`&lt;&lt;=, &gt;&gt;=,</td>
<td>=, &amp;=, ^=`</td>
</tr>
<tr>
<td>to_integer<t>()</t></td>
<td>将字节对象转换为整型 T</td>
</tr>
<tr>
<td>sizeof()</td>
<td>Yields 1</td>
</tr>
</tbody></table>
<h6><span id="zhuan-huan-wei-zheng-xing">转换为整型</span><a href="#zhuan-huan-wei-zheng-xing" class="header-anchor">#</a></h6><p>通过使用 to_integer&lt;&gt;()，您可以将 std::byte 转换为任何基本的整数类型（bool、字符类型或整数类型）。 例如，这是将 std::byte 与数值进行比较或在条件中使用它所必需的：</p>
<div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">if</span> (b2) ... <span class="hljs-comment">// ERROR</span>
<span class="hljs-keyword">if</span> (b2 != std::byte{<span class="hljs-number">0</span>}) ... <span class="hljs-comment">// OK</span>
<span class="hljs-keyword">if</span> (<span class="hljs-built_in">to_integer</span>&lt;<span class="hljs-type">bool</span>&gt;(b2)) ... <span class="hljs-comment">// ERROR (ADL 在这里不起作用)</span>
<span class="hljs-keyword">if</span> (std::<span class="hljs-built_in">to_integer</span>&lt;<span class="hljs-type">bool</span>&gt;(b2)) ... <span class="hljs-comment">// OK</span></code></pre></div>

<p>另一个使用示例是 std::byte I/O to_integer&lt;&gt;() 使用从 unsigned char 到目标类型的静态转换规则。<br>例如：</p>
<div class="code-wrapper"><pre><code class="hljs c++">std::byte ff{<span class="hljs-number">0xFF</span>};
std::cout &lt;&lt; std::<span class="hljs-built_in">to_integer</span>&lt;<span class="hljs-type">unsigned</span> <span class="hljs-type">int</span>&gt;(ff); <span class="hljs-comment">// 255</span>
std::cout &lt;&lt; std::<span class="hljs-built_in">to_integer</span>&lt;<span class="hljs-type">int</span>&gt;(ff); <span class="hljs-comment">// also 255 (没有负值)</span>
std::cout &lt;&lt; <span class="hljs-built_in">static_cast</span>&lt;<span class="hljs-type">int</span>&gt;(std::<span class="hljs-built_in">to_integer</span>&lt;<span class="hljs-type">signed</span> <span class="hljs-type">char</span>&gt;(ff)); <span class="hljs-comment">// -1</span></code></pre></div>

<h6><span id="dai-you-std-byte-de-i-o">带有 std::byte 的 I/O</span><a href="#dai-you-std-byte-de-i-o" class="header-anchor">#</a></h6><p>没有为 std::byte 定义输入和输出运算符，因此您必须将它们转换为整数值：</p>
<div class="code-wrapper"><pre><code class="hljs c++">std::byte b;
...
std::cout &lt;&lt; std::<span class="hljs-built_in">to_integer</span>&lt;<span class="hljs-type">int</span>&gt;(b); <span class="hljs-comment">// 将值打印为十进制值</span>
std::cout &lt;&lt; std::hex &lt;&lt; std::<span class="hljs-built_in">to_integer</span>&lt;<span class="hljs-type">int</span>&gt;(b); <span class="hljs-comment">// 将值打印为十六进制值</span></code></pre></div>

<p>通过使用 std::bitset&lt;&gt;，您还可以将值输出为二进制值（位序列）：</p>
<div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bitset&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;limits&gt;</span></span>
<span class="hljs-keyword">using</span> ByteBitset = std::bitset&lt;std::numeric_limits&lt;<span class="hljs-type">unsigned</span> <span class="hljs-type">char</span>&gt;::digits&gt;;
std::cout &lt;&lt; ByteBitset{std::<span class="hljs-built_in">to_integer</span>&lt;<span class="hljs-type">unsigned</span> <span class="hljs-type">char</span>&gt;(b1)};</code></pre></div>

<p>using 声明定义了一个 bitset 类型，其位数与 std::byte 一样，然后我们创建并输出这样一个用字节的整数类型初始化的对象。<br>您还可以使用它将 std::byte 的二进制表示形式写入字符串：</p>
<div class="code-wrapper"><pre><code class="hljs c++">std::string s = ByteBitset{std::<span class="hljs-built_in">to_integer</span>&lt;<span class="hljs-type">unsigned</span> <span class="hljs-type">char</span>&gt;(b1)}.<span class="hljs-built_in">to_string</span>();</code></pre></div>

<p>输入方式类似：只需将值读取为整数、字符串或位集值并进行转换。 例如，您可以编写一个输入运算符，从二进制表示中读取一个字节，如下所示：</p>
<div class="code-wrapper"><pre><code class="hljs c++">std::istream&amp; <span class="hljs-keyword">operator</span>&gt;&gt; (std::istream&amp; strm, std::byte&amp; b)
{
    <span class="hljs-comment">// 读入 bitset:</span>
    std::bitset&lt;std::numeric_limits&lt;<span class="hljs-type">unsigned</span> <span class="hljs-type">char</span>&gt;::digits&gt; bs;
    strm &gt;&gt; bs;
    <span class="hljs-comment">// 没有失败，转换为 std::byte:</span>
    <span class="hljs-keyword">if</span> (! std::cin.<span class="hljs-built_in">fail</span>()) {
        b = <span class="hljs-built_in">static_cast</span>&lt;std::byte&gt;(bs.<span class="hljs-built_in">to_ulong</span>()); <span class="hljs-comment">// OK</span>
    }
    <span class="hljs-keyword">return</span> strm;
}</code></pre></div>

<p>请注意，我们必须使用 static_cast&lt;&gt;() 将 bitset 转换为 unsigned long 转换为 std::byte。 列表初始化不起作用，因为转换范围缩小：</p>
<div class="code-wrapper"><pre><code class="hljs c++">b = std::byte{bs.<span class="hljs-built_in">to_ulong</span>()}; <span class="hljs-comment">// ERROR: 缩小</span></code></pre></div>

<p>而且我们没有其他的初始化方式.</p>
<h4><span id="18-3-hou-ji">18.3 后记</span><a href="#18-3-hou-ji" class="header-anchor">#</a></h4><p>std::byte 最初由 Neil MacIntosh 提出，传入 <a target="_blank" rel="noopener" href="https://wg21.link/p0298r0%E3%80%82">https://wg21.link/p0298r0。</a> 最终接受的措辞由 Neil MacIntosh 在 <a target="_blank" rel="noopener" href="https://wg21.link/p0298r3">https://wg21.link/p0298r3</a> 中制定。</p>
<h3><span id="19-string-views">19 String Views</span><a href="#19-string-views" class="header-anchor">#</a></h3><p>在 C++17 中，C++ 标准库采用了一个特殊的字符串类，它允许我们处理像字符串这样的字符序列，而无需为它们分配内存：std::string_view。<br>也就是说，std::string_view 对象引用外部字符序列而不拥有它们。<br>也就是说，对象可以被认为是对字符序列的引用。</p>
<p><img src="C:\string_view.png" srcset="/img/loading.gif" lazyload alt="string_view"></p>
<p>使用这样的字符串视图既便宜又快速（按值传递 string_view 总是很便宜）。 然而，它也有潜在的危险，因为与原始指针类似，程序员需要确保在使用 string_view 时引用的字符序列仍然有效）。</p>
<h4><span id="19-1-yu-std-string-de-qu-bie">19.1 与 std::string 的区别</span><a href="#19-1-yu-std-string-de-qu-bie" class="header-anchor">#</a></h4><p>与 std::string 相比，std::string_view 对象具有以下属性：</p>
<ul>
<li><p>底层字符序列是只读的。 没有允许修改字符的操作。 您只能分配新值、交换值以及删除开头或结尾的字符。</p>
</li>
<li><p>不保证字符序列以空值结尾。 因此，字符串视图不是以空结尾的字节流 (NTBS)。</p>
</li>
<li><p>该值可以是 nullptr，例如在使用默认构造函数初始化字符串视图后由 data() 返回。</p>
</li>
<li><p>没有分配器支持。<br>由于可能的 nullptr 值和可能缺少的 null 终止符，您应该始终在通过 operator[] 或 data() 访问字符之前使用 size() （除非您知道得更好）。</p>
</li>
</ul>
<h4><span id="19-2-shi-yong-string-views">19.2 使用 String Views</span><a href="#19-2-shi-yong-string-views" class="header-anchor">#</a></h4><p>字符串视图有两个主要应用：</p>
<ol>
<li><p>您可能已经使用字符序列或字符串分配或映射数据，并希望在不分配更多内存的情况下使用这些数据。典型的例子是使用内存映射文件或处理大文本中的子字符串。   </p>
</li>
<li><p>您想提高接收字符串的函数/操作的性能，只是直接以只读方式处理它们，不需要尾随的空终止符。<br>这种情况的一种特殊形式可能是将字符串文字处理为具有类似于字符串的 API 的对象：</p>
</li>
</ol>
<div class="code-wrapper"><pre><code class="hljs C++"><span class="hljs-type">static</span> <span class="hljs-keyword">constexpr</span> std::string_view hello{<span class="hljs-string">"hello world"</span>};</code></pre></div>

<p>第一个示例通常意味着通常只传递字符串视图，而编程逻辑必须确保底层字符序列保持有效（即，映射的文件内容未被取消映射）。在任何时候，您都可以使用字符串视图来初始化或将它们的值分配给 std::string。</p>
<p>但请注意，使用字符串视图就像“更好的字符串”一样。这可能会导致更差的性能和严重的运行时错误。因此，请仔细阅读以下小节。</p>
<h4><span id="19-3-shi-yong-yu-zi-fu-chuan-xiang-si-de-zi-fu-chuan-shi-tu">19.3 使用与字符串相似的字符串视图</span><a href="#19-3-shi-yong-yu-zi-fu-chuan-xiang-si-de-zi-fu-chuan-shi-tu" class="header-anchor">#</a></h4><p>第一个示例，使用像只读字符串一样的 string_view，是一个打印带有作为字符串视图传递的前缀的元素集合的函数： </p>
<div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string_view&gt;</span></span>
<span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;</span>
<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">printElems</span><span class="hljs-params">(<span class="hljs-type">const</span> T&amp; coll, std::string_view prefix = std::string_view{})</span></span>
<span class="hljs-function"></span>{
    <span class="hljs-keyword">for</span> (<span class="hljs-type">const</span> <span class="hljs-keyword">auto</span>&amp; elem : coll) {
        <span class="hljs-keyword">if</span> (prefix.<span class="hljs-built_in">data</span>()) { <span class="hljs-comment">// 检查 nullptr</span>
            std::cout &lt;&lt; prefix &lt;&lt; <span class="hljs-string">' '</span>;
        }
        std::cout &lt;&lt; elem &lt;&lt; <span class="hljs-string">'\n'</span>;
    }
}</code></pre></div>

<p>在这里，仅通过声明函数将采用 std::string_view，与采用 std::string 的函数相比，我们可以节省分配堆内存的调用。 详细信息取决于是否传递了短字符串以及是否使用了短字符串优化 (SSO)。 例如，如果我们将函数声明如下：</p>
<div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;</span>
<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">printElems</span><span class="hljs-params">(<span class="hljs-type">const</span> T&amp; coll, <span class="hljs-type">const</span> std::string&amp; prefix = std::string{})</span></span>;
</code></pre></div>

<p>我们传递一个字符串文字，调用会创建一个临时字符串，它将分配内存，除非字符串很短并且使用了短字符串优化。 通过使用字符串视图，不需要分配，因为字符串视图只引用字符串文字。</p>
<p>但是，请注意，在使用字符串视图的任何未知值之前，必须根据 nullptr 检查 data()。</p>
<p>另一个示例，使用像只读字符串一样的 string_view，是 std::optional&lt;&gt; 的 asInt() 示例的改进版本，它是为字符串参数声明的：</p>
<p><code>lib/asint.cpp </code></p>
<div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;optional&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string_view&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;charconv&gt;</span> <span class="hljs-comment">// 对于 from_chars()</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span>
<span class="hljs-comment">// 如果可能，将字符串转换为 int:</span>
<span class="hljs-function">std::optional&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">asInt</span><span class="hljs-params">(std::string_view sv)</span></span>
<span class="hljs-function"></span>{
    <span class="hljs-type">int</span> val;
    <span class="hljs-comment">// 将字符序列读入 int:</span>
    <span class="hljs-keyword">auto</span> [ptr, ec] = std::<span class="hljs-built_in">from_chars</span>(sv.<span class="hljs-built_in">data</span>(), sv.<span class="hljs-built_in">data</span>()+sv.<span class="hljs-built_in">size</span>(),
                                     val);
    <span class="hljs-comment">// 如果我们有错误代码，则不返回任何值:</span>
    <span class="hljs-keyword">if</span> (ec != std::errc{}) {
        <span class="hljs-keyword">return</span> std::<span class="hljs-literal">nullopt</span>;
    }
    <span class="hljs-keyword">return</span> val;
}
<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>
<span class="hljs-function"></span>{
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> s : {<span class="hljs-string">"42"</span>, <span class="hljs-string">" 077"</span>, <span class="hljs-string">"hello"</span>, <span class="hljs-string">"0x33"</span>} ) {
        <span class="hljs-comment">// 如果可能，尝试将 s 转换为 int 并打印结果:</span>
        std::optional&lt;<span class="hljs-type">int</span>&gt; oi = <span class="hljs-built_in">asInt</span>(s);
        <span class="hljs-keyword">if</span> (oi) {
            std::cout &lt;&lt; <span class="hljs-string">"convert '"</span> &lt;&lt; s &lt;&lt; <span class="hljs-string">"' to int: "</span> &lt;&lt; *oi &lt;&lt; <span class="hljs-string">"\n"</span>;
        }
        <span class="hljs-keyword">else</span> {
            std::cout &lt;&lt; <span class="hljs-string">"can't convert '"</span> &lt;&lt; s &lt;&lt; <span class="hljs-string">"' to int\n"</span>;
        }
    }
}</code></pre></div>

<p>现在， asInt() 按值获取字符串视图。但是，这会产生重大影响。首先，使用 std::stoi() 创建整数不再有意义，因为 stoi() 接受一个字符串，而从字符串视图创建一个字符串是一项相对昂贵的操作。</p>
<p>相反，我们将字符串视图的字符范围传递给新的标准库函数 std::from_chars()。它需要一对原始字符指针来转换字符的开头和结尾。请注意，这意味着我们可以跳过对空字符串视图的任何特殊处理，其中 data() 为 nullptr 且 size() 为 0，因为从 nullptr 到 nullptr+0 的范围是有效的空范围（对于添加的任何指针类型0 受支持且无效）。</p>
<p>std_from_chars() 返回一个 std::from_chars_result，它是一个具有两个成员的结构，一个指向未处理的第一个字符的指针 ptr 和一个 std::errc ec，其中 std::errc 表示没有错误。因此，在使用返回值的 ec 成员（使用结构化绑定）初始化 ec 后，如果转换失败，则以下检查返回 nullopt：</p>
<div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">if</span> (ec != std::errc{}) {
    <span class="hljs-keyword">return</span> std::<span class="hljs-literal">nullopt</span>;
}
</code></pre></div>

<p>在对子字符串进行排序时，使用字符串视图还可以显着提高性能。</p>
<h5><span id="19-3-1-bei-ren-wei-shi-you-hai-de-zi-fu-chuan-shi-tu">19.3.1 被认为是有害的字符串视图</span><a href="#19-3-1-bei-ren-wei-shi-you-hai-de-zi-fu-chuan-shi-tu" class="header-anchor">#</a></h5><p>通常，诸如智能指针之类的“智能对象”被认为比相应的语言功能更安全（或至少不更危险）。 因此，给人的印象可能是字符串视图（一种字符串引用）更安全，或者至少与使用字符串引用一样安全。 但不幸的是，事实并非如此。 字符串视图实际上比字符串引用或智能指针更危险。<br>它们的行为更像原始字符指针。</p>
<h6><span id="bu-yao-jiang-zi-fu-chuan-fen-pei-gei-zi-fu-chuan-shi-tu">不要将字符串分配给字符串视图</span><a href="#bu-yao-jiang-zi-fu-chuan-fen-pei-gei-zi-fu-chuan-shi-tu" class="header-anchor">#</a></h6><p>考虑我们声明一个返回新字符串的函数：</p>
<div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-function">std::string <span class="hljs-title">retString</span><span class="hljs-params">()</span></span>;
</code></pre></div>

<p>使用返回值通常很安全：</p>
<ul>
<li><p>将其分配给使用 auto 声明的字符串或对象是安全的（但可以移动，这通常是可以的，但没有最佳性能）：</p>
<div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">auto</span> std::string s1 = <span class="hljs-built_in">retString</span>(); <span class="hljs-comment">// safe</span>
</code></pre></div>
</li>
<li><p>如果可能的话，将返回值分配给字符串引用是非常安全的，只要我们在本地使用该对象，因为引用会将返回值的生命周期延长到其生命周期的末尾：</p>
<div class="code-wrapper"><pre><code class="hljs c++">std::string&amp; s2 = <span class="hljs-built_in">retString</span>(); <span class="hljs-comment">// 编译时错误（缺少常量）</span>
<span class="hljs-type">const</span> std::string&amp; s3 = <span class="hljs-built_in">retString</span>(); <span class="hljs-comment">// s3 延长返回字符串的生命周期</span>
std::cout &lt;&lt; s3 &lt;&lt; <span class="hljs-string">'\n'</span>; <span class="hljs-comment">// OK</span>
<span class="hljs-keyword">auto</span>&amp;&amp; s4 = <span class="hljs-built_in">retString</span>(); <span class="hljs-comment">// s4 延长返回字符串的生命周期</span>
std::cout &lt;&lt; <span class="hljs-number">4</span> &lt;&lt; <span class="hljs-string">'\n'</span>; <span class="hljs-comment">// OK</span>
</code></pre></div></li>
</ul>
<p>对于字符串视图，没有给出这种安全性。 它既不复制也不延长返回值的生命周期：</p>
<div class="code-wrapper"><pre><code class="hljs c++">std::string_view sv = <span class="hljs-built_in">retString</span>(); <span class="hljs-comment">// sv 不会延长返回字符串的生命周期</span>
std::cout &lt;&lt; sv &lt;&lt; <span class="hljs-string">'\n'</span>; <span class="hljs-comment">// 运行时错误：返回的字符串被破坏</span></code></pre></div>

<p>在这里，返回的字符串在第一条语句的末尾被破坏，因此从字符串视图 sv 中引用它是一个致命的运行时错误，导致未定义的行为。<br>问题与调用时相同：</p>
<div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-type">const</span> <span class="hljs-type">char</span>* p = <span class="hljs-built_in">retString</span>().<span class="hljs-built_in">c_str</span>();</code></pre></div>

<p>或者：</p>
<div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">auto</span> p = <span class="hljs-built_in">retString</span>().<span class="hljs-built_in">c_str</span>();</code></pre></div>

<p>出于这个原因，您还应该非常小心地返回一个字符串视图：</p>
<div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-comment">// 非常危险:</span>
<span class="hljs-function">std::string_view <span class="hljs-title">substring</span><span class="hljs-params">(<span class="hljs-type">const</span> std::string&amp;, std::<span class="hljs-type">size_t</span> idx = <span class="hljs-number">0</span>)</span></span>;
<span class="hljs-comment">// 因为:</span>
<span class="hljs-keyword">auto</span> sub = <span class="hljs-built_in">substring</span>(<span class="hljs-string">"very nice"</span>, <span class="hljs-number">5</span>); <span class="hljs-comment">// 将视图返回到传递的临时字符串</span>
<span class="hljs-comment">// 但调用后临时字符串被破坏</span>
std::cout &lt;&lt; sub &lt;&lt; <span class="hljs-string">'\n'</span>; <span class="hljs-comment">// 运行时错误：tmp 字符串已被破坏</span></code></pre></div>

<h6><span id="bu-yao-jiang-zi-fu-chuan-shi-tu-fan-hui-gei-zi-fu-chuan">不要将字符串视图返回给字符串</span><a href="#bu-yao-jiang-zi-fu-chuan-shi-tu-fan-hui-gei-zi-fu-chuan" class="header-anchor">#</a></h6><p>尤其是让字符串成员的 getter 返回字符串视图是一种非常危险的设计。 因此，您不应执行以下操作：</p>
<div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span> {
    std::string name;
<span class="hljs-keyword">public</span>:
    <span class="hljs-built_in">Person</span> (std::string n) : name{std::<span class="hljs-built_in">move</span>(n)} {
    }
    <span class="hljs-function">std::string_view <span class="hljs-title">getName</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>{ <span class="hljs-comment">// don’t do this</span>
        <span class="hljs-keyword">return</span> name;
    }
};</code></pre></div>

<p>因为，同样，以下结果将成为致命的运行时错误，导致未定义的行为：</p>
<div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-function">Person <span class="hljs-title">createPerson</span><span class="hljs-params">()</span></span>;
<span class="hljs-keyword">auto</span> n = <span class="hljs-built_in">createPerson</span>().<span class="hljs-built_in">getName</span>(); <span class="hljs-comment">// OOPS：删除临时字符串</span>
std::cout &lt;&lt; <span class="hljs-string">"name: "</span> &lt;&lt; n &lt;&lt; <span class="hljs-string">'\n'</span>; <span class="hljs-comment">// 致命的运行时错误</span></code></pre></div>

<p>如果 getName() 按值或按引用返回字符串，这又是一个问题。</p>
<h6><span id="han-shu-mo-ban-ying-gai-shi-yong-fan-hui-lei-xing-auto">函数模板应该使用返回类型 auto</span><a href="#han-shu-mo-ban-ying-gai-shi-yong-fan-hui-lei-xing-auto" class="header-anchor">#</a></h6><p>请注意，很容易意外地将返回的字符串分配给字符串视图。 例如，考虑两个单独看起来非常有用的函数的定义：</p>
<div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-comment">// 为返回字符串的字符串视图定义 +:</span>
std::string <span class="hljs-keyword">operator</span>+ (std::string_view sv1, std::string_view sv2) {
    <span class="hljs-keyword">return</span> std::<span class="hljs-built_in">string</span>(sv1) + std::<span class="hljs-built_in">string</span>(sv2);
}
<span class="hljs-comment">// 泛型串联:</span>
<span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;</span>
<span class="hljs-function">T <span class="hljs-title">concat</span> <span class="hljs-params">(<span class="hljs-type">const</span> T&amp; x, <span class="hljs-type">const</span> T&amp; y)</span> </span>{
    <span class="hljs-keyword">return</span> x + y;
}</code></pre></div>

<p>但是，再次将它们一起使用可能很容易导致致命的运行时错误：</p>
<div class="code-wrapper"><pre><code class="hljs c++">std::string_view hi = <span class="hljs-string">"hi"</span>;
<span class="hljs-keyword">auto</span> xy = <span class="hljs-built_in">concat</span>(hi, hi); <span class="hljs-comment">// xy 是 std::string_view</span>
std::cout &lt;&lt; xy &lt;&lt; <span class="hljs-string">'\n'</span>; <span class="hljs-comment">// 致命的运行时错误：引用的字符串被破坏</span></code></pre></div>

<p>这样的代码很容易被意外编写。 这里真正的问题是 concat() 的返回类型。 如果声明它的返回类型由编译器推断，上面的示例将 xy 初始化为 std::string：</p>
<div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-comment">// 改进的通用连接:</span>
<span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;</span>
<span class="hljs-function"><span class="hljs-keyword">auto</span> <span class="hljs-title">concat</span> <span class="hljs-params">(<span class="hljs-type">const</span> T&amp; x, <span class="hljs-type">const</span> T&amp; y)</span> </span>{
    <span class="hljs-keyword">return</span> x + y;
}</code></pre></div>

<p>此外，在调用链中使用字符串视图会适得其反，因为在调用链中或在其末尾需要字符串。 例如，如果您使用以下构造函数定义类 Person：</p>
<div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span> {
    std::string name;
<span class="hljs-keyword">public</span>:
    <span class="hljs-built_in">Person</span> (std::string_view n) : name{n} {
    }
    ...
};</code></pre></div>

<p>传递您仍然需要的字符串文字或字符串很好：</p>
<div class="code-wrapper"><pre><code class="hljs c++">Person p1{<span class="hljs-string">"Jim"</span>}; <span class="hljs-comment">// 没有性能开销</span>
std::string s = <span class="hljs-string">"Joe"</span>;
Person p2{s}; <span class="hljs-comment">// 没有性能开销</span></code></pre></div>

<p>但是在字符串中移动变得不必要的昂贵，因为传递的字符串首先被隐式转换为字符串视图，然后用于创建一个新的字符串再次分配内存：</p>
<div class="code-wrapper"><pre><code class="hljs c++">Person p3{std::<span class="hljs-built_in">move</span>(s)}; <span class="hljs-comment">// 性能开销：移动损坏</span></code></pre></div>

<p>不要在这里处理 std::string_view 。 按值取参数并将其移动到成员仍然是最好的解决方案。 因此，构造函数和 getter 应该如下所示：</p>
<div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span> {
    std::string name;
<span class="hljs-keyword">public</span>:
    <span class="hljs-built_in">Person</span> (std::string n) : name{std::<span class="hljs-built_in">move</span>(n)} {
    }
    <span class="hljs-function">std::string <span class="hljs-title">getName</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>{
        <span class="hljs-keyword">return</span> name;
    }
};</code></pre></div>

<h6><span id="zi-fu-chuan-shi-tu-de-an-quan-shi-yong-zong-jie">字符串视图的安全使用总结</span><a href="#zi-fu-chuan-shi-tu-de-an-quan-shi-yong-zong-jie" class="header-anchor">#</a></h6><p>总而言之，请谨慎使用 std::string_view，这意味着您还应该更改<br>您编程的一般风格：</p>
<ul>
<li>不要在 API 中使用将参数传递给字符串的字符串视图。<br>– 不要从字符串视图参数初始化字符串成员。<br>– 字符串视图链的末尾没有字符串。</li>
<li>不要返回字符串视图。<br>– 除非它只是一个转发的输入参数，或者您通过例如相应地命名函数来发出危险信号。</li>
<li>出于这个原因，函数模板永远不应该返回传递的泛型参数的类型 T。<br>– 改为返回 auto。</li>
<li>永远不要使用返回值来初始化字符串视图。</li>
<li>出于这个原因，不要将返回泛型类型的函数模板的返回值分配给 auto。<br>– 这意味着，AAA（几乎总是自动）模式被字符串视图打破。<br>如果这些规则太复杂或难以遵循，请不要使用 std::string_view （除非您知道自己在做什么）。</li>
</ul>
<h4><span id="19-4-string-view-lei-xing-he-cao-zuo">19.4 String View 类型和操作</span><a href="#19-4-string-view-lei-xing-he-cao-zuo" class="header-anchor">#</a></h4><p>本节详细介绍字符串视图的类型和操作。</p>
<h5><span id="19-4-1-ju-ti-zi-fu-chuan-shi-tu-lei-xing">19.4.1 具体字符串视图类型</span><a href="#19-4-1-ju-ti-zi-fu-chuan-shi-tu-lei-xing" class="header-anchor">#</a></h5><p>在头文件 <string_view> 中，C++ 标准库提供了一些类 basic_string_view&lt;&gt; 的特化：</string_view></p>
<ul>
<li>类 std::string_view 是该模板的预定义特化，用于 char 类型的字符：</li>
</ul>
<div class="code-wrapper"><pre><code class="hljs C++"><span class="hljs-keyword">namespace</span> std {
    <span class="hljs-keyword">using</span> string_view = basic_string_view&lt;<span class="hljs-type">char</span>&gt;;
}</code></pre></div>

<ul>
<li>对于使用更广泛字符集（例如 Unicode 或某些亚洲字符集）的字符串，预定义了其他三种类型：</li>
</ul>
<div class="code-wrapper"><pre><code class="hljs C++"><span class="hljs-keyword">namespace</span> std {
    <span class="hljs-keyword">using</span> u16string_view = basic_string_view&lt;<span class="hljs-type">char16_t</span>&gt;;
    <span class="hljs-keyword">using</span> u32string_view = basic_string_view&lt;<span class="hljs-type">char32_t</span>&gt;;
    <span class="hljs-keyword">using</span> wstring_view = basic_string_view&lt;<span class="hljs-type">wchar_t</span>&gt;;
}</code></pre></div>

<p>在以下部分中，这些类型的字符串视图之间没有区别。用法和问题是相同的，因为所有字符串视图类都具有相同的接口。因此，“字符串视图”表示任何字符串视图类型：string_view、u16string_view、u32string_view 和 wstring_view。本书中的示例通常使用 string_view 类型，因为欧洲和英美环境是软件开发的常见环境。</p>
<h5><span id="19-4-2-zi-fu-chuan-shi-tu-cao-zuo">19.4.2 字符串视图操作</span><a href="#19-4-2-zi-fu-chuan-shi-tu-cao-zuo" class="header-anchor">#</a></h5><p>表字符串视图操作列出了为字符串视图提供的所有操作。<br>除了 remove_prefix() 和 remove_suffix() 之外，还为 std::strings 提供了字符串视图的所有操作。 但是，保证可能略有不同，因为对于字符串视图， data() 返回的值可能是 nullptr 并且缺少保证以空终止符结束序列。</p>
<table>
<thead>
<tr>
<th>操作</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>constructors</td>
<td>创建或复制字符串视图</td>
</tr>
<tr>
<td>destructor</td>
<td>销毁字符串视图</td>
</tr>
<tr>
<td>=</td>
<td>分配一个新值</td>
</tr>
<tr>
<td>swap()</td>
<td>在两个字符串视图之间交换值</td>
</tr>
<tr>
<td>==, !=, &lt;, &lt;=, &gt;, &gt;=, compare()</td>
<td>比较字符串视图</td>
</tr>
<tr>
<td>empty()</td>
<td>返回字符串视图是否为空</td>
</tr>
<tr>
<td>size(), length()</td>
<td>返回字符数</td>
</tr>
<tr>
<td>max_size()</td>
<td>返回最大可能的字符数</td>
</tr>
<tr>
<td>[], at()</td>
<td>访问一个字符</td>
</tr>
<tr>
<td>front(), back()</td>
<td>访问第一个或最后一个字符</td>
</tr>
<tr>
<td>&lt;&lt;</td>
<td>将值写入流</td>
</tr>
<tr>
<td>copy()</td>
<td>将内容复制或写入字符数组</td>
</tr>
<tr>
<td>data()</td>
<td>将值作为 nullptr 或常量字符返回，数组（注意：没有终止空字符）</td>
</tr>
<tr>
<td>find functions</td>
<td>搜索某个子字符串或字符</td>
</tr>
<tr>
<td>begin(), end()</td>
<td>提供正常的迭代器支持</td>
</tr>
<tr>
<td>cbegin(), cend()</td>
<td>提供常量迭代器支持</td>
</tr>
<tr>
<td>rbegin(), rend()</td>
<td>提供反向迭代器支持</td>
</tr>
<tr>
<td>crbegin(), crend()</td>
<td>提供常量反向迭代器支持</td>
</tr>
<tr>
<td>substr()</td>
<td>返回某个子字符串</td>
</tr>
<tr>
<td>remove_prefix()</td>
<td>删除前导字符</td>
</tr>
<tr>
<td>remove_suffix()</td>
<td>删除尾随字符</td>
</tr>
<tr>
<td>hash&lt;&gt;</td>
<td>计算哈希值的函数对象类型</td>
</tr>
</tbody></table>
<h6><span id="gou-zao">构造</span><a href="#gou-zao" class="header-anchor">#</a></h6><p>您可以使用默认构造函数创建字符串视图，作为副本，从原始字符数组（以 null 终止或具有指定长度），从 std::string 或作为带有后缀 sv 的文字。 但是，请注意以下几点：</p>
<ul>
<li><p>使用默认构造函数创建的字符串视图将 nullptr 作为 data()。 因此，没有有效的 operator[] 调用。</p>
<div class="code-wrapper"><pre><code class="hljs c++">std::string_view sv;
<span class="hljs-keyword">auto</span> p = sv.<span class="hljs-built_in">data</span>(); <span class="hljs-comment">// 产生 nullptr</span>
std::cout &lt;&lt; sv[<span class="hljs-number">0</span>]; <span class="hljs-comment">// ERROR: 没有有效字符</span></code></pre></div>
</li>
<li><p>当通过空终止字节流初始化字符串视图时，结果大小是不带 ‘\0’ 的字符数，并且使用终止空字符的索引是无效的：</p>
<div class="code-wrapper"><pre><code class="hljs c++">std::string_view sv{<span class="hljs-string">"hello"</span>};
std::cout &lt;&lt; sv; <span class="hljs-comment">// OK</span>
std::cout &lt;&lt; sv.<span class="hljs-built_in">size</span>(); <span class="hljs-comment">// 5</span>
std::cout &lt;&lt; sv.<span class="hljs-built_in">at</span>(<span class="hljs-number">5</span>); <span class="hljs-comment">// 抛出 std::out_of_range 异常</span>
std::cout &lt;&lt; sv[<span class="hljs-number">5</span>]; <span class="hljs-comment">// 未定义的行为，但在这里它通常有效</span>
std::cout &lt;&lt; sv.<span class="hljs-built_in">data</span>(); <span class="hljs-comment">// 未定义的行为，但在这里它通常有效</span></code></pre></div>

<p>最后两个调用是形式上未定义的行为。 因此，它们不能保证工作，尽管在这种情况下您可以假设在最后一个字符之后有空终止符。<br>您可以通过传递包括空终止符在内的字符数来初始化具有空终止符作为其值的一部分的字符串视图：</p>
<div class="code-wrapper"><pre><code class="hljs c++">std::string_view sv{<span class="hljs-string">"hello"</span>, <span class="hljs-number">6</span>}; <span class="hljs-comment">// <span class="hljs-doctag">NOTE:</span> 6 to include ’\0’</span>
std::cout &lt;&lt; sv.<span class="hljs-built_in">size</span>(); <span class="hljs-comment">// 6</span>
std::cout &lt;&lt; sv.<span class="hljs-built_in">at</span>(<span class="hljs-number">5</span>); <span class="hljs-comment">// OK, 打印  ’\0’的值</span>
std::cout &lt;&lt; sv[<span class="hljs-number">5</span>]; <span class="hljs-comment">// OK, 打印 '\0' 的值</span>
std::cout &lt;&lt; sv.<span class="hljs-built_in">data</span>(); <span class="hljs-comment">// OK</span></code></pre></div>
</li>
<li><p>要从 std::string 创建字符串视图，std::string 类中提供了隐式转换运算符。 同样，在最后一个字符之后有空终止符，通常保证字符串，不保证字符串视图存在：</p>
<div class="code-wrapper"><pre><code class="hljs c++">std::string s = <span class="hljs-string">"hello"</span>;
std::cout &lt;&lt; s.<span class="hljs-built_in">size</span>(); <span class="hljs-comment">// 5</span>
std::cout &lt;&lt; s.<span class="hljs-built_in">at</span>(<span class="hljs-number">5</span>); <span class="hljs-comment">// OK, 打印 '\0' 的值</span>
std::cout &lt;&lt; s[<span class="hljs-number">5</span>]; <span class="hljs-comment">// OK, 打印 '\0' 的值</span>
std::string_view sv{s};
std::cout &lt;&lt; sv.<span class="hljs-built_in">size</span>(); <span class="hljs-comment">// 5</span>
std::cout &lt;&lt; sv.<span class="hljs-built_in">at</span>(<span class="hljs-number">5</span>); <span class="hljs-comment">// 抛出 std::out_of_range 异常</span>
std::cout &lt;&lt; sv[<span class="hljs-number">5</span>]; <span class="hljs-comment">// 未定义的行为，但在这里它通常有效</span>
std::cout &lt;&lt; sv.<span class="hljs-built_in">data</span>(); <span class="hljs-comment">// 未定义的行为，但在这里它通常有效</span></code></pre></div>
</li>
<li><p>由于为后缀 sv 定义了文字运算符，因此您还可以创建一个字符串视图，如下所示：</p>
<div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std::literals;
<span class="hljs-keyword">auto</span> s = <span class="hljs-string">"hello"</span>sv;</code></pre></div></li>
</ul>
<p>这里的关键点是，通常你不应该期望空终止字符并且在访问字符之前总是使用 size() （除非你知道关于值的具体事情）。</p>
<p>作为一种解决方法，您可以将 ‘\0’ 作为字符串视图的一部分，但您不应该使用字符串视图作为空终止字符串，而空终止符不是它的一部分，即使空终止符就在后面。</p>
<h6><span id="san-lie">散列</span><a href="#san-lie" class="header-anchor">#</a></h6><p>C++ 标准库保证字符串和字符串视图的哈希值是相等的。</p>
<h6><span id="xiu-gai-zi-fu-chuan-shi-tu">修改字符串视图</span><a href="#xiu-gai-zi-fu-chuan-shi-tu" class="header-anchor">#</a></h6><p>只提供了几个操作来修改字符串视图：</p>
<ul>
<li><p>您可以分配一个新值或交换两个字符串视图的值：</p>
<div class="code-wrapper"><pre><code class="hljs c++">std::string_view sv1 = <span class="hljs-string">"hey"</span>;
std::string_view sv2 = <span class="hljs-string">"world"</span>;
sv1.<span class="hljs-built_in">swap</span>(sv2);
sv2 = sv1;
</code></pre></div>
</li>
<li><p>您可以跳过前导或尾随字符（即，将开头移动到第一个字符后面的字符或将结尾移动到最后一个字符之前的字符）。</p>
<div class="code-wrapper"><pre><code class="hljs c++">std::string_view sv = <span class="hljs-string">"I like my kindergarten"</span>;
sv.<span class="hljs-built_in">remove_prefix</span>(<span class="hljs-number">2</span>);
sv.<span class="hljs-built_in">remove_suffix</span>(<span class="hljs-number">8</span>);
std::cout &lt;&lt; sv; <span class="hljs-comment">// prints: like my kind</span>
</code></pre></div></li>
</ul>
<p>​    请注意，不支持 operator+。 因此：</p>
<div class="code-wrapper"><pre><code class="hljs c++">std::string_view sv1 = <span class="hljs-string">"hello"</span>;
std::string_view sv2 = <span class="hljs-string">"world"</span>;
<span class="hljs-keyword">auto</span> s1 = sv1 + sv2; <span class="hljs-comment">// ERROR</span>
</code></pre></div>

<p>其中一个操作数必须是字符串：</p>
<div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">auto</span> s2 = std::<span class="hljs-built_in">string</span>(sv1) + sv2; <span class="hljs-comment">// OK</span>
</code></pre></div>

<p>请注意，没有隐式转换为字符串，因为这是一项昂贵的操作，因为它可能会分配内存。 因此，只能进行显式转换。</p>
<h5><span id="19-4-3-qi-ta-lei-xing-de-zi-fu-chuan-shi-tu-zhi-chi">19.4.3 其他类型的字符串视图支持</span><a href="#19-4-3-qi-ta-lei-xing-de-zi-fu-chuan-shi-tu-zhi-chi" class="header-anchor">#</a></h5><p>原则上，可以传递字符串的每个地方也传递字符串视图是有意义的，期望接收者何时需要将该值以空值终止（例如，通过将值传递给字符串的 C 函数）。</p>
<p>​    但是，到目前为止，我们只添加了对最重要的地方的支持：</p>
<ul>
<li>字符串可以在有用的地方使用或与字符串视图结合使用。 您可以从中创建一个字符串（构造函数是显式的）、分配、追加、插入、替换、比较或通过传递字符串视图来查找子字符串。<br>还有从字符串到字符串视图的隐式转换。</li>
<li>你可以将一个字符串视图传递给std::quoted，它可以打印出其带引号的值。比如说:</li>
</ul>
<div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std::literals;
<span class="hljs-keyword">auto</span> s = <span class="hljs-string">R""(some\value) "sv; // 原始字符串视图</span>
<span class="hljs-string">std::cout &lt;&lt; std::quoted(s); // 输出。"some\value"</span>
<span class="hljs-string"></span></code></pre></div>

<ul>
<li>你可以用字符串视图初始化、扩展或比较文件系统路径。</li>
</ul>
<p>但是，例如，在C++标准库的regex组件中还没有对字符串视图的支持。标准库中，还没有对字符串视图的支持。</p>
<h4><span id="19-5-shi-yong-string-views-in-api-s">19.5 使用 String Views in API’s</span><a href="#19-5-shi-yong-string-views-in-api-s" class="header-anchor">#</a></h4><p>字符串视图很便宜，每个std::string都可以作为一个字符串视图使用。所以，似乎std::string_view是处理字符串参数的更好的类型。嗯，细节很重要…<br>首先，使用std::string_view只有在使用该参数的函数具有以下条件时才有意义<br>以下的限制条件时，使用std::string_view才有意义。</p>
<ul>
<li><p>它不期望在结尾处有一个空的终结符。例如，当把参数作为一个单一的const char*传递给C函数时，情况就不是这样了。</p>
</li>
<li><p>它尊重所传递参数的生命周期。通常这意味着接收函数只使用传递的值，直到它结束。</p>
</li>
<li><p>调用函数不应该处理底层字符的所有者（比如删除它，改变它的值，或者释放它的内存）。</p>
</li>
<li><p>它可以将nullptr作为值来处理。<br>请注意，如果你同时为std::string和std::string_view的函数重载，可能会出现歧义错误。std::string_view。</p>
<div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">foo</span><span class="hljs-params">(<span class="hljs-type">const</span> std::string&amp;)</span></span>;
<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">foo</span><span class="hljs-params">(std::string_view)</span></span>;
<span class="hljs-built_in">foo</span>(<span class="hljs-string">"hello"</span>); <span class="hljs-comment">// ERROR: 模糊的</span>
</code></pre></div></li>
</ul>
<h5><span id="19-5-1-shi-yong-yong-yu-chu-shi-hua-zi-fu-chuan-de-zi-fu-chuan-shi-tu">19.5.1 使用用于初始化字符串的字符串视图</span><a href="#19-5-1-shi-yong-yong-yu-chu-shi-hua-zi-fu-chuan-de-zi-fu-chuan-shi-tu" class="header-anchor">#</a></h5><p>看起来字符串视图的一个简单而有用的应用是在初始化字符串时将其声明为参数类型 当初始化一个字符串时。但是要注意!</p>
<p>考虑用 “老办法 “来初始化一个字符串成员。</p>
<div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span> {
    std::string name;
<span class="hljs-keyword">public</span>:
    <span class="hljs-built_in">Person</span> (<span class="hljs-type">const</span> std::string&amp; n) : <span class="hljs-built_in">name</span>(n) {
    }
    ...
};</code></pre></div>

<p>这个构造函数有其缺点。用一个字符串字头初始化一个人，会产生一个不必要的拷贝，这可能会导致对堆内存的不必要的请求。比如说:</p>
<div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-function">Person <span class="hljs-title">p</span><span class="hljs-params">(<span class="hljs-string">"Aprettylong NonSSO Name"</span>)</span></span>;</code></pre></div>

<p>首先调用 std::string 构造函数来创建临时参数 n，因为请求了 std::string 类型的引用。 如果字符串很长或没有启用短字符串优化，这意味着为字符串值分配堆内存。 即使使用移动语义，临时字符串也会被复制以初始化成员名称，这意味着再次分配内存。<br>您只能通过添加更多构造函数重载或引入模板构造函数来避免这种开销，这可能会导致其他问题。<br>相反，如果我们使用字符串视图，性能会更好：</p>
<div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span> {
    std::string name;
<span class="hljs-keyword">public</span>:
    <span class="hljs-built_in">Person</span> (std::string_view n) : <span class="hljs-built_in">name</span>(n) {
    }
    ...
};</code></pre></div>

<p>现在，一个临时的字符串视图n被创建，它根本不分配内存，因为字符串视图只引用了字符串字面的字符。只有name的初始化为成员name分配了一次内存。</p>
<p>然而，有一个问题：如果你传递一个临时字符串或用std::move()标记的字符串，该字符串被转换为字符串视图的类型（这很便宜），然后字符串视图被用来为新字符串分配内存（这很昂贵）。换句话说。使用字符串视图会禁用移动语义，除非你为它提供一个额外的重载。</p>
<p>对于如何初始化带有字符串成员的对象，仍然有明确的建议。以 字符串的值和移动。</p>
<div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span> {
    std::string name;
<span class="hljs-keyword">public</span>:
    <span class="hljs-built_in">Person</span> (std::string n) : <span class="hljs-built_in">name</span>(std::<span class="hljs-built_in">move</span>(n)) {
    }
    ...
};</code></pre></div>

<p>无论如何，我们必须创建一个字符串。因此，尽快创建它可以使我们在传递参数的那一刻就能从所有可能的优化中受益。当我们拥有它时，我们只需移动，这是一个廉价的操作。</p>
<p>如果我们通过一个返回临时字符串的辅助函数来初始化这个字符串:</p>
<div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-function">std::string <span class="hljs-title">newName</span><span class="hljs-params">()</span></span>
<span class="hljs-function"></span>{
    ...;
    <span class="hljs-keyword">return</span> std::string{...};
}
Person p{<span class="hljs-built_in">newName</span>()};</code></pre></div>

<p>强制性的复制消除将推迟新字符串的物化，直到该值被传递给构造函数。在那里我们有一个名为n的字符串，这样我们就有了一个有位置的对象（一个glvalue）。<br>然后这个对象的值被移动到初始化成员名。<br>这个例子再次证明了。</p>
<ul>
<li>字符串视图并不是一个更好的取用字符串的接口。</li>
<li>事实上，字符串视图只应该在调用链中使用，在那里它们永远不必作为字符串使用</li>
</ul>
<h5><span id="19-5-2-shi-yong-zi-fu-chuan-shi-tu-er-bu-shi-zi-fu-chuan">19.5.2 使用字符串视图而不是字符串</span><a href="#19-5-2-shi-yong-zi-fu-chuan-shi-tu-er-bu-shi-zi-fu-chuan" class="header-anchor">#</a></h5><p>还有其他通过字符串视图替换字符串的可能。但还是要小心。<br>例如，用下面的代码代替:</p>
<div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-comment">// 将时间点（带前缀）转换为字符串:</span>
<span class="hljs-function">std::string <span class="hljs-title">toString</span> <span class="hljs-params">(<span class="hljs-type">const</span> std::string&amp; prefix, <span class="hljs-type">const</span> std::chrono::system_clock::time_point&amp; tp)</span></span>
<span class="hljs-function"></span>{
    <span class="hljs-comment">// 转换为日历时间:</span>
    <span class="hljs-keyword">auto</span> rawtime = std::chrono::system_clock::<span class="hljs-built_in">to_time_t</span>(tp);
    std::string ts = std::<span class="hljs-built_in">ctime</span>(&amp;rawtime); <span class="hljs-comment">// 注意：不是线程安全的</span>
    ts.<span class="hljs-built_in">resize</span>(ts.<span class="hljs-built_in">size</span>()<span class="hljs-number">-1</span>); <span class="hljs-comment">// 跳过尾随换行符</span>
    <span class="hljs-keyword">return</span> prefix + ts;
}</code></pre></div>

<p>您可以实现以下内容：</p>
<div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-function">std::string <span class="hljs-title">toString</span> <span class="hljs-params">(std::string_view prefix,</span></span>
<span class="hljs-params"><span class="hljs-function">                      <span class="hljs-type">const</span> std::chrono::system_clock::time_point&amp; tp)</span></span>
<span class="hljs-function"></span>{
    <span class="hljs-keyword">auto</span> rawtime = std::chrono::system_clock::<span class="hljs-built_in">to_time_t</span>(tp);
    std::string_view ts = std::<span class="hljs-built_in">ctime</span>(&amp;rawtime); <span class="hljs-comment">// 注意：不是线程安全的</span>
    ts.<span class="hljs-built_in">remove_suffix</span>(<span class="hljs-number">1</span>); <span class="hljs-comment">// 跳过尾随换行符</span>
    <span class="hljs-keyword">return</span> std::<span class="hljs-built_in">string</span>(prefix) + ts; <span class="hljs-comment">// 不幸的是还没有运算符 +</span>
}</code></pre></div>

<p>除了通过值获取前缀的传递字符串值作为 std::string_view 的优化之外，我们还可以在内部使用字符串视图。 但只是因为 ctime() 返回的 C 字符串在一段时间内有效（直到下一次调用 ctime() 或 asctime() 才有效）。 请注意，我们可以从字符串中删除尾随的换行符，但是我们不能通过简单地调用 operator+ 来连接两个字符串视图。 相反，我们必须将其中一个操作数转换为 std::string （不幸的是，这可能会不必要地分配额外的内存）。</p>
<h4><span id="19-6-hou-ji">19.6 后记</span><a href="#19-6-hou-ji" class="header-anchor">#</a></h4><p>除了通过值获取前缀的传递字符串值作为 std::string_view 的优化之外，我们还可以在内部使用字符串视图。但只是因为ctime()返回的C字符串有一段时间有效（一直有效到下一个有引用语义的字符串类是由Jeffrey Yasskin在<a target="_blank" rel="noopener" href="https://wg21.link/n3334%E6%8F%90%E5%87%BA%E7%9A%84%EF%BC%88%E4%BD%BF%E7%94%A8%E5%90%8D%E7%A7%B0string_ref">https://wg21.link/n3334提出的（使用名称string_ref</a> ). 该课程被 Jeffrey Yasskin 在 <a target="_blank" rel="noopener" href="https://wg21.link/n3921">https://wg21.link/n3921</a> 中提出的图书馆基础知识 TS 中采用。<br>正如 Beman Dawes 和 Alisdair Meredith 在 <a target="_blank" rel="noopener" href="https://wg21.link/p0220r1">https://wg21.link/p0220r1</a> 中提出的，该类与 C++17 的其他组件一起采用。 Marshall Clow 在 <a target="_blank" rel="noopener" href="https://wg21.link/p0254r2">https://wg21.link/p0254r2</a> 和 <a target="_blank" rel="noopener" href="https://wg21.link/p0403r1">https://wg21.link/p0403r1</a> 以及 Nicolai Josuttis 在 <a target="_blank" rel="noopener" href="https://wg21.link/p0392r0">https://wg21.link/p0392r0</a> 中添加了一些用于更好集成的修改。<br>Daniel Krugler 的其他修复在  <a target="_blank" rel="noopener" href="https://wg21.link/lwg2946">https://wg21.link/lwg2946</a> 中（这可能是针对 C++17 的缺陷）。调用 ctime() 或 asctime())。请注意，我们可以从字符串中删除尾随的换行符，但是我们不能通过简单地调用 operator+ 来连接两个字符串视图。相反，我们必须将其中一个操作数转换为 std::string （不幸的是，这可能会不必要地分配额外的内存）。</p>
<h3><span id="20-wen-jian-xi-tong-ku">20 文件系统库</span><a href="#20-wen-jian-xi-tong-ku" class="header-anchor">#</a></h3><p>在C++17中，Boost.filesystem库最终被采纳为C++标准库。通过这样做，该库根据新的语言特性进行了调整，与库的其他部分更加一致，进行了清理，并对一些缺失的部分进行了扩展（比如计算文件系统路径之间相对路径的操作）。</p>
<h4><span id="20-1-ji-ben-li-zi">20.1 基本例子</span><a href="#20-1-ji-ben-li-zi" class="header-anchor">#</a></h4><p>让我们从一些基本的例子开始。</p>
<h5><span id="20-1-1-da-yin-yi-ge-tong-guo-wen-jian-xi-tong-lu-jing-de-shu-xing">20.1.1 打印一个通过文件系统路径的属性</span><a href="#20-1-1-da-yin-yi-ge-tong-guo-wen-jian-xi-tong-lu-jing-de-shu-xing" class="header-anchor">#</a></h5><p>以下程序允许我们使用传递的字符串作为文件系统路径来根据文件类型打印补丁的某些方面：</p>
<p><code>filesystem/checkpath1.cpp</code></p>
<div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;filesystem&gt;</span></span>
<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span>* argv[])</span></span>
<span class="hljs-function"></span>{
    <span class="hljs-keyword">if</span> (argc &lt; <span class="hljs-number">2</span>) {
        std::cout &lt;&lt; <span class="hljs-string">"Usage: "</span> &lt;&lt; argv[<span class="hljs-number">0</span>] &lt;&lt; <span class="hljs-string">" &lt;path&gt; \n"</span>;
        <span class="hljs-keyword">return</span> EXIT_FAILURE;
    }
    std::filesystem::path p{argv[<span class="hljs-number">1</span>]}; <span class="hljs-comment">// p 表示文件系统路径（可能不存在）</span>
    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">is_regular_file</span>(p)) { <span class="hljs-comment">// 路径 p 是常规文件吗？</span>
        std::cout &lt;&lt; p &lt;&lt; <span class="hljs-string">" exists with "</span> &lt;&lt; <span class="hljs-built_in">file_size</span>(p) &lt;&lt; <span class="hljs-string">" bytes\n"</span>;
    }
    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-built_in">is_directory</span>(p)) { <span class="hljs-comment">// 路径 p 是目录吗？</span>
        std::cout &lt;&lt; p &lt;&lt; <span class="hljs-string">" is a directory containing:\n"</span>;
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span>&amp; e : std::filesystem::directory_iterator{p}) {
            std::cout &lt;&lt; <span class="hljs-string">" "</span> &lt;&lt; e.<span class="hljs-built_in">path</span>() &lt;&lt; <span class="hljs-string">'\n'</span>;
        }
    }
    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-built_in">exists</span>(p)) { <span class="hljs-comment">// 路径 p 真的存在吗？</span>
        std::cout &lt;&lt; p &lt;&lt; <span class="hljs-string">" is a special file\n"</span>;
    }
    <span class="hljs-keyword">else</span> {
        std::cout &lt;&lt; <span class="hljs-string">"path "</span> &lt;&lt; p &lt;&lt; <span class="hljs-string">" does not exist\n"</span>;
    }
}</code></pre></div>

<p>我们首先将任何传递的命令行参数转换为文件系统路径：</p>
<div class="code-wrapper"><pre><code class="hljs c++">std::filesystem::path p{argv[<span class="hljs-number">1</span>]}; <span class="hljs-comment">// p 表示文件系统路径（可能不存在）</span>
</code></pre></div>

<p>然后，我们执行以下检查：</p>
<ul>
<li><p>如果路径代表一个现有的常规文件，我们打印它的大小：</p>
<div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">if</span> (<span class="hljs-built_in">is_regular_file</span>(p)) { <span class="hljs-comment">// 路径 p 是普通文件吗?</span>
    std::cout &lt;&lt; p &lt;&lt; <span class="hljs-string">" exists with "</span> &lt;&lt; <span class="hljs-built_in">file_size</span>(p) &lt;&lt; <span class="hljs-string">" bytes\n"</span>;
}
</code></pre></div>

<p>调用这个程序如下：</p>
<div class="code-wrapper"><pre><code class="hljs bash">checkpath checkpath.cpp
</code></pre></div>

<p>将输出如下内容：</p>
<div class="code-wrapper"><pre><code class="hljs bash"><span class="hljs-string">"checkpath.cpp"</span> exists with 907 bytes
</code></pre></div>

<p>请注意，路径的输出运算符会自动写入引用的路径名（在双引号内，反斜杠被另一个反斜杠转义，这是 Windows 路径的一个问题）。</p>
</li>
<li><p>如果文件系统路径作为目录存在，我们遍历目录中的文件并打印路径：</p>
<div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">if</span> (<span class="hljs-built_in">is_directory</span>(p)) { <span class="hljs-comment">// 路径 p 是目录吗?</span>
    std::cout &lt;&lt; p &lt;&lt; <span class="hljs-string">" is a directory containing:\n"</span>;
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span>&amp; e : std::filesystem::<span class="hljs-built_in">directory_iterator</span>(p)) {
        std::cout &lt;&lt; <span class="hljs-string">" "</span> &lt;&lt; e.<span class="hljs-built_in">path</span>() &lt;&lt; <span class="hljs-string">'\n'</span>;
    }
}
</code></pre></div></li>
</ul>
<p>这里我们使用了 directory_iterator，它提供了 begin() 和 end()，我们可以使用基于范围的 for 循环遍历 directory_entry 元素。 在这种情况下，我们使用 directory_entry 成员函数 path()，它产生条目的文件系统路径。<br>调用这个程序如下：</p>
<div class="code-wrapper"><pre><code class="hljs bash">checkpath .
</code></pre></div>

<p>将输出如下内容：</p>
<div class="code-wrapper"><pre><code class="hljs bash"><span class="hljs-string">"."</span> is a directory containing:
<span class="hljs-string">"./checkpath.cpp"</span>
<span class="hljs-string">"./checkpath.exe"</span>
...</code></pre></div>

<ul>
<li><p>最后，我们检查传递的文件系统路径是否存在：</p>
<div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">if</span> (!<span class="hljs-built_in">exists</span>(p)) { <span class="hljs-comment">// 路径 p 真的存在吗?</span>
    ...
}</code></pre></div></li>
</ul>
<h6><span id="windows-xia-de-lu-jing-chu-li">Windows下的路径处理</span><a href="#windows-xia-de-lu-jing-chu-li" class="header-anchor">#</a></h6><p>在 Windows 下，默认情况下路径被引用的事实是一个问题，因为通常的目录分隔符反斜杠总是被转义并写入两次。 因此，在 Windows 下调用该程序如下：</p>
<div class="code-wrapper"><pre><code class="hljs bash">checkpath C:\</code></pre></div>

<p>将输出如下内容：</p>
<div class="code-wrapper"><pre><code class="hljs bash"><span class="hljs-string">"C:\\"</span> is a directory containing:
...
<span class="hljs-string">"C:\\Users"</span>
<span class="hljs-string">"C:\\Windows"</span></code></pre></div>

<p>写入引用的路径可确保写入的文件名可以读入程序，以便您取回原始文件名。 但是，对于标准输出，这通常是不可接受的。</p>
<p>出于这个原因，在 Windows 下运行良好的可移植版本应该避免使用成员函数 string() 将引用的路径写入标准输出：</p>
<p><code>filesystem/checkpath2.cpp </code></p>
<div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;filesystem&gt;</span></span>
<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span>* argv[])</span></span>
<span class="hljs-function"></span>{
    <span class="hljs-keyword">if</span> (argc &lt; <span class="hljs-number">2</span>) {
        std::cout &lt;&lt; <span class="hljs-string">"Usage: "</span> &lt;&lt; argv[<span class="hljs-number">0</span>] &lt;&lt; <span class="hljs-string">" &lt;path&gt; \n"</span>;
        <span class="hljs-keyword">return</span> EXIT_FAILURE;
    }
    std::filesystem::path p{argv[<span class="hljs-number">1</span>]}; <span class="hljs-comment">// p 表示文件系统路径（可能不存在）</span>
    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">is_regular_file</span>(p)) { <span class="hljs-comment">// 路径 p 是普通文件吗?</span>
        std::cout &lt;&lt; <span class="hljs-string">'"'</span> &lt;&lt; p &lt;&lt; <span class="hljs-string">"\" exists with "</span> &lt;&lt; <span class="hljs-built_in">file_size</span>(p) &lt;&lt; <span class="hljs-string">" bytes\n"</span>;
    }
    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-built_in">is_directory</span>(p)) { <span class="hljs-comment">// 路径 p 是目录吗?</span>
        std::cout &lt;&lt; <span class="hljs-string">'"'</span> &lt;&lt; p &lt;&lt; <span class="hljs-string">"\" is a directory containing:\n"</span>;
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span>&amp; e : std::filesystem::directory_iterator{p}) {
            std::cout &lt;&lt; <span class="hljs-string">" \""</span> &lt;&lt; e.<span class="hljs-built_in">path</span>().<span class="hljs-built_in">string</span>() &lt;&lt; <span class="hljs-string">"\"\n"</span>;
        }
    }
    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-built_in">exists</span>(p)) { <span class="hljs-comment">// 路径 p 真的存在吗?</span>
        std::cout &lt;&lt; <span class="hljs-string">'"'</span> &lt;&lt; p &lt;&lt; <span class="hljs-string">"\" is a special file\n"</span>;
    }
    <span class="hljs-keyword">else</span> {
        std::cout &lt;&lt; <span class="hljs-string">"path \""</span> &lt;&lt; p &lt;&lt; <span class="hljs-string">"\" does not exist\n"</span>;
    }
}</code></pre></div>

<p>现在，在 Windows 下调用这个程序如下：</p>
<div class="code-wrapper"><pre><code class="hljs bash">checkpath C:\</code></pre></div>

<p>将输出如下内容：</p>
<div class="code-wrapper"><pre><code class="hljs bash"><span class="hljs-string">"C:\" is a directory containing:</span>
<span class="hljs-string">...</span>
<span class="hljs-string">"</span>C:\Users<span class="hljs-string">"</span>
<span class="hljs-string">"</span>C:\Windows<span class="hljs-string">"</span></code></pre></div>

<p>提供了其他转换以使用通用字符串格式或将字符串转换为本机编码。</p>
<h5><span id="20-1-2-qie-huan-wen-jian-xi-tong-lei-xing">20.1.2 切换文件系统类型</span><a href="#20-1-2-qie-huan-wen-jian-xi-tong-lei-xing" class="header-anchor">#</a></h5><p>我们仍然可以对之前的程序进行一些修改和改进，如下所示：</p>
<p><code>filesystem/checkpath3.cpp</code></p>
<div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;filesystem&gt;</span></span>
<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span>* argv[])</span></span>
<span class="hljs-function"></span>{
    <span class="hljs-keyword">if</span> (argc &lt; <span class="hljs-number">2</span>) {
        std::cout &lt;&lt; <span class="hljs-string">"Usage: "</span> &lt;&lt; argv[<span class="hljs-number">0</span>] &lt;&lt; <span class="hljs-string">" &lt;path&gt; \n"</span>;
        <span class="hljs-keyword">return</span> EXIT_FAILURE;
    }
    <span class="hljs-keyword">namespace</span> fs = std::filesystem;
    <span class="hljs-keyword">switch</span> (fs::path p{argv[<span class="hljs-number">1</span>]}; <span class="hljs-built_in">status</span>(p).<span class="hljs-built_in">type</span>()) {
        <span class="hljs-keyword">case</span> fs::file_type::not_found:
            std::cout &lt;&lt; <span class="hljs-string">"path \""</span> &lt;&lt; p.<span class="hljs-built_in">string</span>() &lt;&lt; <span class="hljs-string">"\" does not exist\n"</span>;
            <span class="hljs-keyword">break</span>;
        <span class="hljs-keyword">case</span> fs::file_type::regular:
            std::cout &lt;&lt; <span class="hljs-string">'"'</span> &lt;&lt; p.<span class="hljs-built_in">string</span>() &lt;&lt; <span class="hljs-string">"\" exists with "</span>
                &lt;&lt; <span class="hljs-built_in">file_size</span>(p) &lt;&lt; <span class="hljs-string">" bytes\n"</span>;
            <span class="hljs-keyword">break</span>;
        <span class="hljs-keyword">case</span> fs::file_type::directory:
            std::cout &lt;&lt; <span class="hljs-string">'"'</span> &lt;&lt; p.<span class="hljs-built_in">string</span>() &lt;&lt; <span class="hljs-string">"\" is a directory containing:\n"</span>;
            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span>&amp; e : std::filesystem::directory_iterator{p}) {
                std::cout &lt;&lt; <span class="hljs-string">" "</span> &lt;&lt; e.<span class="hljs-built_in">path</span>().<span class="hljs-built_in">string</span>() &lt;&lt; <span class="hljs-string">'\n'</span>;
            }
            <span class="hljs-keyword">break</span>;
        <span class="hljs-keyword">default</span>:
            std::cout &lt;&lt; <span class="hljs-string">'"'</span> &lt;&lt; p.<span class="hljs-built_in">string</span>() &lt;&lt; <span class="hljs-string">"\" is a special file\n"</span>;
            <span class="hljs-keyword">break</span>;
    }
}</code></pre></div>

<h6><span id="ming-ming-kong-jian-fs">命名空间 fs</span><a href="#ming-ming-kong-jian-fs" class="header-anchor">#</a></h6><p>首先，我们做一些非常常见的事情：将 fs 定义为命名空间 std::filesystem 的快捷方式：</p>
<div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">namespace</span> fs = std::filesystem;</code></pre></div>

<p>使用这个命名空间，我们初始化，例如，switch 语句中的路径 p：</p>
<div class="code-wrapper"><pre><code class="hljs c++">fs::path p{argv[<span class="hljs-number">1</span>]};</code></pre></div>

<p>switch 语句是带有初始化的新 switch 的应用，我们在其中初始化路径并为其类型提供不同的情况：</p>
<div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">switch</span> (fs::path p{argv[<span class="hljs-number">1</span>]}; <span class="hljs-built_in">status</span>(p).<span class="hljs-built_in">type</span>()) {
        ...
}</code></pre></div>

<p>表达式 status(p).type() 创建一个 file_status，type() 为此创建一个 file_type。 这样我们就可以直接处理不同的类型，而不是像 is_regular_file()、is_directory() 等一连串的调用。 提供类型是在多个步骤中有意提供的，这样如果我们对状态信息不感兴趣，我们就不必支付操作系统调用的代价。</p>
<p>另请注意，特定于实现的 file_type 可能存在。 例如，Windows 提供了特殊的文件类型连接。 但是使用它不是便携式的。</p>
<h5><span id="20-1-3-chuang-jian-bu-tong-lei-xing-de-wen-jian">20.1.3 创建不同类型的文件</span><a href="#20-1-3-chuang-jian-bu-tong-lei-xing-de-wen-jian" class="header-anchor">#</a></h5><p>在仅对文件系统进行读取访问之后，现在让我们给出第一个修改它的示例。 以下程序在子目录 tmp 中创建不同类型的文件：</p>
<p><code>filesystem/createfiles.cpp </code></p>
<div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;fstream&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;filesystem&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstdlib&gt;</span></span>
<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span> <span class="hljs-params">()</span></span>
<span class="hljs-function"></span>{
    <span class="hljs-keyword">namespace</span> fs = std::filesystem;
    <span class="hljs-keyword">try</span> {
        <span class="hljs-comment">// 创建目录 tmp/test/（如果它们还不存在）:</span>
        fs::path testDir{<span class="hljs-string">"tmp/test"</span>};
        <span class="hljs-built_in">create_directories</span>(testDir);
        <span class="hljs-comment">// 创建数据文件 tmp/test/data.txt:</span>
        <span class="hljs-keyword">auto</span> testFile = testDir / <span class="hljs-string">"data.txt"</span>;
        std::ofstream dataFile{testFile};
        <span class="hljs-keyword">if</span> (!dataFile) {
            std::cerr &lt;&lt; <span class="hljs-string">"OOPS, can't open \""</span> &lt;&lt; testFile.<span class="hljs-built_in">string</span>() &lt;&lt; <span class="hljs-string">"\"\n"</span>;
            std::<span class="hljs-built_in">exit</span>(EXIT_FAILURE); <span class="hljs-comment">// 退出程序失败</span>
        }
        dataFile &lt;&lt; <span class="hljs-string">"The answer is 42\n"</span>;
        <span class="hljs-comment">// 创建从 tmp/slink/ 到 tmp/test/ 的符号链接:</span>
        <span class="hljs-built_in">create_directory_symlink</span>(<span class="hljs-string">"test"</span>, testDir.<span class="hljs-built_in">parent_path</span>() / <span class="hljs-string">"slink"</span>);
        <span class="hljs-comment">// 递归列出所有文件（也遵循符号链接）</span>
        std::cout &lt;&lt; fs::<span class="hljs-built_in">current_path</span>().<span class="hljs-built_in">string</span>() &lt;&lt; <span class="hljs-string">":\n"</span>;
        <span class="hljs-keyword">auto</span> iterOpts{fs::directory_options::follow_directory_symlink};
        <span class="hljs-keyword">for</span> (<span class="hljs-type">const</span> <span class="hljs-keyword">auto</span>&amp; e : fs::<span class="hljs-built_in">recursive_directory_iterator</span>(<span class="hljs-string">"."</span>, iterOpts)) {
            std::cout &lt;&lt; <span class="hljs-string">" "</span> &lt;&lt; e.<span class="hljs-built_in">path</span>().<span class="hljs-built_in">lexically_normal</span>().<span class="hljs-built_in">string</span>() &lt;&lt; <span class="hljs-string">'\n'</span>;
        }
    }
    <span class="hljs-built_in">catch</span> (fs::filesystem_error&amp; e) {
        std::cerr &lt;&lt; <span class="hljs-string">"EXCEPTION: "</span> &lt;&lt; e.<span class="hljs-built_in">what</span>() &lt;&lt; <span class="hljs-string">'\n'</span>;
        std::cerr &lt;&lt; <span class="hljs-string">" path1: \""</span> &lt;&lt; e.<span class="hljs-built_in">path1</span>().<span class="hljs-built_in">string</span>() &lt;&lt; <span class="hljs-string">"\"\n"</span>;
    }
}</code></pre></div>

<p>让我们一步一步地完成这个程序。</p>
<h6><span id="ming-ming-kong-jian-fs">命名空间 fs</span><a href="#ming-ming-kong-jian-fs" class="header-anchor">#</a></h6><p>首先，我们做一些非常常见的事情：将 fs 定义为命名空间 std::filesystem 的快捷方式：</p>
<div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">namespace</span> fs = std::filesystem;</code></pre></div>

<p>例如，我们使用这个命名空间初始化临时文件的基本子目录的路径：</p>
<div class="code-wrapper"><pre><code class="hljs c++">fs::path testDir{<span class="hljs-string">"tmp/test"</span>};
</code></pre></div>

<h6><span id="chuang-jian-mu-lu">创建目录</span><a href="#chuang-jian-mu-lu" class="header-anchor">#</a></h6><p>然后我们尝试创建子目录：</p>
<div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-built_in">create_directories</span>(testDir);
</code></pre></div>

<p>通过使用 create_directories() 我们创建整个传递路径的所有缺失目录（还有 create_directory() 仅在现有目录内创建目录）。</p>
<p>如果目录已经存在，则执行此调用不是错误。 但是，任何其他问题都是错误并引发相应的异常。</p>
<p>如果 testDir 已经存在，create_directories() 返回 false。 因此，您也可以调用：</p>
<div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">if</span> (!<span class="hljs-built_in">create_directories</span>(testDir)) {
    std::cout &lt;&lt; <span class="hljs-string">"\""</span> &lt;&lt; testDir.<span class="hljs-built_in">string</span>() &lt;&lt; <span class="hljs-string">"\" already exists\n"</span>;
}</code></pre></div>

<p>但是，请注意，如果 testDir 存在但不是目录，这也不是错误。 因此，返回 true 并不意味着在调用之后有一个具有请求名称的目录。 我们可以检查一下，但在这种情况下，这是间接涉及的，因为下一次在目录中创建文件的调用将失败。 但是，错误消息可能会令人困惑。 为了获得更好的错误消息，您可能需要检查之后是否真的存在目录。</p>
<h6><span id="chuang-jian-chang-gui-wen-jian">创建常规文件</span><a href="#chuang-jian-chang-gui-wen-jian" class="header-anchor">#</a></h6><p>然后我们创建一个包含一些内容的新文件 /tmp/test/data.txt：</p>
<div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">auto</span> testFile = testDir / <span class="hljs-string">"data.txt"</span>;
<span class="hljs-function">std::ofstream <span class="hljs-title">dataFile</span><span class="hljs-params">(testFile)</span></span>;
<span class="hljs-keyword">if</span> (!dataFile) {
    std::cerr &lt;&lt; <span class="hljs-string">"OOPS, can't open \""</span> &lt;&lt; testFile.<span class="hljs-built_in">string</span>() &lt;&lt; <span class="hljs-string">"\"\n"</span>;
    std::<span class="hljs-built_in">exit</span>(EXIT_FAILURE); <span class="hljs-comment">// 退出程序失败</span>
}
dataFile &lt;&lt; <span class="hljs-string">"The answer is 42\n"</span>;</code></pre></div>

<p>这里我们使用运算符 / 来扩展路径，然后我们将其作为参数传递给文件流的构造函数。 如您所见，常规文件的创建仍然只能使用现有的 I/O 流库来完成。 但是，为构造函数提供了一个新的重载，以便能够直接传递文件系统路径。<br>请注意，您仍应始终检查创建/打开文件是否成功。 很多事情都可能在这里出错（见下文）。</p>
<h6><span id="chuang-jian-fu-hao-lian-jie">创建符号链接</span><a href="#chuang-jian-fu-hao-lian-jie" class="header-anchor">#</a></h6><p>下一条语句尝试创建一个引用目录 tmp/test 的符号链接 tmp/slink：</p>
<div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-built_in">create_directory_symlink</span>(<span class="hljs-string">"test"</span>, testDir.<span class="hljs-built_in">parent_path</span>() / <span class="hljs-string">"slink"</span>);</code></pre></div>

<p>请注意，第一个参数定义了创建链接视图的路径。 因此，您必须通过“test”而不是“tmp/test”才能有效地从 tmp/slink 链接到 tmp/test。 如果你调用：</p>
<div class="code-wrapper"><pre><code class="hljs c++">std::filesystem::<span class="hljs-built_in">create_directory_symlink</span>(<span class="hljs-string">"tmp/test"</span>, <span class="hljs-string">"tmp/slink"</span>);
</code></pre></div>

<p>您将有效地创建 tmp/slink 作为指向 tmp/tmp/test 的符号链接。</p>
<p>请注意，通常调用 create_symlink() 而不是 create_directory_symlink() 也可以，但是某些操作系统对目录的符号链接有特殊处理，或者当它们知道文件是目录时执行得更好，因此如果您应该使用 create_directory_symlink() 知道符号链接是指一个目录。</p>
<h6><span id="mu-lu-di-gui">目录递归</span><a href="#mu-lu-di-gui" class="header-anchor">#</a></h6><p>最后，我们递归地列出当前目录：</p>
<div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">auto</span> iterOpts = fs::directory_options::follow_directory_symlink;
<span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span>&amp; e : fs::<span class="hljs-built_in">recursive_directory_iterator</span>(<span class="hljs-string">"."</span>, iterOpts)) {
    std::cout &lt;&lt; <span class="hljs-string">" "</span> &lt;&lt; e.<span class="hljs-built_in">path</span>().<span class="hljs-built_in">lexically_normal</span>().<span class="hljs-built_in">string</span>() &lt;&lt; <span class="hljs-string">'\n'</span>;
}
</code></pre></div>

<p>因为我们使用递归目录迭代器并传递选项以跟随符号链接，follow_directory_symlink，我们应该在基于 POSIX 的系统上获得如下输出：</p>
<div class="code-wrapper"><pre><code class="hljs bash"><span class="hljs-comment"># /home/nico:</span>
...
tmp
tmp/slink
tmp/slink/data.txt
tmp/test
tmp/test/data.txt
...
</code></pre></div>

<p>在 Windows 系统上的输出如下所示：</p>
<div class="code-wrapper"><pre><code class="hljs bash"><span class="hljs-comment"># C:/Users/nico:</span>
...
tmp
tmp\slink
tmp\slink\data.txt
tmp\<span class="hljs-built_in">test</span>
tmp\<span class="hljs-built_in">test</span>\data.txt
...
</code></pre></div>

<p>请注意，我们在打印所有目录条目的路径时使用 lexically_normal()。 如果我们跳过它，目录条目的路径将包含一个带有初始化迭代器的目录的前缀。 因此，只打印循环内的路径：</p>
<div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">auto</span> iterOpts = fs::directory_options::follow_directory_symlink;
<span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span>&amp; e : fs::<span class="hljs-built_in">recursive_directory_iterator</span>(<span class="hljs-string">"."</span>, iterOpts)) {
    std::cout &lt;&lt; <span class="hljs-string">" "</span> &lt;&lt; e.<span class="hljs-built_in">path</span>() &lt;&lt; <span class="hljs-string">'\n'</span>;
}
</code></pre></div>

<p>将在基于 POSIX 的系统下输出：</p>
<div class="code-wrapper"><pre><code class="hljs bash"><span class="hljs-comment"># all files:</span>
...
<span class="hljs-string">"./testdir"</span>
<span class="hljs-string">"./testdir/data.txt"</span>
<span class="hljs-string">"./tmp"</span>
<span class="hljs-string">"./tmp/test"</span>
<span class="hljs-string">"./tmp/test/data.txt"</span></code></pre></div>

<p>在 Windows 上，输出将是：</p>
<div class="code-wrapper"><pre><code class="hljs bash"><span class="hljs-comment"># all files:</span>
...
<span class="hljs-string">".\\testdir"</span>
<span class="hljs-string">".\\testdir\\data.txt"</span>
<span class="hljs-string">".\\tmp"</span>
<span class="hljs-string">".\\tmp\\test"</span>
<span class="hljs-string">".\\tmp\\test\\data.txt"</span></code></pre></div>

<p>因此，通过调用 lexically_normal() 我们产生了规范化的路径，它确实删除了当前目录的前导点。 如前所述，通过调用 string() 我们避免了每个路径都被引用，这对于基于 POSIX 的系统来说是可以的（只是将名称放在双引号中），但在 Windows 系统上看起来非常令人惊讶（因为每个反斜杠 被另一个反斜杠转义）。</p>
<h6><span id="cuo-wu-chu-li">错误处理</span><a href="#cuo-wu-chu-li" class="header-anchor">#</a></h6><p>文件系统是麻烦的根源。 由于使用了错误的字符、没有必要的权限或其他进程可能会在您处理文件系统时修改文件系统，您可能无法执行操作。 因此，根据平台和权限，该程序可能会出现一些问题。</p>
<p>对于那些没有被返回值覆盖的情况（这里是目录已经存在的情况），我们捕获相应的异常并打印一般消息和其中的第一个路径：</p>
<div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">try</span> {
    ...
}
<span class="hljs-built_in">catch</span> (fs::filesystem_error&amp; e) {
    std::cerr &lt;&lt; <span class="hljs-string">"EXCEPTION: "</span> &lt;&lt; e.<span class="hljs-built_in">what</span>() &lt;&lt; <span class="hljs-string">'\n'</span>;
    std::cerr &lt;&lt; <span class="hljs-string">" path1: \""</span> &lt;&lt; e.<span class="hljs-built_in">path1</span>().<span class="hljs-built_in">string</span>() &lt;&lt; <span class="hljs-string">"\"\n"</span>;
}</code></pre></div>

<p>例如，如果我们无法创建目录，则可能会打印出如下消息：</p>
<div class="code-wrapper"><pre><code class="hljs bash">EXCEPTION: filesystem error: cannot create directory: [tmp/test]
path1: <span class="hljs-string">"tmp/test"</span>
</code></pre></div>

<p>或者，如果我们无法创建符号链接，例如因为它已经存在，您会收到类似以下消息：</p>
<div class="code-wrapper"><pre><code class="hljs bash">EXCEPTION: create_directory_symlink: Can’t create a file when it already
exists: <span class="hljs-string">"tmp\test\data.txt"</span>, <span class="hljs-string">"testdir"</span>
path1: <span class="hljs-string">"tmp\test\data.txt"</span>
</code></pre></div>

<p>如前所述，当目录已经作为常规文件存在时，在目录中创建新文件的尝试将失败。因此，不要忘记检查打开文件的状态。默认情况下，用于读取和写入常规文件的 I/O Stream 库不会将错误作为异常处理。</p>
<p>无论如何请注意，多用户/多进程操作系统中的情况随时可能发生变化。因此，您创建的目录甚至可能在您创建后被删除、重命名或替换为常规文件。因此，根本不可能通过找出当前情况来确保未来请求的有效性。出于这个原因，它通常是尝试做你想做的事情（即创建目录、打开文件）并处理异常和错误或验证检查预期行为的最佳方法。</p>
<p>但是，有时尝试对文件系统做一些事情可能会奏效，但不是您想的那样。例如，如果您想在特定目录中创建文件并且已经存在指向另一个目录的符号链接，则该文件会在意外位置创建或覆盖。这可能没问题（用户可能有充分的理由在预期目录的位置创建符号链接）。但是，如果您想检测这种情况，则必须在创建文件之前检查文件是否存在（这比您最初想象的要复杂一些）。</p>
<p>但同样：不能保证文件系统检查的结果在您处理它们时仍然有效。</p>
<h5><span id="20-1-4-shi-yong-bing-xing-suan-fa-chu-li-wen-jian-xi-tong-de-wen-ti">20.1.4 使用并行算法处理文件系统的问题</span><a href="#20-1-4-shi-yong-bing-xing-suan-fa-chu-li-wen-jian-xi-tong-de-wen-ti" class="header-anchor">#</a></h5><p>有关使用并行算法累积目录树中所有常规文件大小的另一个示例，请参见 dirsize.cpp。</p>
<h4><span id="20-2-yuan-ze-he-zhu-yu">20.2 原则和术语</span><a href="#20-2-yuan-ze-he-zhu-yu" class="header-anchor">#</a></h4><p>在讨论文件系统库的细节之前，我们必须介绍一些设计原则和术语。 这是必要的，因为该标准涵盖了不同的操作系统并将它们映射到一个通用 API。</p>
<h5><span id="20-2-1-yi-ban-ke-yi-zhi-xing-sheng-ming">20.2.1 一般可移植性声明</span><a href="#20-2-1-yi-ban-ke-yi-zhi-xing-sheng-ming" class="header-anchor">#</a></h5><p>C++ 标准不仅标准化了所有可能的操作系统对其文件系统的共同点。 在许多情况下，它遵循 POSIX 标准，而 C++ 标准要求尽可能地遵循 POSIX。 只要它是合理的，行为应该仍然存在，但有一些限制。 如果不可能有合理的行为，则实现应报告错误。<br>此类错误的可能示例是：</p>
<ul>
<li>字符用于不支持的文件名</li>
<li>创建了不受支持的文件系统元素（例如，符号链接） 特定文件系统的差异仍然可能很重要：</li>
<li>区分大小写：<br>“hello.txt”和“Hello.txt”和“hello.TXT”可能指同一个（Windows）或三个不同的文件（基于POSIX）。</li>
<li>绝对路径与相对路径：<br>在某些系统上，“/bin”是绝对路径（基于 POSIX），而在其他系统上则不是（Windows）。</li>
</ul>
<h5><span id="20-2-2-ming-ming-kong-jian">20.2.2 命名空间</span><a href="#20-2-2-ming-ming-kong-jian" class="header-anchor">#</a></h5><p>文件系统库在 std 中有自己的子命名空间文件系统。 为其引入快捷方式 fs 是一个非常常见的约定：</p>
<div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">namespace</span> fs = std::filesystem;
</code></pre></div>

<p>例如，这允许使用 fs::current_path() 而不是 std::filesystem::current_path()。<br>本章的进一步代码示例通常会使用 fs 作为相应的快捷方式。<br>请注意，不限定文件系统调用有时会导致意外行为。</p>
<h5><span id="20-2-3-lu-jing">20.2.3 路径</span><a href="#20-2-3-lu-jing" class="header-anchor">#</a></h5><p>文件系统库的关键元素是路径。它是一个名称，表示文件系统中文件的（潜在）位置。它由一个可选的根名称、一个可选的根目录和一系列由目录分隔符分隔的文件名组成。路径可以是相对的（因此文件位置取决于当前工作目录）或绝对的。<br>不同的格式是可能的：</p>
<ul>
<li><p>通用格式，可移植</p>
</li>
<li><p>一种原生格式，特定于底层文件系统<br>在基于 POSIX 的操作系统上，通用格式和本机格式之间没有区别。<br>在 Windows 上，通用格式 /tmp/test.txt 是除 \tmp\test.txt 之外的有效原生格式，它也受支持（因此，/tmp/test.txt 和 \tmp\test.txt 是相同的路径）。在 OpenVMS 上，相应的原生格式可能是 [tmp]test.txt。<br>存在特殊文件名：</p>
</li>
<li><p>“.”代表当前目录</p>
</li>
<li><p>“..” 代表父目录<br>通用路径格式如下：</p>
<div class="code-wrapper"><pre><code class="hljs bash">[rootname] [rootdir] [relativepath]</code></pre></div></li>
</ul>
<p> 在哪里：</p>
<ul>
<li>可选的根名称是特定于实现的（例如，在 POSIX 系统上可以是 //host，在 Windows 系统上可以是 C:）</li>
<li>可选的根目录是目录分隔符</li>
<li>相对路径是由目录分隔符分隔的一系列文件名</li>
</ul>
<p>根据定义，目录分隔符由一个或多个“/”或特定于实现的首选目录分隔符组成。</p>
<p>可移植通用路径的示例是：</p>
<div class="code-wrapper"><pre><code class="hljs bash">//host1/bin/hello.txt
.
tmp/
/a/b//../c</code></pre></div>

<p>请注意，最后一个路径与 /a/c 指向相同的位置，并且在 POSIX 系统上是绝对的，但在 Windows 系统上是相对的（因为缺少驱动器/分区）。</p>
<p>另一方面，诸如 C:/bin 之类的路径在 Windows 系统上是绝对路径（“C”驱动器/分区上的根目录“bin”），但在 POSIX 上是相对路径（目录中的子目录“bin”） “C：”）。</p>
<p>在 Windows 系统上，反斜杠是实现特定的目录分隔符，因此上面的路径也可以通过使用反斜杠作为首选目录分隔符来编写：</p>
<div class="code-wrapper"><pre><code class="hljs bash">\\host1\bin\hello.txt
.
tmp\
\a\b\..\c</code></pre></div>

<p>文件系统库提供了在本地格式和通用格式之间转换路径的功能。<br>路径可能是空的。 这意味着没有定义路径。 这不一定与“.”相同。 它的含义取决于上下文。</p>
<h5><span id="20-2-4-gui-fan-hua">20.2.4 规范化</span><a href="#20-2-4-gui-fan-hua" class="header-anchor">#</a></h5><p>路径可能已经或可以被规范化。 在规范化路径中：</p>
<ul>
<li>文件名仅由一个首选目录分隔符分隔。</li>
<li>文件名“.”除非整个路径只是“.”，否则不使用。 （代表当前目录）。</li>
<li>文件名不包含“..”文件名（我们不会先向下然后再向上），除非它们位于相对路径的开头。</li>
<li>如果尾部的文件名是一个名称不是”… “或”… “的目录，路径才以目录分隔符结束。</li>
</ul>
<p>请注意，规范化仍然意味着以目录分隔符结尾的文件名与不以分隔符结尾的文件名不同。原因是在某些操作系统上，当知道路径是目录时，行为会有所不同（例如，带有尾随分隔符的符号链接可能会被解析）。</p>
<p>路径规范化的表效果列出了一些在 POSIX 和 Windows 系统上进行规范化的示例。再次注意，在 POSIX 系统上，C:bar 和 C: are 只是文件名，并没有像在 Windows 上那样指定分区的特殊含义。</p>
<table>
<thead>
<tr>
<th>路径</th>
<th>POSIX 标准化</th>
<th>windows 标准化</th>
</tr>
</thead>
<tbody><tr>
<td>foo/.///bar/../</td>
<td>foo/</td>
<td>foo\</td>
</tr>
<tr>
<td>//host/../foo.txt</td>
<td>//host/foo.txt</td>
<td>\host\foo.txt</td>
</tr>
<tr>
<td>./f/../.f/</td>
<td>.f/</td>
<td>.f\</td>
</tr>
<tr>
<td>C:bar/../</td>
<td>.</td>
<td>C:</td>
</tr>
<tr>
<td>C:/bar/..</td>
<td>C:/</td>
<td>C:\</td>
</tr>
<tr>
<td>C:\bar..</td>
<td>C:\bar..</td>
<td>C:\</td>
</tr>
<tr>
<td>/./../data.txt</td>
<td>/data.txt</td>
<td>\data.txt</td>
</tr>
<tr>
<td>././</td>
<td>.</td>
<td>.</td>
</tr>
</tbody></table>
<p>请注意，在基于POSIX的系统上进行规范化处理时，路径C:\bar...保持不变。原因是在那里反斜杠不是目录分隔符，所以整个路径只是一个文件名，其中有一个冒号、两个反斜杠和两个点作为其名称的一部分。<br>文件系统为词法规范化（不考虑文件系统）和依赖文件系统的规范化都提供了功能。</p>
<h5><span id="20-2-5-cheng-yuan-han-shu-yu-du-li-de-han-shu">20.2.5 成员函数与独立的函数</span><a href="#20-2-5-cheng-yuan-han-shu-yu-du-li-de-han-shu" class="header-anchor">#</a></h5><p>文件系统库提供了几个函数，它们既可以是成员函数也可以是独立函数。一般的做法是：</p>
<ul>
<li><p>成员函数很便宜。原因是它们是纯词法操作，不考虑实际的文件系统，所以不需要调用操作系统。</p>
<p>例如：</p>
<div class="code-wrapper"><pre><code class="hljs c++">mypath.<span class="hljs-built_in">is_absolute</span>() <span class="hljs-comment">// 检查路径是绝对的还是相对的</span></code></pre></div>
</li>
<li><p>独立的函数是昂贵的，因为它们通常考虑到实际的文件系统，所以不需要调用操作系统。</p>
<p>例子：</p>
<div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-built_in">equivalent</span>(path1, path2); <span class="hljs-comment">// 如果两个路径都指向同一个文件，则为true</span></code></pre></div></li>
</ul>
<p>有时，文件系统库甚至提供了相同的功能，既在词法上操作，又考虑到了实际的文件系统。</p>
<div class="code-wrapper"><pre><code class="hljs c++">std::filesystem::path fromP, toP;
...
toP.<span class="hljs-built_in">lexically_relative</span>(fromP); <span class="hljs-comment">// 产生从 fromP 到 toP 的词法路径</span>
<span class="hljs-built_in">relative</span>(toP, fromP); <span class="hljs-comment">// 产生从 fromP 到 toP 的实际路径</span></code></pre></div>

<p>由于参数依赖性查找（ADL），在调用独立的文件系统函数和一个参数具有文件系统的特定类型时，你通常不需要指定完整的命名空间std::filesystem。只有在使用其他类型的隐式转换时，你才需要限定 调用。比如说:</p>
<div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-built_in">create_directory</span>(std::filesystem::path{<span class="hljs-string">"tmpdir"</span>}); <span class="hljs-comment">// OK</span>
<span class="hljs-built_in">remove</span>(std::filesystem::path{<span class="hljs-string">"tmpdir"</span>}); <span class="hljs-comment">// OK</span>
std::filesystem::<span class="hljs-built_in">create_directory</span>(<span class="hljs-string">"tmpdir"</span>); <span class="hljs-comment">// OK</span>
std::filesystem::<span class="hljs-built_in">remove</span>(<span class="hljs-string">"tmpdir"</span>); <span class="hljs-comment">// OK</span>
<span class="hljs-built_in">create_directory</span>(<span class="hljs-string">"tmpdir"</span>); <span class="hljs-comment">// ERROR</span>
<span class="hljs-built_in">remove</span>(<span class="hljs-string">"tmpdir"</span>); <span class="hljs-comment">// OOPS: 调用 C 函数 remove()</span></code></pre></div>

<p>请注意，最后一个调用通常会编译，但会找到C函数remove()，它也会删除一个指定的文件，但在Windows下不会删除空目录。</p>
<h5><span id="20-2-6-cuo-wu-chu-li">20.2.6 错误处理</span><a href="#20-2-6-cuo-wu-chu-li" class="header-anchor">#</a></h5><p>正如第二个例子所讨论的，文件系统是一个错误的来源。你必须考虑到必要的文件可能不存在，文件操作不被允许，或者操作违反了资源限制。此外，当程序运行时，其他进程可能会创建、修改或删除文件，因此，即使提前检查也不能保证没有错误。</p>
<p>问题是，原则上你无法确保下一个文件系统操作会成功。任何检查的结果在你处理它时可能不再有效。因此，通常最好的方法是执行一个或多个文件系统操作，并处理由此产生的异常或错误。</p>
<p>还要注意的是，当用普通文件进行读写时，I/O流库默认不会抛出错误。它将任何操作转换为无操作。因此，我们建议至少检查一下文件是否能成功打开。</p>
<p>因为处理异常并不总是合适的（比如当你想直接对一个失败的文件系统调用做出反应时），文件系统库在处理以下问题时使用了混合方法 文件系统时，采用混合方法:</p>
<ul>
<li>默认情况下，文件系统错误被作为异常处理。</li>
<li>但是，如果你有或者想要，你可以在本地处理特定的错误。<br>这是通过文件系统操作实现的，通常每个操作都有两个重载。</li>
</ul>
<ol>
<li>默认情况下（没有额外的错误处理参数），操作在出错时抛出一个filesystem_error异常。</li>
<li>通过传递一个额外的输出参数，你可以在出错时得到一个错误代码。<br>请注意，在后一种情况下，你可能仍然有特殊的返回值，标志着一个特定的错误没有被作为异常处理。</li>
</ol>
<h6><span id="shi-yong-filesystem-error-yi-chang">使用 filesystem_error 异常</span><a href="#shi-yong-filesystem-error-yi-chang" class="header-anchor">#</a></h6><p>例如，你可以尝试创建一个目录，如下所示:</p>
<div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">if</span> (!<span class="hljs-built_in">create_directory</span>(p)) { <span class="hljs-comment">// 错误异常（除非路径存在）</span>
    std::cout &lt;&lt; p &lt;&lt; <span class="hljs-string">" already exists\n"</span>; <span class="hljs-comment">// 路径存在</span>
}</code></pre></div>

<p>这里，没有传递错误代码参数，所以错误通常会引发一个异常。但是请注意，路径已经存在的特殊情况（是否是一个目录并不重要），将通过返回false来处理。因此，一个异常是由于其他问题引起的，比如缺少创建目录的权限，无效的路径p，或者违反文件系统资源（比如超过路径长度<br>限制）。<br>像这样的代码应该直接或间接地包含在一个try-catch子句中，它可以处理std::filesystem::filesystem_error类型的异常:</p>
<div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">try</span> {
    ...;
    <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">create_directory</span>(p)) { <span class="hljs-comment">// 错误异常（除非路径存在）</span>
        std::cout &lt;&lt; p &lt;&lt; <span class="hljs-string">" already exists\n"</span>; <span class="hljs-comment">// 路径存在</span>
    }
    ...;
}
<span class="hljs-built_in">catch</span> (<span class="hljs-type">const</span> std::filesystem::filesystem_error&amp; e) { <span class="hljs-comment">// 源自 std::exception</span>
    std::cout &lt;&lt; <span class="hljs-string">"EXCEPTION: "</span> &lt;&lt; e.<span class="hljs-built_in">what</span>() &lt;&lt; <span class="hljs-string">'\n'</span>;
    std::cout &lt;&lt; <span class="hljs-string">" path: "</span> &lt;&lt; e.<span class="hljs-built_in">path1</span>() &lt;&lt; <span class="hljs-string">'\n'</span>;
}</code></pre></div>

<p>正如你所看到的，文件系统异常提供了通常的标准异常API，通过what()产生一个特定于实现的错误信息。然而，它还提供了path1()，如果涉及到一个路径，甚至是 path2()，如果涉及到第二个路径。</p>
<h6><span id="shi-yong-error-code-can-shu">使用 error_code 参数</span><a href="#shi-yong-error-code-can-shu" class="header-anchor">#</a></h6><p>使用error_code参数<br>另一种调用函数创建目录的方法如下。</p>
<div class="code-wrapper"><pre><code class="hljs c++">std::error_code ec;
<span class="hljs-built_in">create_directory</span>(p, ec); <span class="hljs-comment">// 出错时设置错误代码</span>
<span class="hljs-keyword">if</span> (ec) { <span class="hljs-comment">// 如果设置了错误代码(由于错误)</span>
    std::cout &lt;&lt; <span class="hljs-string">"ERROR: "</span> &lt;&lt; ec.<span class="hljs-built_in">message</span>() &lt;&lt; <span class="hljs-string">"\n"</span>;
}</code></pre></div>
<p>之后，我们还可以针对特定的错误代码进行检查。</p>
<div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">if</span> (ec == std::errc::read_only_file_system) { <span class="hljs-comment">// if specific error code set</span>
    std::cout &lt;&lt; <span class="hljs-string">"ERROR: "</span> &lt;&lt; p &lt;&lt; <span class="hljs-string">" is read-only/n"</span>;
}</code></pre></div>
<p>注意，在这种情况下，我们仍然可以检查create_directory()的返回值。</p>
<div class="code-wrapper"><pre><code class="hljs c++">std::error_code ec;
<span class="hljs-keyword">if</span> (!<span class="hljs-built_in">create_directory</span>(p, ec)) { <span class="hljs-comment">// 出错时设置错误代码</span>
    std::cout &lt;&lt; <span class="hljs-string">"can't create directory "</span> &lt;&lt; p &lt;&lt; <span class="hljs-string">"\n"</span>; <span class="hljs-comment">// any error occurred</span>
    std::cout &lt;&lt; <span class="hljs-string">"ERROR:"</span> &lt;&lt; ec.<span class="hljs-built_in">message</span>() &lt;&lt; <span class="hljs-string">"\n"</span>;
}</code></pre></div>
<p>然而，并不是所有的文件系统操作都提供这种能力（因为它们在正常情况下返回一些值正常情况下）。<br>在C++11中引入了error_code类型，包括一个可移植错误条件的列表，如<br>如std::errc::read_only_filesystem。在POSIX系统中，这些映射为errno值</p>
<h5><span id="20-2-7-wen-jian-lei-xing">20.2.7 文件类型</span><a href="#20-2-7-wen-jian-lei-xing" class="header-anchor">#</a></h5><p>不同的操作系统支持不同的文件类型。标准文件系统库考虑到了这一点。原则上，有一个枚举类型file_type，它被标准化为有以下值:</p>
<div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">namespace</span> std::filesystem {
    <span class="hljs-keyword">enum class</span> <span class="hljs-title class_">file_type</span> {
        regular, directory, symlink,
        block, character, fifo, socket,
        ...;
        none, not_found, unknown,
    };
}</code></pre></div>

<p>表file_type Values列出了这些值的含义。<br>平台可能会提供额外的文件类型值，但这是不可移植的。例如:</p>
<p> Windows提供了文件类型值junction，它用于NTFS文件系统的NTFS结点（也称为软链接）。它们被用作位于同一台计算机的不同本地卷上的目录的链接。在同一台计算机上的不同卷上的目录的链接。</p>
<table>
<thead>
<tr>
<th>值</th>
<th>意义</th>
</tr>
</thead>
<tbody><tr>
<td>regular</td>
<td>常规文件</td>
</tr>
<tr>
<td>directory</td>
<td>目录文件</td>
</tr>
<tr>
<td>symlink</td>
<td>符号连接</td>
</tr>
<tr>
<td>character</td>
<td>字符专用文件</td>
</tr>
<tr>
<td>block</td>
<td>块特殊文件</td>
</tr>
<tr>
<td>fifo</td>
<td>FIFO或管道文件</td>
</tr>
<tr>
<td>socket</td>
<td>套接字文件</td>
</tr>
<tr>
<td>…</td>
<td>额外的执行定义的文件类型</td>
</tr>
<tr>
<td>none</td>
<td>文件类型未知（尚）</td>
</tr>
<tr>
<td>unknown</td>
<td>文件存在但无法确定类型</td>
</tr>
<tr>
<td>not_found</td>
<td>表示未找到该文件的伪类型</td>
</tr>
</tbody></table>
<p>除了常规文件和目录之外，最常见的其他类型是符号链接，它是一种指向另一个文件系统位置的文件的类型。在那个位置可能有一个文件，也可能没有。请注意，某些操作系统和/或文件系统（例如 FAT 文件系统）根本不支持符号链接。某些操作系统仅对常规文件支持它们。请注意，在 Windows 上，您需要特殊权限才能创建符号链接，例如，您可以使用 mklink 命令执行此操作。<br>字符特殊文件、块特殊文件、FIFO 和套接字来自 UNIX 文件系统。目前，所有四种类型都不能与 Visual C++ 一起使用。<br>如您所见，对于文件不存在或其文件类型未知或无法检测的情况，存在特殊值。在本章的其余部分中，我使用两个通用类别来表示几种文件类型：</p>
<ul>
<li>其他文件：具有除常规文件、目录和符号链接之外的任何文件类型的文件。库函数 is_other() 匹配该术语。</li>
<li>特殊文件：具有以下任何文件类型的文件：字符特殊文件、块特殊文件、FIFO 和套接字。<br>特殊文件类型加上实现定义的文件类型共同构成了其他文件类型。</li>
</ul>
<h4><span id="20-3-lu-jing-cao-zuo">20.3 路径操作</span><a href="#20-3-lu-jing-cao-zuo" class="header-anchor">#</a></h4><p>为了处理文件系统，有很多操作可以调用。处理文件系统的一个关键类型是std::filesystem::path，它可以作为一个文件的绝对或相对路径，这个文件可能存在，也可能不存在（尚未存在）。</p>
<p>你可以创建路径，检查它们，修改它们，以及比较它们。因为这些操作通常不考虑文件系统（关心现有文件、符号链接等），所以它们的调用很便宜。因此，它们通常是成员函数（如果它们不是构造函数或 操作符）。</p>
<h5><span id="20-3-1-chuang-jian-lu-jing">20.3.1 创建路径</span><a href="#20-3-1-chuang-jian-lu-jing" class="header-anchor">#</a></h5><p>表Path Creation列出了创建新路径对象的方法。</p>
<table>
<thead>
<tr>
<th>调用</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>path(string)</td>
<td>从一个字符串创建路径</td>
</tr>
<tr>
<td>path(beg,end)</td>
<td>从一个范围创建路径</td>
</tr>
<tr>
<td>u8path(u8string)</td>
<td>从一个UTF-8字符串中创建路径</td>
</tr>
<tr>
<td>current_path()</td>
<td>产生当前工作目录的路径</td>
</tr>
<tr>
<td>temp_directory_path()</td>
<td>产生临时文件的路径</td>
</tr>
</tbody></table>
<p>注意，current_path()和temp_directory_path()都是比较昂贵的操作，因为它们是基于操作系统的调用。通过传递一个参数，current_path()也可以用来修改当前工作目录。<br>通过u8path()，你可以使用所有UTF-8字符创建可移植的路径。比如说:</p>
<div class="code-wrapper"><pre><code class="hljs c++">std::filesystem::path{<span class="hljs-built_in">u8path</span>(<span class="hljs-string">u8"K\u00F6ln"</span>); <span class="hljs-comment">// ”Koln” (Cologne native) ¨</span>
...
<span class="hljs-comment">// 从返回的UTF-8字符串中创建目录:</span>
std::string utf8String = <span class="hljs-built_in">readUTF8String</span>(...);
<span class="hljs-built_in">create_directory</span>(std::filesystem::<span class="hljs-built_in">u8path</span>(utf8String));</code></pre></div>

<h5><span id="20-3-2-lu-jing-jian-cha">20.3.2 路径检查</span><a href="#20-3-2-lu-jing-jian-cha" class="header-anchor">#</a></h5><p>表Path Inspection列出了你可以调用的检查路径p的函数。注意，这些操作不考虑文件系统，因此是路径的成员函数。<br>每个路径都是绝对或相对的。如果它没有根目录，它就是相对的（根名称是可能的；例如，C:hello.txt在Windows下是一个相对路径）。<br>has_…()函数检查没有has_的相应函数是否产生一个空路径。<br>请注意以下几点。</p>
<ul>
<li>如果根元素或目录分隔符是路径的一部分，总是有一个父路径。如果路径只由根元素组成（即相对路径是空的），parent_path()得到的是相同的路径。也就是说，例如，”/“的父路径是”/“。只有像 “hello.txt “这样的纯文件名的父路径是空的。</li>
</ul>
<table>
<thead>
<tr>
<th>调用</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>p.empty()</td>
<td>产生路径是否为空</td>
</tr>
<tr>
<td>p.is_absolute()</td>
<td>产生一个路径是否是绝对的</td>
</tr>
<tr>
<td>p.is_relative()</td>
<td>产生是否是相对路径</td>
</tr>
<tr>
<td>p.has_filename()</td>
<td>产生路径是否既不是目录也不是根名的问题</td>
</tr>
<tr>
<td>p.has_stem()</td>
<td>与has_filename()相同（因为任何文件名都有一个干）。</td>
</tr>
<tr>
<td>p.has_extension()</td>
<td>产生路径是否有扩展名</td>
</tr>
<tr>
<td>p.has_root_name()</td>
<td>yields 路径是否有根名</td>
</tr>
<tr>
<td>p.has_root_directory()</td>
<td>yields 路径是否有根目录</td>
</tr>
<tr>
<td>p.has_root_path()</td>
<td>yields 路径是否有根名或根目录</td>
</tr>
<tr>
<td>p.has_parent_path()</td>
<td>产生路径是否有一个父路径</td>
</tr>
<tr>
<td>p.has_relative_path()</td>
<td>产生路径是否不只由根元素组成</td>
</tr>
<tr>
<td>p.filename()</td>
<td>产生文件名（或空路径）。</td>
</tr>
<tr>
<td>p.stem()</td>
<td>产生不带扩展名的文件名（或空路径）</td>
</tr>
<tr>
<td>p.extension()</td>
<td>产生扩展名(或空路径)</td>
</tr>
<tr>
<td>p.root_name()</td>
<td>产生根名(或空路径)</td>
</tr>
<tr>
<td>p.root_directory()</td>
<td>产生根目录(或空路径)</td>
</tr>
<tr>
<td>p.root_path()</td>
<td>产生根元素(或空路径)</td>
</tr>
<tr>
<td>p.parent_path()</td>
<td>产生父路径(或空路径)</td>
</tr>
<tr>
<td>p.relative_path()</td>
<td>产生没有根元素的路径(或空路径)</td>
</tr>
<tr>
<td>p.begin()</td>
<td>路径迭代的开始</td>
</tr>
<tr>
<td>p.end()</td>
<td>路径迭代结束</td>
</tr>
</tbody></table>
<ul>
<li>如果一个路径有一个文件名，它也总是有一个茎。</li>
<li>空路径是一个相对路径（对于除is_empty()和is_relative()之外的所有其他操作，产生false或空路径）。<br>这些操作的结果可能取决于操作系统。例如，路径C:/hello.txt</li>
<li>在Unix系统上<ul>
<li>是相对的</li>
<li>没有根元素（既没有根名称也没有根目录），因为C:是一个文件名。</li>
<li>有父路径C:</li>
<li>具有相对路径C:/hello.txt</li>
</ul>
</li>
<li>在Windows系统上<ul>
<li>是绝对的</li>
<li>有根名称C：和根目录/</li>
<li>没有父路径</li>
<li>有相对路径 hello.txt</li>
</ul>
</li>
</ul>
<h6><span id="lu-jing-die-dai">路径迭代</span><a href="#lu-jing-die-dai" class="header-anchor">#</a></h6><p>你可以对一个路径进行迭代，产生路径中的元素：根名（如果有），根目录（如果有），以及所有的文件名。如果路径以目录分隔符结束，最后一个元素是一个空文件名。<br>迭代器是一个双向的迭代器，这样你就可以使用—-。迭代器引用的值又是路径类型的。然而，两个迭代器在同一路径上迭代时，即使它们引用了相同的元素，也可能不会引用相同的路径对象。<br>比如说：</p>
<div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">printPath</span><span class="hljs-params">(<span class="hljs-type">const</span> std::filesystem::path&amp; p)</span></span>
<span class="hljs-function"></span>{
    std::cout &lt;&lt; <span class="hljs-string">"path elements of "</span> &lt;&lt; p.string &lt;&lt; <span class="hljs-string">":\n"</span>;
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> pos = p.<span class="hljs-built_in">begin</span>(); pos != p.<span class="hljs-built_in">end</span>(); ++pos) {
        std::filesystem::path elem = *pos;
        std::cout &lt;&lt; <span class="hljs-string">" "</span> &lt;&lt; elem;
    }
    std::cout &lt;&lt; <span class="hljs-string">'\n'</span>;
}</code></pre></div>

<p>如果这个函数被调用如下:</p>
<div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-built_in">printPath</span>(<span class="hljs-string">"../sub/file.txt"</span>);
<span class="hljs-built_in">printPath</span>(<span class="hljs-string">"/usr/tmp/test/dir/"</span>);
<span class="hljs-built_in">printPath</span>(<span class="hljs-string">"C:\\usr\\tmp\\test\\dir\\"</span>);</code></pre></div>

<p>在基于POSIX的系统上的输出将是:</p>
<div class="code-wrapper"><pre><code class="hljs bash">path elements of <span class="hljs-string">"../sub/file.txt"</span>:
<span class="hljs-string">".."</span> <span class="hljs-string">"sub"</span> <span class="hljs-string">"file.txt"</span>
path elements of <span class="hljs-string">"/usr/tmp/test/dir/"</span>:
<span class="hljs-string">"/"</span> <span class="hljs-string">"usr"</span> <span class="hljs-string">"tmp"</span> <span class="hljs-string">"test"</span> <span class="hljs-string">"dir"</span> <span class="hljs-string">""</span>
path elements of <span class="hljs-string">"C:\\usr\\tmp\\test\\dir\\"</span>:
<span class="hljs-string">"C:\\usr\\tmp\\test\\dir\\"</span></code></pre></div>

<p>注意，最后一个路径只是一个文件名，因为在基于POSIX的系统下，C:既不是有效的根名，反斜杠也不是有效的目录分隔符。<br>在Windows系统上的输出将是：</p>
<div class="code-wrapper"><pre><code class="hljs bash">path elements of <span class="hljs-string">"../sub/file.txt"</span>:
<span class="hljs-string">".."</span> <span class="hljs-string">"sub"</span> <span class="hljs-string">"file.txt"</span>
path elements of <span class="hljs-string">"/usr/tmp/test/dir/"</span>:
<span class="hljs-string">"/"</span> <span class="hljs-string">"usr"</span> <span class="hljs-string">"tmp"</span> <span class="hljs-string">"test"</span> <span class="hljs-string">"dir"</span> <span class="hljs-string">""</span>
path elements of <span class="hljs-string">"C:\\usr\\tmp\\test\\dir\\"</span>:
<span class="hljs-string">"C:"</span> <span class="hljs-string">"\\"</span> <span class="hljs-string">"usr"</span> <span class="hljs-string">"tmp"</span> <span class="hljs-string">"test"</span> <span class="hljs-string">"dir"</span> <span class="hljs-string">""</span></code></pre></div>

<p>要检查一个路径p是否以目录分隔符结束，你可以实现:</p>
<div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">if</span> (!p.<span class="hljs-built_in">empty</span>() &amp;&amp; (--p.<span class="hljs-built_in">end</span>())-&gt;<span class="hljs-built_in">empty</span>()) {
    std::cout &lt;&lt; p &lt;&lt; <span class="hljs-string">" has a trailing separator\n"</span>;
}</code></pre></div>

<h5><span id="20-3-3-lu-jing-i-o-he-zhuan-huan">20.3.3 路径I/O和转换</span><a href="#20-3-3-lu-jing-i-o-he-zhuan-huan" class="header-anchor">#</a></h5><p>表中路径I/O和转换列出了读取或写入以及产生转换后的路径的操作。<br>这些功能没有考虑到实际的文件系统。如果你必须处理符号链接重要的路径，你可能想使用与文件系统相关的路径转换。</p>
<table>
<thead>
<tr>
<th>调用</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>strm &lt;&lt; p</td>
<td>把路径的值写成引号字符串</td>
</tr>
<tr>
<td>strm &gt;&gt; p</td>
<td>将路径的值读成带引号的字符串</td>
</tr>
<tr>
<td>p.string()</td>
<td>得到的路径是std::string</td>
</tr>
<tr>
<td>p.wstring()</td>
<td>得到的路径是std::wstring</td>
</tr>
<tr>
<td>p.u8string()</td>
<td>产生路径的UTF-8字符串，类型为std::u8string</td>
</tr>
<tr>
<td>p.u16string()</td>
<td>产生路径的UTF-16字符串，类型为std::u16string</td>
</tr>
<tr>
<td>p.u32string()</td>
<td>产生路径的UTF-32字符串，类型为std::u32string</td>
</tr>
<tr>
<td>p.string&lt;…&gt;()</td>
<td>得到的路径是std::basic_string&lt;…&gt;。</td>
</tr>
<tr>
<td>p.lexically_normal()</td>
<td>产生 p 作为标准化路径</td>
</tr>
<tr>
<td>p.lexically_relative(p2)</td>
<td>产生从p2到p的路径（如果没有则为空路）。</td>
</tr>
<tr>
<td>p.lexically_proximate(p2)</td>
<td>产生从 p2 到 p 的路径（如果没有，则为 p）</td>
</tr>
</tbody></table>
<p>lexically_…()函数返回一个新的路径，而其他转换函数产生一个相应的字符串类型。这些函数都没有修改它们所调用的路径。<br>例如，下面的代码:</p>
<div class="code-wrapper"><pre><code class="hljs c++">std::filesystem::path p{<span class="hljs-string">"/dir/./sub//sub1/../sub2"</span>};
std::cout &lt;&lt; <span class="hljs-string">"path: "</span> &lt;&lt; p &lt;&lt; <span class="hljs-string">'\n'</span>;
std::cout &lt;&lt; <span class="hljs-string">"string(): "</span> &lt;&lt; p.<span class="hljs-built_in">string</span>() &lt;&lt; <span class="hljs-string">'\n'</span>;
std::wcout &lt;&lt; <span class="hljs-string">"wstring(): "</span> &lt;&lt; p.<span class="hljs-built_in">wstring</span>() &lt;&lt; <span class="hljs-string">'\n'</span>;
std::cout &lt;&lt; <span class="hljs-string">"lexically_normal(): "</span> &lt;&lt; p.<span class="hljs-built_in">lexically_normal</span>() &lt;&lt; <span class="hljs-string">'\n'</span>;</code></pre></div>

<p>对前三行有相同的输出:</p>
<div class="code-wrapper"><pre><code class="hljs bash">path: <span class="hljs-string">"/dir/./sub//sub1/../sub2"</span>
string(): /dir/./sub//sub1/../sub2
wstring(): /dir/./sub//sub1/../sub2</code></pre></div>

<p>但最后一行的输出取决于目录分隔符。在基于POSIX的系统中，它是:</p>
<div class="code-wrapper"><pre><code class="hljs bash">lexically_normal(): <span class="hljs-string">"/dir/sub/sub2"</span></code></pre></div>

<p>而在Windows上，它是:</p>
<div class="code-wrapper"><pre><code class="hljs bash">lexically_normal(): <span class="hljs-string">"\\dir\\sub\\sub2"</span></code></pre></div>

<h6><span id="lu-jing-i-o">路径I/O</span><a href="#lu-jing-i-o" class="header-anchor">#</a></h6><p>首先，请注意，I/O操作符是以带引号的字符串形式写入和读取路径。你必须把它们转换为字符串，以便在写它们时不加引号:</p>
<div class="code-wrapper"><pre><code class="hljs c++">std::filesystem::path file{<span class="hljs-string">"test.txt"</span>}
std::cout &lt;&lt; file &lt;&lt; <span class="hljs-string">'\n'</span>; <span class="hljs-comment">// writes: "test.txt"</span>
std::cout &lt;&lt; file.<span class="hljs-built_in">string</span>() &lt;&lt; <span class="hljs-string">'\n'</span>; <span class="hljs-comment">// writes: test.txt</span></code></pre></div>

<p>在Windows上，这有更糟糕的效果。下面的代码:</p>
<div class="code-wrapper"><pre><code class="hljs c++">std::filesystem::path tmp{<span class="hljs-string">"C:\\Windows\\Temp"</span>};
std::cout &lt;&lt; tmp &lt;&lt; <span class="hljs-string">'\n'</span>;
std::cout &lt;&lt; tmp.<span class="hljs-built_in">string</span>() &lt;&lt; <span class="hljs-string">'\n'</span>;
std::cout &lt;&lt; <span class="hljs-string">'"'</span> &lt;&lt; tmp.<span class="hljs-built_in">string</span>() &lt;&lt; <span class="hljs-string">"\"\n"</span>;</code></pre></div>

<p>有以下输出:</p>
<div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-string">"C:\\Windows\\Temp"</span>
C:\Windows\Temp
<span class="hljs-string">"C:\Windows\Temp"</span></code></pre></div>

<p>注意，读取文件名支持两种形式（带前导 “的引号和不带引号）。因此，所有打印出来的形式将被正确地读回，使用标准输入操作符的路径:</p>
<div class="code-wrapper"><pre><code class="hljs c++">std::filesystem::path tmp;
std::cin &gt;&gt; tmp; <span class="hljs-comment">// 正确读取带引号和不带引号的路径</span></code></pre></div>

<h6><span id="zheng-chang-hua">正常化</span><a href="#zheng-chang-hua" class="header-anchor">#</a></h6><p>当你处理可移植代码时，malization可能有更多令人惊讶的结果。比如说：</p>
<div class="code-wrapper"><pre><code class="hljs c++">td::filesystem::path p2{<span class="hljs-string">"//dir\\subdir/subsubdir\\/./\\"</span>};
std::cout &lt;&lt; <span class="hljs-string">"p2: "</span> &lt;&lt; p2 &lt;&lt; <span class="hljs-string">'\n'</span>;
std::cout &lt;&lt; <span class="hljs-string">"lexically_normal(): "</span> &lt;&lt; p2.<span class="hljs-built_in">lexically_normal</span>() &lt;&lt; <span class="hljs-string">'\n'</span>;</code></pre></div>

<p>在Windows系统上有以下可能的预期输出:</p>
<div class="code-wrapper"><pre><code class="hljs bash">p2: <span class="hljs-string">"//host\\dir/sub\\/./\\"</span>
lexically_normal(): <span class="hljs-string">"\\\\host\\dir\\sub\\"</span></code></pre></div>

<p>然而，在基于POSIX的系统上，输出变成了:</p>
<div class="code-wrapper"><pre><code class="hljs bash">p2: <span class="hljs-string">"//host\\dir/sub\\/./\\"</span>
lexically_normal(): <span class="hljs-string">"/host\\dir/sub\\/\\"</span></code></pre></div>

<p>原因是在基于POSIX的系统中，反斜杠不是目录分隔符，也不是根名的有效字符，所以我们有一个绝对路径，有三个文件名host\dir、sub\和\。在基于POSIX的系统中，没有办法检测到反斜杠是一个可能的目录分隔符（在这种情况下，generic_string()和make_preferred()都没有帮助）。<br>因此，对于可移植代码来说，在处理路径时，你应该始终使用通用路径格式。<br>尽管如此，在迭代当前目录时，使用lexically_normal()函数去掉前面的点也是一个好办法。</p>
<h6><span id="xiang-dui-lu-jing">相对路径</span><a href="#xiang-dui-lu-jing" class="header-anchor">#</a></h6><p>lexically_relative()和lexically_proximate()都可以被调用来计算相对于<br>路径之间的相对路径。唯一的区别是在没有路径的情况下的行为，只有在一个路径是相对的，另一个是绝对的或者根名称不同的情况下才会发生。在这种情况下。</p>
<ul>
<li><p>p.lexically_relative(p2)如果没有从p2到p的相对路径，则产生空路径。</p>
</li>
<li><p>p.lexically_proximate(p2)如果没有从p2到p的相对路径，则产生p。<br>由于这两个操作都是词法操作，实际的文件系统（可能有符号链接）和current_path()都没有被考虑在内。如果两个路径相等，则相对路径为”.”。<br>例子:</p>
<div class="code-wrapper"><pre><code class="hljs c++">fs::path{<span class="hljs-string">"/a/d"</span>}.<span class="hljs-built_in">lexically_relative</span>(<span class="hljs-string">"/a/b/c"</span>) <span class="hljs-comment">// "../../d"</span>
fs::path{<span class="hljs-string">"/a/b/c"</span>}.<span class="hljs-built_in">lexically_relative</span>(<span class="hljs-string">"/a/d"</span>) <span class="hljs-comment">// "../b/c"</span>
fs::path{<span class="hljs-string">"/a/b"</span>}.<span class="hljs-built_in">lexically_relative</span>(<span class="hljs-string">"/a/b"</span>) <span class="hljs-comment">// "."</span>
fs::path{<span class="hljs-string">"/a/b"</span>}.<span class="hljs-built_in">lexically_relative</span>(<span class="hljs-string">"/a/b/"</span>) <span class="hljs-comment">// "."</span>
fs::path{<span class="hljs-string">"/a/b"</span>}.<span class="hljs-built_in">lexically_relative</span>(<span class="hljs-string">"/a/b\\"</span>) <span class="hljs-comment">// "."</span>
fs::path{<span class="hljs-string">"/a/b"</span>}.<span class="hljs-built_in">lexically_relative</span>(<span class="hljs-string">"/a/d/../c"</span>) <span class="hljs-comment">// "../b</span>
fs::path{<span class="hljs-string">"a/d/../b"</span>}.<span class="hljs-built_in">lexically_relative</span>(<span class="hljs-string">"a/c"</span>) <span class="hljs-comment">// "../d/../b"</span>
fs::path{<span class="hljs-string">"a//d/..//b"</span>}.<span class="hljs-built_in">lexically_relative</span>(<span class="hljs-string">"a/c"</span>) <span class="hljs-comment">// "../d/../b"</span></code></pre></div>

<p>在Windows系统上，我们有:</p>
<div class="code-wrapper"><pre><code class="hljs c++">fs::path{<span class="hljs-string">"C:/a/b"</span>}.<span class="hljs-built_in">lexically_relative</span>(<span class="hljs-string">"c:/c/d"</span>) ; <span class="hljs-comment">// ""</span>
fs::path{<span class="hljs-string">"C:/a/b"</span>}.<span class="hljs-built_in">lexically_relative</span>(<span class="hljs-string">"D:/c/d"</span>) ; <span class="hljs-comment">// ""</span>
fs::path{<span class="hljs-string">"C:/a/b"</span>}.<span class="hljs-built_in">lexically_proximate</span>(<span class="hljs-string">"D:/c/d"</span>) ; <span class="hljs-comment">// "C:/a/b"</span></code></pre></div></li>
</ul>
<h6><span id="zhuan-huan-wei-zi-fu-chuan">转换为字符串</span><a href="#zhuan-huan-wei-zi-fu-chuan" class="header-anchor">#</a></h6><p>  使用u8string()，你可以将路径作为UTF-8字符串使用，这也是当今存储数据的常用格式。存储数据的常用格式。比如说;</p>
  <div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-comment">// 将路径存储为UTF-8字符串:</span>
std::vector&lt;std::string&gt; utf8paths; <span class="hljs-comment">// std::u8string with C++20</span>
<span class="hljs-keyword">for</span> (<span class="hljs-type">const</span> <span class="hljs-keyword">auto</span>&amp; entry : fs::<span class="hljs-built_in">directory_iterator</span>(p)) {
    utf8paths.<span class="hljs-built_in">push_back</span>(entry.<span class="hljs-built_in">path</span>().<span class="hljs-built_in">u8string</span>());
}</code></pre></div>

<p>  请注意，u8string()的返回值可能会在C++20中从std::string变为std::u8string（新的UTF-8字符串类型，与char8_t一起在<a target="_blank" rel="noopener" href="https://wg21.link/p0482%EF%BC%8C%E7%94%A8%E4%BA%8EUTF-8%E5%AD%97%E7%AC%A6%EF%BC%89%E3%80%82">https://wg21.link/p0482，用于UTF-8字符）。</a><br>  成员模板string&lt;&gt;()可以用来转换为一个特殊的字符串类型，例如一个不区分大小写的字符串类型:</p>
  <div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">ignoreCaseTraits</span> : <span class="hljs-keyword">public</span> std::char_traits&lt;<span class="hljs-type">char</span>&gt; {
    <span class="hljs-comment">// 不敏感地比较两个字符的情况:</span>
    <span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">bool</span> <span class="hljs-title">eq</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span>&amp; c1, <span class="hljs-type">const</span> <span class="hljs-type">char</span>&amp; c2)</span> </span>{
        <span class="hljs-keyword">return</span> std::<span class="hljs-built_in">toupper</span>(c1) == std::<span class="hljs-built_in">toupper</span>(c2);
    }
    <span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">bool</span> <span class="hljs-title">lt</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span>&amp; c1, <span class="hljs-type">const</span> <span class="hljs-type">char</span>&amp; c2)</span> </span>{
        <span class="hljs-keyword">return</span> std::<span class="hljs-built_in">toupper</span>(c1) &lt; std::<span class="hljs-built_in">toupper</span>(c2);
    }
    <span class="hljs-comment">// 比较s1和s2的多达n个字符:</span>
    <span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">int</span> <span class="hljs-title">compare</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span>* s1, <span class="hljs-type">const</span> <span class="hljs-type">char</span>* s2, std::<span class="hljs-type">size_t</span> n)</span></span>;
    <span class="hljs-comment">// 检索字符c在s中的位置:</span>
    <span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">const</span> <span class="hljs-type">char</span>* <span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span>* s, std::<span class="hljs-type">size_t</span> n, <span class="hljs-type">const</span> <span class="hljs-type">char</span>&amp; c)</span></span>;
};
<span class="hljs-comment">// 为这类字符串定义一个特殊的类型:</span>
<span class="hljs-keyword">using</span> icstring = std::basic_string&lt;<span class="hljs-type">char</span>, ignoreCaseTraits&gt;;
std::filesystem::path p{<span class="hljs-string">"/dir\\subdir/subsubdir\\/./\\"</span>};
icstring s2 = p.<span class="hljs-built_in">string</span>&lt;<span class="hljs-type">char</span>,ignoreCaseTraits&gt;();</code></pre></div>

<p>还需要注意的是，你不应该使用同样提供的函数c_str()，因为它可以转换为本地字符串格式，可能是一个wchar_t，这样你就必须使用，例如 std::wcout而不是std::cout来将其写入流中。</p>
<h5><span id="20-3-4-ben-di-ge-shi-he-tong-yong-ge-shi-zhi-jian-de-zhuan-huan">20.3.4 本地格式和通用格式之间的转换</span><a href="#20-3-4-ben-di-ge-shi-he-tong-yong-ge-shi-zhi-jian-de-zhuan-huan" class="header-anchor">#</a></h5><p>在本地和通用格式之间的转换表列出了在通用路径格式和实际平台的特定实现格式之间的转换操作。</p>
<p>这些函数在基于POSIX的系统中应该没有影响，因为本地路径格式和通用路径格式之间没有区别。在其他平台上调用这些函数可能会有影响：</p>
<ul>
<li><p>generic…() path 函数产生转换为具有通用格式的相应字符串格式的路径，</p>
<table>
<thead>
<tr>
<th>调用</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>p.generic_string()</td>
<td>得到的路径是一个通用的std::string</td>
</tr>
<tr>
<td>p.generic_wstring()</td>
<td>得到的路径是一个通用的std::wstring</td>
</tr>
<tr>
<td>p.generic_u8string()</td>
<td>得到的路径是一个通用的std::u8string</td>
</tr>
<tr>
<td>p.generic_u16string()</td>
<td>得到的路径是一个通用的std::u16string</td>
</tr>
<tr>
<td>p.generic_u32string()</td>
<td>得到的路径是一个通用的std::u32string</td>
</tr>
<tr>
<td>p.generic_string&lt;…&gt;()</td>
<td>得到的路径是一个通用的std::basic_string&lt;…&gt;</td>
</tr>
<tr>
<td>p.native()</td>
<td>产生本地格式的路径，类型为path::string_type</td>
</tr>
<tr>
<td>conversionToNativeString</td>
<td>隐式转换为本地字符串类型</td>
</tr>
<tr>
<td>p.c_str()</td>
<td>产生作为本地字符串格式的字符序列的路径</td>
</tr>
<tr>
<td>p.make_preferred()</td>
<td>用本地格式替换p中的目录分隔符，并得到修改后的p</td>
</tr>
</tbody></table>
<ul>
<li>native()产生转换为本地字符串编码的路径，它由std::filesystem::path::string_type类型定义。在Windows下，这个类型是std::wstring类型，所以你必须使用std::wcout而不是std::cout来直接将其写入标准输出流。新的重载允许我们将本地字符串传递给文件流的新重载。</li>
<li>c_str()做了同样的事情，但产生的结果是一个空尾的字符序列。注意，使用这个函数也是不可移植的，因为在Windows上用std::cout打印序列并不能产生正确的输出。你必须在那里使用std::wcout。</li>
<li>make_preferred()用本地目录分隔符替换了除根名之外的任何目录分隔符。注意，这是唯一一个修改它所调用的路径的函数。因此，严格来说属于下一节修改路径的函数，但由于它处理的是本地格式的转换，所以也在这里列出。</li>
</ul>
<p>例如，在Windows下，下面的代码。</p>
<div class="code-wrapper"><pre><code class="hljs c++">std::filesystem::path p{<span class="hljs-string">"/dir\\subdir/subsubdir\\/./\\"</span>};
std::cout &lt;&lt; <span class="hljs-string">"p: "</span> &lt;&lt; p &lt;&lt; <span class="hljs-string">'\n'</span>;
std::cout &lt;&lt; <span class="hljs-string">"string(): "</span> &lt;&lt; p.<span class="hljs-built_in">string</span>() &lt;&lt; <span class="hljs-string">'\n'</span>;
std::wcout &lt;&lt; <span class="hljs-string">"wstring(): "</span> &lt;&lt; p.<span class="hljs-built_in">wstring</span>() &lt;&lt; <span class="hljs-string">'\n'</span>;
std::cout &lt;&lt; <span class="hljs-string">"lexically_normal(): "</span> &lt;&lt; p.<span class="hljs-built_in">lexically_normal</span>() &lt;&lt; <span class="hljs-string">'\n'</span>;
std::cout &lt;&lt; <span class="hljs-string">"generic_string(): "</span> &lt;&lt; p.<span class="hljs-built_in">generic_string</span>() &lt;&lt; <span class="hljs-string">'\n'</span>;
std::wcout &lt;&lt; <span class="hljs-string">"generic_wstring(): "</span> &lt;&lt; p.<span class="hljs-built_in">generic_wstring</span>() &lt;&lt; <span class="hljs-string">'\n'</span>;
<span class="hljs-comment">// 因为它是Windows，而且本地字符串类型是wstring。:</span>
std::wcout &lt;&lt; <span class="hljs-string">"native(): "</span> &lt;&lt; p.<span class="hljs-built_in">native</span>() &lt;&lt; <span class="hljs-string">'\n'</span>; <span class="hljs-comment">// Windows!</span>
std::wcout &lt;&lt; <span class="hljs-string">"c_str(): "</span> &lt;&lt; p.<span class="hljs-built_in">c_str</span>() &lt;&lt; <span class="hljs-string">'\n'</span>;
std::cout &lt;&lt; <span class="hljs-string">"make_preferred(): "</span> &lt;&lt; p.<span class="hljs-built_in">make_preferred</span>() &lt;&lt; <span class="hljs-string">'\n'</span>;
std::cout &lt;&lt; <span class="hljs-string">"p: "</span> &lt;&lt; p &lt;&lt; <span class="hljs-string">'\n'</span>;</code></pre></div>

<p>有以下输出:</p>
<div class="code-wrapper"><pre><code class="hljs bash">p: <span class="hljs-string">"/dir\\subdir/subsubdir\\/./\\"</span>
string(): /dir\subdir/subsubdir\/./\
wstring(): /dir\subdir/subsubdir\/./\
lexically_normal(): <span class="hljs-string">"\\dir\\subdir\\subsubdir\\"</span>
generic_string(): /dir/subdir/subsubdir//.//
generic_wstring(): /dir/subdir/subsubdir//.//
native(): /dir\subdir/subsubdir\/./\
c_str(): /dir\subdir/subsubdir\/./\
make_preferred(): <span class="hljs-string">"\\dir\\subdir\\subsubdir\\\\.\\\\"</span>
p: <span class="hljs-string">"\\dir\\subdir\\subsubdir\\\\.\\\\"</span></code></pre></div>

<p>再次注意:</p>
<ul>
<li>本地字符串类型是不可移植的。在Windows上它是一个wstring，在基于POSIX的系统上它是一个字符串，所以你必须使用cout而不是wcout来打印native()和c_str()的结果。使用wcout只对wstring()和generic_wstring()的返回值具有可移植性。generic_wstring()的返回值。</li>
<li>只有make_preferred()的调用会修改它所调用的路径。所有其他的调用使p 不受影响。</li>
</ul>
</li>
</ul>
<h5><span id="20-3-5-lu-jing-xiu-gai">20.3.5 路径修改</span><a href="#20-3-5-lu-jing-xiu-gai" class="header-anchor">#</a></h5><p>表Path Modifications列出了允许我们直接修改路径的操作。<br>+=和concat()只是在路径上添加新的字符，而/、/=和append()则是在路径上添加一个子 路径，并用当前目录的分隔符分隔:</p>
<div class="code-wrapper"><pre><code class="hljs c++">std::filesystem::path p{<span class="hljs-string">"myfile"</span>};
p += <span class="hljs-string">".git"</span>; <span class="hljs-comment">// p: myfile.git</span>
p /= <span class="hljs-string">".git"</span>; <span class="hljs-comment">// p: myfile.git/.git</span>
p.<span class="hljs-built_in">concat</span>(<span class="hljs-string">"1"</span>); <span class="hljs-comment">// p: myfile.git/git1</span>
p.<span class="hljs-built_in">append</span>(<span class="hljs-string">"1"</span>); <span class="hljs-comment">// p: myfile.git/git1/1</span>
std::cout &lt;&lt; p &lt;&lt; <span class="hljs-string">'\n'</span>;
std::cout &lt;&lt; p / p &lt;&lt; <span class="hljs-string">'\n'</span>;</code></pre></div>

<p>在基于POSIX的系统上，输出是:</p>
<div class="code-wrapper"><pre><code class="hljs bash"><span class="hljs-string">"myfile.git/.git1/1"</span>
<span class="hljs-string">"myfile.git/.git1/1/myfile.git/.git1/1"</span></code></pre></div>

<p>在Windows系统上，输出为:</p>
<div class="code-wrapper"><pre><code class="hljs bash"><span class="hljs-string">"myfile.git\\.git1\\1"</span>
<span class="hljs-string">"myfile.git\\.git1\\1\\myfile.git\\.git1\\1"</span></code></pre></div>

<p>注意，追加一个绝对子路径意味着替换现有的路径。例如，在:</p>
<div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">namespace</span> fs = std::filesystem;
<span class="hljs-keyword">auto</span> p1 = fs::<span class="hljs-built_in">path</span>(<span class="hljs-string">"/usr"</span>) / <span class="hljs-string">"tmp"</span>; <span class="hljs-comment">// path is /usr/tmp or /usr\tmp</span>
<span class="hljs-keyword">auto</span> p2 = fs::<span class="hljs-built_in">path</span>(<span class="hljs-string">"/usr/"</span>) / <span class="hljs-string">"tmp"</span>; <span class="hljs-comment">// path is /usr/tmp</span>
<span class="hljs-keyword">auto</span> p3 = fs::<span class="hljs-built_in">path</span>(<span class="hljs-string">"/usr"</span>) / <span class="hljs-string">"/tmp"</span>; <span class="hljs-comment">// path is /tmp</span></code></pre></div>

<table>
<thead>
<tr>
<th>调用</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>p = p2</td>
<td>指定一个新的路径</td>
</tr>
<tr>
<td>p = sv</td>
<td>指定一个字符串（视图）作为新的路径</td>
</tr>
<tr>
<td>p.assign(p2)</td>
<td>指定一个新的路径</td>
</tr>
<tr>
<td>p.assign(sv)</td>
<td>将一个字符串(视图)作为一个新的路径。</td>
</tr>
<tr>
<td>p.assign(beg, end)</td>
<td>将范围内的元素从开始到结束分配给路径</td>
</tr>
<tr>
<td>p1 / p2</td>
<td>将p2作为p1的子路径连接起来，产生路径。</td>
</tr>
<tr>
<td>p /= sub</td>
<td>将子路径作为子路径附加到路径p上</td>
</tr>
<tr>
<td>p.append(sub)</td>
<td>将子路径作为子路径附加到路径p上</td>
</tr>
<tr>
<td>p.append(beg, end)</td>
<td>将范围内从开始到结束的元素作为子路径附加到<br>路径p</td>
</tr>
<tr>
<td>p += str</td>
<td>将str的字符附加到路径p中</td>
</tr>
<tr>
<td>p.concat(sub)</td>
<td>将str的字符附加到路径p中</td>
</tr>
<tr>
<td>p.concat(beg, end)</td>
<td>将范围内从beg到end的元素追加到路径p中。</td>
</tr>
<tr>
<td>p.remove_filename()</td>
<td>从路径中删除尾部的文件名</td>
</tr>
<tr>
<td>p.replace_filename(repl)</td>
<td>替换尾部的文件名（如果有的话）</td>
</tr>
<tr>
<td>p.replace_extension()</td>
<td>删除任何尾部的文件名扩展名</td>
</tr>
<tr>
<td>p.replace_extension(repl)</td>
<td>替换尾部文件名的扩展名（如果有）。</td>
</tr>
<tr>
<td>p.clear()</td>
<td>使路径为空</td>
</tr>
<tr>
<td>p.swap(p2)</td>
<td>交换两个路径的值</td>
</tr>
<tr>
<td>swap(p1, p2)</td>
<td>交换两个路径的值</td>
</tr>
<tr>
<td>p.make_preferred()</td>
<td>用本地格式替换p中的目录分隔符，并产生<br>修改后的p</td>
</tr>
</tbody></table>
<div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">auto</span> p4 = fs::<span class="hljs-built_in">path</span>(<span class="hljs-string">"/usr/"</span>) / <span class="hljs-string">"/tmp"</span>; <span class="hljs-comment">// path is /tmp</span></code></pre></div>

<p>我们有4个路径，分别指向两个不同的文件。</p>
<ul>
<li><p>p1和p2相等，指向文件/usr/tmp（注意，在Windows下它们相等，p1是/usr/tmp）。</p>
</li>
<li><p>p3和p4是相等的，指的是文件/tmp，因为附加了一个绝对路径。<br>对于根元素来说，是否分配了一个新元素也很重要。例如，在Windows下 </p>
<p>我们有:</p>
<div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">auto</span> p1 = fs::<span class="hljs-built_in">path</span>(<span class="hljs-string">"usr"</span>) / <span class="hljs-string">"C:/tmp"</span>; <span class="hljs-comment">// path is C:/tmp</span>
<span class="hljs-keyword">auto</span> p2 = fs::<span class="hljs-built_in">path</span>(<span class="hljs-string">"usr"</span>) / <span class="hljs-string">"C:"</span>; <span class="hljs-comment">// path is C:</span>
<span class="hljs-keyword">auto</span> p3 = fs::<span class="hljs-built_in">path</span>(<span class="hljs-string">"C:"</span>) / <span class="hljs-string">""</span>; <span class="hljs-comment">// path is C:</span>
<span class="hljs-keyword">auto</span> p4 = fs::<span class="hljs-built_in">path</span>(<span class="hljs-string">"C:usr"</span>) / <span class="hljs-string">"/tmp"</span>; <span class="hljs-comment">// path is C:/tmp</span>
<span class="hljs-keyword">auto</span> p5 = fs::<span class="hljs-built_in">path</span>(<span class="hljs-string">"C:usr"</span>) / <span class="hljs-string">"C:tmp"</span>; <span class="hljs-comment">// path is C:usr\tmp</span>
<span class="hljs-keyword">auto</span> p6 = fs::<span class="hljs-built_in">path</span>(<span class="hljs-string">"C:usr"</span>) / <span class="hljs-string">"c:tmp"</span>; <span class="hljs-comment">// path is c:tmp</span>
<span class="hljs-keyword">auto</span> p7 = fs::<span class="hljs-built_in">path</span>(<span class="hljs-string">"C:usr"</span>) / <span class="hljs-string">"D:tmp"</span>; <span class="hljs-comment">// path is D:tmp</span></code></pre></div>

<p>函数make_preferred()将路径中的目录分隔符转换为本地格式。<br>比如说:</p>
<div class="code-wrapper"><pre><code class="hljs c++">std::filesystem::path p{<span class="hljs-string">"//server/dir//subdir///file.txt"</span>};
p.<span class="hljs-built_in">make_preferred</span>();
std::cout &lt;&lt; p &lt;&lt; <span class="hljs-string">'\n'</span>;</code></pre></div>

<p>写在基于POSIX的平台上:</p>
<div class="code-wrapper"><pre><code class="hljs bash"><span class="hljs-string">"//server/dir/subdir/file.txt"</span></code></pre></div>

<p>在Windows上，输出结果如下:</p>
<div class="code-wrapper"><pre><code class="hljs bash"><span class="hljs-string">"\\\\server\\dir\\\\subdir\\\\\\file.txt"</span></code></pre></div>

<p>请注意，前导根名不会被修改，因为它必须由两个斜线或反斜线组成。<br>还要注意的是，在基于POSIX的系统上，这个函数不能将反斜线转换为斜线，因为反斜线不被认为是目录分隔符。<br>replace_extension() 替换、添加或删除一个扩展名。</p>
<ul>
<li><p>如果文件有一个扩展名，它被替换</p>
</li>
<li><p>如果文件没有扩展名，将添加新的扩展名。</p>
</li>
<li><p>如果你跳过新的扩展名或者新的扩展名是空的，任何现有的扩展名都会被删除。<br>你是否在替换处放置一个前导点并不重要。该函数确保 例如：</p>
<div class="code-wrapper"><pre><code class="hljs c++">fs::path{<span class="hljs-string">"file.txt"</span>}.<span class="hljs-built_in">replace_extension</span>(<span class="hljs-string">"tmp"</span>) <span class="hljs-comment">// file.tmp</span>
fs::path{<span class="hljs-string">"file.txt"</span>}.<span class="hljs-built_in">replace_extension</span>(<span class="hljs-string">".tmp"</span>) <span class="hljs-comment">// file.tmp</span>
fs::path{<span class="hljs-string">"file.txt"</span>}.<span class="hljs-built_in">replace_extension</span>(<span class="hljs-string">""</span>) <span class="hljs-comment">// file</span>
fs::path{<span class="hljs-string">"file.txt"</span>}.<span class="hljs-built_in">replace_extension</span>() <span class="hljs-comment">// file</span>
fs::path{<span class="hljs-string">"dir"</span>}.<span class="hljs-built_in">replace_extension</span>(<span class="hljs-string">"tmp"</span>) <span class="hljs-comment">// dir.tmp</span>
fs::path{<span class="hljs-string">".git"</span>}.<span class="hljs-built_in">replace_extension</span>(<span class="hljs-string">"tmp"</span>) <span class="hljs-comment">// .git.tmp</span></code></pre></div>

<p>注意，作为 “纯扩展名 “的文件名（如.git）不算是扩展名。</p>
</li>
</ul>
</li>
</ul>
<h5><span id="20-3-6-lu-jing-bi-jiao">20.3.6 路径比较</span><a href="#20-3-6-lu-jing-bi-jiao" class="header-anchor">#</a></h5><p>表路径比较列出了你可以用来比较两个不同路径的操作。<br>请注意，大多数比较不考虑文件系统，这意味着它们只进行词法操作，这很便宜，但可能会导致令人惊讶的返回值。</p>
<ul>
<li><p>使用==、!=和compare()，下列路径都是不同的。</p>
<div class="code-wrapper"><pre><code class="hljs bash">tmp1/f
./tmp1/f
tmp1/./f
tmp1/tmp11/../f</code></pre></div>

<table>
<thead>
<tr>
<th>调用</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>p1 == p2</td>
<td>产生两个路径是否相等</td>
</tr>
<tr>
<td>p1 != p2</td>
<td>得出两条路径是否不相等</td>
</tr>
<tr>
<td>p1 &lt; p2</td>
<td>产生一个路径是否小于另一个路径的结果</td>
</tr>
<tr>
<td>p1 &lt;= p2</td>
<td>产生一条路径是否小于或等于另一条路径</td>
</tr>
<tr>
<td>p1 &gt;= p2</td>
<td>产生一条路径是否大于或等于另一条路径</td>
</tr>
<tr>
<td>p1 &gt; p2</td>
<td>产生一条路径是否大于另一条路径</td>
</tr>
<tr>
<td>p.compare(p2)</td>
<td>得出p2是否小于、等于或大于p的结论</td>
</tr>
<tr>
<td>p.compare(sv)</td>
<td>产生p2是否小于、等于或大于字符串(view)的结果，sv转换为路径</td>
</tr>
<tr>
<td>equivalent(p1, p2)</td>
<td>考虑到文件系统的昂贵的路径比较</td>
</tr>
</tbody></table>
<ul>
<li><p>只检测指定目录分隔符的不同格式。因此，下列路径都是相同的（只要反斜线是有效的目录分隔符）。</p>
<div class="code-wrapper"><pre><code class="hljs c++">tmp1/f
/tmp1<span class="hljs-comment">//f</span>
/tmp1\f
tmp1/\/f</code></pre></div></li>
</ul>
<p>只有当你为每个路径调用lexically_normal()时，上面所有的路径才是相等的（只要反斜杠是有效的目录分隔符）。比如说:</p>
<div class="code-wrapper"><pre><code class="hljs c++">std::filesystem::path p1{<span class="hljs-string">"tmp1/f"</span>};
std::filesystem::path p2{<span class="hljs-string">"./tmp1/f"</span>};
p1 == p2 <span class="hljs-comment">// true</span>
p1.<span class="hljs-built_in">compare</span>(p2) <span class="hljs-comment">// not 0</span>
p1.<span class="hljs-built_in">lexically_normal</span>() == p2.<span class="hljs-built_in">lexically_normal</span>() <span class="hljs-comment">// true</span>
p1.<span class="hljs-built_in">lexically_normal</span>().<span class="hljs-built_in">compare</span>(p2.<span class="hljs-built_in">lexically_normal</span>()) <span class="hljs-comment">// 0</span></code></pre></div>

<p>如果你想把文件系统考虑进去，以便正确处理符号链接，你可以使用equivalent()。然而，请注意，这个函数要求两个路径都代表现有的文件。因此，一个尽可能准确地比较路径的通用方法（但没有最好的性能） 是这样的:</p>
<div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">pathsAreEqual</span><span class="hljs-params">(<span class="hljs-type">const</span> std::filesystem::path&amp; p1,</span></span>
<span class="hljs-params"><span class="hljs-function">                   <span class="hljs-type">const</span> std::filesystem::path&amp; p2)</span></span>
<span class="hljs-function"></span>{
    <span class="hljs-keyword">return</span> <span class="hljs-built_in">exists</span>(p1) &amp;&amp; <span class="hljs-built_in">exists</span>(p2) ? <span class="hljs-built_in">equivalent</span>(p1, p2)
        : p1.<span class="hljs-built_in">lexically_normal</span>() == p2.<span class="hljs-built_in">lexically_normal</span>();
}</code></pre></div></li>
</ul>
<h5><span id="20-3-7-qi-ta-lu-jing-cao-zuo">20.3.7 其他路径操作</span><a href="#20-3-7-qi-ta-lu-jing-cao-zuo" class="header-anchor">#</a></h5><p>表中其他路径操作列出了尚未列出的其余路径操作。</p>
<table>
<thead>
<tr>
<th>调用</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>p.hash_value()</td>
<td>产生一个路径的哈希值</td>
</tr>
</tbody></table>
<p>注意，只有相等的路径才有相同的哈希值。也就是说，以下的路径产生不同的 哈希值：</p>
<div class="code-wrapper"><pre><code class="hljs bash">tmp1/f
./tmp1/f
tmp1/./f
tmp1/tmp11/../f</code></pre></div>

<p>出于这个原因，你可能想在将路径放入哈希表之前将其规范化。</p>
<h4><span id="20-4-wen-jian-xi-tong-cao-zuo">20.4 文件系统操作</span><a href="#20-4-wen-jian-xi-tong-cao-zuo" class="header-anchor">#</a></h4><p>本节涵盖了考虑到当前文件系统的更昂贵的文件系统操作。<br>因为这些操作通常要考虑到文件系统（照顾现有文件、符号链接等），所以它们比纯路径操作要昂贵。 因此，它们通常是独立的函数。</p>
<h5><span id="20-4-1-wen-jian-shu-xing">20.4.1 文件属性</span><a href="#20-4-1-wen-jian-shu-xing" class="header-anchor">#</a></h5><ol>
<li>有几个属性你可以得到关于一个给定路径后面的文件。首先，表 “文件类型的操作 “列出了你可以调用的函数，以检查由路径p指定的文件是否存在以及它的整体类型（如果有的话）。注意，这些操作确实考虑到了文件系统，因此是独立的函数。</li>
<li>文件系统类型的函数与相应的file_type值相匹配。然而，请注意，这些函数（除了is_symlink()）遵循符号链接。也就是说，对于一个目录的符号链接，is_symlink()和is_directory()都会产生true。</li>
<li>还要注意的是，根据其他文件类型的定义，对于所有检查特殊文件（没有普通文件、没有目录、没有符号链接）的is_other()也会产生真值。</li>
<li>对于特定实现的文件类型，没有特定的便利函数，因此对它们来说 只有is_other()为真（如果我们有一个符号链接到这样的文件，则is_symlink()为真）。你可以 使用文件状态API来检查这些特定的类型。</li>
<li>为了不跟踪符号链接，使用symlink_status()并为返回的 file_status，正如接下来讨论的exists()。</li>
</ol>
<table>
<thead>
<tr>
<th>调用</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>exists(p)</td>
<td>产生是否有文件可以打开的结果</td>
</tr>
<tr>
<td>is_symlink(p)</td>
<td>产生文件p是否存在并且是一个符号链接</td>
</tr>
<tr>
<td>is_regular_file(p)</td>
<td>产生文件p是否存在并且是一个普通文件</td>
</tr>
<tr>
<td>is_directory(p)</td>
<td>产生文件p是否存在并且是一个目录</td>
</tr>
<tr>
<td>is_other(p)</td>
<td>产生文件是否存在 p 并且既不是常规也不是目录也不是符号链接</td>
</tr>
<tr>
<td>is_block_file(p)</td>
<td>产生文件p是否存在并且是一个块状的特殊文件</td>
</tr>
<tr>
<td>is_character_file(p)</td>
<td>产生文件p是否存在并且是一个特殊字符的文件</td>
</tr>
<tr>
<td>is_fifo(p)</td>
<td>产生文件 p 是否存在，并且是 FIFO 或管道文件</td>
</tr>
<tr>
<td>is_socket(p)</td>
<td>产生文件p是否存在并且是一个套接字文件</td>
</tr>
</tbody></table>
<h6><span id="jian-cha-wen-jian-shi-fou-cun-zai">检查文件是否存在</span><a href="#jian-cha-wen-jian-shi-fou-cun-zai" class="header-anchor">#</a></h6><p>exists()回答的问题是，是否有一个有效的文件可以打开。因此，正如刚才讨论的，它遵循符号链接。所以，如果有一个符号链接到一个不存在的文件，它就会产生错误。<br>因此，像这样的代码不会像预期的那样工作：</p>
<div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-comment">// 如果还没有做，就创建一个符号链接到文件:</span>
<span class="hljs-keyword">if</span> (!<span class="hljs-built_in">exists</span>(p)) { <span class="hljs-comment">// OOPS：检查p所指的文件是否不存在</span>
    std::filesystem::<span class="hljs-built_in">create_symlink</span>(file, p);
}</code></pre></div>

<p>如果p已经作为一个不存在的文件的符号链接存在，它将尝试在已经存在符号链接的位置创建符号链接，并引发一个相应的异常。</p>
<p>因为多用户/多进程文件系统中的情况可能随时发生变化，通常最好的办法是尝试执行一个操作，并在操作失败时处理错误。因此，我们可以简单地调用操作并处理相应的异常或处理作为附加参数传递的错误代码。</p>
<p>然而，有时你需要检查一个文件是否存在（在执行文件系统操作之前）。例如，如果你想在一个特定的位置创建一个文件，而那里已经有一个符号链接，那么这个文件就会在一个可能意想不到的位置被创建或被覆盖。在这种情况下，你 在这种情况下，你应该检查文件是否存在，方法如下:</p>
<div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">if</span> (!<span class="hljs-built_in">exists</span>(<span class="hljs-built_in">symlink_status</span>(p))) { <span class="hljs-comment">// OK: 检查p是否还不存在（作为符号链接）。</span>
    ...
}</code></pre></div>

<p>这里我们使用symlink_status()，它产生的是不跟随符号链接的状态，来检查 检查在p的位置是否存在任何文件。</p>
<h6><span id="qi-ta-wen-jian-shu-xing">其他文件属性</span><a href="#qi-ta-wen-jian-shu-xing" class="header-anchor">#</a></h6><p>文件属性的表操作列出了几个独立的函数来检查额外的文件属性。</p>
<table>
<thead>
<tr>
<th>调用</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>is_empty(p)</td>
<td>产生文件是否为空</td>
</tr>
<tr>
<td>file_size(p)</td>
<td>产生文件的大小</td>
</tr>
<tr>
<td>hard_link_count(p)</td>
<td>产生硬链接的数量</td>
</tr>
<tr>
<td>last_write_time(p)</td>
<td>产生最后一次写到一个文件的时间点</td>
</tr>
</tbody></table>
<p>请注意，一个路径是否为空和一个路径所指定的文件是否为是空的：</p>
<div class="code-wrapper"><pre><code class="hljs c++">p.<span class="hljs-built_in">empty</span>() <span class="hljs-comment">// 如果路径p是空的，则为真（廉价操作）。</span>
<span class="hljs-built_in">is_empty</span>(p) <span class="hljs-comment">// 如果路径p上的文件是空的，则为真(文件系统操作)</span></code></pre></div>

<p>file_size(p)返回文件p的大小，如果它作为常规文件存在的话（就像POSIX函数stat()的成员st_size一样）。对于所有其他的文件，其结果是执行定义的，不可移植。<br>hard_link_count(p) 返回一个文件在文件系统中存在的次数。通常这个数字是1，但在某些文件系统中，同一个文件可以存在于文件系统的不同位置（即有不同的路径）。这与符号链接不同，在符号链接中，一个文件指的是另一个文件。在这里，我们有一个具有不同路径的文件，可以直接访问它。只有当最后一个硬链接被删除时，文件本身才会被删除。文件本身也会被删除。</p>
<h6><span id="chu-li-zui-hou-yi-ci-xiu-gai">处理最后一次修改</span><a href="#chu-li-zui-hou-yi-ci-xiu-gai" class="header-anchor">#</a></h6><p>last_write_time(p)返回文件最后一次修改或写入的时间点。返回类型是标准Chrono库中用于时间点的特殊time_point类型:</p>
<div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">namespace</span> std::filesystem {
    <span class="hljs-keyword">using</span> file_time_type = chrono::time_point&lt;trivialClock&gt;;
}</code></pre></div>

<p>时钟类型trivialClock是一个特定实现的时钟类型，反映了文件时间值的分辨率和范围。例如，你可以按以下方式使用它:</p>
<div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">printFileTime</span><span class="hljs-params">(<span class="hljs-type">const</span> std::filesystem::path&amp; p)</span></span>
<span class="hljs-function"></span>{
    <span class="hljs-keyword">auto</span> filetime = <span class="hljs-built_in">last_write_time</span>(p);
    <span class="hljs-keyword">auto</span> diff = std::filesystem::file_time_type::clock::<span class="hljs-built_in">now</span>() - filetime;
    std::cout &lt;&lt; p &lt;&lt; <span class="hljs-string">" is "</span>
        &lt;&lt; std::chrono::<span class="hljs-built_in">duration_cast</span>&lt;std::chrono::seconds&gt;(diff).<span class="hljs-built_in">count</span>()
        &lt;&lt; <span class="hljs-string">" Seconds old.\n"</span>;
}</code></pre></div>

<p>这可能会输出:</p>
<div class="code-wrapper"><pre><code class="hljs bash"><span class="hljs-string">"fileattr.cpp"</span> is 4 Seconds old.</code></pre></div>

<p>而不是</p>
<div class="code-wrapper"><pre><code class="hljs c++">std::filesystem::file_time_type::clock::<span class="hljs-built_in">now</span>()</code></pre></div>

<p>在这个例子中，你也可以这样写:</p>
<div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">decltype</span>(filetime)::clock::<span class="hljs-built_in">now</span>()</code></pre></div>

<p>请注意，文件系统时间点使用的时钟并不保证是标准的system_clock。由于这个原因，目前还没有标准化的支持将文件系统的时间点转换为time_t类型，以便在字符串或输出中使用它作为绝对时间。下面的函数 “大致 “地将任何时钟的时间点转换为time_t对象:</p>
<div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> TimePoint&gt;</span>
<span class="hljs-function">std::<span class="hljs-type">time_t</span> <span class="hljs-title">toTimeT</span><span class="hljs-params">(TimePoint tp)</span></span>
<span class="hljs-function"></span>{
    <span class="hljs-keyword">using</span> system_clock = std::chrono::system_clock;
    <span class="hljs-keyword">return</span> system_clock::<span class="hljs-built_in">to_time_t</span>(system_clock::<span class="hljs-built_in">now</span>()
                                   + (tp - <span class="hljs-keyword">decltype</span>(tp)::clock::<span class="hljs-built_in">now</span>()));
}</code></pre></div>

<p>诀窍是计算出文件系统时间点相对于现在的持续时间，然后把这个差值加到系统时钟的当前时间上。这个函数并不精确，因为两个时钟可能有不同的分辨率，而且我们在稍微不同的时间调用now()两次。然而，在一般情况下 一般来说，这样做效果很好。<br>例如，对于一个路径p，我们可以调用:</p>
<div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">auto</span> ftime = <span class="hljs-built_in">last_write_time</span>(p);
std::<span class="hljs-type">time_t</span> t = <span class="hljs-built_in">toTimeT</span>(ftime);
<span class="hljs-comment">// 转换为日历时间（包括跳过尾部换行）。:</span>
std::string ts = <span class="hljs-built_in">ctime</span>(&amp;t);
ts.<span class="hljs-built_in">resize</span>(ts.<span class="hljs-built_in">size</span>()<span class="hljs-number">-1</span>);
std::cout &lt;&lt; <span class="hljs-string">"last access of "</span> &lt;&lt; p &lt;&lt; <span class="hljs-string">": "</span> &lt;&lt; ts &lt;&lt; <span class="hljs-string">'\n'</span>;</code></pre></div>

<p>其中可能会打印:</p>
<div class="code-wrapper"><pre><code class="hljs bash">last access of <span class="hljs-string">"fileattr.exe"</span>: Sun Jun 24 10:41:12 2018</code></pre></div>

<p>为了以我们想要的方式格式化一个字符串，我们可以调用:</p>
<div class="code-wrapper"><pre><code class="hljs c++">std::<span class="hljs-type">time_t</span> t = <span class="hljs-built_in">toTimeT</span>(ftime);
<span class="hljs-type">char</span> mbstr[<span class="hljs-number">100</span>];
<span class="hljs-keyword">if</span> (std::<span class="hljs-built_in">strftime</span>(mbstr, <span class="hljs-built_in">sizeof</span>(mbstr), <span class="hljs-string">"last access: %B %d, %Y at %H:%M\n"</span>,
                  std::<span class="hljs-built_in">localtime</span>(&amp;t))) {
    std::cout &lt;&lt; mbstr;
}</code></pre></div>

<p>这可能会输出:</p>
<div class="code-wrapper"><pre><code class="hljs bash">last access: June 24, 2018 at 10:41</code></pre></div>

<p>将任何文件系统的时间点转换为字符串的一个有用的辅助工具是:</p>
<p><code>filesystem/ftimeAsString.hpp </code></p>
<div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;chrono&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;filesystem&gt;</span></span>
<span class="hljs-function">std::string <span class="hljs-title">asString</span><span class="hljs-params">(<span class="hljs-type">const</span> std::filesystem::file_time_type&amp; ft)</span></span>
<span class="hljs-function"></span>{
    <span class="hljs-keyword">using</span> system_clock = std::chrono::system_clock;
    <span class="hljs-keyword">auto</span> t = system_clock::<span class="hljs-built_in">to_time_t</span>(system_clock::<span class="hljs-built_in">now</span>()
                                     + (ft - std::filesystem::file_time_type::clock::<span class="hljs-built_in">now</span>()));
    <span class="hljs-comment">// 转换为日历时间（包括跳过尾部的新行）。</span>
    std::string ts = <span class="hljs-built_in">ctime</span>(&amp;t);
    ts.<span class="hljs-built_in">resize</span>(ts.<span class="hljs-built_in">size</span>()<span class="hljs-number">-1</span>);
    <span class="hljs-keyword">return</span> ts;
}</code></pre></div>

<p>注意，ctime()和strftime()不是线程安全的，不能同时调用。<br>请参阅修改现有文件，了解修改最后一次写入权限的相应API。</p>
<h5><span id="20-4-2-wen-jian-zhuang-tai">20.4.2 文件状态</span><a href="#20-4-2-wen-jian-zhuang-tai" class="header-anchor">#</a></h5><p>为了避免文件系统的访问，有一个特殊的类型file_status，可以用来保持和修改缓存的文件类型和权限。<br>缓存的文件类型和权限。这个状态可以在询问特定路径的文件状态时被设置。</p>
<ul>
<li><p>当询问特定路径的文件状态时，如表 “文件状态的操作 “中所列。</p>
</li>
<li><p>当在一个目录上迭代时</p>
<table>
<thead>
<tr>
<th>调用</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>status(p)</td>
<td>产生文件p的file_status（包括符号链接)</td>
</tr>
<tr>
<td>symlink_status(p)</td>
<td>读取p的文件状态（不遵循符号链接）</td>
</tr>
</tbody></table>
</li>
</ul>
<p>不同的是，如果路径p在符号链接中解析，status()跟随链接并打印那里的文件属性（状态可能是没有文件），而symlink_status(p)打印的是符号链接本身的状态。<br>表file_status Operations列出了对file_status对象fs的可能调用。</p>
<table>
<thead>
<tr>
<th>调用</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>exists(fs)</td>
<td>产生一个文件是否存在。</td>
</tr>
<tr>
<td>is_regular_file(fs)</td>
<td>产生文件是否存在并且是一个常规文件</td>
</tr>
<tr>
<td>is_directory(fs)</td>
<td>产生文件是否存在并且是一个目录。</td>
</tr>
<tr>
<td>is_symlink(fs)</td>
<td>产生文件是否存在并且是一个符号链接。</td>
</tr>
<tr>
<td>is_other(fs)</td>
<td>产生文件是否存在，并且既不是普通文件也不是目录<br>也不是象征性链接</td>
</tr>
<tr>
<td>is_character_file(fs)</td>
<td>产生文件是否存在并且是一个特殊字符的文件。</td>
</tr>
<tr>
<td>is_block_file(fs)</td>
<td>产生文件是否存在并且是一个块状特殊文件。</td>
</tr>
<tr>
<td>is_fifo(fs)</td>
<td>产生文件是否存在并且是FIFO或管道文件</td>
</tr>
<tr>
<td>is_socket(fs)</td>
<td>产生文件是否存在并且是一个套接字。</td>
</tr>
<tr>
<td>fs.type()</td>
<td>产生文件的文件类型。</td>
</tr>
<tr>
<td>fs.permissions()</td>
<td>产生文件的权限。</td>
</tr>
</tbody></table>
<p>状态操作的一个好处是，你可以为同一个文件保存多个操作系统的调用。同一个文件。例如，不使用</p>
<div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">if</span> (!<span class="hljs-built_in">is_directory</span>(path)) {
    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">is_character_file</span>(path) || <span class="hljs-built_in">is_block_file</span>(path)) {
        ...
    }
    ...
}</code></pre></div>

<p>你最好执行:</p>
<div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">auto</span> pathStatus{<span class="hljs-built_in">status</span>(path)};
<span class="hljs-keyword">if</span> (!<span class="hljs-built_in">is_directory</span>(pathStatus)) {
    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">is_character_file</span>(pathStatus) || <span class="hljs-built_in">is_block_file</span>(pathStatus)) {
        ...
    }
    ...
}</code></pre></div>

<p>另一个关键的好处是，通过使用symlink_status()，你可以在不遵循任何符号链接的情况下检查路径的状态。例如，这有助于检查某个特定路径上是否存在任何文件。<br>因为这些文件状态不使用操作系统，所以不提供返回错误代码的重载。提供。</p>
<p>路径参数的exists()和is_…()函数是调用和检查文件状态的type()的捷径。比如说:</p>
<div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-built_in">is_regular_file</span>(mypath)</code></pre></div>

<p>快捷方式:</p>
<div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-built_in">is_regular_file</span>(<span class="hljs-built_in">status</span>(mypath))</code></pre></div>

<p>捷径，它是</p>
<div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-built_in">status</span>(mypath).<span class="hljs-built_in">type</span>() == file_type::regular</code></pre></div>

<h5><span id="20-4-3-quan-xian">20.4.3 权限</span><a href="#20-4-3-quan-xian" class="header-anchor">#</a></h5><p>处理文件权限的模式是从UNIX/POSIX世界中采用的。有一些位来表示对文件所有者、同一组的成员或所有其他人的阅读、写入和/或执行/搜索访问。此外，还有 “执行时设置用户ID”、”执行时设置组ID “和粘性位（或其他与系统有关的含义）的特殊位。<br>表Permission Bits列出了在命名空间std::filesystem中定义的bitmask范围枚举类型perms的值，它代表一个或多个权限位。</p>
<table>
<thead>
<tr>
<th>枚举</th>
<th>八进制</th>
<th>POSIX</th>
<th>意义</th>
</tr>
</thead>
<tbody><tr>
<td>none</td>
<td>0</td>
<td></td>
<td>未设置权限</td>
</tr>
<tr>
<td>owner_read</td>
<td>0400</td>
<td>S_IRUSR</td>
<td>对所有者的阅读权限</td>
</tr>
<tr>
<td>owner_write</td>
<td>0200</td>
<td>S_IWUSR</td>
<td>对所有者的写入权限</td>
</tr>
<tr>
<td>owner_exec</td>
<td>0100</td>
<td>S_IXUSR</td>
<td>所有者的执行/搜索权限</td>
</tr>
<tr>
<td>owner_all</td>
<td>0700</td>
<td>S_IRWXU</td>
<td>所有者的所有权限</td>
</tr>
<tr>
<td>group_read</td>
<td>040</td>
<td>S_IRGRP</td>
<td>组的读取权限</td>
</tr>
<tr>
<td>group_write</td>
<td>020</td>
<td>S_IWGRP</td>
<td>组的写入权限</td>
</tr>
<tr>
<td>group_exec</td>
<td>010</td>
<td>S_IXGRP</td>
<td>组的执行/搜索权限</td>
</tr>
<tr>
<td>group_all</td>
<td>070</td>
<td>S_IRWXG</td>
<td>群组的所有权限</td>
</tr>
<tr>
<td>others_read</td>
<td>04</td>
<td>S_IROTH</td>
<td>所有其他人的读取权限</td>
</tr>
<tr>
<td>others_write</td>
<td>02</td>
<td>S_IWOTH</td>
<td>所有其他人的写入权限</td>
</tr>
<tr>
<td>others_exec</td>
<td>01</td>
<td>S_IXOTH</td>
<td>所有其他人的执行/搜索权限</td>
</tr>
<tr>
<td>others_all</td>
<td>07</td>
<td>S_IRWXO</td>
<td>所有其他人的所有权限</td>
</tr>
<tr>
<td>all</td>
<td>0777</td>
<td></td>
<td>所有人的所有权限</td>
</tr>
<tr>
<td>set_uid</td>
<td>04000</td>
<td>S_ISUID</td>
<td>在执行时设置用户 ID</td>
</tr>
<tr>
<td>set_gid</td>
<td>02000</td>
<td>S_ISGID</td>
<td>在执行时设置组 ID</td>
</tr>
<tr>
<td>sticky_bit</td>
<td>01000</td>
<td>S_ISVTX</td>
<td>依赖于操作系统</td>
</tr>
<tr>
<td>mask</td>
<td>07000</td>
<td></td>
<td>所有可能位掩码</td>
</tr>
<tr>
<td>unkonwn</td>
<td>0xFFFF</td>
<td></td>
<td>权限未知</td>
</tr>
</tbody></table>
<p>你可以询问当前的权限，结果是检查返回的perms对象的位。<br>为了组合标志，你必须使用位操作符。比如说：</p>
<div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-comment">// 如果可写:</span>
<span class="hljs-keyword">if</span> ((fileStatus.<span class="hljs-built_in">permissions</span>()
     &amp; (fs::perms::owner_write | fs::perms::group_write
        | fs::perms::others_write))
    != fs::perms::none) {
    ...
}</code></pre></div>

<p>初始化比特掩码的一个更短的方法（但可能不太容易读懂）是直接使用相应的八进制值和放松枚举的初始化:</p>
<div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-comment">// 如果可写:</span>
<span class="hljs-keyword">if</span> ((fileStatus.<span class="hljs-built_in">permissions</span>() &amp; fs::perms{<span class="hljs-number">0222</span>}) != fs::perms::none) {
    ...
}</code></pre></div>

<p>注意，在将结果与特定的值进行比较之前，你必须将&amp;表达式放在括号里。还要注意的是，你不能跳过比较，因为对于比特掩码范围的枚举类型，没有隐含的转换为bool。<br>再比如，要把一个文件的权限转换为UNIX ls -l命令中的字符串，你可以使用下面的辅助函数:</p>
<p><code>filesystem/permAsString.hpp</code></p>
<div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;chrono&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;filesystem&gt;</span></span>
<span class="hljs-function">std::string <span class="hljs-title">asString</span><span class="hljs-params">(<span class="hljs-type">const</span> std::filesystem::perms&amp; pm)</span></span>
<span class="hljs-function"></span>{
    <span class="hljs-keyword">using</span> perms = std::filesystem::perms;
    std::string s;
    s.<span class="hljs-built_in">resize</span>(<span class="hljs-number">9</span>);
    s[<span class="hljs-number">0</span>] = (pm &amp; perms::owner_read) != perms::none ? <span class="hljs-string">'r'</span> : <span class="hljs-string">'-'</span>;
    s[<span class="hljs-number">1</span>] = (pm &amp; perms::owner_write) != perms::none ? <span class="hljs-string">'w'</span> : <span class="hljs-string">'-'</span>;
    s[<span class="hljs-number">2</span>] = (pm &amp; perms::owner_exec) != perms::none ? <span class="hljs-string">'x'</span> : <span class="hljs-string">'-'</span>;
    s[<span class="hljs-number">3</span>] = (pm &amp; perms::group_read) != perms::none ? <span class="hljs-string">'r'</span> : <span class="hljs-string">'-'</span>;
    s[<span class="hljs-number">4</span>] = (pm &amp; perms::group_write) != perms::none ? <span class="hljs-string">'w'</span> : <span class="hljs-string">'-'</span>;
    s[<span class="hljs-number">5</span>] = (pm &amp; perms::group_exec) != perms::none ? <span class="hljs-string">'x'</span> : <span class="hljs-string">'-'</span>;
    s[<span class="hljs-number">6</span>] = (pm &amp; perms::others_read) != perms::none ? <span class="hljs-string">'r'</span> : <span class="hljs-string">'-'</span>;
    s[<span class="hljs-number">7</span>] = (pm &amp; perms::others_write) != perms::none ? <span class="hljs-string">'w'</span> : <span class="hljs-string">'-'</span>;
    s[<span class="hljs-number">8</span>] = (pm &amp; perms::others_exec) != perms::none ? <span class="hljs-string">'x'</span> : <span class="hljs-string">'-'</span>;
    <span class="hljs-keyword">return</span> s;
}</code></pre></div>

<p>这允许你打印一个文件的权限，作为标准ostream命令的一部分:</p>
<div class="code-wrapper"><pre><code class="hljs c++">std::cout &lt;&lt; <span class="hljs-string">"permissions: "</span> &lt;&lt; <span class="hljs-built_in">asString</span>(<span class="hljs-built_in">status</span>(mypath).<span class="hljs-built_in">permissions</span>())
    &lt;&lt; <span class="hljs-string">'\n'</span>;</code></pre></div>

<p>对于一个拥有所有者所有权限和所有其他人的读/执行权限的文件，可能的输出结果是:</p>
<div class="code-wrapper"><pre><code class="hljs bash">permissions: rwxr-xr-x</code></pre></div>

<p>然而，请注意，Windows的ACL（访问控制列表）方法并不真正适合这个方案。由于这个原因，在使用Visual C++时，可写文件总是设置了所有的读、写和执行位（即使它们不是可执行文件），带有只读标志的文件总是设置了所有的读和可执行位。这也影响了可移植地修改权限的API。</p>
<h5><span id="20-4-4-wen-jian-xi-tong-de-xiu-gai">20.4.4 文件系统的修改</span><a href="#20-4-4-wen-jian-xi-tong-de-xiu-gai" class="header-anchor">#</a></h5><p>你也可以通过创建和删除文件或修改现有文件来修改文件系统。</p>
<h6><span id="chuang-jian-he-shan-chu-wen-jian">创建和删除文件</span><a href="#chuang-jian-he-shan-chu-wen-jian" class="header-anchor">#</a></h6><p>创建和删除文件表列出了路径 p 创建和删除文件的操作。</p>
<table>
<thead>
<tr>
<th>调用</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>create_directory(p)</td>
<td>创建一个目录</td>
</tr>
<tr>
<td>create_directory(p, attrPath)</td>
<td>创建一个具有attrPath属性的目录。</td>
</tr>
<tr>
<td>create_directories(p)</td>
<td>创建一个目录和上面的所有目录，还不存在的目录</td>
</tr>
<tr>
<td>create_hard_link(old, new)</td>
<td>创建另一个文件系统的条目，以取代现有的文件old</td>
</tr>
<tr>
<td>create_symlink(to, new)</td>
<td>创建一个符号链接，从新文件到新文件。</td>
</tr>
<tr>
<td>create_directory_symlink(to, new)</td>
<td>创建一个符号链接，从新的目录连接到</td>
</tr>
<tr>
<td>copy(from, to)</td>
<td>复制一个任何类型的文件</td>
</tr>
<tr>
<td>copy(from, to, options)</td>
<td>复制一个带有选项的任何类型的文件</td>
</tr>
<tr>
<td>copy_file(from, to)</td>
<td>复制一个文件（但不是目录或符号链接）</td>
</tr>
<tr>
<td>copy_file(from, to, options)</td>
<td>拷贝一个带有选项的文件</td>
</tr>
<tr>
<td>copy_symlink(from, to)</td>
<td>复制一个符号链接（to指的是from指的地方）。</td>
</tr>
<tr>
<td>remove(p)</td>
<td>remove(p) 删除一个文件或空目录</td>
</tr>
<tr>
<td>remove_all(p)</td>
<td>删除p和其子树中的所有文件（如果有的话）任何）。</td>
</tr>
</tbody></table>
<p>没有创建普通文件的功能。这是由I/O流标准库涵盖的。<br>例如，下面的语句创建一个新的空文件（如果它还不存在）:</p>
<div class="code-wrapper"><pre><code class="hljs c++">std::ofstream{<span class="hljs-string">"log.txt"</span>};</code></pre></div>

<p>创建一个或多个目录的函数会返回是否创建了一个新目录。 因此，查找已经存在的目录不会出错。 但是，在那里找到不是目录的文件也不是错误。 因此，在 create_directory() 或 create_directories() 返回 false 之后，您不知道是否已经存在请求的目录或其他内容。 当然，如果您之后对该文件执行特定于目录的操作并获得异常，您会发现它可能没问题（因为处理这个罕见的问题可能不值得付出努力）。 但是，如果您想要更正错误消息或出于其他原因必须确保确实有一个目录，您必须执行以下操作：</p>
<div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">if</span> (!<span class="hljs-built_in">create_directory</span>(myPath) &amp;&amp; !<span class="hljs-built_in">is_directory</span>(myPath)) {
    std::cerr &lt;&lt; <span class="hljs-string">"OOPS, \""</span> &lt;&lt; myPath.<span class="hljs-built_in">string</span>() &lt;&lt; <span class="hljs-string">"\" is already something else\n"</span>;
    ... <span class="hljs-comment">// 处理这个错误</span>
}</code></pre></div>

<p>copy…() 函数不适用于特殊文件类型。 默认情况下，它们：</p>
<ul>
<li><p>如果现有文件被覆盖，则报告错误</p>
</li>
<li><p>不要递归操作</p>
</li>
<li><p>按照符号链接<br>这个默认值可以被参数 options 覆盖，它具有位掩码范围的枚举类型 copy_options，定义在命名空间 std::filesystem 中。 表复制选项。 列出可能的值。</p>
<table>
<thead>
<tr>
<th>复制选项</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>none</td>
<td>默认值（值 0）</td>
</tr>
<tr>
<td>skip_existing</td>
<td>跳过覆盖现有文件</td>
</tr>
<tr>
<td>overwrite_existing</td>
<td>覆盖现有文件</td>
</tr>
<tr>
<td>update_existing</td>
<td>如果新文件较新，则覆盖现有文件</td>
</tr>
<tr>
<td>recursive</td>
<td>递归复制子目录及其内容</td>
</tr>
<tr>
<td>copy_symlinks</td>
<td>将符号链接复制为符号链接</td>
</tr>
<tr>
<td>skip_symlinks</td>
<td>忽略符号链接</td>
</tr>
<tr>
<td>directories_only</td>
<td>仅复制目录</td>
</tr>
<tr>
<td>create_hard_links</td>
<td>创建额外的硬链接而不是文件副本</td>
</tr>
<tr>
<td>create_symlinks</td>
<td>创建符号链接而不是文件副本（源路径必须是<br>绝对路径，除非目标路径在当前目录中）</td>
</tr>
</tbody></table>
<p>rename() 可以处理任何类型的文件，包括目录和符号链接。 对于符号链接，链接被重命名，而不是它所指的位置。 请注意， rename() 需要包含文件名的完整新路径才能将其移动到不同的目录：</p>
<div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-comment">// move "tmp/sub/x" to "tmp/x":</span>
std::filesystem::<span class="hljs-built_in">rename</span>(<span class="hljs-string">"tmp/sub/x"</span>, <span class="hljs-string">"top"</span>); <span class="hljs-comment">// ERROR</span>
std::filesystem::<span class="hljs-built_in">rename</span>(<span class="hljs-string">"tmp/sub/x"</span>, <span class="hljs-string">"top/x"</span>); <span class="hljs-comment">// OK</span></code></pre></div>

<p>last_write_time() 使用处理上次修改中描述的时间点格式。 例如：</p>
<div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-comment">// 创建文件p（更新最后的文件访问）。:</span>
<span class="hljs-built_in">last_write_time</span>(p, std::filesystem::file_time_type::clock::<span class="hljs-built_in">now</span>());</code></pre></div>

<p>permissions() 使用权限中描述的权限 API 格式。 可选模式是位掩码枚举类型 perm_options，在命名空间 std::filesystem 中定义。 它一方面允许在替换、添加和删除之间进行选择，另一方面允许使用 nofollow 来修改符号链接而不是它们所引用的文件的权限。<br>例如：</p>
<div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-comment">// 删除组的写访问权限和其他人的任何访问权限:</span>
<span class="hljs-built_in">permissions</span>(mypath,
            std::filesystem::perms::group_write
            | std::filesystem::perms::others_all,
            std::filesystem::perm_options::remove);</code></pre></div>

<p>再次注意，Windows 由于其 ACL 权限概念仅支持两种模式：</p>
<ul>
<li><p>读取、写入和执行/搜索所有 (rwxrwxrwx)</p>
</li>
<li><p>读取、执行/搜索所有（r-xr-xr-x）<br>要在这两种模式之间进行可移植的切换，您必须同时启用或禁用所有三个写入标志（一个接一个地删除不起作用）：</p>
<div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-comment">// 启用/禁用写访问的可移植值:</span>
<span class="hljs-keyword">auto</span> allWrite = std::filesystem::perms::owner_write
| std::filesystem::perms::group_write
| std::filesystem::perms::others_write;
<span class="hljs-comment">// 可移植地删除写入权限:</span>
<span class="hljs-built_in">permissions</span>(file, allWrite, std::filesystem::perm_options::remove);</code></pre></div>

<p>初始化allWrite的一个更短的方法（但可能不那么好读）（使用放松的枚举初始化）如下。:</p>
<div class="code-wrapper"><pre><code class="hljs c++">std::filesystem::perms allWrite{<span class="hljs-number">0222</span>};</code></pre></div>

<p>resize_file() 可用于减小或扩展常规文件的大小：例如：</p>
<div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-comment">// 使文件为空:</span>
<span class="hljs-built_in">resize_file</span>(file, <span class="hljs-number">0</span>);
</code></pre></div></li>
</ul>
</li>
</ul>
<h5><span id="20-4-5-fu-hao-lian-jie-he-yi-lai-wen-jian-xi-tong-de-lu-jing-zhuan-huan">20.4.5 符号链接和依赖文件系统的路径转换</span><a href="#20-4-5-fu-hao-lian-jie-he-yi-lai-wen-jian-xi-tong-de-lu-jing-zhuan-huan" class="header-anchor">#</a></h5><p>表中文件系统路径转换列出了处理文件路径的操作，其中考虑到了文件系统。如果你需要处理符号链接，这一点尤其重要。对于不考虑文件系统的廉价路径转换，请参见纯路径转换。<br>注意，这些调用对文件是否必须存在、是否规范化以及是否遵循符号链接的处理方式不同。表中的文件系统路径转换属性给出了这些函数的要求和执行情况的概述。<br>下面的函数演示了大多数这些操作的用法和效果（在处理符号链接时）:</p>
<p><code>filesystem/symlink.hpp </code></p>
<table>
<thead>
<tr>
<th align="left">调用</th>
<th align="left">作用</th>
</tr>
</thead>
<tbody><tr>
<td align="left">read_symlink(symlink)</td>
<td align="left">产生现有符号链接引用的文件</td>
</tr>
<tr>
<td align="left">absolute(p)</td>
<td align="left">产生现有的 p 作为绝对路径（不遵循符号链接）</td>
</tr>
<tr>
<td align="left">canonical(p)</td>
<td align="left">产生现有的 p 作为绝对路径（遵循符号链接）</td>
</tr>
<tr>
<td align="left">weakly_canonical(p)</td>
<td align="left">产生 p 作为绝对路径（遵循符号链接）</td>
</tr>
<tr>
<td align="left">relative(p)</td>
<td align="left">产生从当前目录到 p 的相对（或空）路径</td>
</tr>
<tr>
<td align="left">relative(p, base)</td>
<td align="left">产生从 base 到 p 的相对（或空）路径</td>
</tr>
<tr>
<td align="left">proximate(p)</td>
<td align="left">产生从当前目录到 p 的相对（或绝对）路径</td>
</tr>
<tr>
<td align="left">proximate(p, base)</td>
<td align="left">产生从 base 到 p 的相对（或绝对）路径</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th align="left">调用</th>
<th align="left">必须存在</th>
<th align="left">规范化</th>
<th align="left">遵循符号链接</th>
</tr>
</thead>
<tbody><tr>
<td align="left">read_symlink()</td>
<td align="left">yes</td>
<td align="left">yes</td>
<td align="left">once</td>
</tr>
<tr>
<td align="left">absolute()</td>
<td align="left">no</td>
<td align="left">yes</td>
<td align="left">no</td>
</tr>
<tr>
<td align="left">canonical()</td>
<td align="left">yes</td>
<td align="left">yes</td>
<td align="left">all</td>
</tr>
<tr>
<td align="left">weakly_canonical()</td>
<td align="left">no</td>
<td align="left">yes</td>
<td align="left">all</td>
</tr>
<tr>
<td align="left">relative()</td>
<td align="left">no</td>
<td align="left">yes</td>
<td align="left">all</td>
</tr>
<tr>
<td align="left">proximate()</td>
<td align="left">no</td>
<td align="left">yes</td>
<td align="left">all</td>
</tr>
</tbody></table>
<div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;filesystem&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span>
<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">testSymLink</span><span class="hljs-params">(std::filesystem::path top)</span></span>
<span class="hljs-function"></span>{
    top = <span class="hljs-built_in">absolute</span>(top); <span class="hljs-comment">// 在我们更改当前路径时使用绝对路径</span>
    <span class="hljs-built_in">create_directory</span>(top); <span class="hljs-comment">// 确保 top 存在</span>
    <span class="hljs-built_in">current_path</span>(top); <span class="hljs-comment">// 这样我们就可以将目录更改为它</span>
    std::cout &lt;&lt; std::filesystem::<span class="hljs-built_in">current_path</span>() &lt;&lt; <span class="hljs-string">'\n'</span>; <span class="hljs-comment">// 打印top路径</span>
    <span class="hljs-comment">// 定义我们的子目录（不创建它们）:</span>
    std::filesystem::path px{top / <span class="hljs-string">"a/x"</span>};
    std::filesystem::path py{top / <span class="hljs-string">"a/y"</span>};
    std::filesystem::path ps{top / <span class="hljs-string">"a/s"</span>};
    <span class="hljs-comment">// 打印一些相对路径（对于不存在的文件）：</span>
    std::cout &lt;&lt; px.<span class="hljs-built_in">relative_path</span>() &lt;&lt; <span class="hljs-string">'\n'</span>; <span class="hljs-comment">// 相对路径，从top</span>
    std::cout &lt;&lt; px.<span class="hljs-built_in">lexically_relative</span>(py) &lt;&lt; <span class="hljs-string">'\n'</span>; <span class="hljs-comment">// 从 py 到 px: "../x"</span>
    std::cout &lt;&lt; <span class="hljs-built_in">relative</span>(px, py) &lt;&lt; <span class="hljs-string">'\n'</span>; <span class="hljs-comment">// 从 py 到 px: "../x"</span>
    std::cout &lt;&lt; <span class="hljs-built_in">relative</span>(px) &lt;&lt; <span class="hljs-string">'\n'</span>; <span class="hljs-comment">// 从curr.path到px : "a/x"</span>
    std::cout &lt;&lt; px.<span class="hljs-built_in">lexically_relative</span>(ps) &lt;&lt; <span class="hljs-string">'\n'</span>; <span class="hljs-comment">// 从 ps 到 px: "../x"</span>
    std::cout &lt;&lt; <span class="hljs-built_in">relative</span>(px, ps) &lt;&lt; <span class="hljs-string">'\n'</span>; <span class="hljs-comment">// 从 ps 到 px: "../x"</span>
    <span class="hljs-comment">// 现在创建所有子目录和符号链接:</span>
    <span class="hljs-built_in">create_directories</span>(px);
    <span class="hljs-built_in">create_directories</span>(py);
    <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">is_symlink</span>(ps)) {
        <span class="hljs-built_in">create_directory_symlink</span>(top, ps);
    }
    std::cout &lt;&lt; <span class="hljs-string">"ps: "</span> &lt;&lt; ps &lt;&lt; <span class="hljs-string">'\n'</span>
        &lt;&lt; <span class="hljs-string">" -&gt; "</span> &lt;&lt; <span class="hljs-built_in">read_symlink</span>(ps) &lt;&lt; <span class="hljs-string">'\n'</span>;
    <span class="hljs-comment">// 并查看词法和文件系统相关之间的区别:</span>
    std::cout &lt;&lt; px.<span class="hljs-built_in">lexically_relative</span>(ps) &lt;&lt; <span class="hljs-string">'\n'</span>; <span class="hljs-comment">// 从 ps 到 px: "../x"</span>
    std::cout &lt;&lt; <span class="hljs-built_in">relative</span>(px, ps) &lt;&lt; <span class="hljs-string">'\n'</span>; <span class="hljs-comment">// 从 ps 到 px: "a/x"</span>
}</code></pre></div>

<p>注意，我们首先将可能的相对路径转换为绝对路径，因为否则改变当前路径会影响路径变量的位置。 relative_path()和lexically_relative()是廉价的路径成员函数，没有考虑到实际的文件系统。因此，它们忽略了符号链接。独立的函数relative()<br>将文件系统考虑在内。只要我们还没有文件，它的作用就像lexically_relative()。但在创建符号链接ps（top/a/s）之后，它就会跟随符号链接，并给出不同的结果。<br>在POSIX系统中，从”/tmp “调用该函数，参数为 “top”，其输出结果如下:</p>
<div class="code-wrapper"><pre><code class="hljs bash"><span class="hljs-string">"/tmp/sub"</span>
<span class="hljs-string">"tmp/sub/a/x"</span>
<span class="hljs-string">"../x"</span>
<span class="hljs-string">"../x"</span>
<span class="hljs-string">"a/x"</span>
<span class="hljs-string">"../x"</span>
<span class="hljs-string">"../x"</span>
ps: <span class="hljs-string">"/tmp/sub/a/s"</span> -&gt; <span class="hljs-string">"/tmp/sub"</span>
<span class="hljs-string">"../x"</span>
<span class="hljs-string">"a/x"</span></code></pre></div>

<p>在Windows系统中，从 “C:/temp “调用该函数，参数为 “top”，输出结果为如下所示:</p>
<div class="code-wrapper"><pre><code class="hljs bash"><span class="hljs-string">"C:\\temp\\top"</span>
<span class="hljs-string">"temp\\top\\a/x"</span>
<span class="hljs-string">"..\\x"</span>
<span class="hljs-string">"..\\x"</span>
<span class="hljs-string">"a\\x"</span>
<span class="hljs-string">"..\\x"</span>
<span class="hljs-string">"..\\x"</span>
ps: <span class="hljs-string">"C:\\temp\\top\\a/s"</span> -&gt; <span class="hljs-string">"C:\\temp\\top"</span>
<span class="hljs-string">"..\\x"</span>
<span class="hljs-string">"a\\x"</span></code></pre></div>

<p>请再次注意，你需要管理员权限才能在Windows上创建符号链接。</p>
<h5><span id="20-4-6-qi-ta-wen-jian-xi-tong-cao-zuo">20.4.6 其他文件系统操作</span><a href="#20-4-6-qi-ta-wen-jian-xi-tong-cao-zuo" class="header-anchor">#</a></h5><p>表 “其他操作 “列出了尚未提及的其他文件系统操作。</p>
<table>
<thead>
<tr>
<th>调用</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>equivalent(p1, p2)</td>
<td>得出 p1 和 p2 是否引用同一个文件</td>
</tr>
<tr>
<td>space(p)</td>
<td>产生有关路径 p 处可用磁盘空间的信息</td>
</tr>
<tr>
<td>current_path(p)</td>
<td>将当前工作目录的路径设置为 p</td>
</tr>
</tbody></table>
<p>在关于路径比较的章节中讨论了equivalent()函数。<br>space()的返回值是以下结构：</p>
<div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">namespace</span> std::filesystem {
    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">space_info</span> {
        <span class="hljs-type">uintmax_t</span> capacity;
        <span class="hljs-type">uintmax_t</span> free;
        <span class="hljs-type">uintmax_t</span> available;
    };
}</code></pre></div>

<p>因此，使用结构化绑定可以打印 root 的可用磁盘空间，如下所示：</p>
<div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">auto</span> [cap, _, avail] = std::filesystem::<span class="hljs-built_in">space</span>(<span class="hljs-string">"/"</span>);
std::cout &lt;&lt; std::fixed &lt;&lt; std::<span class="hljs-built_in">precision</span>(<span class="hljs-number">2</span>)
    &lt;&lt; avail/<span class="hljs-number">1.0e6</span> &lt;&lt; <span class="hljs-string">" of "</span> &lt;&lt; cap/<span class="hljs-number">1.0e6</span> &lt;&lt; <span class="hljs-string">" MB available\n\n"</span>;</code></pre></div>

<p>输出可能是例如：</p>
<div class="code-wrapper"><pre><code class="hljs bash">43019.82 of 150365.79 MB available</code></pre></div>

<p>为路径参数调用的 current_path() 会修改整个程序的当前工作目录（因此，它适用于所有线程）。 离开范围时，您可以通过以下方式切换到另一个工作目录并恢复旧目录：</p>
<div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">auto</span> current{std::filesystem::<span class="hljs-built_in">current_path</span>()};
<span class="hljs-keyword">try</span> {
    std::filesystem::<span class="hljs-built_in">current_path</span>(subdir);
    ...;
}
<span class="hljs-built_in">catch</span> (...) {
    std::filesystem::<span class="hljs-built_in">current_path</span>(current);
    <span class="hljs-keyword">throw</span>;
}
std::filesystem::<span class="hljs-built_in">current_path</span>(subdir);</code></pre></div>

<h4><span id="20-5-bian-li-mu-lu">20.5 遍历目录</span><a href="#20-5-bian-li-mu-lu" class="header-anchor">#</a></h4><p>文件系统库的一个关键应用是遍历目录或文件系统（子）树的所有文件。<br>最方便的方法是使用基于范围的 for 循环。 您可以遍历目录中的所有文件：</p>
 <div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">for</span> (<span class="hljs-type">const</span> <span class="hljs-keyword">auto</span>&amp; e : std::filesystem::<span class="hljs-built_in">directory_iterator</span>(dir)) {
    std::cout &lt;&lt; e.<span class="hljs-built_in">path</span>() &lt;&lt; <span class="hljs-string">'\n'</span>;
}</code></pre></div>

<p>或递归遍历文件系统（子）树中的所有文件：</p>
<div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">for</span> (<span class="hljs-type">const</span> <span class="hljs-keyword">auto</span>&amp; e : std::filesystem::<span class="hljs-built_in">recursive_directory_iterator</span>(dir)) {
    std::cout &lt;&lt; e.<span class="hljs-built_in">path</span>() &lt;&lt; <span class="hljs-string">'\n'</span>;
}</code></pre></div>

<p>传递的参数 dir 可以是路径或任何可隐式转换为路径的内容（尤其是所有形式的字符串）；<br>请注意， e.path() 产生的文件名包括迭代开始的目录。</p>
<p>因此，如果我们遍历“.” 文件名 file.txt 变为 ./file.txt 或 .\file.txt。</p>
<p>此外，此路径被引用到流中，因此此文件名的输出变为“./file.txt”或“.\file.txt”。 因此，正如之前在初始示例中所讨论的，以下循环更便于移植：</p>
<div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">for</span> (<span class="hljs-type">const</span> <span class="hljs-keyword">auto</span>&amp; e : std::filesystem::<span class="hljs-built_in">directory_iterator</span>(dir)) {
    std::cout &lt;&lt; e.<span class="hljs-built_in">path</span>().<span class="hljs-built_in">lexically_normal</span>().<span class="hljs-built_in">string</span>() &lt;&lt; <span class="hljs-string">'\n'</span>;
}</code></pre></div>

<p>要在当前目录上进行迭代，你应该传递”. “作为当前目录而不是””。传递一个空的路径在Windows上是可行的，但不能移植。</p>
<h6><span id="fan-wei-de-mu-lu-die-dai-qi">范围的目录迭代器</span><a href="#fan-wei-de-mu-lu-die-dai-qi" class="header-anchor">#</a></h6><p>你可以将一个迭代器传递给一个基于范围的for循环，这可能看起来令人惊讶，因为你通常需要一个范围。</p>
<p>诀窍在于，directory_iterator和recursive_directory_iterator都是提供begin()和end()的全局重载的类。</p>
<ul>
<li>begin()产生迭代器本身。</li>
<li>end()产生结束迭代器，你也可以用默认的构造函数来创建它。</li>
</ul>
<p> 出于这个原因，你也可以按以下方式进行迭代。</p>
<div class="code-wrapper"><pre><code class="hljs c++">std::filesystem::directory_iterator di{p};
<span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> pos = <span class="hljs-built_in">begin</span>(di); pos != <span class="hljs-built_in">end</span>(di); ++pos) {
    std::cout &lt;&lt; pos-&gt;<span class="hljs-built_in">path</span>() &lt;&lt; <span class="hljs-string">'\n'</span>;
}</code></pre></div>

<p>或者如下:</p>
<div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">for</span> (std::filesystem::directory_iterator pos{p};
     pos != std::filesystem::directory_iterator{};
     ++pos) {
    std::cout &lt;&lt; pos-&gt;<span class="hljs-built_in">path</span>() &lt;&lt; <span class="hljs-string">'\n'</span>;
}</code></pre></div>

<h6><span id="mu-lu-die-dai-qi-xuan-xiang">目录迭代器选项</span><a href="#mu-lu-die-dai-qi-xuan-xiang" class="header-anchor">#</a></h6><p>遍历目录时，您可以传递 directory_options 类型的值，这些值列在表 Directory Iterator Options 中。 该类型是位掩码范围的枚举类型，在命名空间 std::filesystem 中定义。</p>
<table>
<thead>
<tr>
<th>目录选项</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>none</td>
<td>默认（值 0）</td>
</tr>
<tr>
<td>follow_directory_symlink</td>
<td>跟随符号链接（而不是跳过它们）</td>
</tr>
<tr>
<td>skip_permission_denied</td>
<td>跳过权限被拒绝的目录</td>
</tr>
</tbody></table>
<p>默认情况下，不跟踪符号链接，并跳过你不允许迭代的目录。使用 skip_permission_denied 遍历一个被拒绝的目录时，会产生一个异常。<br>createfiles.cpp显示了follow_directory_symlink的一个应用:</p>
<h5><span id="20-5-1-mu-lu-tiao-mu">20.5.1 目录条目</span><a href="#20-5-1-mu-lu-tiao-mu" class="header-anchor">#</a></h5><p>目录迭代器所迭代的元素是std::filesystem::directory_entry类型的。因此，如果一个目录迭代器是有效的，operator*()就会产生该类型。这意味着，基于范围的for循环的正确类型如下。</p>
<div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">for</span> (<span class="hljs-type">const</span> std::filesystem::directory_entry&amp; e
     : std::filesystem::<span class="hljs-built_in">directory_iterator</span>(p)) {
    std::cout &lt;&lt; e.<span class="hljs-built_in">path</span>() &lt;&lt; <span class="hljs-string">'\n'</span>;
}</code></pre></div>
<p>目录条目既包含路径对象，也包含额外的属性，如硬链接计数、文件状态、文件大小、最后写入时间、是否是符号链接，以及如果是的话，它指向哪里。</p>
<p>注意，这些迭代器是输入迭代器。原因是在一个目录上迭代可能导致不同的结果，因为在任何时候目录条目都可能改变。在并行算法中使用目录迭代器时，必须考虑到这一点。</p>
<p>表中目录条目操作列出了你可以为一个目录条目e调用的操作，它们或多或少是你可以调用的查询文件属性、获取文件状态检查权限和比较路径的操作。</p>
<table>
<thead>
<tr>
<th>调用</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>e.path()</td>
<td>产生当前条目的文件系统路径</td>
</tr>
<tr>
<td>e.exists()</td>
<td>产生文件是否存在</td>
</tr>
<tr>
<td>e.is_regular_file()</td>
<td>产生文件是否存在并且是一个普通文件</td>
</tr>
<tr>
<td>e.is_directory()</td>
<td>产生文件是否存在并且是一个目录</td>
</tr>
<tr>
<td>e.is_symlink()</td>
<td>得出文件是否存在并且是一个符号链接</td>
</tr>
<tr>
<td>e.is_other()</td>
<td>产生文件是否存在，并且既不是常规文件也不是目录也不是象征性链接</td>
</tr>
<tr>
<td>e.is_block_file()</td>
<td>产生文件是否存在并且是一个块状特殊文件</td>
</tr>
<tr>
<td>e.is_character_file()</td>
<td>产生文件是否存在并且是一个特殊字符的文件。</td>
</tr>
<tr>
<td>e.is_fifo()</td>
<td>产生文件是否存在，并且是FIFO或管道文件</td>
</tr>
<tr>
<td>e.is_socket()</td>
<td>产生文件是否存在并且是一个套接字。</td>
</tr>
<tr>
<td>e.file_size()</td>
<td>产生文件的大小。</td>
</tr>
<tr>
<td>e.hard_link_count()</td>
<td>产生硬链接的数量</td>
</tr>
<tr>
<td>e.last_write_time()</td>
<td>产生最后一次写到文件的时间点</td>
</tr>
<tr>
<td>e.status()</td>
<td>产生文件的状态p</td>
</tr>
<tr>
<td>e.symlink_status()</td>
<td>产生文件的状态（在符号链接之后） p</td>
</tr>
<tr>
<td>e1 == e2</td>
<td>产生两个入口的路径是否相等</td>
</tr>
<tr>
<td>e1 != e2</td>
<td>产生两个入口路径是否不相等</td>
</tr>
<tr>
<td>e1 &lt; e2</td>
<td>产生是否一个条目路径小于另一个条目路径的结果</td>
</tr>
<tr>
<td>e1 &lt;= e2</td>
<td>产生一个条目路径是否比另一个条目路径小或相等</td>
</tr>
<tr>
<td>e1 &gt;= e2</td>
<td>产生一个条目路径是否大于或等于另一个条目路径</td>
</tr>
<tr>
<td>e1 &gt; e2</td>
<td>产生一个条目路径是否大于另一个条目路径。</td>
</tr>
<tr>
<td>e.assign(p)</td>
<td>用p替换e的路径并更新所有条目属性</td>
</tr>
<tr>
<td>e.replace_filename(p)</td>
<td>用p替换e的当前路径的文件名并更新所有条目属性</td>
</tr>
<tr>
<td>e.refresh()</td>
<td>更新此条目的所有缓存属性</td>
</tr>
</tbody></table>
<p>assign()和replace_filename()调用相应的修改路径操作，但不修改底层文件系统中的文件。</p>
<h6><span id="mu-lu-tiao-mu-huan-cun">目录条目缓存</span><a href="#mu-lu-tiao-mu-huan-cun" class="header-anchor">#</a></h6><p>我们鼓励实现者缓存这些额外的文件属性，以避免在使用条目时对文件系统的额外访问。然而，实现并不要求缓存数据，这意味着这些通常很便宜的操作可能会变得更昂贵。<br>因为所有的值通常都被缓存了，这些调用通常是廉价的，因此是成员函数。</p>
<div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">for</span> (<span class="hljs-type">const</span> <span class="hljs-keyword">auto</span>&amp; e : std::filesystem::directory_iterator{<span class="hljs-string">"."</span>})
{
    <span class="hljs-keyword">auto</span> t = e.<span class="hljs-built_in">last_write_time</span>(); <span class="hljs-comment">// 通常便宜</span>
    ...
}</code></pre></div>

<p>无论是否有缓存，在一个多用户或多进程的操作系统中，所有这些迭代可能产生不再有效的文件数据。文件内容和大小可能会改变，文件可能被删除或替换（因此，甚至文件类型也可能改变），权限可能被修改。<br>在这种情况下，你可以要求刷新一个目录项所持有的数据:</p>
<div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">for</span> (<span class="hljs-type">const</span> <span class="hljs-keyword">auto</span>&amp; e : std::filesystem::directory_iterator{<span class="hljs-string">"."</span>})
{
    ...; <span class="hljs-comment">// 数据数据变旧</span>
    e.<span class="hljs-built_in">refresh</span>(); <span class="hljs-comment">// 刷新文件的缓存数据</span>
    <span class="hljs-keyword">if</span> (e.<span class="hljs-built_in">exists</span>()) {
        <span class="hljs-keyword">auto</span> t = e.<span class="hljs-built_in">last_write_time</span>();
        ...;
    }
}</code></pre></div>

<p>另外，你可能总是问当前的情况：</p>
<div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">for</span> (<span class="hljs-type">const</span> <span class="hljs-keyword">auto</span>&amp; e : std::filesystem::directory_iterator{<span class="hljs-string">"."</span>})
{
    ...; <span class="hljs-comment">// 数据数据变旧</span>
    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">exists</span>(e.<span class="hljs-built_in">path</span>())) {
        <span class="hljs-keyword">auto</span> t = <span class="hljs-built_in">last_write_time</span>(e.<span class="hljs-built_in">path</span>());
        ...
    }
}</code></pre></div>

<h4><span id="20-6-hou-ji">20.6 后记</span><a href="#20-6-hou-ji" class="header-anchor">#</a></h4><p>文件系统库在Beman Dawes的领导下作为一个Boost库开发了多年。在2014年，它第一次成为一个正式的测试标准，即文件系统技术规范（见<a target="_blank" rel="noopener" href="https://wg21.link/n4100%EF%BC%89%E3%80%82">https://wg21.link/n4100）。</a><br>随着<a target="_blank" rel="noopener" href="https://wg21.link/p0218r0%EF%BC%8C%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E6%8A%80%E6%9C%AF%E8%A7%84%E8%8C%83%E8%A2%AB%E9%87%87%E7%BA%B3%E4%B8%BA">https://wg21.link/p0218r0，文件系统技术规范被采纳为</a> 由Beman Dawes提出的标准库。对计算相对路径的支持被添加到<br>由Beman Dawes, Nicolai Josuttis和Jamie Allsop在<a target="_blank" rel="noopener" href="https://wg21.link/p0219r1%E3%80%82%E7%94%B1Beman">https://wg21.link/p0219r1。由Beman</a> Dawes在<a target="_blank" rel="noopener" href="https://wg21.link/p0317r1">https://wg21.link/p0317r1</a> 中提议增加了几个小的修正。Nicolai Josuttis在<a target="_blank" rel="noopener" href="https://wg21.link/p0392r0%EF%BC%8CJason">https://wg21.link/p0392r0，Jason</a> Liu和Hubert Tong在https: //wg21.link/p0430r2，特别是文件系统小组的成员（Beman Dawes, S. Davis Herring, Nicolai Josuttis, Jason Liu, Billy O’Neal, P.J. Plauger, and Jonathan Wakely）在<a target="_blank" rel="noopener" href="https://wg21.link/p0492r2%E3%80%82">https://wg21.link/p0492r2。</a></p>

            </div>
            <hr>
            <div>
              <div class="post-metas mb-3">
                
                
                  <div class="post-meta">
                    <i class="iconfont icon-tags"></i>
                    
                      <a class="hover-with-bg" href="/tags/C-17/">C++17</a>
                    
                      <a class="hover-with-bg" href="/tags/STL/">STL</a>
                    
                  </div>
                
              </div>
              
                <p class="note note-warning">
                  
                    本博客所有文章除特别声明外，均采用 <a target="_blank" href="https://creativecommons.org/licenses/by-sa/4.0/deed.zh" rel="nofollow noopener noopener">CC BY-SA 4.0 协议</a> ，转载请注明出处！
                  
                </p>
              
              
                <div class="post-prevnext">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/2022/03/19/%E7%AC%AC%E4%B8%80%E9%83%A8%E5%88%86%EF%BC%9A%E5%9F%BA%E6%9C%AC%E8%AF%AD%E8%A8%80%E7%89%B9%E5%BE%81/">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">第一部分-基本语言特征</span>
                        <span class="visible-mobile">上一篇</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2022/03/19/%E7%AC%AC%E4%BA%94%E9%83%A8%E5%88%86%20%E4%B8%93%E4%B8%9A%E5%B7%A5%E5%85%B7%20/">
                        <span class="hidden-mobile">第五部分-专业工具</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
              <!-- Comments -->
              <article class="comments" id="comments" lazyload>
                
                  
                
                
  <div id="lv-container" data-id="city" data-uid="MTAyMC81NTMzMi8zMTc5OQ==">
    <script type="text/javascript">
      Fluid.utils.loadComments('#lv-container', function() {
        Fluid.utils.createScript('https://cdn-city.livere.com/js/embed.dist.js');
      });
    </script>
    <noscript>Please enable JavaScript to view the comments</noscript>
  </div>


              </article>
            
          </article>
        </div>
      </div>
    </div>
    
      <div class="d-none d-lg-block col-lg-2 toc-container" id="toc-ctn">
        <div id="toc">
  <p class="toc-header"><i class="iconfont icon-list"></i>&nbsp;目录</p>
  <div class="toc-body" id="toc-body"></div>
</div>

      </div>
    
  </div>
</div>

<!-- Custom -->


    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v"
                 for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>
    

    
  </main>

  <footer class="text-center mt-5 py-3">
  <div class="footer-content">
     <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> 
  </div>
  

  

  
</footer>


  <!-- SCRIPTS -->
  
  <script  src="https://cdn.jsdelivr.net/npm/nprogress@0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/nprogress@0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js" ></script>
<script  src="https://cdn.jsdelivr.net/npm/bootstrap@4/dist/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>

<!-- Plugins -->


  <script  src="/js/local-search.js" ></script>



  
    <script  src="/js/img-lazyload.js" ></script>
  



  



  
    <script  src="https://cdn.jsdelivr.net/npm/tocbot@4/dist/tocbot.min.js" ></script>
  
  
    <script  src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3/dist/jquery.fancybox.min.js" ></script>
  
  
    <script  src="https://cdn.jsdelivr.net/npm/anchor-js@4/anchor.min.js" ></script>
  
  
    <script defer src="https://cdn.jsdelivr.net/npm/clipboard@2/dist/clipboard.min.js" ></script>
  






  <script  src="https://cdn.jsdelivr.net/npm/typed.js@2/lib/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var title = document.getElementById('subtitle').title;
      
        typing(title);
      
    })(window, document);
  </script>















<!-- 主题的启动项 保持在最底部 -->
<script  src="/js/boot.js" ></script>


</body>
</html>
