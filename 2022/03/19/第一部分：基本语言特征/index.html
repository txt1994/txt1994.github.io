

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=auto>



<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/logo.jpg">
  <link rel="icon" href="/img/logo.jpg">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
    <meta http-equiv="Content-Security-Policy" content="upgrade-insecure-requests">
  
  <meta name="theme-color" content="#6aa84f">
  <meta name="author" content="John Doe">
  <meta name="keywords" content="">
  
    <meta name="description" content="第一部分：基本语言特征 1 结构化绑定 2 if 和 switch 初始化 3 内联变量 4 聚合扩展 5 强制复制省略或传递未实现的对象 6 Lambda 扩展 7 新属性和属性特性 8 其他语言特性        第一部分：基本语言特征#1 结构化绑定#结构化绑定允许你使用对象的成员或者说元素来初始化多个变量。 举个例子，假如你定义了一个包含两个不同成员的结构： struct MyS">
<meta property="og:type" content="article">
<meta property="og:title" content="第一部分-基本语言特征">
<meta property="og:url" content="https://txt1994.github.io/2022/03/19/%E7%AC%AC%E4%B8%80%E9%83%A8%E5%88%86%EF%BC%9A%E5%9F%BA%E6%9C%AC%E8%AF%AD%E8%A8%80%E7%89%B9%E5%BE%81/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:description" content="第一部分：基本语言特征 1 结构化绑定 2 if 和 switch 初始化 3 内联变量 4 聚合扩展 5 强制复制省略或传递未实现的对象 6 Lambda 扩展 7 新属性和属性特性 8 其他语言特性        第一部分：基本语言特征#1 结构化绑定#结构化绑定允许你使用对象的成员或者说元素来初始化多个变量。 举个例子，假如你定义了一个包含两个不同成员的结构： struct MyS">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://gitee.com/txt1994/Cpp17TheCompleteGuideChinese/raw/master/public/fig8-1.jpg">
<meta property="article:published_time" content="2022-03-18T16:01:17.000Z">
<meta property="article:modified_time" content="2022-03-18T17:25:53.701Z">
<meta property="article:author" content="John Doe">
<meta property="article:tag" content="C++17">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="https://gitee.com/txt1994/Cpp17TheCompleteGuideChinese/raw/master/public/fig8-1.jpg">
  
  
  <title>第一部分-基本语言特征 - Hexo</title>

  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4/dist/css/bootstrap.min.css" />


  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/github-markdown-css@4/github-markdown.min.css" />
  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/hint.css@2/hint.min.css" />

  
    
    
      
      <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@10/styles/github-gist.min.css" />
    
  

  
    <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3/dist/jquery.fancybox.min.css" />
  


<!-- 主题依赖的图标库，不要自行修改 -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_ba1fz6golrf.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_lbnruvf0jn.css">


<link  rel="stylesheet" href="/css/main.css" />

<!-- 自定义样式保持在最底部 -->

  
<link rel="stylesheet" href="/css/style.css">



  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    var CONFIG = {"hostname":"txt1994.github.io","root":"/","version":"1.8.14","typing":{"enable":true,"typeSpeed":70,"cursorChar":"_","loop":false},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"right","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"copy_btn":true,"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":false,"baidu":null,"google":null,"gtag":null,"tencent":{"sid":null,"cid":null},"woyaola":null,"cnzz":null,"leancloud":{"app_id":null,"app_key":null,"server_url":null,"path":"window.location.pathname","ignore_local":false}},"search_path":"/local-search.xml"};
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
<meta name="generator" content="Hexo 6.1.0">
<style>.github-emoji { position: relative; display: inline-block; width: 1.2em; min-height: 1.2em; overflow: hidden; vertical-align: top; color: transparent; }  .github-emoji > span { position: relative; z-index: 10; }  .github-emoji img, .github-emoji .fancybox { margin: 0 !important; padding: 0 !important; border: none !important; outline: none !important; text-decoration: none !important; user-select: none !important; cursor: auto !important; }  .github-emoji img { height: 1.2em !important; width: 1.2em !important; position: absolute !important; left: 50% !important; top: 50% !important; transform: translate(-50%, -50%) !important; user-select: none !important; cursor: auto !important; } .github-emoji-fallback { color: inherit; } .github-emoji-fallback img { opacity: 0 !important; }</style>
</head>


<body>
  <header style="height: 70vh;">
    <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/">
      <strong>txt1994s</strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/">
                <i class="iconfont icon-home-fill"></i>
                首页
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/">
                <i class="iconfont icon-archive-fill"></i>
                归档
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/">
                <i class="iconfont icon-tags-fill"></i>
                标签
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/">
                <i class="iconfont icon-user-fill"></i>
                关于
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/links/">
                <i class="iconfont icon-link-fill"></i>
                友联
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              &nbsp;<i class="iconfont icon-search"></i>&nbsp;
            </a>
          </li>
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">&nbsp;<i
                class="iconfont icon-dark" id="color-toggle-icon"></i>&nbsp;</a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

    <div class="banner" id="banner" parallax=true
         style="background: url('/img/default.png') no-repeat center center;
           background-size: cover;">
      <div class="full-bg-img">
        <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
          <div class="page-header text-center fade-in-up">
            <span class="h2" id="subtitle" title="第一部分-基本语言特征">
              
            </span>

            
              <div class="mt-3">
  
  
    <span class="post-meta">
      <i class="iconfont icon-date-fill" aria-hidden="true"></i>
      <time datetime="2022-03-19 00:01" pubdate>
        2022年3月19日 凌晨
      </time>
    </span>
  
</div>

<div class="mt-1">
  
    <span class="post-meta mr-2">
      <i class="iconfont icon-chart"></i>
      53k 字
    </span>
  

  
    <span class="post-meta mr-2">
      <i class="iconfont icon-clock-fill"></i>
      
      
      443 分钟
    </span>
  

  
  
</div>

            
          </div>

          
        </div>
      </div>
    </div>
  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="d-none d-lg-block col-lg-2"></div>
    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div class="py-5" id="board">
          <article class="post-content mx-auto">
            <!-- SEO header -->
            <h1 style="display: none">第一部分-基本语言特征</h1>
            
              <p class="note note-info">
                
                  本文最后更新于：2022年3月19日 凌晨
                
              </p>
            
            <div class="markdown-body">
              <div class="toc">

<!-- toc -->

<ul>
<li><a href="#di-yi-bu-fen-ji-ben-yu-yan-te-zheng">第一部分：基本语言特征</a><ul>
<li><a href="#1-jie-gou-hua-bang-ding">1 结构化绑定</a></li>
<li><a href="#2-if-he-switch-chu-shi-hua">2 if 和 switch 初始化</a></li>
<li><a href="#3-nei-lian-bian-liang">3 内联变量</a></li>
<li><a href="#4-ju-he-kuo-zhan">4 聚合扩展</a></li>
<li><a href="#5-qiang-zhi-fu-zhi-sheng-lue-huo-chuan-di-wei-shi-xian-de-dui-xiang">5 强制复制省略或传递未实现的对象</a></li>
<li><a href="#6-lambda-kuo-zhan">6 Lambda 扩展</a></li>
<li><a href="#7-xin-shu-xing-he-shu-xing-te-xing">7 新属性和属性特性</a></li>
<li><a href="#8-qi-ta-yu-yan-te-xing">8 其他语言特性</a></li>
</ul>
</li>
</ul>
<!-- tocstop -->

</div>

<h2><span id="di-yi-bu-fen-ji-ben-yu-yan-te-zheng">第一部分：基本语言特征</span><a href="#di-yi-bu-fen-ji-ben-yu-yan-te-zheng" class="header-anchor">#</a></h2><h3><span id="1-jie-gou-hua-bang-ding">1 结构化绑定</span><a href="#1-jie-gou-hua-bang-ding" class="header-anchor">#</a></h3><p>结构化绑定允许你使用对象的成员或者说元素来初始化多个变量。</p>
<p>举个例子，假如你定义了一个包含两个不同成员的结构：</p>
<div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">MyStruct</span> {
  <span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;
  std::string s;
};

MyStruct ms;</code></pre></div>

<p>只需使用下面的声明，你就可以将这个结构体的成员直接绑定到新名字上</p>
<div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">auto</span> [u,v] = ms;</code></pre></div>

<p>在这里，名字u和v就被称为结构化绑定（structured bindings）。在某种程度上，它们分解了对象并用来初始化自己（在有些地方它们也被称为分解声明（decompose declarations））。</p>
<p>结构化绑定对于那些返回结构体或者数组的函数来说尤其有用。举个例子，假设你有一个返回结构体的函数：</p>
<div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-function">MyStruct <span class="hljs-title">getStruct</span><span class="hljs-params">()</span> </span>{
  <span class="hljs-keyword">return</span> MyStruct{<span class="hljs-number">42</span>, <span class="hljs-string">"hello"</span>};
}</code></pre></div>

<p>你可以直接为函数返回的数据成员赋予两个局部名字：</p>
<div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">auto</span>[id,val] = <span class="hljs-built_in">getStruct</span>(); <span class="hljs-comment">// id and val name i and s of returned struct</span></code></pre></div>

<p>在这里，id和val分别表示返回的数据成员i和s。它们的类型分别是int和<code>std::string</code> ，可以当新变量使用。</p>
<div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">if</span> (id &gt; <span class="hljs-number">30</span>) {
  std::cout &lt;&lt; val;
}</code></pre></div>

<p>使用结构化绑定的好处是可以直接通过名字访问值，并且由于名字可以传递语义信息，使得代码可读性也大大提高。</p>
<p>下面的示例展示了结构化绑定如何改善代码可读性。在没有结构化绑定的时候，要想迭代处理<code>std::map&lt;&gt;</code>的所有元素，需要这么写：</p>
<div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">for</span> (<span class="hljs-type">const</span> <span class="hljs-keyword">auto</span>&amp; elem : mymap) {
  std::cout &lt;&lt; elem.first &lt;&lt; <span class="hljs-string">": "</span> &lt;&lt; elem.second &lt;&lt; <span class="hljs-string">'\n'</span>; 
}</code></pre></div>

<p>代码中的elem是表示键和值的<code>std::pair</code>，它们在<code>std::pair</code>中分别用first和second表示，你可以使用这两个名字去访问键和值。使用结构化绑定后，代码可读性大大提高：</p>
<div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">for</span> (<span class="hljs-type">const</span> <span class="hljs-keyword">auto</span>&amp; [key,val] : mymap) {
  std::cout &lt;&lt; key &lt;&lt; <span class="hljs-string">": "</span> &lt;&lt; val &lt;&lt; <span class="hljs-string">'\n'</span>; 
}</code></pre></div>

<p>我们可以直接使用每个元素的键和值，key和value清晰的表示了它们的语义。</p>
<h4><span id="1-1-jie-gou-hua-bang-ding-de-xi-jie">1.1 结构化绑定的细节</span><a href="#1-1-jie-gou-hua-bang-ding-de-xi-jie" class="header-anchor">#</a></h4><p>为了理解结构化绑定，了解其中设计的一个匿名变量是很重要的。结构化绑定引入的新名字都是指代的这个匿名变量的成员/元素的。</p>
<h5><span id="1-1-1-bang-ding-dao-ni-ming-bian-liang">1.1.1 绑定到匿名变量</span><a href="#1-1-1-bang-ding-dao-ni-ming-bian-liang" class="header-anchor">#</a></h5><p>初始化代码的最精确的行为：</p>
<div class="code-wrapper"><pre><code class="hljs angelscript"><span class="hljs-built_in">auto</span> [u,v] = ms;</code></pre></div>

<p>可以看成我们初始化一个匿名变量e，然后让结构化绑定u和v成为这个新对象的别名，类似下面：</p>
<div class="code-wrapper"><pre><code class="hljs abnf">auto e <span class="hljs-operator">=</span> ms<span class="hljs-comment">;</span>
aliasname u <span class="hljs-operator">=</span> e.i<span class="hljs-comment">;</span>
aliasname v <span class="hljs-operator">=</span> e.s<span class="hljs-comment">;</span></code></pre></div>

<p>注意u和v不是<code>e.i</code>和<code>e.s</code>的引用。它们只是这两个成员的别名。因此，<code>decltype(u)</code>的类型与成员i的类型一致，<code>decltype(v)</code>的类型与成员s的类型一致。因为匿名变量e没有名字，所以我们不能直接访问这个已经初始化的变量。所以</p>
<div class="code-wrapper"><pre><code class="hljs c++">std::cout &lt;&lt; u &lt;&lt; <span class="hljs-string">' '</span> &lt;&lt; v &lt;&lt; <span class="hljs-string">'\n'</span>;</code></pre></div>

<p>输出<code>e.i</code>和<code>e.s</code>的值，它们是<code>ms.i</code>和<code>ms.s</code>的一份拷贝。</p>
<p>e和结构化绑定的存活时间一样长，当结构化绑定离开作用域时，e也会析构。</p>
<p>这样做的后果，除非使用引用，否则修改通过结构化绑定的值不会影响到初始化它的对象（反之亦然）：</p>
<div class="code-wrapper"><pre><code class="hljs c++">MyStruct ms{<span class="hljs-number">42</span>,<span class="hljs-string">"hello"</span>};
<span class="hljs-keyword">auto</span> [u,v] = ms;
ms.i = <span class="hljs-number">77</span>;
std::cout &lt;&lt; u;    <span class="hljs-comment">// prints 42</span>
u = <span class="hljs-number">99</span>;
std::cout &lt;&lt; ms.i; <span class="hljs-comment">// prints 77</span></code></pre></div>

<p>u和<code>ms.i</code>地址是不一样的。</p>
<p>当对返回值使用结构化绑定的时候，上面的规则一样成立。下面代码的初始化：</p>
<div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">auto</span> [u,v] = <span class="hljs-built_in">getStruct</span>();</code></pre></div>

<p>和我们使用<code>getStruct()</code>的返回值初始化匿名变量e，然后用u和v作为e的成员别名效果一样，类似下面：</p>
<div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">auto</span> e = <span class="hljs-built_in">getStruct</span>();
aliasname u = e.i;
aliasname v = e.s;</code></pre></div>

<p>换句话说，结构化绑定将绑定到一个新的对象，它由返回值初始化，而不是直接绑定到返回值本身。</p>
<p>对于匿名变量e，内存地址和对齐也是存在的，以至于如果成员有对齐，结构化绑定也会有对齐。比如：</p>
<div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">auto</span> [u,v] = ms;
<span class="hljs-built_in">assert</span>(&amp;((MyStruct*)&amp;u)-&gt;s == &amp;v); <span class="hljs-comment">// OK</span></code></pre></div>

<p><code>((MyStruct*)&amp;u)</code>会产生一个指向匿名变量的指针。</p>
<h5><span id="1-1-2-shi-yong-xiu-shi-fu">1.1.2 使用修饰符</span><a href="#1-1-2-shi-yong-xiu-shi-fu" class="header-anchor">#</a></h5><p>我们在结构化绑定过程中使用一些修饰符，如const和引用。再次强调，这些修饰符修饰的是匿名变量e。虽说是对匿名变量使用修饰符，但是通常也可以看作对结构化绑定使用修饰符，尽管存在一些额例外。</p>
<p>下面的例子中，我们对结构化绑定使用const引用：</p>
<div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-type">const</span> <span class="hljs-keyword">auto</span>&amp; [u,v] = ms; <span class="hljs-comment">// a reference, so that u/v refer to ms.i/ms.s</span></code></pre></div>

<p>这里，匿名变量被声明为const引用，这意味着对ms使用const引用修饰，然后再将u和v作为i和s的别名。后续对ms成员的修改会直接影响到u和v：</p>
<div class="code-wrapper"><pre><code class="hljs c++">ms.i = <span class="hljs-number">77</span>;      <span class="hljs-comment">// affects the value of u</span>
std::cout &lt;&lt; u; <span class="hljs-comment">// prints 77</span></code></pre></div>

<p>如果使用非const引用，你甚至可以通过对结构化绑定的修改，影响到初始化它的对象：</p>
<div class="code-wrapper"><pre><code class="hljs c++">MyStruct ms{<span class="hljs-number">42</span>,<span class="hljs-string">"hello"</span>};
<span class="hljs-keyword">auto</span>&amp; [u,v] = ms;       <span class="hljs-comment">// the initialized entity is a reference to ms</span>
ms.i = <span class="hljs-number">77</span>;              <span class="hljs-comment">// affects the value of u</span>
std::cout &lt;&lt; u;         <span class="hljs-comment">// prints 77</span>
u = <span class="hljs-number">99</span>;                 <span class="hljs-comment">// modifies ms.i</span>
std::cout &lt;&lt; ms.i;      <span class="hljs-comment">// prints 99</span></code></pre></div>

<p>如果初始化对象是临时变量，对它使用结构化绑定，此时临时值的生命周期会扩展：</p>
<div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-function">MyStruct <span class="hljs-title">getStruct</span><span class="hljs-params">()</span></span>;
...
<span class="hljs-type">const</span> <span class="hljs-keyword">auto</span>&amp; [a,b] = <span class="hljs-built_in">getStruct</span>();
std::cout &lt;&lt; <span class="hljs-string">"a: "</span> &lt;&lt; a &lt;&lt; <span class="hljs-string">'\n'</span>; <span class="hljs-comment">// OK</span></code></pre></div>

<h5><span id="1-1-3-xiu-shi-fu-bing-fei-xiu-shi-jie-gou-hua-bang-ding">1.1.3 修饰符并非修饰结构化绑定</span><a href="#1-1-3-xiu-shi-fu-bing-fei-xiu-shi-jie-gou-hua-bang-ding" class="header-anchor">#</a></h5><p>如题，修饰符修饰的是匿名变量。它们没必要修饰结构化绑定。事实上：</p>
<div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-type">const</span> <span class="hljs-keyword">auto</span>&amp; [u,v] = ms;  <span class="hljs-comment">// a reference, so that u/v refer to ms.i/ms.s</span></code></pre></div>

<p>u和v都没有声明为引用。上面只是对匿名变量e的引用。u和v的类型需要ms的成员一致。根据我们最开始的定义可以知道，<code>decltype(u)</code>是int，<code>decltype(v)</code>是<code>std::string</code>。</p>
<p>当指定对齐宽度的时候也有一些不同。</p>
<div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-built_in">alignas</span>(<span class="hljs-number">16</span>) <span class="hljs-keyword">auto</span> [u,v] = ms;</code></pre></div>

<p>在这里，我们将初始化后的匿名对象对齐而不是结构化绑定u和v。这意味着u作为第一个成员，被强制对齐到16位，而v不是。</p>
<p>同样的原因，尽管使用了auto，结构化绑定的类型也不会类型退化（术语退化（decay）描述的是当参数值传递的时候发生的类型转换，这意味着数组会转换为指针，最外面的修饰符如const和引用会被忽略）。例如，如果我们有一个包含多个原生数组的结构体：</p>
<div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">S</span>{
    <span class="hljs-type">const</span> <span class="hljs-type">char</span> x[<span class="hljs-number">6</span>];
    <span class="hljs-type">const</span> <span class="hljs-type">char</span> y[<span class="hljs-number">3</span>];
};</code></pre></div>

<p>然后</p>
<div class="code-wrapper"><pre><code class="hljs c++">S s1{};
<span class="hljs-keyword">auto</span> [a, b] = s1; <span class="hljs-comment">// a and b get the exact member types</span></code></pre></div>

<p>a的类型仍然是<code>const char[6]</code>。原因仍然是修饰符并非修饰结构化绑定而是修饰初始化结构化绑定的对象。这一点和使用auto初始化新对象很不一样，它会发生类型退化：</p>
<div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">auto</span> a2 = a;    <span class="hljs-comment">// a2 gets decayed type of a</span></code></pre></div>

<h5><span id="1-1-4-yi-dong-yu-yi">1.1.4移动语义</span><a href="#1-1-4-yi-dong-yu-yi" class="header-anchor">#</a></h5><p>即将介绍到，结构化绑定也支持移动语义。在下面的声明中：</p>
<div class="code-wrapper"><pre><code class="hljs c++">MyStruct ms = { <span class="hljs-number">42</span>, <span class="hljs-string">"Jim"</span> };
<span class="hljs-keyword">auto</span>&amp;&amp; [v,n] = std::<span class="hljs-built_in">move</span>(ms);  <span class="hljs-comment">// entity is rvalue reference to ms</span></code></pre></div>

<p>结构化绑定v和n指向匿名变量中的成员，该匿名变量是ms的右值引用。ms仍然持有它的值:</p>
<div class="code-wrapper"><pre><code class="hljs c++">std::cout &lt;&lt; <span class="hljs-string">"ms.s: "</span> &lt;&lt; ms.s &lt;&lt; <span class="hljs-string">'\n'</span>; <span class="hljs-comment">// prints "Jim"</span></code></pre></div>

<p>但是你可以移动赋值n，它与<code>ms.s</code>关联：</p>
<div class="code-wrapper"><pre><code class="hljs c++">std::string s = std::<span class="hljs-built_in">move</span>(n); <span class="hljs-comment">// moves ms.s to s</span>
std::cout &lt;&lt; <span class="hljs-string">"ms.s: "</span> &lt;&lt; ms.s &lt;&lt; <span class="hljs-string">'\n'</span>; <span class="hljs-comment">// prints unspecified value</span>
std::cout &lt;&lt; <span class="hljs-string">"n: "</span> &lt;&lt; n &lt;&lt; <span class="hljs-string">'\n'</span>; <span class="hljs-comment">// prints unspecified value</span>
std::cout &lt;&lt; <span class="hljs-string">"s: "</span> &lt;&lt; s &lt;&lt; <span class="hljs-string">'\n'</span>; <span class="hljs-comment">// prints "Jim"</span></code></pre></div>

<p>通常，移动后的对象的状态是有效的，只是包含了未指定的值（unspecified value）。因此，输出它的值是没有问题的，但是不能断言输出的东西一定是什么。</p>
<p>这一点和直接移动ms的值给匿名变量稍有不同：</p>
<div class="code-wrapper"><pre><code class="hljs c++">MyStruct ms = { <span class="hljs-number">42</span>, <span class="hljs-string">"Jim"</span> };
<span class="hljs-keyword">auto</span> [v,n] = std::<span class="hljs-built_in">move</span>(ms); <span class="hljs-comment">// new entity with moved-from values from ms</span></code></pre></div>

<p>此时匿名对象是一个新对象，它用移动后的ms的值来初始化。所以ms失去了他们的值：</p>
<div class="code-wrapper"><pre><code class="hljs c++">std::cout &lt;&lt; <span class="hljs-string">"ms.s: "</span> &lt;&lt; ms.s &lt;&lt; <span class="hljs-string">'\n'</span>; <span class="hljs-comment">// prints unspecified value</span>
std::cout &lt;&lt; <span class="hljs-string">"n: "</span> &lt;&lt; n &lt;&lt; <span class="hljs-string">'\n'</span>; <span class="hljs-comment">// prints "Jim"</span></code></pre></div>

<p>你仍然可以移动n并赋值，或者用它赋予一个新的值，但是不会影响<code>ms.s</code>：</p>
<div class="code-wrapper"><pre><code class="hljs c++">std::string s = std::<span class="hljs-built_in">move</span>(n); <span class="hljs-comment">// moves n to s</span>
n = <span class="hljs-string">"Lara"</span>;
std::cout &lt;&lt; <span class="hljs-string">"ms.s: "</span> &lt;&lt; ms.s &lt;&lt; <span class="hljs-string">'\n'</span>; <span class="hljs-comment">// prints unspecified value</span>
std::cout &lt;&lt; <span class="hljs-string">"n: "</span> &lt;&lt; n &lt;&lt; <span class="hljs-string">'\n'</span>; <span class="hljs-comment">// prints "Lara"</span>
std::cout &lt;&lt; <span class="hljs-string">"s: "</span> &lt;&lt; s &lt;&lt; <span class="hljs-string">'\n'</span>; <span class="hljs-comment">// prints "Jim"</span></code></pre></div>

<h4><span id="1-2-ke-yi-shi-yong-jie-gou-hua-bang-ding-de-di-fang">1.2 可以使用结构化绑定的地方</span><a href="#1-2-ke-yi-shi-yong-jie-gou-hua-bang-ding-de-di-fang" class="header-anchor">#</a></h4><p>原则上，结构化绑定可以用于公有成员，原始C-style数组，以及“似若tuple”的对象：</p>
<ul>
<li>如果结构体或者类中，所有非静态数据成员都是public，那么你可以使用结构化绑定来绑定非静态数据成员</li>
<li>对于原生数组，你可以使用结构化绑定来绑定每个元素</li>
<li>对于任何类型，你都可以使用似若tuple的API来进行绑定。对于类型type，API可以粗糙的概括为下列内容：<ul>
<li><code>std::tuple_size::value</code>返回元素数量</li>
<li><code>std::tupel_element::type</code>返回第idx个元素的类型</li>
<li>一个全局的或者成员函数<code>get()</code>返回第idx个元素的值</li>
</ul>
</li>
</ul>
<p>如果结构体或者累提供这些似若tuple的API，那么就可以使用它们。</p>
<p>任何情况下都要求元素或者数据成员的数量必须匹配结构化绑定的名字的个数。你不能跳过任何一个元素，也不能使用同一个名字两次。但是你可以看使用非常段的名字如”_”（很多程序员倾向于用下划线，但是也有些人讨厌它，不允许它出现在全局命名空间中），但是在一个作用域它也只能出现一次：</p>
<div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">auto</span> [_,val1] = <span class="hljs-built_in">getStruct</span>(); <span class="hljs-comment">// OK</span>
<span class="hljs-keyword">auto</span> [_,val2] = <span class="hljs-built_in">getStruct</span>(); <span class="hljs-comment">// ERROR: name _ already used</span></code></pre></div>

<p>嵌套或者非平坦的对象分解是不支持的。（译注：指的是形如OCaml等语言的这种<code>let a,(b,c) = (3,(4,2));;</code>模式匹配能力）</p>
<p>接下来的章节讨论本节列表提到的各种情况。</p>
<h5><span id="1-2-1-jie-gou-he-lei">1.2.1 结构和类</span><a href="#1-2-1-jie-gou-he-lei" class="header-anchor">#</a></h5><p>到目前为止，已经演示了很多关于结构体和类的简单示例了。</p>
<p>如果类和结构体用到了继承，那么结构化绑定的使用就很受限了。所有非静态数据成员必须出现在同一个类。（换句话说，这些数据成员要么全是该类的，要么全是基类的）。</p>
<div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">B</span> {
  <span class="hljs-type">int</span> a = <span class="hljs-number">1</span>;
  <span class="hljs-type">int</span> b = <span class="hljs-number">2</span>;
};

<span class="hljs-keyword">struct</span> <span class="hljs-title class_">D1</span> : B {
};
<span class="hljs-keyword">auto</span> [x, y] = D1{}; <span class="hljs-comment">// OK</span>

<span class="hljs-keyword">struct</span> <span class="hljs-title class_">D2</span> : B {
  <span class="hljs-type">int</span> c = <span class="hljs-number">3</span>;
};

<span class="hljs-keyword">auto</span> [i, j, k] = D2{}; <span class="hljs-comment">// Compile-Time ERROR</span></code></pre></div>

<h5><span id="1-2-2-yuan-shi-shu-zu">1.2.2 原始数组</span><a href="#1-2-2-yuan-shi-shu-zu" class="header-anchor">#</a></h5><p>下面的代码使用有两个元素的C-style数组初始化x和y：</p>
<div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-type">int</span> arr[] = { <span class="hljs-number">47</span>, <span class="hljs-number">11</span> };
<span class="hljs-keyword">auto</span> [x, y] = arr; <span class="hljs-comment">// x and y are ints initialized by elems of arr</span>
<span class="hljs-keyword">auto</span> [z] = arr; <span class="hljs-comment">// ERROR: number of elements doesn’t fit</span></code></pre></div>

<p>这种方式只能出现在数组长度已知的情况下。如果将数组作为参数传递，这样写就行不通，因为数组作为参数传递会发生类型退化，变成指针类型。</p>
<p>C++允许我们返回带长度的数组引用，如果有函数返回这种带长度的数组引用，那么也可以使用结构化绑定：</p>
<div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">auto</span> <span class="hljs-title">getArr</span><span class="hljs-params">()</span> -&gt; <span class="hljs-title">int</span><span class="hljs-params">(&amp;)</span>[2]</span>; <span class="hljs-comment">// getArr() returns reference to raw int array</span>
...
<span class="hljs-keyword">auto</span> [x, y] = <span class="hljs-built_in">getArr</span>(); <span class="hljs-comment">// x and y are ints initialized by elems of returned array</span></code></pre></div>

<p>你也可以对<code>std::array</code>使用结构化绑定，但是这需要使用似若tuple的API，这也是下一节的内容。</p>
<h5><span id="1-2-3-std-pair-std-tuple-he-std-array">1.2.3 std::pair、std::tuple 和 std::array</span><a href="#1-2-3-std-pair-std-tuple-he-std-array" class="header-anchor">#</a></h5><p>结构化绑定是可扩展的，你可以为任何类型添加结构化绑定机制。标准库为<code>std::paor</code>,<code>std::tuple</code>和<code>std::array</code>都添加了该机制。</p>
<h6><span id="std-array"><code>std::array</code></span><a href="#std-array" class="header-anchor">#</a></h6><p>举个例子，下面的<code>getArray()</code>将返回四个元素的<code>std::array&lt;&gt;</code>，并用它初始化i，j，k和l。</p>
<div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-function">std::array&lt;<span class="hljs-type">int</span>,4&gt; <span class="hljs-title">getArray</span><span class="hljs-params">()</span></span>;
...
<span class="hljs-keyword">auto</span> [i,j,k,l] = <span class="hljs-built_in">getArray</span>(); <span class="hljs-comment">// i,j,k,l name the 4 elements of the copied return value</span></code></pre></div>

<p>i，j，k和l分别绑定到<code>getArray()</code>返回的四个元素上。</p>
<p>写操作也是支持的，但这要求用来初始化结构化绑定的值不是一个临时的返回值：</p>
<div class="code-wrapper"><pre><code class="hljs c++">std::array&lt;<span class="hljs-type">int</span>,4&gt; stdarr { <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span> };
...
<span class="hljs-keyword">auto</span>&amp; [i,j,k,l] = stdarr;
i += <span class="hljs-number">10</span>; <span class="hljs-comment">// modifies std::array[0]</span></code></pre></div>

<h6><span id="std-tuple"><code>std::tuple</code></span><a href="#std-tuple" class="header-anchor">#</a></h6><p>下面的代码使用<code>getTuple()</code>返回有三个元素的<code>std::tuple&lt;&gt;</code>来初始化a，b和c：</p>
<div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-function">std::tuple&lt;<span class="hljs-type">char</span>,<span class="hljs-type">float</span>,std::string&gt; <span class="hljs-title">getTuple</span><span class="hljs-params">()</span></span>;
...
<span class="hljs-keyword">auto</span> [a,b,c] = <span class="hljs-built_in">getTuple</span>();    <span class="hljs-comment">// a,b,c have types and values of returned tuple</span></code></pre></div>

<h6><span id="std-pair"><code>std::pair</code></span><a href="#std-pair" class="header-anchor">#</a></h6><p>另一个例子是处理关联型/无序型容器的<code>insert()</code>调用的返回值，使用结构化绑定使代码可读性更强，可以清晰的表达自己的意图，而不是依赖于<code>std::tuple</code>通用的first和second：</p>
<div class="code-wrapper"><pre><code class="hljs c++">std::map&lt;std::string, <span class="hljs-type">int</span>&gt; coll;
...
<span class="hljs-keyword">auto</span> [pos,ok] = coll.<span class="hljs-built_in">insert</span>({<span class="hljs-string">"new"</span>,<span class="hljs-number">42</span>});
<span class="hljs-keyword">if</span> (!ok) {
  <span class="hljs-comment">// if insert failed, handle error using iterator pos:</span>
  ...
}</code></pre></div>

<p>在C++17之前，必须使用下面的代码检查返回数据：</p>
<div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">auto</span> ret = coll.<span class="hljs-built_in">insert</span>({<span class="hljs-string">"new"</span>,<span class="hljs-number">42</span>});
<span class="hljs-keyword">if</span> (!ret.second){
  <span class="hljs-comment">// if insert failed, handle error using iterator ret.first</span>
  ...
}</code></pre></div>

<p>注意，在这个例子中，C++17甚至还提供一种表达力更强的带初始化的if：</p>
<h6><span id="wei-pair-he-tuple-de-jie-gou-hua-bang-ding-fu-zhi">为pair和tuple的结构化绑定赋值</span><a href="#wei-pair-he-tuple-de-jie-gou-hua-bang-ding-fu-zhi" class="header-anchor">#</a></h6><p>在声明了结构化绑定之后，通常你不能一次性修改全部结构化绑定，因为结构化绑定是一次性声明所有而不是一次性使用所有。然而，如果重新赋的值是<code>std::pair&lt;&gt;</code>或者<code>std::tuple&lt;&gt;</code>那么你可以使用<code>std::tie()</code>。</p>
<p>也就是说，你可以写出下面的代码：</p>
<div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-function">std::tuple&lt;<span class="hljs-type">char</span>,<span class="hljs-type">float</span>,std::string&gt; <span class="hljs-title">getTuple</span><span class="hljs-params">()</span></span>;
...
<span class="hljs-keyword">auto</span> [a,b,c] = <span class="hljs-built_in">getTuple</span>(); <span class="hljs-comment">// a,b,c have types and values of returned tuple</span>
...
std::<span class="hljs-built_in">tie</span>(a,b,c) = <span class="hljs-built_in">getTuple</span>(); <span class="hljs-comment">// a,b,c get values of next returned tuple</span></code></pre></div>

<p>这种方式在实现循环调用且每次循环赋予一对返回值的过程中尤其有用，比如下面子啊循环中使用searcher的代码：</p>
<div class="code-wrapper"><pre><code class="hljs c++">std::boyer_moore_searcher bm{sub.<span class="hljs-built_in">begin</span>(), sub.<span class="hljs-built_in">end</span>()};
<span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> [beg, end] = <span class="hljs-built_in">bm</span>(text.<span class="hljs-built_in">begin</span>(), text.<span class="hljs-built_in">end</span>());
     beg != text.<span class="hljs-built_in">end</span>();
     std::<span class="hljs-built_in">tie</span>(beg,end) = <span class="hljs-built_in">bm</span>(end, text.<span class="hljs-built_in">end</span>())) {
    ...
}</code></pre></div>

<h4><span id="1-3-wei-jie-gou-hua-bang-ding-ti-gong-lei-si-yuan-zu-de-api">1.3 为结构化绑定提供类似元组的 API</span><a href="#1-3-wei-jie-gou-hua-bang-ding-ti-gong-lei-si-yuan-zu-de-api" class="header-anchor">#</a></h4><p> 前面提到过，只要你的类型实现了似若tuple的API，那么就可以针对该类型使用结构化绑定，就和标准库的<code>std::pair&lt;&gt;</code>,<code>std::tuple&lt;&gt;</code>和<code>std::array&lt;&gt;</code>意义。 </p>
<h6><span id="zhi-du-jie-gou-hua-bang-ding">只读结构化绑定</span><a href="#zhi-du-jie-gou-hua-bang-ding" class="header-anchor">#</a></h6><p>下面的代码展示了如何为类型Customer添加结构化绑定功能，Customer的定义如下</p>
<div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-comment">// lang/customer1.hpp</span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;utility&gt;</span> <span class="hljs-comment">// for std::move()</span></span>
<span class="hljs-keyword">class</span> <span class="hljs-title class_">Customer</span> {
<span class="hljs-keyword">private</span>:
    std::string first;
    std::string last;
    <span class="hljs-type">long</span> val;
<span class="hljs-keyword">public</span>:
    <span class="hljs-built_in">Customer</span> (std::string f, std::string l, <span class="hljs-type">long</span> v)
        : <span class="hljs-built_in">first</span>(std::<span class="hljs-built_in">move</span>(f)), <span class="hljs-built_in">last</span>(std::<span class="hljs-built_in">move</span>(l)), <span class="hljs-built_in">val</span>(v) {
        }
    <span class="hljs-function">std::string <span class="hljs-title">getFirst</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>{
        <span class="hljs-keyword">return</span> first;
    }
    <span class="hljs-function">std::string <span class="hljs-title">getLast</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>{
        <span class="hljs-keyword">return</span> last;
    }
    <span class="hljs-function"><span class="hljs-type">long</span> <span class="hljs-title">getValue</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>{
        <span class="hljs-keyword">return</span> val;
    }
};</code></pre></div>

<p>我们可以提供似若tuple的API：</p>
<div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-comment">// lang/structbind1.hpp</span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">"customer1.hpp"</span> #<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;utility&gt;</span> <span class="hljs-comment">// for tuple-like API</span></span>
<span class="hljs-comment">// provide a tuple-like API for class Customer for structured bindings:</span>
<span class="hljs-keyword">template</span>&lt;&gt;
<span class="hljs-keyword">struct</span> <span class="hljs-title class_">std</span>::tuple_size&lt;Customer&gt; {
    <span class="hljs-type">static</span> <span class="hljs-keyword">constexpr</span> <span class="hljs-type">int</span> value = <span class="hljs-number">3</span>; <span class="hljs-comment">// we have 3 attributes</span>
};
<span class="hljs-keyword">template</span>&lt;&gt;
<span class="hljs-keyword">struct</span> <span class="hljs-title class_">std</span>::tuple_element&lt;<span class="hljs-number">2</span>, Customer&gt; {
    <span class="hljs-keyword">using</span> type = <span class="hljs-type">long</span>; <span class="hljs-comment">// last attribute is a long</span>
};
<span class="hljs-keyword">template</span>&lt;std::<span class="hljs-type">size_t</span> Idx&gt;
<span class="hljs-keyword">struct</span> <span class="hljs-title class_">std</span>::tuple_element&lt;Idx, Customer&gt; {
    <span class="hljs-keyword">using</span> type = std::string; <span class="hljs-comment">// the other attributes are strings</span>
};
<span class="hljs-comment">// define specific getters:</span>
<span class="hljs-function"><span class="hljs-keyword">template</span>&lt;std::<span class="hljs-type">size_t</span>&gt; <span class="hljs-keyword">auto</span> <span class="hljs-title">get</span><span class="hljs-params">(<span class="hljs-type">const</span> Customer&amp; c)</span></span>;
<span class="hljs-keyword">template</span>&lt;&gt; <span class="hljs-keyword">auto</span> <span class="hljs-built_in">get</span>&lt;<span class="hljs-number">0</span>&gt;(<span class="hljs-type">const</span> Customer&amp; c) { <span class="hljs-keyword">return</span> c.<span class="hljs-built_in">getFirst</span>(); }
<span class="hljs-keyword">template</span>&lt;&gt; <span class="hljs-keyword">auto</span> <span class="hljs-built_in">get</span>&lt;<span class="hljs-number">1</span>&gt;(<span class="hljs-type">const</span> Customer&amp; c) { <span class="hljs-keyword">return</span> c.<span class="hljs-built_in">getLast</span>(); }
<span class="hljs-keyword">template</span>&lt;&gt; <span class="hljs-keyword">auto</span> <span class="hljs-built_in">get</span>&lt;<span class="hljs-number">2</span>&gt;(<span class="hljs-type">const</span> Customer&amp; c) { <span class="hljs-keyword">return</span> c.<span class="hljs-built_in">getValue</span>(); }</code></pre></div>

<p>代码Customer有三个成员，还有为三个成员准备的getter：</p>
<ul>
<li>表示first name的成员，<code>std::string</code>类型</li>
<li>表示last nane的成员，<code>std::string</code>类型</li>
<li>表示value的成员，long类型</li>
</ul>
<p>获取Customer成员个数的函数是<code>std::tuple_size</code>的特化：</p>
<div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">template</span>&lt;&gt;
<span class="hljs-keyword">struct</span> <span class="hljs-title class_">std</span>::tuple_size&lt;Customer&gt; {
<span class="hljs-type">static</span> <span class="hljs-keyword">constexpr</span> <span class="hljs-type">int</span> value = <span class="hljs-number">3</span>; <span class="hljs-comment">// we have 3 attributes</span>
};</code></pre></div>

<p>获取成员类型的函数是<code>std::tuple_element</code>的特化：</p>
<div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">template</span>&lt;&gt;
<span class="hljs-keyword">struct</span> <span class="hljs-title class_">std</span>::tuple_element&lt;<span class="hljs-number">2</span>, Customer&gt; {
    <span class="hljs-keyword">using</span> type = <span class="hljs-type">long</span>; <span class="hljs-comment">// last attribute is a long</span>
};
<span class="hljs-keyword">template</span>&lt;std::<span class="hljs-type">size_t</span> Idx&gt;
<span class="hljs-keyword">struct</span> <span class="hljs-title class_">std</span>::tuple_element&lt;Idx, Customer&gt; {
    <span class="hljs-keyword">using</span> type = std::string; <span class="hljs-comment">// the other attributes are strings</span>
};</code></pre></div>

<p>第三个成员类型是long，需要为它（index 2）编写全特化代码。其它成员是<code>std::stinrg</code>类型，部分特化（比全特化优先级低）即可。这里指定的类型与<code>decltype</code>产生的类型一致。</p>
<p>最终，我们在同一个命名空间为Customer类型定义相应的<code>get&lt;&gt;()</code>函数重载：</p>
<div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;std::<span class="hljs-type">size_t</span>&gt; <span class="hljs-keyword">auto</span> <span class="hljs-title">get</span><span class="hljs-params">(<span class="hljs-type">const</span> Customer&amp; c)</span></span>;
<span class="hljs-keyword">template</span>&lt;&gt; <span class="hljs-keyword">auto</span> <span class="hljs-built_in">get</span>&lt;<span class="hljs-number">0</span>&gt;(<span class="hljs-type">const</span> Customer&amp; c) { <span class="hljs-keyword">return</span> c.<span class="hljs-built_in">getFirst</span>(); }
<span class="hljs-keyword">template</span>&lt;&gt; <span class="hljs-keyword">auto</span> <span class="hljs-built_in">get</span>&lt;<span class="hljs-number">1</span>&gt;(<span class="hljs-type">const</span> Customer&amp; c) { <span class="hljs-keyword">return</span> c.<span class="hljs-built_in">getLast</span>(); }
<span class="hljs-keyword">template</span>&lt;&gt; <span class="hljs-keyword">auto</span> <span class="hljs-built_in">get</span>&lt;<span class="hljs-number">2</span>&gt;(<span class="hljs-type">const</span> Customer&amp; c) { <span class="hljs-keyword">return</span> c.<span class="hljs-built_in">getValue</span>(); }</code></pre></div>

<p>在这里，我们声明了模板函数，然后为所有情况都写出来对应的全特化形式。</p>
<p>注意，模板函数的全特化必须与模板函数的签名一致（也包括一致的返回类型）。原因是我们只提供了特定的“实现”，而不是声明新的函数。下面的代码不能通过编译：</p>
<div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;std::<span class="hljs-type">size_t</span>&gt; <span class="hljs-keyword">auto</span> <span class="hljs-title">get</span><span class="hljs-params">(<span class="hljs-type">const</span> Customer&amp; c)</span></span>;
<span class="hljs-keyword">template</span>&lt;&gt; std::string <span class="hljs-built_in">get</span>&lt;<span class="hljs-number">0</span>&gt;(<span class="hljs-type">const</span> Customer&amp; c) { <span class="hljs-keyword">return</span> c.<span class="hljs-built_in">getFirst</span>(); }
<span class="hljs-keyword">template</span>&lt;&gt; std::string <span class="hljs-built_in">get</span>&lt;<span class="hljs-number">1</span>&gt;(<span class="hljs-type">const</span> Customer&amp; c) { <span class="hljs-keyword">return</span> c.<span class="hljs-built_in">getLast</span>(); }
<span class="hljs-keyword">template</span>&lt;&gt; <span class="hljs-type">long</span> <span class="hljs-built_in">get</span>&lt;<span class="hljs-number">2</span>&gt;(<span class="hljs-type">const</span> Customer&amp; c) { <span class="hljs-keyword">return</span> c.<span class="hljs-built_in">getValue</span>(); }</code></pre></div>

<p>通过使用新的<strong>编译时if特性</strong>，我们可以所有特化形式的<code>get&lt;&gt;()</code>组合到一个函数里面：</p>
<div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;std::<span class="hljs-type">size_t</span> I&gt; <span class="hljs-keyword">auto</span> <span class="hljs-title">get</span><span class="hljs-params">(<span class="hljs-type">const</span> Customer&amp; c)</span> </span>{
    <span class="hljs-built_in">static_assert</span>(I &lt; <span class="hljs-number">3</span>);
    <span class="hljs-function"><span class="hljs-keyword">if</span> <span class="hljs-title">constexpr</span> <span class="hljs-params">(I == <span class="hljs-number">0</span>)</span> </span>{
        <span class="hljs-keyword">return</span> c.<span class="hljs-built_in">getFirst</span>();
    }
    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> <span class="hljs-built_in">constexpr</span> (I == <span class="hljs-number">1</span>) {
        <span class="hljs-keyword">return</span> c.<span class="hljs-built_in">getLast</span>();
    }
    <span class="hljs-keyword">else</span> { <span class="hljs-comment">// I == 2</span>
        <span class="hljs-keyword">return</span> c.<span class="hljs-built_in">getValue</span>();
    } 
}</code></pre></div>

<p>有了这些API，就能对Customer的对象使用结构化绑定了：</p>
<div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span>
<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>
<span class="hljs-function"></span>{
    <span class="hljs-function">Customer <span class="hljs-title">c</span><span class="hljs-params">(<span class="hljs-string">"Tim"</span>, <span class="hljs-string">"Starr"</span>, <span class="hljs-number">42</span>)</span></span>;
    <span class="hljs-keyword">auto</span> [f, l, v] = c;
    std::cout &lt;&lt; <span class="hljs-string">"f/l/v: "</span> &lt;&lt; f &lt;&lt; <span class="hljs-string">' '</span> &lt;&lt; l &lt;&lt; <span class="hljs-string">' '</span> &lt;&lt; v &lt;&lt; <span class="hljs-string">'\n'</span>;
    <span class="hljs-comment">// modify structured bindings:</span>
    std::string s = std::<span class="hljs-built_in">move</span>(f);
    l = <span class="hljs-string">"Waters"</span>;
    v += <span class="hljs-number">10</span>;
    std::cout &lt;&lt; <span class="hljs-string">"f/l/v: "</span> &lt;&lt; f &lt;&lt; <span class="hljs-string">' '</span> &lt;&lt; l &lt;&lt; <span class="hljs-string">' '</span> &lt;&lt; v &lt;&lt;<span class="hljs-string">'\n'</span>;
    std::cout &lt;&lt; <span class="hljs-string">"c: "</span> &lt;&lt; c.<span class="hljs-built_in">getFirst</span>() &lt;&lt; <span class="hljs-string">' '</span>
        &lt;&lt; c.<span class="hljs-built_in">getLast</span>() &lt;&lt; <span class="hljs-string">' '</span> &lt;&lt; c.<span class="hljs-built_in">getValue</span>() &lt;&lt; <span class="hljs-string">'\n'</span>;
    std::cout &lt;&lt; <span class="hljs-string">"s: "</span> &lt;&lt; s &lt;&lt; <span class="hljs-string">'\n'</span>;
}</code></pre></div>

<p>和往常一样，结构化绑定f，l和v是新的匿名变量的成员的别名，新的匿名变量经由c初始化。初始化为每个成员调用相应的getter函数。因此，在初始化后，修改c不会影响到结构化绑定（反之亦然）。所以，程序的输出如下：</p>
<div class="code-wrapper"><pre><code class="hljs bash">f/l/v: Tim Starr 42
f/l/v:  Waters 52
c: Tim Starr 42
s: Tim</code></pre></div>

<p>你也可以在迭代一个由Customer元素构成的vector的过程中使用结构化绑定：</p>
<div class="code-wrapper"><pre><code class="hljs c++">std::vector&lt;Customer&gt; coll;
...
    <span class="hljs-keyword">for</span> (<span class="hljs-type">const</span> <span class="hljs-keyword">auto</span>&amp; [first, last, val] : coll) {
        std::cout &lt;&lt; first &lt;&lt; <span class="hljs-string">' '</span> &lt;&lt; last &lt;&lt; <span class="hljs-string">": "</span> &lt;&lt; val &lt;&lt; <span class="hljs-string">'\n'</span>; 
    }</code></pre></div>

<p>对结构化绑定使用<code>decltype</code>仍然回产出它的类型，而不是匿名变量的类型。这意味着<code>decltype(first)</code>是<code>const std::string</code>。</p>
<h6><span id="yun-xu-zhen-dui-jie-gou-hua-bang-ding-de-xie-cao-zuo">允许针对结构化绑定的写操作</span><a href="#yun-xu-zhen-dui-jie-gou-hua-bang-ding-de-xie-cao-zuo" class="header-anchor">#</a></h6><p>似若tuple的API可以可以使用产生引用的函数。这使得我们可以允许针对结构化绑定的写操作发生。考虑下面的代码，它为Customer提供了读取和修改成员的API：</p>
<div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-comment">// lang/customer2.hpp</span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;utility&gt;</span> <span class="hljs-comment">// for std::move()</span></span>
<span class="hljs-keyword">class</span> <span class="hljs-title class_">Customer</span> {
    <span class="hljs-keyword">private</span>:
    std::string first;
    std::string last;
    <span class="hljs-type">long</span> val;
    <span class="hljs-keyword">public</span>:
    <span class="hljs-built_in">Customer</span> (std::string f, std::string l, <span class="hljs-type">long</span> v)
        : <span class="hljs-built_in">first</span>(std::<span class="hljs-built_in">move</span>(f)), <span class="hljs-built_in">last</span>(std::<span class="hljs-built_in">move</span>(l)), <span class="hljs-built_in">val</span>(v) {
        }
    <span class="hljs-function"><span class="hljs-type">const</span> std::string&amp; <span class="hljs-title">firstname</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>{
        <span class="hljs-keyword">return</span> first;
    }
    <span class="hljs-function">std::string&amp; <span class="hljs-title">firstname</span><span class="hljs-params">()</span> </span>{
        <span class="hljs-keyword">return</span> first;
    }
    <span class="hljs-function"><span class="hljs-type">const</span> std::string&amp; <span class="hljs-title">lastname</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>{
        <span class="hljs-keyword">return</span> last;
    }
    <span class="hljs-function">std::string&amp; <span class="hljs-title">lastname</span><span class="hljs-params">()</span> </span>{
        <span class="hljs-keyword">return</span> last;
    }
    <span class="hljs-function"><span class="hljs-type">long</span> <span class="hljs-title">value</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>{
        <span class="hljs-keyword">return</span> val;
    }
    <span class="hljs-function"><span class="hljs-type">long</span>&amp; <span class="hljs-title">value</span><span class="hljs-params">()</span> </span>{
        <span class="hljs-keyword">return</span> val;
    }
};</code></pre></div>

<p>要支持读写操作，我们还得为常量引用和非常量引用准备getter重载：</p>
<div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-comment">// lang/structbind2.hpp</span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">"customer2.hpp"</span> </span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt; utility&gt;</span> <span class="hljs-comment">// for tuple-like API</span></span>
<span class="hljs-comment">// provide a tuple-like API for class Customer for structured bindings:</span>
<span class="hljs-keyword">template</span> &lt;&gt; <span class="hljs-keyword">struct</span> <span class="hljs-title class_">std</span>::tuple_size&lt;Customer&gt; {
    <span class="hljs-type">static</span> <span class="hljs-keyword">constexpr</span> <span class="hljs-type">int</span> value = <span class="hljs-number">3</span>; <span class="hljs-comment">// we have 3 attributes</span>
};
<span class="hljs-keyword">template</span> &lt;&gt; <span class="hljs-keyword">struct</span> <span class="hljs-title class_">std</span>::tuple_element&lt;<span class="hljs-number">2</span>, Customer&gt; {
    <span class="hljs-keyword">using</span> type = <span class="hljs-type">long</span>; <span class="hljs-comment">// last attribute is a long</span>
};
<span class="hljs-keyword">template</span> &lt;std::<span class="hljs-type">size_t</span> Idx&gt; <span class="hljs-keyword">struct</span> <span class="hljs-title class_">std</span>::tuple_element&lt;Idx, Customer&gt; {
    <span class="hljs-keyword">using</span> type = std::string; <span class="hljs-comment">// the other attributes are strings</span>
};
<span class="hljs-comment">// define specific getters:</span>
<span class="hljs-keyword">template</span> &lt;std::<span class="hljs-type">size_t</span> I&gt; <span class="hljs-function"><span class="hljs-keyword">decltype</span>(<span class="hljs-keyword">auto</span>) <span class="hljs-title">get</span><span class="hljs-params">(Customer &amp;c)</span> </span>{
    <span class="hljs-built_in">static_assert</span>(I &lt; <span class="hljs-number">3</span>);
    <span class="hljs-function"><span class="hljs-keyword">if</span> <span class="hljs-title">constexpr</span> <span class="hljs-params">(I == <span class="hljs-number">0</span>)</span> </span>{
        <span class="hljs-keyword">return</span> c.<span class="hljs-built_in">firstname</span>();
    } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> <span class="hljs-built_in">constexpr</span> (I == <span class="hljs-number">1</span>) {
        <span class="hljs-keyword">return</span> c.<span class="hljs-built_in">lastname</span>();
    } <span class="hljs-keyword">else</span> { <span class="hljs-comment">// I == 2</span>
        <span class="hljs-keyword">return</span> c.<span class="hljs-built_in">value</span>();
    }
}
<span class="hljs-keyword">template</span> &lt;std::<span class="hljs-type">size_t</span> I&gt; <span class="hljs-function"><span class="hljs-keyword">decltype</span>(<span class="hljs-keyword">auto</span>) <span class="hljs-title">get</span><span class="hljs-params">(<span class="hljs-type">const</span> Customer &amp;c)</span> </span>{
    <span class="hljs-built_in">static_assert</span>(I &lt; <span class="hljs-number">3</span>);
    <span class="hljs-function"><span class="hljs-keyword">if</span> <span class="hljs-title">constexpr</span> <span class="hljs-params">(I == <span class="hljs-number">0</span>)</span> </span>{
        <span class="hljs-keyword">return</span> c.<span class="hljs-built_in">firstname</span>();
    } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> <span class="hljs-built_in">constexpr</span> (I == <span class="hljs-number">1</span>) {
        <span class="hljs-keyword">return</span> c.<span class="hljs-built_in">lastname</span>();
    } <span class="hljs-keyword">else</span> { <span class="hljs-comment">// I == 2</span>
        <span class="hljs-keyword">return</span> c.<span class="hljs-built_in">value</span>();
    }
}
<span class="hljs-keyword">template</span> &lt;std::<span class="hljs-type">size_t</span> I&gt; <span class="hljs-function"><span class="hljs-keyword">decltype</span>(<span class="hljs-keyword">auto</span>) <span class="hljs-title">get</span><span class="hljs-params">(Customer &amp;&amp;c)</span> </span>{
    <span class="hljs-built_in">static_assert</span>(I &lt; <span class="hljs-number">3</span>);
    <span class="hljs-function"><span class="hljs-keyword">if</span> <span class="hljs-title">constexpr</span> <span class="hljs-params">(I == <span class="hljs-number">0</span>)</span> </span>{
        <span class="hljs-keyword">return</span> std::<span class="hljs-built_in">move</span>(c.<span class="hljs-built_in">firstname</span>());
    } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> <span class="hljs-built_in">constexpr</span> (I == <span class="hljs-number">1</span>) {
        <span class="hljs-keyword">return</span> std::<span class="hljs-built_in">move</span>(c.<span class="hljs-built_in">lastname</span>());
    } <span class="hljs-keyword">else</span> { <span class="hljs-comment">// I == 2</span>
        <span class="hljs-keyword">return</span> c.<span class="hljs-built_in">value</span>();
    }
}</code></pre></div>

<p>你应该写出这三个重载，来处理常量对象，非常量对象，以及可移动对象。为了返回引用，你应该使用<code>decltype(auto)</code>。</p>
<p>还是之前那样，我们可以使用新的<strong>编译时if特性</strong>，来简化我们的实现，尤其是getter的返回类型不一样时，它更有用。没有编译时if特性，我们只能写出所有的全特化：</p>
<div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;std::<span class="hljs-type">size_t</span>&gt; <span class="hljs-keyword">decltype</span>(<span class="hljs-keyword">auto</span>) <span class="hljs-title">get</span><span class="hljs-params">(Customer&amp; c)</span></span>;
<span class="hljs-keyword">template</span>&lt;&gt; <span class="hljs-keyword">decltype</span>(<span class="hljs-keyword">auto</span>) <span class="hljs-built_in">get</span>&lt;<span class="hljs-number">0</span>&gt;(Customer&amp; c) { 
    <span class="hljs-keyword">return</span> c.<span class="hljs-built_in">firstname</span>(); 
}
<span class="hljs-keyword">template</span>&lt;&gt; <span class="hljs-keyword">decltype</span>(<span class="hljs-keyword">auto</span>) <span class="hljs-built_in">get</span>&lt;<span class="hljs-number">1</span>&gt;(Customer&amp; c) { 
    <span class="hljs-keyword">return</span> c.<span class="hljs-built_in">lastname</span>(); 
}
<span class="hljs-keyword">template</span>&lt;&gt; <span class="hljs-keyword">decltype</span>(<span class="hljs-keyword">auto</span>) <span class="hljs-built_in">get</span>&lt;<span class="hljs-number">2</span>&gt;(Customer&amp; c) { 
    <span class="hljs-keyword">return</span> c.<span class="hljs-built_in">value</span>(); 
}</code></pre></div>

<p>模板函数声明的签名必须与全特化的一致（包括返回类型）。下面的代码不能编译：</p>
<div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;std::<span class="hljs-type">size_t</span>&gt; <span class="hljs-keyword">decltype</span>(<span class="hljs-keyword">auto</span>) <span class="hljs-title">get</span><span class="hljs-params">(Customer&amp; c)</span></span>;
<span class="hljs-keyword">template</span>&lt;&gt; std::string&amp; <span class="hljs-built_in">get</span>&lt;<span class="hljs-number">0</span>&gt;(Customer&amp; c) { 
    <span class="hljs-keyword">return</span> c.<span class="hljs-built_in">firstname</span>(); 
}
<span class="hljs-keyword">template</span>&lt;&gt; std::string&amp; <span class="hljs-built_in">get</span>&lt;<span class="hljs-number">1</span>&gt;(Customer&amp; c) { 
    <span class="hljs-keyword">return</span> c.<span class="hljs-built_in">lastname</span>(); 
}
<span class="hljs-keyword">template</span>&lt;&gt; <span class="hljs-type">long</span>&amp; <span class="hljs-built_in">get</span>&lt;<span class="hljs-number">2</span>&gt;(Customer&amp; c) { 
    <span class="hljs-keyword">return</span> c.<span class="hljs-built_in">value</span>(); 
}</code></pre></div>

<p>做完这些后，你就能使用结构化绑定读取或者修改Customer的成员了：</p>
<div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">"structbind2.hpp"</span> </span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span>
<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>{
    <span class="hljs-function">Customer <span class="hljs-title">c</span><span class="hljs-params">(<span class="hljs-string">"Tim"</span>, <span class="hljs-string">"Starr"</span>, <span class="hljs-number">42</span>)</span></span>;
    <span class="hljs-keyword">auto</span> [f, l, v] = c;
    std::cout &lt;&lt; <span class="hljs-string">"f/l/v: "</span> &lt;&lt; f &lt;&lt; <span class="hljs-string">' '</span> &lt;&lt; l &lt;&lt; <span class="hljs-string">' '</span> &lt;&lt; v &lt;&lt; <span class="hljs-string">'\n'</span>;
    <span class="hljs-comment">// modify structured bindings via references:</span>
    <span class="hljs-keyword">auto</span> &amp;&amp;[f2, l2, v2] = c;
    std::string s = std::<span class="hljs-built_in">move</span>(f2);
    f2 = <span class="hljs-string">"Ringo"</span>;
    v2 += <span class="hljs-number">10</span>;
    std::cout &lt;&lt; <span class="hljs-string">"f2/l2/v2: "</span> &lt;&lt; f2 &lt;&lt; <span class="hljs-string">' '</span> &lt;&lt; l2 &lt;&lt; <span class="hljs-string">' '</span> &lt;&lt; v2 &lt;&lt; <span class="hljs-string">'\n'</span>;
    std::cout &lt;&lt; <span class="hljs-string">"c: "</span> &lt;&lt; c.<span class="hljs-built_in">firstname</span>() &lt;&lt; <span class="hljs-string">' '</span> &lt;&lt; c.<span class="hljs-built_in">lastname</span>() &lt;&lt; <span class="hljs-string">' '</span> &lt;&lt; c.<span class="hljs-built_in">value</span>() &lt;&lt; <span class="hljs-string">'\n'</span>;
    std::cout &lt;&lt; <span class="hljs-string">"s: "</span> &lt;&lt; s &lt;&lt; <span class="hljs-string">'\n'</span>; 
}</code></pre></div>

<p>它会输出：</p>
<div class="code-wrapper"><pre><code class="hljs bash">f/l/v: Tim Starr 42
f2/l2/v2: Ringo Starr 52
c: Ringo Starr 52
s: Tim</code></pre></div>

<h4><span id="1-4-hou-ji">1.4 后记</span><a href="#1-4-hou-ji" class="header-anchor">#</a></h4><p> 结构化绑定最初由Herb Sutter，Bjarne Stroustrup和Gabriel Dos Reis在<a href="https://gitee.com/link?target=https://wg21.link/p0144r0">https://wg21.link/p0144r0</a>中提出，当时使用花括号而不是方括号。最后这个特性的公认措辞是由Jens Maurer在<a href="https://gitee.com/link?target=https://wg21.link/p0217r3">https://wg21.link/p0217r3</a>中给出。 </p>
<h3><span id="2-if-he-switch-chu-shi-hua">2 if 和 switch 初始化</span><a href="#2-if-he-switch-chu-shi-hua" class="header-anchor">#</a></h3><p>现在<strong>if</strong>和<strong>switch</strong>控制结构允许我们在普通的条件语句或者选择语句之外再指定一个初始化语句。</p>
<p>比如，你可以这样写：</p>
<div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">if</span> (status s = <span class="hljs-built_in">check</span>(); s != status::success) {
    <span class="hljs-keyword">return</span> s;
}</code></pre></div>

<p>其中初始化语句是：</p>
<div class="code-wrapper"><pre><code class="hljs c++">status s = <span class="hljs-built_in">check</span>();</code></pre></div>

<p>它初始化s，然后用if判断s是否是有效状态。</p>
<h4><span id="2-1-if-chu-shi-hua">2.1 if 初始化。</span><a href="#2-1-if-chu-shi-hua" class="header-anchor">#</a></h4><p>任何在if语句内初始化的值的生命周期都持续到then代码块或者else代码块（如果有的话）的最后。比如：</p>
<div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">if</span> (std::ofstream strm = <span class="hljs-built_in">getLogStrm</span>(); coll.<span class="hljs-built_in">empty</span>()) {
    strm &lt;&lt; <span class="hljs-string">"&lt;no data&gt;\n"</span>; 
}
<span class="hljs-keyword">else</span> {
    <span class="hljs-keyword">for</span> (<span class="hljs-type">const</span> <span class="hljs-keyword">auto</span>&amp; elem : coll) {
        strm &lt;&lt; elem &lt;&lt; <span class="hljs-string">'\n'</span>; 
    } 
}
<span class="hljs-comment">// strm no longer declared</span></code></pre></div>

<p>strm的析构函数回在then代码块或者else代码块的最后调用。</p>
<p>另一个例子是执行一些依赖某些条件的任务的时候使用锁：</p>
<div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">if</span> (std::lock_guard&lt;std::mutex&gt; lg{collMutex}; !coll.<span class="hljs-built_in">empty</span>()) {
    std::cout &lt;&lt; coll.<span class="hljs-built_in">front</span>() &lt;&lt; <span class="hljs-string">'\n'</span>; 
}</code></pre></div>

<p>因为有<strong>类模板参数推导</strong>，也可以这样写：</p>
<div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">if</span> (std::lock_guard lg{collMutex}; !coll.<span class="hljs-built_in">empty</span>()) {
    std::cout &lt;&lt; coll.<span class="hljs-built_in">front</span>() &lt;&lt; <span class="hljs-string">'\n'</span>; 
}</code></pre></div>

<p>任何情况下，上面的代码都等价于：</p>
<div class="code-wrapper"><pre><code class="hljs c++">{
    std::lock_guard&lt;std::mutex&gt; lg{collMutex};
    <span class="hljs-keyword">if</span> (!coll.<span class="hljs-built_in">empty</span>()) {
        std::cout &lt;&lt; coll.<span class="hljs-built_in">front</span>() &lt;&lt; <span class="hljs-string">'\n'</span>; 
    } 
}</code></pre></div>

<p>区别在于lg是在if语句的作用域中定义的，因此与条件在相同的作用域（声明性区域）中，就像for循环中初始化的情况一样。</p>
<p>任何被初始化的对象都必须有一个名字。否则，初始化语句会长久一个立即销毁大的临时值。举个例子，初始化一个没有名字的lock guard，其后的条件检查不是在加锁环境下进行的：</p>
<div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">if</span> (std::lock_guard&lt;std::mutex&gt;{collMutex}; <span class="hljs-comment">// run-time ERROR:</span>
    !coll.<span class="hljs-built_in">empty</span>()) { <span class="hljs-comment">// - no longer locked</span>
    std::cout &lt;&lt; coll.<span class="hljs-built_in">front</span>() &lt;&lt; <span class="hljs-string">'\n'</span>; <span class="hljs-comment">// - no longer locked</span>
}</code></pre></div>

<p>一般来说，一个<code>_</code>作为名字也是可以的（一些程序员喜欢它，另一些讨厌它因为它污染全局命名空间）：</p>
<div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">if</span> (std::lock_guard&lt;std::mutex&gt; _{collMutex}; <span class="hljs-comment">// OK, but...</span>
    !coll.<span class="hljs-built_in">empty</span>()) {
    std::cout &lt;&lt; coll.<span class="hljs-built_in">front</span>() &lt;&lt; <span class="hljs-string">'\n'</span>;
}</code></pre></div>

<p>接下来是第三个例子，考虑一段代码，插入新元素到map或者unordered map。你可以检查操作是否成功，就像下面一样：</p>
<div class="code-wrapper"><pre><code class="hljs c++">std::map&lt;std::string, <span class="hljs-type">int</span>&gt; coll;
... 
    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">auto</span> [pos, ok] = coll.<span class="hljs-built_in">insert</span>({<span class="hljs-string">"new"</span>, <span class="hljs-number">42</span>}); !ok) {
        <span class="hljs-comment">// if insert failed, handle error using iterator pos:</span>
        <span class="hljs-type">const</span> <span class="hljs-keyword">auto</span> &amp;[key, val] = *pos;
        std::cout &lt;&lt; <span class="hljs-string">"already there: "</span> &lt;&lt; key &lt;&lt; <span class="hljs-string">'\n'</span>;
    }</code></pre></div>

<p>这段代码还是用了结构化绑定，给返回值和元素插入的位置pos分别赋予了名字，而不是first和second。在C++17前，上面相应的检查必须像下面一样规范：</p>
<div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">auto</span> ret = coll.<span class="hljs-built_in">insert</span>({<span class="hljs-string">"new"</span>, <span class="hljs-number">42</span>});
<span class="hljs-keyword">if</span> (!ret.second) {
    <span class="hljs-comment">// if insert failed, handle error using iterator ret.first</span>
    <span class="hljs-type">const</span> <span class="hljs-keyword">auto</span> &amp;elem = *(ret.first);
    std::cout &lt;&lt; <span class="hljs-string">"already there: "</span> &lt;&lt; elem.first &lt;&lt; <span class="hljs-string">'\n'</span>;
}</code></pre></div>

<p>注意这种带if的初始化也能用于编译时if特性。</p>
<h4><span id="2-2-switch-chu-shi-hua">2.2 switch 初始化。</span><a href="#2-2-switch-chu-shi-hua" class="header-anchor">#</a></h4><p>使用带初始化的switch语句允许我们在检查条件并决定控制流跳转到哪个case执行之前初始化一个对象。</p>
<p>比如，我们可以先初始化一个<strong>文件系统路径</strong>，再根据路径的类型选择对应的处理方式：</p>
<div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std::filesystem;
... 
<span class="hljs-keyword">switch</span> (path <span class="hljs-built_in">p</span>(name); 
<span class="hljs-built_in">status</span>(p).<span class="hljs-built_in">type</span>()) {
    <span class="hljs-keyword">case</span> file_type::not_found:
        std::cout &lt;&lt; p &lt;&lt; <span class="hljs-string">" not found\n"</span>;
        <span class="hljs-keyword">break</span>;
    <span class="hljs-keyword">case</span> file_type::directory:
        std::cout &lt;&lt; p &lt;&lt; <span class="hljs-string">":\n"</span>;
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> &amp;e : std::filesystem::<span class="hljs-built_in">directory_iterator</span>(p)) {
                std::cout &lt;&lt; <span class="hljs-string">"- "</span> &lt;&lt; e.<span class="hljs-built_in">path</span>() &lt;&lt; <span class="hljs-string">'\n'</span>;
        }
        <span class="hljs-keyword">break</span>;
    <span class="hljs-keyword">default</span>:
        std::cout &lt;&lt; p &lt;&lt; <span class="hljs-string">" exists\n"</span>;
        <span class="hljs-keyword">break</span>;
}</code></pre></div>

<p>初始化的p能在整个switch语句中使用。</p>
<h4><span id="2-3-hou-ji">2.3 后记</span><a href="#2-3-hou-ji" class="header-anchor">#</a></h4><p>带初始化的if和switch最初由Thomas Koppe在<a href="https://gitee.com/link?target=https://wg21.link/p0305r0">https://wg21.link/p0305r0</a>中提出，当时只有带初始化的if没有带初始化的switch。最后这个特性的公认措辞是由Thomas Koppe在<a href="https://gitee.com/link?target=https://wg21.link/p0305r1">https://wg21.link/p0305r1</a>中给出。  </p>
<h3><span id="3-nei-lian-bian-liang">3 内联变量</span><a href="#3-nei-lian-bian-liang" class="header-anchor">#</a></h3><p>C++的一个优点是它支持header-only（译注：即只有头文件）的库。然而，截止C++17，header-only的库也不能有全局变量或者对象出现。</p>
<p>C++17后，你可以在头文件中使用inline定义变量，如果这个变量被多个翻译单元（translation unit）使用，它们都会指向相同对象：</p>
<div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyClass</span> {
    <span class="hljs-type">static</span> <span class="hljs-keyword">inline</span> std::string name = <span class="hljs-string">""</span>; <span class="hljs-comment">// OK since C++17</span>
    ...
};
<span class="hljs-keyword">inline</span> MyClass myGlobalObj; <span class="hljs-comment">// OK even if included/defined by multiple CPP files</span></code></pre></div>

<h4><span id="3-1-nei-lian-bian-liang-de-dong-ji">3.1 内联变量的动机</span><a href="#3-1-nei-lian-bian-liang-de-dong-ji" class="header-anchor">#</a></h4><p>C++不允许在class内部初始化非const静态成员：</p>
<div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyClass</span> {
    <span class="hljs-type">static</span> std::string name = <span class="hljs-string">""</span>;  <span class="hljs-comment">// Compile-Time ERROR</span>
    ...
};</code></pre></div>

<p>在class外面定义这个变量定义这个变量，且变量定义是在头文件中，多个CPP文件包含它，仍然会引发错误：</p>
<div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyClass</span> {
    <span class="hljs-type">static</span> std::string name; <span class="hljs-comment">// OK</span>
    ...
};
MyClass::name = <span class="hljs-string">""</span>; <span class="hljs-comment">// Link ERROR if included by multiple CPP files</span></code></pre></div>

<p>根据一处定义规则（one definition 入了，ODR），每个翻译单元只能定义变量最多一次。</p>
<p>即便有预处理保护（译注：也叫头文件保护，header guard）也没有用：</p>
<div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">ifndef</span> MYHEADER_HPP</span>
<span class="hljs-meta">#<span class="hljs-keyword">define</span> MYHEADER_HPP</span>
<span class="hljs-keyword">class</span> <span class="hljs-title class_">MyClass</span> {
  <span class="hljs-type">static</span> std::string name; <span class="hljs-comment">// OK</span>
  ...
};
MyClass.name = <span class="hljs-string">""</span>; <span class="hljs-comment">// Link ERROR if included by multiple CPP files</span>
<span class="hljs-meta">#<span class="hljs-keyword">endif</span></span></code></pre></div>

<p>不是因为头文件可能被包含多次，问题是两个不同的CPP如果都包含这个头文件，那么<code>MyClass.name</code>可能定义两次。</p>
<p>同样的原因，如果你在头文件中定义一个变量，你会得到一个链接时错误：</p>
<div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyClass</span> {
    ...
};
MyClass myGlobalObject; <span class="hljs-comment">// Link ERROR if included by multiple CPP files</span></code></pre></div>

<h5><span id="lin-shi-jie-jue-fang-an">临时解决方案</span><a href="#lin-shi-jie-jue-fang-an" class="header-anchor">#</a></h5><p>这里有一些临时的应对措施：</p>
<ul>
<li>你可以在class/struct内初始化一个static const整型数据成员：</li>
</ul>
<div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyClass</span> {
    <span class="hljs-type">static</span> <span class="hljs-type">const</span> <span class="hljs-type">bool</span> trace = <span class="hljs-literal">false</span>;
    ...
};</code></pre></div>

<ul>
<li>你可以定义一个返回局部static对象的内联函数：</li>
</ul>
<div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">inline</span> std::string <span class="hljs-title">getName</span><span class="hljs-params">()</span> </span>{
    <span class="hljs-type">static</span> std::string name = <span class="hljs-string">"initial value"</span>;
    <span class="hljs-keyword">return</span> name;
}</code></pre></div>

<ul>
<li>你可以定义一个static成员函数返回它的值：</li>
</ul>
<div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-function">std::string <span class="hljs-title">getMyGlobalObject</span><span class="hljs-params">()</span> </span>{
    <span class="hljs-type">static</span> std::string myGlobalObject = <span class="hljs-string">"initial value"</span>;
    <span class="hljs-keyword">return</span> myGlobalObject;
}</code></pre></div>

<ul>
<li>你可以使用变量模板（C++14及以后）：</li>
</ul>
<div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T = std::string&gt;
T myGlobalObject = <span class="hljs-string">"initial value"</span>;</code></pre></div>

<ul>
<li>你可以继承一个包含static成员的类模板：</li>
</ul>
<div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> Dummy&gt;
<span class="hljs-keyword">class</span> <span class="hljs-title class_">MyClassStatics</span>
{
    <span class="hljs-type">static</span> std::string name;
};
<span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> Dummy&gt;
std::string MyClassStatics&lt;Dummy&gt;::name = <span class="hljs-string">"initial value"</span>;
<span class="hljs-keyword">class</span> <span class="hljs-title class_">MyClass</span> : <span class="hljs-keyword">public</span> MyClassStatics&lt;<span class="hljs-type">void</span>&gt; {
    ...
};</code></pre></div>

<p>但是这些方法都有不小的负载，可读性也比较差，想要使用全局变量也比较困难。除此之外，全局变量的初始化可能会推迟到它第一次使用的时候，这使得应用程序不能在启动的时候把对象初始化好。（比如用一个对象监控进程）。</p>
<h4><span id="3-2-shi-yong-nei-lian-bian-liang">3.2 使用内联变量</span><a href="#3-2-shi-yong-nei-lian-bian-liang" class="header-anchor">#</a></h4><p>现在，有了inline，你可以在头文件中定义一个全局可用的变量，它可以被多个CPP文件包含：</p>
<div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyClass</span> {
    <span class="hljs-type">static</span> <span class="hljs-keyword">inline</span> std::string name = <span class="hljs-string">""</span>; <span class="hljs-comment">// OK since C++17</span>
    ...
};
<span class="hljs-keyword">inline</span> MyClass myGlobalObj; <span class="hljs-comment">// OK even if included/defined by multiple CPP files</span></code></pre></div>

<p>初始化发生在第一个包含该头文件的翻译单元。</p>
<p>形式化来说，在变量前使用inline和将函数声明为inline有相同的语义：</p>
<ul>
<li>如果每个定义都是相同的，那么它可以在多个翻译单元定义</li>
<li>它必须在使用它的每个翻译单元中定义</li>
</ul>
<p>两者都是通过包含来自同一头文件的定义来实现的。最终程序的行为就像是只有一个变量。</p>
<p>你甚至可以在头文件中定义原子类型的变量：</p>
<div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">inline</span> std::atomic&lt;<span class="hljs-type">bool</span>&gt; ready{<span class="hljs-literal">false</span>};</code></pre></div>

<p>注意，对于<code>std::atomic</code>，通常在定义它的时候你还得初始化它。</p>
<p>这意味着，你仍然必须保证在你初始化它之前类型是完全的（complete）。比如，如果一个struct或者class有一个static成员，类型是自身，那么该成员只能在该类型被声明后才能使用。</p>
<div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">MyType</span> {
    <span class="hljs-type">int</span> value;
    <span class="hljs-built_in">MyType</span>(<span class="hljs-type">int</span> i) : value{i} {
    }
    <span class="hljs-comment">// one static object to hold the maximum value of this type:</span>
    <span class="hljs-type">static</span> MyType max; <span class="hljs-comment">// can only be declared here</span>
    ...
};
<span class="hljs-keyword">inline</span> MyType MyType::max{<span class="hljs-number">0</span>};</code></pre></div>

<p>参见另一个使用内联变量的例子，它会<strong>使用头文件跟踪所有new调用</strong>。</p>
<h4><span id="3-3-constexpr-yin-shi-bao-han-inline">3.3 constexpr 隐式包含 inline</span><a href="#3-3-constexpr-yin-shi-bao-han-inline" class="header-anchor">#</a></h4><p>对于static数据成员，constexpr现在隐式包含inline的语义，所以下面的声明在C++17后会<strong>定义</strong>static数据成员n：</p>
<div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">D</span> {
    <span class="hljs-type">static</span> <span class="hljs-keyword">constexpr</span> <span class="hljs-type">int</span> n = <span class="hljs-number">5</span>; <span class="hljs-comment">// C++11/C++14: declaration</span>
    <span class="hljs-comment">// since C++17: definition</span>
};</code></pre></div>

<p>换句话说，它与下面的代码一样：</p>
<div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">D</span> {
    <span class="hljs-keyword">inline</span> <span class="hljs-type">static</span> <span class="hljs-keyword">constexpr</span> <span class="hljs-type">int</span> n = <span class="hljs-number">5</span>;
};</code></pre></div>

<p>在C++17之前,有时候你也可以只声明不定义。考虑下面的声明：</p>
<div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">D</span> {
    <span class="hljs-type">static</span> <span class="hljs-keyword">constexpr</span> <span class="hljs-type">int</span> n = <span class="hljs-number">5</span>;
};</code></pre></div>

<p>如果不需要<code>D::n</code>的定义，这就足够了，例如，<code>D::n</code>只通过值传递的话：</p>
<div class="code-wrapper"><pre><code class="hljs c++">std::cout &lt;&lt; D::n; <span class="hljs-comment">// OK (ostream::operator&lt;&lt;(int) gets D::n by value)</span></code></pre></div>

<p>如果<code>D::n</code>是传引用到非内联函数，并且/或者函数调用没有优化，那么就是无效的。比如：</p>
<div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">inc</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">int</span>&amp; i)</span></span>;
std::cout &lt;&lt; <span class="hljs-built_in">inc</span>(D::n); <span class="hljs-comment">// usually an ERROR</span></code></pre></div>

<p>这段代码违背了一处定义规则（ODR）。当使用带优化的编译器构建时，它可能正常工作，或者抛出链接时错误指出缺少定义。当使用不带优化的编译器时，几乎可以确定这段代码会由于缺少<code>D::n</code>的定义而拒绝编译：</p>
<p>因此，在C++17前，你不得不在相同的翻译单元定义<code>D::n</code>：</p>
<div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">constexpr</span> <span class="hljs-type">int</span> D::n; <span class="hljs-comment">// C++11/C++14: definition</span>
<span class="hljs-comment">// since C++17: redundant declaration (deprecated)</span></code></pre></div>

<p>当使用C++17构建，在class中的声明本身就是一个定义，所以这段代码就算没有前面的定义也是有效的。前面的定义也是可以的，但是已经废弃。</p>
<h4><span id="3-4-nei-lian-bian-liang-he-thread-local">3.4 内联变量和thread_local</span><a href="#3-4-nei-lian-bian-liang-he-thread-local" class="header-anchor">#</a></h4><p>使用thread_local你可以让每个线程拥有一个内联变量：</p>
<div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">ThreadData</span> {
    <span class="hljs-keyword">inline</span> <span class="hljs-type">static</span> <span class="hljs-keyword">thread_local</span> std::string name; <span class="hljs-comment">// unique name per thread</span>
    ...
};

<span class="hljs-keyword">inline</span> <span class="hljs-keyword">thread_local</span> std::vector&lt;std::string&gt; cache; <span class="hljs-comment">// one cache per thread</span></code></pre></div>

<p>为了演示一个完整的例子，考虑下面的头文件：</p>
<div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-comment">// lang/inlinethreadlocal.hpp</span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span>

<span class="hljs-keyword">struct</span> <span class="hljs-title class_">MyData</span> {
    <span class="hljs-keyword">inline</span> <span class="hljs-type">static</span> std::string gName = <span class="hljs-string">"global"</span>; <span class="hljs-comment">// unique in program</span>
    <span class="hljs-keyword">inline</span> <span class="hljs-type">static</span> <span class="hljs-keyword">thread_local</span> std::string tName = <span class="hljs-string">"tls"</span>; <span class="hljs-comment">// unique per thread</span>
    std::string lName = <span class="hljs-string">"local"</span>; <span class="hljs-comment">// for each object</span>
    ...
    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">print</span><span class="hljs-params">(<span class="hljs-type">const</span> std::string&amp; msg)</span> <span class="hljs-type">const</span> </span>{
    std::cout &lt;&lt; msg &lt;&lt; <span class="hljs-string">'\n'</span>;
    std::cout &lt;&lt; <span class="hljs-string">"- gName: "</span> &lt;&lt; gName &lt;&lt; <span class="hljs-string">'\n'</span>;
    std::cout &lt;&lt; <span class="hljs-string">"- tName: "</span> &lt;&lt; tName &lt;&lt; <span class="hljs-string">'\n'</span>;
    std::cout &lt;&lt; <span class="hljs-string">"- lName: "</span> &lt;&lt; lName &lt;&lt; <span class="hljs-string">'\n'</span>; }
};

<span class="hljs-keyword">inline</span> <span class="hljs-keyword">thread_local</span> MyData myThreadData; <span class="hljs-comment">// one object per thread</span></code></pre></div>

<p>你可以在有<code>main()</code>的翻译单元使用它：</p>
<div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-comment">// lang/inlinethreadlocal1.cpp</span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">"inlinethreadlocal.hpp"</span> </span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;thread&gt;</span></span>
<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">foo</span><span class="hljs-params">()</span></span>;

<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>
<span class="hljs-function"></span>{
    myThreadData.<span class="hljs-built_in">print</span>(<span class="hljs-string">"main() begin:"</span>);
    myThreadData.gName = <span class="hljs-string">"thread1 name"</span>;
    myThreadData.tName = <span class="hljs-string">"thread1 name"</span>;
    myThreadData.lName = <span class="hljs-string">"thread1 name"</span>;
    myThreadData.<span class="hljs-built_in">print</span>(<span class="hljs-string">"main() later:"</span>);
    <span class="hljs-function">std::thread <span class="hljs-title">t</span><span class="hljs-params">(foo)</span></span>;
    t.<span class="hljs-built_in">join</span>();
    myThreadData.<span class="hljs-built_in">print</span>(<span class="hljs-string">"main() end:"</span>);
}</code></pre></div>

<p>你可以在另一个定义<code>foo()</code>的翻译单元使用头文件，其中<code>foo()</code>被不同的线程调用：</p>
<div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-comment">// lang/inlinethreadlocal2.cpp</span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">"inlinethreadlocal.hpp"</span></span>

<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">foo</span><span class="hljs-params">()</span></span>
<span class="hljs-function"></span>{
    myThreadData.<span class="hljs-built_in">print</span>(<span class="hljs-string">"foo() begin:"</span>);
    myThreadData.gName = <span class="hljs-string">"thread2 name"</span>;
    myThreadData.tName = <span class="hljs-string">"thread2 name"</span>;
    myThreadData.lName = <span class="hljs-string">"thread2 name"</span>;
    myThreadData.<span class="hljs-built_in">print</span>(<span class="hljs-string">"foo() end:"</span>);
}</code></pre></div>

<p>程序的输出如下：</p>
<div class="code-wrapper"><pre><code class="hljs bash">main() begin:
- gName: global
- tName: tls
- lName: <span class="hljs-built_in">local</span>
main() later:
- gName: thread1 name
- tName: thread1 name
- lName: thread1 name
foo() begin:
- gName: thread1 name
- tName: tls
- lName: <span class="hljs-built_in">local</span>
foo() end:
- gName: thread2 name
- tName: thread2 name
- lName: thread2 name
main() end:
- gName: thread2 name
- tName: thread1 name
- lName: thread1 name</code></pre></div>

<h4><span id="3-5-hou-ji">3.5 后记</span><a href="#3-5-hou-ji" class="header-anchor">#</a></h4><p>David Krauss的文档<a href="https://gitee.com/link?target=https://wg21.link/n4147">https://wg21.link/n4147</a>是内联变量产生的动机。内联变量最初由Hal Finkel和Richard Smith在<a href="https://gitee.com/link?target=https://wg21.link/n4424">https://wg21.link/n4424</a>中提出。最后这个特性的公认措辞是由Hal Finkel和Richard Smith在<a href="https://gitee.com/link?target=https://wg21.link/p0386r2"> https://wg21.link/p0386r2</a>中给出。 </p>
<h3><span id="4-ju-he-kuo-zhan">4 聚合扩展</span><a href="#4-ju-he-kuo-zhan" class="header-anchor">#</a></h3><p>C++中有一种初始化对象的方式叫做聚合初始化（aggregate initialization），它允许用花括号聚集多个值来初始化。</p>
<div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Data</span> {
    std::string name;
    <span class="hljs-type">double</span> value;
};

Data x{<span class="hljs-string">"test1"</span>, <span class="hljs-number">6.778</span>};</code></pre></div>

<p>从C++17开始，聚合还支持带基类的数据结构，所以下面这种数据结构用列表初始化也是允许的：</p>
<div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">MoreData</span> : Data {
    <span class="hljs-type">bool</span> done;
};
MoreData y{{<span class="hljs-string">"test1"</span>, <span class="hljs-number">6.778</span>}, <span class="hljs-literal">false</span>};</code></pre></div>

<p>正如你看到的，聚合初始化现在支持嵌套的花括号传给基类的成员来初始化。</p>
<p>对于带有成员的子对象的初始化，如果基类或子对象只有一个值，则可以跳过嵌套的大括号：</p>
<div class="code-wrapper"><pre><code class="hljs c++">MoreData y{<span class="hljs-string">"test1"</span>, <span class="hljs-number">6.778</span>, <span class="hljs-literal">false</span>};</code></pre></div>

<h4><span id="4-1-kuo-zhan-ju-he-chu-shi-hua-de-dong-ji">4.1 扩展聚合初始化的动机</span><a href="#4-1-kuo-zhan-ju-he-chu-shi-hua-de-dong-ji" class="header-anchor">#</a></h4><p>如果没有这项特性的话，继承一个类之后就不能使用聚合初始化了，需要你为新类定义一个构造函数：</p>
<div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Cpp14Data</span> : Data {
    <span class="hljs-type">bool</span> done;
    <span class="hljs-built_in">Cpp14Data</span> (<span class="hljs-type">const</span> std::string&amp; s, <span class="hljs-type">double</span> d, <span class="hljs-type">bool</span> b)
        : Data{s,d}, done{b} {
        }
};
Cpp14Data y{<span class="hljs-string">"test1"</span>, <span class="hljs-number">6.778</span>, <span class="hljs-literal">false</span>};</code></pre></div>

<p>现在，有了这个特性我们可以自由的使用嵌套的花括号，如果只传递一个值还可以省略它：</p>
<div class="code-wrapper"><pre><code class="hljs c++">MoreData x{{<span class="hljs-string">"test1"</span>, <span class="hljs-number">6.778</span>}, <span class="hljs-literal">false</span>}; <span class="hljs-comment">// OK since C++17</span>
MoreData y{<span class="hljs-string">"test1"</span>, <span class="hljs-number">6.778</span>, <span class="hljs-literal">false</span>}; <span class="hljs-comment">// OK</span></code></pre></div>

<p>注意，因为它现在是聚合体，其它初始化方式也是可以的：</p>
<div class="code-wrapper"><pre><code class="hljs c++">MoreData u; <span class="hljs-comment">// OOPS: value/done are uninitialized</span>
MoreData z{}; <span class="hljs-comment">// OK: value/done have values 0/false</span></code></pre></div>

<p>如果这个看起来太危险了，你还是最好提供一个构造函数。</p>
<h4><span id="4-2-shi-yong-kuo-zhan-ju-he-chu-shi-hua">4.2 使用扩展聚合初始化</span><a href="#4-2-shi-yong-kuo-zhan-ju-he-chu-shi-hua" class="header-anchor">#</a></h4><p>关于这个特性的常见用法是列表初始化一个C风格的数据结构，该数据结构继承自一个类，然后添加了一些数据成员或者操作。比如：</p>
<div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Data</span> {
  <span class="hljs-type">const</span> <span class="hljs-type">char</span>* name;
  <span class="hljs-type">double</span> value;
};
<span class="hljs-keyword">struct</span> <span class="hljs-title class_">PData</span> : Data {
  <span class="hljs-type">bool</span> critical;
  <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">print</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>{
    std::cout &lt;&lt; <span class="hljs-string">'['</span> &lt;&lt; name &lt;&lt; <span class="hljs-string">','</span> &lt;&lt; value &lt;&lt; <span class="hljs-string">"]\n"</span>; }
};

PData y{{<span class="hljs-string">"test1"</span>, <span class="hljs-number">6.778</span>}, <span class="hljs-literal">false</span>};
y.<span class="hljs-built_in">print</span>();</code></pre></div>

<p>这里里面的花括号会传递给基类Data的数据成员。</p>
<p>你可以跳过一些初始值。这种情况下这些元素是零值初始化（zero initalized）（调用默认构造函数或者将基本数据类型初始化为0，false或者nullptr）。比如：</p>
<div class="code-wrapper"><pre><code class="hljs c++">PData a{};          <span class="hljs-comment">// zero-initialize all elements</span>
PData b{{<span class="hljs-string">"msg"</span>}};   <span class="hljs-comment">// same as {{"msg",0.0},false}</span>
PData c{{}, <span class="hljs-literal">true</span>};  <span class="hljs-comment">// same as {{nullptr,0.0},true}</span>
PData d;            <span class="hljs-comment">// values of fundamental types are unspecified</span></code></pre></div>

<p>注意使用空的花括号和不使用花括号的区别。</p>
<ul>
<li>a零值初始化所有成员，所以name被默认构造，double value被初始化为0.0，bool flag被初始化为false。</li>
<li>d只调用name的默认构造函数。所有其它的成员都没用被初始化，所以值是未指定的（unspecified）。</li>
</ul>
<p>你也可以继承非聚合体来创建一个聚合体。比如：</p>
<div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">MyString</span> : std::string {
    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">print</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>{
        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">empty</span>()) {
            std::cout &lt;&lt; <span class="hljs-string">"&lt;undefined&gt;\n"</span>; }
        <span class="hljs-keyword">else</span> {
            std::cout &lt;&lt; <span class="hljs-built_in">c_str</span>() &lt;&lt; <span class="hljs-string">'\n'</span>; } }
};

MyString x{{<span class="hljs-string">"hello"</span>}};
MyString y{<span class="hljs-string">"world"</span>};</code></pre></div>

<p>甚至还可以继承多个非聚合体：</p>
<div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;
<span class="hljs-keyword">struct</span> <span class="hljs-title class_">D</span> : std::string, std::complex&lt;T&gt;
{
    std::string data;
};</code></pre></div>

<p>然后使用下面的代码初始化它们：</p>
<div class="code-wrapper"><pre><code class="hljs c++">D&lt;<span class="hljs-type">float</span>&gt; s{{<span class="hljs-string">"hello"</span>}, {<span class="hljs-number">4.5</span>,<span class="hljs-number">6.7</span>}, <span class="hljs-string">"world"</span>};        <span class="hljs-comment">// OK since C++17</span>
D&lt;<span class="hljs-type">float</span>&gt; t{<span class="hljs-string">"hello"</span>, {<span class="hljs-number">4.5</span>, <span class="hljs-number">6.7</span>}, <span class="hljs-string">"world"</span>};         <span class="hljs-comment">// OK since C++17</span>
std::cout &lt;&lt; s.data;                              <span class="hljs-comment">// outputs: ”world”</span>
std::cout &lt;&lt; <span class="hljs-built_in">static_cast</span>&lt;std::string&gt;(s);         <span class="hljs-comment">// outputs: ”hello”</span>
std::cout &lt;&lt; <span class="hljs-keyword">static_cast</span>&lt;std::complex&lt;<span class="hljs-type">float</span>&gt;&gt;(s); <span class="hljs-comment">// outputs: (4.5,6.7)</span></code></pre></div>

<p>内部花括号的值（initializer_lists）会传递给基类，其传递顺序遵循基类声明的顺序。</p>
<p>这项新特性还有助于用很少的代码定义<strong>lambdas重载</strong>。</p>
<h4><span id="4-3-ju-he-ti-de-ding-yi">4.3 聚合体的定义</span><a href="#4-3-ju-he-ti-de-ding-yi" class="header-anchor">#</a></h4><p>总结一下，C++17的聚合体（aggregate）定义如下：</p>
<ul>
<li>是个数组</li>
<li>或者是个类类型（class，struct，union），其中<ul>
<li>没有用户声明的构造函数或者explicit构造函数</li>
<li>没有使用using声明继承的构造函数</li>
<li>没有private或者protected的非static数据成员</li>
<li>没有virtual函数</li>
<li>没有virtual，private或者protected基类</li>
</ul>
</li>
</ul>
<p>为了让聚合体可以使用，还要求聚合体没有private或者protected基类成员或者构造函数在初始化的时候使用。</p>
<p>C++17还引入了一种新的type trait即<code>is_aggregate&lt;&gt;</code>来检查一个类型是否是聚合体：</p>
<div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;
<span class="hljs-keyword">struct</span> <span class="hljs-title class_">D</span> : std::string, std::complex&lt;T&gt; {
    std::string data;
};
D&lt;<span class="hljs-type">float</span>&gt; s{{<span class="hljs-string">"hello"</span>}, {<span class="hljs-number">4.5</span>,<span class="hljs-number">6.7</span>}, <span class="hljs-string">"world"</span>}; <span class="hljs-comment">// OK since C++17</span>
std::cout &lt;&lt; std::is_aggregate&lt;<span class="hljs-keyword">decltype</span>(s)&gt;::value; <span class="hljs-comment">// outputs: 1 (true)</span></code></pre></div>

<h4><span id="4-4-xiang-hou-bu-jian-rong">4.4 向后不兼容</span><a href="#4-4-xiang-hou-bu-jian-rong" class="header-anchor">#</a></h4><p>注意，下面示例中的代码将不再能通过编译：</p>
<div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-comment">// lang/aggr14.cpp</span>
<span class="hljs-keyword">struct</span> <span class="hljs-title class_">Derived</span>;
<span class="hljs-keyword">struct</span> <span class="hljs-title class_">Base</span> {
    <span class="hljs-keyword">friend</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">Derived</span>;
<span class="hljs-keyword">private</span>:
    <span class="hljs-built_in">Base</span>() {
    }
};
<span class="hljs-keyword">struct</span> <span class="hljs-title class_">Derived</span> : Base {
};
<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>
<span class="hljs-function"></span>{
    Derived d1{}; <span class="hljs-comment">// ERROR since C++17</span>
    Derived d2; <span class="hljs-comment">// still OK (but might not initialize)</span>
}</code></pre></div>

<p>C++17之前，Derived不是一个聚合体，所以：</p>
<div class="code-wrapper"><pre><code class="hljs c++">Derived d1{};</code></pre></div>

<p>调用Derived隐式定义的默认构造函数，它默认调用基类Base的默认构造函数。虽然基类的默认构造函数是private，但是通过子类的默认构造函数调用它是有效的，因为子类被声明为一个friend类。</p>
<p>C++17开始，Derived是一个聚合体，没有隐式的默认构造函数。所以这个初始化被认为是聚合初始化，聚合初始化不允许调用基类的默认构造函数。不管基类是不是friend都不行。</p>
<h4><span id="4-5-hou-ji">4.5 后记</span><a href="#4-5-hou-ji" class="header-anchor">#</a></h4><p>内联变量最初由Oleg Smolsky在<a href="https://gitee.com/link?target=https://wg21.link/n4404">https://wg21.link/n4404</a>中提出。最后这个特性的公认措辞是由Oleg Smolsky在<a href="https://gitee.com/link?target=https://wg21.link/p0017r1"> https://wg21.link/p0017r1</a>中给出。</p>
<p>新的type trait即<code>std::is_aggregate&lt;&gt;</code>最初作为美国国家机构对C++ 17标准化的评论而引入。（参见<a href="https://gitee.com/link?target=https://wg21.link/lwg2911">https://wg21.link/lwg2911</a>）</p>
<h3><span id="5-qiang-zhi-fu-zhi-sheng-lue-huo-chuan-di-wei-shi-xian-de-dui-xiang">5 强制复制省略或传递未实现的对象</span><a href="#5-qiang-zhi-fu-zhi-sheng-lue-huo-chuan-di-wei-shi-xian-de-dui-xiang" class="header-anchor">#</a></h3><p>本章的主题可以从两个角度来看：</p>
<ul>
<li>C++17引入了新的规则，在确定条件下可以强制消除拷贝：以前临时对象传值或者返回临时对象期间发生的拷贝操作的消除是可选的，现在是强制的。</li>
<li>因此，我们处理传递未具体化对象的值以进行初始化 我将从技术上介绍这个特性，然后讨论具体化（materialization）的效果和相关术语。</li>
</ul>
<h4><span id="5-1-lin-shi-liang-qiang-zhi-fu-zhi-shan-chu-de-dong-ji">5.1 临时量强制复制删除的动机</span><a href="#5-1-lin-shi-liang-qiang-zhi-fu-zhi-shan-chu-de-dong-ji" class="header-anchor">#</a></h4><p> 标准伊始，C++就明确允许一些拷贝操作可以被省略（消除），不调用拷贝构造函数会失去可能存在的副作用，从而可能影响程序的行为，即便这样也在所不惜。强制拷贝消除的场景之一是使用临时对象初始化新对象。这个情况经常发生，尤其是以值传递方式将临时对象传递给一个函数，或者函数返回临时对象。举个例子： </p>
<div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyClass</span>
{
    ...
};
<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">foo</span><span class="hljs-params">(MyClass param)</span> </span>{ <span class="hljs-comment">// param is initialized by passed argument</span>
    ...
}
<span class="hljs-function">MyClass <span class="hljs-title">bar</span><span class="hljs-params">()</span> </span>{
    <span class="hljs-keyword">return</span> <span class="hljs-built_in">MyClass</span>(); <span class="hljs-comment">// returns temporary</span>
}

<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>
<span class="hljs-function"></span>{
    <span class="hljs-built_in">foo</span>(<span class="hljs-built_in">MyClass</span>());       <span class="hljs-comment">// pass temporary to initialize param</span>
    MyClass x = <span class="hljs-built_in">bar</span>();    <span class="hljs-comment">// use returned temporary to initialize x</span>
    <span class="hljs-built_in">foo</span>(<span class="hljs-built_in">bar</span>());           <span class="hljs-comment">// use returned temporary to initialize param</span>
}</code></pre></div>

<p>但是，由于这些拷贝消除优化不是强制的，要拷贝的对象必须提供隐式或显式的拷贝或移动构造函数。也就是说，尽管拷贝/移动构造函数一般不会调用，但是也必须存在。如果没有定义拷贝/移动构造函数，那么代码不能通过编译。</p>
<p>因此，下面MyClass的定义的代码编译不了：</p>
<div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyClass</span>
{
<span class="hljs-keyword">public</span>:
  ...
  <span class="hljs-comment">// no copy/move constructor defined:</span>
  	<span class="hljs-built_in">MyClass</span>(<span class="hljs-type">const</span> MyClass&amp;) = <span class="hljs-keyword">delete</span>;
 	<span class="hljs-built_in">MyClass</span>(MyClass&amp;&amp;) = <span class="hljs-keyword">delete</span>;
  ...
};</code></pre></div>

<p>这里没有拷贝构造函数就足够了，因为仅当没有用户声明的拷贝构造（或者拷贝赋值运算符）时移动构造函数才隐式可用。</p>
<p>C++17后，临时变量初始化新对象期间发生的拷贝是强制消除的。事实上，在后面我们会看到，我们简单的传值作为实参初始化或者返回一个值，该值会接下来用于具体化（materalize）一个新对象。</p>
<p>这意味着就算MyClass类完全没有表示启用拷贝操作，上面的例子也能通过编译。</p>
<p>然而，请注意其他可选的拷贝消除仍然是可选的，仍然要求一个可调用的拷贝或者移动构造函数，比如：</p>
<div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-function">MyClass <span class="hljs-title">foo</span><span class="hljs-params">()</span></span>
<span class="hljs-function"></span>{
  	MyClass obj;
  ...
  	<span class="hljs-keyword">return</span> obj;    <span class="hljs-comment">// still requires copy/move support</span>
}</code></pre></div>

<p>在这里，<code>foo()</code>里面的obj是一个带名字的变量（即左值（lvalue））。所以会发生命名的返回值优化（named return value optimization，NRVO），它要求类型支持拷贝或者移动操作。即便obj是一个参数也仍然如此：</p>
<div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-function">MyClass <span class="hljs-title">bar</span><span class="hljs-params">(MyClass obj)</span> <span class="hljs-comment">// copy elision for passed temporaries</span></span>
<span class="hljs-function"></span>{
  ...
  	<span class="hljs-keyword">return</span> obj; <span class="hljs-comment">// still requires copy/move support</span>
}</code></pre></div>

<p>传递一个临时量（即纯右值（prvalue））到函数作为实参，不会发生拷贝/移动操作，但是返回这个参数仍然需要拷贝/移动操作，因为返回的对象有名字。</p>
<p>作为这一改变的部分，值类别（value categories）修改和新增了很多术语。</p>
<h4><span id="5-2-qiang-zhi-shan-chu-lin-shi-xing-fu-ben-de-dong-ji">5.2 强制删除临时性副本的动机</span><a href="#5-2-qiang-zhi-shan-chu-lin-shi-xing-fu-ben-de-dong-ji" class="header-anchor">#</a></h4><p>很明显，强制拷贝消除的一个好处是:如果拷贝操作开销较大时会得到更好的性能。虽然移动语义显著减少了拷贝开销，但是完全不执行拷贝能极大的提示性能。这可能会减少使用出参（译注：所谓出参即可out parameter，是指使用参数来传递返回信息，通常是一个指针或者引用）代替返回一个值（假设这个值是由返回语句创建的）的需求。</p>
<p>另一个好处是现在只要写一个工厂函数它总是能工作，因为现在的工厂函数可以返回对象，即便对象不允许拷贝/移动。比如，考虑下面的泛型工厂函数：</p>
<div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-comment">// lang/factory.hpp</span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;utility&gt;</span></span>
<span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T, <span class="hljs-keyword">typename</span>... Args&gt;
<span class="hljs-function">T <span class="hljs-title">create</span><span class="hljs-params">(Args&amp;&amp;... args)</span></span>
<span class="hljs-function"></span>{
    ...
    <span class="hljs-keyword">return</span> T{std::forward&lt;Args&gt;(args)...};
}</code></pre></div>

<p>这个函数现在甚至可以用于<code>std::atomic&lt;&gt;</code>这种类型，该类型既没有定义拷贝构造函数也没有定义移动构造函数：</p>
<div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-comment">// lang/factory.cpp</span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">"factory.hpp"</span> </span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;memory&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;atomic&gt;</span></span>

<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>{
    <span class="hljs-type">int</span> i = <span class="hljs-built_in">create</span>&lt;<span class="hljs-type">int</span>&gt;(<span class="hljs-number">42</span>);
    std::unique_ptr&lt;<span class="hljs-type">int</span>&gt; up = create&lt;std::unique_ptr&lt;<span class="hljs-type">int</span>&gt;&gt;(<span class="hljs-keyword">new</span> <span class="hljs-type">int</span>{<span class="hljs-number">42</span>});
    std::atomic&lt;<span class="hljs-type">int</span>&gt; ai = create&lt;std::atomic&lt;<span class="hljs-type">int</span>&gt;&gt;(<span class="hljs-number">42</span>);
}</code></pre></div>

<p>这个特性带来的另一个效果是，如果类有显式delete的移动构造函数，你现在可以返回临时值，然后用它初始化对象：</p>
<div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">CopyOnly</span> {
<span class="hljs-keyword">public</span>:
    <span class="hljs-built_in">CopyOnly</span>() {
    }
    <span class="hljs-built_in">CopyOnly</span>(<span class="hljs-type">int</span>) {
    }
    <span class="hljs-built_in">CopyOnly</span>(<span class="hljs-type">const</span> CopyOnly&amp;) = <span class="hljs-keyword">default</span>;
    <span class="hljs-built_in">CopyOnly</span>(CopyOnly&amp;&amp;) = <span class="hljs-keyword">delete</span>; <span class="hljs-comment">// explicitly deleted</span>
};

<span class="hljs-function">CopyOnly <span class="hljs-title">ret</span><span class="hljs-params">()</span> </span>{
    <span class="hljs-keyword">return</span> CopyOnly{}; <span class="hljs-comment">// OK since C++17</span>
}

CopyOnly x = <span class="hljs-number">42</span>; <span class="hljs-comment">// OK since C++17</span></code></pre></div>

<p>x的初始化代码在C++17之前是无效的，因为拷贝初始化需要将42转换为一个临时对象，然后临时对象原则上需要提供一个移动构造函数，尽管不会用到它。</p>
<h4><span id="5-3-zhi-lei-bie-de-jie-shi">5.3 值类别的解释</span><a href="#5-3-zhi-lei-bie-de-jie-shi" class="header-anchor">#</a></h4><p> 强制拷贝消除带来的额外工作是值类别（value categories）的一些修改。 </p>
<h5><span id="5-3-1-zhi-lei-bie">5.3.1 值类别</span><a href="#5-3-1-zhi-lei-bie" class="header-anchor">#</a></h5><p>在C++中的每个表达式都有一个值类别。这个值类别描述了表达式可以做什么。</p>
<h6><span id="zhi-lei-bie-de-li-shi">值类别的历史</span><a href="#zhi-lei-bie-de-li-shi" class="header-anchor">#</a></h6><p>从C语言历史的角度来看，在赋值语句中只有lvalue（左值）和rvalue（右值）：</p>
<div class="code-wrapper"><pre><code class="hljs c++">x = <span class="hljs-number">42</span>;</code></pre></div>

<p>表达式x是lvalue，因为它可以出现在赋值语句的左边，表达式42是rvalue，因为它只能出现在赋值语句的右边。但是因为ANSI-C，事情变得更复杂一些，因为x如果声明为<code>const int</code>就不能在赋值语句的左边了，但是它仍然是个（不具可修改性的）lvalue。</p>
<p>C++11我们有了可移动的对象，这些对象在语义上是只能出现在赋值语句右边，但是可以被修改，因为赋值语句可以盗取它们的值。基于这个原因，新的值类别xvalue被引入，并且之前的值类别rvalue有了新名字即prvalue。</p>
<h6><span id="c-11-de-zhi-lei-bie">C++11的值类别</span><a href="#c-11-de-zhi-lei-bie" class="header-anchor">#</a></h6><p>C++11后，值类别如图5.1描述的那样：我们的核心值类别是lvalue，prvalue（pure rvalue，纯右值），xvalue（eXpiring value，将亡值）。组合得到的值类别有：glvalue（generalized lvalue，泛化左值，是lvalue和xvalue的结合）以及rvalue（是xvalue和prvalue的结合）。</p>
<h5><span id="5-3-2-c-17-de-zhi-lei-bie">5.3.2 C++17的值类别</span><a href="#5-3-2-c-17-de-zhi-lei-bie" class="header-anchor">#</a></h5><p>现在解释值类别的主要方式是认为我们有两类表达式：</p>
<ul>
<li>glvalue：对象/函数位置的表达式</li>
<li>prvalue：初始化表达式 xvalue被认为是一个特殊的位置，表示有一个变量它的资源可以重用（通常因为它接近它的生命周期结尾）。</li>
</ul>
<p>C++17引入了一个新术语，具体化（materialization），表示在某个时刻一个prvalue成为临时对象。因此，临时变量具体化转换（temporary materialization conversion）是指prvalue到xvalue的转换。</p>
<p>任何时刻，期待出现glvalue（lvalue或xvalue）的地方出现prvalue都是有效的，创建一个临时变量并通过prvalue初始化，然后prvallue被替换为xvalue。因此在上面的例子中，严格来说：</p>
<div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">f</span><span class="hljs-params">(<span class="hljs-type">const</span> X&amp; p)</span></span>; <span class="hljs-comment">// accepts an expression of any value category,</span>
					<span class="hljs-comment">// but expects a glvalue</span>
<span class="hljs-built_in">f</span>(<span class="hljs-built_in">X</span>());             <span class="hljs-comment">// passes a prvalue materialized as xvalue</span></code></pre></div>

<p>因为例子中的<code>f()</code>有一个引用参数，它期待一个glvalue实参。然而，表达式<code>X()</code>是一个prvalue。临时具体化规则因此生效，表达式<code>X()</code>转换为一个xvalue并使用默认构造函数初始化临时变量。</p>
<p>注意具体化不意味着我们创建了一个新的/不同的对象。lvalue引用仍然绑定xvalue和prvalue，虽然后者总是转换到xvalue。</p>
<p>在这些改变后，拷贝消除意义非凡，因为prvalue不再要求可移动，我们只传递一个初始值，这个值迟早会具体化然后初始化一个对象。</p>
<h4><span id="5-4-wei-ju-ti-hua-fan-hui-zhi-chuan-di">5.4 未具体化返回值传递</span><a href="#5-4-wei-ju-ti-hua-fan-hui-zhi-chuan-di" class="header-anchor">#</a></h4><p>未具体化返回值传递是指所有形式的返回临时对象（prvalue）的值：</p>
<ul>
<li>当返回一个不是字符串字面值的字面值：</li>
</ul>
<div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">f1</span><span class="hljs-params">()</span> </span>{    <span class="hljs-comment">// return int by value</span>
    <span class="hljs-keyword">return</span> <span class="hljs-number">42</span>;
}</code></pre></div>

<ul>
<li>当返回类型为临时变量的值或者使用auto：</li>
</ul>
<div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">auto</span> <span class="hljs-title">f2</span><span class="hljs-params">()</span> </span>{   <span class="hljs-comment">// return deduced type by value</span>
    ...
    <span class="hljs-keyword">return</span> MyType{...};
}</code></pre></div>

<ul>
<li>当返回临时对象，并且类型用<code>decltype(auto)</code>推导：</li>
</ul>
<div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">decltype</span>(<span class="hljs-keyword">auto</span>) <span class="hljs-title">f3</span><span class="hljs-params">()</span> </span>{   <span class="hljs-comment">// return temporary from return statement by value</span>
    ...
    <span class="hljs-keyword">return</span> MyType{...};
}</code></pre></div>

<p>记住如果用于初始化的表达式（这里是返回语句）会创建一个临时变量（prvalue），那么用<code>decltype(auto)</code>声明的类型是值。</p>
<p>上述所有形式我们都返回一个prvalue的值，我们不需要任何拷贝/移动的支持。</p>
<h4><span id="5-5-hou-ji">5.5 后记</span><a href="#5-5-hou-ji" class="header-anchor">#</a></h4><p>强制拷贝消除最初由Richard Smith在<a href="https://gitee.com/link?target=https://wg21.link/p0135r0">https://wg21.link/p0135r0</a>中提出。最后这个特性的公认措辞是由Richard Smith在<a href="https://gitee.com/link?target=https://wg21.link/p0135r1">https://wg21.link/p0135r1</a>中给出。</p>
<blockquote>
<p>这一章翻译的不好，后面我会修订</p>
</blockquote>
<h3><span id="6-lambda-kuo-zhan">6 Lambda 扩展</span><a href="#6-lambda-kuo-zhan" class="header-anchor">#</a></h3><p>C++11引入了lambda，C++14引入了泛型lambda，这是一个成功的故事。lambda允许我们将功能指定为参数，这让定制函数的行为变得更加容易。</p>
<p>C++ 17进一步改进，允许lambda用在更多的地方。</p>
<h4><span id="6-1-chang-liang-biao-da-shi-lambda">6.1 常量表达式 Lambda</span><a href="#6-1-chang-liang-biao-da-shi-lambda" class="header-anchor">#</a></h4><p>自C++17后，只要可能，lambda就隐式地用constexpr修饰。也就是说，任何lambda都可以用于编译时上下文，前提是它使用的特性对编译时上下文有效（例如，仅字符串字面值，无静态变量，无virutal变量，无try/catch，无new/delete）。</p>
<p>举个例子，你可以传一个值给lambda，然后用计算的结果作为编译时的<code>std::array&lt;&gt;</code>大小：</p>
<div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">auto</span> squared = [](<span class="hljs-keyword">auto</span> val) { <span class="hljs-comment">// implicitly constexpr since C++17</span>
    <span class="hljs-keyword">return</span> val*val;
};
std::array&lt;<span class="hljs-type">int</span>,squared(5)&gt; a; <span class="hljs-comment">// OK since C++17 =&gt; std::array&lt;int,25&gt;</span></code></pre></div>

<p>如果在不允许constexpr的上下文使用这个特性就不行，但是你仍然可以在运行时傻姑娘上下文使用lambda：</p>
<div class="code-wrapper"><pre><code class="hljs c++">he lambda in run-time contexts:
<span class="hljs-keyword">auto</span> squared2 = [](<span class="hljs-keyword">auto</span> val) {      <span class="hljs-comment">// implicitly constexpr since C++17</span>
    <span class="hljs-type">static</span> <span class="hljs-type">int</span> calls = <span class="hljs-number">0</span>;             <span class="hljs-comment">// OK, but disables lambda for constexpr contexts</span>
    ...
    <span class="hljs-keyword">return</span> val*val;
};
std::array&lt;<span class="hljs-type">int</span>,squared2(5)&gt; a;      <span class="hljs-comment">// ERROR: static variable in compile-time context</span>
std::cout &lt;&lt; <span class="hljs-built_in">squared2</span>(<span class="hljs-number">5</span>) &lt;&lt; <span class="hljs-string">'\n'</span>;   <span class="hljs-comment">// OK</span></code></pre></div>

<p>要知道是否一个lambda在一个编译时上下文有效，你可以将它声明为constexpr：</p>
<div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">auto</span> squared3 = [](<span class="hljs-keyword">auto</span> val) <span class="hljs-keyword">constexpr</span> {    <span class="hljs-comment">// OK since C++17</span>
    <span class="hljs-keyword">return</span> val*val;
};</code></pre></div>

<p>还可以指定返回类型，语法如下：</p>
<div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">auto</span> squared3i = [](<span class="hljs-type">int</span> val) <span class="hljs-keyword">constexpr</span> -&gt; <span class="hljs-type">int</span> { <span class="hljs-comment">// OK since C++17</span>
    <span class="hljs-keyword">return</span> val*val;
};</code></pre></div>

<p>constexpr对于函数的一般规则仍然有效：如果lambda在运行时上下文中使用，相应的功能在运行时执行。</p>
<p>然而，在不允许编译时上下文的地方使用constexpr lambda会得到一个编译时错误：</p>
<div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">auto</span> squared4 = [](<span class="hljs-keyword">auto</span> val) <span class="hljs-keyword">constexpr</span> {
    <span class="hljs-type">static</span> <span class="hljs-type">int</span> calls=<span class="hljs-number">0</span>; <span class="hljs-comment">// ERROR: static variable in compile-time context</span>
    ...
    <span class="hljs-keyword">return</span> val*val;
};</code></pre></div>

<p>如果lambda式显式或隐式的constexpr，那么函数调用操作符也会是constexpr。换句话说，下面的定义：</p>
<div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">auto</span> squared = [](<span class="hljs-keyword">auto</span> val) { <span class="hljs-comment">// implicitly constexpr since C++17</span>
    <span class="hljs-keyword">return</span> val*val;
};</code></pre></div>

<p>会转换为闭包类型：</p>
<div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">CompilerSpecificName</span> {
<span class="hljs-keyword">public</span>:
    ...
    <span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;</span>
<span class="hljs-function">    <span class="hljs-keyword">constexpr</span> <span class="hljs-keyword">auto</span> <span class="hljs-title">operator</span><span class="hljs-params">()</span> <span class="hljs-params">(T val)</span> <span class="hljs-type">const</span> </span>{
      <span class="hljs-keyword">return</span> val*val;
    }
};</code></pre></div>

<p>生成的闭包类型的函数调用操作符是自动附加constexpr的。在C++17中，如果lambda显式定义为constexpr或者隐式定义为constexpr（就像这个例子），那么生成的函数调用运算符也会是constexpr。</p>
<h4><span id="6-2-jiang-this-fu-ben-chuan-di-gei-lambdas">6.2 将this副本传递给 Lambdas</span><a href="#6-2-jiang-this-fu-ben-chuan-di-gei-lambdas" class="header-anchor">#</a></h4><p>当在成员函数中使用lambda时，你不能隐式的访问调用这个成员函数的对象的成员。也就是说，在lambda内部，如果不捕获this，那么你不能使用这个对象的成员：</p>
<div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">C</span> {
<span class="hljs-keyword">private</span>:
    std::string name;
<span class="hljs-keyword">public</span>:
    ...
    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">foo</span><span class="hljs-params">()</span> </span>{
        <span class="hljs-keyword">auto</span> l1 = [] { std::cout &lt;&lt; name &lt;&lt; <span class="hljs-string">'\n'</span>; }; <span class="hljs-comment">// ERROR</span>
        <span class="hljs-keyword">auto</span> l2 = [] { std::cout &lt;&lt; <span class="hljs-keyword">this</span>-&gt;name &lt;&lt; <span class="hljs-string">'\n'</span>; }; <span class="hljs-comment">// ERROR</span>
        ...
    }
};</code></pre></div>

<p>C++11和C++14中可以传this引用或者传this值：</p>
<div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">C</span> {
<span class="hljs-keyword">private</span>:
    std::string name;
<span class="hljs-keyword">public</span>:
    ...
    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">foo</span><span class="hljs-params">()</span> </span>{
        <span class="hljs-keyword">auto</span> l1 = [<span class="hljs-keyword">this</span>] { std::cout &lt;&lt; name &lt;&lt; <span class="hljs-string">'\n'</span>; }; <span class="hljs-comment">// OK</span>
        <span class="hljs-keyword">auto</span> l2 = [=] { std::cout &lt;&lt; name &lt;&lt; <span class="hljs-string">'\n'</span>; }; <span class="hljs-comment">// OK</span>
        <span class="hljs-keyword">auto</span> l3 = [&amp;] { std::cout &lt;&lt; name &lt;&lt; <span class="hljs-string">'\n'</span>; }; <span class="hljs-comment">// OK</span>
        ...
    }
};</code></pre></div>

<p>然而，问题是即使是传递this的值，其底层捕获的仍然是引自对象（即只有<em>指针</em>被拷贝）。如果lambda的生命周期超过了对象的生命周期，这就会出现问题。一个重要的例子是当用lambda为新线程定义task，它应该使用对象的拷贝来避免任何并发或者生命周期问题。另一个原因可能只是传递一个对象的副本当前状态。</p>
<p>C++14有一个临时的解决方案，但是它读起来不好，工作起来也不好：</p>
<div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">C</span> {
<span class="hljs-keyword">private</span>:
    std::string name;
<span class="hljs-keyword">public</span>:
    ...
    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">foo</span><span class="hljs-params">()</span> </span>{
        <span class="hljs-keyword">auto</span> l1 = [thisCopy=*<span class="hljs-keyword">this</span>] { std::cout &lt;&lt; thisCopy.name &lt;&lt; <span class="hljs-string">'\n'</span>; };
        ...
    }
};</code></pre></div>

<p>举个例子，就算使用<code>=</code>或<code>&amp;</code>捕获了对象，开发者仍然可能不小心用到<code>this</code>：</p>
<div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">auto</span> l1 = [&amp;, thisCopy=*<span class="hljs-keyword">this</span>] {
            thisCopy.name = <span class="hljs-string">"new name"</span>;
            std::cout &lt;&lt; name &lt;&lt; <span class="hljs-string">'\n'</span>; <span class="hljs-comment">// OOPS: still the old name</span>
};</code></pre></div>

<p>C++17开始，你可以显式地通过<code>*this</code>说明你想捕获当前对象的复制：</p>
<div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">C</span> {
<span class="hljs-keyword">private</span>:
    std::string name;
<span class="hljs-keyword">public</span>:
    ...
    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">foo</span><span class="hljs-params">()</span> </span>{
        <span class="hljs-keyword">auto</span> l1 = [*<span class="hljs-keyword">this</span>] { std::cout &lt;&lt; name &lt;&lt; <span class="hljs-string">'\n'</span>; };
        ...
    }
};</code></pre></div>

<p>捕获<code>*this</code>意味着当前对象的复制传递到了lambda。</p>
<p>在捕获了<code>*this</code>的情况下你仍然可以捕获其他this，只要没有与其他的发生冲突：</p>
<div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">auto</span> l2 = [&amp;, *<span class="hljs-keyword">this</span>] { ... };     <span class="hljs-comment">// OK</span>
<span class="hljs-keyword">auto</span> l3 = [<span class="hljs-keyword">this</span>, *<span class="hljs-keyword">this</span>] { ... };  <span class="hljs-comment">// ERROR</span></code></pre></div>

<p>这里一个完整的例子：</p>
<div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-comment">// lang/lambdathis.cpp</span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;thread&gt;</span></span>

<span class="hljs-keyword">class</span> <span class="hljs-title class_">Data</span> {
    <span class="hljs-keyword">private</span>:
    std::string name;
    <span class="hljs-keyword">public</span>:
    <span class="hljs-built_in">Data</span>(<span class="hljs-type">const</span> std::string&amp; s) : <span class="hljs-built_in">name</span>(s) {
    }
    <span class="hljs-function"><span class="hljs-keyword">auto</span> <span class="hljs-title">startThreadWithCopyOfThis</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>{
        <span class="hljs-comment">// 3秒后使用它启动并返回新线程:</span>
        <span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std::literals;
        <span class="hljs-function">std::thread <span class="hljs-title">t</span><span class="hljs-params">([*<span class="hljs-keyword">this</span>] {</span></span>
<span class="hljs-params"><span class="hljs-function">            std::this_thread::sleep_for(<span class="hljs-number">3</span>s);</span></span>
<span class="hljs-params"><span class="hljs-function">            std::cout &lt;&lt; name &lt;&lt; <span class="hljs-string">'\n'</span>;</span></span>
<span class="hljs-params"><span class="hljs-function">        })</span></span>;
        <span class="hljs-keyword">return</span> t;
    }
};

<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>
<span class="hljs-function"></span>{
    std::thread t;
    {
        Data d{<span class="hljs-string">"c1"</span>};
        t = d.<span class="hljs-built_in">startThreadWithCopyOfThis</span>();
    } <span class="hljs-comment">// d is no longer valid</span>
    t.<span class="hljs-built_in">join</span>();
}</code></pre></div>

<p>lambda用<code>*this</code>获取对象拷贝，即d。因此，即便是d的析构函数被调用后线程再使用传递的对象也没有问题。</p>
<p>如果我们使用<code>[this],[=]</code>或<code>[&amp;]</code>捕获this，线程会产生未定义行为，因为在lambda打印name时，lambda使用的是已经析构后的对象的成员。</p>
<h4><span id="6-3-yin-yong-bu-huo">6.3 引用捕获</span><a href="#6-3-yin-yong-bu-huo" class="header-anchor">#</a></h4><p> 通过使用新的utility库函数，你现在可以<strong>捕获const对象引用</strong>。 </p>
<h4><span id="6-4-hou-ji">6.4 后记</span><a href="#6-4-hou-ji" class="header-anchor">#</a></h4><p>constexpr最初由 Faisal Vali, Ville Voutilainen和Gabriel Dos Reis在<a href="https://gitee.com/link?target=https://wg21.link/n4487">https://wg21.link/n4487</a>中提出。最后这个特性的公认措辞是由Faisal Vali, Jens Maurer和Richard Smith在<a href="https://gitee.com/link?target=https://wg21.link/p0170r1">https://wg21.link/p0170r1</a>中给出。</p>
<p>捕获<code>*this</code>最初由H. Carter Edwards, Christian Trott, Hal Finkel, Jim Reus, Robin Maffeo和Ben Sander在<a href="https://gitee.com/link?target=https://wg21.link/p0018r0">https://wg21.link/p0018r0</a>中提出。最后这个特性的公认措辞是由 H. Carter Edwards, Daveed Vandevoorde, Christian Trott, Hal Finkel, Jim Reus, Robin Maffeo和Ben Sander在<a href="https://gitee.com/link?target=https://wg21.link/p0180r3">https://wg21.link/p0180r3</a>中给出。</p>
<h3><span id="7-xin-shu-xing-he-shu-xing-te-xing">7 新属性和属性特性</span><a href="#7-xin-shu-xing-he-shu-xing-te-xing" class="header-anchor">#</a></h3><p> C++11开始，你可以指定属性（attribute，一种规范的注解，可以启用或者禁用一些warning）。C++17还引入了新的属性。此外，属性现在可以在更多的地方使用，并且有一些额外的便利。 </p>
<h4><span id="7-1-shu-xing-nodiscard">7.1 属性[[nodiscard]]</span><a href="#7-1-shu-xing-nodiscard" class="header-anchor">#</a></h4><p>新属性<code>[[nodiscard]]</code>用于鼓励编译器，当发现函数返回值没有被使用的时候，产生一个warning。</p>
<p>通常，这个属性可以用于通知一些返回值没有使用的错误行为。错误行为可能是：</p>
<ul>
<li><strong>内存泄漏</strong>，比如没有使用已经分配并返回的内存</li>
<li><strong>不符合期望，或者非直观行为</strong>，比如没有使用返回值时候可能产生的一些不同寻常/不符合期望的行为</li>
<li><strong>不必要的负载</strong>，比如如果没有使用返回值，这个调用过程相当于无操作。</li>
</ul>
<p>这是一些例子，它们展示了这个属性的是有用的：</p>
<ul>
<li>分配资源必须由另一个函数释放的函数应标记为 <code>[[nodiscard]]</code>。 一个典型的例子是分配内存的函数，例如<code>malloc()</code>或分配器的成员函数<code>allocate()</code>。 但是请注意，某些函数可能会返回一个值，后续无需再针对这个值做其他调用。 例如，程序员调用大小为零字节的C函数<code>realloc(0</code>以释放内存，这个函数的返回值就不必保存以后再调用<code>free()</code></li>
<li>一个关于不使用返回值那么函数的行为将会改变的例子是<code>std::async</code>（由C++11引入）。它的目的是异步启动任务，并返回一个句柄以等待其结束（并使用结果）。当返回值没使用时，这个调用会成为同步调用，因为未使用的返回值的析构函数会立即调用，即立刻开始等待任务结束。 因此，不使用返回值会与<code>std::async()</code>的设计目的相矛盾。 这种情况下用<code>[[nodiscard]]</code>让编译器对此发出警告。</li>
<li>另一个例子是成员函数<code>empty()</code>，它检查对象是否没有元素。程序员有时候可能错误的调用这个函数来清空容器（译注：即误以为empty做动词）</li>
</ul>
<div class="code-wrapper"><pre><code class="hljs c++">cont.<span class="hljs-built_in">empty</span>();</code></pre></div>

<p>这种对<code>empty()</code>的误用可以被检查出来，因为它的返回值没有被使用。将成员函数标注这个属性即可：</p>
<div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyContainer</span> {
    ...;
<span class="hljs-keyword">public</span>:
    [[nodiscard]] <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">empty</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> <span class="hljs-keyword">noexcept</span></span>;
    ...;
};</code></pre></div>

<p>尽管这个是C++17引入的，但是标准库至今都没有使用它。对于C++17来说，应用此功能的建议来得太晚了。因此关于这个特性的关键动机，即为<code>std::async()</code>的声明添加现在都没有完成。对于上述所有示例，下一个C++标准将附带相应的修复程序（具体参见已经接受的提案<a href="https://gitee.com/link?target=https://wg21.link/p0600r1">https://wg21.link/p0600r1</a>）。为了使代码更具可移植性，你应该使用它，而不是使用不可移植的方式（比如gcc或者clang的<code>[[gnu:warn_unused_result]]</code>）来标注函数。当定义<code>operator new()</code>时你应该为函数标记<code>[[nodiscard]]</code>。</p>
<h4><span id="7-2-shu-xing-maybe-unused">7.2 属性[[maybe_unused]]</span><a href="#7-2-shu-xing-maybe-unused" class="header-anchor">#</a></h4><p>新属性<code>[[maybe_unused]]</code>可以用来避免编译器为未被使用的名字或者对象发出警告。</p>
<p>这个属性可以用在类声明上、类型定义<code>typedef</code>或者<code>using</code>上、变量、非静态数据成员、函数、枚举类型或者枚举值。</p>
<p>这个属性的一个应用是标记那些不是必要的参数：</p>
<div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">foo</span><span class="hljs-params">(<span class="hljs-type">int</span> val, [[maybe_unused]] std::string msg)</span></span>
<span class="hljs-function"></span>{
    <span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> DEBUG</span>
    <span class="hljs-built_in">log</span>(msg);
    <span class="hljs-meta">#<span class="hljs-keyword">endif</span></span>
    ...
}</code></pre></div>

<p>另一个例子是标记可能不会使用的成员</p>
<div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyStruct</span> {
    <span class="hljs-type">char</span> c;
    <span class="hljs-type">int</span> i;
    [[maybe_unused]] <span class="hljs-type">char</span> makeLargerSize[<span class="hljs-number">100</span>];
    ...
};</code></pre></div>

<p>注意，你不能为一个语句标注<code>[[maybe_unused]]</code>。基于这个原因，你不能使用让<code>[[maybe_unused]]</code>与<code>[[nodiscard]]</code>相见：</p>
<div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>
<span class="hljs-function"></span>{
    <span class="hljs-built_in">foo</span>(); <span class="hljs-comment">// WARNING: return value not used</span>
    [[maybe_unused]] <span class="hljs-built_in">foo</span>(); <span class="hljs-comment">// ERROR: attribute not allowed here</span>
    [[maybe_unused]] <span class="hljs-keyword">auto</span> x = <span class="hljs-built_in">foo</span>(); <span class="hljs-comment">// OK</span>
}</code></pre></div>

<h4><span id="7-3-shu-xing-fallthrough">7.3 属性[[fallthrough]]</span><a href="#7-3-shu-xing-fallthrough" class="header-anchor">#</a></h4><p>新属性<code>[[fallthrough]]</code>可以让编译器不警告那些switch中的某个case没有break，导致其他case被相继执行的情况。</p>
<p>比如：</p>
<div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">commentPlace</span><span class="hljs-params">(<span class="hljs-type">int</span> place)</span></span>
<span class="hljs-function"></span>{
    <span class="hljs-keyword">switch</span> (place) {
        <span class="hljs-keyword">case</span> <span class="hljs-number">1</span>:
            std::cout &lt;&lt; <span class="hljs-string">"very "</span>;
            [[fallthrough]];
        <span class="hljs-keyword">case</span> <span class="hljs-number">2</span>:
            std::cout &lt;&lt; <span class="hljs-string">"well\n"</span>;
            <span class="hljs-keyword">break</span>;
        <span class="hljs-keyword">default</span>:
            std::cout &lt;&lt; <span class="hljs-string">"OK\n"</span>;
            <span class="hljs-keyword">break</span>; 
    } 
}</code></pre></div>

<p>传递1会输出</p>
<div class="code-wrapper"><pre><code class="hljs bash">very well</code></pre></div>

<p>同时执行了case 1和case 2。</p>
<p>注意这个属性必须被用在空语句中。因此，你需要在它尾巴上加个分号。</p>
<p>在switch的最后一条语句使用这个属性是不允许的。</p>
<h4><span id="7-4-tong-yong-shu-xing-kuo-zhan">7.4 通用属性扩展</span><a href="#7-4-tong-yong-shu-xing-kuo-zhan" class="header-anchor">#</a></h4><p>下面的特性在C++17中被启用：</p>
<ol>
<li>现在允许为namespace标记属性。比如，你可以像下面代码一样弃用一个命名空间：</li>
</ol>
<div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">namespace</span> [[deprecated]] DraftAPI {
  ...
}</code></pre></div>

<p>也可以用于inline namespace和匿名namespace。 </p>
<ol start="2">
<li>枚举值现在也可以标注属性。</li>
</ol>
<p>比如，你可以引入新的枚举值代替原有的枚举值，然后弃用原有枚举值：</p>
<div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">enum class</span> <span class="hljs-title class_">City</span> { Berlin = <span class="hljs-number">0</span>,
                 NewYork = <span class="hljs-number">1</span>,
                 Mumbai = <span class="hljs-number">2</span>, Bombay [[deprecated]] = Mumbai,
                 ... };</code></pre></div>

<p>Mumbai和Bombay都表示相同的city数值，但是Bombay已经弃用。注意标记枚举值时，语法上需要将属性放到枚举值名字的后面。</p>
<ol start="3">
<li>用户定义的属性它们通常在自己的namespace定义，你现在可以使用using来避免重复书写namespace。换句话说，以前写法是：</li>
</ol>
<div class="code-wrapper"><pre><code class="hljs c++">[[MyLib::WebService, MyLib::RestService, MyLib::<span class="hljs-built_in">doc</span>(<span class="hljs-string">"html"</span>)]] <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">foo</span><span class="hljs-params">()</span></span>;</code></pre></div>

<p>现在你可以这么写：</p>
<div class="code-wrapper"><pre><code class="hljs c++">[[<span class="hljs-keyword">using</span> MyLib: WebService, RestService, <span class="hljs-built_in">doc</span>(<span class="hljs-string">"html"</span>)]] <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">foo</span><span class="hljs-params">()</span></span>;</code></pre></div>

<p>注意用了using之后再书写namespace前缀会出错的：</p>
<div class="code-wrapper"><pre><code class="hljs c++">[[<span class="hljs-keyword">using</span> MyLib: MyLib::<span class="hljs-built_in">doc</span>(<span class="hljs-string">"html"</span>)]] <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">foo</span><span class="hljs-params">()</span></span>; <span class="hljs-comment">// ERROR</span></code></pre></div>

<h4><span id="7-5-hou-ji">7.5 后记</span><a href="#7-5-hou-ji" class="header-anchor">#</a></h4><p>这三个属性最初由Andrew Tomazos在<a href="https://gitee.com/link?target=https://wg21.link/p0068r0">https://wg21.link/p0068r0</a>中提出。最后<code>[[nodiscard]]</code>的公认措辞是由Andrew Tomazos在<a href="https://gitee.com/link?target=https://wg21.link/p0189r1">https://wg21.link/p0189r1</a>中给出。<code>[[maybe_unused]]</code>的公认措辞是由Andrew Tomazos在<a href="https://gitee.com/link?target=https://wg21.link/p0212r1">https://wg21.link/p0212r1</a>中给出。<code>[[fallthrough]]</code>的公认措辞是由Andrew Tomazos在<a href="https://gitee.com/link?target=https://wg21.link/p0188r1">https://wg21.link/p0188r1</a>中给出。</p>
<p>允许namespace和枚举值标注属性这个特性最初由 Richard Smith在<a href="https://gitee.com/link?target=https://wg21.link/n4196">https://wg21.link/n4196</a>中提出。最后的公认措辞是由 Richard Smith在<a href="https://gitee.com/link?target=https://wg21.link/n4266">https://wg21.link/n4266</a>中给出。</p>
<p>属性允许使用using这个特性最初由J. Daniel Garcia, Luis M. Sanchez, Massimo Torquati, Marco Danelutto和Peter Sommerlad在<a href="https://gitee.com/link?target=https://wg21.link/p0028r0">https://wg21.link/p0028r0</a>中提出。最后的公认措辞是由J. Daniel Garcia and Daveed Vandevoorde在<a href="https://gitee.com/link?target=https://wg21.link/P0028R4">https://wg21.link/P0028R4</a>中给出。</p>
<h3><span id="8-qi-ta-yu-yan-te-xing">8 其他语言特性</span><a href="#8-qi-ta-yu-yan-te-xing" class="header-anchor">#</a></h3><p> 有一些小的C++核心语言特性改动，它们会在本章描述。 </p>
<h4><span id="8-1-qian-tao-ming-ming-kong-jian">8.1 嵌套命名空间</span><a href="#8-1-qian-tao-ming-ming-kong-jian" class="header-anchor">#</a></h4><p>最早这个提案是在2003年提出的，C++标准委员会现在终于最终接受了它：</p>
<div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">namespace</span> A::B::C {
    ...
}</code></pre></div>

<p>它等价于:</p>
<div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">namespace</span> A {
    <span class="hljs-keyword">namespace</span> B {
        <span class="hljs-keyword">namespace</span> C {
            ...
        }
    }
}</code></pre></div>

<p>嵌套的inline命名空间还不支持。这是因为如果用了inline就不知道到底inline是针对最后一个还是对所有命名空间使用。</p>
<h4><span id="8-2-ding-yi-biao-da-shi-qiu-zhi-shun-xu">8.2 定义表达式求值顺序</span><a href="#8-2-ding-yi-biao-da-shi-qiu-zhi-shun-xu" class="header-anchor">#</a></h4><p>很多代码库和C++书籍包含的代码首先给出符合直觉的假设，然后代码上看起来是有效的，但是严格来讲，这些代码可能产生未定义行为。一个例子是使用寻找并替换子字符串：</p>
<div class="code-wrapper"><pre><code class="hljs c++">std::string s = <span class="hljs-string">"I heard it even works if you don't believe"</span>;
s.<span class="hljs-built_in">replace</span>(<span class="hljs-number">0</span>,<span class="hljs-number">8</span>,<span class="hljs-string">""</span>).<span class="hljs-built_in">replace</span>(s.<span class="hljs-built_in">find</span>(<span class="hljs-string">"even"</span>),<span class="hljs-number">4</span>,<span class="hljs-string">"sometimes"</span>)
    .<span class="hljs-built_in">replace</span>(s.<span class="hljs-built_in">find</span>(<span class="hljs-string">"you don✬t"</span>),<span class="hljs-number">9</span>,<span class="hljs-string">"I"</span>);</code></pre></div>

<p>直觉上看起来这段代码是有效的，它将前8个字符替换为空，“even”替换为“sometimes”，将“you don’t”替换为“I”：</p>
<div class="code-wrapper"><pre><code class="hljs bash">it sometimes works <span class="hljs-keyword">if</span> I believe</code></pre></div>

<p>然而，在C++17之前，结果是不保证的，因为，虽然<code>find()</code>调用返回从何处开始替换，但是当整个语句执行并且在结果被需要之前，这个调用可能在任何时候执行。实际上，所有<code>find()</code>，即计算待替换的起始索引，都可能在任何替换发生前被执行，因此结果是：</p>
<div class="code-wrapper"><pre><code class="hljs bash">it sometimes works <span class="hljs-keyword">if</span> I believe</code></pre></div>

<p>其他结果也是可能的：</p>
<div class="code-wrapper"><pre><code class="hljs bash">it sometimes workIdon’t believe
it even worsometiIdon’t believe
it even worsometimesf youIlieve</code></pre></div>

<p>另一个例子是使用输出运算符来打印计算后的表达式的值：</p>
<div class="code-wrapper"><pre><code class="hljs c++">std::cout &lt;&lt; <span class="hljs-built_in">f</span>() &lt;&lt; <span class="hljs-built_in">g</span>() &lt;&lt; <span class="hljs-built_in">h</span>();</code></pre></div>

<p>通常的假设是<code>f()</code>在<code>g()</code>之前被调用，两者又都在<code>h()</code>之前被调用。然而，这个假设是错误的。<code>f()</code>，<code>g()</code>和<code>h()</code>可以按任意顺序调用，这可能导致一些奇怪的，甚至是糟糕的结果，尤其是当这些调用互相依赖时</p>
<p>具体来说，考虑下面的例子，在C++17之前，这段代码会产生未定义行为：</p>
<div class="code-wrapper"><pre><code class="hljs c++">i = <span class="hljs-number">0</span>;
std::cout &lt;&lt; ++i &lt;&lt; <span class="hljs-string">' '</span> &lt;&lt; --i &lt;&lt; <span class="hljs-string">'\n'</span>;</code></pre></div>

<p>在C++17之前，他可能输出<code>1 0</code>，也可能输出<code>0 -1</code>，甚至是<code>0 0</code>。不管i是int还是用户定义的类型，都可能这样。（对于基本类型，一些编译器至少会warning这个问题）。</p>
<p>要修复这个未定义行为，一些运算符/操作符的求值被挑战，因此现在它们有确定的求值顺序：</p>
<ul>
<li>对于<ul>
<li><code>e1 [ e2 ]</code></li>
<li><code>e1 . e2</code></li>
<li><code>e1 .* e2</code></li>
<li><code>e1 -&gt;* e2</code></li>
<li><code>e1 &lt;&lt; e2</code></li>
<li><code>e1 &gt;&gt; e2</code> e1保证在e2之前求值，它们的求值顺序是从左至右。</li>
</ul>
</li>
</ul>
<p>然而，相同函数的不同实参的求值顺序仍然是未定义的。即：</p>
<div class="code-wrapper"><pre><code class="hljs c++">e1.<span class="hljs-built_in">f</span>(a1,a2,a3)</code></pre></div>

<p>e1保证在a1 a2 a3之前求值。但是a1 a2 a3的求职顺序仍然是未定义的。</p>
<ul>
<li>所有赋值运算符<ul>
<li><code>e2 = e1</code></li>
<li><code>e2 += e1</code></li>
<li><code>e2 *= e1</code></li>
<li><code>...</code> 右手边的e1会先于左手变的e2被求值。</li>
</ul>
</li>
<li>最后，new表达式中<ul>
<li><code>new Type(e)</code> 分配行为保证在e之前求值，初始化新的值保证在任何使用初始化的值之前被求值。</li>
</ul>
</li>
</ul>
<p>上述所有保证对基本类型和用户定义类型都有效。</p>
<p>这样做的效果是，C++17后：</p>
<div class="code-wrapper"><pre><code class="hljs c++">std::string s = <span class="hljs-string">"I heard it even works if you don't believe"</span>;
s.<span class="hljs-built_in">replace</span>(<span class="hljs-number">0</span>,<span class="hljs-number">8</span>,<span class="hljs-string">""</span>).<span class="hljs-built_in">replace</span>(s.<span class="hljs-built_in">find</span>(<span class="hljs-string">"even"</span>),<span class="hljs-number">4</span>,<span class="hljs-string">"sometimes"</span>)
    .<span class="hljs-built_in">replace</span>(s.<span class="hljs-built_in">find</span>(<span class="hljs-string">"you don✬t"</span>),<span class="hljs-number">9</span>,<span class="hljs-string">"I"</span>);</code></pre></div>

<p>保证会改变s的值，变成：</p>
<div class="code-wrapper"><pre><code class="hljs bash">it always works <span class="hljs-keyword">if</span> you use C++17</code></pre></div>

<p>因此，每个<code>find()</code>之前的替换都会在<code>find()</code>之前被求值。</p>
<p>另一个结果是，下面的语句</p>
<div class="code-wrapper"><pre><code class="hljs c++">i = <span class="hljs-number">0</span>;
std::cout &lt;&lt; ++i &lt;&lt; <span class="hljs-string">' '</span> &lt;&lt; --i &lt;&lt; <span class="hljs-string">'\n'</span>;</code></pre></div>

<p>其输出保证是<code>1 0</code>。</p>
<p>然而，对于其他大多数运算符而言，求值顺序仍然未定义。举个例子：</p>
<div class="code-wrapper"><pre><code class="hljs c++">i = i++ + i; <span class="hljs-comment">// still undefined behavior</span></code></pre></div>

<p>这里右手变的i可能在递增之前或者递增之后传递给左手变。</p>
<p>另一个使用new表达式求值顺序的例子是<strong>在传值之前插入空格的函数</strong>。</p>
<h5><span id="xiang-hou-jian-rong">向后兼容</span><a href="#xiang-hou-jian-rong" class="header-anchor">#</a></h5><p>新的求值顺序的保证可能影响既有程序的输出。这不是理论上可能，是真的。考虑下面的代码：</p>
<div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span>

<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">print10elems</span><span class="hljs-params">(<span class="hljs-type">const</span> std::vector&lt;<span class="hljs-type">int</span>&gt;&amp; v)</span> </span>
<span class="hljs-function"></span>{
    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>; i&lt;<span class="hljs-number">10</span>; ++i) {
        std::cout &lt;&lt; <span class="hljs-string">"value: "</span> &lt;&lt; v.<span class="hljs-built_in">at</span>(i) &lt;&lt; <span class="hljs-string">'\n'</span>;
    }
}

<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>
<span class="hljs-function"></span>{
    <span class="hljs-keyword">try</span> {
        std::vector&lt;<span class="hljs-type">int</span>&gt; vec{<span class="hljs-number">7</span>, <span class="hljs-number">14</span>, <span class="hljs-number">21</span>, <span class="hljs-number">28</span>};
        <span class="hljs-built_in">print10elems</span>(vec);
    }
    <span class="hljs-built_in">catch</span> (<span class="hljs-type">const</span> std::exception&amp; e) { <span class="hljs-comment">// handle standard exception</span>
        std::cerr &lt;&lt; <span class="hljs-string">"EXCEPTION: "</span> &lt;&lt; e.<span class="hljs-built_in">what</span>() &lt;&lt; <span class="hljs-string">'\n'</span>; }
    <span class="hljs-built_in">catch</span> (...) { <span class="hljs-comment">// handle any other exception</span>
        std::cerr &lt;&lt; <span class="hljs-string">"EXCEPTION of unknown type\n"</span>; 
    } 
}</code></pre></div>

<p>因为这里的<code>vector&lt;&gt;</code>只有4个元素，程序会在<code>print10elems()</code>的循环中，调用<code>at()</code>时遇到无效索引抛出异常：</p>
<div class="code-wrapper"><pre><code class="hljs c++">std::cout &lt;&lt; <span class="hljs-string">"value: "</span> &lt;&lt; v.<span class="hljs-built_in">at</span>(i) &lt;&lt; <span class="hljs-string">"\n"</span>;</code></pre></div>

<p>在C++17之前，可能输出：</p>
<div class="code-wrapper"><pre><code class="hljs c++">value: <span class="hljs-number">7</span>
value: <span class="hljs-number">14</span>
value: <span class="hljs-number">21</span>
value: <span class="hljs-number">28</span>
EXCEPTION: ...</code></pre></div>

<p>因为<code>at()</code>可以在”value “输出之前求值，所以对于错误的索引可能直接跳过不输出”value “。</p>
<p>自C++17之后，保证输出：</p>
<div class="code-wrapper"><pre><code class="hljs c++">value: <span class="hljs-number">7</span>
value: <span class="hljs-number">14</span>
value: <span class="hljs-number">21</span>
value: <span class="hljs-number">28</span>
value: EXCEPTION: ...</code></pre></div>

<p>因为”value “一定在<code>at()</code>调用之前执行。</p>
<h4><span id="8-3-zheng-shu-zhi-de-kuan-song-mei-ju-chu-shi-hua">8.3 整数值的宽松枚举初始化</span><a href="#8-3-zheng-shu-zhi-de-kuan-song-mei-ju-chu-shi-hua" class="header-anchor">#</a></h4><p>对于有固定基本类型的枚举，C++17允许你使用带数值的列表初始化。</p>
<div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-comment">// 具有基础类型的无范围枚举:</span>
<span class="hljs-keyword">enum</span> <span class="hljs-title class_">MyInt</span> : <span class="hljs-type">char</span> { };
MyInt i1{<span class="hljs-number">42</span>};     <span class="hljs-comment">// C++17 OK (C++17之前错误)</span>
MyInt i2 = <span class="hljs-number">42</span>;    <span class="hljs-comment">// 仍然错误</span>
<span class="hljs-function">MyInt <span class="hljs-title">i3</span><span class="hljs-params">(<span class="hljs-number">42</span>)</span></span>;     <span class="hljs-comment">// 仍然错误</span>
MyInt i4 = {<span class="hljs-number">42</span>};  <span class="hljs-comment">// 仍然错误</span>

<span class="hljs-keyword">enum class</span> <span class="hljs-title class_">Weekday</span> { mon, tue, wed, thu, fri, sat, sun };
Weekday s1{<span class="hljs-number">0</span>};    <span class="hljs-comment">// C++17 OK (C++17之前错误)</span>
Weekday s2 = <span class="hljs-number">0</span>;   <span class="hljs-comment">// 仍然错误</span>
<span class="hljs-function">Weekday <span class="hljs-title">s3</span><span class="hljs-params">(<span class="hljs-number">0</span>)</span></span>;    <span class="hljs-comment">// 仍然错误</span>
Weekday s4 = {<span class="hljs-number">0</span>}; <span class="hljs-comment">// 仍然错误</span></code></pre></div>

<p>类似的，如果Weekday有基本类型：</p>
<div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-comment">// 具有指定基础类型的范围枚举:</span>
<span class="hljs-keyword">enum class</span> <span class="hljs-title class_">Weekday</span> : <span class="hljs-type">char</span> { mon, tue, wed, thu, fri, sat, sun };
Weekday s1{<span class="hljs-number">0</span>};    <span class="hljs-comment">// C++17 OK (C++17之前错误)</span>
Weekday s2 = <span class="hljs-number">0</span>;   <span class="hljs-comment">// 仍然错误</span>
<span class="hljs-function">Weekday <span class="hljs-title">s3</span><span class="hljs-params">(<span class="hljs-number">0</span>)</span></span>;    <span class="hljs-comment">// 仍然错误</span>
Weekday s4 = {<span class="hljs-number">0</span>}; <span class="hljs-comment">// 仍然错误</span></code></pre></div>

<p>对于没有指定基本类型的未限域枚举（不带class的enum），你仍然不能使用带数值的列表初始化：</p>
<div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">enum</span> <span class="hljs-title class_">Flag</span> { bit1=<span class="hljs-number">1</span>, bit2=<span class="hljs-number">2</span>, bit3=<span class="hljs-number">4</span> };
Flag f1{<span class="hljs-number">0</span>}; <span class="hljs-comment">// 仍然错误</span></code></pre></div>

<p>注意，列表初始化还是不允许变窄（narrowing），因此你不能传递浮点值：</p>
<div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">enum</span> <span class="hljs-title class_">MyInt</span> : <span class="hljs-type">char</span> { };
MyInt i5{<span class="hljs-number">42.2</span>}; <span class="hljs-comment">// 仍然错误</span></code></pre></div>

<p>之所以提出这个特性，是想实现一种技巧，即基于原有的整数类型定义另一种新的枚举类型，就像上面MyInt一样。</p>
<p>实际上，C++17的标准库中的<code>std::byte</code>也提供这个功能，它直接使用了这个特性。</p>
<h4><span id="8-4-xiu-fu-dai-auto-he-zhi-jie-lie-biao-chu-shi-hua-yi-qi-shi-yong-chan-sheng-de-mao-dun-xing-wei">8.4 修复带 auto 和直接列表初始化一起使用产生的矛盾行为</span><a href="#8-4-xiu-fu-dai-auto-he-zhi-jie-lie-biao-chu-shi-hua-yi-qi-shi-yong-chan-sheng-de-mao-dun-xing-wei" class="header-anchor">#</a></h4><p>C++11引入了统一初始化后，结果证明它和auto搭配会不幸地产生反直觉的矛盾行为：</p>
<div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-type">int</span> x{<span class="hljs-number">42</span>};      <span class="hljs-comment">// 初始化一个 int</span>
<span class="hljs-type">int</span> y{<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>};   <span class="hljs-comment">// ERROR</span>
<span class="hljs-keyword">auto</span> a{<span class="hljs-number">42</span>};     <span class="hljs-comment">// 初始化一个 std::initializer_list&lt;int&gt;</span>
<span class="hljs-keyword">auto</span> b{<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>};  <span class="hljs-comment">// OK：初始化一个 std::initializer_list&lt;int&gt;</span></code></pre></div>

<p>这些使用直接列表初始化（direct list initialization，不带<code>=</code>的花括号）造成的前后不一致行为已经得到修复，现在程序行为如下：</p>
<div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-type">int</span> x{<span class="hljs-number">42</span>};      <span class="hljs-comment">// 初始化一个 int</span>
<span class="hljs-type">int</span> y{<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>};   <span class="hljs-comment">// ERROR</span>
<span class="hljs-keyword">auto</span> a{<span class="hljs-number">42</span>};     <span class="hljs-comment">// 现在初始化一个 int</span>
<span class="hljs-keyword">auto</span> b{<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>};  <span class="hljs-comment">// ERROR now</span></code></pre></div>

<p>注意这是一个非常大的改变，甚至可能悄悄的改变程序的行为。出于这个原因，编译器接受这个改变，但是通常也提供C++11版本的模式。对于主流编译器，比如Visual Studio 2015，g++5和clang3.8同时接受两种模式。</p>
<p>还请注意拷贝列表初始化（copy list initialization，带<code>=</code>的花括号）的行为是不变的，当使用auto时初始化一个<code>std::initializer_list&lt;&gt;</code>：</p>
<div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">auto</span> c = {<span class="hljs-number">42</span>}; <span class="hljs-comment">// 仍然初始化一个 std::initializer_list&lt;int&gt;</span>
<span class="hljs-keyword">auto</span> d = {<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>}; <span class="hljs-comment">// 仍然可以：初始化一个 std::initializer_list&lt;int&gt;</span></code></pre></div>

<p>因此，现在的直接列表初始化（不带<code>=</code>）和拷贝列表初始化（带<code>=</code>）有另一个显著区别：</p>
<div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">auto</span> a{<span class="hljs-number">42</span>}; <span class="hljs-comment">// 现在初始化一个 int</span>
<span class="hljs-keyword">auto</span> c = {<span class="hljs-number">42</span>}; <span class="hljs-comment">// 仍然初始化一个 std::initializer_list&lt;int&gt;</span></code></pre></div>

<p>推荐的方式是总是使用直接列表初始化（不带<code>=</code>的花括号）来初始化变量和对象。</p>
<h4><span id="8-5-shi-liu-jin-zhi-fu-dian-zi-mian-zhi">8.5 十六进制浮点字面值</span><a href="#8-5-shi-liu-jin-zhi-fu-dian-zi-mian-zhi" class="header-anchor">#</a></h4><p>C++17标准化了十六进制的浮点值字面值（有些编译器早已在C++17之前就支持了）。这种方式尤其适用于要求精确的浮点表示（对于双精度浮点值，没法保证精确值的存在）。</p>
<p>举个例子：</p>
<div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-comment">// lang/hexfloat.cpp</span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iomanip&gt;</span></span>

<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>{
    <span class="hljs-comment">// 浮点值的初始化列表:</span>
    std::initializer_list&lt;<span class="hljs-type">double</span>&gt; values{
        <span class="hljs-number">0x1</span>p4, <span class="hljs-comment">// 16</span>
        <span class="hljs-number">0xA</span>, <span class="hljs-comment">// 10</span>
        <span class="hljs-number">0xA</span>p2, <span class="hljs-comment">// 40</span>
        <span class="hljs-number">5e0</span>, <span class="hljs-comment">// 5</span>
        <span class="hljs-number">0x1</span><span class="hljs-number">.4</span>p+<span class="hljs-number">2</span>, <span class="hljs-comment">// 5</span>
        <span class="hljs-number">1e5</span>, <span class="hljs-comment">// 100000</span>
        <span class="hljs-number">0x1</span><span class="hljs-number">.86</span>Ap+<span class="hljs-number">16</span>, <span class="hljs-comment">// 100000</span>
        <span class="hljs-number">0xC</span><span class="hljs-number">.68</span>p+<span class="hljs-number">2</span>, <span class="hljs-comment">// 49.625</span>
    };

    <span class="hljs-comment">// 将所有值打印为十进制和十六进制值:</span>
    <span class="hljs-keyword">for</span> (<span class="hljs-type">double</span> d : values) {
        std::cout &lt;&lt; <span class="hljs-string">"dec: "</span> &lt;&lt; std::<span class="hljs-built_in">setw</span>(<span class="hljs-number">6</span>) &lt;&lt; std::defaultfloat &lt;&lt; d
            &lt;&lt; <span class="hljs-string">" hex: "</span> &lt;&lt; std::hexfloat &lt;&lt; d &lt;&lt; <span class="hljs-string">'\n'</span>;
    }
}</code></pre></div>

<p>这个程序使用不同的方式定义了不同的浮点值，其中包括使用十六进制浮点记法。新的记法是base为2的科学表示法：</p>
<ul>
<li>significant/mantissa写作十六进制方式</li>
<li>exponent写作数值方式，解释为base为2</li>
</ul>
<p>比如说，<code>0xAp2</code>是指定数值40（10乘以2的次方）。这个值也可以表示为<code>0x1.4p+5</code>，表示1.25乘以32（0.4是十六进制的四分之一，2的5次方是32）。</p>
<p>程序输出如下：</p>
<div class="code-wrapper"><pre><code class="hljs bash">dec: 16     hex: 0x1p+4
dec: 10     hex: 0x1.4p+3
dec: 40     hex: 0x1.4p+5
dec: 5      hex: 0x1.4p+2
dec: 5      hex: 0x1.4p+2
dec: 100000 hex: 0x1.86ap+16
dec: 100000 hex: 0x1.86ap+16
dec: 49.625 hex: 0x1.8dp+5</code></pre></div>

<p>如你说见，这个例子的浮点记法早已在C++11的<code>std::hexfloat</code>操作符上就已经支持了。</p>
<h4><span id="8-6-utf-8-zi-fu-chuan-zi-mian-zhi">8.6 UTF-8字符串字面值</span><a href="#8-6-utf-8-zi-fu-chuan-zi-mian-zhi" class="header-anchor">#</a></h4><p>C++11支持以u8前缀表示的UTF-8字符串字面值。然而，这个前缀对于字符是不支持的。C++17修复了这个问题，你现在可以这样写：</p>
<div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-type">char</span> c = <span class="hljs-string">u8'6'</span>; <span class="hljs-comment">// character 6 with UTF-8 encoding value</span></code></pre></div>

<p>样可以保证字符值是UTF-8中字符‘6’的值。你可以使用所有的7bits US-ASCII字符，对于这些字符，UTF-8代码具有相同的值。换句话说，用这个指定的值和US-ASCII、ISO Latin-1、ISO-8859-15和基本Windows字符集的值都是一样的。通常，你的源代码的字符都会被解释为US-ASCII/UTF-8，所以前缀不是很重要。变量c的值几乎总是54（十六进制的36）。</p>
<p>对于源码中的字符和字符串字面值，C++标准化了你可以使用哪些字符，但是没有标准化这些字符对应的值。这些值取决于源代码字符集。当编译器生成可执行程序时，它会使用运行时字符集。源代码字符集集合总是7bits的US-ASCII，并且运行时字符集通常和源代码字符集一样。对于任何C++程序，有没有u8前缀这些字符和字符串字面值都是一样的。但是在很少见的情况下，可能不是这样。比如老式的IBM主机，仍然使用EBCDIC字符集，在这个字符集中字符‘6’的值是246（十六进制F6）。如果程序使用EBCDIC字符集，那么c的值将会是246而不是54，并且在UTF-8编码的平台上运行该程序时可能输出”¨o”，因为它对应ASCII值的246.在这种情况下前缀可能是必要的。</p>
<p>注意u8只能用于单个字符和UTF-8单字节字符。下面的初始化： <img src="https://gitee.com/txt1994/Cpp17TheCompleteGuideChinese/raw/master/public/fig8-1.jpg" srcset="/img/loading.gif" lazyload alt="img"> 是不被允许的，因为这个德语字符在UTF-8是双字节，即195和182（十六进制C3 B6）。</p>
<p>总结来熟哦，所有允许的字符和字符串字面值如下：</p>
<ul>
<li>单字节US-ASCII和UTF-8可以使用<strong>u8</strong></li>
<li>双字节的UTF-16可以使用<strong>u</strong></li>
<li>四字节的UTF-32可以使用<strong>U</strong></li>
<li>没有指定编码的宽字符可以使用<strong>l</strong>，它可能是两字节也可能是四字节</li>
</ul>
<h4><span id="8-7-yi-chang-gui-fan-zuo-wei-lei-xing-de-yi-bu-fen">8.7 异常规范作为类型的一部分</span><a href="#8-7-yi-chang-gui-fan-zuo-wei-lei-xing-de-yi-bu-fen" class="header-anchor">#</a></h4><p>C++17开始异常处理声明成为一个函数的类型的一部分。也就是说，下面的两个函数现在有不同的类型：</p>
<div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">f1</span><span class="hljs-params">()</span></span>;
<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">f2</span><span class="hljs-params">()</span> <span class="hljs-keyword">noexcept</span></span>; <span class="hljs-comment">// 不同类型</span></code></pre></div>

<p>在C++17之前，这两个函数的类型是相同的。</p>
<p>这样的后果是，现在的编译器会检查是否你将不抛异常的函数传递给抛异常的函数指针：</p>
<div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-built_in">void</span> (*fp)() <span class="hljs-keyword">noexcept</span>;  <span class="hljs-comment">// 指向函数的指针，不抛出</span>
fp = f2;                <span class="hljs-comment">// OK</span>
fp = f1;                <span class="hljs-comment">// ERROR since C++17</span></code></pre></div>

<p>给抛异常的函数指针传递不抛异常的函数仍然有效：</p>
<div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-built_in">void</span> (*fp2)();  <span class="hljs-comment">// 指向函数的指针，可能会抛出</span>
fp2 = f2;       <span class="hljs-comment">// OK</span>
fp2 = f1;       <span class="hljs-comment">// OK</span></code></pre></div>

<p>所以，这个新的特性不会破坏哪些没有使用noexcept作为函数指针的一部分的那些程序。</p>
<p>异常声明有无不能作为重载函数的依据：</p>
<div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">f3</span><span class="hljs-params">()</span></span>;
<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">f3</span><span class="hljs-params">()</span> <span class="hljs-keyword">noexcept</span></span>; <span class="hljs-comment">// ERROR</span></code></pre></div>

<p>注意，其他规则是不受影响的。举个例子，下面的代码中你还是不能忽略基类noexcept声明：</p>
<div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Base</span> {
<span class="hljs-keyword">public</span>:
    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">foo</span><span class="hljs-params">()</span> <span class="hljs-keyword">noexcept</span></span>;
    ...
};

<span class="hljs-keyword">class</span> <span class="hljs-title class_">Derived</span> : <span class="hljs-keyword">public</span> Base {
<span class="hljs-keyword">public</span>:
    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">foo</span><span class="hljs-params">()</span> <span class="hljs-keyword">override</span></span>; <span class="hljs-comment">// 错误：不覆盖</span>
    ...
};</code></pre></div>

<p>子类的<code>foo()</code>的类型与基类的<code>foo()</code>类型不一致，所以不允许重载，这个代码不能通过编译。即便没有指定override修饰符，还是不能编译，因为我们不能用更宽松的抛异常的版本来重载不抛异常的严格版本。</p>
<h5><span id="shi-yong-tiao-jian-yi-chang-sheng-ming">使用条件异常声明</span><a href="#shi-yong-tiao-jian-yi-chang-sheng-ming" class="header-anchor">#</a></h5><p>当使用条件异常声明时，函数的类型取决于条件为true还是false：</p>
<div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">f1</span><span class="hljs-params">()</span></span>;
<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">f2</span><span class="hljs-params">()</span> <span class="hljs-keyword">noexcept</span></span>;
<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">f3</span><span class="hljs-params">()</span> <span class="hljs-title">noexcept</span><span class="hljs-params">(<span class="hljs-keyword">sizeof</span>(<span class="hljs-type">int</span>)&lt;<span class="hljs-number">4</span>)</span></span>; <span class="hljs-comment">// 与 f1() 或 f2() 相同的类型</span>
<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">f4</span><span class="hljs-params">()</span> <span class="hljs-title">noexcept</span><span class="hljs-params">(<span class="hljs-keyword">sizeof</span>(<span class="hljs-type">int</span>)&gt;=<span class="hljs-number">4</span>)</span></span>; <span class="hljs-comment">// 不同于 f3() 的类型</span></code></pre></div>

<p>在这里，当代码编译时<code>f3()</code>的类型取决于条件：</p>
<ul>
<li>如果<code>sizeof(int)</code>为4（或者更多），最终的签名是</li>
</ul>
<div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">f3</span><span class="hljs-params">()</span> <span class="hljs-title">noexcept</span><span class="hljs-params">(<span class="hljs-literal">false</span>)</span></span>;    <span class="hljs-comment">// 与 f1() 相同的类型</span></code></pre></div>

<ul>
<li>如果<code>sizeof(int)</code>小于4，最终签名是：</li>
</ul>
<div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">f3</span><span class="hljs-params">()</span> <span class="hljs-title">noexcept</span><span class="hljs-params">(<span class="hljs-literal">true</span>)</span></span>;     <span class="hljs-comment">// 与 f2() 相同的类型</span></code></pre></div>

<p>因为<code>f4()</code>的异常条件与<code>f3()</code>相反，所以<code>f4()</code>的类型总是与<code>f3()</code>不一样（即保证<code>f3()</code>抛异常它就不抛，<code>f3()</code>不抛它就抛）。</p>
<p>老式的空异常声明仍然可以使用，但是C++17已经标为废弃：</p>
<div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">f5</span><span class="hljs-params">()</span> <span class="hljs-title">throw</span><span class="hljs-params">()</span></span>; <span class="hljs-comment">// 与 void f5() noexcept 相同，但已弃用</span></code></pre></div>

<p>动态的异常声明已经不再支持（它们在C++11时已经标为废弃）：</p>
<div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">f6</span><span class="hljs-params">()</span> <span class="hljs-title">throw</span><span class="hljs-params">(std::bad_alloc)</span></span>; <span class="hljs-comment">// 错误：自 C++17 起无效</span></code></pre></div>

<h5><span id="dui-fan-xing-ku-de-ying-xiang">对泛型库的影响</span><a href="#dui-fan-xing-ku-de-ying-xiang" class="header-anchor">#</a></h5><p>让noexcept成为类型的一部分可能对一些泛型库造成影响。</p>
<p>比如，下面的程序截止C++14是有效的，但是在C++17中无法编译：</p>
<div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-comment">// lang/noexceptcalls.cpp</span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span>

<span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;</span>
<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">call</span><span class="hljs-params">(T op1, T op2)</span></span>
<span class="hljs-function"></span>{
    <span class="hljs-built_in">op1</span>();
    <span class="hljs-built_in">op2</span>();
}

<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">f1</span><span class="hljs-params">()</span> </span>{
    std::cout &lt;&lt; <span class="hljs-string">"f1()\n"</span>; 
}

<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">f2</span><span class="hljs-params">()</span> <span class="hljs-keyword">noexcept</span> </span>{
    std::cout &lt;&lt; <span class="hljs-string">"f2()\n"</span>; 
}

<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>
<span class="hljs-function"></span>{
    <span class="hljs-built_in">call</span>(f1, f2); <span class="hljs-comment">// ERROR since C++17</span>
}</code></pre></div>

<p>原因是C++17中<code>f1()</code>和<code>f2()</code>的类型不一样，编译器在实例化模板调用<code>call()</code>的时候不能为两个类型找到相同的类型T。</p>
<p>在C++17下，你不得不用两个类型：</p>
<div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T1, <span class="hljs-keyword">typename</span> T2&gt;</span>
<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">call</span><span class="hljs-params">(T1 op1, T2 op2)</span></span>
<span class="hljs-function"></span>{
    <span class="hljs-built_in">op1</span>();
    <span class="hljs-built_in">op2</span>();
}</code></pre></div>

<p>如果你想，或者不得不重载所有可能的函数类型，你需要付出双倍。来看<code>std::is_function&lt;&gt;</code>，主要的函数模板定义如下，通常T不是函数：</p>
<div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-comment">// 主模板（一般类型 T 没有功能）:</span>
<span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt; <span class="hljs-keyword">struct</span> <span class="hljs-title class_">is_function</span> : std::false_type { };</code></pre></div>

<p>这个模板继承自<code>std::false_type</code>，所以<code>is_function::value</code>通常产生false。</p>
<p>对于那些的确是函数的类型，需要偏特化，它继承自<code>std::true_type</code>，所以成员value的值是true：</p>
<div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-comment">// 所有函数类型的部分特化:</span>
<span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> Ret, <span class="hljs-keyword">typename</span>... Params&gt;
<span class="hljs-keyword">struct</span> <span class="hljs-title class_">is_function</span>&lt;<span class="hljs-built_in">Ret</span> (Params...)&gt; : std::true_type { };
<span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> Ret, <span class="hljs-keyword">typename</span>... Params&gt;
<span class="hljs-keyword">struct</span> <span class="hljs-title class_">is_function</span>&lt;<span class="hljs-built_in">Ret</span> (Params...) <span class="hljs-type">const</span>&gt; : std::true_type { };
<span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> Ret, <span class="hljs-keyword">typename</span>... Params&gt;
<span class="hljs-keyword">struct</span> <span class="hljs-title class_">is_function</span>&lt;<span class="hljs-built_in">Ret</span> (Params...) &amp;&gt; : std::true_type { };
<span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> Ret, <span class="hljs-keyword">typename</span>... Params&gt;
<span class="hljs-keyword">struct</span> <span class="hljs-title class_">is_function</span>&lt;<span class="hljs-built_in">Ret</span> (Params...) <span class="hljs-type">const</span> &amp;&gt; : std::true_type { };</code></pre></div>

<p>C++17之前，它已经有24个偏特化来，因为函数可能有const和volatile修饰符，也可能有lvalue和rvalue引用修饰符，你重载的函数需要可变参数模板类型。</p>
<p>C++17后，偏特化的数量将会翻倍，因为有了新的noexcept修饰符，所以现在有48个：</p>
<div class="code-wrapper"><pre><code class="hljs c++">...
<span class="hljs-comment">// 带有 noexcept 的所有函数类型的部分特化:</span>
<span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> Ret, <span class="hljs-keyword">typename</span>... Params&gt;
<span class="hljs-keyword">struct</span> <span class="hljs-title class_">is_function</span>&lt;<span class="hljs-built_in">Ret</span> (Params...) <span class="hljs-keyword">noexcept</span>&gt; : std::true_type { };
<span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> Ret, <span class="hljs-keyword">typename</span>... Params&gt;
<span class="hljs-keyword">struct</span> <span class="hljs-title class_">is_function</span>&lt;<span class="hljs-built_in">Ret</span> (Params...) <span class="hljs-type">const</span> <span class="hljs-keyword">noexcept</span>&gt; : std::true_type { };
<span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> Ret, <span class="hljs-keyword">typename</span>... Params&gt;
<span class="hljs-keyword">struct</span> <span class="hljs-title class_">is_function</span>&lt;<span class="hljs-built_in">Ret</span> (Params...) &amp; <span class="hljs-keyword">noexcept</span>&gt; : std::true_type { };
<span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> Ret, <span class="hljs-keyword">typename</span>... Params&gt;
<span class="hljs-keyword">struct</span> <span class="hljs-title class_">is_function</span>&lt;<span class="hljs-built_in">Ret</span> (Params...) <span class="hljs-type">const</span>&amp; <span class="hljs-keyword">noexcept</span>&gt; : std::true_type { };</code></pre></div>

<p>没有实现noexcept重载的库可能编译不了一些代码，因为它们可能用了noexcept。</p>
<h4><span id="8-8-dan-can-shu-static-assert">8.8 单参数 static_assert</span><a href="#8-8-dan-can-shu-static-assert" class="header-anchor">#</a></h4><p>C++17开始，之前<code>static_assert()</code>必须传的错误消息参数现在变成可选了。这意味着最后的诊断性消息完全平台特定。比如：</p>
<div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;type_traits&gt;</span></span>

<span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;
<span class="hljs-keyword">class</span> <span class="hljs-title class_">C</span> {
    <span class="hljs-comment">// OK since C++11:</span>
    <span class="hljs-built_in">static_assert</span>(std::is_default_constructible&lt;T&gt;::value,
                  <span class="hljs-string">"class C: elements must be default-constructible"</span>);
    <span class="hljs-comment">// OK since C++17:</span>
    <span class="hljs-built_in">static_assert</span>(std::is_default_constructible_v&lt;T&gt;);
    ...
};</code></pre></div>

<p>没有传消息的断言使用了新的type trait后缀<code>_v</code>。</p>
<h4><span id="8-9-yu-chu-li-tiao-jian-has-include">8.9 预处理条件__has_include</span><a href="#8-9-yu-chu-li-tiao-jian-has-include" class="header-anchor">#</a></h4><p>C++17扩展了预处理起，可以检查一个特定的头文件是否被include。比如：</p>
<div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">if</span> __has_include(<span class="hljs-string">&lt;filesystem&gt;</span>)</span>
<span class="hljs-meta"># <span class="hljs-keyword">include</span> <span class="hljs-string">&lt;filesystem&gt;</span></span>
<span class="hljs-meta"># <span class="hljs-keyword">define</span> HAS_FILESYSTEM 1</span>
<span class="hljs-meta">#<span class="hljs-keyword">elif</span> __has_include(<span class="hljs-string">&lt;experimental/filesystem&gt;</span>)</span>
<span class="hljs-meta"># <span class="hljs-keyword">include</span> <span class="hljs-string">&lt;experimental/filesystem&gt;</span></span>
<span class="hljs-meta"># <span class="hljs-keyword">define</span> HAS_FILESYSTEM 1</span>
<span class="hljs-meta"># <span class="hljs-keyword">define</span> FILESYSTEM_IS_EXPERIMENTAL 1</span>
<span class="hljs-meta">#<span class="hljs-keyword">elif</span> __has_include(<span class="hljs-string">"filesystem.hpp"</span>) </span>
<span class="hljs-meta"># <span class="hljs-keyword">include</span> <span class="hljs-string">"filesystem.hpp"</span> </span>
<span class="hljs-meta"># <span class="hljs-keyword">define</span> HAS_FILESYSTEM 1</span>
<span class="hljs-meta"># <span class="hljs-keyword">define</span> FILESYSTEM_IS_EXPERIMENTAL 1</span>
<span class="hljs-meta">#<span class="hljs-keyword">else</span></span>
<span class="hljs-meta"># <span class="hljs-keyword">define</span> HAS_FILESYSTEM </span>
<span class="hljs-meta">#<span class="hljs-keyword">if</span> __has_include(<span class="hljs-string">&lt;filesystem&gt;</span>)</span>
<span class="hljs-meta"># <span class="hljs-keyword">include</span> <span class="hljs-string">&lt;filesystem&gt;</span></span>
<span class="hljs-meta"># <span class="hljs-keyword">define</span> HAS_FILESYSTEM 1</span>
<span class="hljs-meta">#<span class="hljs-keyword">elif</span> __has_include(<span class="hljs-string">&lt;experimental/filesystem&gt;</span>)</span>
<span class="hljs-meta"># <span class="hljs-keyword">include</span> <span class="hljs-string">&lt;experimental/filesystem&gt;</span></span>
<span class="hljs-meta"># <span class="hljs-keyword">define</span> HAS_FILESYSTEM 1</span>
<span class="hljs-meta"># <span class="hljs-keyword">define</span> FILESYSTEM_IS_EXPERIMENTAL 1</span>
<span class="hljs-meta">#<span class="hljs-keyword">elif</span> __has_include(<span class="hljs-string">"filesystem.hpp"</span>) </span>
<span class="hljs-meta"># <span class="hljs-keyword">include</span> <span class="hljs-string">"filesystem.hpp"</span> </span>
<span class="hljs-meta"># <span class="hljs-keyword">define</span> HAS_FILESYSTEM 1</span>
<span class="hljs-meta"># <span class="hljs-keyword">define</span> FILESYSTEM_IS_EXPERIMENTAL 1</span>
<span class="hljs-meta">#<span class="hljs-keyword">else</span></span>
<span class="hljs-meta"># <span class="hljs-keyword">define</span> HAS_FILESYSTEM 0</span>
#endif0
<span class="hljs-meta">#<span class="hljs-keyword">endif</span></span></code></pre></div>

<p>如果<code>#include</code>成功则<code>__has_include(...)</code>会求值为1(true)。如果不成功则没有什么影响。</p>
<h4><span id="8-10-hou-ji">8.10 后记</span><a href="#8-10-hou-ji" class="header-anchor">#</a></h4><p>嵌套namespace定义最初由Jon Jagger在2003年于<a href="https://gitee.com/link?target=https://wg21.link/n1524">https://wg21.link/n1524</a>提出。Robert Kawulak在2014年于<a href="https://gitee.com/link?target=https://wg21.link/n4026">https://wg21.link/n4026</a>提出了新的提案。最后这个特性的公认措辞是由Robert Kawulak 和 Andrew Tomazos在<a href="https://gitee.com/link?target=https://wg21.link/n4230">https://wg21.link/n4230</a>中给出。</p>
<p>重新定义后的求值顺序最初由Gabriel Dos Reis, Herb Sutter和Jonathan Caves在<a href="https://gitee.com/link?target=https://wg21.link/n4228">https://wg21.link/n4228</a>中提出。最后这个特性的公认措辞是由Gabriel Dos Reis, Herb Sutter和Jonathan Caves在<a href="https://gitee.com/link?target=https://wg21.link/p0145r3">https://wg21.link/p0145r3</a>中给出。</p>
<p>更宽松的枚举初始化最初由Gabriel Dos Reis在<a href="https://gitee.com/link?target=https://wg21.link/p0138r0">https://wg21.link/p0138r0</a>中提出。最后这个特性的公认措辞是由Gabriel Dos Reis在<a href="https://gitee.com/link?target=https://wg21.link/p0138r2">https://wg21.link/p0138r2</a>中给出。</p>
<p>修复带auto和直接列表初始化一起使用产生的矛盾行为最初由Ville Voutilainen在<a href="https://gitee.com/link?target=https://wg21.link/n3681"> https://wg21.link/n3681</a>和<a href="https://gitee.com/link?target=https://wg21.link/3912">https://wg21.link/3912</a>中提出。最后这个特性的公认措辞是由 James Dennett在<a href="https://gitee.com/link?target=https://wg21.link/n3681">https://wg21.link/n3681</a>中给出。</p>
<p>十六进制浮点值最初由Thomas Koppe在<a href="https://gitee.com/link?target=https://wg21.link/p0245r0">https://wg21.link/p0245r0</a>中提出。最后这个特性的公认措辞是由Thomas Koppe在<a href="https://gitee.com/link?target=https://wg21.link/p0245r1">https://wg21.link/p0245r1</a>中给出。</p>
<p>UTF-8字符串字面值最初由 Richard Smith在<a href="https://gitee.com/link?target=https://wg21.link/n4197">https://wg21.link/n4197</a>中提出。最后这个特性的公认措辞是由 Richard Smith在<a href="https://gitee.com/link?target=https://wg21.link/n4267">https://wg21.link/n4267</a>中给出。</p>
<p>异常声明成为类型的一部分最初由Jens Maurer在<a href="https://gitee.com/link?target=https://wg21.link/n4320">https://wg21.link/n4320</a>中提出。最后这个特性的公认措辞是由Jens Maurer在<a href="https://gitee.com/link?target=https://wg21.link/p0012r1">https://wg21.link/p0012r1</a>中给出。</p>
<p>单参数的static_assert的公认措辞是由Walter E. Brown在<a href="https://gitee.com/link?target=https://wg21.link/n3928">https://wg21.link/n3928</a>中给出。</p>
<p>预处理条件<code>__has_include</code>最初由Clark Nelson和RichardSmith在<a href="https://gitee.com/link?target=https://wg21.link/p0061r0">https://wg21.link/p0061r0</a>中作为其中一部分提出。最后这个特性的公认措辞是由Clark Nelson和RichardSmith在<a href="https://gitee.com/link?target=https://wg21.link/p0061r1">https://wg21.link/p0061r1</a>中给出。</p>

            </div>
            <hr>
            <div>
              <div class="post-metas mb-3">
                
                
                  <div class="post-meta">
                    <i class="iconfont icon-tags"></i>
                    
                      <a class="hover-with-bg" href="/tags/C-17/">C++17</a>
                    
                  </div>
                
              </div>
              
                <p class="note note-warning">
                  
                    本博客所有文章除特别声明外，均采用 <a target="_blank" href="https://creativecommons.org/licenses/by-sa/4.0/deed.zh" rel="nofollow noopener noopener">CC BY-SA 4.0 协议</a> ，转载请注明出处！
                  
                </p>
              
              
                <div class="post-prevnext">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/2022/03/20/QtDocumentCN/Logo/README/">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">Logo 设计</span>
                        <span class="visible-mobile">上一篇</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2022/03/19/%E7%AC%AC%E4%B8%89%E9%83%A8%E5%88%86%20%E6%96%B0%E7%9A%84%E6%A0%87%E5%87%86%E5%BA%93%E7%BB%84%E4%BB%B6/">
                        <span class="hidden-mobile">第三部分-新的标准库组件</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
              <!-- Comments -->
              <article class="comments" id="comments" lazyload>
                
                  
                
                
  <div id="lv-container" data-id="city" data-uid="MTAyMC81NTMzMi8zMTc5OQ==">
    <script type="text/javascript">
      Fluid.utils.loadComments('#lv-container', function() {
        Fluid.utils.createScript('https://cdn-city.livere.com/js/embed.dist.js');
      });
    </script>
    <noscript>Please enable JavaScript to view the comments</noscript>
  </div>


              </article>
            
          </article>
        </div>
      </div>
    </div>
    
      <div class="d-none d-lg-block col-lg-2 toc-container" id="toc-ctn">
        <div id="toc">
  <p class="toc-header"><i class="iconfont icon-list"></i>&nbsp;目录</p>
  <div class="toc-body" id="toc-body"></div>
</div>

      </div>
    
  </div>
</div>

<!-- Custom -->


    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v"
                 for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>
    

    
  </main>

  <footer class="text-center mt-5 py-3">
  <div class="footer-content">
     <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> 
  </div>
  

  

  
</footer>


  <!-- SCRIPTS -->
  
  <script  src="https://cdn.jsdelivr.net/npm/nprogress@0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/nprogress@0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js" ></script>
<script  src="https://cdn.jsdelivr.net/npm/bootstrap@4/dist/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>

<!-- Plugins -->


  <script  src="/js/local-search.js" ></script>



  
    <script  src="/js/img-lazyload.js" ></script>
  



  



  
    <script  src="https://cdn.jsdelivr.net/npm/tocbot@4/dist/tocbot.min.js" ></script>
  
  
    <script  src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3/dist/jquery.fancybox.min.js" ></script>
  
  
    <script  src="https://cdn.jsdelivr.net/npm/anchor-js@4/anchor.min.js" ></script>
  
  
    <script defer src="https://cdn.jsdelivr.net/npm/clipboard@2/dist/clipboard.min.js" ></script>
  






  <script  src="https://cdn.jsdelivr.net/npm/typed.js@2/lib/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var title = document.getElementById('subtitle').title;
      
        typing(title);
      
    })(window, document);
  </script>















<!-- 主题的启动项 保持在最底部 -->
<script  src="/js/boot.js" ></script>


</body>
</html>
