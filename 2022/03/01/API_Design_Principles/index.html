

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=auto>



<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/logo.jpg">
  <link rel="icon" href="/img/logo.jpg">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
    <meta http-equiv="Content-Security-Policy" content="upgrade-insecure-requests">
  
  <meta name="theme-color" content="#6aa84f">
  <meta name="author" content="John Doe">
  <meta name="keywords" content="">
  
    <meta name="description" content="API 设计规范 优秀接口的六大特点 静态多态 好的 坏的 存疑   基于属性的 API QProperty C++ 特性 值 与 对象 指针 与 引用 传递常引用 与 传递值 虚函数 不变性   API Semantics and Documentation The Art of Naming General Naming Rules Naming Classes Naming Enu">
<meta property="og:type" content="article">
<meta property="og:title" content="API_Design_Principles">
<meta property="og:url" content="https://txt1994.github.io/2022/03/01/API_Design_Principles/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:description" content="API 设计规范 优秀接口的六大特点 静态多态 好的 坏的 存疑   基于属性的 API QProperty C++ 特性 值 与 对象 指针 与 引用 传递常引用 与 传递值 虚函数 不变性   API Semantics and Documentation The Art of Naming General Naming Rules Naming Classes Naming Enu">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2022-03-01T14:54:34.000Z">
<meta property="article:modified_time" content="2022-03-18T16:14:20.399Z">
<meta property="article:author" content="John Doe">
<meta property="article:tag" content="API设计规范">
<meta name="twitter:card" content="summary_large_image">
  
  
  <title>API_Design_Principles - Hexo</title>

  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4/dist/css/bootstrap.min.css" />


  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/github-markdown-css@4/github-markdown.min.css" />
  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/hint.css@2/hint.min.css" />

  
    
    
      
      <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@10/styles/github-gist.min.css" />
    
  

  
    <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3/dist/jquery.fancybox.min.css" />
  


<!-- 主题依赖的图标库，不要自行修改 -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_ba1fz6golrf.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_lbnruvf0jn.css">


<link  rel="stylesheet" href="/css/main.css" />

<!-- 自定义样式保持在最底部 -->

  
<link rel="stylesheet" href="/css/style.css">



  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    var CONFIG = {"hostname":"txt1994.github.io","root":"/","version":"1.8.14","typing":{"enable":true,"typeSpeed":70,"cursorChar":"_","loop":false},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"right","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"copy_btn":true,"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":false,"baidu":null,"google":null,"gtag":null,"tencent":{"sid":null,"cid":null},"woyaola":null,"cnzz":null,"leancloud":{"app_id":null,"app_key":null,"server_url":null,"path":"window.location.pathname","ignore_local":false}},"search_path":"/local-search.xml"};
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
<meta name="generator" content="Hexo 6.1.0">
<style>.github-emoji { position: relative; display: inline-block; width: 1.2em; min-height: 1.2em; overflow: hidden; vertical-align: top; color: transparent; }  .github-emoji > span { position: relative; z-index: 10; }  .github-emoji img, .github-emoji .fancybox { margin: 0 !important; padding: 0 !important; border: none !important; outline: none !important; text-decoration: none !important; user-select: none !important; cursor: auto !important; }  .github-emoji img { height: 1.2em !important; width: 1.2em !important; position: absolute !important; left: 50% !important; top: 50% !important; transform: translate(-50%, -50%) !important; user-select: none !important; cursor: auto !important; } .github-emoji-fallback { color: inherit; } .github-emoji-fallback img { opacity: 0 !important; }</style>
</head>


<body>
  <header style="height: 70vh;">
    <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/">
      <strong>txt1994s</strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/">
                <i class="iconfont icon-home-fill"></i>
                首页
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/">
                <i class="iconfont icon-archive-fill"></i>
                归档
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/">
                <i class="iconfont icon-tags-fill"></i>
                标签
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/">
                <i class="iconfont icon-user-fill"></i>
                关于
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/links/">
                <i class="iconfont icon-link-fill"></i>
                友联
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              &nbsp;<i class="iconfont icon-search"></i>&nbsp;
            </a>
          </li>
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">&nbsp;<i
                class="iconfont icon-dark" id="color-toggle-icon"></i>&nbsp;</a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

    <div class="banner" id="banner" parallax=true
         style="background: url('/img/default.png') no-repeat center center;
           background-size: cover;">
      <div class="full-bg-img">
        <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
          <div class="page-header text-center fade-in-up">
            <span class="h2" id="subtitle" title="API_Design_Principles">
              
            </span>

            
              <div class="mt-3">
  
  
    <span class="post-meta">
      <i class="iconfont icon-date-fill" aria-hidden="true"></i>
      <time datetime="2022-03-01 22:54" pubdate>
        2022年3月1日 晚上
      </time>
    </span>
  
</div>

<div class="mt-1">
  
    <span class="post-meta mr-2">
      <i class="iconfont icon-chart"></i>
      24k 字
    </span>
  

  
    <span class="post-meta mr-2">
      <i class="iconfont icon-clock-fill"></i>
      
      
      199 分钟
    </span>
  

  
  
</div>

            
          </div>

          
        </div>
      </div>
    </div>
  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="d-none d-lg-block col-lg-2"></div>
    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div class="py-5" id="board">
          <article class="post-content mx-auto">
            <!-- SEO header -->
            <h1 style="display: none">API_Design_Principles</h1>
            
              <p class="note note-info">
                
                  本文最后更新于：2022年3月19日 凌晨
                
              </p>
            
            <div class="markdown-body">
              <div class="toc">

<!-- toc -->

<ul>
<li><a href="#api-she-ji-gui-fan">API 设计规范</a><ul>
<li><a href="#you-xiu-jie-kou-de-liu-da-te-dian">优秀接口的六大特点</a></li>
<li><a href="#jing-tai-duo-tai">静态多态</a><ul>
<li><a href="#hao-de">好的</a></li>
<li><a href="#pi-de">坏的</a></li>
<li><a href="#cun-yi">存疑</a></li>
</ul>
</li>
<li><a href="#ji-yu-shu-xing-de-api">基于属性的 API</a></li>
<li><a href="#qproperty">QProperty</a></li>
<li><a href="#c-te-xing">C++ 特性</a><ul>
<li><a href="#zhi-yu-dui-xiang">值 与 对象</a></li>
<li><a href="#zhi-zhen-yu-yin-yong">指针 与 引用</a></li>
<li><a href="#chuan-di-chang-yin-yong-yu-chuan-di-zhi">传递常引用 与 传递值</a></li>
<li><a href="#xu-han-shu">虚函数</a></li>
<li><a href="#bu-bian-xing">不变性</a></li>
</ul>
</li>
<li><a href="#api-semantics-and-documentation">API Semantics and Documentation</a></li>
<li><a href="#the-art-of-naming">The Art of Naming</a><ul>
<li><a href="#general-naming-rules">General Naming Rules</a></li>
<li><a href="#naming-classes">Naming Classes</a></li>
<li><a href="#naming-enum-types-and-values">Naming Enum Types and Values</a></li>
<li><a href="#naming-functions-and-parameters">Naming Functions and Parameters</a></li>
<li><a href="#naming-boolean-getters-setters-and-properties">Naming Boolean Getters, Setters, and Properties</a></li>
</ul>
</li>
<li><a href="#avoiding-common-traps">Avoiding Common Traps</a><ul>
<li><a href="#the-convenience-trap">The Convenience Trap</a></li>
<li><a href="#the-boolean-parameter-trap">The Boolean Parameter Trap</a></li>
<li><a href="#the-copy-cat-trap">The Copy Cat Trap</a></li>
</ul>
</li>
<li><a href="#case-studies">Case Studies</a><ul>
<li><a href="#qprogressbar">QProgressBar</a></li>
<li><a href="#qabstractprintdialog-qabstractpagesizedialog">QAbstractPrintDialog &amp; QAbstractPageSizeDialog</a></li>
<li><a href="#qabstractitemmodel">QAbstractItemModel</a></li>
<li><a href="#qlayoutiterator-qglayoutiterator">QLayoutIterator &amp; QGLayoutIterator</a></li>
<li><a href="#qimagesink">QImageSink</a></li>
<li><a href="#other-qt3-vs-qt4">other Qt3 vs. Qt4?</a></li>
<li><a href="#qwidget-setwindowmodified-bool">QWidget::setWindowModified(bool)</a></li>
<li><a href="#q3url-vs-qurl">Q3Url vs. QUrl</a></li>
<li><a href="#q3textedit-vs-qtextedit">Q3TextEdit vs. QTextEdit</a></li>
<li><a href="#qt-s-clipping-story-naming-of-clipping-fns">Qt’s Clipping Story (naming of clipping fns)</a></li>
</ul>
</li>
</ul>
</li>
</ul>
<!-- tocstop -->

</div>

<h1><span id="api-she-ji-gui-fan">API 设计规范</span><a href="#api-she-ji-gui-fan" class="header-anchor">#</a></h1><blockquote>
<p>译者注：</p>
<p>本文不来自于 Qt 文档，而是来自于 Qt Wiki：<a target="_blank" rel="noopener" href="https://wiki.qt.io/API_Design_Principles">API_Design_Principles</a></p>
<p>API(Application Programming Interface)，应用开发接口，本文中也将 P 解释为 Programmer（开发者）。</p>
</blockquote>
<p>Qt 最出名的特点之一是一致性强、易于学习、功能强大的 API。本文尝试对我们在设计 Qt 风格的 API 中积累的诀窍进行总结。其中许多准则都是通用的，其它的则是习惯性用法，我们主要为了保持接口一致性而继续遵循。</p>
<p>尽管这些准则主要面向公共接口，但也鼓励您在设计内部接口时使用相同的技术，这对与您合作开发的同僚会更加友好。</p>
<p>您可能也会有兴趣查阅 Jasmin Blanchette 的 <a target="_blank" rel="noopener" href="https://people.mpi-inf.mpg.de/~jblanche/api-design.pdf">Little Manual of API Design (PDF)</a>，或它的前身，由 Matthias Ettrich 编写的 <a target="_blank" rel="noopener" href="https://doc.qt.io/archives/qq/qq13-apis.html"><em>Designing Qt-Style C++ APIs</em></a>。</p>
<h2><span id="you-xiu-jie-kou-de-liu-da-te-dian">优秀接口的六大特点</span><a href="#you-xiu-jie-kou-de-liu-da-te-dian" class="header-anchor">#</a></h2><p>API 是面向开发者的，而 GUI 则是面向终端用户。API 中的 P 代表开发者(Programmer)，而非程序(Program)，目的是指出 API 由开发者，即人类（而非计算机）所使用这一特点。</p>
<p>Matthias 在 Qt 季刊弟13期，关于 API 设计的文章中，声称他坚信 API 应该是最小化但完备的，具备清晰而简洁的语义，符合直觉，被开发者，易于记忆，能够引导开发者编写高可读性的代码。</p>
<hr>
<h4><span id="zui-xiao-hua">最小化</span><a href="#zui-xiao-hua" class="header-anchor">#</a></h4><p>最小化的 API 指包含尽可能少的公共成员和最少的类。这可让 API 更易于理解、记忆、调试和修改。</p>
<hr>
<h4><span id="wan-bei-xing">完备性</span><a href="#wan-bei-xing" class="header-anchor">#</a></h4><p>完备的 API 意味着具备所有应有的功能。这可能会与最小化产生冲突。此外，若一个成员函数位于错误的类中，则大多数潜在的用户回无法找到它。</p>
<hr>
<h4><span id="qing-xi-jian-ji-de-yu-yi">清晰简洁的语义</span><a href="#qing-xi-jian-ji-de-yu-yi" class="header-anchor">#</a></h4><p>与其它设计协作时，应该让您的设计做到最小例外。通用化会让事情更简单。特例可能存在，但不应成为关注的焦点。在处理特定问题时，不应让解决方案过度泛化。（例如，Qt 3 中的 <code>QMineSourceFactory</code> 本该被称作 <code>QImageLoader</code>，并且具备另一套 API。）</p>
<hr>
<h4><span id="fu-he-zhi-jue">复合直觉</span><a href="#fu-he-zhi-jue" class="header-anchor">#</a></h4><p>如同计算机上其它内容，API 应复合直觉。不同的开发经验和技术背景会导致对复合直觉与否有不同的感知。复合直觉的 API 应能让中等经验的开发者无需阅读文档并直接使用，并让不知道这个 API 的开发者可以理解使用它编写的代码。</p>
<hr>
<h4><span id="yi-yu-ji-yi">易于记忆</span><a href="#yi-yu-ji-yi" class="header-anchor">#</a></h4><p>为了让 API 易于记忆，请选择一组保持一致并足够精确的命名约定。使用可理解的模式和概念，并且避免缩写。</p>
<hr>
<h4><span id="ke-du-xing-dao-xiang">可读性导向</span><a href="#ke-du-xing-dao-xiang" class="header-anchor">#</a></h4><p>编写代码只需要一次，但阅读（以及调试和修改）则会非常频繁。高可读性的代码通常需要花更多时间编写，但可以在产品的生命周期中节约更多的时间。</p>
<p>最后需要谨记，不同类型的用户会使用 API 的不同部分。在单纯地创建一个 Qt 类实例能非常直观的同时，希望用户在尝试继承它之前先阅读文档则是很合理的。</p>
<h2><span id="jing-tai-duo-tai">静态多态</span><a href="#jing-tai-duo-tai" class="header-anchor">#</a></h2><p>相似的代码类应具有相似的 API。可以使用继承来实现——当运行时多态支持时，这是很合理的。但多态同时也可以体现在设计截断。例如，若将代码中的 <code>QProgressBar</code> 换为 <code>QSlider</code>，或将 <code>QString</code> 换为 <code>QByteArray</code>，他们间相似的 API 会另替换操作变得非常容易。这便是为何我们称之为“静态多态”。</p>
<p>静态多态同样可让记忆 API 和开发模式变得更加简单。结果是，对于一组有关联的类，相似的 API 通常比为每个类独立设计的完美 API 更加好用。</p>
<p>在 Qt 中，当不具备有足够说服力的原因时，我们更倾向于使用静态多态，而非继承。这减少了 Qt 的公共类数量，并让新用户更容易在文档中找到需要的内容。</p>
<hr>
<h3><span id="hao-de">好的</span><a href="#hao-de" class="header-anchor">#</a></h3><p>​    <code>QDialogBox</code> 和 <code>QMessageBox</code> 具有相似的 APi，以用于处理按钮（<code>addButton()</code>, <code>setStandardButtons()</code>，但无需继承自某些 “QAbstractButtonBox” 类。</p>
<hr>
<h3><span id="pi-de">坏的</span><a href="#pi-de" class="header-anchor">#</a></h3><p>​    <code>QAbstractSocket</code> 被 <code>QTcpSOcket</code> 和 <code>QUdpSocket</code> 所继承，但这两个类的交互方式差异很大。看起来并没有人使用过（或能够使用） <code>QAbstractSocket</code> 指针来进行通用且有效的操作。</p>
<hr>
<h3><span id="cun-yi">存疑</span><a href="#cun-yi" class="header-anchor">#</a></h3><p>​    <code>QBoxLayout</code> 是 <code>QHBoxLayout</code> 和 <code>QVBoxLayout</code> 的基类。优点：可以在工具栏中使用 <code>QBoxLayout</code>，调用 <code>setOrientation()</code> 来令其水平/垂直排布。缺点：引入额外的类，用户可能会写出形如 <code>((QBoxLayout *)hbox)-&gt;setOrientation(Qt::Vertical)</code> 的代码，而这是不合理的。</p>
<h2><span id="ji-yu-shu-xing-de-api">基于属性的 API</span><a href="#ji-yu-shu-xing-de-api" class="header-anchor">#</a></h2><p>比较新的 Qt 类倾向于使用基于属性的 API，例如：</p>
<div class="code-wrapper"><pre><code class="hljs c++">QTimer timer;
timer.<span class="hljs-built_in">setInterval</span>(<span class="hljs-number">1000</span>);
timer.<span class="hljs-built_in">setSingleShot</span>(<span class="hljs-literal">true</span>);
timer.<span class="hljs-built_in">start</span>();</code></pre></div>

<p>此处的<em>属性</em>，指的是作为对象状态一部分的任何概念性的特征——无论是否是实际的 <code>Q_PROPERTY</code>。只要可行，用户都应该允许以任何顺序设置属性，也就是说，这些属性应该是正交的。例如，上文的代码也可以写为：</p>
<div class="code-wrapper"><pre><code class="hljs c++">QTimer timer;
timer.<span class="hljs-built_in">setSingleShot</span>(<span class="hljs-literal">true</span>);
timer.<span class="hljs-built_in">setInterval</span>(<span class="hljs-number">1000</span>);
timer.<span class="hljs-built_in">start</span>();</code></pre></div>

<p>为了方便，我们也可以这样写：</p>
<div class="code-wrapper"><pre><code class="hljs c++">timer.<span class="hljs-built_in">start</span>(<span class="hljs-number">1000</span>);</code></pre></div>

<p>类似的，对于 <code>QRegExp</code>，我们可以：</p>
<div class="code-wrapper"><pre><code class="hljs c++">QRegExp regExp;
regExp.<span class="hljs-built_in">setCaseSensitive</span>(Qt::CaseInsensitive);
regExp.<span class="hljs-built_in">setPattern</span>(<span class="hljs-string">"."</span>);
regExp.<span class="hljs-built_in">setPatternSyntax</span>(Qt::WildcardSyntax);</code></pre></div>

<p>为了实现此类 API，内部的对象需要被惰性构造。例如在 <code>QRegExp</code> 的案例中，不应该在还不知道表达式使用何种语法之前，就在 <code>setPattern()</code> 中过早地编译 <code>.</code> 表达式。</p>
<p>属性通常是级联的，此时我们应该谨慎地处理。仔细考虑下当前样式提供的“默认图标大小”与 <code>QToolButton</code> 的 <code>iconSize</code> 属性：</p>
<div class="code-wrapper"><pre><code class="hljs c++">toolButton-&gt;<span class="hljs-built_in">iconSize</span>(); <span class="hljs-comment">// 返回当前样式表的默认大小</span>
toolButton-&gt;<span class="hljs-built_in">setStyle</span>(otherStyle);
toolButton-&gt;<span class="hljs-built_in">iconSize</span>(); <span class="hljs-comment">// 返回 otherStyle 的默认大小</span>
toolButton-&gt;<span class="hljs-built_in">setIconSize</span>(<span class="hljs-built_in">QSize</span>(<span class="hljs-number">52</span>, <span class="hljs-number">52</span>));
toolButton-&gt;<span class="hljs-built_in">iconSize</span>(); <span class="hljs-comment">// 返回 (52, 52)</span>
toolButton-&gt;<span class="hljs-built_in">setStyle</span>(yetAnotherStyle);
toolButton-&gt;<span class="hljs-built_in">iconSize</span>(); <span class="hljs-comment">// 返回 (52, 52) </span></code></pre></div>

<p>注意，一旦 <code>iconSize</code> 被设置，它会被一直留存，此时修改当前样式不会影响它。这是 <strong>好的</strong>。有时，提供重置属性的渠道会很方便，这有两种实现方式：</p>
<ul>
<li>传递一个特定值（如 <code>QSIze()</code>、<code>-1 </code>或 <code>Qt::Alignment(0)</code>）来指代“重置”；</li>
<li>提供显示的 <code>resetFoo()</code> 或 <code>unsetFoo()</code> 函数。</li>
</ul>
<p>对于 <code>iconSize</code>，将 <code>QSize()</code>（即 <code>QSize(-1, -1)</code>）设为“重置”便足够了。</p>
<p>某些场景中，取值方法会返回值会与设置的内容不同。例如，若调用 <code>widget-&gt;setEnabled(true)</code>，可能通过 <code>widget-&gt;isEnabled()</code> 获得的依然是 <code>false</code>，因为父控件被禁用了。这并没问题，因为通常这正是我们要检查的状态（父控件被禁用时，子控件也应该变灰，表现为也被禁用，但同时在它内部，应该知道自己实际是“可用”的，并等待父控件可用后恢复状态），但必须在文档中正确地进行描述。</p>
<hr>
<h2><span id="qproperty">QProperty</span><a href="#qproperty" class="header-anchor">#</a></h2><blockquote>
<p>译者注：该类型为 Qt 6.0 引入，需要参见 Qt 6 类文档。</p>
<p>本文原文中的内容与现有的 Qt 6.0 预览版存在出入，因此暂不翻译本节，待官方进一步维护更新原文。</p>
</blockquote>
<h2><span id="c-te-xing">C++ 特性</span><a href="#c-te-xing" class="header-anchor">#</a></h2><h3><span id="zhi-yu-dui-xiang">值 与 对象</span><a href="#zhi-yu-dui-xiang" class="header-anchor">#</a></h3><blockquote>
<p>译者注：此条原文无内容，待官方更新</p>
</blockquote>
<hr>
<h3><span id="zhi-zhen-yu-yin-yong">指针 与 引用</span><a href="#zhi-zhen-yu-yin-yong" class="header-anchor">#</a></h3><p>作为输出参数，指针与引用哪个更好？</p>
<div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">getHsv</span><span class="hljs-params">(<span class="hljs-type">int</span> *h, <span class="hljs-type">int</span> *s, <span class="hljs-type">int</span> *v)</span> <span class="hljs-type">const</span> <span class="hljs-type">void</span> <span class="hljs-title">getHsv</span><span class="hljs-params">(<span class="hljs-type">int</span> &amp;h, <span class="hljs-type">int</span> &amp;s, <span class="hljs-type">int</span> &amp;v)</span> <span class="hljs-type">const</span></span></code></pre></div>

<p>绝大多数 C++ 数据都推荐尽可能使用引用，因为引用在感知上比指针“更安全更漂亮”。事实上，我们在 Qt 软件中更倾向于使用指针，因为这会令代码更加已读。如对比：</p>
<div class="code-wrapper"><pre><code class="hljs c++">color.<span class="hljs-built_in">getHsv</span>(&amp;h, &amp;s, &amp;v);
color.<span class="hljs-built_in">getHsv</span>(h, s, v);</code></pre></div>

<p>第一行代码能很清晰地表示，<code>h</code>、<code>s</code>、<code>v</code> 对象有很大概率会被该函数调用所修改。</p>
<p>即便如此，由于编译器并不喜欢输出参数，在新 APi 中应该避免此用法，而是返回一个小结构体：</p>
<div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Hsv</span> { <span class="hljs-type">int</span> hue, saturation, value }; <span class="hljs-function">Hsv <span class="hljs-title">getHsv</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span>;</code></pre></div>

<blockquote>
<p>译者注：对于可能失败的带返回值的函数，Qt 倾向于返回数值，使用 <code>bool* ok = 0</code> 参数来存储调用结果，以便在不关心时忽略之。同样在 Qt 6 以后，该方式不再被建议使用，而是改用 <code>std::optional&lt;T&gt;</code> 返回类型。</p>
</blockquote>
<hr>
<h3><span id="chuan-di-chang-yin-yong-yu-chuan-di-zhi">传递常引用 与 传递值</span><a href="#chuan-di-chang-yin-yong-yu-chuan-di-zhi" class="header-anchor">#</a></h3><p>若类型大于16字节，传递常引用。</p>
<p>若类型具有<a target="_blank" rel="noopener" href="https://zh.cppreference.com/w/cpp/language/copy_constructor#.E5.B9.B3.E5.87.A1.E5.A4.8D.E5.88.B6.E6.9E.84.E9.80.A0.E5.87.BD.E6.95.B0">非平凡的拷贝构造函数</a>或<a target="_blank" rel="noopener" href="https://zh.cppreference.com/w/cpp/language/destructor#.E5.B9.B3.E5.87.A1.E6.9E.90.E6.9E.84.E5.87.BD.E6.95.B0">非平凡的析构函数</a>，传递常引用来避免执行这些方法。</p>
<p>所有其它类型都应使用值传递。</p>
<p>范例：</p>
<div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">setAge</span><span class="hljs-params">(<span class="hljs-type">int</span> age)</span></span>;
<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">setCategory</span><span class="hljs-params">(QChar cat)</span></span>;
<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">setName</span><span class="hljs-params">(QLatin1String name)</span></span>;
<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">setAlarm</span><span class="hljs-params">(<span class="hljs-type">const</span> QSharedPointer&lt;Alarm&gt; &amp;alarm)</span></span>; <span class="hljs-comment">// 常引用远快于拷贝构造和析构</span>
<span class="hljs-comment">// QDate, QTime, QPoint, QPointF, QSize, QSizeF, QRect 都是其它应该值传递的好例子</span></code></pre></div>

<hr>
<h3><span id="xu-han-shu">虚函数</span><a href="#xu-han-shu" class="header-anchor">#</a></h3><p>当 C++ 中的一个成员函数被声明为虚函数，这主要用于通过在子类中重写来自定义该函数的行为。将函数设为虚函数的目的是让对该函数的现有调用会被替代为访问自定义的代码分支。若在该类之外没人调用此函数，则在将其声明为虚函数之前需要小心斟酌：</p>
<div class="code-wrapper"><pre><code class="hljs c++"> <span class="hljs-comment">// Qt 3 中的 QTextEdit: 成员函数不需要作为虚函数的成员函数</span>
<span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">resetFormat</span><span class="hljs-params">()</span></span>;
<span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">setUndoDepth</span><span class="hljs-params">( <span class="hljs-type">int</span> d )</span></span>;
<span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">setFormat</span><span class="hljs-params">( QTextFormat &amp;f, <span class="hljs-type">int</span> flags )</span></span>;
<span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">ensureCursorVisible</span><span class="hljs-params">()</span></span>;
<span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">placeCursor</span><span class="hljs-params">( <span class="hljs-type">const</span> QPoint &amp;pos;, QTextCursorc = <span class="hljs-number">0</span> )</span></span>;
<span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">moveCursor</span><span class="hljs-params">( CursorAction action, <span class="hljs-type">bool</span> select )</span></span>;
<span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">doKeyboardAction</span><span class="hljs-params">( KeyboardAction action )</span></span>;
<span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">removeSelectedText</span><span class="hljs-params">( <span class="hljs-type">int</span> selNum = <span class="hljs-number">0</span> )</span></span>;
<span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">removeSelection</span><span class="hljs-params">( <span class="hljs-type">int</span> selNum = <span class="hljs-number">0</span> )</span></span>;
<span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">setCurrentFont</span><span class="hljs-params">( <span class="hljs-type">const</span> QFont &amp;f )</span></span>;
<span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">setOverwriteMode</span><span class="hljs-params">( <span class="hljs-type">bool</span> b )</span> </span>{ overWrite = b; }</code></pre></div>

<p>当 <code>QTextEdit</code> 从 Qt 3 迁移至 Qt 4 时，几乎所有虚函数都被移除。有趣的是（但并未预料到），并没有大量的抱怨。为什么？因为 Qt 3 并未使用 <code>QTextEdit</code> 的多态性，Qt 3 并不会调用这些函数——只有使用者会。简单来说，否则并没有任何理由去继承 <code>QTextEdit</code> 并重写这些方法——除非您自己会通过多态去调用它们。若您需要在您的应用程序，也就是 Qt 之外使用多态机制，您应该自行添加。</p>
<h4><span id="bi-mian-shi-yong-xu-han-shu">避免使用虚函数</span><a href="#bi-mian-shi-yong-xu-han-shu" class="header-anchor">#</a></h4><p>在 Qt 中，我们因为多种原因而尝试最小化虚函数的数量。每个虚函数调用都会让缺陷修复变得更难，因为会在调用图中插入一个不受控制的节点（使得调用结果无法预测）。人们会在虚函数中做非常疯狂的举措，例如：</p>
<ul>
<li>发送事件</li>
<li>发送信号</li>
<li>重入事件循环（例如，打开一个模态文件对话框）</li>
<li>删除对象（例如，某些导致 <code>delete this</code> 的操作）</li>
</ul>
<p>此外还有一些避免过度使用虚函数的原因：</p>
<ul>
<li>无法在不破坏二进制兼容性的前提下增加、移动或删除虚函数</li>
<li>无法简便地重写虚函数</li>
<li>编译器通常几乎不会内敛虚函数调用</li>
<li>调用虚函数需要查询虚表，导致其比常规函数调用慢2-3倍</li>
<li>虚函数另类对象更难进行值拷贝（可能做到，但会表现得很混乱且不被推荐）</li>
</ul>
<p>过去的经验告诉我们，没有虚函数地类会产生更少的错误，通常也导致更少的维护。</p>
<p>一个通用的经验法则是，除非从工具集或该类的主要使用者角度需要调用它，否则一个函数不应该是虚函数。</p>
<h4><span id="xu-dui-xiang-yu-ke-fu-zhi-xing">虚对象 与 可复制性</span><a href="#xu-dui-xiang-yu-ke-fu-zhi-xing" class="header-anchor">#</a></h4><p>多态对象和值类型的类并不是好朋友。</p>
<p>包含虚函数的类会有虚析构函数来避免基类析构时未清理子类数据导致的内存泄漏。</p>
<p>若需要以值语义拷贝、复制和对比一个类，则可能需要拷贝构造函数、赋值运算符重载和等于运算符重载：</p>
<div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">CopyClass</span> {
  <span class="hljs-keyword">public</span>:
    <span class="hljs-built_in">CopyClass</span>();
    <span class="hljs-built_in">CopyClass</span>(<span class="hljs-type">const</span> CopyClass &amp;other);
    ~<span class="hljs-built_in">CopyClass</span>();
    CopyClass &amp;<span class="hljs-keyword">operator</span>=(<span class="hljs-type">const</span> CopyClass &amp;other);
    <span class="hljs-type">bool</span> <span class="hljs-keyword">operator</span>== (<span class="hljs-type">const</span> CopyClass &amp;other) <span class="hljs-type">const</span>;
    <span class="hljs-type">bool</span> <span class="hljs-keyword">operator</span>!=(<span class="hljs-type">const</span> CopyClass &amp;other) <span class="hljs-type">const</span>;
    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">setValue</span><span class="hljs-params">(<span class="hljs-type">int</span> v)</span></span>;
};</code></pre></div>

<p>若创建该类的子类，则代码中会开始发生意料外的行为。通常来说，若没有虚函数和虚构造函数，则人们无法创建依赖于多态特性的子类。因此一旦虚函数或虚析构函数被添加，这会马上成为建立子类的理由，事情从此变得复杂。<em>乍一看来，很容易觉得可以简单定义一下虚运算符重载</em>。但顺着这条路深入下去，会导致混乱和毁灭（例如无可读性的代码）。请研究下这段代码：</p>
<div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">OtherClass</span> {
  <span class="hljs-keyword">public</span>:
    <span class="hljs-function"><span class="hljs-type">const</span> CopyClass &amp;<span class="hljs-title">instance</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span>; <span class="hljs-comment">// 此处会返回什么？我应该将返回值赋值给谁？</span>
};</code></pre></div>

<p>（此小节正在施工中）</p>
<hr>
<h3><span id="bu-bian-xing">不变性</span><a href="#bu-bian-xing" class="header-anchor">#</a></h3><p>C++ 提供了 <code>const</code> 关键字来标识不会改变或不会产生副作用的事物。它可被用于数值、指针和倍只想的内容，也可被作为成员函数的特殊属性来标识它不会修改对象的状态。</p>
<p>注意，<code>const</code> 自身并不提供太大的价值——许多语言甚至并未提供 <code>const</code> 关键字，但这并不会自动导致它们存在缺陷。事实上，若移除所有函数重载，并通过搜索替换移除 C++ 代码中的所有 <code>const</code> 标识，代码很可能依然能够编译并正确执行。使用实用主义导向来使用 <code>const</code> 是很重要的。</p>
<p>让我们看看 Qt 中使用 <code>const</code> 的 API 设计：</p>
<h4><span id="shu-ru-can-shu-const-zhi-zhen">输入参数：<code>const</code> 指针</span><a href="#shu-ru-can-shu-const-zhi-zhen" class="header-anchor">#</a></h4><p>使用指针输入参数的 <code>const</code> 成员函数几乎总是使用 <code>const</code> 指针。</p>
<p>若一个成员函数确实被声明为 <code>const</code>，这意味着它不具有副作用，也不会修改对象对外可见的状态。那么，为什么要需要非 <code>const</code> 的输入参数？需要牢记，<code>const</code> 成员函数经常会被其它 <code>const</code> 成员函数，在这些调用场合中，非 <code>const</code> 的指针并不容易得到（除非使用 <code>const_cast</code>，而我们应该尽可能避免使用它）。</p>
<p>修改之前：</p>
<div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">QWidget::isVisibleTo</span><span class="hljs-params">(QWidget *ancestor)</span> <span class="hljs-type">const</span></span>;
<span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">QWidget::isEnabledTo</span><span class="hljs-params">(QWidget *ancestor)</span> <span class="hljs-type">const</span></span>;
<span class="hljs-function">QPoint <span class="hljs-title">QWidget::mapFrom</span><span class="hljs-params">(QWidget *ancestor, <span class="hljs-type">const</span> QPoint &amp;pos)</span> <span class="hljs-type">const</span></span>;</code></pre></div>

<p><code>QWidget</code> 声明了大量使用非 <code>const</code> 指针作为输入参数的 <code>const</code> 成员函数。注意，虽然这些函数不能修改调用的控件本身，但是可以修改传入的控件。这类成员函数经常会伴随 <code>const_cast</code> 所使用。此类成员函数使用 <code>const</code> 输入参数会更合适。</p>
<p>修改之后：</p>
<div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">QWidget::isVisibleTo</span><span class="hljs-params">(<span class="hljs-type">const</span> QWidget *ancestor)</span> <span class="hljs-type">const</span></span>;
<span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">QWidget::isEnabledTo</span><span class="hljs-params">(<span class="hljs-type">const</span> QWidget *ancestor)</span> <span class="hljs-type">const</span></span>;
<span class="hljs-function">QPoint <span class="hljs-title">QWidget::mapFrom</span><span class="hljs-params">(<span class="hljs-type">const</span> QWidget *ancestor, <span class="hljs-type">const</span> QPoint &amp;pos)</span> <span class="hljs-type">const</span></span>;</code></pre></div>

<p>注意，我们在 <code>QGraphicsItem</code> 中修复了这些成员函数，但 <code>QWidget</code> 的修复需要等待 Qt 5：</p>
<div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isVisibleTo</span><span class="hljs-params">(<span class="hljs-type">const</span> QGraphicsItem *parent)</span> <span class="hljs-type">const</span></span>;
<span class="hljs-function">QPointF <span class="hljs-title">mapFromItem</span> <span class="hljs-params">(<span class="hljs-type">const</span> QGraphicsItem *item, <span class="hljs-type">const</span> QPointF &amp;point)</span> <span class="hljs-type">const</span></span>;</code></pre></div>

<h4><span id="fan-hui-zhi-const-zhi">返回值：<code>const</code> 值</span><a href="#fan-hui-zhi-const-zhi" class="header-anchor">#</a></h4><p>函数的返回值，要么是引用类型，要么是<a target="_blank" rel="noopener" href="https://zh.cppreference.com/w/cpp/language/value_category#.E5.8F.B3.E5.80.BC">右值</a>。</p>
<p>非类类型的右值是不受<a target="_blank" rel="noopener" href="https://zh.cppreference.com/w/cpp/language/cv">cv限定符</a>影响的。因此，即使在语法上允许为其添加 <code>const</code> 修饰，这并不会产生效果，因为由于其访问权不允许对其做出修改。大多数现代编译器在编译此类代码时会打印警告信息。</p>
<p>当为类类型的右值添加 <code>const</code> 时，对该类的非 <code>const</code> 的成员函数的访问会被禁止，对其成员变量的直接操作也会被禁止。</p>
<p>不添加 <code>const</code> 允许此类操作，但很少有此类需求，因为这些修改会伴随右值对象生命周期的结束而消失，这会在当前语句的分号结束后发生。</p>
<p>例如：</p>
<div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Foo</span> {
    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">setValue</span><span class="hljs-params">(<span class="hljs-type">int</span> v)</span> </span>{ value = v; } <span class="hljs-type">int</span> value;
};

<span class="hljs-function">Foo <span class="hljs-title">foo</span><span class="hljs-params">()</span> </span>{ <span class="hljs-keyword">return</span> <span class="hljs-built_in">Foo</span>(); }
<span class="hljs-function"><span class="hljs-type">const</span> Foo <span class="hljs-title">cfoo</span><span class="hljs-params">()</span> </span>{ <span class="hljs-keyword">return</span> <span class="hljs-built_in">Foo</span>(); }
<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>{
    <span class="hljs-comment">// 下述代码可以编译，foo() 返回非 const 右值，无法</span>
    <span class="hljs-comment">// 成为赋值目标（这通常需要左值），但对成员变量的访问</span>
    <span class="hljs-comment">// 是左值：</span>
    <span class="hljs-built_in">foo</span>().value = <span class="hljs-number">1</span>; <span class="hljs-comment">// 可以编译，但该临时值在这个完整的表达式结束后会被抛弃</span>
    
    <span class="hljs-comment">// 下述代码可以编译，foo() 返回非 const 右值，无法</span>
    <span class="hljs-comment">// 成为赋值目标，但可以调用（甚至于非 const 的)成员函数：</span>
    <span class="hljs-built_in">foo</span>().<span class="hljs-built_in">setValue</span>(<span class="hljs-number">1</span>); <span class="hljs-comment">// 可以编译，但该临时值在这个完整的表达式结束后会被抛弃</span>
    
    <span class="hljs-comment">// 下述代码无法编译，cfoo() 返回 const 右值，因此其</span>
    <span class="hljs-comment">// 成员变量是 const 授权，无法被赋值：</span>
    <span class="hljs-built_in">cfoo</span>().value = <span class="hljs-number">1</span>; <span class="hljs-comment">// 无法编译</span>
    
    <span class="hljs-comment">// 下述代码无法编译，cfoo() 返回 const 右值，无法调用</span>
    <span class="hljs-comment">// 其非 const 的成员函数：</span>
    <span class="hljs-built_in">cfoo</span>().<span class="hljs-built_in">setValue</span>(<span class="hljs-number">1</span>); <span class="hljs-comment">// 无法编译</span>
}</code></pre></div>

<h4><span id="fan-hui-zhi-zhi-zhen-yu-const-zhi-zhen">返回值：指针与 <code>const</code> 指针</span><a href="#fan-hui-zhi-zhi-zhen-yu-const-zhi-zhen" class="header-anchor">#</a></h4><p><code>const</code> 成员函数应该返回指针还是 <code>const</code> 指针这个问题，令许多人发现 C++ 的“const 正确性”被瓦解了。该问题源于某些 <code>const</code> 成员函数，并不修改它们的内部状态，而是返回成员变量的非 <code>const</code> 指针。单纯返回一个指针并不会影响对象对外可见的状态，也不会修改它正在维护的状态。但这会令程序员获得间接地修改对象数据的权限。</p>
<p>下述范例展示了通过 <code>const</code> 成员函数返回的非 <code>const</code> 指针来规避不可变性的诸多方法之一：</p>
<div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-function">QVariant <span class="hljs-title">CustomWidget::inputMethodQuery</span><span class="hljs-params">(Qt::InputMethodQuery query)</span> <span class="hljs-type">const</span> </span>{
    <span class="hljs-built_in">moveBy</span>(<span class="hljs-number">10</span>, <span class="hljs-number">10</span>); <span class="hljs-comment">// 无法编译！</span>
    <span class="hljs-built_in">window</span>()-&gt;<span class="hljs-built_in">childAt</span>(<span class="hljs-built_in">mapTo</span>(<span class="hljs-built_in">window</span>(), <span class="hljs-built_in">rect</span>().<span class="hljs-built_in">center</span>()))-&gt;<span class="hljs-built_in">moveBy</span>(<span class="hljs-number">10</span>, <span class="hljs-number">10</span>); <span class="hljs-comment">// 可以编译！</span>
}</code></pre></div>

<p>返回 <code>const</code> 指针的函数，至少在一定程度上，避免了此类（可能并不希望/非预期的）副作用。但哪些函数会考虑返回 <code>const</code> 指针，或一组 <code>const</code> 指针？若我们使用 const正确 的方案，即令任何 <code>const</code> 成员函数返回成员变量（或一组成员变量的指针）时都是用 <code>const</code> 指针形式。很不幸的是，实际中这会造就无法使用的 API：</p>
<div class="code-wrapper"><pre><code class="hljs c++">QGraphicsScene scene;
<span class="hljs-comment">// … 初始化场景</span>
foreach (<span class="hljs-type">const</span> QGraphicsItem *item, scene.<span class="hljs-built_in">items</span>()) {
    item-&gt;<span class="hljs-built_in">setPos</span>(<span class="hljs-built_in">qrand</span>() % <span class="hljs-number">500</span>, <span class="hljs-built_in">qrand</span>() % <span class="hljs-number">500</span>); <span class="hljs-comment">// 无法编译！item 是 const 指针</span>
}</code></pre></div>

<p><code>QGraphicsScene::items()</code> 是 <code>const</code> 成员函数，这可能会让人觉得应该返回 <code>const</code> 指针。</p>
<p>在 Qt 中，我们近乎只使用非 <code>const</code> 的模式。我们选择了实用主义之路：返回 <code>const</code> 指针更容易导致 <code>const_cast</code> 的过度使用，这比滥用返回的非 <code>const</code> 指针引发的问题更加频繁。</p>
<h4><span id="fan-hui-lei-xing-zhi-huo-const-yin-yong">返回类型：值 或 <code>const</code> 引用？</span><a href="#fan-hui-lei-xing-zhi-huo-const-yin-yong" class="header-anchor">#</a></h4><p>如果我们在返回对象时还保留了它的副本，返回 <code>const</code> 引用是最快的方法；然而，这在我们之后打算重构这个类时成为了限制（使用 d 指针惯用法，我们可以在任何时候修改 Qt 类的内存结构；但我们无法在不破坏二进制兼容性的前提下，将函数签名从 <code>const QFoo&amp;</code> 改为 <code>QFoo</code>）。出于此原因，我们通常返回 <code>QFoo</code> 而非 <code>const QFoo&amp;</code>，除了性能极端敏感，而重构并不是问题的少数场合（例如 <code>QList::at()</code>）。</p>
<h4><span id="const-yu-dui-xiang-de-zhuang-tai"><code>const</code> 与 对象的状态</span><a href="#const-yu-dui-xiang-de-zhuang-tai" class="header-anchor">#</a></h4><p><code>const</code>正确性 是 C 中的一场“圣战”（译者注：原文为 <code>vi-emacs discussion</code>），因为该原则在一些领域（如基于指针的函数）中是失效了。</p>
<p>但 <code>const</code> 成员函数的常规含义是值不会修改一个类对外可见的状态，状态在此处值“我自己的和我负责的”。这并不意味着 <code>const</code> 成员函数会改变它们自己的私有成员变量，但也不代表不能这么做。但通常来说，<code>const</code> 成员函数不会产生可见的副作用。例如：</p>
<div class="code-wrapper"><pre><code class="hljs c++">QSize size = widget-&gt;<span class="hljs-built_in">sizeHint</span>(); <span class="hljs-comment">// const</span>
widget-&gt;<span class="hljs-built_in">move</span>(<span class="hljs-number">10</span>, <span class="hljs-number">10</span>); <span class="hljs-comment">// 非 const</span></code></pre></div>

<p>代理对象负责处理对另一个对象的绘制工作，它的状态包含了它负责的内容，也就是包含它的绘制目标的状态。请求代理进行绘制是具有副作用的：这会改变正在被绘制的设备的外观（也意味着状态）。正因如此，令 <code>paint()</code> 成为 <code>const</code> 并不合理。任何视图控件或 <code>QIcon</code> 的 <code>paint()</code> 作为 <code>const</code> 都很不合理。没人会在 <code>const</code> 成员函数中去调用 <code>QIcon::paint()</code>，除非他们明确地像规避当前函数的 <code>const</code> 性质。而在这种场景中，显示的 <code>const_cast</code> 会是更好的选择：</p>
<div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-comment">// QAbstractItemDelegate::paint 是 const</span>
<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">QAbstractItemDelegate::paint</span><span class="hljs-params">(QPainter *painter, <span class="hljs-type">const</span> QStyleOptionViewItem &amp;option, <span class="hljs-type">const</span> QModelIndex &amp;index)</span> <span class="hljs-type">const</span></span>
<span class="hljs-function"><span class="hljs-comment">// QGraphicsItem::paint 不是 const</span></span>
<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">QGraphicsItem::paint</span><span class="hljs-params">(QPainter &amp;painter, <span class="hljs-type">const</span> QStyleOptionGraphicsItem &amp;option, QWidget &amp;widget = <span class="hljs-number">0</span>)</span></span></code></pre></div>

<p><code>const</code> 关键字不会为你<strong>做任何事</strong>，考虑将其移除，而非为一个成员函数提供 <code>const</code>/非 <code>const</code> 的重载版本。</p>
<h2><span id="api-semantics-and-documentation">API Semantics and Documentation</span><a href="#api-semantics-and-documentation" class="header-anchor">#</a></h2><p>What should you do when you pass -1 to a function? etc…</p>
<p>Warnings/fatals/etc</p>
<p>APIs need quality assurance. The first revision is never right;  you must test it. Make use cases by looking at code which uses this API  and verify that the code is readable.</p>
<p>Other tricks include having somebody else use the API with or  without documentation and documenting the class (both the class overview and the individual functions).</p>
<h2><span id="the-art-of-naming">The Art of Naming</span><a href="#the-art-of-naming" class="header-anchor">#</a></h2><p>Naming is probably the single most important issue when designing an API. What should the classes be called? What should the member functions be  called?</p>
<h3><span id="general-naming-rules">General Naming Rules</span><a href="#general-naming-rules" class="header-anchor">#</a></h3><p>A few rules apply equally well to all kinds of names. First, as I  mentioned earlier, do not abbreviate. Even obvious abbreviations such as “prev” for “previous” don’t pay off in the long run, because the user  must remember which words are abbreviated.</p>
<p>Things naturally get worse if the API itself is inconsistent; for example, Qt 3 has activatePreviousWindow() and fetchPrev(). Sticking to the “no abbreviation” rule makes it simpler to create consistent APIs.</p>
<p>Another important but more subtle rule when designing classes is  that you should try to keep the namespace for subclasses clean. In Qt 3, this principle wasn’t always followed. To illustrate this, we will take the example of a QToolButton. If you call name(), caption(), text(), or textLabel() on a QToolButton in Qt 3, what do you expect? Just try  playing around with a QToolButton in Qt Designer:</p>
<ul>
<li>The name property is inherited from QObject and refers to an internal object name that can be used for debugging and testing.</li>
<li>The caption property is inherited from QWidget and refers to the  window title, which has virtually no meaning for QToolButtons, since  they usually are created with a parent.</li>
<li>The text property is inherited from QButton and is normally used on the button, unless useTextLabel is true.</li>
<li>The textLabel property is declared in QToolButton and is shown on the button if useTextLabel is true.</li>
</ul>
<p>In the interest of readability, name is called objectName in Qt 4,  caption has become windowTitle, and there is no longer any textLabel  property distinct from text in QToolButton.</p>
<p>Documenting is also a good way of finding good names when you get stuck: just try to document the item (class, function, enum value,  etc.) and use your first sentence as inspiration. If you cannot find a  precise name, this is often a sign that the item shouldn’t exist. If  everything else fails and you are convinced that the concept makes  sense, invent a new name. This is, after all, how “widget”, “event”,  “focus”, and “buddy” came to be. </p>
<h3><span id="naming-classes">Naming Classes</span><a href="#naming-classes" class="header-anchor">#</a></h3><p>Identify groups of classes instead of finding the perfect name for each  individual class. For example, All the Qt 4 model-aware item view  classes are suffixed with View (QListView, QTableView, and QTreeView),  and the corresponding item-based classes are suffixed with Widget  instead (QListWidget, QTableWidget, and QTreeWidget).</p>
<h3><span id="naming-enum-types-and-values">Naming Enum Types and Values</span><a href="#naming-enum-types-and-values" class="header-anchor">#</a></h3><p>The guiding principle is to avoid name clashes between enum values and to ensure readability code with reasonable verbosity.</p>
<h4><span id="enums-in-qt-global-namespace">Enums in Qt/global namespace</span><a href="#enums-in-qt-global-namespace" class="header-anchor">#</a></h4><p>New enums in the Qt namespace should always use scoped/strong enumerators  by default. The scoping/strong typing ensures that there is no conflict  if the same enum value name is used multiple times:</p>
<div class="code-wrapper"><pre><code class="hljs"></code></pre></div>

<p>`namespace Qt {  enum class Color {    Blue,    Orange,    Yellow  };  <code> enum class FavoriteColor {    Yellow,    Orange  }; }</code>Color yellow = Qt::Color::Yellow; FavoriteColor yellow2 = Qt::FavoriteColor::Yellow; yellow2 = Qt::Orange; // error ```</p>
<p>``</p>
<p>When using scoped enums additional naming rules (repeating of enum type name inside enum value name) for are not necessary. </p>
<h4><span id="enums-in-classes">Enums in classes</span><a href="#enums-in-classes" class="header-anchor">#</a></h4><p>Enums inside a class do not have the same problem of names clashing, as they are already namespaced within the class. </p>
<p>There are still reasons to prefer scoped enums inside classes, but this should be decided on a case by case basis.</p>
<p>If the enum values have a clear relation to the parent class, prefer un-scoped enums:</p>
<div class="code-wrapper"><pre><code class="hljs"></code></pre></div>

<p>`class TouchPoint {  enum State {       Pressed,       Held,       Released  }; <code>}; // The context is clear when used outside the class if (point.state() == TouchPoint::Pressed) </code>  … <code>// As well as when used inside it if (state() == Pressed) </code>  … ```</p>
<p>``</p>
<p>Using scoped enums in this case would add redundant line noise:</p>
<div class="code-wrapper"><pre><code class="hljs pf">if (point.<span class="hljs-keyword">state</span>() == TouchPoint::State::Pressed)</code></pre></div>

<p>`  … <code>if (state() == State::Pressed) </code>  … ```</p>
<p>``</p>
<p>Note that the context where the enum is used, such as the name of the getter that returns the enum value, might be enough information to  make a scoped enum redundant.</p>
<p>If the enum values do not have a natural relation to the class name, prefer scoped enums, e.g.:</p>
<div class="code-wrapper"><pre><code class="hljs"></code></pre></div>

<p>`class QSslCertificate {  enum class PatternSyntax {       RegularExpression,       Wildcard,       FixedString  }; <code>}; if (syntax == PatternSyntax::Wildcard) </code> … ```</p>
<p>`` Another option to avoid the name clash instead of scoped/strong enums is to embedded the enum type name into each enum value. This method was  extensively used in Qt 4 before scoped/strong enums were available.</p>
<div class="code-wrapper"><pre><code class="hljs"></code></pre></div>

<p>`class Widget {      enum Corner {          TopLeftCorner,          BottomRightCorner,           …     }; };  ``tabWidget-&gt;setCornerWidget(widget, Widget::TopLeftCorner); ```</p>
<p>``</p>
<h4><span id="enums-in-flags">Enums in flags</span><a href="#enums-in-flags" class="header-anchor">#</a></h4><p>When enumerator values can be OR’d together and be used as flags, the  traditional solution is to store the result of the OR in an int, which  isn’t type-safe. Qt offers a template class QFlags<t>, where T is  the enum type. For convenience, Qt provides typedefs for the flag type  names, so you can type Qt::Alignment instead of  QFlags<a href="Qt::AlignmentFlag">Qt::AlignmentFlag</a>.</t></p>
<p>By convention, we give the enum type a singular name (since it  can only hold one flag at a time) and the “flags” type a plural name.  For example:</p>
<div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">enum</span> <span class="hljs-title class_">RectangleEdge</span> { LeftEdge, RightEdge, … };
<span class="hljs-keyword">typedef</span> QFlags&lt;RectangleEdge&gt; RectangleEdges;</code></pre></div>

<p>In some cases, the “flags” type has a singular name. In that case, the enum type is suffixed with Flag:</p>
<div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">enum</span> <span class="hljs-title class_">AlignmentFlag</span> { AlignLeft, AlignTop, … };
<span class="hljs-keyword">typedef</span> QFlags&lt;AlignmentFlag&gt; Alignment;</code></pre></div>

<h3><span id="naming-functions-and-parameters">Naming Functions and Parameters</span><a href="#naming-functions-and-parameters" class="header-anchor">#</a></h3><p>The number one rule of function naming is that it should be clear from the  name whether the function has side-effects or not. In Qt 3, the const  function QString::simplifyWhiteSpace() violated this rule, since it  returned a QString instead of modifying the string on which it is  called, as the name suggests. In Qt 4, the function has been renamed  QString::simplified().</p>
<p>Parameter names are an important source of information to the  programmer, even though they don’t show up in the code that uses the  API. Since modern IDEs show them while the programmer is writing code,  it’s worthwhile to give decent names to parameters in the header files  and to use the same names in the documentation.</p>
<h3><span id="naming-boolean-getters-setters-and-properties">Naming Boolean Getters, Setters, and Properties</span><a href="#naming-boolean-getters-setters-and-properties" class="header-anchor">#</a></h3><p>Finding good names for the getter and setter of a bool property is always a  special pain. Should the getter be called checked() or isChecked()?  scrollBarsEnabled() or areScrollBarEnabled()?</p>
<p>In Qt 4, we used the following guidelines for naming the getter function:</p>
<ul>
<li><p>Adjectives are prefixed with </p>
<p>is-</p>
<p>. Examples:</p>
<ul>
<li><code>isChecked()</code></li>
<li><code>isDown()</code></li>
<li><code>isEmpty()</code></li>
<li><code>isMovingEnabled()</code></li>
</ul>
</li>
<li><p>However, adjectives applying to a plural noun have no prefix:</p>
<ul>
<li><code>scrollBarsEnabled(), not areScrollBarsEnabled()</code></li>
</ul>
</li>
<li><p>Verbs have no prefix and don’t use the third person (-s):</p>
<ul>
<li><code>acceptDrops(), not acceptsDrops()</code></li>
<li><code>allColumnsShowFocus()</code></li>
</ul>
</li>
<li><p>Nouns generally have no prefix:</p>
<ul>
<li><code>autoCompletion(), not isAutoCompletion()</code></li>
<li><code>boundaryChecking()</code></li>
</ul>
</li>
<li><p>Sometimes, having no prefix is misleading, in which case we prefix with </p>
<p>is-</p>
<p>:</p>
<ul>
<li><code>isOpenGLAvailable(), not openGL()</code></li>
<li><code>isDialog(), not dialog()</code></li>
</ul>
</li>
</ul>
<p>The name of the setter is derived from that of the getter by removing any is prefix and putting a set at the front of the name; for example,  setDown() and setScrollBarsEnabled(). The name of the property is the  same as the getter, but without the is prefix.</p>
<h2><span id="avoiding-common-traps">Avoiding Common Traps</span><a href="#avoiding-common-traps" class="header-anchor">#</a></h2><h3><span id="the-convenience-trap">The Convenience Trap</span><a href="#the-convenience-trap" class="header-anchor">#</a></h3><p>It is a common misconception that the less code you need to achieve  something, the better the API. Keep in mind that code is written more  than once but has to be understood over and over again. For example,</p>
<div class="code-wrapper"><pre><code class="hljs"></code></pre></div>

<p>`QSlider *slider = new QSlider(12, 18, 3, 13, Qt::Vertical, 0, “volume”); ```</p>
<p>``</p>
<p>is much harder to read (and even to write) than</p>
<div class="code-wrapper"><pre><code class="hljs"></code></pre></div>

<p>`QSlider *slider = new QSlider(Qt::Vertical); slider-&gt;setRange(12, 18); slider-&gt;setPageStep(3); slider-&gt;setValue(13); slider-&gt;setObjectName(“volume”); ```</p>
<p>``</p>
<h3><span id="the-boolean-parameter-trap">The Boolean Parameter Trap</span><a href="#the-boolean-parameter-trap" class="header-anchor">#</a></h3><p>Boolean parameters often lead to unreadable code. In particular, it’s almost  invariably a mistake to add a bool parameter to an existing function. In Qt, the traditional example is repaint(), which takes an optional bool  parameter specifying whether the background should be erased (the  default) or not. This leads to code such as</p>
<div class="code-wrapper"><pre><code class="hljs"></code></pre></div>

<p>`widget-&gt;repaint(false); ```</p>
<p>``</p>
<p>which beginners might read as meaning, “Don’t repaint!”</p>
<p>The thinking is apparently that the bool parameter saves one  function, thus helping reducing the bloat. In truth, it adds bloat; how  many Qt users know by heart what each of the next three lines does?</p>
<div class="code-wrapper"><pre><code class="hljs"></code></pre></div>

<p>`widget-&gt;repaint(); widget-&gt;repaint(true); widget-&gt;repaint(false); ```</p>
<p>``</p>
<p>A somewhat better API might have been</p>
<div class="code-wrapper"><pre><code class="hljs"></code></pre></div>

<p>`widget-&gt;repaint(); widget-&gt;repaintWithoutErasing(); ```</p>
<p>``</p>
<p>In Qt 4, we solved the problem by simply removing the possibility of repainting without erasing the widget. Qt 4’s native support for  double buffering made this feature obsolete.</p>
<p>Here are a few more examples:</p>
<div class="code-wrapper"><pre><code class="hljs"></code></pre></div>

<p>`widget-&gt;setSizePolicy(QSizePolicy::Fixed, QSizePolicy::Expanding, true); textEdit-&gt;insert(“Where’s Waldo?”, true, true, false); QRegExp rx(“moc_’***.c??”, false, true);*** ```</p>
<p>``</p>
<p>An obvious solution is to replace the bool parameters with enum  types. This is what we’ve done in Qt 4 with case sensitivity in QString. Compare:</p>
<div class="code-wrapper"><pre><code class="hljs"></code></pre></div>

<p>`str.replace(“USER”, user, false); // Qt 3 str.replace(“USER”, user, Qt::CaseInsensitive); // Qt 4 ```</p>
<p>``</p>
<h3><span id="the-copy-cat-trap">The Copy Cat Trap</span><a href="#the-copy-cat-trap" class="header-anchor">#</a></h3><h2><span id="case-studies">Case Studies</span><a href="#case-studies" class="header-anchor">#</a></h2><h3><span id="qprogressbar">QProgressBar</span><a href="#qprogressbar" class="header-anchor">#</a></h3><p>To show some of these concepts in practice, we’ll study the QProgressBar API of Qt 3 and compare it to the Qt 4 API. In Qt 3:</p>
<div class="code-wrapper"><pre><code class="hljs"></code></pre></div>

<p>`class QProgressBar : public QWidget { … public: int totalSteps() const; int progress() const; <code>const QString &amp;progressString() const; bool percentageVisible() const; void setPercentageVisible(bool); </code>void setCenterIndicator(bool on); bool centerIndicator() const; <code>void setIndicatorFollowsStyle(bool); bool indicatorFollowsStyle() const; </code>public slots: void reset(); virtual void setTotalSteps(int totalSteps); virtual void setProgress(int progress); void setProgress(int progress, int totalSteps); ``protected: virtual bool setIndicator(QString &amp;progressStr, int progress, int totalSteps); … }; ```</p>
<p>``</p>
<p>The API is quite complex and inconsistent; for example, it’s not  clear from the naming that reset(), setTotalSteps(), and setProgress()  are tightly related.</p>
<p>The key to improve the API is to notice that QProgressBar is  similar to Qt 4’s QAbstractSpinBox class and its subclasses, QSpinBox,  QSlider and QDial. The solution? Replace progress and totalSteps with  minimum, maximum and value. Add a valueChanged() signal. Add a  setRange() convenience function.</p>
<p>The next observation is that progressString, percentage and  indicator really refer to one thing: the text that is shown on the  progress bar. Usually the text is a percentage, but it can be set to  anything using the setIndicator() function. Here’s the new API:</p>
<div class="code-wrapper"><pre><code class="hljs"></code></pre></div>

<p>`virtual QString text() const; void setTextVisible(bool visible); bool isTextVisible() const; ```</p>
<p>``</p>
<p>By default, the text is a percentage indicator. This can be changed by reimplementing text().</p>
<p>The setCenterIndicator() and setIndicatorFollowsStyle() functions in the Qt 3 API are two functions that influence alignment. They can  advantageously be replaced by one function, setAlignment():</p>
<div class="code-wrapper"><pre><code class="hljs"></code></pre></div>

<p>`void setAlignment(Qt::Alignment alignment); ```</p>
<p>``</p>
<p>If the programmer doesn’t call setAlignment(), the alignment is  chosen based on the style. For Motif-based styles, the text is shown  centered; for other styles, it is shown on the right hand side.</p>
<p>Here’s the improved QProgressBar API:</p>
<div class="code-wrapper"><pre><code class="hljs"></code></pre></div>

<p>`class QProgressBar : public QWidget { … public: void setMinimum(int minimum); int minimum() const; void setMaximum(int maximum); int maximum() const; void setRange(int minimum, int maximum); int value() const; <code>virtual QString text() const; void setTextVisible(bool visible); bool isTextVisible() const; Qt::Alignment alignment() const; void setAlignment(Qt::Alignment alignment); </code>public slots: void reset(); void setValue(int value); ``signals: void valueChanged(int value); … }; ```</p>
<p>``</p>
<h3><span id="qabstractprintdialog-amp-qabstractpagesizedialog">QAbstractPrintDialog &amp; QAbstractPageSizeDialog</span><a href="#qabstractprintdialog-amp-qabstractpagesizedialog" class="header-anchor">#</a></h3><p>Qt 4.0 saw the apparition of two classes QAbstractPrintDialog and  QAbstractPageSizeDialog that served as base classes for QPrintDialog and QPageSizeDialog. This served no purpose at all, since none of Qt’s APIs take a QAbstractPrint- or -PageSizeDialog pointer as an argument and  perform some operation on it. Using qdoc trickery, we’ve hidden them,  but they’re the prototypical examples of needless abstract classes.</p>
<p>This is not to say <em>good</em> abstraction is wrong, and indeed  QPrintDialog probably should have a factory or some other mechanism for  changing it- as evidenced by the #ifdef QTOPIA_PRINTDIALOG in its  declaration.</p>
<h3><span id="qabstractitemmodel">QAbstractItemModel</span><a href="#qabstractitemmodel" class="header-anchor">#</a></h3><p>The details of the problems with model/view in Qt 4 are documented well  elsewhere, but an important generalization is that “QAbstractFoo” should not just be the union of all possible subclasses you can think of at  the time of writing. Such “union of all things” base classes are almost  never a good solution. QAbstractItemModel commits this error - it is  really just QTreeOfTablesModel, with the consequently complicated API  that causes… and which is then <em>inherited by all the nicer subclasses</em>,</p>
<p>Just adding abstraction does not make an API better automatically.</p>
<h3><span id="qlayoutiterator-amp-qglayoutiterator">QLayoutIterator &amp; QGLayoutIterator</span><a href="#qlayoutiterator-amp-qglayoutiterator" class="header-anchor">#</a></h3><p>In Qt 3, creating a custom layout involved subclassing both QLayout and  QGLayoutIterator (“G” stands for generic). A QGLayoutIterator subclass  instance pointer was wrapped in a QLayoutIterator, which users could use like any other iterator class. QLayoutIterator made it possible to  write code like this:</p>
<div class="code-wrapper"><pre><code class="hljs"></code></pre></div>

<p>`QLayoutIterator it = layout()-&gt;iterator(); QLayoutItem **child; while ((child = it.current()) != 0) {    if (child-&gt;widget() == myWidget) {        it.takeCurrent();        return;   }   ++it; ```</p>
<div class="code-wrapper"><pre><code class="hljs">}</code></pre></div>

<p>In Qt 4, we killed QGLayoutIterator classes (and their internal  subclasses for box and grid layouts) and instead asked the QLayout  subclasses to reimplement itemAt(), takeAt(), and count().</p>
<h3><span id="qimagesink">QImageSink</span><a href="#qimagesink" class="header-anchor">#</a></h3><p>Qt 3 had a whole set of classes that allowed images to be incrementally  read and passed to an animation - the  QImageSource/Sink/QASyncIO/QASyncImageIO classes. Since all these were  ever used for was animated QLabels, it was total overkill.</p>
<p>The lesson is not to add abstraction to aide some very vague  future possibility. Keep it simple. When those future things come, it  will be a lot easier to factor them into a simple system than into a  complex one.</p>
<h3><span id="other-qt3-vs-qt4">other Qt3 vs. Qt4?</span><a href="#other-qt3-vs-qt4" class="header-anchor">#</a></h3><h3><span id="qwidget-setwindowmodified-bool">QWidget::setWindowModified(bool)</span><a href="#qwidget-setwindowmodified-bool" class="header-anchor">#</a></h3><h3><span id="q3url-vs-qurl">Q3Url vs. QUrl</span><a href="#q3url-vs-qurl" class="header-anchor">#</a></h3><h3><span id="q3textedit-vs-qtextedit">Q3TextEdit vs. QTextEdit</span><a href="#q3textedit-vs-qtextedit" class="header-anchor">#</a></h3><p>How all those virtual functions went a-goner…</p>
<h3><span id="qt-s-clipping-story-naming-of-clipping-fns">Qt’s Clipping Story (naming of clipping fns)</span><a href="#qt-s-clipping-story-naming-of-clipping-fns" class="header-anchor">#</a></h3><p>When you set the clip rect, you actually set a region (should be setClipRegion(QRect) instead of setClipRect()).</p>
<p>(on the right, how it should have been…)</p>

            </div>
            <hr>
            <div>
              <div class="post-metas mb-3">
                
                
                  <div class="post-meta">
                    <i class="iconfont icon-tags"></i>
                    
                      <a class="hover-with-bg" href="/tags/API%E8%AE%BE%E8%AE%A1%E8%A7%84%E8%8C%83/">API设计规范</a>
                    
                  </div>
                
              </div>
              
                <p class="note note-warning">
                  
                    本博客所有文章除特别声明外，均采用 <a target="_blank" href="https://creativecommons.org/licenses/by-sa/4.0/deed.zh" rel="nofollow noopener noopener">CC BY-SA 4.0 协议</a> ，转载请注明出处！
                  
                </p>
              
              
                <div class="post-prevnext">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/2022/03/02/QtDocumentCN/Src/A/QAction/QAction/">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">QAction类</span>
                        <span class="visible-mobile">上一篇</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2022/03/01/QtDocumentCN/Src/A/API_Design_Principles/API_Design_Principles/">
                        <span class="hidden-mobile">API_Design_Principles</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
              <!-- Comments -->
              <article class="comments" id="comments" lazyload>
                
                  
                
                
  <div id="lv-container" data-id="city" data-uid="MTAyMC81NTMzMi8zMTc5OQ==">
    <script type="text/javascript">
      Fluid.utils.loadComments('#lv-container', function() {
        Fluid.utils.createScript('https://cdn-city.livere.com/js/embed.dist.js');
      });
    </script>
    <noscript>Please enable JavaScript to view the comments</noscript>
  </div>


              </article>
            
          </article>
        </div>
      </div>
    </div>
    
      <div class="d-none d-lg-block col-lg-2 toc-container" id="toc-ctn">
        <div id="toc">
  <p class="toc-header"><i class="iconfont icon-list"></i>&nbsp;目录</p>
  <div class="toc-body" id="toc-body"></div>
</div>

      </div>
    
  </div>
</div>

<!-- Custom -->


    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v"
                 for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>
    

    
  </main>

  <footer class="text-center mt-5 py-3">
  <div class="footer-content">
     <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> 
  </div>
  

  

  
</footer>


  <!-- SCRIPTS -->
  
  <script  src="https://cdn.jsdelivr.net/npm/nprogress@0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/nprogress@0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js" ></script>
<script  src="https://cdn.jsdelivr.net/npm/bootstrap@4/dist/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>

<!-- Plugins -->


  <script  src="/js/local-search.js" ></script>



  
    <script  src="/js/img-lazyload.js" ></script>
  



  



  
    <script  src="https://cdn.jsdelivr.net/npm/tocbot@4/dist/tocbot.min.js" ></script>
  
  
    <script  src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3/dist/jquery.fancybox.min.js" ></script>
  
  
    <script  src="https://cdn.jsdelivr.net/npm/anchor-js@4/anchor.min.js" ></script>
  
  
    <script defer src="https://cdn.jsdelivr.net/npm/clipboard@2/dist/clipboard.min.js" ></script>
  






  <script  src="https://cdn.jsdelivr.net/npm/typed.js@2/lib/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var title = document.getElementById('subtitle').title;
      
        typing(title);
      
    })(window, document);
  </script>















<!-- 主题的启动项 保持在最底部 -->
<script  src="/js/boot.js" ></script>


</body>
</html>
