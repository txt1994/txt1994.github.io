

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=auto>



<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/logo.jpg">
  <link rel="icon" href="/img/logo.jpg">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
    <meta http-equiv="Content-Security-Policy" content="upgrade-insecure-requests">
  
  <meta name="theme-color" content="#6aa84f">
  <meta name="author" content="John Doe">
  <meta name="keywords" content="">
  
    <meta name="description" content="QFuture Class 公共类型 公共函数 详细描述 成员类型文档 QFuture::ConstIterator   成员函数文档 QFuture::QFuture(const QFuture &amp;other) QFuture::QFuture() QFuture QFuture::~QFuture() template &lt;typename U, typename&gt;">
<meta property="og:type" content="article">
<meta property="og:title" content="QFuture类">
<meta property="og:url" content="https://txt1994.github.io/2022/03/02/QtDocumentCN/Src/F/QFuture/QFuture/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:description" content="QFuture Class 公共类型 公共函数 详细描述 成员类型文档 QFuture::ConstIterator   成员函数文档 QFuture::QFuture(const QFuture &amp;other) QFuture::QFuture() QFuture QFuture::~QFuture() template &lt;typename U, typename&gt;">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2022-03-02T06:21:47.000Z">
<meta property="article:modified_time" content="2022-03-18T16:40:00.710Z">
<meta property="article:author" content="John Doe">
<meta property="article:tag" content="F">
<meta name="twitter:card" content="summary_large_image">
  
  
  <title>QFuture类 - Hexo</title>

  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4/dist/css/bootstrap.min.css" />


  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/github-markdown-css@4/github-markdown.min.css" />
  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/hint.css@2/hint.min.css" />

  
    
    
      
      <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@10/styles/github-gist.min.css" />
    
  

  
    <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3/dist/jquery.fancybox.min.css" />
  


<!-- 主题依赖的图标库，不要自行修改 -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_ba1fz6golrf.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_lbnruvf0jn.css">


<link  rel="stylesheet" href="/css/main.css" />

<!-- 自定义样式保持在最底部 -->

  
<link rel="stylesheet" href="/css/style.css">



  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    var CONFIG = {"hostname":"txt1994.github.io","root":"/","version":"1.8.14","typing":{"enable":true,"typeSpeed":70,"cursorChar":"_","loop":false},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"right","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"copy_btn":true,"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":false,"baidu":null,"google":null,"gtag":null,"tencent":{"sid":null,"cid":null},"woyaola":null,"cnzz":null,"leancloud":{"app_id":null,"app_key":null,"server_url":null,"path":"window.location.pathname","ignore_local":false}},"search_path":"/local-search.xml"};
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
<meta name="generator" content="Hexo 6.1.0">
<style>.github-emoji { position: relative; display: inline-block; width: 1.2em; min-height: 1.2em; overflow: hidden; vertical-align: top; color: transparent; }  .github-emoji > span { position: relative; z-index: 10; }  .github-emoji img, .github-emoji .fancybox { margin: 0 !important; padding: 0 !important; border: none !important; outline: none !important; text-decoration: none !important; user-select: none !important; cursor: auto !important; }  .github-emoji img { height: 1.2em !important; width: 1.2em !important; position: absolute !important; left: 50% !important; top: 50% !important; transform: translate(-50%, -50%) !important; user-select: none !important; cursor: auto !important; } .github-emoji-fallback { color: inherit; } .github-emoji-fallback img { opacity: 0 !important; }</style>
</head>


<body>
  <header style="height: 70vh;">
    <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/">
      <strong>txt1994s</strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/">
                <i class="iconfont icon-home-fill"></i>
                首页
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/">
                <i class="iconfont icon-archive-fill"></i>
                归档
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/">
                <i class="iconfont icon-tags-fill"></i>
                标签
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/">
                <i class="iconfont icon-user-fill"></i>
                关于
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/links/">
                <i class="iconfont icon-link-fill"></i>
                友联
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              &nbsp;<i class="iconfont icon-search"></i>&nbsp;
            </a>
          </li>
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">&nbsp;<i
                class="iconfont icon-dark" id="color-toggle-icon"></i>&nbsp;</a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

    <div class="banner" id="banner" parallax=true
         style="background: url('/img/default.png') no-repeat center center;
           background-size: cover;">
      <div class="full-bg-img">
        <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
          <div class="page-header text-center fade-in-up">
            <span class="h2" id="subtitle" title="QFuture类">
              
            </span>

            
              <div class="mt-3">
  
  
    <span class="post-meta">
      <i class="iconfont icon-date-fill" aria-hidden="true"></i>
      <time datetime="2022-03-02 14:21" pubdate>
        2022年3月2日 下午
      </time>
    </span>
  
</div>

<div class="mt-1">
  
    <span class="post-meta mr-2">
      <i class="iconfont icon-chart"></i>
      20k 字
    </span>
  

  
    <span class="post-meta mr-2">
      <i class="iconfont icon-clock-fill"></i>
      
      
      166 分钟
    </span>
  

  
  
</div>

            
          </div>

          
        </div>
      </div>
    </div>
  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="d-none d-lg-block col-lg-2"></div>
    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div class="py-5" id="board">
          <article class="post-content mx-auto">
            <!-- SEO header -->
            <h1 style="display: none">QFuture类</h1>
            
              <p class="note note-info">
                
                  本文最后更新于：2022年3月19日 凌晨
                
              </p>
            
            <div class="markdown-body">
              <div class="toc">

<!-- toc -->

<ul>
<li><a href="#qfuture-class">QFuture Class</a><ul>
<li><a href="#gong-gong-lei-xing">公共类型</a></li>
<li><a href="#gong-gong-han-shu">公共函数</a></li>
<li><a href="#xiang-xi-miao-shu">详细描述</a></li>
<li><a href="#cheng-yuan-lei-xing-wen-dang">成员类型文档</a><ul>
<li><a href="#qfuture-constiterator">QFuture::ConstIterator</a></li>
</ul>
</li>
<li><a href="#cheng-yuan-han-shu-wen-dang">成员函数文档</a><ul>
<li><a href="#qfuture-qfuture-const-qfuture-qfuture-t-other">QFuture::QFuture(const </a><a href="#QFuture">QFuture</a><t> &amp;<em>other</em>)</t></li>
<li><a href="#qfuture-qfuture">QFuture::QFuture()</a></li>
<li><a href="#qfuture-qfuture-t-qfuture-operator-const-qfuture-qfuture-t-other">QFuture</a></li>
<li><a href="#qfuture-qfuture">QFuture::~QFuture()</a></li>
<li><a href="#template-typename-u-typename-qfuture-const-iterator-https-doc-qt-io-qt-6-qfuture-const-iterator-html-qfuture-begin-const">template &lt;typename U, typename&gt; </a><a target="_blank" rel="noopener" href="https://doc.qt.io/qt-6/qfuture-const-iterator.html">QFuture::const_iterator</a> QFuture::begin() const</li>
<li><a href="#void-qfuture-cancel">void QFuture::cancel()</a></li>
<li><a href="#template-typename-u-typename-qfuture-const-iterator-https-doc-qt-io-qt-6-qfuture-const-iterator-html-qfuture-constbegin-const">template &lt;typename U, typename&gt; </a><a target="_blank" rel="noopener" href="https://doc.qt.io/qt-6/qfuture-const-iterator.html">QFuture::const_iterator</a> QFuture::constBegin() const</li>
<li><a href="#template-typename-u-typename-qfuture-const-iterator-https-doc-qt-io-qt-6-qfuture-const-iterator-html-qfuture-constend-const">template &lt;typename U, typename&gt; </a><a target="_blank" rel="noopener" href="https://doc.qt.io/qt-6/qfuture-const-iterator.html">QFuture::const_iterator</a> QFuture::constEnd() const</li>
<li><a href="#template-typename-u-typename-qfuture-const-iterator-https-doc-qt-io-qt-6-qfuture-const-iterator-html-qfuture-end-const">template &lt;typename U, typename&gt; </a><a target="_blank" rel="noopener" href="https://doc.qt.io/qt-6/qfuture-const-iterator.html">QFuture::const_iterator</a> QFuture::end() const</li>
<li><a href="#bool-qfuture-iscanceled-const">bool QFuture::isCanceled() const</a></li>
<li><a href="#bool-qfuture-isfinished-const">bool QFuture::isFinished() const</a></li>
<li><a href="#template-typename-u-typename-bool-qfuture-isresultreadyat-int-index-const">template &lt;typename U, typename&gt; bool QFuture::isResultReadyAt(int <em>index</em>) const</a></li>
<li><a href="#bool-qfuture-isrunning-const">bool QFuture::isRunning() const</a></li>
<li><a href="#bool-qfuture-isstarted-const">bool QFuture::isStarted() const</a></li>
<li><a href="#since-6-0-bool-qfuture-issuspended-const"><code>[since 6.0]</code>bool QFuture::isSuspended() const</a></li>
<li><a href="#since-6-0-bool-qfuture-issuspending-const"><code>[since 6.0]</code>bool QFuture::isSuspending() const</a></li>
<li><a href="#since-6-0-bool-qfuture-isvalid-const"><code>[since 6.0]</code>bool QFuture::isValid() const</a></li>
<li><a href="#since-6-0-template-typename-function-typename-qfuture-qfuture-t-qfuture-oncanceled-function-handler"><code>[since 6.0]</code>template &lt;typename Function, typename&gt; </a><a href="#QFuture">QFuture</a><t> QFuture::onCanceled(Function &amp;&amp;<em>handler</em>)</t></li>
<li><a href="#since-6-1-template-typename-function-typename-qfuture-qfuture-t-qfuture-oncanceled-qobject-https-doc-qt-io-qt-6-qobject-html-context-function-handler"><code>[since 6.1]</code>template &lt;typename Function, typename&gt; </a><a href="#QFuture">QFuture</a><t> QFuture::onCanceled(<a target="_blank" rel="noopener" href="https://doc.qt.io/qt-6/qobject.html">QObject</a> *<em>context</em>, Function &amp;&amp;<em>handler</em>)</t></li>
<li><a href="#since-6-0-template-typename-function-typename-qfuture-qfuture-t-qfuture-onfailed-function-handler"><code>[since 6.0]</code>template &lt;typename Function, typename&gt; </a><a href="#QFuture">QFuture</a><t> QFuture::onFailed(Function &amp;&amp;<em>handler</em>)</t></li>
<li><a href="#since-6-1-template-typename-function-typename-qfuture-qfuture-t-qfuture-onfailed-qobject-https-doc-qt-io-qt-6-qobject-html-context-function-handler"><code>[since 6.1]</code>template &lt;typename Function, typename&gt; </a><a href="#QFuture">QFuture</a><t> QFuture::onFailed(<a target="_blank" rel="noopener" href="https://doc.qt.io/qt-6/qobject.html">QObject</a> *<em>context</em>, Function &amp;&amp;<em>handler</em>)</t></li>
<li><a href="#int-qfuture-progressmaximum-const">int QFuture::progressMaximum() const</a></li>
<li><a href="#int-qfuture-progressminimum-const">int QFuture::progressMinimum() const</a></li>
<li><a href="#qstring-https-doc-qt-io-qt-6-qstring-html-qfuture-progresstext-const">QString</a></li>
<li><a href="#int-qfuture-progressvalue-const">int QFuture::progressValue() const</a></li>
<li><a href="#template-typename-u-typename-t-qfuture-result-const">template &lt;typename U, typename&gt; T QFuture::result() const</a></li>
<li><a href="#template-typename-u-typename-t-qfuture-resultat-int-index-const">template &lt;typename U, typename&gt; T QFuture::resultAt(int <em>index</em>) const</a></li>
<li><a href="#int-qfuture-resultcount-const">int QFuture::resultCount() const</a></li>
<li><a href="#template-typename-u-typename-qlist-https-doc-qt-io-qt-6-qlist-html-t-qfuture-results-const">template &lt;typename U, typename&gt; </a><a target="_blank" rel="noopener" href="https://doc.qt.io/qt-6/qlist.html">QList</a><t> QFuture::results() const</t></li>
<li><a href="#void-qfuture-resume">void QFuture::resume()</a></li>
<li><a href="#since-6-0-void-qfuture-setsuspended-bool-suspend"><code>[since 6.0]</code>void QFuture::setSuspended(bool <em>suspend</em>)</a></li>
<li><a href="#since-6-0-void-qfuture-suspend"><code>[since 6.0]</code>void QFuture::suspend()</a></li>
<li><a href="#since-6-0-template-typename-u-typename-t-qfuture-takeresult"><code>[since 6.0]</code>template &lt;typename U, typename&gt; T QFuture::takeResult()</a></li>
<li><a href="#since-6-0-template-typename-function-qfuture-qfuture-resulttype-function-qfuture-then-function-function"><code>[since 6.0]</code>template <typename function> </typename></a><a href="#QFuture">QFuture</a>&lt;ResultType<function> &gt; QFuture::then(Function &amp;&amp;<em>function</em>)</function></li>
<li><a href="#since-6-0-template-typename-function-qfuture-qfuture-resulttype-function-qfuture-then-qtfuture-launch-https-doc-qt-io-qt-6-qtfuture-html-launch-enum-policy-function-function"><code>[since 6.0]</code>template <typename function> </typename></a><a href="#QFuture">QFuture</a>&lt;ResultType<function> &gt; QFuture::then(<a target="_blank" rel="noopener" href="https://doc.qt.io/qt-6/qtfuture.html#Launch-enum">QtFuture::Launch</a> <em>policy</em>, Function &amp;&amp;<em>function</em>)</function></li>
<li><a href="#since-6-0-template-typename-function-qfuture-qfuture-resulttype-function-qfuture-then-qthreadpool-https-doc-qt-io-qt-6-qthreadpool-html-pool-function-function"><code>[since 6.0]</code>template <typename function> </typename></a><a href="#QFuture">QFuture</a>&lt;ResultType<function> &gt; QFuture::then(<a target="_blank" rel="noopener" href="https://doc.qt.io/qt-6/qthreadpool.html">QThreadPool</a> *<em>pool</em>, Function &amp;&amp;<em>function</em>)</function></li>
<li><a href="#since-6-1-template-typename-function-qfuture-qfuture-resulttype-function-qfuture-then-qobject-https-doc-qt-io-qt-6-qobject-html-context-function-function"><code>[since 6.1]</code>template <typename function> </typename></a><a href="#QFuture">QFuture</a>&lt;ResultType<function> &gt; QFuture::then(<a target="_blank" rel="noopener" href="https://doc.qt.io/qt-6/qobject.html">QObject</a> *<em>context</em>, Function &amp;&amp;<em>function</em>)</function></li>
<li><a href="#since-6-0-void-qfuture-togglesuspended"><code>[since 6.0]</code>void QFuture::toggleSuspended()</a></li>
<li><a href="#void-qfuture-waitforfinished">void QFuture::waitForFinished()</a></li>
</ul>
</li>
</ul>
</li>
</ul>
<!-- tocstop -->

</div>
# QFuture Class

<p>template <typename t> class QFuture</typename></p>
<p>QFuture类表示一个异步计算的结果。 <a href="#%E8%AF%A6%E7%BB%86%E6%8F%8F%E8%BF%B0">More…</a></p>
<table>
<thead>
<tr>
<th>Header:</th>
<th>#include <qfuture></qfuture></th>
</tr>
</thead>
<tbody><tr>
<td>CMake:</td>
<td>find_package(Qt6 COMPONENTS Core REQUIRED) target_link_libraries(mytarget PRIVATE Qt6::Core)</td>
</tr>
<tr>
<td>qmake:</td>
<td>QT += core</td>
</tr>
</tbody></table>
<ul>
<li><a target="_blank" rel="noopener" href="https://doc.qt.io/qt-6/qfuture-members.html">List of all members, including inherited members</a></li>
<li><a target="_blank" rel="noopener" href="https://doc.qt.io/qt-6/qfuture-obsolete.html">Deprecated members</a></li>
</ul>
<p><strong>注意：</strong>这个类中的所有函数都是<a target="_blank" rel="noopener" href="https://doc.qt.io/qt-6/threads-reentrancy.html">线程安全的</a>，但有以下例外。</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://doc.qt.io/qt-6/qfuture-const-iterator.html">const_iterator</a></li>
</ul>
<h2><span id="gong-gong-lei-xing">公共类型</span><a href="#gong-gong-lei-xing" class="header-anchor">#</a></h2><table>
<thead>
<tr>
<th>class</th>
<th><strong><a target="_blank" rel="noopener" href="https://doc.qt.io/qt-6/qfuture-const-iterator.html">const_iterator</a></strong></th>
</tr>
</thead>
<tbody><tr>
<td></td>
<td><strong><a href="#ConstIterator-typedef">ConstIterator</a></strong></td>
</tr>
</tbody></table>
<h2><span id="gong-gong-han-shu">公共函数</span><a href="#gong-gong-han-shu" class="header-anchor">#</a></h2><table>
<thead>
<tr>
<th></th>
<th><strong><a href="#QFuture-4">QFuture</a></strong>(const QFuture<t> &amp;<em>other</em>)</t></th>
</tr>
</thead>
<tbody><tr>
<td></td>
<td><strong><a href="#QFuture">QFuture</a></strong>()</td>
</tr>
<tr>
<td>QFuture<t> &amp;</t></td>
<td><strong><a href="#operator-eq-1">operator=</a></strong>(const QFuture<t> &amp;<em>other</em>)</t></td>
</tr>
<tr>
<td></td>
<td><strong><a href="#dtor.QFuture">~QFuture</a></strong>()</td>
</tr>
<tr>
<td>QFuture::const_iterator</td>
<td><strong><a href="#begin">begin</a></strong>() const</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="#cancel">cancel</a></strong>()</td>
</tr>
<tr>
<td>QFuture::const_iterator</td>
<td><strong><a href="#constBegin">constBegin</a></strong>() const</td>
</tr>
<tr>
<td>QFuture::const_iterator</td>
<td><strong><a href="#constEnd">constEnd</a></strong>() const</td>
</tr>
<tr>
<td>QFuture::const_iterator</td>
<td><strong><a href="#end">end</a></strong>() const</td>
</tr>
<tr>
<td>bool</td>
<td><strong><a href="#isCanceled">isCanceled</a></strong>() const</td>
</tr>
<tr>
<td>bool</td>
<td><strong><a href="#isFinished">isFinished</a></strong>() const</td>
</tr>
<tr>
<td>bool</td>
<td><strong><a href="#isResultReadyAt">isResultReadyAt</a></strong>(int <em>index</em>) const</td>
</tr>
<tr>
<td>bool</td>
<td><strong><a href="#isRunning">isRunning</a></strong>() const</td>
</tr>
<tr>
<td>bool</td>
<td><strong><a href="#isStarted">isStarted</a></strong>() const</td>
</tr>
<tr>
<td>bool</td>
<td><strong><a href="#isSuspended">isSuspended</a></strong>() const</td>
</tr>
<tr>
<td>bool</td>
<td><strong><a href="#isSuspending">isSuspending</a></strong>() const</td>
</tr>
<tr>
<td>bool</td>
<td><strong><a href="#isValid">isValid</a></strong>() const</td>
</tr>
<tr>
<td>QFuture<t></t></td>
<td><strong><a href="#onCanceled">onCanceled</a></strong>(Function &amp;&amp;<em>handler</em>)</td>
</tr>
<tr>
<td>QFuture<t></t></td>
<td><strong><a href="#onCanceled-1">onCanceled</a></strong>(QObject *<em>context</em>, Function &amp;&amp;<em>handler</em>)</td>
</tr>
<tr>
<td>QFuture<t></t></td>
<td><strong><a href="#onFailed">onFailed</a></strong>(Function &amp;&amp;<em>handler</em>)</td>
</tr>
<tr>
<td>QFuture<t></t></td>
<td><strong><a href="#onFailed-1">onFailed</a></strong>(QObject *<em>context</em>, Function &amp;&amp;<em>handler</em>)</td>
</tr>
<tr>
<td>int</td>
<td><strong><a href="#progressMaximum">progressMaximum</a></strong>() const</td>
</tr>
<tr>
<td>int</td>
<td><strong><a href="#progressMinimum">progressMinimum</a></strong>() const</td>
</tr>
<tr>
<td>QString</td>
<td><strong><a href="#progressText">progressText</a></strong>() const</td>
</tr>
<tr>
<td>int</td>
<td><strong><a href="#progressValue">progressValue</a></strong>() const</td>
</tr>
<tr>
<td>T</td>
<td><strong><a href="#result">result</a></strong>() const</td>
</tr>
<tr>
<td>T</td>
<td><strong><a href="#resultAt">resultAt</a></strong>(int <em>index</em>) const</td>
</tr>
<tr>
<td>int</td>
<td><strong><a href="#resultCount">resultCount</a></strong>() const</td>
</tr>
<tr>
<td>QList<t></t></td>
<td><strong><a href="#results">results</a></strong>() const</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="#resume">resume</a></strong>()</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="#setSuspended">setSuspended</a></strong>(bool <em>suspend</em>)</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="#suspend">suspend</a></strong>()</td>
</tr>
<tr>
<td>T</td>
<td><strong><a href="#takeResult">takeResult</a></strong>()</td>
</tr>
<tr>
<td>QFuture&lt;ResultType<function> &gt;</function></td>
<td><strong><a href="#then">then</a></strong>(Function &amp;&amp;<em>function</em>)</td>
</tr>
<tr>
<td>QFuture&lt;ResultType<function> &gt;</function></td>
<td><strong><a href="#then-1">then</a></strong>(QtFuture::Launch <em>policy</em>, Function &amp;&amp;<em>function</em>)</td>
</tr>
<tr>
<td>QFuture&lt;ResultType<function> &gt;</function></td>
<td><strong><a href="#then-2">then</a></strong>(QThreadPool *<em>pool</em>, Function &amp;&amp;<em>function</em>)</td>
</tr>
<tr>
<td>QFuture&lt;ResultType<function> &gt;</function></td>
<td><strong><a href="#then-3">then</a></strong>(QObject *<em>context</em>, Function &amp;&amp;<em>function</em>)</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="#toggleSuspended">toggleSuspended</a></strong>()</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="#waitForFinished">waitForFinished</a></strong>()</td>
</tr>
</tbody></table>
<h2><span id="xiang-xi-miao-shu">详细描述</span><a href="#xiang-xi-miao-shu" class="header-anchor">#</a></h2><p>QFuture允许线程对一个或多个结果进行同步，这些结果将在稍后的时间点上准备好。结果可以是任何具有默认、复制和可能的移动构造函数的类型。如果在调用<a href="#result">result</a>(), <a href="#resultAt">resultAt</a>(), <a href="#results">result</a>()和<a href="#takeResult">takeResult</a>()函数时，一个结果还不可用，QFuture将等待结果变得可用为止。你可以使用<a href="#isResultReadyAt">isResultReadyAt</a>()函数来确定一个结果是否就绪。对于报告不止一个结果的QFuture对象，<a href="#resultCount">resultCount</a>()函数返回连续结果的数量。这意味着，从0到<a href="#resultCount">resultCount</a>()的结果中进行迭代总是安全的。<a href="#takeResult">takeResult</a>()会使一个future失效，任何随后试图访问future的结果或结果的行为都会导致未定义行为。<a href="#isValid">isValid</a>()告诉你是否可以访问结果。</p>
<p>QFuture提供了一个<a target="_blank" rel="noopener" href="https://doc.qt.io/qt-6/java-style-iterators.html#java-style-iterators">Java风格的迭代器</a> (<a target="_blank" rel="noopener" href="https://doc.qt.io/qt-6/qfutureiterator.html">QFutureIterator</a>)和一个<a target="_blank" rel="noopener" href="https://doc.qt.io/qt-6/containers.html#stl-style-iterators">STL风格的迭代器</a> (<a target="_blank" rel="noopener" href="https://doc.qt.io/qt-6/qfuture-const-iterator.html">QFuture::const_iterator</a> 。） 使用这些迭代器是在<code>fulture</code>访问结果的另一种方式。</p>
<p>如果一个异步计算的结果需要传递给另一个，QFuture提供了一种方便的方式，即使用<a href="#then">then</a>()将多个顺序的计算连锁起来。<a href="#onCanceled">onCanceled</a>()可用于添加一个处理程序，以便在QFuture被取消时被调用。此外，<a href="#onFailed">onFailed</a>()可以用来处理链中发生的任何失败。请注意，QFuture的错误处理是依靠异常的。如果使用异常不是一种选择，你仍然可以指示QFuture的错误状态，通过使错误类型成为QFuture类型的一部分。例如，你可以使用std::variant, std::any或类似的方法来保持结果或失败，或者制作你的自定义类型。</p>
<p>下面的例子演示了如何在不使用异常的情况下进行错误处理。假设我们想发送一个网络请求，从一个网络位置获得一个大文件。然后我们想把它写到文件系统中，并在成功的情况下返回其位置。这两个操作都可能以不同的错误失败。所以，我们使用<code>std::variant</code>来保持结果或错误:</p>
<div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">using</span> NetworkReply = std::variant&lt;QByteArray, QNetworkReply::NetworkError&gt;;

<span class="hljs-keyword">enum class</span> <span class="hljs-title class_">IOError</span> { FailedToRead, FailedToWrite };
<span class="hljs-keyword">using</span> IOResult = std::variant&lt;QString, IOError&gt;;</code></pre></div>

<p>而我们使用<a href="#then">then</a>()将这两个操作结合起来:</p>
<div class="code-wrapper"><pre><code class="hljs c++">QFuture&lt;IOResult&gt; future = QtConcurrent::<span class="hljs-built_in">run</span>([url] {
        ...
        <span class="hljs-keyword">return</span> <span class="hljs-built_in">NetworkReply</span>(QNetworkReply::TimeoutError);
}).<span class="hljs-built_in">then</span>([](NetworkReply reply) {
    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">auto</span> error = std::<span class="hljs-built_in">get_if</span>&lt;QNetworkReply::NetworkError&gt;(&amp;reply))
        <span class="hljs-keyword">return</span> <span class="hljs-built_in">IOResult</span>(IOError::FailedToRead);

    <span class="hljs-keyword">auto</span> data = std::<span class="hljs-built_in">get_if</span>&lt;QByteArray&gt;(&amp;reply);
    <span class="hljs-comment">// try to write *data and return IOError::FailedToWrite on failure</span>
    ...
});

<span class="hljs-keyword">auto</span> result = future.<span class="hljs-built_in">result</span>();
<span class="hljs-keyword">if</span> (<span class="hljs-keyword">auto</span> filePath = std::<span class="hljs-built_in">get_if</span>&lt;QString&gt;(&amp;result)) {
    <span class="hljs-comment">// do something with *filePath</span>
<span class="hljs-keyword">else</span>
    <span class="hljs-comment">// process the error</span></code></pre></div>

<p>可以按任何顺序连锁多个延续和处理程序。比如说:</p>
<div class="code-wrapper"><pre><code class="hljs c++">QFuture&lt;<span class="hljs-type">int</span>&gt; testFuture = ...;
<span class="hljs-keyword">auto</span> resultFuture = testFuture.<span class="hljs-built_in">then</span>([](<span class="hljs-type">int</span> res) {
    <span class="hljs-comment">// Block 1</span>
}).<span class="hljs-built_in">onCanceled</span>([] {
    <span class="hljs-comment">// Block 2</span>
}).<span class="hljs-built_in">onFailed</span>([] {
    <span class="hljs-comment">// Block 3</span>
}).<span class="hljs-built_in">then</span>([] {
    <span class="hljs-comment">// Block 4</span>
}).<span class="hljs-built_in">onFailed</span>([] {
    <span class="hljs-comment">// Block 5</span>
}).<span class="hljs-built_in">onCanceled</span>([] {
    <span class="hljs-comment">// Block 6</span>
});</code></pre></div>

<p>根据<code>testFuture</code>的状态（取消、有异常或有结果），下一个<a href="#onCanceled">onCanceled</a>(), <a href="#onFailed">onFailed</a>() 或 <a href="#then">then</a>() 将被调用。因此，如果<code>testFuture</code>被成功实现，<code>Block 1</code>将被调用。如果它也成功了，下一个<a href="#then">then</a>()(<code>Block 4</code>)将被调用。如果 <code>testFuture</code>被取消或因异常而失败，<code>Block 2</code>或 <code>Block 3</code>将被分别调用。之后，下一个<a href="#then">then</a>()将被调用，故事重复进行。</p>
<p><strong>注意：</strong>如果<code>Block 2</code>被调用并抛出一个异常，下面的<a href="#onFailed">onFailed</a>()（<code>Block 3</code>）将处理它。如果<a href="#onFailed">onFailed</a>()和<a href="#onCanceled">onCanceled</a>()的顺序颠倒了，那么异常状态将传播到下一个延续，最终将在<code>Block 5</code>中被捕获。</p>
<p>In the next example the first <a href="#onCanceled">onCanceled</a>() (<code>Block 2</code>) is removed:</p>
<div class="code-wrapper"><pre><code class="hljs c++">QFuture&lt;<span class="hljs-type">int</span>&gt; testFuture = ...;
<span class="hljs-keyword">auto</span> resultFuture = testFuture.<span class="hljs-built_in">then</span>([](<span class="hljs-type">int</span> res) {
    <span class="hljs-comment">// Block 1</span>
}).<span class="hljs-built_in">onFailed</span>([] {
    <span class="hljs-comment">// Block 3</span>
}).<span class="hljs-built_in">then</span>([] {
    <span class="hljs-comment">// Block 4</span>
}).<span class="hljs-built_in">onFailed</span>([] {
    <span class="hljs-comment">// Block 5</span>
}).<span class="hljs-built_in">onCanceled</span>([] {
    <span class="hljs-comment">// Block 6</span>
});</code></pre></div>

<p>如果<code>testFuture</code>被取消，它的状态会被传播到下一个<a href="#then">then</a>()，它也会被取消。所以在这种情况下，`Block 6’将被调用。</p>
<p>QFuture还提供了与运行中的计算进行交互的方法。例如，计算可以通过<a href="#cancel">cancel</a>()函数被取消。要暂停或恢复计算，请使用<a href="#setSuspended">setSuspended</a>()函数或<a href="#suspend">suspend</a>()、<a href="#resume">resume</a>()或<a href="#toggleSuspended">toggleSuspended</a>()等便利函数之一。请注意，并非所有正在运行的异步计算都可以被取消或暂停。例如，由QtConcurrent::run()返回的<code>fulture</code>不能被取消；但由QtConcurrent::mappedReduced()返回的<code>fulture</code>可以。</p>
<p>进度信息由<a href="#progressValue">progressValue</a>()、<a href="#progressMinimum">progressMinimum</a>()、<a href="#progressMaximum">progressMaximum</a>()和<a href="#progressText">progressText</a>() 函数提供。waitForFinished](#waitForFinished)()函数使调用线程阻塞并等待计算结束，以确保所有结果都可用。</p>
<p>QFuture所代表的计算状态可以使用<a href="#isCanceled">isCanceled</a>()、<a href="#isStarted">isStarted</a>()、<a href="#isFinished">isFinished</a>()、<a href="#isRunning">isRunning</a>()、<a href="#isSuspending">isSuspending</a>()或者<a href="#isSuspended">isSuspended</a> ()函数进行查询。</p>
<p>QFuture<void>被专门化，不包含任何获取结果的函数。任何QFuture<t>也可以被分配或复制到QFuture<void>中。如果只需要状态或进度信息–而不是实际的结果数据，这就很有用。</void></t></void></p>
<p>要使用信号和槽与正在运行的任务交互，请使用<a target="_blank" rel="noopener" href="https://doc.qt.io/qt-6/qfuturewatcher.html">QFutureWatcher</a>。</p>
<p>你也可以使用<a target="_blank" rel="noopener" href="https://doc.qt.io/qt-6/qtfuture.html#connect">QtFuture::connect</a>将信号连接到一个QFuture对象上，当信号被发出时，该对象将被解析。这允许像处理QFuture对象一样处理信号。例如，如果你将它与<a href="#then">then</a>()结合起来，你可以将多个延续附加到一个信号上，这些信号在同一个线程或一个新的线程中被调用。</p>
<p>一个带有数值的准备好的QFuture对象或一个持有异常的QFuture对象可以使用便利函数<a target="_blank" rel="noopener" href="https://doc.qt.io/qt-6/qtfuture.html#makeReadyFuture">QtFuture::makeReadyFuture</a>和<a target="_blank" rel="noopener" href="https://doc.qt.io/qt-6/qtfuture.html#makeExceptionalFuture">QtFuture::makeExceptionalFuture</a>来创建。</p>
<p><strong>注意：</strong>要启动一个计算并将结果存储在QFuture中，请使用<a target="_blank" rel="noopener" href="https://doc.qt.io/qt-6/qpromise.html">QPromise</a>或<a target="_blank" rel="noopener" href="https://doc.qt.io/qt-6/qtconcurrent-index.html">Qt Concurrent</a> 框架中的一个API。</p>
<p><strong>See also</strong> <a target="_blank" rel="noopener" href="https://doc.qt.io/qt-6/qpromise.html">QPromise</a>, <a target="_blank" rel="noopener" href="https://doc.qt.io/qt-6/qtfuture.html#connect">QtFuture::connect</a>(), <a target="_blank" rel="noopener" href="https://doc.qt.io/qt-6/qtfuture.html#makeReadyFuture-1">QtFuture::makeReadyFuture</a>(), <a target="_blank" rel="noopener" href="https://doc.qt.io/qt-6/qtfuture.html#makeExceptionalFuture">QtFuture::makeExceptionalFuture</a>(), <a target="_blank" rel="noopener" href="https://doc.qt.io/qt-6/qfuturewatcher.html">QFutureWatcher</a>, and <a target="_blank" rel="noopener" href="https://doc.qt.io/qt-6/qtconcurrent-index.html">Qt Concurrent</a>.</p>
<h2><span id="cheng-yuan-lei-xing-wen-dang">成员类型文档</span><a href="#cheng-yuan-lei-xing-wen-dang" class="header-anchor">#</a></h2><h3><span id="qfuture-constiterator">QFuture::ConstIterator</span><a href="#qfuture-constiterator" class="header-anchor">#</a></h3><p>Qt风格的<a target="_blank" rel="noopener" href="https://doc.qt.io/qt-6/qfuture-const-iterator.html">QFuture::const_iterator</a>的同义词。</p>
<h2><span id="cheng-yuan-han-shu-wen-dang">成员函数文档</span><a href="#cheng-yuan-han-shu-wen-dang" class="header-anchor">#</a></h2><h3><span id="qfuture-qfuture-const-qfuture-amp-other">QFuture::QFuture(const <t> &amp;<em>other</em>)</t></span><a href="#qfuture-qfuture-const-qfuture-amp-other" class="header-anchor">#</a></h3><p>构建一个<em>other</em>的副本。</p>
<p><strong>See also</strong> <a href="#operator-eq-1">operator=</a>().</p>
<h3><span id="qfuture-qfuture">QFuture::QFuture()</span><a href="#qfuture-qfuture" class="header-anchor">#</a></h3><p>构建一个空的、被取消的<code>fulture</code>。</p>
<h3><span id="qfuture-amp-qfuture-operator-const-qfuture-amp-other"><t> &amp;QFuture::operator=(const <a href="#QFuture">QFuture</a><t> &amp;<em>other</em>)</t></t></span><a href="#qfuture-amp-qfuture-operator-const-qfuture-amp-other" class="header-anchor">#</a></h3><p>将<em>other</em>分配给这个未来，并返回对这个未来的引用。</p>
<h3><span id="qfuture-qfuture">QFuture::~QFuture()</span><a href="#qfuture-qfuture" class="header-anchor">#</a></h3><p>销毁<code>fulture</code>。</p>
<p>请注意，这既没有等待也没有取消异步计算。当你需要确保计算在未来被销毁之前完成时，请使用<a href="#waitForFinished">waitForFinished</a>()或<a target="_blank" rel="noopener" href="https://doc.qt.io/qt-6/qfuturesynchronizer.html">QFutureSynchronizer</a>。</p>
<h3><span id="template-lt-typename-u-typename-gt-qfuture-const-iterator-qfuture-begin-const">template &lt;typename U, typename&gt;  QFuture::begin() const</span><a href="#template-lt-typename-u-typename-gt-qfuture-const-iterator-qfuture-begin-const" class="header-anchor">#</a></h3><p>返回一个const <a target="_blank" rel="noopener" href="https://doc.qt.io/qt-6/containers.html#stl-style-iterators">STL-style iterator</a> 指向未来的第一个结果。</p>
<p><strong>See also</strong> <a href="#constBegin">constBegin</a>() and <a href="#end">end</a>().</p>
<h3><span id="void-qfuture-cancel">void QFuture::cancel()</span><a href="#void-qfuture-cancel" class="header-anchor">#</a></h3><p>取消这个future所代表的异步计算。注意，这个取消是异步的。当你需要同步取消时，在调用cancel()后使用<a href="#waitForFinished">waitForFinished</a>()。</p>
<p>当前可用的结果仍然可以在被取消的<code>fulture</code>中被访问，但新的结果在调用此函数后将<em>not</em>变得可用。任何正在观察这个<code>fulture</code>的<a target="_blank" rel="noopener" href="https://doc.qt.io/qt-6/qfuturewatcher.html">QFutureWatcher</a>对象将不会在取消的<code>fulture</code>上传递进度和结果就绪信号。</p>
<p>请注意，并非所有正在运行的异步计算都可以被取消。例如，由QtConcurrent::run()返回的<code>fulture</code>不能被取消；但由QtConcurrent::mappedReduced()返回的<code>fulture</code>可以。</p>
<h3><span id="template-lt-typename-u-typename-gt-qfuture-const-iterator-qfuture-constbegin-const">template &lt;typename U, typename&gt;  QFuture::constBegin() const</span><a href="#template-lt-typename-u-typename-gt-qfuture-const-iterator-qfuture-constbegin-const" class="header-anchor">#</a></h3><p>返回一个const <a target="_blank" rel="noopener" href="https://doc.qt.io/qt-6/containers.html#stl-style-iterators">STL-style iterator</a> 指向<code>fulture</code>的第一个结果。</p>
<p><strong>See also</strong> <a href="#begin">begin</a>() and <a href="#constEnd">constEnd</a>().</p>
<h3><span id="template-lt-typename-u-typename-gt-qfuture-const-iterator-qfuture-constend-const">template &lt;typename U, typename&gt;  QFuture::constEnd() const</span><a href="#template-lt-typename-u-typename-gt-qfuture-const-iterator-qfuture-constend-const" class="header-anchor">#</a></h3><p>返回一个const <a target="_blank" rel="noopener" href="https://doc.qt.io/qt-6/containers.html#stl-style-iterators">STL-style iterator</a>，指向<code>fulture</code>最后一个结果之后的虚数结果。</p>
<p><strong>See also</strong> <a href="#constBegin">constBegin</a>() and <a href="#end">end</a>().</p>
<h3><span id="template-lt-typename-u-typename-gt-qfuture-const-iterator-qfuture-end-const">template &lt;typename U, typename&gt;  QFuture::end() const</span><a href="#template-lt-typename-u-typename-gt-qfuture-const-iterator-qfuture-end-const" class="header-anchor">#</a></h3><p>返回一个const <a target="_blank" rel="noopener" href="https://doc.qt.io/qt-6/containers.html#stl-style-iterators">STL-style iterator</a>，指向<code>fulture</code>最后一个结果之后的虚数结果。</p>
<p><strong>See also</strong> <a href="#begin">begin</a>() and <a href="#constEnd">constEnd</a>().</p>
<h3><span id="bool-qfuture-iscanceled-const">bool QFuture::isCanceled() const</span><a href="#bool-qfuture-iscanceled-const" class="header-anchor">#</a></h3><p>如果异步计算已经被<a href="#cancel">cancel</a>()函数取消，则返回 “true”；否则返回 “false”。</p>
<p>请注意，即使这个函数返回 “true”，计算可能仍然在运行。更多细节请参见<a href="#cancel">cancel</a>()。</p>
<h3><span id="bool-qfuture-isfinished-const">bool QFuture::isFinished() const</span><a href="#bool-qfuture-isfinished-const" class="header-anchor">#</a></h3><p>如果这个future所代表的异步计算已经完成，返回 “true”；否则返回 “false”。</p>
<h3><span id="template-lt-typename-u-typename-gt-bool-qfuture-isresultreadyat-int-index-const">template &lt;typename U, typename&gt; bool QFuture::isResultReadyAt(int <em>index</em>) const</span><a href="#template-lt-typename-u-typename-gt-bool-qfuture-isresultreadyat-int-index-const" class="header-anchor">#</a></h3><p>如果<em>index</em>处的结果立即可用，则返回<code>true</code>；否则返回<code>false</code>。</p>
<p><strong>注意：</strong>如果<a href="#isValid">isValid</a>()对这个<a href>QFuture</a>返回<code>false</code>，调用isResultReadyAt()会导致未定义行为。</p>
<p><strong>See also</strong> <a href="#resultAt">resultAt</a>(), <a href="#resultCount">resultCount</a>(), and <a href="#takeResult">takeResult</a>().</p>
<h3><span id="bool-qfuture-isrunning-const">bool QFuture::isRunning() const</span><a href="#bool-qfuture-isrunning-const" class="header-anchor">#</a></h3><p>如果这个future所代表的异步计算目前正在运行，则返回 “true”；否则返回 “false”。</p>
<h3><span id="bool-qfuture-isstarted-const">bool QFuture::isStarted() const</span><a href="#bool-qfuture-isstarted-const" class="header-anchor">#</a></h3><p>如果这个future所代表的异步计算已经开始，返回 “true”；否则返回 “false”。</p>
<h3><span id="since-6-0-bool-qfuture-issuspended-const"><code>[since 6.0]</code>bool QFuture::isSuspended() const</span><a href="#since-6-0-bool-qfuture-issuspended-const" class="header-anchor">#</a></h3><p>如果请求暂停异步计算，则返回 “true”，并且它是有效的，这意味着没有更多的结果或进度变化被期待。</p>
<p>这个函数是在Qt 6.0中引入的。</p>
<p><strong>See also</strong> <a href="#setSuspended">setSuspended</a>(), <a href="#toggleSuspended">toggleSuspended</a>(), and <a href="#isSuspending">isSuspending</a>().</p>
<h3><span id="since-6-0-bool-qfuture-issuspending-const"><code>[since 6.0]</code>bool QFuture::isSuspending() const</span><a href="#since-6-0-bool-qfuture-issuspending-const" class="header-anchor">#</a></h3><p>如果异步计算已经用<a href="#suspend">suspend</a>()函数中止，但工作尚未中止，计算仍在运行，则返回<code>true</code>。否则返回 “false”。</p>
<p>要检查暂停是否真的生效，请使用<a href="#isSuspended">isSuspended</a>()代替。</p>
<p>这个函数是在Qt 6.0中引入的。</p>
<p><strong>See also</strong> <a href="#setSuspended">setSuspended</a>(), <a href="#toggleSuspended">toggleSuspended</a>(), and <a href="#isSuspended">isSuspended</a>().</p>
<h3><span id="since-6-0-bool-qfuture-isvalid-const"><code>[since 6.0]</code>bool QFuture::isValid() const</span><a href="#since-6-0-bool-qfuture-isvalid-const" class="header-anchor">#</a></h3><p>如果一个或多个结果可以被访问或从这个<a href>QFuture</a>对象中提取，则返回<code>true'。在结果被从</code>fulture`中取出后，返回false。</p>
<p>这个函数是在Qt 6.0中引入的。</p>
<p><strong>See also</strong> <a href="#takeResult">takeResult</a>(), <a href="#result">result</a>(), <a href="#results">results</a>(), and <a href="#resultAt">resultAt</a>().</p>
<h3><span id="since-6-0-template-lt-typename-function-typename-gt-qfuture-qfuture-oncanceled-function-amp-amp-handler"><code>[since 6.0]</code>template &lt;typename Function, typename&gt; <t> QFuture::onCanceled(Function &amp;&amp;<em>handler</em>)</t></span><a href="#since-6-0-template-lt-typename-function-typename-gt-qfuture-qfuture-oncanceled-function-amp-amp-handler" class="header-anchor">#</a></h3><p>将一个取消的<em>处理程序附加到这个future上。返回的future的行为与这个future完全一样（具有相同的状态和结果），除非这个future被取消了。该</em>handler<em>是一个可调用的，它不需要参数，并返回一个由该future打包的类型的值。在取消后，返回的future会打包由</em>handler*返回的值。</p>
<p>如果在取消之前附加，<em>handler</em>将在取消后报告future完成的同一线程中被调用。如果处理程序是在这个<code>fulture</code>已经被取消后附加的，它将在执行<code>onCanceled()</code>的线程中立即被调用。因此，处理程序不能总是假设它将在哪个线程上运行。如果你想控制处理程序在哪个线程上被调用，请使用接受一个上下文对象的重载。</p>
<p>下面的例子演示了如何附加一个取消处理程序:</p>
<div class="code-wrapper"><pre><code class="hljs c++">QFuture&lt;<span class="hljs-type">int</span>&gt; testFuture = ...;
<span class="hljs-keyword">auto</span> resultFuture = testFuture.<span class="hljs-built_in">then</span>([](<span class="hljs-type">int</span> res) {
    <span class="hljs-comment">// Block 1</span>
    ...
    <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;
}).<span class="hljs-built_in">then</span>([](<span class="hljs-type">int</span> res) {
    <span class="hljs-comment">// Block 2</span>
    ...
    <span class="hljs-keyword">return</span> <span class="hljs-number">2</span>;
}).<span class="hljs-built_in">onCanceled</span>([] {
    <span class="hljs-comment">// Block 3</span>
    ...
    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;
});</code></pre></div>

<p>如果<code>testFuture</code>被取消，<code>Block 3</code>将被调用，<code>resultFuture</code>的结果将是<code>-1</code>。与<code>testFuture</code>不同的是，它不会处于`取消’的状态。这意味着你可以得到它的结果，将计数附加到它，等等。</p>
<p>还要注意的是，你可以在连续体链执行时，通过启动连续体链的future来取消它们。假设<code>testFuture.cancel()</code>被调用，而<code>Block 1</code>已经在执行。下一个延续将检测到有人请求取消，所以<code>Block 2</code>将被跳过，取消处理程序（<code>Block 3</code>）将被调用。</p>
<p><strong>注意：</strong>该方法返回一个新的<code>QFuture</code>，代表延续链的结果。取消结果的<code>QFuture</code>本身不会调用导致它的链中的取消处理程序。这意味着，如果你调用<code>resultFuture.cancel()</code>，<code>Block 3</code>将不会被调用：因为<code>resultFuture</code>是将取消处理程序附加到<code>testFuture</code>的结果，没有取消处理程序被附加到<code>resultFuture</code>本身。只有取消<code>testFuture</code>或在<code>onCancelled()</code>调用之前附加的连续程序所返回的期货才能触发<code>block 3</code>。</p>
<p>这个函数是在Qt 6.0中引入的。</p>
<p><strong>See also</strong> <a href="#then">then</a>() and <a href="#onFailed">onFailed</a>().</p>
<h3><span id="since-6-1-template-lt-typename-function-typename-gt-qfuture-qfuture-oncanceled-qobject-context-function-amp-amp-handler"><code>[since 6.1]</code>template &lt;typename Function, typename&gt; <t> QFuture::onCanceled(<a target="_blank" rel="noopener" href="https://doc.qt.io/qt-6/qobject.html">QObject</a> *<em>context</em>, Function &amp;&amp;<em>handler</em>)</t></span><a href="#since-6-1-template-lt-typename-function-typename-gt-qfuture-qfuture-oncanceled-qobject-context-function-amp-amp-handler" class="header-anchor">#</a></h3><p>这是一个重载函数。</p>
<p>将一个取消的<em>handler</em>附加到这个future上，当这个future被取消时被调用。这个<em>handler</em>是一个可调用的，不需要任何参数。它将在<em>context</em>对象的线程中被调用。如果取消需要在一个特定的线程中处理，这可能很有用。</p>
<p><strong>注意：</strong>在调用这个方法时，应该保证<em>context</em>在整个链的执行过程中保持活力。</p>
<p>关于<em>handler</em>的更多细节，请参见其他重载的文档。</p>
<p>这个函数是在Qt 6.1中引入的。</p>
<p><strong>See also</strong> <a href="#then">then</a>() and <a href="#onFailed">onFailed</a>().</p>
<h3><span id="since-6-0-template-lt-typename-function-typename-gt-qfuture-qfuture-onfailed-function-amp-amp-handler"><code>[since 6.0]</code>template &lt;typename Function, typename&gt; <t> QFuture::onFailed(Function &amp;&amp;<em>handler</em>)</t></span><a href="#since-6-0-template-lt-typename-function-typename-gt-qfuture-qfuture-onfailed-function-amp-amp-handler" class="header-anchor">#</a></h3><p>将一个失败处理程序附加到这个future上，以处理任何异常。返回的future的行为与这个future完全一样（具有相同的状态和结果），除非这个future出现异常而失败。</p>
<p>处理程序是一个可调用的，它不需要任何参数或一个参数，可以通过特定的错误类型进行过滤，类似于 <a target="_blank" rel="noopener" href="https://en.cppreference.com/w/cpp/language/try_catch">catch</a> 语句。它返回一个由这个future打包的类型的值。失败后，返回的future打包了由<em>handler</em> 返回的值。</p>
<p>处理程序只有在异常被引发时才会被调用。如果异常是在这个处理程序被附加后引发的，处理程序将在报告future由于异常而完成的线程中执行。如果处理程序是在这个future已经失败后被附加的，它将被立即调用，在执行<code>onFailed()</code>的线程中。因此，处理程序不能总是假设它将在哪个线程上运行。如果你想控制处理程序在哪个线程上被调用，请使用需要一个上下文对象的重载。</p>
<p>下面的例子演示了如何附加一个失败处理程序:</p>
<div class="code-wrapper"><pre><code class="hljs c++">QFuture&lt;<span class="hljs-type">int</span>&gt; future = ...;
<span class="hljs-keyword">auto</span> resultFuture = future.<span class="hljs-built_in">then</span>([](<span class="hljs-type">int</span> res) {
    ...
    <span class="hljs-keyword">throw</span> <span class="hljs-built_in">Error</span>();
    ...
}).<span class="hljs-built_in">onFailed</span>([](<span class="hljs-type">const</span> Error &amp;e) {
    <span class="hljs-comment">// Handle exceptions of type Error</span>
    ...
    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;
}).<span class="hljs-built_in">onFailed</span>([] {
    <span class="hljs-comment">// Handle all other types of errors</span>
    ...
    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;
});

<span class="hljs-keyword">auto</span> result = resultFuture.<span class="hljs-built_in">result</span>(); <span class="hljs-comment">// result is -1</span></code></pre></div>

<p>如果有多个处理程序，第一个与抛出的异常类型匹配的处理程序将被调用。比如说:</p>
<div class="code-wrapper"><pre><code class="hljs c++">QFuture&lt;<span class="hljs-type">int</span>&gt; future = ...;
future.<span class="hljs-built_in">then</span>([](<span class="hljs-type">int</span> res) {
    ...
    <span class="hljs-keyword">throw</span> std::<span class="hljs-built_in">runtime_error</span>(<span class="hljs-string">"message"</span>);
    ...
}).<span class="hljs-built_in">onFailed</span>([](<span class="hljs-type">const</span> std::exception &amp;e) {
    <span class="hljs-comment">// This handler will be invoked</span>
}).<span class="hljs-built_in">onFailed</span>([](<span class="hljs-type">const</span> std::runtime_error &amp;e) {
    <span class="hljs-comment">// This handler won't be invoked, because of the handler above.</span>
});</code></pre></div>

<p>如果没有一个处理程序与被抛出的异常类型相匹配，该异常将被传播到结果的未来:</p>
<div class="code-wrapper"><pre><code class="hljs c++">QFuture&lt;<span class="hljs-type">int</span>&gt; future = ...;
<span class="hljs-keyword">auto</span> resultFuture = future.<span class="hljs-built_in">then</span>([](<span class="hljs-type">int</span> res) {
    ...
    <span class="hljs-keyword">throw</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">"message"</span>);
    ...
}).<span class="hljs-built_in">onFailed</span>([](<span class="hljs-type">const</span> std::exception &amp;e) {
    <span class="hljs-comment">// Won't be invoked</span>
}).<span class="hljs-built_in">onFailed</span>([](<span class="hljs-type">const</span> QException &amp;e) {
    <span class="hljs-comment">// Won't be invoked</span>
});

<span class="hljs-keyword">try</span> {
    <span class="hljs-keyword">auto</span> result = resultFuture.<span class="hljs-built_in">result</span>();
} <span class="hljs-built_in">catch</span>(...) {
    <span class="hljs-comment">// Handle the exception</span>
}</code></pre></div>

<p><strong>注意：</strong>你总是可以附加一个没有参数的处理程序，以处理所有的异常类型，并避免编写try-catch块。</p>
<p>这个函数是在Qt 6.0中引入的。</p>
<p><strong>See also</strong> <a href="#then">then</a>() and <a href="#onCanceled">onCanceled</a>().</p>
<h3><span id="since-6-1-template-lt-typename-function-typename-gt-qfuture-qfuture-onfailed-qobject-context-function-amp-amp-handler"><code>[since 6.1]</code>template &lt;typename Function, typename&gt; <t> QFuture::onFailed(<a target="_blank" rel="noopener" href="https://doc.qt.io/qt-6/qobject.html">QObject</a> *<em>context</em>, Function &amp;&amp;<em>handler</em>)</t></span><a href="#since-6-1-template-lt-typename-function-typename-gt-qfuture-qfuture-onfailed-qobject-context-function-amp-amp-handler" class="header-anchor">#</a></h3><p>这是一个重载函数。</p>
<p>将一个失败处理程序附加到这个future上，以处理这个future所引发的或已经引发的任何异常。返回一个与此future相同类型的<a href>QFuture</a>。该处理程序将只在发生异常的情况下，在<em>context</em>对象的线程中被调用。如果故障需要在一个特定的线程中处理，这可能是有用的。比如说:</p>
<div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-comment">// somewhere in the main thread</span>
<span class="hljs-keyword">auto</span> future = QtConcurrent::<span class="hljs-built_in">run</span>([] {
    <span class="hljs-comment">// This will run in a separate thread</span>
    ...
    <span class="hljs-keyword">throw</span> std::<span class="hljs-built_in">exception</span>();
}).<span class="hljs-built_in">onFailed</span>(<span class="hljs-keyword">this</span>, [] {
   <span class="hljs-comment">// Update UI elements</span>
});</code></pre></div>

<p>附在<a target="_blank" rel="noopener" href="https://doc.qt.io/qt-6/qtconcurrent.html#run">QtConcurrent::run</a>中的失败处理程序会更新UI元素，不能从非gui线程调用。因此，<code>this</code>被作为上下文提供给<code>.onFailed()</code>，以确保它将在主线程中被调用。</p>
<p><strong>注意：</strong>在调用此方法时，应保证<em>上下文</em>在整个执行链中保持活力。</p>
<p>关于<em>handler</em>的更多细节，请参见其他重载的文档。</p>
<p>这个函数是在Qt 6.1中引入的。</p>
<p><strong>See also</strong> <a href="#then">then</a>() and <a href="#onCanceled">onCanceled</a>().</p>
<h3><span id="int-qfuture-progressmaximum-const">int QFuture::progressMaximum() const</span><a href="#int-qfuture-progressmaximum-const" class="header-anchor">#</a></h3><p>返回最大的<a href="#progressValue">progressValue</a>()。</p>
<p><strong>See also</strong> <a href="#progressValue">progressValue</a>() and <a href="#progressMinimum">progressMinimum</a>().</p>
<h3><span id="int-qfuture-progressminimum-const">int QFuture::progressMinimum() const</span><a href="#int-qfuture-progressminimum-const" class="header-anchor">#</a></h3><p>返回最小的<a href="#progressValue">progressValue</a>()。</p>
<p><strong>See also</strong> <a href="#progressValue">progressValue</a>() and <a href="#progressMaximum">progressMaximum</a>().</p>
<h3><span id="qstring-qfuture-progresstext-const"> QFuture::progressText() const</span><a href="#qstring-qfuture-progresstext-const" class="header-anchor">#</a></h3><p>返回由异步计算报告的进度的（可选）文本表示。</p>
<p>请注意，并不是所有的计算都提供进度的文本表示，因此，这个函数可能返回一个空字符串。</p>
<h3><span id="int-qfuture-progressvalue-const">int QFuture::progressValue() const</span><a href="#int-qfuture-progressvalue-const" class="header-anchor">#</a></h3><p>返回当前的进度值，该值介于<a href="#progressMinimum">progressMinimum</a>()和<a href="#progressMaximum">progressMaximum</a>()之间。</p>
<p><strong>See also</strong> <a href="#progressMinimum">progressMinimum</a>() and <a href="#progressMaximum">progressMaximum</a>().</p>
<h3><span id="template-lt-typename-u-typename-gt-t-qfuture-result-const">template &lt;typename U, typename&gt; T QFuture::result() const</span><a href="#template-lt-typename-u-typename-gt-t-qfuture-result-const" class="header-anchor">#</a></h3><p>返回未来的第一个结果。如果结果不是立即可用的，这个函数将阻塞并等待结果变得可用。这是一个调用<a href="#resultAt">resultAt</a>(0)的方便方法。注意，<code>result()</code>返回内部存储的结果的副本。如果<code>T</code>是一个只移动的类型，或者你不想复制结果，请使用<a href="#takeResult">takeResult</a>()代替。</p>
<p><strong>注意：</strong>如果<a href="#isValid">isValid</a>()对这个<a href>QFuture</a>返回<code>false</code>，调用<code>result()</code>会导致未定义的行为。</p>
<p><strong>See also</strong> <a href="#resultAt">resultAt</a>(), <a href="#results">results</a>(), and <a href="#takeResult">takeResult</a>().</p>
<h3><span id="template-lt-typename-u-typename-gt-t-qfuture-resultat-int-index-const">template &lt;typename U, typename&gt; T QFuture::resultAt(int <em>index</em>) const</span><a href="#template-lt-typename-u-typename-gt-t-qfuture-resultat-int-index-const" class="header-anchor">#</a></h3><p>返回未来<em>index</em>处的结果。如果结果不是立即可用的，这个函数将阻塞并等待结果变得可用。</p>
<p><strong>注意：</strong>如果<a href="#isValid">isValid</a>()对这个<a href>QFuture</a>返回<code>false</code>，调用resultAt()会导致未定义行为。</p>
<p><strong>See also</strong> <a href="#result">result</a>(), <a href="#results">results</a>(), <a href="#takeResult">takeResult</a>(), and <a href="#resultCount">resultCount</a>().</p>
<h3><span id="int-qfuture-resultcount-const">int QFuture::resultCount() const</span><a href="#int-qfuture-resultcount-const" class="header-anchor">#</a></h3><p>返回这个未来中可用的连续结果的数量。由于结果集的间隙，实际存储的结果数可能与这个值不同。从0到resultCount()的结果进行迭代总是安全的。</p>
<p><strong>See also</strong> <a href="#result">result</a>(), <a href="#resultAt">resultAt</a>(), <a href="#results">results</a>(), and <a href="#takeResult">takeResult</a>().</p>
<h3><span id="template-lt-typename-u-typename-gt-qlist-qfuture-results-const">template &lt;typename U, typename&gt; <t> QFuture::results() const</t></span><a href="#template-lt-typename-u-typename-gt-qlist-qfuture-results-const" class="header-anchor">#</a></h3><p>返回所有来自未来的结果。如果结果不是立即可用的，这个函数将阻塞并等待它们变得可用。注意，<code>results()</code>返回内部存储的结果的副本。目前不支持获取仅有移动类型<code>T</code>的所有结果。但是你仍然可以通过使用<a target="_blank" rel="noopener" href="https://doc.qt.io/qt-6/containers.html#stl-style-iterators">STL-style iterators</a>或者只读的<a target="_blank" rel="noopener" href="https://doc.qt.io/qt-6/java-style-iterators.html#java-style-iterators">Java-style iterators</a>来迭代只移动的结果列表。</p>
<p><strong>注意：</strong>如果<a href="#isValid">isValid</a>()对这个<a href>QFuture</a>返回<code>false</code>，调用<code>results()</code>会导致未定义行为。</p>
<p><strong>See also</strong> <a href="#result">result</a>(), <a href="#resultAt">resultAt</a>(), <a href="#takeResult">takeResult</a>(), <a href="#resultCount">resultCount</a>(), and <a href="#isValid">isValid</a>().</p>
<h3><span id="void-qfuture-resume">void QFuture::resume()</span><a href="#void-qfuture-resume" class="header-anchor">#</a></h3><p>恢复future()所代表的异步计算。这是一个方便的方法，简单地调用<a href="#setSuspended">setSuspended</a>(false)。</p>
<p><strong>See also</strong> <a href="#suspend">suspend</a>().</p>
<h3><span id="since-6-0-void-qfuture-setsuspended-bool-suspend"><code>[since 6.0]</code>void QFuture::setSuspended(bool <em>suspend</em>)</span><a href="#since-6-0-void-qfuture-setsuspended-bool-suspend" class="header-anchor">#</a></h3><p>如果<em>suspend</em>为真，这个函数将暂停future()所代表的异步计算。如果计算已经暂停，这个函数不做任何事情。<a target="_blank" rel="noopener" href="https://doc.qt.io/qt-6/qfuturewatcher.html">QFutureWatcher</a>不会在future被暂停时立即停止传递进度和结果就绪信号。在暂停的那一刻，可能仍然有正在进行的计算，并且不能被停止。这些计算的信号仍将被传递。</p>
<p>如果<em>suspend</em>为false，这个函数将恢复异步计算。如果计算之前没有被暂停，这个函数什么也不做。</p>
<p>请注意，不是所有的计算都可以被暂停。例如，由QtConcurrent::run()返回的<a href>QFuture</a>不能被暂停；但由QtConcurrent::mappedReduced()返回的<a href>QFuture</a>可以。</p>
<p>这个函数是在Qt 6.0中引入的。</p>
<p><strong>See also</strong> <a href="#isSuspended">isSuspended</a>(), <a href="#suspend">suspend</a>(), <a href="#resume">resume</a>(), and <a href="#toggleSuspended">toggleSuspended</a>().</p>
<h3><span id="since-6-0-void-qfuture-suspend"><code>[since 6.0]</code>void QFuture::suspend()</span><a href="#since-6-0-void-qfuture-suspend" class="header-anchor">#</a></h3><p>暂停这个未来所代表的异步计算。这是一个方便的方法，简单地调用<a href="#setSuspended">setSuspended</a>(true)。</p>
<p>这个函数是在Qt 6.0中引入的。</p>
<p><strong>See also</strong> <a href="#resume">resume</a>().</p>
<h3><span id="since-6-0-template-lt-typename-u-typename-gt-t-qfuture-takeresult"><code>[since 6.0]</code>template &lt;typename U, typename&gt; T QFuture::takeResult()</span><a href="#since-6-0-template-lt-typename-u-typename-gt-t-qfuture-takeresult" class="header-anchor">#</a></h3><p>只有当<a href="#isValid">isValid</a>()返回 “true “时，才调用此函数，否则，行为未被定义。这个函数从<a href>QFuture</a>对象中获取（移动）第一个结果，当预期只有一个结果时。如果有任何其他的结果，在取走第一个结果后，它们会被丢弃。如果结果不是立即可用的，这个函数将阻塞并等待结果变得可用。如果可能的话，<a href>QFuture</a>将尝试使用移动语义，如果类型不是可移动的，将退回到复制构造。在取得结果后，<a href="#isValid">isValid</a>()将评估为<code>false</code>。</p>
<p><strong>注意：</strong> <a href>QFuture</a>一般允许在不同的<a href>QFuture</a>对象之间（以及可能在不同的线程之间）共享结果。takeResult()的引入是为了使<a href>QFuture</a>也能与只移动的类型（如std::unique_ptr）一起工作，所以它假定只有一个线程能将结果从未来中移动出来，并且只做一次。还要注意的是，目前不支持取所有结果的列表。但是你仍然可以通过使用<a target="_blank" rel="noopener" href="https://doc.qt.io/qt-6/containers.html#stl-style-iterators">STL-style iterators</a>或只读的<a target="_blank" rel="noopener" href="https://doc.qt.io/qt-6/java-style-iterators.html#java-style-iterators">Java-style iterators</a>来迭代只移动的结果列表。</p>
<p>这个函数是在Qt 6.0中引入的。</p>
<p><strong>See also</strong> <a href="#result">result</a>(), <a href="#results">results</a>(), <a href="#resultAt">resultAt</a>(), and <a href="#isValid">isValid</a>().</p>
<h3><span id="since-6-0-template-qfuture-lt-resulttype-gt-qfuture-then-function-amp-amp-function"><code>[since 6.0]</code>template <typename function> <a href="#QFuture">QFuture</a>&lt;ResultType<function> &gt; QFuture::then(Function &amp;&amp;<em>function</em>)</function></typename></span><a href="#since-6-0-template-qfuture-lt-resulttype-gt-qfuture-then-function-amp-amp-function" class="header-anchor">#</a></h3><p>这是一个重载函数。</p>
<p>将一个延续附加到这个future上，如果需要的话，允许使用<a target="_blank" rel="noopener" href="https://doc.qt.io/qt-6/qtfuture.html#Launch-enum">Sync</a>策略来连锁多个异步计算。<em>function</em>是一个可调用的函数，如果它有一个结果（不是<a href>QFuture</a><void>），那么它需要一个由这个future打包的类型的参数。否则，它不接受任何参数。这个方法返回一个新的<a href>QFuture</a>，它封装了一个由<em>function</em>返回的类型的值。返回的未来将处于一个未初始化的状态，直到所附的延续被调用，或者直到这个未来失败或被取消。</void></p>
<p><strong>注意：</strong>如果你需要在一个单独的线程中启动延续，请使用此方法的其他重载。</p>
<p>你可以像这样串联多个操作：</p>
<div class="code-wrapper"><pre><code class="hljs c++">QFuture&lt;<span class="hljs-type">int</span>&gt; future = ...;
future.<span class="hljs-built_in">then</span>([](<span class="hljs-type">int</span> res1){ ... }).<span class="hljs-built_in">then</span>([](<span class="hljs-type">int</span> res2){ ... })...</code></pre></div>

<p>或者:</p>
<div class="code-wrapper"><pre><code class="hljs c++">QFuture&lt;<span class="hljs-type">void</span>&gt; future = ...;
future.<span class="hljs-built_in">then</span>([](){ ... }).<span class="hljs-built_in">then</span>([](){ ... })...</code></pre></div>

<p>延续也可以接受一个 <a href>QFuture</a> 参数（而不是它的值），代表上一个未来。例如，如果<a href>QFuture</a>有多个结果，而用户想在延续中访问它们，这就很有用。或者用户需要在延续中处理前一个未来的异常，以避免中断多个延续的链条。比如说：</p>
<div class="code-wrapper"><pre><code class="hljs c++">QFuture&lt;<span class="hljs-type">int</span>&gt; future = ...;
future.<span class="hljs-built_in">then</span>([](QFuture&lt;<span class="hljs-type">int</span>&gt; f) {
    <span class="hljs-keyword">try</span> {
        ...
            <span class="hljs-keyword">auto</span> result = f.<span class="hljs-built_in">result</span>();
        ...
    } <span class="hljs-built_in">catch</span> (QException &amp;e) {
        <span class="hljs-comment">// handle the exception</span>
    }
}).<span class="hljs-built_in">then</span>(...);</code></pre></div>

<p>如果前一个未来抛出一个异常，并且在延续中没有被处理，那么这个异常将被传播到延续的未来，以使调用者能够处理它。</p>
<div class="code-wrapper"><pre><code class="hljs c++">QFuture&lt;<span class="hljs-type">int</span>&gt; future = ...;
<span class="hljs-keyword">auto</span> continuation = future.<span class="hljs-built_in">then</span>([](<span class="hljs-type">int</span> res1){ ... }).<span class="hljs-built_in">then</span>([](<span class="hljs-type">int</span> res2){ ... })...
...
<span class="hljs-comment">// future throws an exception</span>
<span class="hljs-keyword">try</span> {
    <span class="hljs-keyword">auto</span> result = continuation.<span class="hljs-built_in">result</span>();
} <span class="hljs-built_in">catch</span> (QException &amp;e) {
    <span class="hljs-comment">// handle the exception</span>
}</code></pre></div>

<p>在这种情况下，整个延续链将被中断。</p>
<p><strong>注意：</strong>如果这个 future 被取消，附属于它的连续也将被取消。</p>
<p>这个函数是在Qt 6.0中引入的。</p>
<p><strong>See also</strong> <a href="#onFailed">onFailed</a>() and <a href="#onCanceled">onCanceled</a>().</p>
<h3><span id="since-6-0-template-qfuture-lt-resulttype-gt-qfuture-then-qtfuture-launch-policy-function-amp-amp-function"><code>[since 6.0]</code>template <typename function> <a href="#QFuture">QFuture</a>&lt;ResultType<function> &gt; QFuture::then(<a target="_blank" rel="noopener" href="https://doc.qt.io/qt-6/qtfuture.html#Launch-enum">QtFuture::Launch</a> <em>policy</em>, Function &amp;&amp;<em>function</em>)</function></typename></span><a href="#since-6-0-template-qfuture-lt-resulttype-gt-qfuture-then-qtfuture-launch-policy-function-amp-amp-function" class="header-anchor">#</a></h3><p>这是一个重载函数。</p>
<p>将一个延续附加到这个future上，允许连锁多个异步计算。当这个future所代表的异步计算完成后，<em>function</em>将根据给定的启动<em>policy</em>被调用。一个新的<a href>QFuture</a>代表延续的结果被返回。</p>
<p>根据<em>policy</em>，continuation将在与这个future相同的线程中，在一个新的线程中被调用，或者将继承这个future的启动策略和线程池。如果没有指定启动策略（见只取一个可调用的重载），将使用<code>Sync</code>策略。</p>
<p>在下面的例子中，两个延续将在一个新的线程中被调用（但在同一个线程中）。</p>
<div class="code-wrapper"><pre><code class="hljs c++">QFuture&lt;<span class="hljs-type">int</span>&gt; future = ...;
future.<span class="hljs-built_in">then</span>(QtFuture::Launch::Async, [](<span class="hljs-type">int</span> res){ ... }).<span class="hljs-built_in">then</span>([](<span class="hljs-type">int</span> res2){ ... });</code></pre></div>

<p>在下面的例子中，两个延续都将在使用同一线程池的新线程中被调用。</p>
<div class="code-wrapper"><pre><code class="hljs c++">QFuture&lt;<span class="hljs-type">int</span>&gt; future = ...;
future.<span class="hljs-built_in">then</span>(QtFuture::Launch::Async, [](<span class="hljs-type">int</span> res){ ... })
      .<span class="hljs-built_in">then</span>(QtFuture::Launch::Inherit, [](<span class="hljs-type">int</span> res2){ ... });</code></pre></div>

<p>关于<em>function</em>的更多细节，请参见其他重载的文档。</p>
<p>这个函数是在Qt 6.0中引入的。</p>
<p><strong>See also</strong> <a href="#onFailed">onFailed</a>() and <a href="#onCanceled">onCanceled</a>().</p>
<h3><span id="since-6-0-template-qfuture-lt-resulttype-gt-qfuture-then-qthreadpool-pool-function-amp-amp-function"><code>[since 6.0]</code>template <typename function> <a href="#QFuture">QFuture</a>&lt;ResultType<function> &gt; QFuture::then(<a target="_blank" rel="noopener" href="https://doc.qt.io/qt-6/qthreadpool.html">QThreadPool</a> *<em>pool</em>, Function &amp;&amp;<em>function</em>)</function></typename></span><a href="#since-6-0-template-qfuture-lt-resulttype-gt-qfuture-then-qthreadpool-pool-function-amp-amp-function" class="header-anchor">#</a></h3><p>这是一个重载函数。</p>
<p>将一个延续附加到这个future上，如果需要的话，允许连锁多个异步计算。当这个future所代表的异步计算完成后，<em>function</em>将在一个单独的线程中被调用，这个线程来自<a target="_blank" rel="noopener" href="https://doc.qt.io/qt-6/qthreadpool.html">QThreadPool</a> <em>pool</em>。</p>
<p>这个函数是在Qt 6.0中引入的。</p>
<p><strong>See also</strong> <a href="#onFailed">onFailed</a>() and <a href="#onCanceled">onCanceled</a>().</p>
<h3><span id="since-6-1-template-qfuture-lt-resulttype-gt-qfuture-then-qobject-context-function-amp-amp-function"><code>[since 6.1]</code>template <typename function> <a href="#QFuture">QFuture</a>&lt;ResultType<function> &gt; QFuture::then(<a target="_blank" rel="noopener" href="https://doc.qt.io/qt-6/qobject.html">QObject</a> *<em>context</em>, Function &amp;&amp;<em>function</em>)</function></typename></span><a href="#since-6-1-template-qfuture-lt-resulttype-gt-qfuture-then-qobject-context-function-amp-amp-function" class="header-anchor">#</a></h3><p>这是一个重载函数。</p>
<p>将一个延续附加到这个future上，如果需要的话，允许连锁多个异步计算。当这个future所代表的异步计算完成后，<em>function</em>将在<em>context</em>对象的线程中被调用。如果延续需要在一个特定的线程中调用，这可能是有用的。比如说：</p>
<div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-comment">// somewhere in the main thread</span>
<span class="hljs-keyword">auto</span> future = QtConcurrent::<span class="hljs-built_in">run</span>([] {
    <span class="hljs-comment">// This will run in a separate thread</span>
    ...
}).<span class="hljs-built_in">then</span>(<span class="hljs-keyword">this</span>, [] {
   <span class="hljs-comment">// Update UI elements</span>
});</code></pre></div>

<p>附加到<a target="_blank" rel="noopener" href="https://doc.qt.io/qt-6/qtconcurrent.html#run">QtConcurrent::run</a>中的续集更新了UI元素，不能从非gui线程中调用。所以<code>this</code>被作为上下文提供给<code>.then()</code>，以确保它将在主线程中被调用。</p>
<p>除非指定不同的上下文或启动策略，否则下面的延续也将从同一上下文中调用：</p>
<div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">auto</span> future = QtConcurrent::<span class="hljs-built_in">run</span>([] {
    ...
}).<span class="hljs-built_in">then</span>(<span class="hljs-keyword">this</span>, [] {
   <span class="hljs-comment">// Update UI elements</span>
}).<span class="hljs-built_in">then</span>([] {
    <span class="hljs-comment">// This will also run in the main thread</span>
});</code></pre></div>

<p>这是因为默认情况下，<code>.then()</code>是在与前一个线程相同的线程中调用的。</p>
<p>但要注意的是，如果在这个future已经完成后再附加continuation，它将被立即调用，在执行<code>then()</code>的线程中：</p>
<div class="code-wrapper"><pre><code class="hljs c++">QObject *context = ...;
<span class="hljs-keyword">auto</span> future = cachedResultsReady ? QtFuture::<span class="hljs-built_in">makeReadyFuture</span>(results)
                                 : QtConcurrent::<span class="hljs-built_in">run</span>([] { <span class="hljs-comment">/* compute results */</span>});
<span class="hljs-keyword">auto</span> continuation = future.<span class="hljs-built_in">then</span>(context, [] (Results results) {
    <span class="hljs-comment">// Runs in the context's thread</span>
}).<span class="hljs-built_in">then</span>([] {
    <span class="hljs-comment">// May or may not run in the context's thread</span>
});</code></pre></div>

<p>在上面的例子中，如果<code>cachedResultsReady</code>是<code>true</code>，并且返回一个准备好的<code>fulture</code>，有可能第一个<code>.then()</code>在第二个连接之前完成。在这种情况下，它将在当前线程中被解决。因此，当有疑问时，请明确地传递上下文。</p>
<p><strong>注意：</strong>在调用这个方法时，应该保证<em>context</em>在整个链的执行过程中保持活力。</p>
<p>这个函数是在Qt 6.1中引入的。</p>
<p><strong>See also</strong> <a href="#onFailed">onFailed</a>() and <a href="#onCanceled">onCanceled</a>().</p>
<h3><span id="since-6-0-void-qfuture-togglesuspended"><code>[since 6.0]</code>void QFuture::toggleSuspended()</span><a href="#since-6-0-void-qfuture-togglesuspended" class="header-anchor">#</a></h3><p>切换异步计算的暂停状态。换句话说，如果计算当前正在暂停或中止，调用这个函数就可以恢复计算；如果计算正在运行，则是暂停。这是调用<a href="#setSuspended">setSuspended</a>(!(<a href="#isSuspending">isSuspending</a>()||<a href="#isSuspended">isSuspended</a>())的一个便利方法。）</p>
<p>这个函数是在Qt 6.0中引入的。</p>
<p><strong>See also</strong> <a href="#setSuspended">setSuspended</a>(), <a href="#suspend">suspend</a>(), and <a href="#resume">resume</a>().</p>
<h3><span id="void-qfuture-waitforfinished">void QFuture::waitForFinished()</span><a href="#void-qfuture-waitforfinished" class="header-anchor">#</a></h3><p>Waits for the asynchronous computation to finish (including <a href="#cancel">cancel</a>()ed computations), i.e. until <a href="#isFinished">isFinished</a>() returns <code>true</code>.</p>

            </div>
            <hr>
            <div>
              <div class="post-metas mb-3">
                
                
                  <div class="post-meta">
                    <i class="iconfont icon-tags"></i>
                    
                      <a class="hover-with-bg" href="/tags/F/">F</a>
                    
                  </div>
                
              </div>
              
                <p class="note note-warning">
                  
                    本博客所有文章除特别声明外，均采用 <a target="_blank" href="https://creativecommons.org/licenses/by-sa/4.0/deed.zh" rel="nofollow noopener noopener">CC BY-SA 4.0 协议</a> ，转载请注明出处！
                  
                </p>
              
              
                <div class="post-prevnext">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/2022/03/02/QtDocumentCN/Src/F/QFileSelector/QFileSelector/">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">QFileSelector类</span>
                        <span class="visible-mobile">上一篇</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2022/03/02/QtDocumentCN/Src/F/QFutureIterator/QFutureIterator/">
                        <span class="hidden-mobile">QFutureIterator类</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
              <!-- Comments -->
              <article class="comments" id="comments" lazyload>
                
                  
                
                
  <div id="lv-container" data-id="city" data-uid="MTAyMC81NTMzMi8zMTc5OQ==">
    <script type="text/javascript">
      Fluid.utils.loadComments('#lv-container', function() {
        Fluid.utils.createScript('https://cdn-city.livere.com/js/embed.dist.js');
      });
    </script>
    <noscript>Please enable JavaScript to view the comments</noscript>
  </div>


              </article>
            
          </article>
        </div>
      </div>
    </div>
    
      <div class="d-none d-lg-block col-lg-2 toc-container" id="toc-ctn">
        <div id="toc">
  <p class="toc-header"><i class="iconfont icon-list"></i>&nbsp;目录</p>
  <div class="toc-body" id="toc-body"></div>
</div>

      </div>
    
  </div>
</div>

<!-- Custom -->


    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v"
                 for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>
    

    
  </main>

  <footer class="text-center mt-5 py-3">
  <div class="footer-content">
     <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> 
  </div>
  

  

  
</footer>


  <!-- SCRIPTS -->
  
  <script  src="https://cdn.jsdelivr.net/npm/nprogress@0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/nprogress@0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js" ></script>
<script  src="https://cdn.jsdelivr.net/npm/bootstrap@4/dist/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>

<!-- Plugins -->


  <script  src="/js/local-search.js" ></script>



  
    <script  src="/js/img-lazyload.js" ></script>
  



  



  
    <script  src="https://cdn.jsdelivr.net/npm/tocbot@4/dist/tocbot.min.js" ></script>
  
  
    <script  src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3/dist/jquery.fancybox.min.js" ></script>
  
  
    <script  src="https://cdn.jsdelivr.net/npm/anchor-js@4/anchor.min.js" ></script>
  
  
    <script defer src="https://cdn.jsdelivr.net/npm/clipboard@2/dist/clipboard.min.js" ></script>
  






  <script  src="https://cdn.jsdelivr.net/npm/typed.js@2/lib/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var title = document.getElementById('subtitle').title;
      
        typing(title);
      
    })(window, document);
  </script>















<!-- 主题的启动项 保持在最底部 -->
<script  src="/js/boot.js" ></script>


</body>
</html>
