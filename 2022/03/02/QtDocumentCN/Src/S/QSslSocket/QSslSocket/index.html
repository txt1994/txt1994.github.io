

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=auto>



<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/logo.jpg">
  <link rel="icon" href="/img/logo.jpg">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
    <meta http-equiv="Content-Security-Policy" content="upgrade-insecure-requests">
  
  <meta name="theme-color" content="#6aa84f">
  <meta name="author" content="John Doe">
  <meta name="keywords" content="">
  
    <meta name="description" content="QSslSocket Class 公共成员类型 公共成员函数 重写公共成员函数 公共槽函数 信号 静态成员函数   重写保护成员函数 详细介绍 成员类型文档 enum QSslSocket::PeerVerifyMode enum QSslSocket::SslMode   成员函数文档 QSslSocket::QSslSocket(QObject *parent &#x3D; nullptr)">
<meta property="og:type" content="article">
<meta property="og:title" content="QSslSocket类">
<meta property="og:url" content="https://txt1994.github.io/2022/03/02/QtDocumentCN/Src/S/QSslSocket/QSslSocket/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:description" content="QSslSocket Class 公共成员类型 公共成员函数 重写公共成员函数 公共槽函数 信号 静态成员函数   重写保护成员函数 详细介绍 成员类型文档 enum QSslSocket::PeerVerifyMode enum QSslSocket::SslMode   成员函数文档 QSslSocket::QSslSocket(QObject *parent &#x3D; nullptr)">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2022-03-02T06:47:47.000Z">
<meta property="article:modified_time" content="2022-03-18T16:54:48.834Z">
<meta property="article:author" content="John Doe">
<meta property="article:tag" content="S">
<meta name="twitter:card" content="summary_large_image">
  
  
  <title>QSslSocket类 - Hexo</title>

  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4/dist/css/bootstrap.min.css" />


  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/github-markdown-css@4/github-markdown.min.css" />
  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/hint.css@2/hint.min.css" />

  
    
    
      
      <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@10/styles/github-gist.min.css" />
    
  

  
    <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3/dist/jquery.fancybox.min.css" />
  


<!-- 主题依赖的图标库，不要自行修改 -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_ba1fz6golrf.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_lbnruvf0jn.css">


<link  rel="stylesheet" href="/css/main.css" />

<!-- 自定义样式保持在最底部 -->

  
<link rel="stylesheet" href="/css/style.css">



  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    var CONFIG = {"hostname":"txt1994.github.io","root":"/","version":"1.8.14","typing":{"enable":true,"typeSpeed":70,"cursorChar":"_","loop":false},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"right","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"copy_btn":true,"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":false,"baidu":null,"google":null,"gtag":null,"tencent":{"sid":null,"cid":null},"woyaola":null,"cnzz":null,"leancloud":{"app_id":null,"app_key":null,"server_url":null,"path":"window.location.pathname","ignore_local":false}},"search_path":"/local-search.xml"};
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
<meta name="generator" content="Hexo 6.1.0">
<style>.github-emoji { position: relative; display: inline-block; width: 1.2em; min-height: 1.2em; overflow: hidden; vertical-align: top; color: transparent; }  .github-emoji > span { position: relative; z-index: 10; }  .github-emoji img, .github-emoji .fancybox { margin: 0 !important; padding: 0 !important; border: none !important; outline: none !important; text-decoration: none !important; user-select: none !important; cursor: auto !important; }  .github-emoji img { height: 1.2em !important; width: 1.2em !important; position: absolute !important; left: 50% !important; top: 50% !important; transform: translate(-50%, -50%) !important; user-select: none !important; cursor: auto !important; } .github-emoji-fallback { color: inherit; } .github-emoji-fallback img { opacity: 0 !important; }</style>
</head>


<body>
  <header style="height: 70vh;">
    <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/">
      <strong>txt1994s</strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/">
                <i class="iconfont icon-home-fill"></i>
                首页
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/">
                <i class="iconfont icon-archive-fill"></i>
                归档
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/">
                <i class="iconfont icon-tags-fill"></i>
                标签
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/">
                <i class="iconfont icon-user-fill"></i>
                关于
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/links/">
                <i class="iconfont icon-link-fill"></i>
                友联
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              &nbsp;<i class="iconfont icon-search"></i>&nbsp;
            </a>
          </li>
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">&nbsp;<i
                class="iconfont icon-dark" id="color-toggle-icon"></i>&nbsp;</a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

    <div class="banner" id="banner" parallax=true
         style="background: url('/img/default.png') no-repeat center center;
           background-size: cover;">
      <div class="full-bg-img">
        <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
          <div class="page-header text-center fade-in-up">
            <span class="h2" id="subtitle" title="QSslSocket类">
              
            </span>

            
              <div class="mt-3">
  
  
    <span class="post-meta">
      <i class="iconfont icon-date-fill" aria-hidden="true"></i>
      <time datetime="2022-03-02 14:47" pubdate>
        2022年3月2日 下午
      </time>
    </span>
  
</div>

<div class="mt-1">
  
    <span class="post-meta mr-2">
      <i class="iconfont icon-chart"></i>
      24k 字
    </span>
  

  
    <span class="post-meta mr-2">
      <i class="iconfont icon-clock-fill"></i>
      
      
      204 分钟
    </span>
  

  
  
</div>

            
          </div>

          
        </div>
      </div>
    </div>
  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="d-none d-lg-block col-lg-2"></div>
    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div class="py-5" id="board">
          <article class="post-content mx-auto">
            <!-- SEO header -->
            <h1 style="display: none">QSslSocket类</h1>
            
              <p class="note note-info">
                
                  本文最后更新于：2022年3月19日 凌晨
                
              </p>
            
            <div class="markdown-body">
              <div class="toc">

<!-- toc -->

<ul>
<li><a href="#qsslsocket-class">QSslSocket Class</a><ul>
<li><a href="#gong-gong-cheng-yuan-lei-xing">公共成员类型</a></li>
<li><a href="#gong-gong-cheng-yuan-han-shu">公共成员函数</a></li>
<li><a href="#chong-xie-gong-gong-cheng-yuan-han-shu">重写公共成员函数</a></li>
<li><a href="#gong-gong-cao-han-shu">公共槽函数</a></li>
<li><a href="#xin-hao">信号</a><ul>
<li><a href="#jing-tai-cheng-yuan-han-shu">静态成员函数</a></li>
</ul>
</li>
<li><a href="#chong-xie-bao-hu-cheng-yuan-han-shu">重写保护成员函数</a></li>
<li><a href="#xiang-xi-jie-shao">详细介绍</a></li>
<li><a href="#cheng-yuan-lei-xing-wen-dang">成员类型文档</a><ul>
<li><a href="#enum-qsslsocket-peerverifymode">enum QSslSocket::<strong>PeerVerifyMode</strong></a></li>
<li><a href="#enum-qsslsocket-sslmode">enum QSslSocket::<strong>SslMode</strong></a></li>
</ul>
</li>
<li><a href="#cheng-yuan-han-shu-wen-dang">成员函数文档</a><ul>
<li><a href="#qsslsocket-qsslsocket-qobject-o-qobject-qobject-md-parent-nullptr">QSslSocket::<strong>QSslSocket</strong>(</a><a href="../../O/QObject/QObject.md">QObject</a> *<em>parent</em> = nullptr)</li>
<li><a href="#signal-void-qsslsocket-encrypted"><em>[signal]</em> void <strong>QSslSocket</strong>::<strong>encrypted</strong>()</a></li>
<li><a href="#signal-void-qsslsocket-encryptedbyteswritten-qint64-written"><em>[signal]</em> void <strong>QSslSocket</strong>::<strong>encryptedBytesWritten</strong>(qint64 <em>written</em>)</a></li>
<li><a href="#slot-void-qsslsocket-ignoresslerrors"><em>[slot]</em> void <strong>QSslSocket</strong>::<strong>ignoreSslErrors</strong>()</a></li>
<li><a href="#signal-void-qsslsocket-modechanged-qsslsocket-sslmode-enum-qsslsocketsslmode-mode"><em>[signal]</em> void <strong>QSslSocket</strong>::<strong>modeChanged</strong>(</a><a href="#enum-qsslsocketsslmode">QSslSocket::SslMode</a> <em>mode</em>)</li>
<li><a href="#signal-void-qsslsocket-newsessionticketreceived"><em>[signal]</em> void <strong>QSslSocket</strong>::<strong>newSessionTicketReceived</strong>()</a></li>
<li><a href="#signal-void-qsslsocket-peerverifyerror-const-qsslerror-qsslerror-qsslerror-md-error"><em>[signal]</em> void <strong>QSslSocket</strong>::<strong>peerVerifyError</strong>(const </a><a href="../QSslError/QSslError.md">QSslError</a> &amp;<em>error</em>)</li>
<li><a href="#signal-void-qsslsocket-presharedkeyauthenticationrequired-qsslpresharedkeyauthenticator-qsslpresharedkeyauthenticator-qsslpresharedkeyauthenticator-md-authenticator"><em>[signal]</em> void <strong>QSslSocket</strong>::<strong>preSharedKeyAuthenticationRequired</strong>(</a><a href="../QSslPreSharedKeyAuthenticator/QSslPreSharedKeyAuthenticator.md">QSslPreSharedKeyAuthenticator</a> *<em>authenticator</em>)</li>
<li><a href="#signal-void-qsslsocket-sslerrors-const-qlist-l-qlist-qlist-md-qsslerror-qsslerror-qsslerror-md-errors"><em>[signal]</em> void <strong>QSslSocket</strong>::<strong>sslErrors</strong>(const </a><a href="../../L/QList/QList.md">QList</a>&lt;<a href="../QSslError/QSslError.md">QSslError</a>&gt; &amp;<em>errors</em>)</li>
<li><a href="#slot-void-qsslsocket-startclientencryption"><em>[slot]</em> void <strong>QSslSocket</strong>::<strong>startClientEncryption</strong>()</a></li>
<li><a href="#slot-void-qsslsocket-startserverencryption"><em>[slot]</em> void <strong>QSslSocket</strong>::<strong>startServerEncryption</strong>()</a></li>
<li><a href="#virtual-qsslsocket-qsslsocket"><em>[virtual]</em> <strong>QSslSocket</strong>::<strong>~QSslSocket</strong>()</a></li>
<li><a href="#void-qsslsocket-abort">void <strong>QSslSocket</strong>::<strong>abort</strong>()</a></li>
<li><a href="#override-virtual-bool-qsslsocket-atend-const"><em>[override virtual]</em> bool <strong>QSslSocket</strong>::<strong>atEnd</strong>() const</a></li>
<li><a href="#override-virtual-qint64-qsslsocket-bytesavailable-const"><em>[override virtual]</em> qint64 <strong>QSslSocket</strong>::<strong>bytesAvailable</strong>() const</a></li>
<li><a href="#override-virtual-qint64-qsslsocket-bytestowrite-const"><em>[override virtual]</em> qint64 <strong>QSslSocket</strong>::<strong>bytesToWrite</strong>() const</a></li>
<li><a href="#override-virtual-bool-qsslsocket-canreadline-const"><em>[override virtual]</em> bool <strong>QSslSocket</strong>::<strong>canReadLine</strong>() const</a></li>
<li><a href="#override-virtual-void-qsslsocket-close"><em>[override virtual]</em> void <strong>QSslSocket</strong>::<strong>close</strong>()</a></li>
<li><a href="#void-qsslsocket-connecttohostencrypted-const-qstring-s-qstring-qstring-md-hostname-quint16-port-qiodevice-openmode-mode-readwrite-qabstractsocket-networklayerprotocol-a-qabstractsocket-qabstractsocket-md-enum-qabstractsocketnetworklayerprotocol-protocol-anyipprotocol">void <strong>QSslSocket</strong>::<strong>connectToHostEncrypted</strong>(const </a><a href="../../S/QString/QString.md">QString</a> &amp;<em>hostName</em>, quint16 <em>port</em>, <a href>QIODevice::OpenMode</a> <em>mode</em> = ReadWrite, <a href="../../A/QAbstractSocket/QAbstractSocket.md#enum-qabstractsocketnetworklayerprotocol">QAbstractSocket::NetworkLayerProtocol</a> <em>protocol</em> = AnyIPProtocol)</li>
<li><a href="#void-qsslsocket-connecttohostencrypted-const-qstring-s-qstring-qstring-md-hostname-quint16-qthelp-org-qt-project-qtnetwork-5150-qtcore-qtglobal-html-quint16-typedef-port-const-qstring-s-qstring-qstring-md-sslpeername-qiodevice-openmode-mode-readwrite-qabstractsocket-networklayerprotocol-a-qabstractsocket-qabstractsocket-md-enum-qabstractsocketnetworklayerprotocol-protocol-anyipprotocol">void <strong>QSslSocket</strong>::<strong>connectToHostEncrypted</strong>(const </a><a href="../../S/QString/QString.md">QString</a> &amp;<em>hostName</em>, <a href="qthelp://org.qt-project.qtnetwork.5150/qtcore/qtglobal.html#quint16-typedef">quint16</a> <em>port</em>, const <a href="../../S/QString/QString.md">QString</a> &amp;<em>sslPeerName</em>, <a href>QIODevice::OpenMode</a> <em>mode</em> = ReadWrite, <a href="../../A/QAbstractSocket/QAbstractSocket.md#enum-qabstractsocketnetworklayerprotocol">QAbstractSocket::NetworkLayerProtocol</a> <em>protocol</em> = AnyIPProtocol)</li>
<li><a href="#qint64-qthelp-org-qt-project-qtnetwork-5150-qtcore-qtglobal-html-qint64-typedef-qsslsocket-encryptedbytesavailable-const">qint64</a></li>
<li><a href="#qint64-qthelp-org-qt-project-qtnetwork-5150-qtcore-qtglobal-html-qint64-typedef-qsslsocket-encryptedbytestowrite-const-1">qint64</a></li>
<li><a href="#bool-qsslsocket-flush">bool <strong>QSslSocket</strong>::<strong>flush</strong>()</a></li>
<li><a href="#void-qsslsocket-ignoresslerrors-const-qlist-qthelp-org-qt-project-qtnetwork-5150-qtcore-qlist-html-qsslerror-s-qsslerror-qsslerror-md-errors">void <strong>QSslSocket</strong>::<strong>ignoreSslErrors(const</strong> </a><a href="qthelp://org.qt-project.qtnetwork.5150/qtcore/qlist.html">QList</a>&lt;<a href="../../S/QSslError/QSslError.md">QSslError</a>&gt; &amp;<em>errors</em>)</li>
<li><a href="#bool-qsslsocket-isencrypted-const">bool <strong>QSslSocket</strong>::<strong>isEncrypted</strong>() const</a></li>
<li><a href="#qsslcertificate-s-qsslcertificate-qsslcertificate-md-qsslsocket-localcertificate-const">QSslCertificate</a></li>
<li><a href="#qlist-qthelp-org-qt-project-qtnetwork-5150-qtcore-qlist-html-qsslcertificate-s-qsslcertificate-qsslcertificate-md-qsslsocket-localcertificatechain-const">QList</a></li>
<li><a href="#qsslsocket-sslmode-enum-qsslsocketsslmode-qsslsocket-mode-const">QSslSocket::SslMode</a></li>
<li><a href="#qvector-qthelp-org-qt-project-qtnetwork-5150-qtcore-qvector-html-qocspresponse-o-qocspresponse-qocsprespons-md-qsslsocket-ocspresponses-const">QVector</a></li>
<li><a href="#qsslcertificate-s-qsslcertificate-qsslcertificate-md-qsslsocket-peercertificate-const-1">QSslCertificate</a></li>
<li><a href="#qlist-qthelp-org-qt-project-qtnetwork-5150-qtcore-qlist-html-qsslcertificate-s-qsslcertificate-qsslcertificate-md-qsslsocket-peercertificatechain-const-1">QList</a></li>
<li><a href="#int-qsslsocket-peerverifydepth-const">int <strong>QSslSocket</strong>::<strong>peerVerifyDepth</strong>() const</a></li>
<li><a href="#qsslsocket-peerverifymode-enum-qsslsocketpeerverifymode-qsslsocket-peerverifymode-const">QSslSocket::PeerVerifyMode</a></li>
<li><a href="#qstring-s-qstring-qstring-md-qsslsocket-peerverifyname-const">QString</a></li>
<li><a href="#qsslkey-s-qsslkey-qsslkey-md-qsslsocket-privatekey-const">QSslKey</a></li>
<li><a href="#qssl-sslprotocol-qssl-qssl-md-enum-qsslsslprotocol-qsslsocket-protocol-const">QSsl::SslProtocol</a></li>
<li><a href="#override-virtual-protected-qint64-qthelp-org-qt-project-qtnetwork-5150-qtcore-qtglobal-html-qint64-typedef-qsslsocket-readdata-char-data-qint64-qthelp-org-qt-project-qtnetwork-5150-qtcore-qtglobal-html-qint64-typedef-maxlen"><em>[override virtual protected]</em> </a><a href="qthelp://org.qt-project.qtnetwork.5150/qtcore/qtglobal.html#qint64-typedef">qint64</a> <strong>QSslSocket</strong>::<strong>readData</strong>(char *<em>data</em>, <a href="qthelp://org.qt-project.qtnetwork.5150/qtcore/qtglobal.html#qint64-typedef">qint64</a> <em>maxlen</em>)</li>
<li><a href="#override-virtual-void-qsslsocket-resume"><em>[override virtual]</em> void <strong>QSslSocket</strong>::<strong>resume</strong>()</a></li>
<li><a href="#qsslcipher-s-qsslcipher-qsslcipher-md-qsslsocket-sessioncipher-const">QSslCipher</a></li>
<li><a href="#qssl-sslprotocol-qthelp-org-qt-project-qtnetwork-5150-qtnetwork-qssl-html-sslprotocol-enum-qsslsocket-sessionprotocol-const-1">QSsl::SslProtocol</a></li>
<li><a href="#void-qsslsocket-setlocalcertificate-const-qsslcertificate-qthelp-org-qt-project-qtnetwork-5150-qtnetwork-qsslcertificate-html-certificate">void <strong>QSslSocket</strong>::<strong>setLocalCertificate</strong>(const </a><a href="qthelp://org.qt-project.qtnetwork.5150/qtnetwork/qsslcertificate.html">QSslCertificate</a> &amp;<em>certificate</em>)</li>
<li><a href="#void-qsslsocket-setlocalcertificate-const-qstring-qthelp-org-qt-project-qtnetwork-5150-qtcore-qstring-html-path-qssl-encodingformat-qthelp-org-qt-project-qtnetwork-5150-qtnetwork-qssl-html-encodingformat-enum-format-qssl-pem">void <strong>QSslSocket</strong>::<strong>setLocalCertificate</strong>(const </a><a href="qthelp://org.qt-project.qtnetwork.5150/qtcore/qstring.html">QString</a> &amp;<em>path</em>, <a href="qthelp://org.qt-project.qtnetwork.5150/qtnetwork/qssl.html#EncodingFormat-enum">QSsl::EncodingFormat</a> <em>format</em> = QSsl::Pem)</li>
<li><a href="#void-qsslsocket-setlocalcertificatechain-const-qlist-qthelp-org-qt-project-qtnetwork-5150-qtcore-qlist-html-qsslcertificate-qthelp-org-qt-project-qtnetwork-5150-qtnetwork-qsslcertificate-html-localchain">void <strong>QSslSocket</strong>::<strong>setLocalCertificateChain</strong>(const </a><a href="qthelp://org.qt-project.qtnetwork.5150/qtcore/qlist.html">QList</a>&lt;<a href="qthelp://org.qt-project.qtnetwork.5150/qtnetwork/qsslcertificate.html">QSslCertificate</a>&gt; &amp;<em>localChain</em>)</li>
<li><a href="#void-qsslsocket-setpeerverifydepth-int-depth">void <strong>QSslSocket</strong>::<strong>setPeerVerifyDepth</strong>(int <em>depth</em>)</a></li>
<li><a href="#void-qsslsocket-setpeerverifymode-qsslsocket-peerverifymode-qthelp-org-qt-project-qtnetwork-5150-qtnetwork-qsslsocket-html-peerverifymode-enum-mode">void <strong>QSslSocket</strong>::<strong>setPeerVerifyMode</strong>(</a><a href="qthelp://org.qt-project.qtnetwork.5150/qtnetwork/qsslsocket.html#PeerVerifyMode-enum">QSslSocket::PeerVerifyMode</a> <em>mode</em>)</li>
<li><a href="#void-qsslsocket-setpeerverifyname-const-qstring-qthelp-org-qt-project-qtnetwork-5150-qtcore-qstring-html-hostname">void <strong>QSslSocket</strong>::<strong>setPeerVerifyName</strong>(const </a><a href="qthelp://org.qt-project.qtnetwork.5150/qtcore/qstring.html">QString</a> &amp;<em>hostName</em>)</li>
<li><a href="#void-qsslsocket-setprivatekey-const-qsslkey-qthelp-org-qt-project-qtnetwork-5150-qtnetwork-qsslkey-html-key">void <strong>QSslSocket</strong>::<strong>setPrivateKey</strong>(const </a><a href="qthelp://org.qt-project.qtnetwork.5150/qtnetwork/qsslkey.html">QSslKey</a> &amp;<em>key</em>)</li>
<li><a href="#void-qsslsocket-setprivatekey-const-qstring-qthelp-org-qt-project-qtnetwork-5150-qtcore-qstring-html-filename-qssl-keyalgorithm-qthelp-org-qt-project-qtnetwork-5150-qtnetwork-qssl-html-keyalgorithm-enum-algorithm-qssl-rsa-qssl-encodingformat-qthelp-org-qt-project-qtnetwork-5150-qtnetwork-qssl-html-encodingformat-enum-format-qssl-pem-const-qbytearray-qthelp-org-qt-project-qtnetwork-5150-qtcore-qbytearray-html-passphrase-qbytearray">void <strong>QSslSocket</strong>::<strong>setPrivateKey</strong>(const </a><a href="qthelp://org.qt-project.qtnetwork.5150/qtcore/qstring.html">QString</a> &amp;<em>fileName</em>, <a href="qthelp://org.qt-project.qtnetwork.5150/qtnetwork/qssl.html#KeyAlgorithm-enum">QSsl::KeyAlgorithm</a> <em>algorithm</em> = QSsl::Rsa, <a href="qthelp://org.qt-project.qtnetwork.5150/qtnetwork/qssl.html#EncodingFormat-enum">QSsl::EncodingFormat</a> <em>format</em> = QSsl::Pem, const <a href="qthelp://org.qt-project.qtnetwork.5150/qtcore/qbytearray.html">QByteArray</a>&amp;<em>passPhrase</em> = QByteArray())</li>
<li><a href="#void-qsslsocket-setprotocol-qssl-sslprotocol-qthelp-org-qt-project-qtnetwork-5150-qtnetwork-qssl-html-sslprotocol-enum-protocol">void <strong>QSslSocket</strong>::<strong>setProtocol</strong>(</a><a href="qthelp://org.qt-project.qtnetwork.5150/qtnetwork/qssl.html#SslProtocol-enum">QSsl::SslProtocol</a> <em>protocol</em>)</li>
<li><a href="#override-virtual-void-qsslsocket-setreadbuffersize-qint64-qthelp-org-qt-project-qtnetwork-5150-qtcore-qtglobal-html-qint64-typedef-size"><em>[override virtual]</em> void <strong>QSslSocket</strong>::<strong>setReadBufferSize</strong>(</a><a href="qthelp://org.qt-project.qtnetwork.5150/qtcore/qtglobal.html#qint64-typedef">qint64</a> <em>size</em>)</li>
<li><a href="#override-virtual-void-qsslsocket-setsocketoption-qabstractsocket-socketoption-a-qabstractsocket-qabstractsocket-md-enum-qabstractsocketsocketoption-option-const-qvariant-qthelp-org-qt-project-qtnetwork-5150-qtcore-qvariant-html-value"><em>[override virtual]</em> void <strong>QSslSocket</strong>::<strong>setSocketOption</strong>(</a><a href="../../A/QAbstractSocket/QAbstractSocket.md#enum-qabstractsocketsocketoption">QAbstractSocket::SocketOption</a> <em>option</em>, const <a href="qthelp://org.qt-project.qtnetwork.5150/qtcore/qvariant.html">QVariant</a> &amp;<em>value</em>)</li>
<li><a href="#void-qsslsocket-setsslconfiguration-const-qsslconfiguration-qthelp-org-qt-project-qtnetwork-5150-qtnetwork-qsslconfiguration-html-configuration">void <strong>QSslSocket</strong>::<strong>setSslConfiguration</strong>(const </a><a href="qthelp://org.qt-project.qtnetwork.5150/qtnetwork/qsslconfiguration.html">QSslConfiguration</a> &amp;<em>configuration</em>)</li>
<li><a href="#override-virtual-qvariant-qthelp-org-qt-project-qtnetwork-5150-qtcore-qvariant-html-qsslsocket-socketoption-qabstractsocket-socketoption-a-qabstractsocket-qabstractsocket-md-enum-qabstractsocketsocketoption-option">[override virtual] </a><a href="qthelp://org.qt-project.qtnetwork.5150/qtcore/qvariant.html">QVariant</a> <strong>QSslSocket</strong>::<strong>socketOption</strong>(<a href="../../A/QAbstractSocket/QAbstractSocket.md#enum-qabstractsocketsocketoption">QAbstractSocket::SocketOption</a> <em>option</em>)</li>
<li><a href="#qsslconfiguration-qthelp-org-qt-project-qtnetwork-5150-qtnetwork-qsslconfiguration-html-qsslsocket-sslconfiguration-const">QSslConfiguration</a></li>
<li><a href="#qlist-qthelp-org-qt-project-qtnetwork-5150-qtcore-qlist-html-qsslerror-qthelp-org-qt-project-qtnetwork-5150-qtnetwork-qsslerror-html-qsslsocket-sslhandshakeerrors-const-2">QList</a></li>
<li><a href="#static-long-qsslsocket-ssllibrarybuildversionnumber"><em>[static]</em> long <strong>QSslSocket</strong>::<strong>sslLibraryBuildVersionNumber</strong>()</a></li>
<li><a href="#static-qstring-qthelp-org-qt-project-qtnetwork-5150-qtcore-qstring-html-qsslsocket-ssllibrarybuildversionstring"><em>[static]</em> </a><a href="qthelp://org.qt-project.qtnetwork.5150/qtcore/qstring.html">QString</a> <strong>QSslSocket</strong>::<strong>sslLibraryBuildVersionString</strong>()</li>
<li><a href="#static-long-qsslsocket-ssllibraryversionnumber"><em>[static]</em> long <strong>QSslSocket</strong>::<strong>sslLibraryVersionNumber</strong>()</a></li>
<li><a href="#static-qstring-qthelp-org-qt-project-qtnetwork-5150-qtcore-qstring-html-qsslsocket-ssllibraryversionstring"><em>[static]</em> </a><a href="qthelp://org.qt-project.qtnetwork.5150/qtcore/qstring.html">QString</a> <strong>QSslSocket</strong>::<strong>sslLibraryVersionString</strong>()</li>
<li><a href="#static-bool-qsslsocket-supportsssl"><em>[static]</em> bool <strong>QSslSocket</strong>::<strong>supportsSsl</strong>()</a></li>
<li><a href="#override-virtual-bool-qsslsocket-waitforbyteswritten-int-msecs-30000"><em>[override virtual]</em> bool <strong>QSslSocket</strong>::<strong>waitForBytesWritten</strong>(int <em>msecs</em> = 30000)</a></li>
<li><a href="#override-virtual-bool-qsslsocket-waitforconnected-int-msecs-30000"><em>[override virtual]</em> bool <strong>QSslSocket</strong>::<strong>waitForConnected</strong>(int <em>msecs</em> = 30000)</a></li>
<li><a href="#override-virtual-bool-qsslsocket-waitfordisconnected-int-msecs-30000"><em>[override virtual]</em> bool <strong>QSslSocket</strong>::<strong>waitForDisconnected</strong>(int <em>msecs</em> = 30000)</a></li>
<li><a href="#bool-qsslsocket-waitforencrypted-int-msecs-30000">bool <strong>QSslSocket</strong>::<strong>waitForEncrypted</strong>(int <em>msecs</em> = 30000)</a></li>
<li><a href="#override-virtual-bool-qsslsocket-waitforreadyread-int-msecs-30000"><em>[override virtual]</em> bool <strong>QSslSocket</strong>::<strong>waitForReadyRead</strong>(int <em>msecs</em> = 30000)</a></li>
<li><a href="#override-virtual-protected-qint64-qthelp-org-qt-project-qtnetwork-5150-qtcore-qtglobal-html-qint64-typedef-qsslsocket-writedata-const-char-data-qint64-qthelp-org-qt-project-qtnetwork-5150-qtcore-qtglobal-html-qint64-typedef-len"><em>[override virtual protected]</em> </a><a href="qthelp://org.qt-project.qtnetwork.5150/qtcore/qtglobal.html#qint64-typedef">qint64</a> QSslSocket::<strong>writeData</strong>(const char *<em>data</em>, <a href="qthelp://org.qt-project.qtnetwork.5150/qtcore/qtglobal.html#qint64-typedef">qint64</a> <em>len</em>)</li>
</ul>
</li>
</ul>
</li>
</ul>
<!-- tocstop -->

</div>
# QSslSocket Class

<p>QSslSocket 类为客户端和服务端提供了一个 SSL 加密的套接字。</p>
<table>
<thead>
<tr>
<th>属性</th>
<th>方法</th>
</tr>
</thead>
<tbody><tr>
<td>头文件</td>
<td><code>#include &lt;QSslSocket&gt;</code></td>
</tr>
<tr>
<td>qmake</td>
<td>QT += network</td>
</tr>
<tr>
<td>引入</td>
<td>Qt4.3</td>
</tr>
<tr>
<td>继承自</td>
<td>QTcpSocket</td>
</tr>
</tbody></table>
<p>该类最初在 Qt4.3 版本引入。</p>
<p>您可以在 <a href="../QSslSocket_Obsolete/QSslSocket_Obsolete.md">QSslSocket_Obsolete</a> 界面找到过时的成员函数介绍。</p>
<p><strong>注意：</strong> 该类所有的函数都是可重入的。</p>
<h2><span id="gong-gong-cheng-yuan-lei-xing">公共成员类型</span><a href="#gong-gong-cheng-yuan-lei-xing" class="header-anchor">#</a></h2><table>
<thead>
<tr>
<th>类型</th>
<th>属性</th>
</tr>
</thead>
<tbody><tr>
<td>enum</td>
<td><strong><a href="#enum-qsslsocketpeerverifymode">PeerVerifyMode</a></strong> { VerifyNone, QueryPeer, VerifyPeer, AutoVerifyPeer }</td>
</tr>
<tr>
<td>enum</td>
<td><strong><a href="#enum-qsslsocketsslmode">SslMode</a></strong> { UnencryptedMode, SslClientMode, SslServerMode }</td>
</tr>
</tbody></table>
<h2><span id="gong-gong-cheng-yuan-han-shu">公共成员函数</span><a href="#gong-gong-cheng-yuan-han-shu" class="header-anchor">#</a></h2><table>
<thead>
<tr>
<th>类型</th>
<th>函数名</th>
</tr>
</thead>
<tbody><tr>
<td></td>
<td><strong><a href="#qsslsocketqsslsocketqobject-parent--nullptr">QSslSocket</a></strong>(QObject *<em>parent</em> = nullptr)</td>
</tr>
<tr>
<td>virtual</td>
<td><strong><a href="#virtual-qsslsocketqsslsocket">~QSslSocket</a></strong>()</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="#void-qsslsocketabort">abort</a></strong>()</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="#void-qsslsocketconnecttohostencryptedconst-qstring-hostname-quint16-port-qiodeviceopenmode-mode--readwrite-qabstractsocketnetworklayerprotocol-protocol--anyipprotocol">connectToHostEncrypted</a></strong>(const QString &amp;<em>hostName</em>, quint16 <em>port</em>, QIODevice::OpenMode <em>mode</em> = ReadWrite, QAbstractSocket::NetworkLayerProtocol <em>protocol</em> = AnyIPProtocol)</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="#void-qsslsocketconnecttohostencryptedconst-qstring-hostname-quint16-port-const-qstring-sslpeername-qiodeviceopenmode-mode--readwrite-qabstractsocketnetworklayerprotocol-protocol--anyipprotocol">connectToHostEncrypted</a></strong>(const QString &amp;<em>hostName</em>, quint16 <em>port</em>, const QString &amp;<em>sslPeerName</em>, QIODevice::OpenMode <em>mode</em> = ReadWrite, QAbstractSocket::NetworkLayerProtocol <em>protocol</em> = AnyIPProtocol)</td>
</tr>
<tr>
<td>qint64</td>
<td><strong><a href="#qint64-qsslsocketencryptedbytesavailable-const">encryptedBytesAvailable</a></strong>() const</td>
</tr>
<tr>
<td>qint64</td>
<td><strong><a href="#qint64-qsslsocketencryptedbytestowrite-const">encryptedBytesToWrite</a></strong>() const</td>
</tr>
<tr>
<td>bool</td>
<td><strong><a href="#bool-qsslsocketflush">flush</a></strong>()</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="#void-qsslsocketignoresslerrorsconst-qlistqsslerror-errors">ignoreSslErrors</a></strong>(const QList&lt;QSslError&gt; &amp;<em>errors</em>)</td>
</tr>
<tr>
<td>bool</td>
<td><strong><a href="#bool-qsslsocketisencrypted-const">isEncrypted</a></strong>() const</td>
</tr>
<tr>
<td>QSslCertificate</td>
<td><strong><a href="#qsslcertificate-qsslsocketlocalcertificate-const">localCertificate</a></strong>() const</td>
</tr>
<tr>
<td>QList&lt;QSslCertificate&gt;</td>
<td><strong><a href="#qlistqsslcertificate-qsslsocketlocalcertificatechain-const">localCertificateChain</a></strong>() const</td>
</tr>
<tr>
<td>QSslSocket::SslMode</td>
<td><strong><a href="#qsslsocketsslmode-qsslsocketmode-const">mode</a></strong>() const</td>
</tr>
<tr>
<td>QVector&lt;QOcspResponse&gt;</td>
<td><strong><a href="#qvectorqocspresponse-qsslsocketocspresponses-const">ocspResponses</a></strong>() const</td>
</tr>
<tr>
<td>QSslCertificate</td>
<td><strong><a href="#qsslcertificate-qsslsocketpeercertificate-const">peerCertificate</a></strong>() const</td>
</tr>
<tr>
<td>QList&lt;QSslCertificate&gt;</td>
<td><strong><a href="#qlistqsslcertificate-qsslsocketpeercertificatechain-const">peerCertificateChain</a></strong>() const</td>
</tr>
<tr>
<td>int</td>
<td><strong><a href="#int-qsslsocketpeerverifydepth-const">peerVerifyDepth</a></strong>() const</td>
</tr>
<tr>
<td>QSslSocket::PeerVerifyMode</td>
<td><strong><a href="#qsslsocketpeerverifymode-qsslsocketpeerverifymode-const">peerVerifyMode</a></strong>() const</td>
</tr>
<tr>
<td>QString</td>
<td><strong><a href="#qstring-qsslsocketpeerverifyname-const">peerVerifyName</a></strong>() const</td>
</tr>
<tr>
<td>QSslKey</td>
<td><strong><a href="#qsslkey-qsslsocketprivatekey-const">privateKey</a></strong>() const</td>
</tr>
<tr>
<td>QSsl::SslProtocol</td>
<td><strong><a href="#qsslsslprotocol-qsslsocketprotocol-const">protocol</a></strong>() const</td>
</tr>
<tr>
<td>QSslCipher</td>
<td><strong><a href="#qsslcipher-qsslsocketsessioncipher-const">sessionCipher</a></strong>() const</td>
</tr>
<tr>
<td>QSsl::SslProtocol</td>
<td><strong><a href="#qsslsslprotocol-qsslsocketsessionprotocol-const">sessionProtocol</a></strong>() const</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="#void-qsslsocketsetlocalcertificateconst-qsslcertificate-certificate">setLocalCertificate</a></strong>(const QSslCertificate &amp;<em>certificate</em>)</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="#void-qsslsocketsetlocalcertificateconst-qstring-path-qsslencodingformat-format--qsslpem">setLocalCertificate</a></strong>(const QString &amp;<em>path</em>, QSsl::EncodingFormat <em>format</em> = QSsl::Pem)</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="#void-qsslsocketsetlocalcertificatechainconst-qlistqsslcertificate-localchain">setLocalCertificateChain</a></strong>(const QList&lt;QSslCertificate&gt; &amp;<em>localChain</em>)</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="#void-qsslsocketsetpeerverifydepthint-depth">setPeerVerifyDepth</a></strong>(int <em>depth</em>)</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="#void-qsslsocketsetpeerverifymodeqsslsocketpeerverifymode-mode">setPeerVerifyMode</a></strong>(QSslSocket::PeerVerifyMode <em>mode</em>)</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="#void-qsslsocketsetpeerverifynameconst-qstring-hostname">setPeerVerifyName</a></strong>(const QString &amp;<em>hostName</em>)</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="#void-qsslsocketsetprivatekeyconst-qsslkey-key">setPrivateKey</a></strong>(const QSslKey &amp;<em>key</em>)</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="#void-qsslsocketsetprivatekeyconst-qstring-filename-qsslkeyalgorithm-algorithm--qsslrsa-qsslencodingformat-format--qsslpem-const-qbytearraypassphrase--qbytearray">setPrivateKey</a></strong>(const QString &amp;<em>fileName</em>, QSsl::KeyAlgorithm <em>algorithm</em> = QSsl::Rsa, QSsl::EncodingFormat <em>format</em> = QSsl::Pem, const QByteArray &amp;<em>passPhrase</em> = QByteArray())</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="#void-qsslsocketsetprotocolqsslsslprotocol-protocol">setProtocol</a></strong>(QSsl::SslProtocol <em>protocol</em>)</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="#void-qsslsocketsetsslconfigurationconst-qsslconfiguration-configuration">setSslConfiguration</a></strong>(const QSslConfiguration &amp;<em>configuration</em>)</td>
</tr>
<tr>
<td>QSslConfiguration</td>
<td><strong><a href="#qsslconfiguration-qsslsocketsslconfiguration-const">sslConfiguration</a></strong>() const</td>
</tr>
<tr>
<td>QList&lt;QSslError&gt;</td>
<td><strong><a href="#qlistqsslerror-qsslsocketsslhandshakeerrors-const">sslHandshakeErrors</a></strong>() const</td>
</tr>
<tr>
<td>bool</td>
<td><strong><a href="#bool-qsslsocketwaitforencryptedint-msecs--30000">waitForEncrypted</a></strong>(int <em>msecs</em> = 30000)</td>
</tr>
</tbody></table>
<h2><span id="chong-xie-gong-gong-cheng-yuan-han-shu">重写公共成员函数</span><a href="#chong-xie-gong-gong-cheng-yuan-han-shu" class="header-anchor">#</a></h2><table>
<thead>
<tr>
<th>类型</th>
<th>函数名</th>
</tr>
</thead>
<tbody><tr>
<td>virtual bool</td>
<td><strong><a href="#override-virtual-bool-qsslsocketatend-const">atEnd</a></strong>() const override</td>
</tr>
<tr>
<td>virtual qint64</td>
<td><strong><a href="#override-virtual-qint64-qsslsocketbytesavailable-const">bytesAvailable</a></strong>() const override</td>
</tr>
<tr>
<td>virtual qint64</td>
<td><strong><a href="#override-virtual-qint64-qsslsocketbytestowrite-const">bytesToWrite</a></strong>() const override</td>
</tr>
<tr>
<td>virtual bool</td>
<td><strong><a href="#override-virtual-bool-qsslsocketcanreadline-const">canReadLine</a></strong>() const override</td>
</tr>
<tr>
<td>virtual void</td>
<td><strong><a href="#override-virtual-void-qsslsocketclose">close</a></strong>() override</td>
</tr>
<tr>
<td>virtual void</td>
<td><strong><a href="#override-virtual-void-qsslsocketresume">resume</a></strong>() override</td>
</tr>
<tr>
<td>virtual void</td>
<td><strong><a href="#override-virtual-void-qsslsocketsetreadbuffersizeqint64-size">setReadBufferSize</a></strong>(qint64 <em>size</em>) override</td>
</tr>
<tr>
<td>virtual bool</td>
<td><strong><a href="#override-virtual-qvariant-qsslsocketsocketoptionqabstractsocketsocketoption-option">setSocketDescriptor</a></strong>(qintptr <em>socketDescriptor</em>, QAbstractSocket::SocketState <em>state</em> = ConnectedState, QIODevice::OpenMode <em>openMode</em> = ReadWrite) override</td>
</tr>
<tr>
<td>virtual void</td>
<td><strong><a href="#override-virtual-qvariant-qsslsocketsocketoptionqabstractsocketsocketoption-option">setSocketOption</a></strong>(QAbstractSocket::SocketOption <em>option</em>, const QVariant &amp;<em>value</em>) override</td>
</tr>
<tr>
<td>virtual QVariant</td>
<td><strong><a href="#override-virtual-qvariant-qsslsocketsocketoptionqabstractsocketsocketoption-option">socketOption</a></strong>(QAbstractSocket::SocketOption <em>option</em>) override</td>
</tr>
<tr>
<td>virtual bool</td>
<td><strong><a href="#override-virtual-bool-qsslsocketwaitforbyteswrittenint-msecs--30000">waitForBytesWritten</a></strong>(int <em>msecs</em> = 30000) override</td>
</tr>
<tr>
<td>virtual bool</td>
<td><strong><a href="#override-virtual-bool-qsslsocketwaitforconnectedint-msecs--30000">waitForConnected</a></strong>(int <em>msecs</em> = 30000) override</td>
</tr>
<tr>
<td>virtual bool</td>
<td><strong><a href="#override-virtual-bool-qsslsocketwaitfordisconnectedint-msecs--30000">waitForDisconnected</a></strong>(int <em>msecs</em> = 30000) override</td>
</tr>
<tr>
<td>virtual bool</td>
<td><strong><a href="#override-virtual-bool-qsslsocketwaitforreadyreadint-msecs--30000">waitForReadyRead</a></strong>(int <em>msecs</em> = 30000) override</td>
</tr>
</tbody></table>
<h2><span id="gong-gong-cao-han-shu">公共槽函数</span><a href="#gong-gong-cao-han-shu" class="header-anchor">#</a></h2><table>
<thead>
<tr>
<th>类型</th>
<th>函数名</th>
</tr>
</thead>
<tbody><tr>
<td>void</td>
<td><strong><a href="#void-qsslsocketignoresslerrorsconst-qlistqsslerror-errors">ignoreSslErrors</a></strong>()</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="#slot-void-qsslsocketstartclientencryption">startClientEncryption</a></strong>()</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="#slot-void-qsslsocketstartserverencryption">startServerEncryption</a></strong>()</td>
</tr>
</tbody></table>
<h2><span id="xin-hao">信号</span><a href="#xin-hao" class="header-anchor">#</a></h2><table>
<thead>
<tr>
<th>类型</th>
<th>函数名</th>
</tr>
</thead>
<tbody><tr>
<td>void</td>
<td><strong><a href="#signal-void-qsslsocketencrypted">encrypted</a></strong>()</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="#signal-void-qsslsocketencryptedbyteswrittenqint64-written">encryptedBytesWritten</a></strong>(qint64 <em>written</em>)</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="#signal-void-qsslsocketmodechangedqsslsocketsslmode-mode">modeChanged</a></strong>(QSslSocket::SslMode <em>mode</em>)</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="#signal-void-qsslsocketnewsessionticketreceived">newSessionTicketReceived</a></strong>()</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="#signal-void-qsslsocketpeerverifyerrorconst-qsslerror-error">peerVerifyError</a></strong>(const QSslError &amp;<em>error</em>)</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="#signal-void-qsslsocketpresharedkeyauthenticationrequiredqsslpresharedkeyauthenticator-authenticator">preSharedKeyAuthenticationRequired</a></strong>(QSslPreSharedKeyAuthenticator *<em>authenticator</em>)</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="#signal-void-qsslsocketsslerrorsconst-qlistqsslerror-errors">sslErrors</a></strong>(const QList&lt;QSslError&gt; &amp;<em>errors</em>)</td>
</tr>
</tbody></table>
<h3><span id="jing-tai-cheng-yuan-han-shu">静态成员函数</span><a href="#jing-tai-cheng-yuan-han-shu" class="header-anchor">#</a></h3><table>
<thead>
<tr>
<th>类型</th>
<th>函数名</th>
</tr>
</thead>
<tbody><tr>
<td>long</td>
<td><strong><a href="#static-long-qsslsocketssllibrarybuildversionnumber">sslLibraryBuildVersionNumber</a></strong>()</td>
</tr>
<tr>
<td>QString</td>
<td><strong><a href="#static-qstring-qsslsocketssllibrarybuildversionstring">sslLibraryBuildVersionString</a></strong>()</td>
</tr>
<tr>
<td>long</td>
<td><strong><a href="#static-long-qsslsocketssllibraryversionnumber">sslLibraryVersionNumber</a></strong>()</td>
</tr>
<tr>
<td>QString</td>
<td><strong><a href="#static-long-qsslsocketssllibraryversionnumber">sslLibraryVersionString</a></strong>()</td>
</tr>
<tr>
<td>bool</td>
<td><strong><a href="#static-bool-qsslsocketsupportsssl">supportsSsl</a></strong>()</td>
</tr>
</tbody></table>
<h2><span id="chong-xie-bao-hu-cheng-yuan-han-shu">重写保护成员函数</span><a href="#chong-xie-bao-hu-cheng-yuan-han-shu" class="header-anchor">#</a></h2><table>
<thead>
<tr>
<th>类型</th>
<th>函数名</th>
</tr>
</thead>
<tbody><tr>
<td>virtual qint64</td>
<td><strong><a href="#override-virtual-protected-qint64-qsslsocketreaddatachar-data-qint64-maxlen">readData</a></strong>(char *<em>data</em>, qint64 <em>maxlen</em>) override</td>
</tr>
<tr>
<td>virtual qint64</td>
<td><strong><a href="#override-virtual-protected-qint64-qsslsocketwritedataconst-char-data-qint64-len">writeData</a></strong>(const char *<em>data</em>, qint64 <em>len</em>) override</td>
</tr>
</tbody></table>
<h2><span id="xiang-xi-jie-shao">详细介绍</span><a href="#xiang-xi-jie-shao" class="header-anchor">#</a></h2><p>QSslSocket 能够建立一个安全的、加密的 TCP 连接，您可以使用该连接来传输加密数据。在服务器端和客户端都可以使用它，并且他支持现代的 SSL 协议，包括 SSL 3 和 TLS 1.2。默认情况下，QSslSocket 仅仅使用被认为是安全的（ <a href="../QSsl/QSsl.md#enum-qsslsslprotocol">QSsl::SecureProtocols</a> ） SSL 协议，但是只要处在握手开始之前，您仍然可以调用 <a href="#void-qsslsocketsetprotocolqsslsslprotocol-protocol">setProtocol</a>() 函数来更改 SSL 协议。</p>
<p>在套接字进入 <em>已连接</em>（<a href="../../A/QAbstractSocket/QAbstractSocket.md#enum-qabstractsocketsocketstate">ConnectedState</a> ）状态后，SSL 将在现有 TCP 流上进行加密。有两种使用 QSslSocket 建立安全连接的简单方法：使用即时 SSL 握手，或在未加密模式下建立连接之后的延迟 SSL 握手。</p>
<p>最常见的 QSslSocket 使用方法是构造一个对象后使用 <a href="#void-qsslsocketconnecttohostencryptedconst-qstring-hostname-quint16-port-qiodeviceopenmode-mode--readwrite-qabstractsocketnetworklayerprotocol-protocol--anyipprotocol">connectToHostEncrypted</a>() 函数开启一个安全连接，这种方法会在连接建立后开启一个即时的 SSL 握手。</p>
<div class="code-wrapper"><pre><code class="hljs cpp">QSslSocket *socket = <span class="hljs-keyword">new</span> <span class="hljs-built_in">QSslSocket</span>(<span class="hljs-keyword">this</span>);
<span class="hljs-built_in">connect</span>(socket, <span class="hljs-built_in">SIGNAL</span>(<span class="hljs-built_in">encrypted</span>()), <span class="hljs-keyword">this</span>, <span class="hljs-built_in">SLOT</span>(<span class="hljs-built_in">ready</span>()));

socket-&gt;<span class="hljs-built_in">connectToHostEncrypted</span>(<span class="hljs-string">"imap.example.com"</span>, <span class="hljs-number">993</span>);</code></pre></div>

<p>与普通的 <a href="../../T/QTcpSocket/QTcpSocket.md">QTcpSocket</a> 相同，若成功建立连接， QSslSocket 会依次进入 <a href="../../A/QAbstractSocket/QAbstractSocket.md#enum-qabstractsocketsocketstate">HostLookupState</a> ，<a href="../../A/QAbstractSocket/QAbstractSocket.md#enum-qabstractsocketsocketstate">ConnectingState</a> 和 <a href="(../../A/QAbstractSocket/QAbstractSocket.md#enum-qabstractsocketsocketstate)">ConnectedState</a> 状态。连接成功后，握手会自动开始，若握手连接成功，QSsslSocket 将会发送 <a href="#signal-void-qsslsocketencrypted">encrypted</a>() 信号，表明该套接字已经进入加密状态并准备好使用。</p>
<p>请注意，在 <a href="#void-qsslsocketconnecttohostencryptedconst-qstring-hostname-quint16-port-qiodeviceopenmode-mode--readwrite-qabstractsocketnetworklayerprotocol-protocol--anyipprotocol">connectToHostEncrypted</a>() 函数执行完成返回后（即 <a href="#signal-void-qsslsocketencrypted">encrypted</a>() 信号发出之前）数据就可以立即写入套接字。此时写入到套接字的数据将会被加入等待队列，直到 <a href="#signal-void-qsslsocketencrypted">encrypted</a>() 信号被发出。</p>
<p>使用延迟 SSL 握手来保护现有连接的示例是 SSL 服务器保护传入连接。</p>
<p>假设您继承 <a href="../../T/QTcpServer/QTcpServer.md">QTcpServer</a> 类创建了一个 SSL 服务器类。您需要如下例重写 <a href="../../T/QTcpServer/QTcpServer.md#virtual-protected-void-qtcpserverincomingconnectionqintptrsocketdescriptor">QTcpServer::incomingConnection</a>() ：首先构造一个 QSslSocket 对象并调用 <a href="#override-virtual-qvariant-qsslsocketsocketoptionqabstractsocketsocketoption-option">setSocketDescriptor</a>() 函数将新的套接字描述符设置为传入的已有的套接字描述符。然后调用 <a href="#slot-void-qsslsocketstartserverencryption">startServerEncryption</a>() 函数初始化 SSL 握手。</p>
<div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">SslServer::incomingConnection</span><span class="hljs-params">(qintptr socketDescriptor)</span></span>
<span class="hljs-function"></span>{
    QSslSocket *serverSocket = <span class="hljs-keyword">new</span> QSslSocket;
    <span class="hljs-keyword">if</span> (serverSocket-&gt;<span class="hljs-built_in">setSocketDescriptor</span>(socketDescriptor)) {
        <span class="hljs-built_in">addPendingConnection</span>(serverSocket);
        <span class="hljs-built_in">connect</span>(serverSocket, &amp;QSslSocket::encrypted, <span class="hljs-keyword">this</span>, &amp;SslServer::ready);
        serverSocket-&gt;<span class="hljs-built_in">startServerEncryption</span>();
    } <span class="hljs-keyword">else</span> {
        <span class="hljs-keyword">delete</span> serverSocket;
    }
}</code></pre></div>

<p>如果出现了错误， QSslSocket 将会发出 <a href="#signal-void-qsslsocketsslerrorsconst-qlistqsslerror-errors">sslErrors</a>() 信号。在这种情况下，如果没有采取任何操作去忽略出现的错误，该连接将会掉线。若要出现错误后仍然继续维持连接，您可以在错误发生后的槽函数中，或者 QSslSocket 对象构建后、尝试连接之前，调用 <a href="#void-qsslsocketignoresslerrorsconst-qlistqsslerror-errors">ignoreSslErrors</a>() 函数。<a href="#void-qsslsocketignoresslerrorsconst-qlistqsslerror-errors">ignoreSslErrors</a>() 函数将允许 QSslSocket 忽略在建立对等方身份时遇到的错误。 应谨慎使用 <a href="#void-qsslsocketignoresslerrorsconst-qlistqsslerror-errors">ignoreSslErrors</a>() 函数忽略SSL握手期间的错误，因为安全连接的基本特征是应该通过成功的握手来建立它们。</p>
<p>连接加密后，您可以像普通的 <a href="../../T/QTcpSocket/QTcpSocket.md">QTcpSocket</a> 类一样使用 QSslSocket。当 readyRead() 信号发出后，您可以调用 read()，<a href="#override-virtual-bool-qsslsocketcanreadline-const">canReadLine</a>() 和 readLine() 或者 getChar() 从 QSslSocket 的内部缓冲区中读取加密数据，然后您可以调用 write() 或者 putChar() 向对等端写回数据。 QSslSocket 将会自动将您写入的数据加密并在数据写入到对等端后发送 <a href="#signal-void-qsslsocketencryptedbyteswrittenqint64-written">encryptedBytesWritten</a>() 信号。</p>
<p>方便起见，QSslSocket 支持 <a href="../../T/QTcpSocket/QTcpSocket.md">QTcpSocket</a> 的阻塞函数：<a href="../../A/QAbstractSocket/QAbstractSocket.md#virtual-bool-qabstractsocketwaitforconnectedint-msecs--30000">waitForConnected</a>()，<a href="../../A/QAbstractSocket/QAbstractSocket.md#override-virtual-bool-qabstractsocketwaitforreadyreadint-msecs--30000">waitForReadyRead</a>()，<a href="../../A/QAbstractSocket/QAbstractSocket.md#override-virtual-bool-qabstractsocketwaitforbyteswrittenint-msecs--30000">waitForBytesWritten</a>() 和 <a href="../../A/QAbstractSocket/QAbstractSocket.md#virtual-bool-qabstractsocketwaitfordisconnectedint-msecs--30000">waitForDisconnected</a>()。它也提供了 <a href="#bool-qsslsocketwaitforencryptedint-msecs--30000">waitForEncrypted</a>() 函数来在加密连接建立之前阻塞调用的线程。</p>
<div class="code-wrapper"><pre><code class="hljs cpp">QSslSocket socket;
socket.<span class="hljs-built_in">connectToHostEncrypted</span>(<span class="hljs-string">"http.example.com"</span>, <span class="hljs-number">443</span>);
<span class="hljs-keyword">if</span> (!socket.<span class="hljs-built_in">waitForEncrypted</span>()) {
    <span class="hljs-built_in">qDebug</span>() &lt;&lt; socket.<span class="hljs-built_in">errorString</span>();
    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
}

socket.<span class="hljs-built_in">write</span>(<span class="hljs-string">"GET / HTTP/1.0\r\n\r\n"</span>);
<span class="hljs-keyword">while</span> (socket.<span class="hljs-built_in">waitForReadyRead</span>())
    <span class="hljs-built_in">qDebug</span>() &lt;&lt; socket.<span class="hljs-built_in">readAll</span>().<span class="hljs-built_in">data</span>();</code></pre></div>

<p>QSslSocket 提供了广泛的、易于使用的 API ，用于处理密码，私钥以及本地，对等端和证书颁发机构（CA）证书。它也为处理握手阶段出现的错误提供了 API 支持。</p>
<p>以下的特性也可以被客制化：</p>
<ul>
<li>套接字的加密密码套件可以在握手阶段之前通过 <a href="qthelp%EF%BC%9A//org.qt-project.qtnetwork.5150/qtnetwork/qsslconfiguration.html#setCiphers">QSslConfiguration :: setCiphers</a>() 和 QSslConfiguration :: setDefaultCiphers() 定制。</li>
<li>套接字的本地证书和私钥可以在握手阶段之前通过 <a href="#void-qsslsocketsetlocalcertificateconst-qsslcertificate-certificate">setLocalCertificate</a>() 和 <a href="#void-qsslsocketsetprivatekeyconst-qsslkey-key">setPrivateKey</a>() 设置。</li>
<li>CA 证书数据可以通过 <a href="qthelp://org.qt-project.qtnetwork.5150/qtnetwork/qsslconfiguration.html#addCaCertificate">QSslConfiguration::addCaCertificate</a>() 和 <a href="qthelp://org.qt-project.qtnetwork.5150/qtnetwork/qsslconfiguration.html#addCaCertificates">QSslConfiguration::addCaCertificates</a>() 扩展和定制。</li>
</ul>
<p>要扩展在 SSL 握手期间 SSL 套接字使用的<em>默认</em> CA 证书列表，您必须像下面的代码片段一样更新默认配置：</p>
<div class="code-wrapper"><pre><code class="hljs cpp">QList&lt;QSslCertificate&gt; certificates = <span class="hljs-built_in">getCertificates</span>();
QSslConfiguration configuration = QSslConfiguration::<span class="hljs-built_in">defaultConfiguration</span>();
configuration.<span class="hljs-built_in">addCaCertificates</span>(certificates);
QSslConfiguration::<span class="hljs-built_in">setDefaultConfiguration</span>(configuration);</code></pre></div>

<p><strong>注意：</strong> 在 Unix 系统（ macOS 除外）下，如果可能的话，QSslSocket 将从标准证书目录中按需加载根证书。如果您不想按需家在根证书，则您需要在应用程序进行首次 SSL 握手之前（例如通过 QSslSocket::systemCaCertificates() 传递证书）调用 <a href="qthelp://org.qt-project.qtnetwork.5150/qtnetwork/qsslconfiguration.html#defaultConfiguration">QSslConfiguration::defaultConfiguration</a>()::setCaCertificates() ，或者在您的 QSslSocket 实例进行 SSL 握手前调用 <a href="qthelp://org.qt-project.qtnetwork.5150/qtnetwork/qsslconfiguration.html#defaultConfiguration">QSslConfiguration::defaultConfiguration</a>()::setCaCertificates() 。</p>
<p>您也可以在 <a href="../QSslCipher/QSslCipher.md">QSslCipher</a> 和 <a href="../QSslCertificate/QSslCertificate.md">QSslCertificate</a> 类文档中找到关于密钥与证书的信息。</p>
<p>该产品包括了由 OpenSSL Project 项目开发的，可在 OpenSSL Toolkit 工具包中使用的软件 (<a target="_blank" rel="noopener" href="http://www.openssl.org/">http://www.openssl.org/</a>) 。</p>
<p><strong>注意：</strong> 要注意 bytesWritten() 信号和 <a href="#signal-void-qsslsocketencryptedbyteswrittenqint64-written">encryptedBytesWritten</a>() 信号之间的差别。 对于 <a href="../../T/QTcpSocket/QTcpSocket.md">QTcpSocket</a> 类来说，一旦数据被写入到 TCP 套接字， bytesWritten() 信号就会被发出。 对 QSslSocket 类来说，当数据正在被加密时，bytesWritten() 信号将会被发出；当数据写入到 TCP 套接字后，<a href="#signal-void-qsslsocketencryptedbyteswrittenqint64-written">encryptedBytesWritten</a>() 信号将会被发出。</p>
<p>另外您也可以在 <a href="../QSslCertificate/QSslCertificate.md">QSslCertificate</a>，<a href="../QSslCipher/QSslCipher.md">QSslCipher</a> 和 <a href="../QSslError/QSslError.md">QSslError</a> 类文档中找到相关信息。</p>
<h2><span id="cheng-yuan-lei-xing-wen-dang">成员类型文档</span><a href="#cheng-yuan-lei-xing-wen-dang" class="header-anchor">#</a></h2><h3><span id="enum-qsslsocket-peerverifymode">enum QSslSocket::<strong>PeerVerifyMode</strong></span><a href="#enum-qsslsocket-peerverifymode" class="header-anchor">#</a></h3><p>描述了 QSslSocket 的对等端验证模式。默认模式为 <em>自动验证对等端</em> (<em>AutoVerifyPeer</em>)，该模式下将会根据 <a href="#enum-qsslsocketsslmode">QSslSocket::SslMode</a> 选择一个合适的验证模式 。</p>
<table>
<thead>
<tr>
<th align="left">常量</th>
<th align="left">值</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">QSslSocket::VerifyNone</td>
<td align="left">0</td>
<td align="left">QSslSocket 将不会请求对等端发送证书。如果您对连接的另一端的身份并不感兴趣，您可以使用该模式。连接依旧会被加密，如果对等端需要您的本地证书，套接字仍然会发送本地套接字到对等端。</td>
</tr>
<tr>
<td align="left">QSslSocket::QueryPeer</td>
<td align="left">1</td>
<td align="left">QSslSocket 将会请求对等端发送一个证书，但是并不需要该证书有效。如果您想向用户展示对等端证书的详细信息，但是并不象影响实际的 SSL 握手，可以考虑使用该模式。该模式是服务器的默认模式。注意：在频道(Schannel)中该值与 QSslSocket::VerifyNone 效果相同。</td>
</tr>
<tr>
<td align="left">QSslSocket::VerifyPeer</td>
<td align="left">2</td>
<td align="left">This mode is the default for clients.QSslSocket 将在握手阶段请求对等端发送一个有效的证书。如果失败，QSslSocket 将会发送 QSslSocket::<a href="#signal-void-qsslsocketsslerrorsconst-qlistqsslerror-errors">sslErrors</a>() 信号。</td>
</tr>
<tr>
<td align="left">QSslSocket::AutoVerifyPeer</td>
<td align="left">3</td>
<td align="left"><a href="qthelp://org.qt-project.qtnetwork.5150/qtnetwork/qsslsocket.html">QSslSocket</a> will automatically use QueryPeer for server sockets and VerifyPeer for client sockets.自动模式。服务端 QSslSocket 会自动使用 QueryPeer 模式，客户端 QSslSocket 会自动使用 AutoVerifyPeer 模式。</td>
</tr>
</tbody></table>
<p>该枚举最初在 Qt 4.4 引入。</p>
<p>另外您也可以在 <a href="#qsslsocketpeerverifymode-qsslsocketpeerverifymode-const">QSslSocket::peerVerifyMode</a>() 函数介绍中找到相关信息。</p>
<hr>
<h3><span id="enum-qsslsocket-sslmode">enum QSslSocket::<strong>SslMode</strong></span><a href="#enum-qsslsocket-sslmode" class="header-anchor">#</a></h3><p>描述了 QSslSocket 可用的连接模式。</p>
<table>
<thead>
<tr>
<th align="left">常量</th>
<th align="left">值</th>
<th align="left">Description</th>
</tr>
</thead>
<tbody><tr>
<td align="left">QSslSocket::UnencryptedMode</td>
<td align="left">0</td>
<td align="left">未加密套接字，该行为与 <a href="../../T/QTcpSocket/QTcpSocket.md">QTcpSocket</a> 相同。</td>
</tr>
<tr>
<td align="left">QSslSocket::SslClientMode</td>
<td align="left">1</td>
<td align="left">该套接字为客户端 SSL 套接字。它既可以已经被加密，也可以处于握手阶段（详情见 <a href="#bool-qsslsocketisencrypted-const">QSslSocket::isEncrypted</a>() ）。</td>
</tr>
<tr>
<td align="left">QSslSocket::SslServerMode</td>
<td align="left">2</td>
<td align="left">该套接字为服务端 SSL 套接字。它既可以已经被加密，也可以处于握手阶段（详情见 <a href="#bool-qsslsocketisencrypted-const">QSslSocket::isEncrypted</a>() ）。</td>
</tr>
</tbody></table>
<h2><span id="cheng-yuan-han-shu-wen-dang">成员函数文档</span><a href="#cheng-yuan-han-shu-wen-dang" class="header-anchor">#</a></h2><h3><span id="qsslsocket-qsslsocket-qobject-parent-nullptr">QSslSocket::<strong>QSslSocket</strong>( *<em>parent</em> = nullptr)</span><a href="#qsslsocket-qsslsocket-qobject-parent-nullptr" class="header-anchor">#</a></h3><p>构造一个 QSslSocket 对象。<em>parent</em> 参数将传递给 <a href="../../O/QObject/QObject.md">QObject</a> 构造函数。新套接字的密钥套件设置为静态方法 defaultCiphers() 返回的一个密钥。</p>
<hr>
<h3><span id="signal-void-qsslsocket-encrypted"><em>[signal]</em> void <strong>QSslSocket</strong>::<strong>encrypted</strong>()</span><a href="#signal-void-qsslsocket-encrypted" class="header-anchor">#</a></h3><p>当 QSslSocket 进入加密模式时将发出该信号。该信号发送后， <a href="#bool-qsslsocketisencrypted-const">QSslSocket::isEncrypted</a>() 将会返回 <em>true</em>，并且接下来套接字上的传输都将被加密。</p>
<p>另外您也可以在 <a href="#void-qsslsocketconnecttohostencryptedconst-qstring-hostname-quint16-port-qiodeviceopenmode-mode--readwrite-qabstractsocketnetworklayerprotocol-protocol--anyipprotocol">QSslSocket::connectToHostEncrypted</a>() 和 <a href="#bool-qsslsocketisencrypted-const">QSslSocket::isEncrypted</a>() 函数介绍中找到相关信息。</p>
<hr>
<h3><span id="signal-void-qsslsocket-encryptedbyteswritten-qint64-written"><em>[signal]</em> void <strong>QSslSocket</strong>::<strong>encryptedBytesWritten</strong>(qint64 <em>written</em>)</span><a href="#signal-void-qsslsocket-encryptedbyteswritten-qint64-written" class="header-anchor">#</a></h3><p>当 QSslSocket 将加密数据写入到网路后将会发出该信号。 <em>written</em> 参数包含着成功写入的字节书。</p>
<p>该函数最初在 Qt 4.4 版本引入。</p>
<p>另外您也可以在 QIODevice::bytesWritten() 函数介绍中找到相关信息。</p>
<hr>
<h3><span id="slot-void-qsslsocket-ignoresslerrors"><em>[slot]</em> void <strong>QSslSocket</strong>::<strong>ignoreSslErrors</strong>()</span><a href="#slot-void-qsslsocket-ignoresslerrors" class="header-anchor">#</a></h3><p>该函数会让 QSslSocket 忽略握手期间的错误并继续连接。如果您想要让 QSslSocket 在握手期间即使出现错误仍继续链接，您必须在链接到 sslErrors() 信号的槽函数中调用该槽函数或者在握手阶段之前调用该槽函数。如果您不调用该函数，在 sslErrors() 信号发送后，无论是在回应错误期间还是在握手期间之前，连接都会断开。</p>
<p>如果 SSL 握手期间没有发生任何错误（即对等端的身份成功建立），QSslSocket 不会发送 sslErrors() 信号，因而在此时调用该函数是没有任何必要的。</p>
<p><strong>警告：</strong> 确保始终让用户检查 sslErrors() 信号报告的错误，并且仅在用户确认可以继续进行操作时才调用此方法。如果发生了以外的错误，连接应当被取消。未经检查实际的错误就盲目的调用该函数会给您的应用程序带来极大的安全隐患。请谨慎使用该函数！</p>
<p>另外您也可以在 <a href="#signal-void-qsslsocketsslerrorsconst-qlistqsslerror-errors">sslErrors</a>() 函数介绍中找到相关信息。</p>
<hr>
<h3><span id="signal-void-qsslsocket-modechanged-qsslsocket-sslmode-mode"><em>[signal]</em> void <strong>QSslSocket</strong>::<strong>modeChanged</strong>( <em>mode</em>)</span><a href="#signal-void-qsslsocket-modechanged-qsslsocket-sslmode-mode" class="header-anchor">#</a></h3><p>当 QSslSocket 从 <a href="#enum-qsslsocketsslmode">QSslSocket::UnencryptedMode</a> 模式变为 <a href="#enum-qsslsocketsslmode">QSslSocket::SslClient</a> 模式或者 <a href="#enum-qsslsocketsslmode">QSslSocket::SslServerMode</a> 模式后会发出该信号。 参数 <em>mode</em> 即新的模式。</p>
<p>另外您也可以在 <a href="#qsslsocketsslmode-qsslsocketmode-const">mode</a>() 函数介绍中找到相关信息。</p>
<hr>
<h3><span id="signal-void-qsslsocket-newsessionticketreceived"><em>[signal]</em> void <strong>QSslSocket</strong>::<strong>newSessionTicketReceived</strong>()</span><a href="#signal-void-qsslsocket-newsessionticketreceived" class="header-anchor">#</a></h3><p>如果在握手期间协商了 TLS 1.3 协议，QSslSocket 会在接收到新的会话票据（ SessionTicket ）后发送该信号。会话和会话票据的生命周期的示意会在套接字的配置中更新。该会话可用于将来的 TLS 连接中的会话恢复（和缩短的握手）。</p>
<p><strong>注意：</strong> 该功能仅支持 OpenSSL 后端，并要求 OpenSSL 版本 1.1.1及以上。</p>
<p>该函数最初在 Qt 5.15 版本引入。</p>
<p>另外您也可以在 QSslSocket::<a href="#qsslconfiguration-qsslsocketsslconfiguration-const">sslConfiguration</a>()，QSslConfiguration::<a href>sessionTicket</a>() 和 QSslConfirguration::sessionTicketLifeTimeHint() 函数介绍中找到相关信息。</p>
<hr>
<h3><span id="signal-void-qsslsocket-peerverifyerror-const-qsslerror-amp-error"><em>[signal]</em> void <strong>QSslSocket</strong>::<strong>peerVerifyError</strong>(const  &amp;<em>error</em>)</span><a href="#signal-void-qsslsocket-peerverifyerror-const-qsslerror-amp-error" class="header-anchor">#</a></h3><p>QSslSocket 在握手期间、加密连接建立之前，可以多次发出该信号来表明对等端身份建立时出现错误。<em>error</em> 参通常表示了 QSslSocket 不能安全地鉴定对等端身份。</p>
<p>当遇到问题时该信号会给你提供早期的指示。通过连接该信号，您可以在连接的槽函数中在握手完成前手动结束该连接。如果该信号发送后未采取任何操作， QSslSocket 会继续发送 QSslSocket::sslErrors() 信号。</p>
<p>该函数最初在 Qt 4.4 版本引入。</p>
<p>另外您也可以在 <a href="#signal-void-qsslsocketsslerrorsconst-qlistqsslerror-errors">sslErrors</a>() 函数介绍中找到相关信息。</p>
<hr>
<h3><span id="signal-void-qsslsocket-presharedkeyauthenticationrequired-qsslpresharedkeyauthenticator-authenticator"><em>[signal]</em> void <strong>QSslSocket</strong>::<strong>preSharedKeyAuthenticationRequired</strong>( *<em>authenticator</em>)</span><a href="#signal-void-qsslsocket-presharedkeyauthenticationrequired-qsslpresharedkeyauthenticator-authenticator" class="header-anchor">#</a></h3><p>QSslSocket 在协商 PSK 密码套件时发出此信号，并且接下来会要求 PSK 身份验证。</p>
<p>当使用 PSK 时，为了使 SSL 握手继续执行，客户端必须向服务端发送一个有效的身份证明和一个有效的预分享密钥。应用程序可以通过一个连接到该信号的槽函数提供这些信息，根据他们的需求来填充传输的 <em>authenticator</em> 对象。</p>
<p><strong>注意：</strong> 忽略该信号或者提供信用材料失败会造成握手失败，该连接也会因而被取消。</p>
<p><strong>注意：</strong> <em>authenticator</em> 对象由该套接字所有并且不能被应用程序删除。</p>
<p>该函数最初在 Qt 5.5 版本引入。</p>
<p>另外您也可以在 <a href="../QSslPreSharedKeyAuthenticator/QSslPreSharedKeyAuthenticator.md">QSslPreSharedKeyAuthenticator</a> 类文档中找到相关信息。</p>
<hr>
<h3><span id="signal-void-qsslsocket-sslerrors-const-qlist-lt-qsslerror-gt-amp-errors"><em>[signal]</em> void <strong>QSslSocket</strong>::<strong>sslErrors</strong>(const &lt;&gt; &amp;<em>errors</em>)</span><a href="#signal-void-qsslsocket-sslerrors-const-qlist-lt-qsslerror-gt-amp-errors" class="header-anchor">#</a></h3><p>在握手期间，QSslSocket 会发送该信号表明在建立对等端身份鉴定的时候出现了一个或者多个错误。这些错误通常表明 QSslSocket 不能安全的鉴定对等端的身份。除非采取相关的操作，否则该连接将会在该信号发出后断开。</p>
<p>如果您想要忽略发生的错误并继续连接，您必须在连接到该信号的槽函数中调用 <a href="#void-qsslsocketignoresslerrorsconst-qlistqsslerror-errors">QsslSocket::ignoreSslErrors</a>() 函数。如果您想要在稍后获得错误列表，您可以调用 <a href="#qlistqsslerror-qsslsocketsslhandshakeerrors-const">sslHandshakeErrors</a>() 函数。</p>
<p><em>error</em> 参数包括着一个或者多个阻止 QSslSocket 验证对等端身份的错误。</p>
<p><strong>注意：</strong> 连接该信号时，您不能使用 Qt::QueuedConnection 方式，否则调用 <a href="#void-qsslsocketignoresslerrorsconst-qlistqsslerror-errors">QsslSocket::ignoreSslErrors</a>() 函数将不会起任何作用。</p>
<p><strong>注意：</strong> 信号 <em>sslErrors</em> 在该类中被重载。为了通过使用函数指针连接到该信号，Qt 提供了一个便捷的助手来包含函数指针，示例如下：</p>
<div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-built_in">connect</span>(sslSocket, QOverload&lt;<span class="hljs-type">const</span> QList&lt;QSslError&gt; &amp;&gt;::<span class="hljs-built_in">of</span>(&amp;QSslSocket::sslErrors),
     [=](<span class="hljs-type">const</span> QList&lt;QSslError&gt; &amp;errors){ <span class="hljs-comment">/* ... */</span> });</code></pre></div>

<p>另外您也可以在 <a href="#signal-void-qsslsocketpeerverifyerrorconst-qsslerror-error">peerVerifyError</a>() 函数介绍中找到相关信息。</p>
<hr>
<h3><span id="slot-void-qsslsocket-startclientencryption"><em>[slot]</em> void <strong>QSslSocket</strong>::<strong>startClientEncryption</strong>()</span><a href="#slot-void-qsslsocket-startclientencryption" class="header-anchor">#</a></h3><p>为客户端连接开启一个 SSL 延迟握手。您可以在套接字处于<strong>已连接</strong>且仍然处于<strong>未加密模式</strong>时调用该槽函数。如果该套接字处于未连接状态或者该套接字已经进入加密模式，则该函数将不会生效。</p>
<p>重新实现了 STARTTLS 的客户端经常会利用延迟 SSL 握手。其他大部分客户端可以使用 <a href="#void-qsslsocketconnecttohostencryptedconst-qstring-hostname-quint16-port-qiodeviceopenmode-mode--readwrite-qabstractsocketnetworklayerprotocol-protocol--anyipprotocol">connectToHostEncrypted</a>() 函数来替代该函数，connectToHostEncrypted() 函数将会自动执行握手。</p>
<hr>
<h3><span id="slot-void-qsslsocket-startserverencryption"><em>[slot]</em> void <strong>QSslSocket</strong>::<strong>startServerEncryption</strong>()</span><a href="#slot-void-qsslsocket-startserverencryption" class="header-anchor">#</a></h3><p>为服务端连接开启延迟 SSL 握手。您可以在套接字处于<strong>已连接</strong>且仍然处于<strong>未加密模式</strong>时调用该槽函数。如果该套接字处于未连接状态或者该套接字已经进入加密模式，则该函数将不会生效。</p>
<p>对于服务端套接字来说，调用该函数是初始化 SSL 握手的唯一方式。大多数服务端会在接收到一个连接、或者接收到一个进入 SSL 模式的指定协议指令（例如：服务端接收到 “STARTTLS\r\n”）时，立即调用该函数。</p>
<p>实现一个 SSL 服务器最常用的的方式是创建一个 <a href="../../T/QTcpServer/QTcpServer.md">QTcpServer</a> 并且重新实现 <a href="../../T/QTcpServer/QTcpServer.md#virtual-protected-void-qtcpserverincomingconnectionqintptrsocketdescriptor">QTcpServer::incomingConnection()</a> 函数。将返回的套接字描述符传递给 <a href="#override-virtual-qvariant-qsslsocketsocketoptionqabstractsocketsocketoption-option">QSslSOcket::setSocketDescriptor()</a>。</p>
<p>另外您也可以在 <a href="#void-qsslsocketconnecttohostencryptedconst-qstring-hostname-quint16-port-qiodeviceopenmode-mode--readwrite-qabstractsocketnetworklayerprotocol-protocol--anyipprotocol">connectToHostEncrypted</a>() 和 <a href="#slot-void-qsslsocketstartclientencryption">startClientEncryption</a>() 函数介绍中找到相关信息。</p>
<hr>
<h3><span id="virtual-qsslsocket-qsslsocket"><em>[virtual]</em> <strong>QSslSocket</strong>::<strong>~QSslSocket</strong>()</span><a href="#virtual-qsslsocket-qsslsocket" class="header-anchor">#</a></h3><p>析构函数。销毁 QSslSocket 对象。</p>
<hr>
<h3><span id="void-qsslsocket-abort">void <strong>QSslSocket</strong>::<strong>abort</strong>()</span><a href="#void-qsslsocket-abort" class="header-anchor">#</a></h3><p>关闭连接并将套接字重新初始化。不像 <a href="../../A/QAbstractSocket/QAbstractSocket.md#virtual-void-qabstractsocketdisconnectfromhost">disconnectFromHost</a>() 函数，该还书会立即关闭套接字，并清空任何在写入缓冲区的数据。</p>
<p>另外您也可以在 <a href="../../A/QAbstractSocket/QAbstractSocket.md#virtual-void-qabstractsocketdisconnectfromhost">disconnectFromHost</a>() 和 <a href="#override-virtual-void-qsslsocketclose">close</a>() 函数介绍中找到相关信息。</p>
<hr>
<h3><span id="override-virtual-bool-qsslsocket-atend-const"><em>[override virtual]</em> bool <strong>QSslSocket</strong>::<strong>atEnd</strong>() const</span><a href="#override-virtual-bool-qsslsocket-atend-const" class="header-anchor">#</a></h3><p>重新实现：<a href="../../A/QAbstractSocket/QAbstractSocket.md#override-virtual-bool-qabstractsocketatend-const">QAbstractSocket::atEnd</a>() 。</p>
<hr>
<h3><span id="override-virtual-qint64-qsslsocket-bytesavailable-const"><em>[override virtual]</em> qint64 <strong>QSslSocket</strong>::<strong>bytesAvailable</strong>() const</span><a href="#override-virtual-qint64-qsslsocket-bytesavailable-const" class="header-anchor">#</a></h3><p>重新实现：<a href="../../A/QAbstractSocket/QAbstractSocket.md#override-virtual-qint64-qabstractsocketbytesavailable-const">QAbstractSocket::bytesAvailable</a>()。</p>
<p>返回可以立即读取的已解密数据的字节数。</p>
<hr>
<h3><span id="override-virtual-qint64-qsslsocket-bytestowrite-const"><em>[override virtual]</em> qint64 <strong>QSslSocket</strong>::<strong>bytesToWrite</strong>() const</span><a href="#override-virtual-qint64-qsslsocket-bytestowrite-const" class="header-anchor">#</a></h3><p>重新实现：<a href="../../A/QAbstractSocket/QAbstractSocket.md#override-virtual-qint64-qabstractsocketbytestowrite-const">QAbstractSocket::bytesToWrite</a>()。</p>
<p>返回等待被加密和写入到网络的未加密数据的字节数。</p>
<hr>
<h3><span id="override-virtual-bool-qsslsocket-canreadline-const"><em>[override virtual]</em> bool <strong>QSslSocket</strong>::<strong>canReadLine</strong>() const</span><a href="#override-virtual-bool-qsslsocket-canreadline-const" class="header-anchor">#</a></h3><p>重新实现：<a href="../../A/QAbstractSocket/QAbstractSocket.md#override-virtual-bool-qabstractsocketcanreadline-const">QAbstractSocket::canReadLine</a>()。</p>
<p>若能读取一行已解密的数据（以一个 ASCII 字符 ‘\n’ 结束 ）则返回 true，否则返回 false 。</p>
<hr>
<h3><span id="override-virtual-void-qsslsocket-close"><em>[override virtual]</em> void <strong>QSslSocket</strong>::<strong>close</strong>()</span><a href="#override-virtual-void-qsslsocket-close" class="header-anchor">#</a></h3><p>重新实现：<a href="../../A/QAbstractSocket/QAbstractSocket.md#override-virtual-void-qabstractsocketclose">QAbstractSocket::close</a>()。</p>
<hr>
<h3><span id="void-qsslsocket-connecttohostencrypted-const-qstring-amp-hostname-quint16-port-qiodevice-openmode-mode-readwrite-qabstractsocket-networklayerprotocol-protocol-anyipprotocol">void <strong>QSslSocket</strong>::<strong>connectToHostEncrypted</strong>(const  &amp;<em>hostName</em>, quint16 <em>port</em>,  <em>mode</em> = ReadWrite,  <em>protocol</em> = AnyIPProtocol)</span><a href="#void-qsslsocket-connecttohostencrypted-const-qstring-amp-hostname-quint16-port-qiodevice-openmode-mode-readwrite-qabstractsocket-networklayerprotocol-protocol-anyipprotocol" class="header-anchor">#</a></h3><p>使用 <em>mode</em> 指定的 <a href>OpenMode</a>，在 <em>hostName</em> 指定的主机的 <em>port</em> 指定的端口上启动一个加密连接。该函数的作用与调用 <a href="../../A/QAbstractSocket/QAbstractSocket.md#virtual-void-qabstractsocketconnecttohostconst-qstring-hostname-quint16-port-qiodeviceopenmode-openmode--readwrite-qabstractsocketnetworklayerprotocol-protocol--anyipprotocol">connectToHost</a>() 函数建立连接然后使用 <a href="#slot-void-qsslsocketstartclientencryption">startClientEncryption</a>() 函数相同。<em>protocol</em> 参数可以用来指定网络协议（例如 IPv4 或者 IPv6）。</p>
<p>QSslSocket 首先会进入<em>查询主机</em>（<a href="../../A/QAbstractSocket/QAbstractSocket.md#enum-qabstractsocketsocketstate">HostLookupState</a>）状态。然后，套接字会进入事件循环或者一个 waitFor…() 函数，进入<em>连接中</em>（<a href="../../A/QAbstractSocket/QAbstractSocket.md#enum-qabstractsocketsocketstate">ConnectingState</a>）状态，连接成功后，套接字会发出 <a href="../../A/QAbstractSocket/QAbstractSocket.md#signal-void-qabstractsocketconnected">connected</a>() 信号。紧接着套接字会初始化 SSL 客户端握手。每次状态发生改变后， QSslSocket 都会发出 <a href="../../A/QAbstractSocket/QAbstractSocket.md#signal-void-qabstractsocketstatechangedqabstractsocketsocketstate-socketstate">stateChanged</a>() 信号。</p>
<p>初始化 SSL 客户端握手后，若对等端身份认证未能成功建立，套接字将会发出 sslErrors() 信号。如果你想忽略出现的错误并继续连接，您必须在连接到 sslErrors() 信号的槽函数中或者在进入加密模式之前调用 <a href="#void-qsslsocketignoresslerrorsconst-qlistqsslerror-errors">ignoreSslErrors</a>() 函数。如果没有调用 <a href="#void-qsslsocketignoresslerrorsconst-qlistqsslerror-errors">ignoreSslErrors</a>() 函数，该连接将会断开，并发出 <a href="../../A/QAbstractSocket/QAbstractSocket.md#signal-void-qabstractsocketdisconnected">disconnected</a>() 信号，返回到<em>未连接</em>（<a href="../../A/QAbstractSocket/QAbstractSocket.md#enum-qabstractsocketsocketstate">UnconnectedState</a>）状态。</p>
<p>若 SSL 握手连接建立成功，套接字将会发出 <a href="#signal-void-qsslsocketencrypted">encrypted</a>() 信号。</p>
<div class="code-wrapper"><pre><code class="hljs cpp">QSslSocket socket;
<span class="hljs-built_in">connect</span>(&amp;socket, <span class="hljs-built_in">SIGNAL</span>(<span class="hljs-built_in">encrypted</span>()), receiver, <span class="hljs-built_in">SLOT</span>(<span class="hljs-built_in">socketEncrypted</span>()));

socket.<span class="hljs-built_in">connectToHostEncrypted</span>(<span class="hljs-string">"imap"</span>, <span class="hljs-number">993</span>);
socket-&gt;<span class="hljs-built_in">write</span>(<span class="hljs-string">"1 CAPABILITY\r\n"</span>);</code></pre></div>

<p><strong>注意：</strong> 上面的例子中文本可以在请求加密连接之后、 <a href="#signal-void-qsslsocketencrypted">encrypted</a>() 信号发出之前立即写入套接字中。在这种情况下，文本将会在对象中队列，并在连接建立且 <a href="#signal-void-qsslsocketencrypted">encrypted</a>() 信号发出后写入到套接字中。</p>
<p><em>mode</em> 参数的默认值为<em>读写</em> （<a href>ReadWrite</a>）。</p>
<p>如果您想在服务器端创建一个 QSslSocket，您应该在 <a href="../../T/QTcpServer/QTcpServer.md">QTcpServer</a> 接收到新接入连接后调用 <a href="#slot-void-qsslsocketstartserverencryption">startServerEncryption</a>() 函数。</p>
<p>另外您也可以在 <a href="../../A/QAbstractSocket/QAbstractSocket.md#virtual-void-qabstractsocketconnecttohostconst-qstring-hostname-quint16-port-qiodeviceopenmode-openmode--readwrite-qabstractsocketnetworklayerprotocol-protocol--anyipprotocol">connectToHost</a>()，<a href="#slot-void-qsslsocketstartclientencryption">startClientEncryption</a>() ，<a href="../../A/QAbstractSocket/QAbstractSocket.md#virtual-bool-qabstractsocketwaitforconnectedint-msecs--30000">waitForConnected</a>() 和 <a href="#bool-qsslsocketwaitforencryptedint-msecs--30000">waitForEncrypted</a>() 函数介绍中找到相关介绍。</p>
<hr>
<h3><span id="void-qsslsocket-connecttohostencrypted-const-qstring-amp-hostname-quint16-port-const-qstring-amp-sslpeername-qiodevice-openmode-mode-readwrite-qabstractsocket-networklayerprotocol-protocol-anyipprotocol">void <strong>QSslSocket</strong>::<strong>connectToHostEncrypted</strong>(const  &amp;<em>hostName</em>,  <em>port</em>, const  &amp;<em>sslPeerName</em>,  <em>mode</em> = ReadWrite,  <em>protocol</em> = AnyIPProtocol)</span><a href="#void-qsslsocket-connecttohostencrypted-const-qstring-amp-hostname-quint16-port-const-qstring-amp-sslpeername-qiodevice-openmode-mode-readwrite-qabstractsocket-networklayerprotocol-protocol-anyipprotocol" class="header-anchor">#</a></h3><p>重载函数。</p>
<p>与非重载版本的 connectToHostEncrypted 相比，该重载方法允许使用 <em>sslPeerName</em> 指定的证书服务器。</p>
<p>该函数最初在 Qt 4.6 版本引入。</p>
<p>另外您也可以在 <a href="#void-qsslsocketconnecttohostencryptedconst-qstring-hostname-quint16-port-const-qstring-sslpeername-qiodeviceopenmode-mode--readwrite-qabstractsocketnetworklayerprotocol-protocol--anyipprotocol">connectToHostEncrypted</a>() 函数介绍中找到相关信息。</p>
<hr>
<h3><span id="qint64-qsslsocket-encryptedbytesavailable-const"> <strong>QSslSocket</strong>::<strong>encryptedBytesAvailable</strong>() const</span><a href="#qint64-qsslsocket-encryptedbytesavailable-const" class="header-anchor">#</a></h3><p>返回等待解密的数据的字节数。通常来说，在 <a href="../../S/QSslSocket/QSslSocket.md">QSslSocket</a> 接收到数据便立即解密的情况下，该函数会返回 0。</p>
<p>该函数最初在 Qt 4.4 版本引入。</p>
<hr>
<h3><span id="qint64-qsslsocket-encryptedbytestowrite-const"> <strong>QSslSocket</strong>::<strong>encryptedBytesToWrite</strong>() const</span><a href="#qint64-qsslsocket-encryptedbytestowrite-const" class="header-anchor">#</a></h3><p>返回等待加密的准备写入网络的数据的字节数。</p>
<p>该函数最初在 Qt 4.4 版本引入。</p>
<hr>
<h3><span id="bool-qsslsocket-flush">bool <strong>QSslSocket</strong>::<strong>flush</strong>()</span><a href="#bool-qsslsocket-flush" class="header-anchor">#</a></h3><p>该函数会在不引起阻塞的情况下 ，尽量多地往内部写缓冲区写入数据。若写入了任何数据，该函数将会返回 true ，否则返回 false 。</p>
<p>如果您想要立即发送缓冲的数据，您可以调用此函数。可成功写入的数据的字节数取决于操作系统。在大多情况下您并不需要调用此函数，因为 <a href="../../A/QAbstractSocket/QAbstractSocket.md">QAbstractSocket</a> 会在重获事件循环控制权后会自动开始发送数据。在没有事件循环情况下，请调用 <a href="#override-virtual-bool-qsslsocketwaitforbyteswrittenint-msecs--30000">waitForBytesWritten</a>()。</p>
<p>另外您也可以在 write() 和 <a href="#override-virtual-bool-qsslsocketwaitforbyteswrittenint-msecs--30000">waitForBytesWritten</a>() 函数介绍中找到相关信息。</p>
<hr>
<h3><span id="void-qsslsocket-ignoresslerrors-const-qlist-lt-qsslerror-gt-amp-errors">void <strong>QSslSocket</strong>::<strong>ignoreSslErrors(const</strong> &lt;&gt; &amp;<em>errors</em>)</span><a href="#void-qsslsocket-ignoresslerrors-const-qlist-lt-qsslerror-gt-amp-errors" class="header-anchor">#</a></h3><p>重载函数。</p>
<p>该方法可令 QSslSocket 仅忽略 <em>errors</em> 指定的错误。</p>
<p><strong>注意：</strong> 因为大部分的 SSL 错误都与一个证书相关联，因而对于大多数 SSL 错误您都必须设置一个相关的预期证书。例如，如果要连接到使用自签名证书的服务器，请考虑使用以下代码段：</p>
<div class="code-wrapper"><pre><code class="hljs cpp">QList&lt;QSslCertificate&gt; cert = QSslCertificate::<span class="hljs-built_in">fromPath</span>(<span class="hljs-built_in">QLatin1String</span>(<span class="hljs-string">"server-certificate.pem"</span>));
<span class="hljs-function">QSslError <span class="hljs-title">error</span><span class="hljs-params">(QSslError::SelfSignedCertificate, cert.at(<span class="hljs-number">0</span>))</span></span>;
QList&lt;QSslError&gt; expectedSslErrors;
expectedSslErrors.<span class="hljs-built_in">append</span>(error);

QSslSocket socket;
socket.<span class="hljs-built_in">ignoreSslErrors</span>(expectedSslErrors);
socket.<span class="hljs-built_in">connectToHostEncrypted</span>(<span class="hljs-string">"server.tld"</span>, <span class="hljs-number">443</span>);</code></pre></div>

<p>对该函数的多次调用会替换掉先前调用该函数时传入的错误列表。若您想清空忽略错误的列表，您可以将一个空列表作为参数调用该函数。</p>
<p>另外您也可以在 <a href="#signal-void-qsslsocketsslerrorsconst-qlistqsslerror-errors">sslErrors</a>() 和 <a href="#qlistqsslerror-qsslsocketsslhandshakeerrors-const">sslHandshakeErrors</a>() 函数介绍中找到相关信息。</p>
<hr>
<h3><span id="bool-qsslsocket-isencrypted-const">bool <strong>QSslSocket</strong>::<strong>isEncrypted</strong>() const</span><a href="#bool-qsslsocket-isencrypted-const" class="header-anchor">#</a></h3><p>若该套接字已加密，则返回 true ，否则返回 false。</p>
<p>一个已加密的套接字会将由 write() 函数和 putChar() 函数写入的数据在写入前全部加密，并在调用 read() 函数和 readLine() 函数或者 getChar() 函数前，将从网络中接收的数据解密。</p>
<p>在进入加密模式后， QSslSocket 会发送 <a href="#signal-void-qsslsocketencrypted">encrypted</a>() 信号。</p>
<p>您可以调用 <a href="#qsslcipher-qsslsocketsessioncipher-const">sessionCipher</a>() 函数来查看加密和解密数据使用的密码。</p>
<p>另外您也可以在 <a href="#qsslsocketsslmode-qsslsocketmode-const">mode</a>() 函数介绍中找到相关信息。</p>
<hr>
<h3><span id="qsslcertificate-qsslsocket-localcertificate-const"> <strong>QSslSocket</strong>::<strong>localCertificate</strong>() const</span><a href="#qsslcertificate-qsslsocket-localcertificate-const" class="header-anchor">#</a></h3><p>返回套接字的本地<a href="./../S/QSslCertificate/QSslCertificate.md">证书</a>，若未指定本地证书则返回一个空证书。</p>
<p>另外您也可以在 <a href="#void-qsslsocketsetlocalcertificateconst-qsslcertificate-certificate">setLocalCertificate</a>() 函数和 <a href="#qsslkey-qsslsocketprivatekey-const">privateKey</a>() 函数介绍中找到相关信息。</p>
<hr>
<h3><span id="qlist-lt-qsslcertificate-gt-qsslsocket-localcertificatechain-const">&lt;&gt; <strong>QSslSocket</strong>::<strong>localCertificateChain</strong>() const</span><a href="#qlist-lt-qsslcertificate-gt-qsslsocket-localcertificatechain-const" class="header-anchor">#</a></h3><p>返回套接字的本地<a href="./../S/QSslCertificate/QSslCertificate.md">证书</a>链，若未指定本地证书则返回一个空的列表。</p>
<p>该函数最初在 Qt 5.1 版本引入。</p>
<p>另外您也可以在 <a href="#void-qsslsocketsetlocalcertificatechainconst-qlistqsslcertificate-localchain">setLocalCertificateChain</a>() 函数介绍中找到相关信息。</p>
<hr>
<h3><span id="qsslsocket-sslmode-qsslsocket-mode-const"> <strong>QSslSocket</strong>::<strong>mode</strong>() const</span><a href="#qsslsocket-sslmode-qsslsocket-mode-const" class="header-anchor">#</a></h3><p>返回该套接字当前的模式。当 QSslSocket 与 QTcpSocket 的行为相同，则为 <em>未加密</em> （*<a href="#enum-qsslsocketsslmode">UnencryptedMode</a><em>） 模式。当处于加密模式，则为 <em>客户端</em> （</em><a href="#enum-qsslsocketsslmode">SslClientMode</a><em>）和 <em>服务端</em> （</em><a href="#enum-qsslsocketsslmode">SslServerMode</a>*）模式之一。</p>
<p>当模式发生改变，QSslSocket 会发出 <a href>modeChanged</a>() 信号。</p>
<hr>
<h3><span id="qvector-lt-qocspresponse-gt-qsslsocket-ocspresponses-const">&lt;&gt; <strong>QSslSocket</strong>::<strong>ocspResponses</strong>() const</span><a href="#qvector-lt-qocspresponse-gt-qsslsocket-ocspresponses-const" class="header-anchor">#</a></h3><p>此函数返回使用 OCSP 的服务器在 TLS 握手期间可能发送的联机证书状态协议响应。 如果没有确定的响应或根本没有响应，则返回的 QVector 容器为空。</p>
<p>该函数最早在 Qt 5.13 引入。</p>
<p>另外您也可以在 <a href="qthelp://org.qt-project.qtnetwork.5151/qtnetwork/qsslconfiguration.html#setOcspStaplingEnabled">QSslConfiguration::setOcspStaplingEnabled</a>() 函数介绍中找到相关信息。</p>
<hr>
<h3><span id="qsslcertificate-qsslsocket-peercertificate-const"> <strong>QSslSocket</strong>::<strong>peerCertificate</strong>() const</span><a href="#qsslcertificate-qsslsocket-peercertificate-const" class="header-anchor">#</a></h3><p>返回对等端的数字证书（即您所连接到的主机的即时证书），若对等端未签署证书则返回一个空证书。</p>
<p>在握手阶段对等端证书会被自动检查，所以该函数通常用来抓取证书以向用户展示或者诊断连接。返回的证书包含着对等端的主机名、证书发行者和对等端公钥等对等端信息。</p>
<p>因为对等端证书是在握手阶段设置的，因而在连接到 <a href="#signal-void-qsslsocketsslerrorsconst-qlistqsslerror-errors">sslErrors</a>() 和 encrypted() 信号的槽函数中获取对等端证书的行为是安全的。</p>
<p>如果该函数返回了一个空证书，则意味着 SSL 握手失败，或者也意味着你链接到的主机并没有证书，或者您甚至没有建立一个连接。</p>
<p>如果您想要检查对等端完整的证书链，您可以调用 <a href="#qlistqsslcertificate-qsslsocketpeercertificatechain-const">peerCertificateChain</a>() 函数来一次性获取所有的证书链。</p>
<p>另外您也可以在 <a href="#qlistqsslcertificate-qsslsocketpeercertificatechain-const">peerCertificateChain</a>() 函数介绍中找到相关信息。</p>
<hr>
<h3><span id="qlist-lt-qsslcertificate-gt-qsslsocket-peercertificatechain-const">&lt;&gt; <strong>QSslSocket</strong>::<strong>peerCertificateChain</strong>() const</span><a href="#qlist-lt-qsslcertificate-gt-qsslsocket-peercertificatechain-const" class="header-anchor">#</a></h3><p>返回对等端的数字证书链，或者返回一个空的证书列表。</p>
<p>在握手阶段对等端证书会被自动检查，所以该函数通常用来抓取证书以向用户展示或者诊断连接。返回的证书包含着对等端的主机名、证书发行者和对等端公钥等对等端信息。</p>
<p>因为对等端证书是在握手阶段设置的，因而在连接到 <a href="#signal-void-qsslsocketsslerrorsconst-qlistqsslerror-errors">sslErrors</a>() 和 encrypted() 信号的槽函数中获取对等端证书的行为是安全的。</p>
<p>如果该函数返回了一个空的证书列表，则意味着 SSL 握手失败，或者也意味着你链接到的主机并没有证书，或者您甚至没有建立一个连接。</p>
<p>如果您仅想获得对等端的即时证书，请使用 <a href="#qsslcertificate-qsslsocketpeercertificate-const">peerCertificate</a>() 函数。</p>
<p>另外您也可以在 <a href="#qsslcertificate-qsslsocketpeercertificate-const">peerCertificate</a>() 函数介绍中找到相关介绍。</p>
<hr>
<h3><span id="int-qsslsocket-peerverifydepth-const">int <strong>QSslSocket</strong>::<strong>peerVerifyDepth</strong>() const</span><a href="#int-qsslsocket-peerverifydepth-const" class="header-anchor">#</a></h3><p>返回对等端的证书链在 SSL 握手阶段要检查的最大的证书数目。若没有设置最大值，则返回0（意味着将会检查正歌证书链）。</p>
<p>证书将会以发行顺序检查，首先检查对等端私有证书，紧接着检查发行者证书，然后继续检查。</p>
<p>该函数最初在 Qt 4.4 版本引入。</p>
<p>另外您也可以在 <a href="#void-qsslsocketsetpeerverifydepthint-depth">setPeerVerifyDepth</a>() 函数和 <a href="#qsslsocketpeerverifymode-qsslsocketpeerverifymode-const">peerVerifyMode</a>() 函数介绍中找到相关信息。</p>
<hr>
<h3><span id="qsslsocket-peerverifymode-qsslsocket-peerverifymode-const"> <strong>QSslSocket</strong>::<strong>peerVerifyMode</strong>() const</span><a href="#qsslsocket-peerverifymode-qsslsocket-peerverifymode-const" class="header-anchor">#</a></h3><p>返回套接字的验证模式。该模式决定 QSslSocket 是否应当从对等端请求一个证书（即客户端从服务器请求一个证书或服务端从客户端请求一个整数），以及它所请求的证书是否必须使有效的。</p>
<p>默认的模式时 <a href="#enum-qsslsocketpeerverifymode">AutoVerifyPeer</a>，该模式下 QSslSocket 将为客户端使用 <a href="#enum-qsslsocketpeerverifymode">VerifyPeer</a>，为服务端使用 <a href="#enum-qsslsocketpeerverifymode">QueryPeer</a>。</p>
<p>该函数最初在 Qt 4.4 版本引入。</p>
<p>另外您也可以在 <a href="#void-qsslsocketsetpeerverifymodeqsslsocketpeerverifymode-mode">setPeerVerifyMode</a>() ， <a href="#void-qsslsocketsetpeerverifydepthint-depth">setPeerVerifyDepth</a>() 和 <a href="#qsslsocketsslmode-qsslsocketmode-const">mode</a>() 函数介绍中找到相关信息。</p>
<hr>
<h3><span id="qstring-qsslsocket-peerverifyname-const"> <strong>QSslSocket</strong>::<strong>peerVerifyName</strong>() const</span><a href="#qstring-qsslsocket-peerverifyname-const" class="header-anchor">#</a></h3><p>返回由 <a href="#void-qsslsocketsetpeerverifynameconst-qstring-hostname">setPeerVerifyName</a>() 设置的或者 <a href="#void-qsslsocketconnecttohostencryptedconst-qstring-hostname-quint16-port-const-qstring-sslpeername-qiodeviceopenmode-mode--readwrite-qabstractsocketnetworklayerprotocol-protocol--anyipprotocol">connectToHostEncrypted</a>() 函数提供的证书有效性检验信息的主机别名。</p>
<p>该函数最初在 Qt 4.8 版本引入。</p>
<p>另外你也可以在 <a href="#void-qsslsocketsetpeerverifynameconst-qstring-hostname">setPeerVerifyName</a>() 和 <a href="#void-qsslsocketconnecttohostencryptedconst-qstring-hostname-quint16-port-const-qstring-sslpeername-qiodeviceopenmode-mode--readwrite-qabstractsocketnetworklayerprotocol-protocol--anyipprotocol">connectToHostEncrypted</a>() 函数介绍中找到相关信息。</p>
<hr>
<h3><span id="qsslkey-qsslsocket-privatekey-const"> <strong>QSslSocket</strong>::<strong>privateKey</strong>() const</span><a href="#qsslkey-qsslsocket-privatekey-const" class="header-anchor">#</a></h3><p>返回套接字的私钥。</p>
<p>另外您也可以在 <a href="#void-qsslsocketsetprivatekeyconst-qsslkey-key">setPrivateKey</a>( 和 <a href="#qsslcertificate-qsslsocketlocalcertificate-const">localCertificate</a>() 函数介绍中找到相关信息。</p>
<hr>
<h3><span id="qssl-sslprotocol-qsslsocket-protocol-const"> <strong>QSslSocket</strong>::<strong>protocol</strong>() const</span><a href="#qssl-sslprotocol-qsslsocket-protocol-const" class="header-anchor">#</a></h3><p>返回套接字的 SSL 协议。默认将使用 <a href="../../S/QSsl/QSsl.md#enum-qsslsslprotocol">QSsl::SecureProtocols</a> 协议。</p>
<p>另外您也可以在 <a href="#void-qsslsocketsetprotocolqsslsslprotocol-protocol">setProtocol</a>() 函数介绍中找到相关信息。</p>
<hr>
<h3><span id="override-virtual-protected-qint64-qsslsocket-readdata-char-data-qint64-maxlen"><em>[override virtual protected]</em>  <strong>QSslSocket</strong>::<strong>readData</strong>(char *<em>data</em>,  <em>maxlen</em>)</span><a href="#override-virtual-protected-qint64-qsslsocket-readdata-char-data-qint64-maxlen" class="header-anchor">#</a></h3><p>重新实现： <a href="../../A/QAbstractSocket/QAbstractSocket.md#override-virtual-protected-qint64-qabstractsocketreaddatachar-data-qint64-maxsize">QAbstractSocket::readData</a>(char *data, qint64 maxSize)。</p>
<hr>
<h3><span id="override-virtual-void-qsslsocket-resume"><em>[override virtual]</em> void <strong>QSslSocket</strong>::<strong>resume</strong>()</span><a href="#override-virtual-void-qsslsocket-resume" class="header-anchor">#</a></h3><p>重新实现：<a href="../../A/QAbstractSocket/QAbstractSocket.md#virtual-void-qabstractsocketresume">QAbstractSocket::resume</a>()。</p>
<p>在套接字数据传输暂停后继续数据传输。如果该套接字调用了 <a href="../../A/QAbstractSocket/QAbstractSocket.md#void-qabstractsocketsetpausemodeqabstractsocketpausemodes-pausemode">setPauseMode</a>(<a href="../../A/QAbstractSocket/QAbstractSocket.md#enum-qabstractsocketpausemode--flags-qabstractsocketpausemodes">QAbstractSocket::PauseOnSslErrors</a>) 并且发出了 <a href="#signal-void-qsslsocketsslerrorsconst-qlistqsslerror-errors">sslErrors</a>() 信号，则为了使套接字继续传输必须调用此函数。</p>
<p>该函数最初在 Qt 5.0 版本引入。</p>
<p>另外您也可以在 <a href="../../A/QAbstractSocket/QAbstractSocket.md#qabstractsocketpausemodes-qabstractsocketpausemode-const">QAbstractSocket::pauseMode</a>() 和 <a href="../../A/QAbstractSocket/QAbstractSocket.md#void-qabstractsocketsetpausemodeqabstractsocketpausemodes-pausemode">QAbstractSicket::setPauseMode</a>() 函数介绍中找到相关信息。</p>
<hr>
<h3><span id="qsslcipher-qsslsocket-sessioncipher-const"> <strong>QSslSocket</strong>::<strong>sessionCipher</strong>() const</span><a href="#qsslcipher-qsslsocket-sessioncipher-const" class="header-anchor">#</a></h3><p>返回该套接字的密钥，若该连接未加密则返回一个空密钥。该套接字的会话的密钥在握手期间设置。该密钥用于套接字传输中加密和解密数据。</p>
<p>QSslSocket 也提供设置在握手期间选择的密钥顺序列表的函数。该顺序列表必须在握手期间前指定。</p>
<p>另外您也可以在 QSslConfiguration::cipher() 和</p>
<hr>
<h3><span id="qssl-sslprotocol-qsslsocket-sessionprotocol-const"> <strong>QSslSocket</strong>::<strong>sessionProtocol</strong>() const</span><a href="#qssl-sslprotocol-qsslsocket-sessionprotocol-const" class="header-anchor">#</a></h3><hr>
<h3><span id="void-qsslsocket-setlocalcertificate-const-qsslcertificate-amp-certificate">void <strong>QSslSocket</strong>::<strong>setLocalCertificate</strong>(const  &amp;<em>certificate</em>)</span><a href="#void-qsslsocket-setlocalcertificate-const-qsslcertificate-amp-certificate" class="header-anchor">#</a></h3><hr>
<h3><span id="void-qsslsocket-setlocalcertificate-const-qstring-amp-path-qssl-encodingformat-format-qssl-pem">void <strong>QSslSocket</strong>::<strong>setLocalCertificate</strong>(const  &amp;<em>path</em>,  <em>format</em> = QSsl::Pem)</span><a href="#void-qsslsocket-setlocalcertificate-const-qstring-amp-path-qssl-encodingformat-format-qssl-pem" class="header-anchor">#</a></h3><hr>
<h3><span id="void-qsslsocket-setlocalcertificatechain-const-qlist-lt-qsslcertificate-gt-amp-localchain">void <strong>QSslSocket</strong>::<strong>setLocalCertificateChain</strong>(const &lt;&gt; &amp;<em>localChain</em>)</span><a href="#void-qsslsocket-setlocalcertificatechain-const-qlist-lt-qsslcertificate-gt-amp-localchain" class="header-anchor">#</a></h3><hr>
<h3><span id="void-qsslsocket-setpeerverifydepth-int-depth">void <strong>QSslSocket</strong>::<strong>setPeerVerifyDepth</strong>(int <em>depth</em>)</span><a href="#void-qsslsocket-setpeerverifydepth-int-depth" class="header-anchor">#</a></h3><hr>
<h3><span id="void-qsslsocket-setpeerverifymode-qsslsocket-peerverifymode-mode">void <strong>QSslSocket</strong>::<strong>setPeerVerifyMode</strong>( <em>mode</em>)</span><a href="#void-qsslsocket-setpeerverifymode-qsslsocket-peerverifymode-mode" class="header-anchor">#</a></h3><p>将套接字的检验模式设置为 <em>mode</em> 参数指定的模式。该模式决定 QSslSocket 是否应当从对等端请求一个证书（即客户端从服务器请求一个证书或服务端从客户端请求一个整数），以及它所请求的证书是否必须使有效的。</p>
<p>默认的模式时 <a href="#enum-qsslsocketpeerverifymode">AutoVerifyPeer</a>，该模式下 QSslSocket 将为客户端使用 <a href="#enum-qsslsocketpeerverifymode">VerifyPeer</a>，为服务端使用 <a href="#enum-qsslsocketpeerverifymode">QueryPeer</a>。</p>
<p>在进入加密模式后，设置模式并不会影响当前连接。</p>
<p>另外您也可以在 <a href="#qsslsocketpeerverifymode-qsslsocketpeerverifymode-const">peerVerifyMode</a>() ， <a href="#void-qsslsocketsetpeerverifydepthint-depth">setPeerVerifyDepth</a>() 和 <a href="#qsslsocketsslmode-qsslsocketmode-const">mode</a>() 函数介绍中找到相关信息。</p>
<hr>
<h3><span id="void-qsslsocket-setpeerverifyname-const-qstring-amp-hostname">void <strong>QSslSocket</strong>::<strong>setPeerVerifyName</strong>(const  &amp;<em>hostName</em>)</span><a href="#void-qsslsocket-setpeerverifyname-const-qstring-amp-hostname" class="header-anchor">#</a></h3><hr>
<h3><span id="void-qsslsocket-setprivatekey-const-qsslkey-amp-key">void <strong>QSslSocket</strong>::<strong>setPrivateKey</strong>(const  &amp;<em>key</em>)</span><a href="#void-qsslsocket-setprivatekey-const-qsslkey-amp-key" class="header-anchor">#</a></h3><hr>
<h3><span id="void-qsslsocket-setprivatekey-const-qstring-amp-filename-qssl-keyalgorithm-algorithm-qssl-rsa-qssl-encodingformat-format-qssl-pem-const-qbytearray-amp-passphrase-qbytearray">void <strong>QSslSocket</strong>::<strong>setPrivateKey</strong>(const  &amp;<em>fileName</em>,  <em>algorithm</em> = QSsl::Rsa,  <em>format</em> = QSsl::Pem, const &amp;<em>passPhrase</em> = QByteArray())</span><a href="#void-qsslsocket-setprivatekey-const-qstring-amp-filename-qssl-keyalgorithm-algorithm-qssl-rsa-qssl-encodingformat-format-qssl-pem-const-qbytearray-amp-passphrase-qbytearray" class="header-anchor">#</a></h3><hr>
<h3><span id="void-qsslsocket-setprotocol-qssl-sslprotocol-protocol">void <strong>QSslSocket</strong>::<strong>setProtocol</strong>( <em>protocol</em>)</span><a href="#void-qsslsocket-setprotocol-qssl-sslprotocol-protocol" class="header-anchor">#</a></h3><hr>
<h3><span id="override-virtual-void-qsslsocket-setreadbuffersize-qint64-size"><em>[override virtual]</em> void <strong>QSslSocket</strong>::<strong>setReadBufferSize</strong>( <em>size</em>)</span><a href="#override-virtual-void-qsslsocket-setreadbuffersize-qint64-size" class="header-anchor">#</a></h3><hr>
<h3><span id="override-virtual-void-qsslsocket-setsocketoption-qabstractsocket-socketoption-option-const-qvariant-amp-value"><em>[override virtual]</em> void <strong>QSslSocket</strong>::<strong>setSocketOption</strong>( <em>option</em>, const  &amp;<em>value</em>)</span><a href="#override-virtual-void-qsslsocket-setsocketoption-qabstractsocket-socketoption-option-const-qvariant-amp-value" class="header-anchor">#</a></h3><hr>
<h3><span id="void-qsslsocket-setsslconfiguration-const-qsslconfiguration-amp-configuration">void <strong>QSslSocket</strong>::<strong>setSslConfiguration</strong>(const  &amp;<em>configuration</em>)</span><a href="#void-qsslsocket-setsslconfiguration-const-qsslconfiguration-amp-configuration" class="header-anchor">#</a></h3><hr>
<h3><span id="override-virtual-qvariant-qsslsocket-socketoption-qabstractsocket-socketoption-option">[override virtual]  <strong>QSslSocket</strong>::<strong>socketOption</strong>( <em>option</em>)</span><a href="#override-virtual-qvariant-qsslsocket-socketoption-qabstractsocket-socketoption-option" class="header-anchor">#</a></h3><hr>
<h3><span id="qsslconfiguration-qsslsocket-sslconfiguration-const"> <strong>QSslSocket</strong>::<strong>sslConfiguration</strong>() const</span><a href="#qsslconfiguration-qsslsocket-sslconfiguration-const" class="header-anchor">#</a></h3><hr>
<h3><span id="qlist-lt-qsslerror-gt-qsslsocket-sslhandshakeerrors-const">&lt;&gt; <strong>QSslSocket</strong>::<strong>sslHandshakeErrors</strong>() const</span><a href="#qlist-lt-qsslerror-gt-qsslsocket-sslhandshakeerrors-const" class="header-anchor">#</a></h3><hr>
<h3><span id="static-long-qsslsocket-ssllibrarybuildversionnumber"><em>[static]</em> long <strong>QSslSocket</strong>::<strong>sslLibraryBuildVersionNumber</strong>()</span><a href="#static-long-qsslsocket-ssllibrarybuildversionnumber" class="header-anchor">#</a></h3><hr>
<h3><span id="static-qstring-qsslsocket-ssllibrarybuildversionstring"><em>[static]</em>  <strong>QSslSocket</strong>::<strong>sslLibraryBuildVersionString</strong>()</span><a href="#static-qstring-qsslsocket-ssllibrarybuildversionstring" class="header-anchor">#</a></h3><hr>
<h3><span id="static-long-qsslsocket-ssllibraryversionnumber"><em>[static]</em> long <strong>QSslSocket</strong>::<strong>sslLibraryVersionNumber</strong>()</span><a href="#static-long-qsslsocket-ssllibraryversionnumber" class="header-anchor">#</a></h3><hr>
<h3><span id="static-qstring-qsslsocket-ssllibraryversionstring"><em>[static]</em>  <strong>QSslSocket</strong>::<strong>sslLibraryVersionString</strong>()</span><a href="#static-qstring-qsslsocket-ssllibraryversionstring" class="header-anchor">#</a></h3><hr>
<h3><span id="static-bool-qsslsocket-supportsssl"><em>[static]</em> bool <strong>QSslSocket</strong>::<strong>supportsSsl</strong>()</span><a href="#static-bool-qsslsocket-supportsssl" class="header-anchor">#</a></h3><hr>
<h3><span id="override-virtual-bool-qsslsocket-waitforbyteswritten-int-msecs-30000"><em>[override virtual]</em> bool <strong>QSslSocket</strong>::<strong>waitForBytesWritten</strong>(int <em>msecs</em> = 30000)</span><a href="#override-virtual-bool-qsslsocket-waitforbyteswritten-int-msecs-30000" class="header-anchor">#</a></h3><hr>
<h3><span id="override-virtual-bool-qsslsocket-waitforconnected-int-msecs-30000"><em>[override virtual]</em> bool <strong>QSslSocket</strong>::<strong>waitForConnected</strong>(int <em>msecs</em> = 30000)</span><a href="#override-virtual-bool-qsslsocket-waitforconnected-int-msecs-30000" class="header-anchor">#</a></h3><hr>
<h3><span id="override-virtual-bool-qsslsocket-waitfordisconnected-int-msecs-30000"><em>[override virtual]</em> bool <strong>QSslSocket</strong>::<strong>waitForDisconnected</strong>(int <em>msecs</em> = 30000)</span><a href="#override-virtual-bool-qsslsocket-waitfordisconnected-int-msecs-30000" class="header-anchor">#</a></h3><hr>
<h3><span id="bool-qsslsocket-waitforencrypted-int-msecs-30000">bool <strong>QSslSocket</strong>::<strong>waitForEncrypted</strong>(int <em>msecs</em> = 30000)</span><a href="#bool-qsslsocket-waitforencrypted-int-msecs-30000" class="header-anchor">#</a></h3><hr>
<h3><span id="override-virtual-bool-qsslsocket-waitforreadyread-int-msecs-30000"><em>[override virtual]</em> bool <strong>QSslSocket</strong>::<strong>waitForReadyRead</strong>(int <em>msecs</em> = 30000)</span><a href="#override-virtual-bool-qsslsocket-waitforreadyread-int-msecs-30000" class="header-anchor">#</a></h3><hr>
<h3><span id="override-virtual-protected-qint64-qsslsocket-writedata-const-char-data-qint64-len"><em>[override virtual protected]</em>  QSslSocket::<strong>writeData</strong>(const char *<em>data</em>,  <em>len</em>)</span><a href="#override-virtual-protected-qint64-qsslsocket-writedata-const-char-data-qint64-len" class="header-anchor">#</a></h3>
            </div>
            <hr>
            <div>
              <div class="post-metas mb-3">
                
                
                  <div class="post-meta">
                    <i class="iconfont icon-tags"></i>
                    
                      <a class="hover-with-bg" href="/tags/S/">S</a>
                    
                  </div>
                
              </div>
              
                <p class="note note-warning">
                  
                    本博客所有文章除特别声明外，均采用 <a target="_blank" href="https://creativecommons.org/licenses/by-sa/4.0/deed.zh" rel="nofollow noopener noopener">CC BY-SA 4.0 协议</a> ，转载请注明出处！
                  
                </p>
              
              
                <div class="post-prevnext">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/2022/03/02/QtDocumentCN/Src/S/QSslError/QSslError/">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">QSslError类</span>
                        <span class="visible-mobile">上一篇</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2022/03/02/QtDocumentCN/Src/S/QSslSocket_Obsolete/QSslSocket_Obsolete/">
                        <span class="hidden-mobile">QSslSocket废弃类</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
              <!-- Comments -->
              <article class="comments" id="comments" lazyload>
                
                  
                
                
  <div id="lv-container" data-id="city" data-uid="MTAyMC81NTMzMi8zMTc5OQ==">
    <script type="text/javascript">
      Fluid.utils.loadComments('#lv-container', function() {
        Fluid.utils.createScript('https://cdn-city.livere.com/js/embed.dist.js');
      });
    </script>
    <noscript>Please enable JavaScript to view the comments</noscript>
  </div>


              </article>
            
          </article>
        </div>
      </div>
    </div>
    
      <div class="d-none d-lg-block col-lg-2 toc-container" id="toc-ctn">
        <div id="toc">
  <p class="toc-header"><i class="iconfont icon-list"></i>&nbsp;目录</p>
  <div class="toc-body" id="toc-body"></div>
</div>

      </div>
    
  </div>
</div>

<!-- Custom -->


    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v"
                 for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>
    

    
  </main>

  <footer class="text-center mt-5 py-3">
  <div class="footer-content">
     <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> 
  </div>
  

  

  
</footer>


  <!-- SCRIPTS -->
  
  <script  src="https://cdn.jsdelivr.net/npm/nprogress@0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/nprogress@0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js" ></script>
<script  src="https://cdn.jsdelivr.net/npm/bootstrap@4/dist/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>

<!-- Plugins -->


  <script  src="/js/local-search.js" ></script>



  
    <script  src="/js/img-lazyload.js" ></script>
  



  



  
    <script  src="https://cdn.jsdelivr.net/npm/tocbot@4/dist/tocbot.min.js" ></script>
  
  
    <script  src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3/dist/jquery.fancybox.min.js" ></script>
  
  
    <script  src="https://cdn.jsdelivr.net/npm/anchor-js@4/anchor.min.js" ></script>
  
  
    <script defer src="https://cdn.jsdelivr.net/npm/clipboard@2/dist/clipboard.min.js" ></script>
  






  <script  src="https://cdn.jsdelivr.net/npm/typed.js@2/lib/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var title = document.getElementById('subtitle').title;
      
        typing(title);
      
    })(window, document);
  </script>















<!-- 主题的启动项 保持在最底部 -->
<script  src="/js/boot.js" ></script>


</body>
</html>
