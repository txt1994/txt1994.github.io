

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=auto>



<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/logo.jpg">
  <link rel="icon" href="/img/logo.jpg">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
    <meta http-equiv="Content-Security-Policy" content="upgrade-insecure-requests">
  
  <meta name="theme-color" content="#6aa84f">
  <meta name="author" content="John Doe">
  <meta name="keywords" content="">
  
    <meta name="description" content="信号与槽 介绍 信号槽 信号 槽 一个小范例 真实范例 信号槽与默认参数 信号槽的进阶应用 在 Qt 中使用第三方的信号槽机制         # 信号与槽  信号(Signals)和槽(Slots)被用于在 Qt 对象之间通信。信号槽机制是 Qt 的核心特性，同时也可能是与其他框架的类似特性区别最大的一部分。信号槽使得 Qt 的元对象系统成为可能。 介绍#在 GUI 编程中，当我们修改">
<meta property="og:type" content="article">
<meta property="og:title" content="信号与槽">
<meta property="og:url" content="https://txt1994.github.io/2022/03/02/QtDocumentCN/Src/S/Signals_and_Slots/Signals_and_Slots/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:description" content="信号与槽 介绍 信号槽 信号 槽 一个小范例 真实范例 信号槽与默认参数 信号槽的进阶应用 在 Qt 中使用第三方的信号槽机制         # 信号与槽  信号(Signals)和槽(Slots)被用于在 Qt 对象之间通信。信号槽机制是 Qt 的核心特性，同时也可能是与其他框架的类似特性区别最大的一部分。信号槽使得 Qt 的元对象系统成为可能。 介绍#在 GUI 编程中，当我们修改">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://txt1994.github.io/Signals_and_Slots.drawio.svg">
<meta property="article:published_time" content="2022-03-02T06:47:47.000Z">
<meta property="article:modified_time" content="2022-03-18T16:52:17.244Z">
<meta property="article:author" content="John Doe">
<meta property="article:tag" content="信号与槽">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="https://txt1994.github.io/Signals_and_Slots.drawio.svg">
  
  
  <title>信号与槽 - Hexo</title>

  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4/dist/css/bootstrap.min.css" />


  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/github-markdown-css@4/github-markdown.min.css" />
  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/hint.css@2/hint.min.css" />

  
    
    
      
      <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@10/styles/github-gist.min.css" />
    
  

  
    <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3/dist/jquery.fancybox.min.css" />
  


<!-- 主题依赖的图标库，不要自行修改 -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_ba1fz6golrf.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_lbnruvf0jn.css">


<link  rel="stylesheet" href="/css/main.css" />

<!-- 自定义样式保持在最底部 -->

  
<link rel="stylesheet" href="/css/style.css">



  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    var CONFIG = {"hostname":"txt1994.github.io","root":"/","version":"1.8.14","typing":{"enable":true,"typeSpeed":70,"cursorChar":"_","loop":false},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"right","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"copy_btn":true,"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":false,"baidu":null,"google":null,"gtag":null,"tencent":{"sid":null,"cid":null},"woyaola":null,"cnzz":null,"leancloud":{"app_id":null,"app_key":null,"server_url":null,"path":"window.location.pathname","ignore_local":false}},"search_path":"/local-search.xml"};
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
<meta name="generator" content="Hexo 6.1.0">
<style>.github-emoji { position: relative; display: inline-block; width: 1.2em; min-height: 1.2em; overflow: hidden; vertical-align: top; color: transparent; }  .github-emoji > span { position: relative; z-index: 10; }  .github-emoji img, .github-emoji .fancybox { margin: 0 !important; padding: 0 !important; border: none !important; outline: none !important; text-decoration: none !important; user-select: none !important; cursor: auto !important; }  .github-emoji img { height: 1.2em !important; width: 1.2em !important; position: absolute !important; left: 50% !important; top: 50% !important; transform: translate(-50%, -50%) !important; user-select: none !important; cursor: auto !important; } .github-emoji-fallback { color: inherit; } .github-emoji-fallback img { opacity: 0 !important; }</style>
</head>


<body>
  <header style="height: 70vh;">
    <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/">
      <strong>txt1994s</strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/">
                <i class="iconfont icon-home-fill"></i>
                首页
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/">
                <i class="iconfont icon-archive-fill"></i>
                归档
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/">
                <i class="iconfont icon-tags-fill"></i>
                标签
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/">
                <i class="iconfont icon-user-fill"></i>
                关于
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/links/">
                <i class="iconfont icon-link-fill"></i>
                友联
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              &nbsp;<i class="iconfont icon-search"></i>&nbsp;
            </a>
          </li>
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">&nbsp;<i
                class="iconfont icon-dark" id="color-toggle-icon"></i>&nbsp;</a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

    <div class="banner" id="banner" parallax=true
         style="background: url('/img/default.png') no-repeat center center;
           background-size: cover;">
      <div class="full-bg-img">
        <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
          <div class="page-header text-center fade-in-up">
            <span class="h2" id="subtitle" title="信号与槽">
              
            </span>

            
              <div class="mt-3">
  
  
    <span class="post-meta">
      <i class="iconfont icon-date-fill" aria-hidden="true"></i>
      <time datetime="2022-03-02 14:47" pubdate>
        2022年3月2日 下午
      </time>
    </span>
  
</div>

<div class="mt-1">
  
    <span class="post-meta mr-2">
      <i class="iconfont icon-chart"></i>
      7.1k 字
    </span>
  

  
    <span class="post-meta mr-2">
      <i class="iconfont icon-clock-fill"></i>
      
      
      60 分钟
    </span>
  

  
  
</div>

            
          </div>

          
        </div>
      </div>
    </div>
  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="d-none d-lg-block col-lg-2"></div>
    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div class="py-5" id="board">
          <article class="post-content mx-auto">
            <!-- SEO header -->
            <h1 style="display: none">信号与槽</h1>
            
              <p class="note note-info">
                
                  本文最后更新于：2022年3月19日 凌晨
                
              </p>
            
            <div class="markdown-body">
              <div class="toc">

<!-- toc -->

<ul>
<li><a href="#xin-hao-yu-cao">信号与槽</a><ul>
<li><a href="#jie-shao">介绍</a></li>
<li><a href="#xin-hao-cao">信号槽</a></li>
<li><a href="#xin-hao">信号</a></li>
<li><a href="#cao">槽</a></li>
<li><a href="#yi-ge-xiao-fan-li">一个小范例</a></li>
<li><a href="#zhen-shi-fan-li">真实范例</a></li>
<li><a href="#xin-hao-cao-yu-mo-ren-can-shu">信号槽与默认参数</a></li>
<li><a href="#xin-hao-cao-de-jin-jie-ying-yong">信号槽的进阶应用</a><ul>
<li><a href="#zai-qt-zhong-shi-yong-di-san-fang-de-xin-hao-cao-ji-zhi">在 Qt 中使用第三方的信号槽机制</a></li>
</ul>
</li>
</ul>
</li>
</ul>
<!-- tocstop -->

</div>
# 信号与槽

<p>信号(Signals)和槽(Slots)被用于在 Qt 对象之间通信。信号槽机制是 Qt 的核心特性，同时也可能是与其他框架的类似特性区别最大的一部分。信号槽使得 Qt 的<a href="../../M/The_Meta-Object_System/The_Meta-Object_System.md">元对象系统</a>成为可能。</p>
<h2><span id="jie-shao">介绍</span><a href="#jie-shao" class="header-anchor">#</a></h2><p>在 GUI 编程中，当我们修改某个控件后，我们通常希望另一个控件可以收到通知。更普遍地，我们希望任何类型的对象都可以和另一个对象进行通信。例如，如果用户点击了<strong>关闭</strong>按钮，我们可能希望该窗口的 <a href="../../W/QWidget/QWidget.md#close">close</a>() 函数被调用。</p>
<p>其它开发工具中，使用回调来实现此类通信。回调是指函数指针——当您希望某个处理函数通知您某些事件时，通过传递一个函数指针（即回调）至该处理函数来实现，处理函数会在适合的时机调用这个回调。尽管许多优秀的框架的确在使用此方法，但回调依然是一种非常不直观的手段，而且可能会遭遇回调参数类型正确性校验等方面的问题。</p>
<h2><span id="xin-hao-cao">信号槽</span><a href="#xin-hao-cao" class="header-anchor">#</a></h2><p>在 Qt 中，我们有回调技术的替代品：信号槽。<strong>信号</strong>会在特定事件发生时被发射；Qt 的控件包含大量预定义的信号，并且我们也可以编写控件的子类来为它们添加自定义的信号。<strong>槽</strong>是指会在响应对应信号时被自动调用的函数；Qt 的控件包含大量预定义的槽，并且，编写控件的子类来添加自定义槽也是常见的做法，这样您便可以处理感兴趣的信号。</p>
<p><img src="/Signals_and_Slots.drawio.svg" srcset="/img/loading.gif" lazyload alt="Signals &amp; Slots"></p>
<p>信号槽机制是<strong>类型安全</strong>的：信号的函数签名必须与接收它的槽函数签名一致（事实上，槽可以具有比它接收的信号更短的签名，因为允许忽略尾部的额外参数）。鉴于函数签名需要兼容，当我们使用函数指针格式的 <a href="../../O/QObject/QObject.md#static-qmetaobjectconnection-qobjectconnectconst-qobject-sender-const-char-signal-const-qobject-receiver-const-char-method-qtconnectiontype-type--qtautoconnectiont">connect</a>() 时，编译器可以帮助我们识别它们的参数类型中的不匹配。信号槽之间是松耦合关系：发射信号的类无需知晓也无需关心是哪个槽接收了这个信号。Qt 的信号槽机制确保了，如果将一个信号连接至一个槽，则槽会在正确的时机被调用，并传入信号所携带的参数。信号槽可以携带任意类型、任意个数的参数，它们是完全类型安全的。</p>
<p>所有继承自 <a href="../../O/QObject/QObject.md">QObject</a> 或它的任意子类型（如 <a href="../../W/QWidget/QWidget.md">QWidget</a>）的类都可以包含信号槽。对象在修改了可能会被其它对象感兴趣的状态时，会发射信号，但并不需要知晓或关心是否有人接收了这个信号。这是真正的信息封装，确保了该对象可以被当作软件中的一个组件所使用。</p>
<p>槽可被用于接收信号，但它们同时也是常规的成员函数。正如一个对象并不知道是否有人接收了它的信号，槽也不知道是否有信号连接至它。这确保了 Qt 可以创建互相之间完全独立的组件。</p>
<p>将任意多的信号可以被连接至同一个槽，同一个信号也可以根据需要连接至任意多个槽。甚至，将一个信号直接连接至另一个信号也是可行的（这会另第二个信号在第一个发射的同时被发射）。</p>
<p>两者结合后，信号槽构成了一种强大的组件化编程机制。</p>
<h2><span id="xin-hao">信号</span><a href="#xin-hao" class="header-anchor">#</a></h2><p>当一个对象的内部状态被改变，同时它的使用者或所有者可能会感兴趣时，它会发射信号。信号是类的公共成员函数，可以从任何地方发射，但我们只推荐在定义这个信号的类和它的子类中发射。</p>
<p>当信号发射时，连接至它的槽通常会立刻执行，就如同常规的函数调用一样（即就地回调）。此时，信号槽机制的运行完全独立于（即不依赖）任何 GUI 事件循环，<code>emit</code>语句之后的代码会在所有槽函数返回后再继续执行。此场景与<a href="../../Q/Qt_Namespace/Qt_Namespace.md#enum_QtConnectionType">队列连接</a>有细微的差别——在后者中，<code>emit</code>语句之后的代码会立即执行，而槽则会在随后才被调度。</p>
<p>若多个槽被连接至同一个信号，则当信号发射时，这些槽会按照连接的顺序依次执行。</p>
<p>信号会通过 <a href="../../M/Using_the_Meta-Object_Compiler_moc/Using_the_Meta-Object_Compiler_moc.md">moc</a> 自动生成定义，不能在<code>.cpp</code>中手动编写定义。信号不具备返回类型（即<code>void</code>）。（<code>译者注：事实上，非队列连接的信号可以具有返回类型，返回类型与槽返回类型相同，也可用</code> <a href="../../V/QVariant/QVariant.md">QVariant</a> <code>接收任意类型返回，但此机制不保证会被后续版本继续支持。Qt 在 qobjectdefs_impl.h 中，通过 operator, 和 ApplyReturnValue 实现此机制，有兴趣的读者可自行查阅。</code>）</p>
<p>关于函数参数：我们的经验是，若信号槽参数不使用特殊类型，则可以具备更广的泛用性。如果 <a href="../../S/QScrollBar/QScrollBar.md#valueChanged">QScrollBar::valueChanged</a>() 中使用了特殊类型，假设命名为<code>QScrollBar::Range</code>，则它只能被连接至专门为 <a href="../../S/QScrollBar/QScrollBar.md">QScrollBar</a> 设计的槽函数上，而将不同的输入控件互相连接则是不可能的。</p>
<h2><span id="cao">槽</span><a href="#cao" class="header-anchor">#</a></h2><p>当连接至它的信号被发射时，槽会被调用。槽是常规的 C++ 函数，可以被正常调用；它的特殊性质只有被连接至信号时才会体现。</p>
<p>由于槽是常规的成员函数（<code>译者注：也可是静态成员函数或常规的全局函数</code>），当被直接调用时，它遵循标准的 C++ 规范。然而，作为槽，它们可以被任何组件通过信号槽机制调用，而无视它的作用域。这意味着从任意类的实例发射的信号，可以触发另一个非友元类实例中的私有槽。</p>
<p>您也可以将槽定义为虚函数，这在实践中被证明非常有用。</p>
<p>与回调相比，信号槽会稍微慢一些，因为它们提供了更多的灵活性，不过在实际应用中这些性能差异通常无关紧要。一般来说，发射一个连接至槽的信号，大约比直接调用接收者的函数慢上十倍（<code>译者注：此处指函数调用的额外开销，并非函数执行总耗时</code>），此处不考虑虚函数调用开销。这些开销被用于定位接收对象、线程安全地遍历所有连接（即检查接收者是否在发射过程中被销毁），并将所有参数转换为规范化的形式。虽然十倍非虚函数的调用开销听起来很高，但它其实比任何<code>new</code>或<code>delete</code>开销少得多。例如，当执行一个字符串、向量或链表操作，而它们在内部依赖<code>new</code>或<code>delete</code>时，信号槽开销在整个函数调用中只占据了一个非常小的比例。这同样适用于在槽中执行系统调用，或在其中间接调用了超过十个函数的场景。信号槽机制的简洁性和灵活性是值得付出这些开销的，并且您的用户甚至都无法感知到。</p>
<p>注意，若其它库定义了名为<code>signals</code>或<code>slots</code>的类型（<code>译者注：包括类型名称、函数签名、宏定义等任何代码标识</code>），将它们与 Qt 程序共同编译时会导致警告甚至错误。为修复此问题，使用<code>#undef</code>取消这些预编译符号的定义。（<code>译者注：不推荐此方法，建议使用下文的</code><a href="Signals_and_Slots.md#%E5%9C%A8-qt-%E4%B8%AD%E4%BD%BF%E7%94%A8%E7%AC%AC%E4%B8%89%E6%96%B9%E7%9A%84%E4%BF%A1%E5%8F%B7%E6%A7%BD%E6%9C%BA%E5%88%B6">在 Qt 中使用第三方的信号槽机制</a>）</p>
<h2><span id="yi-ge-xiao-fan-li">一个小范例</span><a href="#yi-ge-xiao-fan-li" class="header-anchor">#</a></h2><p>若有一个最小化的 C++ 类定义，如下所示：</p>
<div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Counter</span>
{
    <span class="hljs-keyword">public</span>:
    <span class="hljs-built_in">Counter</span>() { m_value = <span class="hljs-number">0</span>; }

    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">value</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>{ <span class="hljs-keyword">return</span> m_value; }
    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">setValue</span><span class="hljs-params">(<span class="hljs-type">int</span> value)</span></span>;

    <span class="hljs-keyword">private</span>:
    <span class="hljs-type">int</span> m_value;
};</code></pre></div>

<p>则它对应的最小化的基于 <a href="../../O/QObject/QObject.md">QObject</a> 的类型则为：</p>
<div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;QObject&gt;</span></span>

<span class="hljs-keyword">class</span> <span class="hljs-title class_">Counter</span> : <span class="hljs-keyword">public</span> QObject
{
    Q_OBJECT

        <span class="hljs-keyword">public</span>:
    <span class="hljs-built_in">Counter</span>() { m_value = <span class="hljs-number">0</span>; }

    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">value</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>{ <span class="hljs-keyword">return</span> m_value; }

    <span class="hljs-keyword">public</span> slots:
    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">setValue</span><span class="hljs-params">(<span class="hljs-type">int</span> value)</span></span>;

    signals:
    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">valueChanged</span><span class="hljs-params">(<span class="hljs-type">int</span> newValue)</span></span>;

    <span class="hljs-keyword">private</span>:
    <span class="hljs-type">int</span> m_value;
};</code></pre></div>

<p>基于 <a href="../../O/QObject/QObject.md">QObject</a> 的版本具备一些内部状态，并且提供了公共方法来获取这些状态，同时还具备使用信号槽机制的组件化编程支持。这个类可以通过发射<code>valueChanged()</code>信号来通知外界它的状态发生了改变，同时也拥有一个槽，让其它对象可以向其发送信号。</p>
<p>所有包含信号槽的类都必须在类的起始处声明 <a href="../../O/QObject/QObject.md#Q_OBJECT">Q_OBJECT</a> ，并且必须继承自（直接或间接） <a href="../../O/QObject/QObject.md">QObject</a> 。（<code>译者注：迄今所有版本中，QObject 均不支持虚继承和菱形继承，即每个类只能拥有唯一一个非虚继承的 QObject 基类</code>）</p>
<p>槽需要程序开发者提供定义，此处为<code>Counter::setValue()</code>槽的一个可能的定义：</p>
<div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Counter::setValue</span><span class="hljs-params">(<span class="hljs-type">int</span> value)</span></span>
<span class="hljs-function"></span>{
    <span class="hljs-keyword">if</span> (value != m_value) {
        m_value = value;
        <span class="hljs-function">emit <span class="hljs-title">valueChanged</span><span class="hljs-params">(value)</span></span>;
    }
}</code></pre></div>

<p><code>emit</code>一行从该对象发射<code>valueChanged()</code>信号，并携带新的值作为参数。</p>
<p>在下方代码片段中，我们创建了两个<code>Counter</code>对象，使用 <a href="../../O/QObject/QObject.md#static-qmetaobjectconnection-qobjectconnectconst-qobject-sender-const-char-signal-const-qobject-receiver-const-char-method-qtconnectiontype-type--qtautoconnection">QObject::connect</a>() 将第一个对象的<code>valueChanged()</code>信号连接至第二个对象的<code>setValue()</code>槽。</p>
<div class="code-wrapper"><pre><code class="hljs c++">Counter a, b;
QObject::<span class="hljs-built_in">connect</span>(&amp;a, &amp;Counter::valueChanged,
                 &amp;b, &amp;Counter::setValue);

a.<span class="hljs-built_in">setValue</span>(<span class="hljs-number">12</span>);     <span class="hljs-comment">// a.value() == 12, b.value() == 12</span>
b.<span class="hljs-built_in">setValue</span>(<span class="hljs-number">48</span>);     <span class="hljs-comment">// a.value() == 12, b.value() == 48</span></code></pre></div>

<p>调用<code>a.setValue(12)</code>会发射信号<code>valueChanged(12)</code>，该信号被<code>b</code>的<code>setValue()</code>槽中接收，即调用<code>b.setValue(12)</code>。然后<code>b</code>会发射相同的<code>valueChanged()</code>信号，但由于没有槽被连接至<code>b</code>的<code>valueChanged()</code>信号，这个信号会被忽略。</p>
<p>注意，<code>setValue()</code>函数当且仅当<code>value != m_value</code>时才会修改数值并发射信号。这样避免了环形连接（如<code>b.valueChanged()</code>又被连接回<code>a.setValue()</code>时）时的无限循环。</p>
<p>默认下，每有一个连接，信号会被发射一次；若创建了两个连接，则信号会被发射两次。您可以使用一次 <a href="../../O/QObject/QObject.md#disconnect">disconnect</a>() 来断开所有连接。如果在连接时传递了 <a href="../../Q/Qt_Namespace/Qt_Namespace.md#enum_QtConnectionType">Qt::UniqueConnection</a>  类型，则连接只会被创建一次而非多次。如果已经有存在的重复连接（即对象的相同的信号，被连接至相同对象的相同的槽），则新连接会失败并返回<code>false</code>。</p>
<p>本范例说明了，对象之间无需了解对彼此的任何信息，便可共同协作。为实现此目的，对象们只需要通过一些简单的 <a href="../../O/QObject/QObject.md#static-qmetaobjectconnection-qobjectconnectconst-qobject-sender-const-char-signal-const-qobject-receiver-const-char-method-qtconnectiontype-type--qtautoconnection">connect</a>() 调用连接至彼此，或通过 <a href="../../U/User_Interface_Compiler_uic/User_Interface_Compiler_uic.md">uic</a> 的<a href="../../U/Using_a_Designer_UI_File_in_Your_Application/Using_a_Designer_UI_File_in_Your_Application.md#%E8%87%AA%E5%8A%A8%E8%BF%9E%E6%8E%A5">自动连接</a>特性完成。</p>
<h2><span id="zhen-shi-fan-li">真实范例</span><a href="#zhen-shi-fan-li" class="header-anchor">#</a></h2><p>下文为一个简单的控件类的头文件范例，不包含成员函数。此代码目为演示如何在您自己的应用中利用信号槽。</p>
<div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">ifndef</span> LCDNUMBER_H</span>
<span class="hljs-meta">#<span class="hljs-keyword">define</span> LCDNUMBER_H</span>

<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;QFrame&gt;</span></span>

<span class="hljs-keyword">class</span> <span class="hljs-title class_">LcdNumber</span> : <span class="hljs-keyword">public</span> QFrame
{
    Q_OBJECT</code></pre></div>

<p><code>LcdNumber</code>通过 <a href="../../F/QFrame/QFrame.md">QFrame</a> 和 <a href="../../W/QWidget/QWidget.md">QWidget</a>，间接继承自 <a href="../../O/QObject/QObject.md">QObject</a>，后者提供了绝大部分信号槽特性。这和内置的 <a href="../../L/QLCDNumber/QLCDNumber.md">QLCDNumber</a> 控件有部分相似之处。</p>
<p> 会被编译器展开为一些成员函数的声明，以供<code>moc</code>实现；如果您遇到形如“无法解析的外部符号：<code>LcdNumber</code>”（undefined reference to vtable for <code>LcdNumber</code>）的编译错误，那么您可能忘记<a href="../../M/Using_the_Meta-Object_Compiler_moc/Using_the_Meta-Object_Compiler_moc.md">执行moc</a>，或忘记将<code>moc</code>输出包含到链接指令中。（<code>译者注：对于 qmake 工程，将包含</code> <a href="../../O/QObject/QObject.md#Q_OBJECT">Q_OBJECT</a> <code>的头文件添加到 .pro 文件的</code> <a href="../../V/Variables/Variables.md#HEADERS">HEADERS</a> <code>变量中，即可自动执行</code> <a href="../../M/Using_the_Meta-Object_Compiler_moc/Using_the_Meta-Object_Compiler_moc.md">moc</a> <code>并链接其输出</code>）</p>
<div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">public</span>:
	<span class="hljs-built_in">LcdNumber</span>(QWidget *parent = <span class="hljs-literal">nullptr</span>);

signals:
	<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">overflow</span><span class="hljs-params">()</span></span>;</code></pre></div>

<p>在类构造函数和公共成员之后，我们声明该类的信号。当被要求显示不可能的数值时，<code>LcdNumber</code>类会发射信号<code>overflow()</code>。</p>
<p>如果不关心越界，或者知道不会发生越界，那么可以忽略<code>overflow()</code>信号，即不将它连接至任何槽。</p>
<p>另一方面，如果您想在数值溢出时调用两个不同的错误处理函数，只需简单地将信号连接至两个不同的槽。Qt 会确保它们都被调用（按照连接的顺序）。</p>
<div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">public</span> slots:
    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">display</span><span class="hljs-params">(<span class="hljs-type">int</span> num)</span></span>;
    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">display</span><span class="hljs-params">(<span class="hljs-type">double</span> num)</span></span>;
    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">display</span><span class="hljs-params">(<span class="hljs-type">const</span> QString &amp;str)</span></span>;
    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">setHexMode</span><span class="hljs-params">()</span></span>;
    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">setDecMode</span><span class="hljs-params">()</span></span>;
    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">setOctMode</span><span class="hljs-params">()</span></span>;
    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">setBinMode</span><span class="hljs-params">()</span></span>;
    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">setSmallDecimalPoint</span><span class="hljs-params">(<span class="hljs-type">bool</span> point)</span></span>;
    };

<span class="hljs-meta">#<span class="hljs-keyword">endif</span></span></code></pre></div>

<p>槽是指接收信号的函数，用于获取其它控件状态改变的信息。如上述代码所示，<code>LcdNumber</code>使用槽来设置被显示的数字。由于<code>display()</code>同时也是该类在程序中的接口之一，这个槽是公共(<code>public</code>)的。</p>
<p>范例程序将 <a href="../../S/QScrollBar/QScrollBar.md">QScrollBar</a> 的 <a href="../../A/QAbstractSlider/QAbstractSlider.md#valueChanged">valueChanged</a>() 信号连接至此处的<code>display()</code>槽，于是 LCD 数字会持续显示为滚动条的数值。</p>
<p>注意，<code>display()</code>函数被重载；当连接信号至这个槽时，Qt 会选取适合的版本。在回调时，您需要自行查询多个不同的名称并跟踪它们的类型。</p>
<h2><span id="xin-hao-cao-yu-mo-ren-can-shu">信号槽与默认参数</span><a href="#xin-hao-cao-yu-mo-ren-can-shu" class="header-anchor">#</a></h2><p>信号槽可以包含默认参数，即具有默认值的参数。如 <a href="../../O/QObject/QObject.md#destroyed">QObject::destroyed</a>()：</p>
<div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">destroyed</span><span class="hljs-params">(QObject* = <span class="hljs-literal">nullptr</span>)</span></span>;</code></pre></div>

<p>当一个 <a href="../../O/QObject/QObject.md">QObject</a> 对象被删除时，它会发射 <a href="../../O/QObject/QObject.md#destroyed">QObject::destroyed</a>() 信号。我们可以捕获此信号，此时我们可能仍持有被删除的 <a href="../../O/QObject/QObject.md">QObject</a> 对象的悬空引用，则可以将其清理掉。一个对应的槽函数签名可能为：</p>
<div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">objectDestroyed</span><span class="hljs-params">(QObject* obj = <span class="hljs-literal">nullptr</span>)</span></span>;</code></pre></div>

<p>为了将该信号连接至此槽，我们使用 <a href="../../O/QObject/QObject.md#static-qmetaobjectconnection-qobjectconnectconst-qobject-sender-const-char-signal-const-qobject-receiver-const-char-method-qtconnectiontype-type--qtautoconnection">QObject::connect</a>()。有多种方式可以连接信号槽，首先是使用函数指针：</p>
<div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-built_in">connect</span>(sender, &amp;QObject::destroyed, <span class="hljs-keyword">this</span>, &amp;MyObject::objectDestroyed);</code></pre></div>

<p>使用函数指针来执行 <a href="../../O/QObject/QObject.md#static-qmetaobjectconnection-qobjectconnectconst-qobject-sender-const-char-signal-const-qobject-receiver-const-char-method-qtconnectiontype-type--qtautoconnection">QObject::connect</a>() 有诸多优点。首先，这允许编译器检查信号的参数是否与槽的参数相匹配；同时，如果有必要，编译器可以对参数进行隐式转换（<code>译者注：如将信号的 int 参数转换为槽的 double 参数</code>）。</p>
<p>您也可以使用仿函数(<code>functor</code>)或 C++11 的匿名函数(<code>lambda</code>)：</p>
<div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-built_in">connect</span>(sender, &amp;QObject::destroyed, <span class="hljs-keyword">this</span>, [=](){ <span class="hljs-keyword">this</span>-&gt;m_objects.<span class="hljs-built_in">remove</span>(sender); });</code></pre></div>

<p>在这两种场景中，我们使用<code>this</code>作为<code>connect()</code>调用中的上下文对象。上下文对象指明了接收函数应该在哪个线程被执行。这非常重要，因为它提供了上下文，以确保接收者可以在上下文所处的线程中被执行。</p>
<p>仿函数/匿名函数可以在发送者或上下文对象被销毁时断开连接。您需要注意确保仿函数/匿名函数中用到的所有对象，在信号发射时保持可用。</p>
<p>另一种连接信号槽的方法，是通过<code>SIGNAL</code>和<code>SLOT</code>宏使用 <a href="../../O/QObject/QObject.md#static-qmetaobjectconnection-qobjectconnectconst-qobject-sender-const-char-signal-const-qobject-receiver-const-char-method-qtconnectiontype-type--qtautoconnection">QObject::connect</a>()。若参数列表中包含默认值，则<code>SIGNAL()</code>和<code>SLOT()</code>中是否包含该参数的规则是，传递给<code>SIGNAL()</code>宏的参数列表必须<strong>不少于</strong>传递给<code>SLOT()</code>宏的参数列表。</p>
<p>以下方式都可以生效：</p>
<div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-built_in">connect</span>(sender, <span class="hljs-built_in">SIGNAL</span>(<span class="hljs-built_in">destroyed</span>(QObject*)), <span class="hljs-keyword">this</span>, <span class="hljs-built_in">SLOT</span>(<span class="hljs-built_in">objectDestroyed</span>(Qbject*)));
<span class="hljs-built_in">connect</span>(sender, <span class="hljs-built_in">SIGNAL</span>(<span class="hljs-built_in">destroyed</span>(QObject*)), <span class="hljs-keyword">this</span>, <span class="hljs-built_in">SLOT</span>(<span class="hljs-built_in">objectDestroyed</span>()));
<span class="hljs-built_in">connect</span>(sender, <span class="hljs-built_in">SIGNAL</span>(<span class="hljs-built_in">destroyed</span>()), <span class="hljs-keyword">this</span>, <span class="hljs-built_in">SLOT</span>(<span class="hljs-built_in">objectDestroyed</span>()));</code></pre></div>

<p>但下面这个无法生效：</p>
<div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-built_in">connect</span>(sender, <span class="hljs-built_in">SIGNAL</span>(<span class="hljs-built_in">destroyed</span>()), <span class="hljs-keyword">this</span>, <span class="hljs-built_in">SLOT</span>(<span class="hljs-built_in">objectDestroyed</span>(QObject*)));</code></pre></div>

<p>——因为槽希望获得一个 <a href="../../O/QObject/QObject.md">QObject</a> 对象，但信号并不会发送它。这个连接会在运行时汇报一条错误信息。</p>
<p>注意，使用这个 <a href="../../O/QObject/QObject.md#static-qmetaobjectconnection-qobjectconnectconst-qobject-sender-const-char-signal-const-qobject-receiver-const-char-method-qtconnectiontype-type--qtautoconnection">QObject::connect</a>() 重载时，信号和槽的参数并不会被编译器进行检查。（<code>译者注：即使用 SIGNAL() / SLOT() 的连接方式</code>）</p>
<h2><span id="xin-hao-cao-de-jin-jie-ying-yong">信号槽的进阶应用</span><a href="#xin-hao-cao-de-jin-jie-ying-yong" class="header-anchor">#</a></h2><p>对于想要获取信号发送方信息的的场景，Qt 提供了 <a href="../../O/QObject/QObject.md#sender">QObject::sender</a>() 函数，该函数返回发送信号的对象的指针。</p>
<p>匿名表达式(<code>lambda</code>)可以用更简单的方法来将自定义参数传递至槽（<code>译者注：使用捕获列表</code>）：</p>
<div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-built_in">connect</span>(action, &amp;QAction::triggered, engine,
        [=]() { engine-&gt;<span class="hljs-built_in">processAction</span>(action-&gt;<span class="hljs-built_in">text</span>()); });</code></pre></div>

<h3><span id="zai-qt-zhong-shi-yong-di-san-fang-de-xin-hao-cao-ji-zhi">在 Qt 中使用第三方的信号槽机制</span><a href="#zai-qt-zhong-shi-yong-di-san-fang-de-xin-hao-cao-ji-zhi" class="header-anchor">#</a></h3><p>Qt 中可以使用第三方的信号槽机制。您可以在项目中同时使用这两种机制，只需要将下述代码添加至您的 qmake 工程文件(<code>.pro</code>)中：</p>
<div class="code-wrapper"><pre><code class="hljs c++">CONFIG += no_keywords</code></pre></div>

<p>它告诉 Qt 不要定义 moc 关键字<code>signals</code>、<code>slots</code>和<code>emit</code>，因为这些名称会被三方库所使用，如 <a target="_blank" rel="noopener" href="https://theboostcpplibraries.com/boost.signals2-signals">Boost</a>。在<code>no_keyword</code>标识下继续使用 Qt 信号槽时，只需简单地将代码中的 Qt moc 关键字替换为对应的 Qt 宏 <a href="../../O/QObject/QObject.md#Q_SIGNALS">Q_SIGNALS</a>(或 <a href="../../O/QObject/QObject.md#Q_SIGNAL">Q_SIGNAL</a>)、<a href="../../O/QObject/QObject.md#Q_SLOTS">Q_SLOTS</a>(或 <a href="../../O/QObject/QObject.md#Q_SLOT">Q_SLOT</a>)，以及 <a href="../../O/QObject/QObject.md#Q_EMIT">Q_EMIT</a>。</p>
<p><strong>另请参阅：</strong> <a href="../../L/QLCDNumber/QLCDNumber.md">QLCDNumber</a>、<a href="../../O/QObject/QObject.md#connect">QObject::connect</a>()、<a href="../../D/Digital_Clock_Example/Digital_Clock_Example.md">Digital Clock Example</a>、<a href="../../T/Tetrix_Example/Tetrix_Example.md">Tetrix Example</a>、<a href="../../M/The_Meta-Object_System/The_Meta-Object_System.md">Meta-Object_System</a>，以及 <a href="../../P/The_Property_System/The_Property_System.md">Qt 属性系统</a>。</p>

            </div>
            <hr>
            <div>
              <div class="post-metas mb-3">
                
                
                  <div class="post-meta">
                    <i class="iconfont icon-tags"></i>
                    
                      <a class="hover-with-bg" href="/tags/%E4%BF%A1%E5%8F%B7%E4%B8%8E%E6%A7%BD/">信号与槽</a>
                    
                  </div>
                
              </div>
              
                <p class="note note-warning">
                  
                    本博客所有文章除特别声明外，均采用 <a target="_blank" href="https://creativecommons.org/licenses/by-sa/4.0/deed.zh" rel="nofollow noopener noopener">CC BY-SA 4.0 协议</a> ，转载请注明出处！
                  
                </p>
              
              
                <div class="post-prevnext">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/2022/03/02/QtDocumentCN/Src/S/QStringRef/QStringRef%20/">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">QStringRef类</span>
                        <span class="visible-mobile">上一篇</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2022/03/02/QtDocumentCN/Src/S/QString/QString/">
                        <span class="hidden-mobile">QString类</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
              <!-- Comments -->
              <article class="comments" id="comments" lazyload>
                
                  
                
                
  <div id="lv-container" data-id="city" data-uid="MTAyMC81NTMzMi8zMTc5OQ==">
    <script type="text/javascript">
      Fluid.utils.loadComments('#lv-container', function() {
        Fluid.utils.createScript('https://cdn-city.livere.com/js/embed.dist.js');
      });
    </script>
    <noscript>Please enable JavaScript to view the comments</noscript>
  </div>


              </article>
            
          </article>
        </div>
      </div>
    </div>
    
      <div class="d-none d-lg-block col-lg-2 toc-container" id="toc-ctn">
        <div id="toc">
  <p class="toc-header"><i class="iconfont icon-list"></i>&nbsp;目录</p>
  <div class="toc-body" id="toc-body"></div>
</div>

      </div>
    
  </div>
</div>

<!-- Custom -->


    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v"
                 for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>
    

    
  </main>

  <footer class="text-center mt-5 py-3">
  <div class="footer-content">
     <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> 
  </div>
  

  

  
</footer>


  <!-- SCRIPTS -->
  
  <script  src="https://cdn.jsdelivr.net/npm/nprogress@0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/nprogress@0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js" ></script>
<script  src="https://cdn.jsdelivr.net/npm/bootstrap@4/dist/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>

<!-- Plugins -->


  <script  src="/js/local-search.js" ></script>



  
    <script  src="/js/img-lazyload.js" ></script>
  



  



  
    <script  src="https://cdn.jsdelivr.net/npm/tocbot@4/dist/tocbot.min.js" ></script>
  
  
    <script  src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3/dist/jquery.fancybox.min.js" ></script>
  
  
    <script  src="https://cdn.jsdelivr.net/npm/anchor-js@4/anchor.min.js" ></script>
  
  
    <script defer src="https://cdn.jsdelivr.net/npm/clipboard@2/dist/clipboard.min.js" ></script>
  






  <script  src="https://cdn.jsdelivr.net/npm/typed.js@2/lib/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var title = document.getElementById('subtitle').title;
      
        typing(title);
      
    })(window, document);
  </script>















<!-- 主题的启动项 保持在最底部 -->
<script  src="/js/boot.js" ></script>


</body>
</html>
