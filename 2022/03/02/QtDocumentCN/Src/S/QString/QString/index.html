

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=auto>



<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/logo.jpg">
  <link rel="icon" href="/img/logo.jpg">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
    <meta http-equiv="Content-Security-Policy" content="upgrade-insecure-requests">
  
  <meta name="theme-color" content="#6aa84f">
  <meta name="author" content="John Doe">
  <meta name="keywords" content="">
  
    <meta name="description" content="QString Class 公共类型 公共函数 静态公共成员 非相关成员 宏 详细描述 初始化字符串 操作字符串数据 查询字符串数据 在编码字符串数据和 QString 之间转换 NULL字符串和Empty字符串之间的区别 数字格式 更高效的字符串构造 最大大小和内存不足情况   成员类型文档 QString::ConstIterator QString::Iterator enum Q">
<meta property="og:type" content="article">
<meta property="og:title" content="QString类">
<meta property="og:url" content="https://txt1994.github.io/2022/03/02/QtDocumentCN/Src/S/QString/QString/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:description" content="QString Class 公共类型 公共函数 静态公共成员 非相关成员 宏 详细描述 初始化字符串 操作字符串数据 查询字符串数据 在编码字符串数据和 QString 之间转换 NULL字符串和Empty字符串之间的区别 数字格式 更高效的字符串构造 最大大小和内存不足情况   成员类型文档 QString::ConstIterator QString::Iterator enum Q">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2022-03-02T06:47:47.000Z">
<meta property="article:modified_time" content="2022-03-18T16:54:55.401Z">
<meta property="article:author" content="John Doe">
<meta property="article:tag" content="S">
<meta name="twitter:card" content="summary_large_image">
  
  
  <title>QString类 - Hexo</title>

  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4/dist/css/bootstrap.min.css" />


  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/github-markdown-css@4/github-markdown.min.css" />
  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/hint.css@2/hint.min.css" />

  
    
    
      
      <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@10/styles/github-gist.min.css" />
    
  

  
    <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3/dist/jquery.fancybox.min.css" />
  


<!-- 主题依赖的图标库，不要自行修改 -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_ba1fz6golrf.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_lbnruvf0jn.css">


<link  rel="stylesheet" href="/css/main.css" />

<!-- 自定义样式保持在最底部 -->

  
<link rel="stylesheet" href="/css/style.css">



  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    var CONFIG = {"hostname":"txt1994.github.io","root":"/","version":"1.8.14","typing":{"enable":true,"typeSpeed":70,"cursorChar":"_","loop":false},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"right","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"copy_btn":true,"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":false,"baidu":null,"google":null,"gtag":null,"tencent":{"sid":null,"cid":null},"woyaola":null,"cnzz":null,"leancloud":{"app_id":null,"app_key":null,"server_url":null,"path":"window.location.pathname","ignore_local":false}},"search_path":"/local-search.xml"};
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
<meta name="generator" content="Hexo 6.1.0">
<style>.github-emoji { position: relative; display: inline-block; width: 1.2em; min-height: 1.2em; overflow: hidden; vertical-align: top; color: transparent; }  .github-emoji > span { position: relative; z-index: 10; }  .github-emoji img, .github-emoji .fancybox { margin: 0 !important; padding: 0 !important; border: none !important; outline: none !important; text-decoration: none !important; user-select: none !important; cursor: auto !important; }  .github-emoji img { height: 1.2em !important; width: 1.2em !important; position: absolute !important; left: 50% !important; top: 50% !important; transform: translate(-50%, -50%) !important; user-select: none !important; cursor: auto !important; } .github-emoji-fallback { color: inherit; } .github-emoji-fallback img { opacity: 0 !important; }</style>
</head>


<body>
  <header style="height: 70vh;">
    <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/">
      <strong>txt1994s</strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/">
                <i class="iconfont icon-home-fill"></i>
                首页
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/">
                <i class="iconfont icon-archive-fill"></i>
                归档
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/">
                <i class="iconfont icon-tags-fill"></i>
                标签
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/">
                <i class="iconfont icon-user-fill"></i>
                关于
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/links/">
                <i class="iconfont icon-link-fill"></i>
                友联
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              &nbsp;<i class="iconfont icon-search"></i>&nbsp;
            </a>
          </li>
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">&nbsp;<i
                class="iconfont icon-dark" id="color-toggle-icon"></i>&nbsp;</a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

    <div class="banner" id="banner" parallax=true
         style="background: url('/img/default.png') no-repeat center center;
           background-size: cover;">
      <div class="full-bg-img">
        <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
          <div class="page-header text-center fade-in-up">
            <span class="h2" id="subtitle" title="QString类">
              
            </span>

            
              <div class="mt-3">
  
  
    <span class="post-meta">
      <i class="iconfont icon-date-fill" aria-hidden="true"></i>
      <time datetime="2022-03-02 14:47" pubdate>
        2022年3月2日 下午
      </time>
    </span>
  
</div>

<div class="mt-1">
  
    <span class="post-meta mr-2">
      <i class="iconfont icon-chart"></i>
      116k 字
    </span>
  

  
    <span class="post-meta mr-2">
      <i class="iconfont icon-clock-fill"></i>
      
      
      968 分钟
    </span>
  

  
  
</div>

            
          </div>

          
        </div>
      </div>
    </div>
  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="d-none d-lg-block col-lg-2"></div>
    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div class="py-5" id="board">
          <article class="post-content mx-auto">
            <!-- SEO header -->
            <h1 style="display: none">QString类</h1>
            
              <p class="note note-info">
                
                  本文最后更新于：2022年3月19日 凌晨
                
              </p>
            
            <div class="markdown-body">
              <div class="toc">

<!-- toc -->

<ul>
<li><a href="#qstring-class">QString Class</a><ul>
<li><a href="#gong-gong-lei-xing">公共类型</a></li>
<li><a href="#gong-gong-han-shu">公共函数</a></li>
<li><a href="#jing-tai-gong-gong-cheng-yuan">静态公共成员</a></li>
<li><a href="#fei-xiang-guan-cheng-yuan">非相关成员</a></li>
<li><a href="#hong">宏</a></li>
<li><a href="#xiang-xi-miao-shu">详细描述</a><ul>
<li><a href="#chu-shi-hua-zi-fu-chuan">初始化字符串</a></li>
<li><a href="#cao-zuo-zi-fu-chuan-shu-ju">操作字符串数据</a></li>
<li><a href="#cha-xun-zi-fu-chuan-shu-ju">查询字符串数据</a></li>
<li><a href="#zai-bian-ma-zi-fu-chuan-shu-ju-he-qstring-zhi-jian-zhuan-huan">在编码字符串数据和 QString 之间转换</a></li>
<li><a href="#null-zi-fu-chuan-he-empty-zi-fu-chuan-zhi-jian-de-qu-bie">NULL字符串和Empty字符串之间的区别</a></li>
<li><a href="#shu-zi-ge-shi">数字格式</a></li>
<li><a href="#geng-gao-xiao-de-zi-fu-chuan-gou-zao">更高效的字符串构造</a></li>
<li><a href="#zui-da-da-xiao-he-nei-cun-bu-zu-qing-kuang">最大大小和内存不足情况</a></li>
</ul>
</li>
<li><a href="#cheng-yuan-lei-xing-wen-dang">成员类型文档</a><ul>
<li><a href="#qstring-constiterator">QString::ConstIterator</a></li>
<li><a href="#qstring-iterator">QString::Iterator</a></li>
<li><a href="#enum-qstring-normalizationform">enum QString::NormalizationForm</a></li>
<li><a href="#enum-qstring-sectionflag-flags-qstring-sectionflags">enum QString::SectionFlag flags QString::SectionFlags</a></li>
<li><a href="#qstring-const-iterator">QString::const_iterator</a></li>
<li><a href="#qstring-const-pointer">QString::const_pointer</a></li>
<li><a href="#qstring-const-reference">QString::const_reference</a></li>
<li><a href="#since-5-6-qstring-const-reverse-iterator"><code>[since 5.6]</code>QString::const_reverse_iterator</a></li>
<li><a href="#qstring-difference-type">QString::difference_type</a></li>
<li><a href="#qstring-iterator">QString::iterator</a></li>
<li><a href="#qstring-pointer">QString::pointer</a></li>
<li><a href="#qstring-reference">QString::reference</a></li>
<li><a href="#since-5-6-qstring-reverse-iterator"><code>[since 5.6]</code>QString::reverse_iterator</a></li>
<li><a href="#qstring-size-type">QString::size_type</a></li>
<li><a href="#qstring-value-type">QString::value_type</a></li>
</ul>
</li>
<li><a href="#cheng-yuan-han-shu-wen-dang">成员函数文档</a><ul>
<li><a href="#since-6-0-template-typename-needle-typename-flags-decltype-qtokenize-qstringtokenizer-html-qtokenize-std-move-this-std-forward-needle-needle-flags-qstring-tokenize-needle-sep-flags-flags"><code>[since 6.0]</code>template &lt;typename Needle, typename Flags&gt; decltype(</a><a href="qstringtokenizer.html#qTokenize">qTokenize</a>(std::move(*this), std::forward<needle>(needle), flags…)) QString::tokenize(Needle &amp;&amp;<em>sep</em>, Flags… <em>flags</em>) &amp;&amp;</needle></li>
<li><a href="#since-6-0-template-typename-needle-typename-flags-decltype-qtokenize-qstringtokenizer-html-qtokenize-this-std-forward-needle-needle-flags-qstring-tokenize-needle-sep-flags-flags-const"><code>[since 6.0]</code>template &lt;typename Needle, typename Flags&gt; decltype(</a><a href="qstringtokenizer.html#qTokenize">qTokenize</a>(*this, std::forward<needle>(needle), flags…)) QString::tokenize(Needle &amp;&amp;<em>sep</em>, Flags… <em>flags</em>) const &amp;</needle></li>
<li><a href="#since-6-0-template-typename-needle-typename-flags-decltype-qtokenize-qstringtokenizer-html-qtokenize-this-std-forward-needle-needle-flags-qstring-tokenize-needle-sep-flags-flags-const-1"><code>[since 6.0]</code>template &lt;typename Needle, typename Flags&gt; decltype(</a><a href="qstringtokenizer.html#qTokenize">qTokenize</a>(*this, std::forward<needle>(needle), flags…)) QString::tokenize(Needle &amp;&amp;<em>sep</em>, Flags… <em>flags</em>) const &amp;</needle></li>
<li><a href="#since-5-14-template-typename-args-qstring-qstring-qstring-arg-args-args-const"><code>[since 5.14]</code>template <typename args> </typename></a><a href="#QString">QString</a> QString::arg(Args &amp;&amp;… <em>args</em>) const</li>
<li><a href="#qstring-qstring-const-qbytearray-qbytearray-html-ba">QString::QString(const </a><a href="qbytearray.html">QByteArray</a> &amp;<em>ba</em>)</li>
<li><a href="#qstring-qstring-const-char-str">QString::QString(const char *<em>str</em>)</a></li>
<li><a href="#since-5-2-qstring-qstring-qstring-qstring-other"><code>[since 5.2]</code>QString::QString(</a><a href="#QString">QString</a> &amp;&amp;<em>other</em>)</li>
<li><a href="#qstring-qstring-const-qstring-qstring-other">QString::QString(const </a><a href="#QString">QString</a> &amp;<em>other</em>)</li>
<li><a href="#since-6-1-template-typename-qstring-qstring-const-char8-t-str"><code>[since 6.1]</code>template <typename> QString::QString(const char8_t *<em>str</em>)</typename></a></li>
<li><a href="#qstring-qstring-qlatin1string-qlatin1string-html-str">QString::QString(</a><a href="qlatin1string.html">QLatin1String</a> <em>str</em>)</li>
<li><a href="#qstring-qstring-qsizetype-size-qchar-qchar-html-ch">QString::QString(qsizetype <em>size</em>, </a><a href="qchar.html">QChar</a> <em>ch</em>)</li>
<li><a href="#qstring-qstring-qchar-qchar-html-ch">QString::QString(</a><a href="qchar.html">QChar</a> <em>ch</em>)</li>
<li><a href="#qstring-qstring-const-qchar-qchar-html-unicode-qsizetype-size-1">QString::QString(const </a><a href="qchar.html">QChar</a> *<em>unicode</em>, qsizetype <em>size</em> = -1)</li>
<li><a href="#qstring-qstring">QString::QString()</a></li>
<li><a href="#qstring-qstring-qstring-operator-const-qbytearray-qbytearray-html-ba">QString</a></li>
<li><a href="#since-5-2-qstring-qstring-qstring-operator-qstring-qstring-other"><code>[since 5.2]</code></a><a href="#QString">QString</a> &amp;QString::operator=(<a href="#QString">QString</a> &amp;&amp;<em>other</em>)</li>
<li><a href="#qstring-qstring-qstring-operator-const-qstring-qstring-other-1">QString</a></li>
<li><a href="#qstring-qstring">QString::~QString()</a></li>
<li><a href="#qstring-qstring-qstring-append-const-qstring-qstring-str-2">QString</a></li>
<li><a href="#qstring-qstring-qstring-append-qchar-qchar-html-ch-3">QString</a></li>
<li><a href="#since-5-0-qstring-qstring-qstring-append-const-qchar-qchar-html-str-qsizetype-len"><code>[since 5.0]</code></a><a href="#QString">QString</a> &amp;QString::append(const <a href="qchar.html">QChar</a> *<em>str</em>, qsizetype <em>len</em>)</li>
<li><a href="#qstring-qstring-qstring-append-qlatin1string-qlatin1string-html-str-4">QString</a></li>
<li><a href="#qstring-qstring-qstring-append-const-char-str-5">QString</a></li>
<li><a href="#qstring-qstring-qstring-append-const-qbytearray-qbytearray-html-ba-6">QString</a></li>
<li><a href="#qstring-qstring-qstring-arg-const-qstring-qstring-a-int-fieldwidth-0-qchar-qchar-html-fillchar-qlatin1char-const-7">QString</a></li>
<li><a href="#qstring-qstring-qstring-arg-qlonglong-qtglobal-html-qlonglong-typedef-a-int-fieldwidth-0-int-base-10-qchar-qchar-html-fillchar-qlatin1char-const-8">QString</a></li>
<li><a href="#qstring-qstring-qstring-arg-qulonglong-qtglobal-html-qulonglong-typedef-a-int-fieldwidth-0-int-base-10-qchar-qchar-html-fillchar-qlatin1char-const-9">QString</a></li>
<li><a href="#qstring-qstring-qstring-arg-long-a-int-fieldwidth-0-int-base-10-qchar-qchar-html-fillchar-qlatin1char-const-10">QString</a></li>
<li><a href="#qstring-qstring-qstring-arg-ulong-qtglobal-html-ulong-typedef-a-int-fieldwidth-0-int-base-10-qchar-qchar-html-fillchar-qlatin1char-const-11">QString</a></li>
<li><a href="#qstring-qstring-qstring-arg-int-a-int-fieldwidth-0-int-base-10-qchar-qchar-html-fillchar-qlatin1char-const-12">QString</a></li>
<li><a href="#qstring-qstring-qstring-arg-uint-qtglobal-html-uint-typedef-a-int-fieldwidth-0-int-base-10-qchar-qchar-html-fillchar-qlatin1char-const-13">QString</a></li>
<li><a href="#qstring-qstring-qstring-arg-short-a-int-fieldwidth-0-int-base-10-qchar-qchar-html-fillchar-qlatin1char-const-14">QString</a></li>
<li><a href="#qstring-qstring-qstring-arg-ushort-qtglobal-html-ushort-typedef-a-int-fieldwidth-0-int-base-10-qchar-qchar-html-fillchar-qlatin1char-const-15">QString</a></li>
<li><a href="#qstring-qstring-qstring-arg-double-a-int-fieldwidth-0-char-format-g-int-precision-1-qchar-qchar-html-fillchar-qlatin1char-const-16">QString</a></li>
<li><a href="#qstring-qstring-qstring-arg-char-a-int-fieldwidth-0-qchar-qchar-html-fillchar-qlatin1char-const-17">QString</a></li>
<li><a href="#qstring-qstring-qstring-arg-qchar-qchar-html-a-int-fieldwidth-0-qchar-qchar-html-fillchar-qlatin1char-const-18">QString</a></li>
<li><a href="#since-5-10-qstring-qstring-qstring-arg-qstringview-qstringview-html-a-int-fieldwidth-0-qchar-qchar-html-fillchar-qlatin1char-const"><code>[since 5.10]</code></a><a href="#QString">QString</a> QString::arg(<a href="qstringview.html">QStringView</a> <em>a</em>, int <em>fieldWidth</em> = 0, <a href="qchar.html">QChar</a> <em>fillChar</em> = QLatin1Char(‘ ‘)) const</li>
<li><a href="#since-5-10-qstring-qstring-qstring-arg-qlatin1string-qlatin1string-html-a-int-fieldwidth-0-qchar-qchar-html-fillchar-qlatin1char-const"><code>[since 5.10]</code></a><a href="#QString">QString</a> QString::arg(<a href="qlatin1string.html">QLatin1String</a> <em>a</em>, int <em>fieldWidth</em> = 0, <a href="qchar.html">QChar</a> <em>fillChar</em> = QLatin1Char(‘ ‘)) const</li>
<li><a href="#static-since-5-5-qstring-qstring-qstring-asprintf-const-char-cformat"><code>[static, since 5.5]</code></a><a href="#QString">QString</a> QString::asprintf(const char *<em>cformat</em>, …)</li>
<li><a href="#const-qchar-qchar-html-qstring-at-qsizetype-position-const">const </a><a href="qchar.html">QChar</a> QString::at(qsizetype <em>position</em>) const</li>
<li><a href="#since-5-10-qchar-qchar-html-qstring-back-const"><code>[since 5.10]</code></a><a href="qchar.html">QChar</a> QString::back() const</li>
<li><a href="#since-5-10-qchar-qchar-html-qstring-back"><code>[since 5.10]</code></a><a href="qchar.html">QChar</a> &amp;QString::back()</li>
<li><a href="#qstring-iterator-iterator-typedefx-qstring-begin-1">QString::iterator</a></li>
<li><a href="#qstring-const-iterator-const-iterator-typedef-qstring-begin-const-1">QString::const_iterator</a></li>
<li><a href="#qsizetype-qstring-capacity-const">qsizetype QString::capacity() const</a></li>
<li><a href="#since-5-0-qstring-const-iterator-const-iterator-typedef-qstring-cbegin-const"><code>[since 5.0]</code></a><a href="#const_iterator-typedef">QString::const_iterator</a> QString::cbegin() const</li>
<li><a href="#since-5-0-qstring-const-iterator-const-iterator-typedef-qstring-cend-const"><code>[since 5.0]</code></a><a href="#const_iterator-typedef">QString::const_iterator</a> QString::cend() const</li>
<li><a href="#void-qstring-chop-qsizetype-n">void QString::chop(qsizetype <em>n</em>)</a></li>
<li><a href="#since-5-10-qstring-qstring-qstring-chopped-qsizetype-len-const"><code>[since 5.10]</code></a><a href="#QString">QString</a> QString::chopped(qsizetype <em>len</em>) const</li>
<li><a href="#void-qstring-clear">void QString::clear()</a></li>
<li><a href="#static-int-qstring-compare-const-qstring-qstring-s1-const-qstring-qstring-s2-qt-casesensitivity-qt-html-casesensitivity-enum-cs-qt-casesensitive"><code>[static]</code>int QString::compare(const </a><a href="#QString">QString</a> &amp;<em>s1</em>, const <a href="#QString">QString</a> &amp;<em>s2</em>, <a href="qt.html#CaseSensitivity-enum">Qt::CaseSensitivity</a> <em>cs</em> = Qt::CaseSensitive)</li>
<li><a href="#int-qstring-compare-const-qstring-qstring-other-qt-casesensitivity-qt-html-casesensitivity-enum-cs-qt-casesensitive-const">int QString::compare(const </a><a href="#QString">QString</a> &amp;<em>other</em>, <a href="qt.html#CaseSensitivity-enum">Qt::CaseSensitivity</a> <em>cs</em> = Qt::CaseSensitive) const</li>
<li><a href="#int-qstring-compare-qlatin1string-qlatin1string-html-other-qt-casesensitivity-qt-html-casesensitivity-enum-cs-qt-casesensitive-const">int QString::compare(</a><a href="qlatin1string.html">QLatin1String</a> <em>other</em>, <a href="qt.html#CaseSensitivity-enum">Qt::CaseSensitivity</a> <em>cs</em> = Qt::CaseSensitive) const</li>
<li><a href="#since-5-12-int-qstring-compare-qstringview-qstringview-html-s-qt-casesensitivity-qt-html-casesensitivity-enum-cs-qt-casesensitive-const"><code>[since 5.12]</code>int QString::compare(</a><a href="qstringview.html">QStringView</a> <em>s</em>, <a href="qt.html#CaseSensitivity-enum">Qt::CaseSensitivity</a> <em>cs</em> = Qt::CaseSensitive) const</li>
<li><a href="#since-5-14-int-qstring-compare-qchar-qchar-html-ch-qt-casesensitivity-qt-html-casesensitivity-enum-cs-qt-casesensitive-const"><code>[since 5.14]</code>int QString::compare(</a><a href="qchar.html">QChar</a> <em>ch</em>, <a href="qt.html#CaseSensitivity-enum">Qt::CaseSensitivity</a> <em>cs</em> = Qt::CaseSensitive) const</li>
<li><a href="#static-int-qstring-compare-const-qstring-qstring-s1-qlatin1string-qlatin1string-html-s2-qt-casesensitivity-qt-html-casesensitivity-enum-cs-qt-casesensitive"><code>[static]</code>int QString::compare(const </a><a href="#QString">QString</a> &amp;<em>s1</em>, <a href="qlatin1string.html">QLatin1String</a> <em>s2</em>, <a href="qt.html#CaseSensitivity-enum">Qt::CaseSensitivity</a> <em>cs</em> = Qt::CaseSensitive)</li>
<li><a href="#static-int-qstring-compare-qlatin1string-qlatin1string-html-s1-const-qstring-qstring-s2-qt-casesensitivity-qt-html-casesensitivity-enum-cs-qt-casesensitive"><code>[static]</code>int QString::compare(</a><a href="qlatin1string.html">QLatin1String</a> <em>s1</em>, const <a href="#QString">QString</a> &amp;<em>s2</em>, <a href="qt.html#CaseSensitivity-enum">Qt::CaseSensitivity</a> <em>cs</em> = Qt::CaseSensitive)</li>
<li><a href="#static-int-qstring-compare-const-qstring-qstring-s1-qstringview-qstringview-html-s2-qt-casesensitivity-qt-html-casesensitivity-enum-cs-qt-casesensitive"><code>[static]</code>int QString::compare(const </a><a href="#QString">QString</a> &amp;<em>s1</em>, <a href="qstringview.html">QStringView</a> <em>s2</em>, <a href="qt.html#CaseSensitivity-enum">Qt::CaseSensitivity</a> <em>cs</em> = Qt::CaseSensitive)</li>
<li><a href="#static-int-qstring-compare-qstringview-qstringview-html-s1-const-qstring-qstring-s2-qt-casesensitivity-qt-html-casesensitivity-enum-cs-qt-casesensitive"><code>[static]</code>int QString::compare(</a><a href="qstringview.html">QStringView</a> <em>s1</em>, const <a href="#QString">QString</a> &amp;<em>s2</em>, <a href="qt.html#CaseSensitivity-enum">Qt::CaseSensitivity</a> <em>cs</em> = Qt::CaseSensitive)</li>
<li><a href="#qstring-const-iterator-const-iterator-typedef-qstring-constbegin-const-2">QString::const_iterator</a></li>
<li><a href="#const-qchar-qchar-html-qstring-constdata-const">const </a><a href="qchar.html">QChar</a> *QString::constData() const</li>
<li><a href="#qstring-const-iterator-const-iterator-typedef-qstring-constend-const-3">QString::const_iterator</a></li>
<li><a href="#bool-qstring-contains-const-qstring-qstring-str-qt-casesensitivity-qt-html-casesensitivity-enum-cs-qt-casesensitive-const">bool QString::contains(const </a><a href="#QString">QString</a> &amp;<em>str</em>, <a href="qt.html#CaseSensitivity-enum">Qt::CaseSensitivity</a> <em>cs</em> = Qt::CaseSensitive) const</li>
<li><a href="#bool-qstring-contains-qchar-qchar-html-ch-qt-casesensitivity-qt-html-casesensitivity-enum-cs-qt-casesensitive-const">bool QString::contains(</a><a href="qchar.html">QChar</a> <em>ch</em>, <a href="qt.html#CaseSensitivity-enum">Qt::CaseSensitivity</a> <em>cs</em> = Qt::CaseSensitive) const</li>
<li><a href="#since-5-3-bool-qstring-contains-qlatin1string-qlatin1string-html-str-qt-casesensitivity-qt-html-casesensitivity-enum-cs-qt-casesensitive-const"><code>[since 5.3]</code>bool QString::contains(</a><a href="qlatin1string.html">QLatin1String</a> <em>str</em>, <a href="qt.html#CaseSensitivity-enum">Qt::CaseSensitivity</a> <em>cs</em> = Qt::CaseSensitive) const</li>
<li><a href="#since-5-14-bool-qstring-contains-qstringview-qstringview-html-str-qt-casesensitivity-qt-html-casesensitivity-enum-cs-qt-casesensitive-const"><code>[since 5.14]</code>bool QString::contains(</a><a href="qstringview.html">QStringView</a> <em>str</em>, <a href="qt.html#CaseSensitivity-enum">Qt::CaseSensitivity</a> <em>cs</em> = Qt::CaseSensitive) const</li>
<li><a href="#since-5-1-bool-qstring-contains-const-qregularexpression-qregularexpression-html-re-qregularexpressionmatch-qregularexpressionmatch-html-rmatch-nullptr-const"><code>[since 5.1]</code>bool QString::contains(const </a><a href="qregularexpression.html">QRegularExpression</a> &amp;<em>re</em>, <a href="qregularexpressionmatch.html">QRegularExpressionMatch</a> *<em>rmatch</em> = nullptr) const</li>
<li><a href="#qsizetype-qstring-count-const-qstring-qstring-str-qt-casesensitivity-qt-html-casesensitivity-enum-cs-qt-casesensitive-const">qsizetype QString::count(const </a><a href="#QString">QString</a> &amp;<em>str</em>, <a href="qt.html#CaseSensitivity-enum">Qt::CaseSensitivity</a> <em>cs</em> = Qt::CaseSensitive) const</li>
<li><a href="#qsizetype-qstring-count-const">qsizetype QString::count() const</a></li>
<li><a href="#qsizetype-qstring-count-qchar-qchar-html-ch-qt-casesensitivity-qt-html-casesensitivity-enum-cs-qt-casesensitive-const">qsizetype QString::count(</a><a href="qchar.html">QChar</a> <em>ch</em>, <a href="qt.html#CaseSensitivity-enum">Qt::CaseSensitivity</a> <em>cs</em> = Qt::CaseSensitive) const</li>
<li><a href="#since-6-0-qsizetype-qstring-count-qstringview-qstringview-html-str-qt-casesensitivity-qt-html-casesensitivity-enum-cs-qt-casesensitive-const"><code>[since 6.0]</code>qsizetype QString::count(</a><a href="qstringview.html">QStringView</a> <em>str</em>, <a href="qt.html#CaseSensitivity-enum">Qt::CaseSensitivity</a> <em>cs</em> = Qt::CaseSensitive) const</li>
<li><a href="#since-5-0-qsizetype-qstring-count-const-qregularexpression-qregularexpression-html-re-const"><code>[since 5.0]</code>qsizetype QString::count(const </a><a href="qregularexpression.html">QRegularExpression</a> &amp;<em>re</em>) const</li>
<li><a href="#since-5-6-qstring-const-reverse-iterator-const-reverse-iterator-typedef-qstring-crbegin-const"><code>[since 5.6]</code></a><a href="#const_reverse_iterator-typedef">QString::const_reverse_iterator</a> QString::crbegin() const</li>
<li><a href="#since-5-6-qstring-const-reverse-iterator-const-reverse-iterator-typedef-qstring-crend-const"><code>[since 5.6]</code></a><a href="#const_reverse_iterator-typedef">QString::const_reverse_iterator</a> QString::crend() const</li>
<li><a href="#qchar-qchar-html-qstring-data">QChar</a></li>
<li><a href="#const-qchar-qchar-html-qstring-data-const">const </a><a href="qchar.html">QChar</a> *QString::data() const</li>
<li><a href="#qstring-iterator-iterator-typedefx-qstring-end-2">QString::iterator</a></li>
<li><a href="#qstring-const-iterator-const-iterator-typedef-qstring-end-const-4">QString::const_iterator</a></li>
<li><a href="#bool-qstring-endswith-const-qstring-qstring-s-qt-casesensitivity-qt-html-casesensitivity-enum-cs-qt-casesensitive-const">bool QString::endsWith(const </a><a href="#QString">QString</a> &amp;<em>s</em>, <a href="qt.html#CaseSensitivity-enum">Qt::CaseSensitivity</a> <em>cs</em> = Qt::CaseSensitive) const</li>
<li><a href="#since-5-10-bool-qstring-endswith-qstringview-qstringview-html-str-qt-casesensitivity-qt-html-casesensitivity-enum-cs-qt-casesensitive-const"><code>[since 5.10]</code>bool QString::endsWith(</a><a href="qstringview.html">QStringView</a> <em>str</em>, <a href="qt.html#CaseSensitivity-enum">Qt::CaseSensitivity</a> <em>cs</em> = Qt::CaseSensitive) const</li>
<li><a href="#bool-qstring-endswith-qlatin1string-qlatin1string-html-s-qt-casesensitivity-qt-html-casesensitivity-enum-cs-qt-casesensitive-const">bool QString::endsWith(</a><a href="qlatin1string.html">QLatin1String</a> <em>s</em>, <a href="qt.html#CaseSensitivity-enum">Qt::CaseSensitivity</a> <em>cs</em> = Qt::CaseSensitive) const</li>
<li><a href="#bool-qstring-endswith-qchar-qchar-html-c-qt-casesensitivity-qt-html-casesensitivity-enum-cs-qt-casesensitive-const">bool QString::endsWith(</a><a href="qchar.html">QChar</a> <em>c</em>, <a href="qt.html#CaseSensitivity-enum">Qt::CaseSensitivity</a> <em>cs</em> = Qt::CaseSensitive) const</li>
<li><a href="#cong-6-1-kai-shi-qstring-iterator-iterator-typedefx-qstring-erase-qstring-const-iterator-const-iterator-typedef-first-qstring-const-iterator-const-iterator-typedef-last"><code>[从 6.1 开始]</code></a><a href="#iterator-typedefx">QString::iterator</a> QString::erase(<a href="#const_iterator-typedef">QString::const_iterator</a> <em>first</em>, [QString::const_iterator](# const_iterator-typedef) <em>last</em>)</li>
<li><a href="#qstring-qstring-qstring-fill-qchar-qchar-html-ch-qsizetype-size-1-19">QString</a></li>
<li><a href="#since-6-0-qstring-qstring-qstring-first-qsizetype-n-const"><code>[since 6.0]</code></a><a href="#QString">QString</a> QString::first(qsizetype <em>n</em>) const</li>
<li><a href="#static-since-5-2-qstring-qstring-qstring-fromcfstring-cfstringref-string"><code>[static, since 5.2]</code></a><a href="#QString">QString</a> QString::fromCFString(CFStringRef <em>string</em>)</li>
<li><a href="#static-qstring-qstring-qstring-fromlatin1-const-char-str-qsizetype-size"><code>[static]</code></a><a href="#QString">QString</a> QString::fromLatin1(const char *<em>str</em>, qsizetype <em>size</em>)</li>
<li><a href="#static-since-6-0-qstring-qstring-qstring-fromlatin1-qbytearrayview-qbytearrayview-html-str"><code>[static, since 6.0]</code></a><a href="#QString">QString</a> QString::fromLatin1(<a href="qbytearrayview.html">QByteArrayView</a> <em>str</em>)</li>
<li><a href="#static-since-5-0-template-typename-qstring-qstring-qstring-fromlatin1-const-qbytearray-qbytearray-html-str"><code>[static, since 5.0]</code>template <typename> </typename></a><a href="#QString">QString</a> QString::fromLatin1(const <a href="qbytearray.html">QByteArray</a> &amp;<em>str</em>)</li>
<li><a href="#static-qstring-qstring-qstring-fromlocal8bit-const-char-str-qsizetype-size"><code>[static]</code></a><a href="#QString">QString</a> QString::fromLocal8Bit(const char *<em>str</em>, qsizetype <em>size</em>)</li>
<li><a href="#static-since-6-0-qstring-qstring-qstring-fromlocal8bit-qbytearrayview-qbytearrayview-html-str"><code>[static, since 6.0]</code></a><a href="#QString">QString</a> QString::fromLocal8Bit(<a href="qbytearrayview.html">QByteArrayView</a> <em>str</em>)</li>
<li><a href="#static-since-5-0-template-typename-qstring-qstring-qstring-fromlocal8bit-const-qbytearray-qbytearray-html-str"><code>[static, since 5.0]</code>template <typename> </typename></a><a href="#QString">QString</a> QString::fromLocal8Bit(const <a href="qbytearray.html">QByteArray</a> &amp;<em>str</em>)</li>
<li><a href="#static-since-5-2-qstring-qstring-qstring-fromnsstring-const-nsstring-string"><code>[static, since 5.2]</code></a><a href="#QString">QString</a> QString::fromNSString(const NSString *<em>string</em>)</li>
<li><a href="#static-qstring-qstring-qstring-fromrawdata-const-qchar-qchar-html-unicode-qsizetype-size"><code>[static]</code></a><a href="#QString">QString</a> QString::fromRawData(const <a href="qchar.html">QChar</a> *<em>unicode</em>, qsizetype <em>size</em>)</li>
<li><a href="#static-qstring-qstring-qstring-fromstdstring-const-std-string-str"><code>[static]</code></a><a href="#QString">QString</a> QString::fromStdString(const std::string &amp;<em>str</em>)</li>
<li><a href="#static-since-5-5-qstring-qstring-qstring-fromstdu16string-const-std-u16string-str"><code>[static, since 5.5]</code></a><a href="#QString">QString</a> QString::fromStdU16String(const std::u16string &amp;<em>str</em>)</li>
<li><a href="#static-since-5-5-qstring-qstring-qstring-fromstdu32string-const-std-u32string-str"><code>[static, since 5.5]</code></a><a href="#QString">QString</a> QString::fromStdU32String(const std::u32string &amp;<em>str</em>)</li>
<li><a href="#static-qstring-qstring-qstring-fromstdwstring-const-std-wstring-str"><code>[static]</code></a><a href="#QString">QString</a> QString::fromStdWString(const std::wstring &amp;<em>str</em>)</li>
<li><a href="#static-since-5-3-qstring-qstring-qstring-fromucs4-const-char32-t-unicode-qsizetype-size-1"><code>[static, since 5.3]</code></a><a href="#QString">QString</a> QString::fromUcs4(const char32_t *<em>unicode</em>, qsizetype <em>size</em> = -1)</li>
<li><a href="#static-qstring-qstring-qstring-fromutf8-const-char-str-qsizetype-size"><code>[static]</code></a><a href="#QString">QString</a> QString::fromUtf8(const char *<em>str</em>, qsizetype <em>size</em>)</li>
<li><a href="#static-since-6-0-qstring-qstring-qstring-fromutf8-qbytearrayview-qbytearrayview-html-str"><code>[static, since 6.0]</code></a><a href="#QString">QString</a> QString::fromUtf8(<a href="qbytearrayview.html">QByteArrayView</a> <em>str</em>)</li>
<li><a href="#static-since-5-0-template-typename-qstring-qstring-qstring-fromutf8-const-qbytearray-qbytearray-html-str"><code>[static, since 5.0]</code>template <typename> </typename></a><a href="#QString">QString</a> QString::fromUtf8(const <a href="qbytearray.html">QByteArray</a> &amp;<em>str</em>)</li>
<li><a href="#static-since-6-1-template-typename-qstring-qstring-qstring-fromutf8-const-char8-t-str"><code>[static, since 6.1]</code>template <typename> </typename></a><a href="#QString">QString</a> QString::fromUtf8(const char8_t *<em>str</em>)</li>
<li><a href="#static-since-6-0-template-typename-qstring-qstring-qstring-fromutf8-const-char8-t-str-qsizetype-size"><code>[static, since 6.0]</code>template <typename> </typename></a><a href="#QString">QString</a> QString::fromUtf8(const char8_t *<em>str</em>, qsizetype <em>size</em>)</li>
<li><a href="#static-since-5-3-qstring-qstring-qstring-fromutf16-const-char16-t-unicode-qsizetype-size-1"><code>[static, since 5.3]</code></a><a href="#QString">QString</a> QString::fromUtf16(const char16_t *<em>unicode</em>, qsizetype <em>size</em> = -1)</li>
<li><a href="#static-qstring-qstring-qstring-fromwchararray-const-wchar-t-string-qsizetype-size-1"><code>[static]</code></a><a href="#QString">QString</a> QString::fromWCharArray(const wchar_t *<em>string</em>, qsizetype <em>size</em> = -1)</li>
<li><a href="#since-5-10-qchar-qchar-html-qstring-front-const"><code>[since 5.10]</code></a><a href="qchar.html">QChar</a> QString::front() const</li>
<li><a href="#since-5-10-qchar-qchar-html-qstring-front"><code>[since 5.10]</code></a><a href="qchar.html">QChar</a> &amp;QString::front()</li>
<li><a href="#qsizetype-qstring-indexof-qlatin1string-qlatin1string-html-str-qsizetype-from-0-qt-casesensitivity-qt-html-casesensitivity-enum-cs-qt-casesensitive-const">qsizetype QString::indexOf(</a><a href="qlatin1string.html">QLatin1String</a> <em>str</em>, qsizetype <em>from</em> = 0, <a href="qt.html#CaseSensitivity-enum">Qt::CaseSensitivity</a> <em>cs</em> = Qt::CaseSensitive) const</li>
<li><a href="#qsizetype-qstring-indexof-qchar-qchar-html-ch-qsizetype-from-0-qt-casesensitivity-qt-html-casesensitivity-enum-cs-qt-casesensitive-const">qsizetype QString::indexOf(</a><a href="qchar.html">QChar</a> <em>ch</em>, qsizetype <em>from</em> = 0, <a href="qt.html#CaseSensitivity-enum">Qt::CaseSensitivity</a> <em>cs</em> = Qt::CaseSensitive）const</li>
<li><a href="#qsizetype-qstring-indexof-const-qstring-qstring-str-qsizetype-from-0-qt-casesensitivity-qt-html-casesensitivity-enum-cs-qt-casesensitive-const">qsizetype QString::indexOf(const </a><a href="#QString">QString</a> &amp;<em>str</em>, qsizetype <em>from</em> = 0, <a href="qt.html#CaseSensitivity-enum">Qt::CaseSensitivity</a> <em>cs</em> = Qt::CaseSensitive) const</li>
<li><a href="#since-5-14-qsizetype-qstring-indexof-qstringview-qstringview-html-str-qsizetype-from-0-qt-casesensitivity-qt-html-casesensitivity-enum-cs-qt-casesensitive-const"><code>[since 5.14]</code>qsizetype QString::indexOf(</a><a href="qstringview.html">QStringView</a> <em>str</em>, qsizetype <em>from</em> = 0, <a href="qt.html#CaseSensitivity-enum">Qt::CaseSensitivity</a> <em>cs</em> = Qt::CaseSensitive) const</li>
<li><a href="#since-5-5-qsizetype-qstring-indexof-const-qregularexpression-qregularexpression-html-re-qsizetype-from-0-qregularexpressionmatch-qregularexpressionmatch-html-rmatch-nullptr-const"><code>[since 5.5]</code>qsizetype QString::indexOf(const </a><a href="qregularexpression.html">QRegularExpression</a> &amp;<em>re</em>, qsizetype <em>from</em> = 0, <a href="qregularexpressionmatch.html">QRegularExpressionMatch</a> *<em>rmatch</em> = nullptr) const</li>
<li><a href="#qstring-qstring-qstring-insert-qsizetype-position-const-qstring-qstring-str-20">QString</a></li>
<li><a href="#qstring-qstring-qstring-insert-qsizetype-position-qchar-qchar-html-ch-21">QString</a></li>
<li><a href="#qstring-qstring-qstring-insert-qsizetype-position-const-qchar-qchar-html-unicode-qsizetype-size-22">QString</a></li>
<li><a href="#since-6-0-qstring-qstring-qstring-insert-qsizetype-position-qstringview-qstringview-html-str"><code>[since 6.0]</code></a><a href="#QString">QString</a> &amp;QString::insert(qsizetype <em>position</em>, <a href="qstringview.html">QStringView</a> <em>str</em>)</li>
<li><a href="#qstring-qstring-qstring-insert-qsizetype-position-qlatin1string-qlatin1string-html-str-23">QString</a></li>
<li><a href="#since-5-5-qstring-qstring-qstring-insert-qsizetype-position-const-char-str"><code>[since 5.5]</code></a><a href="#QString">QString</a> &amp;QString::insert(qsizetype <em>position</em>, const char *<em>str</em>)</li>
<li><a href="#since-5-5-qstring-qstring-qstring-insert-qsizetype-position-const-qbytearray-qbytearray-html-str"><code>[since 5.5]</code></a><a href="#QString">QString</a> &amp;QString::insert(qsizetype <em>position</em>, const <a href="qbytearray.html">QByteArray</a> &amp;<em>str</em>)</li>
<li><a href="#bool-qstring-isempty-const">bool QString::isEmpty() const</a></li>
<li><a href="#since-5-12-bool-qstring-islower-const"><code>[since 5.12]</code>bool QString::isLower() const</a></li>
<li><a href="#bool-qstring-isnull-const">bool QString::isNull() const</a></li>
<li><a href="#bool-qstring-isrighttoleft-const">bool QString::isRightToLeft() const</a></li>
<li><a href="#since-5-12-bool-qstring-isupper-const"><code>[since 5.12]</code>bool QString::isUpper() const</a></li>
<li><a href="#since-5-15-bool-qstring-isvalidutf16-const"><code>[since 5.15]</code>bool QString::isValidUtf16() const</a></li>
<li><a href="#since-6-0-qstring-qstring-qstring-last-qsizetype-n-const"><code>[since 6.0]</code></a><a href="#QString">QString</a> QString::last(qsizetype <em>n</em>) const</li>
<li><a href="#qsizetype-qstring-lastindexof-const-qstring-qstring-str-qsizetype-from-qt-casesensitivity-qt-html-casesensitivity-enum-cs-qt-casesensitive-const">qsizetype QString::lastIndexOf(const </a><a href="#QString">QString</a> &amp;<em>str</em>, qsizetype <em>from</em>, <a href="qt.html#CaseSensitivity-enum">Qt::CaseSensitivity</a> <em>cs</em> = Qt::CaseSensitive) const</li>
<li><a href="#qsizetype-qstring-lastindexof-qchar-qchar-html-ch-qsizetype-from-1-qt-casesensitivity-qt-html-casesensitivity-enum-cs-qt-casesensitive-const">qsizetype QString::lastIndexOf(</a><a href="qchar.html">QChar</a> <em>ch</em>, qsizetype <em>from</em> = -1, <a href="qt.html#CaseSensitivity-enum">Qt::CaseSensitivity</a> <em>cs</em> = Qt::CaseSensitive) const</li>
<li><a href="#since-6-2-qsizetype-qstring-lastindexof-qlatin1string-qlatin1string-html-str-qt-casesensitivity-qt-html-casesensitivity-enum-cs-qt-casesensitive-const"><code>[since 6.2]</code>qsizetype QString::lastIndexOf(</a><a href="qlatin1string.html">QLatin1String</a> <em>str</em>, <a href="qt.html#CaseSensitivity-enum">Qt::CaseSensitivity</a> <em>cs</em> = Qt::CaseSensitive) const</li>
<li><a href="#qsizetype-qstring-lastindexof-qlatin1string-qlatin1string-html-str-qsizetype-from-qt-casesensitivity-qt-html-casesensitivity-enum-cs-qt-casesensitive-const">qsizetype QString::lastIndexOf(</a><a href="qlatin1string.html">QLatin1String</a> <em>str</em>, qsizetype <em>from</em>, <a href="qt.html#CaseSensitivity-enum">Qt::CaseSensitivity</a> <em>cs</em> = Qt::CaseSensitive) const</li>
<li><a href="#since-6-2-qsizetype-qstring-lastindexof-const-qstring-qstring-str-qt-casesensitivity-qt-html-casesensitivity-enum-cs-qt-casesensitive-const"><code>[since 6.2]</code>qsizetype QString::lastIndexOf(const </a><a href="#QString">QString</a> &amp;<em>str</em>, <a href="qt.html#CaseSensitivity-enum">Qt::CaseSensitivity</a> <em>cs</em> = Qt::CaseSensitive) const</li>
<li><a href="#since-6-2-qsizetype-qstring-lastindexof-qstringview-qstringview-html-str-qt-casesensitivity-qt-html-casesensitivity-enum-cs-qt-casesensitive-const"><code>[since 6.2]</code>qsizetype QString::lastIndexOf(</a><a href="qstringview.html">QStringView</a> <em>str</em>, <a href="qt.html#CaseSensitivity-enum">Qt::CaseSensitivity</a> <em>cs</em> = Qt::CaseSensitive) const</li>
<li><a href="#since-5-14-qsizetype-qstring-lastindexof-qstringview-qstringview-html-str-qsizetype-from-qt-casesensitivity-qt-html-casesensitivity-enum-cs-qt-casesensitive-const"><code>[since 5.14]</code>qsizetype QString::lastIndexOf(</a><a href="qstringview.html">QStringView</a> <em>str</em>, qsizetype <em>from</em>, <a href="qt.html#CaseSensitivity-enum">Qt::CaseSensitivity</a> <em>cs</em> = Qt::CaseSensitive) const</li>
<li><a href="#since-6-2-qsizetype-qstring-lastindexof-const-qregularexpression-qregularexpression-html-re-qregularexpressionmatch-qregularexpressionmatch-html-rmatch-nullptr-const"><code>[since 6.2]</code>qsizetype QString::lastIndexOf(const </a><a href="qregularexpression.html">QRegularExpression</a> &amp;<em>re</em>, <a href="qregularexpressionmatch.html">QRegularExpressionMatch</a> *<em>rmatch</em> = nullptr) const</li>
<li><a href="#since-5-5-qsizetype-qstring-lastindexof-const-qregularexpression-qregularexpression-html-re-qsizetype-from-qregularexpressionmatch-qregularexpressionmatch-html-rmatch-nullptr-const"><code>[since 5.5]</code>qsizetype QString::lastIndexOf(const </a><a href="qregularexpression.html">QRegularExpression</a> &amp;<em>re</em>, qsizetype <em>from</em>, <a href="qregularexpressionmatch.html">QRegularExpressionMatch</a> *<em>rmatch</em> = nullptr) const</li>
<li><a href="#qstring-qstring-qstring-left-qsizetype-n-const-24">QString</a></li>
<li><a href="#qstring-qstring-qstring-leftjustified-qsizetype-width-qchar-qchar-html-fill-qlatin1char-bool-truncate-false-const-25">QString</a></li>
<li><a href="#qsizetype-qstring-length-const">qsizetype QString::length() const</a></li>
<li><a href="#static-int-qstring-localeawarecompare-const-qstring-qstring-s1-const-qstring-qstring-s2"><code>[static]</code>int QString::localeAwareCompare(const </a><a href="#QString">QString</a> &amp;<em>s1</em>, const <a href="#QString">QString</a> &amp;<em>s2</em>)</li>
<li><a href="#int-qstring-localeawarecompare-const-qstring-qstring-other-const">int QString::localeAwareCompare(const </a><a href="#QString">QString</a> &amp;<em>other</em>) const</li>
<li><a href="#since-6-0-int-qstring-localeawarecompare-qstringview-qstringview-html-other-const"><code>[since 6.0]</code>int QString::localeAwareCompare(</a><a href="qstringview.html">QStringView</a> <em>other</em>) const</li>
<li><a href="#static-since-6-0-int-qstring-localeawarecompare-qstringview-qstringview-html-s1-qstringview-qstringview-html-s2"><code>[static, since 6.0]</code>int QString::localeAwareCompare(</a><a href="qstringview.html">QStringView</a> <em>s1</em>, <a href="qstringview.html">QStringView</a> <em>s2</em>)</li>
<li><a href="#qstring-qstring-qstring-mid-qsizetype-position-qsizetype-n-1-const-26">QString</a></li>
<li><a href="#qstring-qstring-qstring-normalized-qstring-normalizationform-normalizationform-enum-mode-qchar-unicodeversion-qchar-html-unicodeversion-enum-version-qchar-unicode-unassigned-const-27">QString</a></li>
<li><a href="#static-qstring-qstring-qstring-number-long-n-int-base-10"><code>[static]</code></a><a href="#QString">QString</a> QString::number(long <em>n</em>, int <em>base</em> = 10)</li>
<li><a href="#static-qstring-qstring-qstring-number-int-n-int-base-10"><code>[static]</code></a><a href="#QString">QString</a> QString::number(int <em>n</em>, int <em>base</em> = 10)</li>
<li><a href="#static-qstring-qstring-qstring-number-uint-qtglobal-html-uint-typedef-n-int-base-10"><code>[static]</code></a><a href="#QString">QString</a> QString::number(<a href="qtglobal.html#uint-typedef">uint</a> <em>n</em>, int <em>base</em> = 10)</li>
<li><a href="#static-qstring-qstring-qstring-number-ulong-qtglobal-html-ulong-typedef-n-int-base-10"><code>[static]</code></a><a href="#QString">QString</a> QString::number(<a href="qtglobal.html#ulong-typedef">ulong</a> <em>n</em>, int <em>base</em> = 10)</li>
<li><a href="#static-qstring-qstring-qstring-number-qlonglong-qtglobal-html-qlonglong-typedef-n-int-base-10"><code>[static]</code></a><a href="#QString">QString</a> QString::number(<a href="qtglobal.html#qlonglong-typedef">qlonglong</a> <em>n</em>, int <em>base</em> = 10)</li>
<li><a href="#static-qstring-qstring-qstring-number-qulonglong-qtglobal-html-qulonglong-typedef-n-int-base-10"><code>[static]</code></a><a href="#QString">QString</a> QString::number(<a href="qtglobal.html#qulonglong-typedef">qulonglong</a> <em>n</em>, int <em>base</em> = 10)</li>
<li><a href="#static-qstring-qstring-qstring-number-double-n-char-format-g-int-precision-6"><code>[static]</code></a><a href="#QString">QString</a> QString::number(double <em>n</em>, char <em>format</em> = ‘g’, int <em>precision</em> = 6)</li>
<li><a href="#qstring-qstring-qstring-prepend-const-qstring-qstring-str-28">QString</a></li>
<li><a href="#qstring-qstring-qstring-prepend-qchar-qchar-html-ch-29">QString</a></li>
<li><a href="#since-5-5-qstring-qstring-qstring-prepend-const-qchar-qchar-html-str-qsizetype-len"><code>[since 5.5]</code></a><a href="#QString">QString</a> &amp;QString::prepend(const <a href="qchar.html">QChar</a> *<em>str</em>, qsizetype <em>len</em>)</li>
<li><a href="#cong-6-0-kai-shi-qstring-qstring-qstring-prepend-qstringview-qstringview-html-str"><code>[从 6.0 开始]</code></a><a href="#QString">QString</a> &amp;QString::prepend(<a href="qstringview.html">QStringView</a> <em>str</em>)</li>
<li><a href="#qstring-qstring-qstring-prepend-qlatin1string-qlatin1string-html-str-30">QString</a></li>
<li><a href="#qstring-qstring-qstring-prepend-const-char-str-31">QString</a></li>
<li><a href="#qstring-qstring-qstring-prepend-const-qbytearray-qbytearray-html-ba-32">QString</a></li>
<li><a href="#void-qstring-push-back-const-qstring-qstring-other">void QString::push_back(const </a><a href="#QString">QString</a> &amp;<em>other</em>)</li>
<li><a href="#void-qstring-push-back-qchar-qchar-html-ch">void QString::push_back(</a><a href="qchar.html">QChar</a> <em>ch</em>)</li>
<li><a href="#void-qstring-push-front-const-qstring-qstring-other">void QString::push_front(const </a><a href="#QString">QString</a> &amp;<em>other</em>)</li>
<li><a href="#void-qstring-push-front-qchar-qchar-html-ch">void QString::push_front(</a><a href="qchar.html">QChar</a> <em>ch</em>)</li>
<li><a href="#5-6-qi-qstring-reverse-iterator-reverse-iterator-typedef-qstring-rbegin"><code>[5.6 起]</code></a><a href="#reverse_iterator-typedef">QString::reverse_iterator</a> QString::rbegin()</li>
<li><a href="#5-6-qi-qstring-const-reverse-iterator-const-reverse-iterator-typedef-qstring-rbegin-const"><code>[5.6 起]</code></a><a href="#const_reverse_iterator-typedef">QString::const_reverse_iterator</a> QString::rbegin() const</li>
<li><a href="#qstring-qstring-qstring-remove-qsizetype-position-qsizetype-n-33">QString</a></li>
<li><a href="#qstring-qstring-qstring-remove-qchar-qchar-html-ch-qt-casesensitivity-qt-html-casesensitivity-enum-cs-qt-casesensitive-34">QString</a></li>
<li><a href="#since-5-11-qstring-qstring-qstring-remove-qlatin1string-qlatin1string-html-str-qt-casesensitivity-qt-html-casesensitivity-enum-cs-qt-casesensitive"><code>[since 5.11]</code></a><a href="#QString">QString</a> &amp;QString::remove(<a href="qlatin1string.html">QLatin1String</a> <em>str</em>, <a href="qt.html#CaseSensitivity-enum">Qt::CaseSensitivity</a> <em>cs</em> = Qt::CaseSensitive)</li>
<li><a href="#qstring-qstring-qstring-remove-const-qstring-qstring-str-qt-casesensitivity-qt-html-casesensitivity-enum-cs-qt-casesensitive-35">QString</a></li>
<li><a href="#since-5-0-qstring-qstring-qstring-remove-const-qregularexpression-qregularexpression-html-re"><code>[since 5.0]</code></a><a href="#QString">QString</a> &amp;QString::remove(const <a href="qregularexpression.html">QRegularExpression</a> &amp;<em>re</em>)</li>
<li><a href="#since-6-1-template-typename-predicate-qstring-qstring-qstring-removeif-predicate-pred"><code>[since 6.1]</code>template <typename predicate> </typename></a><a href="#QString">QString</a> &amp;QString::removeIf(Predicate <em>pred</em>)</li>
<li><a href="#since-5-6-qstring-reverse-iterator-reverse-iterator-typedef-qstring-rend"><code>[since 5.6]</code></a><a href="#reverse_iterator-typedef">QString::reverse_iterator</a> QString::rend()</li>
<li><a href="#since-5-6-qstring-const-reverse-iterator-const-reverse-iterator-typedef-qstring-rend-const"><code>[since 5.6]</code></a><a href="#const_reverse_iterator-typedef">QString::const_reverse_iterator</a> QString::rend() const</li>
<li><a href="#qstring-qstring-qstring-repeated-qsizetype-times-const-36">QString</a></li>
<li><a href="#qstring-qstring-qstring-replace-qsizetype-position-qsizetype-n-const-qstring-qstring-after-37">QString</a></li>
<li><a href="#qstring-qstring-qstring-replace-qsizetype-position-qsizetype-n-qchar-qchar-html-after-38">QString</a></li>
<li><a href="#qstring-qstring-qstring-replace-qsizetype-position-qsizetype-n-const-qchar-qchar-html-unicode-qsizetype-size-39">QString</a></li>
<li><a href="#qstring-qstring-qstring-replace-qchar-qchar-html-before-qchar-qchar-html-after-qt-casesensitivity-qt-html-casesensitivity-enum-cs-qt-casesensitive-40">QString</a></li>
<li><a href="#qstring-qstring-qstring-replace-const-qchar-qchar-html-before-qsizetype-blen-const-qchar-qchar-html-after-qsizetype-alen-qt-casesensitivity-qt-html-casesensitivity-enum-cs-qt-casesensitive-41">QString</a></li>
<li><a href="#qstring-qstring-qstring-replace-qlatin1string-qlatin1string-html-before-qlatin1string-qlatin1string-html-after-qt-casesensitivity-qt-html-casesensitivity-enum-cs-qt-casesensitive-42">QString</a></li>
<li><a href="#qstring-qstring-qstring-replace-qlatin1string-qlatin1string-html-before-const-qstring-qstring-after-qt-casesensitivity-qt-html-casesensitivity-enum-cs-qt-casesensitive-43">QString</a></li>
<li><a href="#qstring-qstring-qstring-replace-const-qstring-qstring-before-qlatin1string-qlatin1string-html-after-qt-casesensitivity-qt-html-casesensitivity-enum-cs-qt-casesensitive-44">QString</a></li>
<li><a href="#qstring-qstring-qstring-replace-const-qstring-qstring-before-const-qstring-qstring-after-qt-casesensitivity-qt-html-casesensitivity-enum-cs-qt-casesensitive-45">QString</a></li>
<li><a href="#qstring-qstring-qstring-replace-qchar-qchar-html-ch-const-qstring-qstring-after-qt-casesensitivity-qt-html-casesensitivity-enum-cs-qt-casesensitive-46">QString</a></li>
<li><a href="#qstring-qstring-qstring-replace-qchar-qchar-html-c-qlatin1string-qlatin1string-html-after-qt-casesensitivity-qt-html-casesensitivity-enum-cs-qt-casesensitive-47">QString</a></li>
<li><a href="#since-5-0-qstring-qstring-qstring-replace-const-qregularexpression-qregularexpression-html-re-const-qstring-qstring-after"><code>[since 5.0]</code></a><a href="#QString">QString</a> &amp;QString::replace(const <a href="qregularexpression.html">QRegularExpression</a> &amp;<em>re</em>, const <a href="#QString">QString</a> &amp;<em>after</em>)</li>
<li><a href="#void-qstring-reserve-qsizetype-size">void QString::reserve(qsizetype <em>size</em>)</a></li>
<li><a href="#void-qstring-resize-qsizetype-size">void QString::resize(qsizetype <em>size</em>)</a></li>
<li><a href="#since-5-7-void-qstring-resize-qsizetype-size-qchar-qchar-html-fillchar"><code>[since 5.7]</code>void QString::resize(qsizetype <em>size</em>, </a><a href="qchar.html">QChar</a> <em>fillChar</em>)</li>
<li><a href="#qstring-qstring-qstring-right-qsizetype-n-const-48">QString</a></li>
<li><a href="#qstring-qstring-qstring-rightjustified-qsizetype-width-qchar-qchar-html-fill-qlatin1char-bool-truncate-false-const-49">QString</a></li>
<li><a href="#qstring-qstring-qstring-section-qchar-qchar-html-sep-qsizetype-start-qsizetype-end-1-qstring-sectionflags-sectionflag-enum-flags-sectiondefault-const-50">QString</a></li>
<li><a href="#qstring-qstring-qstring-section-const-qstring-qstring-sep-qsizetype-start-qsizetype-end-1-qstring-sectionflags-sectionflag-enum-flags-sectiondefault-const-51">QString</a></li>
<li><a href="#since-5-0-qstring-qstring-qstring-section-const-qregularexpression-qregularexpression-html-re-qsizetype-start-qsizetype-end-1-qstring-sectionflags-sectionflag-enum-flags-sectiondefault-const"><code>[since 5.0]</code></a><a href="#QString">QString</a> QString::section(const <a href="qregularexpression.html">QRegularExpression</a> &amp;<em>re</em>, qsizetype <em>start</em>, qsizetype <em>end</em> = -1, <a href="#SectionFlag-enum">QString::SectionFlags</a> <em>flags</em> = SectionDefault) const</li>
<li><a href="#qstring-qstring-qstring-setnum-int-n-int-base-10-52">QString</a></li>
<li><a href="#qstring-qstring-qstring-setnum-short-n-int-base-10-53">QString</a></li>
<li><a href="#qstring-qstring-qstring-setnum-ushort-qtglobal-html-ushort-typedef-n-int-base-10-54">QString</a></li>
<li><a href="#qstring-qstring-qstring-setnum-uint-qtglobal-html-uint-typedef-n-int-base-10-55">QString</a></li>
<li><a href="#qstring-qstring-qstring-setnum-long-n-int-base-10-56">QString</a></li>
<li><a href="#qstring-qstring-qstring-setnum-ulong-qtglobal-html-ulong-typedef-n-int-base-10-57">QString</a></li>
<li><a href="#qstring-qstring-qstring-setnum-qlonglong-qtglobal-html-qlonglong-typedef-n-int-base-10-58">QString</a></li>
<li><a href="#qstring-qstring-qstring-setnum-qulonglong-qtglobal-html-qulonglong-typedef-n-int-base-10-59">QString</a></li>
<li><a href="#qstring-qstring-qstring-setnum-float-n-char-format-g-int-precision-6-60">QString</a></li>
<li><a href="#qstring-qstring-qstring-setnum-double-n-char-format-g-int-precision-6-61">QString</a></li>
<li><a href="#qstring-qstring-qstring-setrawdata-const-qchar-qchar-html-unicode-qsizetype-size-62">QString</a></li>
<li><a href="#qstring-qstring-qstring-setunicode-const-qchar-qchar-html-unicode-qsizetype-size-63">QString</a></li>
<li><a href="#qstring-qstring-qstring-setutf16-const-ushort-qtglobal-html-ushort-typedef-unicode-qsizetype-size-64">QString</a></li>
<li><a href="#since-5-10-void-qstring-shrink-to-fit"><code>[since 5.10]</code>void QString::shrink_to_fit()</a></li>
<li><a href="#qstring-qstring-qstring-simplified-chang-liang-65">QString</a></li>
<li><a href="#qsizetype-qstring-size-const">qsizetype QString::size() const</a></li>
<li><a href="#since-6-0-qstring-qstring-qstring-sliced-qsizetype-pos-qsizetype-n-const"><code>[since 6.0]</code></a><a href="#QString">QString</a> QString::sliced(qsizetype <em>pos</em>, qsizetype <em>n</em>) const</li>
<li><a href="#since-6-0-qstring-qstring-qstring-sliced-qsizetype-pos-const"><code>[since 6.0]</code></a><a href="#QString">QString</a> QString::sliced(qsizetype <em>pos</em>) const</li>
<li><a href="#since-5-14-qstringlist-qstringlist-html-qstring-split-const-qstring-qstring-sep-qt-splitbehavior-qt-html-splitbehaviorflags-enum-behavior-qt-keepemptyparts-qt-casesensitivity-qt-html-casesensitivity-enum-cs-qt-casesensitive-const"><code>[since 5.14]</code></a><a href="qstringlist.html">QStringList</a> QString::split(const <a href="#QString">QString</a> &amp;<em>sep</em>, <a href="qt.html#SplitBehaviorFlags-enum">Qt::SplitBehavior</a> <em>behavior</em> = Qt::KeepEmptyParts, <a href="qt.html#CaseSensitivity-enum">Qt::CaseSensitivity</a> <em>cs</em> = Qt::CaseSensitive) const</li>
<li><a href="#since-5-14-qstringlist-qstringlist-html-qstring-split-qchar-qchar-html-sep-qt-splitbehavior-qt-html-splitbehaviorflags-enum-behavior-qt-keepemptyparts-qt-casesensitivity-qt-html-casesensitivity-enum-cs-qt-casesensitive-const"><code>[since 5.14]</code></a><a href="qstringlist.html">QStringList</a> QString::split(<a href="qchar.html">QChar</a> <em>sep</em>, <a href="qt.html#SplitBehaviorFlags-enum">Qt::SplitBehavior</a> <em>behavior</em> = Qt::KeepEmptyParts, <a href="qt.html#CaseSensitivity-enum">Qt::CaseSensitivity</a> <em>cs</em> = Qt::CaseSensitive) const</li>
<li><a href="#since-5-14-qstringlist-qstringlist-html-qstring-split-const-qregularexpression-qregularexpression-html-re-qt-splitbehavior-qt-html-splitbehaviorflags-enum-behavior-qt-keepemptyparts-const"><code>[since 5.14]</code></a><a href="qstringlist.html">QStringList</a> QString::split(const <a href="qregularexpression.html">QRegularExpression</a> &amp;<em>re</em>, <a href="qt.html#SplitBehaviorFlags-enum">Qt::SplitBehavior</a> <em>behavior</em> = Qt::KeepEmptyParts) const</li>
<li><a href="#void-qstring-squeeze">void QString::squeeze()</a></li>
<li><a href="#bool-qstring-startswith-const-qstring-qstring-s-qt-casesensitivity-qt-html-casesensitivity-enum-cs-qt-casesensitive-const">bool QString::startsWith(const </a><a href="#QString">QString</a> &amp;<em>s</em>, <a href="qt.html#CaseSensitivity-enum">Qt::CaseSensitivity</a> <em>cs</em> = Qt::CaseSensitive) const</li>
<li><a href="#since-5-10-bool-qstring-startswith-qstringview-qstringview-html-str-qt-casesensitivity-qt-html-casesensitivity-enum-cs-qt-casesensitive-const"><code>[since 5.10]</code>bool QString::startsWith(</a><a href="qstringview.html">QStringView</a> <em>str</em>, <a href="qt.html#CaseSensitivity-enum">Qt::CaseSensitivity</a> <em>cs</em> = Qt::CaseSensitive) const</li>
<li><a href="#bool-qstring-startswith-qlatin1string-qlatin1string-html-s-qt-casesensitivity-qt-html-casesensitivity-enum-cs-qt-casesensitive-const">bool QString::startsWith(</a><a href="qlatin1string.html">QLatin1String</a> <em>s</em>, <a href="qt.html#CaseSensitivity-enum">Qt::CaseSensitivity</a> <em>cs</em> = Qt::CaseSensitive) const</li>
<li><a href="#bool-qstring-startswith-qchar-qchar-html-c-qt-casesensitivity-qt-html-casesensitivity-enum-cs-qt-casesensitive-const">bool QString::startsWith(</a><a href="qchar.html">QChar</a> <em>c</em>, <a href="qt.html#CaseSensitivity-enum">Qt::CaseSensitivity</a> <em>cs</em> = Qt::CaseSensitive) const</li>
<li><a href="#void-qstring-swap-qstring-qstring-other">void QString::swap(</a><a href="#QString">QString</a> &amp;<em>other</em>)</li>
<li><a href="#5-2-qi-cfstringref-qstring-tocfstring-const"><code>[5.2 起]</code>CFStringRef QString::toCFString() const</a></li>
<li><a href="#qstring-qstring-qstring-tocasefolded-const-66">QString</a></li>
<li><a href="#double-qstring-todouble-bool-ok-nullptr-const">double QString::toDouble(bool *<em>ok</em> = nullptr) const</a></li>
<li><a href="#float-qstring-tofloat-bool-ok-nullptr-const">float QString::toFloat(bool *<em>ok</em> = nullptr) const</a></li>
<li><a href="#since-5-0-qstring-qstring-qstring-tohtmlescaped-const"><code>[since 5.0]</code></a><a href="#QString">QString</a> QString::toHtmlEscaped() const</li>
<li><a href="#int-qstring-toint-bool-ok-nullptr-int-base-10-const">int QString::toInt(bool *<em>ok</em> = nullptr, int <em>base</em> = 10) const</a></li>
<li><a href="#qbytearray-qbytearray-html-qstring-tolatin1-const">QByteArray</a></li>
<li><a href="#qbytearray-qbytearray-html-qstring-tolocal8bit-const-1">QByteArray</a></li>
<li><a href="#long-qstring-tolong-bool-ok-nullptr-int-base-10-const">long QString::toLong(bool *<em>ok</em> = nullptr, int <em>base</em> = 10) const</a></li>
<li><a href="#qlonglong-qtglobal-html-qlonglong-typedef-qstring-tolonglong-bool-ok-nullptr-int-base-10-const">qlonglong</a></li>
<li><a href="#qstring-qstring-qstring-tolower-const-67">QString</a></li>
<li><a href="#since-5-2-nsstring-qstring-tonsstring-const"><code>[since 5.2]</code>NSString *QString::toNSString() const</a></li>
<li><a href="#short-qstring-toshort-bool-ok-nullptr-int-base-10-const">short QString::toShort(bool *<em>ok</em> = nullptr, int <em>base</em> = 10) const</a></li>
<li><a href="#std-string-qstring-tostdstring-const">std::string QString::toStdString() const</a></li>
<li><a href="#since-5-5-std-u16string-qstring-tostdu16string-const"><code>[since 5.5]</code>std::u16string QString::toStdU16String() const</a></li>
<li><a href="#since-5-5-std-u32string-qstring-tostdu32string-const"><code>[since 5.5]</code>std::u32string QString::toStdU32String() const</a></li>
<li><a href="#std-wstring-qstring-tostdwstring-const">std::wstring QString::toStdWString() const</a></li>
<li><a href="#uint-qtglobal-html-uint-typedef-qstring-touint-bool-ok-nullptr-int-base-10-const">uint</a></li>
<li><a href="#ulong-qtglobal-html-ulong-typedef-qstring-toulong-bool-ok-nullptr-int-base-10-const">ulong</a></li>
<li><a href="#qulonglong-qtglobal-html-qulonglong-typedef-qstring-toulonglong-bool-ok-nullptr-int-base-10-const">qulonglong</a></li>
<li><a href="#ushort-qtglobal-html-ushort-typedef-qstring-toushort-bool-ok-nullptr-int-base-10-const">ushort</a></li>
<li><a href="#qlist-qlist-html-uint-qtglobal-html-uint-typedef-qstring-toucs4-const">QList</a></li>
<li><a href="#qstring-qstring-qstring-toupper-const-68">QString</a></li>
<li><a href="#qbytearray-qbytearray-html-qstring-toutf8-const-2">QByteArray</a></li>
<li><a href="#qsizetype-qstring-towchararray-wchar-t-array-const">qsizetype QString::toWCharArray(wchar_t *<em>array</em>) const</a></li>
<li><a href="#qstring-qstring-qstring-trimmed-const-69">QString</a></li>
<li><a href="#void-qstring-truncate-qsizetype-position">void QString::truncate(qsizetype <em>position</em>)</a></li>
<li><a href="#const-qchar-qchar-html-qstring-unicode-const">const </a><a href="qchar.html">QChar</a> *QString::unicode() const</li>
<li><a href="#const-ushort-qtglobal-html-ushort-typedef-qstring-utf16-const">const </a><a href="qtglobal.html#ushort-typedef">ushort</a> *QString::utf16() const</li>
<li><a href="#static-since-5-5-qstring-qstring-qstring-vasprintf-const-char-cformat-va-list-ap"><code>[static, since 5.5]</code></a><a href="#QString">QString</a> QString::vasprintf(const char *<em>cformat</em>, va_list <em>ap</em>)</li>
<li><a href="#bool-qstring-operator-const-char-other-const">bool QString::operator!=(const char *<em>other</em>) const</a></li>
<li><a href="#bool-qstring-operator-const-qbytearray-qbytearray-html-other-const">bool QString::operator!=(const </a><a href="qbytearray.html">QByteArray</a> &amp;<em>other</em>) const</li>
<li><a href="#qstring-qstring-qstring-operator-const-qstring-qstring-other-70">QString</a></li>
<li><a href="#qstring-qstring-qstring-operator-qchar-qchar-html-ch-71">QString</a></li>
<li><a href="#since-6-0-qstring-qstring-qstring-operator-qstringview-qstringview-html-str"><code>[since 6.0]</code></a><a href="#QString">QString</a> &amp;QString::operator+=(<a href="qstringview.html">QStringView</a> <em>str</em>)</li>
<li><a href="#qstring-qstring-qstring-operator-qlatin1string-qlatin1string-html-str-72">QString</a></li>
<li><a href="#qstring-qstring-qstring-operator-const-char-str-73">QString</a></li>
<li><a href="#qstring-qstring-qstring-operator-const-qbytearray-qbytearray-html-ba-74">QString</a></li>
<li><a href="#bool-qstring-operator-const-char-other-const">bool QString::operator&lt;(const char *<em>other</em>) const</a></li>
<li><a href="#bool-qstring-operator-const-qbytearray-qbytearray-html-other-const">bool QString::operator&lt;(const </a><a href="qbytearray.html">QByteArray</a> &amp;<em>other</em>) const</li>
<li><a href="#bool-qstring-operator-const-char-other-const">bool QString::operator&lt;=(const char *<em>other</em>) const</a></li>
<li><a href="#bool-qstring-operator-const-qbytearray-qbytearray-html-other-const">bool QString::operator&lt;=(const </a><a href="qbytearray.html">QByteArray</a> &amp;<em>other</em>) const</li>
<li><a href="#qstring-qstring-qstring-operator-qchar-qchar-html-ch-75">QString</a></li>
<li><a href="#qstring-qstring-qstring-operator-qlatin1string-qlatin1string-html-str-76">QString</a></li>
<li><a href="#qstring-qstring-qstring-operator-const-char-str-77">QString</a></li>
<li><a href="#bool-qstring-operator-const-char-other-const">bool QString::operator==(const char *<em>other</em>) const</a></li>
<li><a href="#bool-qstring-operator-const-qbytearray-qbytearray-html-other-const">bool QString::operator==(const </a><a href="qbytearray.html">QByteArray</a> &amp;<em>other</em>) const</li>
<li><a href="#bool-qstring-operator-const-char-other-const">bool QString::operator&gt;(const char *<em>other</em>) const</a></li>
<li><a href="#bool-qstring-operator-const-qbytearray-qbytearray-html-other-const">bool QString::operator&gt;(const </a><a href="qbytearray.html">QByteArray</a> &amp;<em>other</em>) const</li>
<li><a href="#bool-qstring-operator-const-char-other-const">bool QString::operator&gt;=(const char *<em>other</em>) const</a></li>
<li><a href="#bool-qstring-operator-const-qbytearray-qbytearray-html-other-const">bool QString::operator&gt;=(const </a><a href="qbytearray.html">QByteArray</a> &amp;<em>other</em>) const</li>
<li><a href="#qchar-qchar-html-qstring-operator-qsizetype-position-1">QChar</a></li>
<li><a href="#const-qchar-qchar-html-qstring-operator-qsizetype-position-const">const </a><a href="qchar.html">QChar</a> QString::operator[](qsizetype *position*) const</li>
</ul>
</li>
<li><a href="#fei-xiang-guan-cheng-yuan-1">非相关成员</a><ul>
<li><a href="#since-6-1-template-typename-t-qsizetype-erase-qstring-qstring-s-const-t-t"><code>[since 6.1]</code>template <typename t> qsizetype erase(</typename></a><a href="#QString">QString</a> &amp;<em>s</em>, const T &amp;<em>t</em>)</li>
<li><a href="#since-6-1-template-typename-predicate-qsizetype-erase-if-qstring-qstring-s-predicate-pred"><code>[since 6.1]</code>template <typename predicate> qsizetype erase_if(</typename></a><a href="#QString">QString</a> &amp;<em>s</em>, Predicate <em>pred</em>)</li>
<li><a href="#bool-operator-const-qstring-qstring-s1-const-qstring-qstring-s2">bool operator!=(const </a><a href="#QString">QString</a> &amp;<em>s1</em>, const <a href="#QString">QString</a> &amp;<em>s2</em>)</li>
<li><a href="#bool-operator-const-qstring-qstring-s1-qlatin1string-qlatin1string-html-s2">bool operator!=(const </a><a href="#QString">QString</a> &amp;<em>s1</em>, <a href="qlatin1string.html">QLatin1String</a> <em>s2</em>)</li>
<li><a href="#bool-operator-const-char-s1-const-qstring-qstring-s2">bool operator!=(const char *<em>s1</em>, const </a><a href="#QString">QString</a> &amp;<em>s2</em>)</li>
<li><a href="#since-6-2-qstring-qstring-operator-qs-const-char16-t-str-size-t-size"><code>[since 6.2]</code></a><a href="#QString">QString</a> operator””_qs(const char16_t *<em>str</em>, size_t <em>size</em>)</li>
<li><a href="#const-qstring-qstring-operator-const-qstring-qstring-s1-const-qstring-qstring-s2">const </a><a href="#QString">QString</a> operator+(const <a href="#QString">QString</a> &amp;<em>s1</em>, const <a href="#QString">QString</a> &amp;<em>s2</em>)</li>
<li><a href="#const-qstring-qstring-operator-const-qstring-qstring-s1-const-char-s2">const </a><a href="#QString">QString</a> operator+(const <a href="#QString">QString</a> &amp;<em>s1</em>, const char *<em>s2</em>)</li>
<li><a href="#const-qstring-qstring-operator-const-char-s1-const-qstring-qstring-s2">const </a><a href="#QString">QString</a> operator+(const char *<em>s1</em>, const <a href="#QString">QString</a> &amp;<em>s2</em>)</li>
<li><a href="#bool-operator-const-qstring-qstring-s1-const-qstring-qstring-s2">bool operator&lt;(const </a><a href="#QString">QString</a> &amp;<em>s1</em>, const <a href="#QString">QString</a> &amp;<em>s2</em>)</li>
<li><a href="#bool-operator-const-qstring-qstring-s1-qlatin1string-qlatin1string-html-s2">bool operator&lt;(const </a><a href="#QString">QString</a> &amp;<em>s1</em>, <a href="qlatin1string.html">QLatin1String</a> <em>s2</em>)</li>
<li><a href="#bool-operator-qlatin1string-qlatin1string-html-s1-const-qstring-qstring-s2">bool operator&lt;(</a><a href="qlatin1string.html">QLatin1String</a> <em>s1</em>, const <a href="#QString">QString</a> &amp;<em>s2</em>)</li>
<li><a href="#bool-operator-const-char-s1-const-qstring-qstring-s2">bool operator&lt;(const char *<em>s1</em>, const </a><a href="#QString">QString</a> &amp;<em>s2</em>)</li>
<li><a href="#qdatastream-qdatastream-html-operator-qdatastream-qdatastream-html-stream-const-qstring-qstring-string">QDataStream</a></li>
<li><a href="#bool-operator-const-qstring-qstring-s1-const-qstring-qstring-s2">bool operator&lt;=(const </a><a href="#QString">QString</a> &amp;<em>s1</em>, const <a href="#QString">QString</a> &amp;<em>s2</em>)</li>
<li><a href="#bool-operator-const-qstring-qstring-s1-qlatin1string-qlatin1string-html-s2">bool operator&lt;=(const </a><a href="#QString">QString</a> &amp;<em>s1</em>, <a href="qlatin1string.html">QLatin1String</a> <em>s2</em>)</li>
<li><a href="#bool-operator-qlatin1string-qlatin1string-html-s1-const-qstring-qstring-s2">bool operator&lt;=(</a><a href="qlatin1string.html">QLatin1String</a> <em>s1</em>, const <a href="#QString">QString</a> &amp;<em>s2</em>)</li>
<li><a href="#bool-operator-const-char-s1-const-qstring-qstring-s2">bool operator&lt;=(const char *<em>s1</em>, const </a><a href="#QString">QString</a> &amp;<em>s2</em>)</li>
<li><a href="#bool-operator-const-qstring-qstring-s1-const-qstring-qstring-s2">bool operator==(const </a><a href="#QString">QString</a> &amp;<em>s1</em>, const <a href="#QString">QString</a> &amp;<em>s2</em>)</li>
<li><a href="#bool-operator-const-qstring-qstring-s1-qlatin1string-qlatin1string-html-s2">bool operator==(const </a><a href="#QString">QString</a> &amp;<em>s1</em>, <a href="qlatin1string.html">QLatin1String</a> <em>s2</em>)</li>
<li><a href="#bool-operator-qlatin1string-qlatin1string-html-s1-const-qstring-qstring-s2">bool operator==(</a><a href="qlatin1string.html">QLatin1String</a> <em>s1</em>, const <a href="#QString">QString</a> &amp;<em>s2</em>)</li>
<li><a href="#bool-operator-const-char-s1-const-qstring-qstring-s2">bool operator==(const char *<em>s1</em>, const </a><a href="#QString">QString</a> &amp;<em>s2</em>)</li>
<li><a href="#bool-operator-const-qstring-qstring-s1-const-qstring-qstring-s2">bool operator&gt;(const </a><a href="#QString">QString</a> &amp;<em>s1</em>, const <a href="#QString">QString</a> &amp;<em>s2</em>)</li>
<li><a href="#bool-operator-const-qstring-qstring-s1-qlatin1string-qlatin1string-html-s2">bool operator&gt;(const </a><a href="#QString">QString</a> &amp;<em>s1</em>, <a href="qlatin1string.html">QLatin1String</a> <em>s2</em>)</li>
<li><a href="#bool-operator-qlatin1string-qlatin1string-html-s1-const-qstring-qstring-s2">bool operator&gt;(</a><a href="qlatin1string.html">QLatin1String</a> <em>s1</em>, const <a href="#QString">QString</a> &amp;<em>s2</em>)</li>
<li><a href="#bool-operator-const-char-s1-const-qstring-qstring-s2">bool operator&gt;(const char *<em>s1</em>, const </a><a href="#QString">QString</a> &amp;<em>s2</em>)</li>
<li><a href="#bool-operator-const-qstring-qstring-s1-const-qstring-qstring-s2">bool operator&gt;=(const </a><a href="#QString">QString</a> &amp;<em>s1</em>, const <a href="#QString">QString</a> &amp;<em>s2</em>)</li>
<li><a href="#bool-operator-const-qstring-qstring-s1-qlatin1string-qlatin1string-html-s2">bool operator&gt;=(const </a><a href="#QString">QString</a> &amp;<em>s1</em>, <a href="qlatin1string.html">QLatin1String</a> <em>s2</em>)</li>
<li><a href="#bool-operator-qlatin1string-qlatin1string-html-s1-const-qstring-qstring-s2">bool operator&gt;=(</a><a href="qlatin1string.html">QLatin1String</a> <em>s1</em>, const <a href="#QString">QString</a> &amp;<em>s2</em>)</li>
<li><a href="#bool-operator-const-char-s1-const-qstring-qstring-s2">bool operator&gt;=(const char *<em>s1</em>, const </a><a href="#QString">QString</a> &amp;<em>s2</em>)</li>
<li><a href="#qdatastream-qdatastream-html-operator-qdatastream-qdatastream-html-stream-qstring-qstring-string-1">QDataStream</a></li>
</ul>
</li>
<li><a href="#hong-wen-dang">宏文档</a><ul>
<li><a href="#qstringliteral-str">QStringLiteral(<em>str</em>)</a></li>
<li><a href="#qt-no-cast-from-ascii">QT_NO_CAST_FROM_ASCII</a></li>
<li><a href="#qt-no-cast-to-ascii">QT_NO_CAST_TO_ASCII</a></li>
<li><a href="#qt-restricted-cast-from-ascii">QT_RESTRICTED_CAST_FROM_ASCII</a></li>
</ul>
</li>
</ul>
</li>
</ul>
<!-- tocstop -->

</div>
# QString Class

<p>QString 类提供了一个 Unicode 字符串. <a href="#%E8%AF%A6%E7%BB%86%E6%8F%8F%E8%BF%B0">More…</a></p>
<table>
<thead>
<tr>
<th>Header:</th>
<th>#include <qstring></qstring></th>
</tr>
</thead>
<tbody><tr>
<td>CMake:</td>
<td>find_package(Qt6 COMPONENTS Core REQUIRED) target_link_libraries(mytarget PRIVATE Qt6::Core)</td>
</tr>
<tr>
<td>qmake:</td>
<td>QT += core</td>
</tr>
</tbody></table>
<ul>
<li><a href="qstring-members.html">List of all members, including inherited members</a></li>
<li><a href="qstring-obsolete.html">Deprecated members</a></li>
</ul>
<p><strong>注意：</strong> 此类中的所有函数都是 <a href="17-qdoc-commands-thread.html#reentrant">reentrant</a>。</p>
<h2><span id="gong-gong-lei-xing">公共类型</span><a href="#gong-gong-lei-xing" class="header-anchor">#</a></h2><table>
<thead>
<tr>
<th></th>
<th><strong><a href="#ConstIterator-typedef">ConstIterator</a></strong></th>
</tr>
</thead>
<tbody><tr>
<td></td>
<td><strong><a href="#Iterator-typedef">Iterator</a></strong></td>
</tr>
<tr>
<td>enum</td>
<td><strong><a href="#NormalizationForm-enum">NormalizationForm</a></strong> { NormalizationForm_D, NormalizationForm_C, NormalizationForm_KD, NormalizationForm_KC }</td>
</tr>
<tr>
<td>enum</td>
<td><strong><a href="#SectionFlag-enum">SectionFlag</a></strong> { SectionDefault, SectionSkipEmpty, SectionIncludeLeadingSep, SectionIncludeTrailingSep, SectionCaseInsensitiveSeps }</td>
</tr>
<tr>
<td>flags</td>
<td><strong><a href="#SectionFlag-enum">SectionFlags</a></strong></td>
</tr>
<tr>
<td></td>
<td><strong><a href="#const_iterator-typedef">const_iterator</a></strong></td>
</tr>
<tr>
<td></td>
<td><strong><a href="#const_pointer-typedef">const_pointer</a></strong></td>
</tr>
<tr>
<td></td>
<td><strong><a href="#const_reference-typedef">const_reference</a></strong></td>
</tr>
<tr>
<td></td>
<td><strong><a href="#const_reverse_iterator-typedef">const_reverse_iterator</a></strong></td>
</tr>
<tr>
<td></td>
<td><strong><a href="#difference_type-typedef">difference_type</a></strong></td>
</tr>
<tr>
<td></td>
<td><strong><a href="#iterator-typedefx">iterator</a></strong></td>
</tr>
<tr>
<td></td>
<td><strong><a href="#pointer-typedef">pointer</a></strong></td>
</tr>
<tr>
<td></td>
<td><strong><a href="#reference-typedef">reference</a></strong></td>
</tr>
<tr>
<td></td>
<td><strong><a href="#reverse_iterator-typedef">reverse_iterator</a></strong></td>
</tr>
<tr>
<td></td>
<td><strong><a href="#size_type-typedef">size_type</a></strong></td>
</tr>
<tr>
<td></td>
<td><strong><a href="#value_type-typedef">value_type</a></strong></td>
</tr>
</tbody></table>
<h2><span id="gong-gong-han-shu">公共函数</span><a href="#gong-gong-han-shu" class="header-anchor">#</a></h2><table>
<thead>
<tr>
<th></th>
<th><strong><a href="#QString-9">QString</a></strong>(const QByteArray &amp;<em>ba</em>)</th>
</tr>
</thead>
<tbody><tr>
<td></td>
<td><strong><a href="#QString-8">QString</a></strong>(const char *<em>str</em>)</td>
</tr>
<tr>
<td></td>
<td><strong><a href="#QString-7">QString</a></strong>(QString &amp;&amp;<em>other</em>)</td>
</tr>
<tr>
<td></td>
<td><strong><a href="#QString-6">QString</a></strong>(const QString &amp;<em>other</em>)</td>
</tr>
<tr>
<td></td>
<td><strong><a href="#QString-5">QString</a></strong>(const char8_t *<em>str</em>)</td>
</tr>
<tr>
<td></td>
<td><strong><a href="#QString-4">QString</a></strong>(QLatin1String <em>str</em>)</td>
</tr>
<tr>
<td></td>
<td><strong><a href="#QString-3">QString</a></strong>(qsizetype <em>size</em>, QChar <em>ch</em>)</td>
</tr>
<tr>
<td></td>
<td><strong><a href="#QString-2">QString</a></strong>(QChar <em>ch</em>)</td>
</tr>
<tr>
<td></td>
<td><strong><a href="#QString-1">QString</a></strong>(const QChar *<em>unicode</em>, qsizetype <em>size</em> = -1)</td>
</tr>
<tr>
<td></td>
<td><strong><a href="#QString">QString</a></strong>()</td>
</tr>
<tr>
<td>QString &amp;</td>
<td><strong><a href="#operator-eq-5">operator=</a></strong>(const QByteArray &amp;<em>ba</em>)</td>
</tr>
<tr>
<td>QString &amp;</td>
<td><strong><a href="#operator-eq-3">operator=</a></strong>(QString &amp;&amp;<em>other</em>)</td>
</tr>
<tr>
<td>QString &amp;</td>
<td><strong><a href="#operator-eq">operator=</a></strong>(const QString &amp;<em>other</em>)</td>
</tr>
<tr>
<td></td>
<td><strong><a href="#dtor.QString">~QString</a></strong>()</td>
</tr>
<tr>
<td>QString &amp;</td>
<td><strong><a href="#append">append</a></strong>(const QString &amp;<em>str</em>)</td>
</tr>
<tr>
<td>QString &amp;</td>
<td><strong><a href="#append-1">append</a></strong>(QChar <em>ch</em>)</td>
</tr>
<tr>
<td>QString &amp;</td>
<td><strong><a href="#append-2">append</a></strong>(const QChar *<em>str</em>, qsizetype <em>len</em>)</td>
</tr>
<tr>
<td>QString &amp;</td>
<td><strong><a href="#append-4">append</a></strong>(QLatin1String <em>str</em>)</td>
</tr>
<tr>
<td>QString &amp;</td>
<td><strong><a href="#append-5">append</a></strong>(const char *<em>str</em>)</td>
</tr>
<tr>
<td>QString &amp;</td>
<td><strong><a href="#append-6">append</a></strong>(const QByteArray &amp;<em>ba</em>)</td>
</tr>
<tr>
<td>QString</td>
<td><strong><a href="#arg">arg</a></strong>(const QString &amp;<em>a</em>, int <em>fieldWidth</em> = 0, QChar <em>fillChar</em> = QLatin1Char(‘ ‘)) const</td>
</tr>
<tr>
<td>QString</td>
<td><strong><a href="#arg-1">arg</a></strong>(qlonglong <em>a</em>, int <em>fieldWidth</em> = 0, int <em>base</em> = 10, QChar <em>fillChar</em> = QLatin1Char(‘ ‘)) const</td>
</tr>
<tr>
<td>QString</td>
<td><strong><a href="#arg-2">arg</a></strong>(qulonglong <em>a</em>, int <em>fieldWidth</em> = 0, int <em>base</em> = 10, QChar <em>fillChar</em> = QLatin1Char(‘ ‘)) const</td>
</tr>
<tr>
<td>QString</td>
<td><strong><a href="#arg-3">arg</a></strong>(long <em>a</em>, int <em>fieldWidth</em> = 0, int <em>base</em> = 10, QChar <em>fillChar</em> = QLatin1Char(‘ ‘)) const</td>
</tr>
<tr>
<td>QString</td>
<td><strong><a href="#arg-4">arg</a></strong>(ulong <em>a</em>, int <em>fieldWidth</em> = 0, int <em>base</em> = 10, QChar <em>fillChar</em> = QLatin1Char(‘ ‘)) const</td>
</tr>
<tr>
<td>QString</td>
<td><strong><a href="#arg-5">arg</a></strong>(int <em>a</em>, int <em>fieldWidth</em> = 0, int <em>base</em> = 10, QChar <em>fillChar</em> = QLatin1Char(‘ ‘)) const</td>
</tr>
<tr>
<td>QString</td>
<td><strong><a href="#arg-6">arg</a></strong>(uint <em>a</em>, int <em>fieldWidth</em> = 0, int <em>base</em> = 10, QChar <em>fillChar</em> = QLatin1Char(‘ ‘)) const</td>
</tr>
<tr>
<td>QString</td>
<td><strong><a href="#arg-7">arg</a></strong>(short <em>a</em>, int <em>fieldWidth</em> = 0, int <em>base</em> = 10, QChar <em>fillChar</em> = QLatin1Char(‘ ‘)) const</td>
</tr>
<tr>
<td>QString</td>
<td><strong><a href="#arg-8">arg</a></strong>(ushort <em>a</em>, int <em>fieldWidth</em> = 0, int <em>base</em> = 10, QChar <em>fillChar</em> = QLatin1Char(‘ ‘)) const</td>
</tr>
<tr>
<td>QString</td>
<td><strong><a href="#arg-9">arg</a></strong>(double <em>a</em>, int <em>fieldWidth</em> = 0, char <em>format</em> = ‘g’, int <em>precision</em> = -1, QChar <em>fillChar</em> = QLatin1Char(‘ ‘)) const</td>
</tr>
<tr>
<td>QString</td>
<td><strong><a href="#arg-10">arg</a></strong>(char <em>a</em>, int <em>fieldWidth</em> = 0, QChar <em>fillChar</em> = QLatin1Char(‘ ‘)) const</td>
</tr>
<tr>
<td>QString</td>
<td><strong><a href="#arg-11">arg</a></strong>(QChar <em>a</em>, int <em>fieldWidth</em> = 0, QChar <em>fillChar</em> = QLatin1Char(‘ ‘)) const</td>
</tr>
<tr>
<td>QString</td>
<td><strong><a href="#arg-12">arg</a></strong>(QStringView <em>a</em>, int <em>fieldWidth</em> = 0, QChar <em>fillChar</em> = QLatin1Char(‘ ‘)) const</td>
</tr>
<tr>
<td>QString</td>
<td><strong><a href="#arg-13">arg</a></strong>(QLatin1String <em>a</em>, int <em>fieldWidth</em> = 0, QChar <em>fillChar</em> = QLatin1Char(‘ ‘)) const</td>
</tr>
<tr>
<td>QString</td>
<td><strong><a href="#arg-14">arg</a></strong>(Args &amp;&amp;… <em>args</em>) const</td>
</tr>
<tr>
<td>const QChar</td>
<td><strong><a href="#at">at</a></strong>(qsizetype <em>position</em>) const</td>
</tr>
<tr>
<td>QChar</td>
<td><strong><a href="#back">back</a></strong>() const</td>
</tr>
<tr>
<td>QChar &amp;</td>
<td><strong><a href="#back-1">back</a></strong>()</td>
</tr>
<tr>
<td>QString::iterator</td>
<td><strong><a href="#begin">begin</a></strong>()</td>
</tr>
<tr>
<td>QString::const_iterator</td>
<td><strong><a href="#begin-1">begin</a></strong>() const</td>
</tr>
<tr>
<td>qsizetype</td>
<td><strong><a href="#capacity">capacity</a></strong>() const</td>
</tr>
<tr>
<td>QString::const_iterator</td>
<td><strong><a href="#cbegin">cbegin</a></strong>() const</td>
</tr>
<tr>
<td>QString::const_iterator</td>
<td><strong><a href="#cend">cend</a></strong>() const</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="#chop">chop</a></strong>(qsizetype <em>n</em>)</td>
</tr>
<tr>
<td>QString</td>
<td><strong><a href="#chopped">chopped</a></strong>(qsizetype <em>len</em>) const</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="#clear">clear</a></strong>()</td>
</tr>
<tr>
<td>int</td>
<td><strong><a href="#compare-1">compare</a></strong>(const QString &amp;<em>other</em>, Qt::CaseSensitivity <em>cs</em> = Qt::CaseSensitive) const</td>
</tr>
<tr>
<td>int</td>
<td><strong><a href="#compare-2">compare</a></strong>(QLatin1String <em>other</em>, Qt::CaseSensitivity <em>cs</em> = Qt::CaseSensitive) const</td>
</tr>
<tr>
<td>int</td>
<td><strong><a href="#compare-3">compare</a></strong>(QStringView <em>s</em>, Qt::CaseSensitivity <em>cs</em> = Qt::CaseSensitive) const</td>
</tr>
<tr>
<td>int</td>
<td><strong><a href="#compare-4">compare</a></strong>(QChar <em>ch</em>, Qt::CaseSensitivity <em>cs</em> = Qt::CaseSensitive) const</td>
</tr>
<tr>
<td>QString::const_iterator</td>
<td><strong><a href="#constBegin">constBegin</a></strong>() const</td>
</tr>
<tr>
<td>const QChar *</td>
<td><strong><a href="#constData">constData</a></strong>() const</td>
</tr>
<tr>
<td>QString::const_iterator</td>
<td><strong><a href="#constEnd">constEnd</a></strong>() const</td>
</tr>
<tr>
<td>bool</td>
<td><strong><a href="#contains">contains</a></strong>(const QString &amp;<em>str</em>, Qt::CaseSensitivity <em>cs</em> = Qt::CaseSensitive) const</td>
</tr>
<tr>
<td>bool</td>
<td><strong><a href="#contains-1">contains</a></strong>(QChar <em>ch</em>, Qt::CaseSensitivity <em>cs</em> = Qt::CaseSensitive) const</td>
</tr>
<tr>
<td>bool</td>
<td><strong><a href="#contains-2">contains</a></strong>(QLatin1String <em>str</em>, Qt::CaseSensitivity <em>cs</em> = Qt::CaseSensitive) const</td>
</tr>
<tr>
<td>bool</td>
<td><strong><a href="#contains-3">contains</a></strong>(QStringView <em>str</em>, Qt::CaseSensitivity <em>cs</em> = Qt::CaseSensitive) const</td>
</tr>
<tr>
<td>bool</td>
<td><strong><a href="#contains-4">contains</a></strong>(const QRegularExpression &amp;<em>re</em>, QRegularExpressionMatch *<em>rmatch</em> = nullptr) const</td>
</tr>
<tr>
<td>qsizetype</td>
<td><strong><a href="#count">count</a></strong>(const QString &amp;<em>str</em>, Qt::CaseSensitivity <em>cs</em> = Qt::CaseSensitive) const</td>
</tr>
<tr>
<td>qsizetype</td>
<td><strong><a href="#count-1">count</a></strong>() const</td>
</tr>
<tr>
<td>qsizetype</td>
<td><strong><a href="#count-2">count</a></strong>(QChar <em>ch</em>, Qt::CaseSensitivity <em>cs</em> = Qt::CaseSensitive) const</td>
</tr>
<tr>
<td>qsizetype</td>
<td><strong><a href="#count-3">count</a></strong>(QStringView <em>str</em>, Qt::CaseSensitivity <em>cs</em> = Qt::CaseSensitive) const</td>
</tr>
<tr>
<td>qsizetype</td>
<td><strong><a href="#count-4">count</a></strong>(const QRegularExpression &amp;<em>re</em>) const</td>
</tr>
<tr>
<td>QString::const_reverse_iterator</td>
<td><strong><a href="#crbegin">crbegin</a></strong>() const</td>
</tr>
<tr>
<td>QString::const_reverse_iterator</td>
<td><strong><a href="#crend">crend</a></strong>() const</td>
</tr>
<tr>
<td>QChar *</td>
<td><strong><a href="#data">data</a></strong>()</td>
</tr>
<tr>
<td>const QChar *</td>
<td><strong><a href="#data-1">data</a></strong>() const</td>
</tr>
<tr>
<td>QString::iterator</td>
<td><strong><a href="#end">end</a></strong>()</td>
</tr>
<tr>
<td>QString::const_iterator</td>
<td><strong><a href="#end-1">end</a></strong>() const</td>
</tr>
<tr>
<td>bool</td>
<td><strong><a href="#endsWith">endsWith</a></strong>(const QString &amp;<em>s</em>, Qt::CaseSensitivity <em>cs</em> = Qt::CaseSensitive) const</td>
</tr>
<tr>
<td>bool</td>
<td><strong><a href="#endsWith-1">endsWith</a></strong>(QStringView <em>str</em>, Qt::CaseSensitivity <em>cs</em> = Qt::CaseSensitive) const</td>
</tr>
<tr>
<td>bool</td>
<td><strong><a href="#endsWith-2">endsWith</a></strong>(QLatin1String <em>s</em>, Qt::CaseSensitivity <em>cs</em> = Qt::CaseSensitive) const</td>
</tr>
<tr>
<td>bool</td>
<td><strong><a href="#endsWith-3">endsWith</a></strong>(QChar <em>c</em>, Qt::CaseSensitivity <em>cs</em> = Qt::CaseSensitive) const</td>
</tr>
<tr>
<td>QString::iterator</td>
<td><strong><a href="#erase">erase</a></strong>(QString::const_iterator <em>first</em>, QString::const_iterator <em>last</em>)</td>
</tr>
<tr>
<td>QString &amp;</td>
<td><strong><a href="#fill">fill</a></strong>(QChar <em>ch</em>, qsizetype <em>size</em> = -1)</td>
</tr>
<tr>
<td>QString</td>
<td><strong><a href="#first">first</a></strong>(qsizetype <em>n</em>) const</td>
</tr>
<tr>
<td>QChar</td>
<td><strong><a href="#front">front</a></strong>() const</td>
</tr>
<tr>
<td>QChar &amp;</td>
<td><strong><a href="#front-1">front</a></strong>()</td>
</tr>
<tr>
<td>qsizetype</td>
<td><strong><a href="#indexOf">indexOf</a></strong>(QLatin1String <em>str</em>, qsizetype <em>from</em> = 0, Qt::CaseSensitivity <em>cs</em> = Qt::CaseSensitive) const</td>
</tr>
<tr>
<td>qsizetype</td>
<td><strong><a href="#indexOf-1">indexOf</a></strong>(QChar <em>ch</em>, qsizetype <em>from</em> = 0, Qt::CaseSensitivity <em>cs</em> = Qt::CaseSensitive) const</td>
</tr>
<tr>
<td>qsizetype</td>
<td><strong><a href="#indexOf-2">indexOf</a></strong>(const QString &amp;<em>str</em>, qsizetype <em>from</em> = 0, Qt::CaseSensitivity <em>cs</em> = Qt::CaseSensitive) const</td>
</tr>
<tr>
<td>qsizetype</td>
<td><strong><a href="#indexOf-3">indexOf</a></strong>(QStringView <em>str</em>, qsizetype <em>from</em> = 0, Qt::CaseSensitivity <em>cs</em> = Qt::CaseSensitive) const</td>
</tr>
<tr>
<td>qsizetype</td>
<td><strong><a href="#indexOf-4">indexOf</a></strong>(const QRegularExpression &amp;<em>re</em>, qsizetype <em>from</em> = 0, QRegularExpressionMatch *<em>rmatch</em> = nullptr) const</td>
</tr>
<tr>
<td>QString &amp;</td>
<td><strong><a href="#insert">insert</a></strong>(qsizetype <em>position</em>, const QString &amp;<em>str</em>)</td>
</tr>
<tr>
<td>QString &amp;</td>
<td><strong><a href="#insert-1">insert</a></strong>(qsizetype <em>position</em>, QChar <em>ch</em>)</td>
</tr>
<tr>
<td>QString &amp;</td>
<td><strong><a href="#insert-2">insert</a></strong>(qsizetype <em>position</em>, const QChar *<em>unicode</em>, qsizetype <em>size</em>)</td>
</tr>
<tr>
<td>QString &amp;</td>
<td><strong><a href="#insert-3">insert</a></strong>(qsizetype <em>position</em>, QStringView <em>str</em>)</td>
</tr>
<tr>
<td>QString &amp;</td>
<td><strong><a href="#insert-4">insert</a></strong>(qsizetype <em>position</em>, QLatin1String <em>str</em>)</td>
</tr>
<tr>
<td>QString &amp;</td>
<td><strong><a href="#insert-5">insert</a></strong>(qsizetype <em>position</em>, const char *<em>str</em>)</td>
</tr>
<tr>
<td>QString &amp;</td>
<td><strong><a href="#insert-6">insert</a></strong>(qsizetype <em>position</em>, const QByteArray &amp;<em>str</em>)</td>
</tr>
<tr>
<td>bool</td>
<td><strong><a href="#isEmpty">isEmpty</a></strong>() const</td>
</tr>
<tr>
<td>bool</td>
<td><strong><a href="#isLower">isLower</a></strong>() const</td>
</tr>
<tr>
<td>bool</td>
<td><strong><a href="#isNull">isNull</a></strong>() const</td>
</tr>
<tr>
<td>bool</td>
<td><strong><a href="#isRightToLeft">isRightToLeft</a></strong>() const</td>
</tr>
<tr>
<td>bool</td>
<td><strong><a href="#isUpper">isUpper</a></strong>() const</td>
</tr>
<tr>
<td>bool</td>
<td><strong><a href="#isValidUtf16">isValidUtf16</a></strong>() const</td>
</tr>
<tr>
<td>QString</td>
<td><strong><a href="#last">last</a></strong>(qsizetype <em>n</em>) const</td>
</tr>
<tr>
<td>qsizetype</td>
<td><strong><a href="#lastIndexOf">lastIndexOf</a></strong>(const QString &amp;<em>str</em>, qsizetype <em>from</em>, Qt::CaseSensitivity <em>cs</em> = Qt::CaseSensitive) const</td>
</tr>
<tr>
<td>qsizetype</td>
<td><strong><a href="#lastIndexOf-1">lastIndexOf</a></strong>(QChar <em>ch</em>, qsizetype <em>from</em> = -1, Qt::CaseSensitivity <em>cs</em> = Qt::CaseSensitive) const</td>
</tr>
<tr>
<td>qsizetype</td>
<td><strong><a href="#lastIndexOf-2">lastIndexOf</a></strong>(QLatin1String <em>str</em>, Qt::CaseSensitivity <em>cs</em> = Qt::CaseSensitive) const</td>
</tr>
<tr>
<td>qsizetype</td>
<td><strong><a href="#lastIndexOf-3">lastIndexOf</a></strong>(QLatin1String <em>str</em>, qsizetype <em>from</em>, Qt::CaseSensitivity <em>cs</em> = Qt::CaseSensitive) const</td>
</tr>
<tr>
<td>qsizetype</td>
<td><strong><a href="#lastIndexOf-4">lastIndexOf</a></strong>(const QString &amp;<em>str</em>, Qt::CaseSensitivity <em>cs</em> = Qt::CaseSensitive) const</td>
</tr>
<tr>
<td>qsizetype</td>
<td><strong><a href="#lastIndexOf-5">lastIndexOf</a></strong>(QStringView <em>str</em>, Qt::CaseSensitivity <em>cs</em> = Qt::CaseSensitive) const</td>
</tr>
<tr>
<td>qsizetype</td>
<td><strong><a href="#lastIndexOf-6">lastIndexOf</a></strong>(QStringView <em>str</em>, qsizetype <em>from</em>, Qt::CaseSensitivity <em>cs</em> = Qt::CaseSensitive) const</td>
</tr>
<tr>
<td>qsizetype</td>
<td><strong><a href="#lastIndexOf-7">lastIndexOf</a></strong>(const QRegularExpression &amp;<em>re</em>, QRegularExpressionMatch *<em>rmatch</em> = nullptr) const</td>
</tr>
<tr>
<td>qsizetype</td>
<td><strong><a href="#lastIndexOf-8">lastIndexOf</a></strong>(const QRegularExpression &amp;<em>re</em>, qsizetype <em>from</em>, QRegularExpressionMatch *<em>rmatch</em> = nullptr) const</td>
</tr>
<tr>
<td>QString</td>
<td><strong><a href="#left">left</a></strong>(qsizetype <em>n</em>) const</td>
</tr>
<tr>
<td>QString</td>
<td><strong><a href="#leftJustified">leftJustified</a></strong>(qsizetype <em>width</em>, QChar <em>fill</em> = QLatin1Char(‘ ‘), bool <em>truncate</em> = false) const</td>
</tr>
<tr>
<td>qsizetype</td>
<td><strong><a href="#length">length</a></strong>() const</td>
</tr>
<tr>
<td>int</td>
<td><strong><a href="#localeAwareCompare-1">localeAwareCompare</a></strong>(const QString &amp;<em>other</em>) const</td>
</tr>
<tr>
<td>int</td>
<td><strong><a href="#localeAwareCompare-2">localeAwareCompare</a></strong>(QStringView <em>other</em>) const</td>
</tr>
<tr>
<td>QString</td>
<td><strong><a href="#mid">mid</a></strong>(qsizetype <em>position</em>, qsizetype <em>n</em> = -1) const</td>
</tr>
<tr>
<td>QString</td>
<td><strong><a href="#normalized">normalized</a></strong>(QString::NormalizationForm <em>mode</em>, QChar::UnicodeVersion <em>version</em> = QChar::Unicode_Unassigned) const</td>
</tr>
<tr>
<td>QString &amp;</td>
<td><strong><a href="#prepend">prepend</a></strong>(const QString &amp;<em>str</em>)</td>
</tr>
<tr>
<td>QString &amp;</td>
<td><strong><a href="#prepend-1">prepend</a></strong>(QChar <em>ch</em>)</td>
</tr>
<tr>
<td>QString &amp;</td>
<td><strong><a href="#prepend-2">prepend</a></strong>(const QChar *<em>str</em>, qsizetype <em>len</em>)</td>
</tr>
<tr>
<td>QString &amp;</td>
<td><strong><a href="#prepend-3">prepend</a></strong>(QStringView <em>str</em>)</td>
</tr>
<tr>
<td>QString &amp;</td>
<td><strong><a href="#prepend-4">prepend</a></strong>(QLatin1String <em>str</em>)</td>
</tr>
<tr>
<td>QString &amp;</td>
<td><strong><a href="#prepend-5">prepend</a></strong>(const char *<em>str</em>)</td>
</tr>
<tr>
<td>QString &amp;</td>
<td><strong><a href="#prepend-6">prepend</a></strong>(const QByteArray &amp;<em>ba</em>)</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="#push_back">push_back</a></strong>(const QString &amp;<em>other</em>)</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="#push_back-1">push_back</a></strong>(QChar <em>ch</em>)</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="#push_front">push_front</a></strong>(const QString &amp;<em>other</em>)</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="#push_front-1">push_front</a></strong>(QChar <em>ch</em>)</td>
</tr>
<tr>
<td>QString::reverse_iterator</td>
<td><strong><a href="#rbegin">rbegin</a></strong>()</td>
</tr>
<tr>
<td>QString::const_reverse_iterator</td>
<td><strong><a href="#rbegin-1">rbegin</a></strong>() const</td>
</tr>
<tr>
<td>QString &amp;</td>
<td><strong><a href="#remove">remove</a></strong>(qsizetype <em>position</em>, qsizetype <em>n</em>)</td>
</tr>
<tr>
<td>QString &amp;</td>
<td><strong><a href="#remove-1">remove</a></strong>(QChar <em>ch</em>, Qt::CaseSensitivity <em>cs</em> = Qt::CaseSensitive)</td>
</tr>
<tr>
<td>QString &amp;</td>
<td><strong><a href="#remove-2">remove</a></strong>(QLatin1String <em>str</em>, Qt::CaseSensitivity <em>cs</em> = Qt::CaseSensitive)</td>
</tr>
<tr>
<td>QString &amp;</td>
<td><strong><a href="#remove-3">remove</a></strong>(const QString &amp;<em>str</em>, Qt::CaseSensitivity <em>cs</em> = Qt::CaseSensitive)</td>
</tr>
<tr>
<td>QString &amp;</td>
<td><strong><a href="#remove-4">remove</a></strong>(const QRegularExpression &amp;<em>re</em>)</td>
</tr>
<tr>
<td>QString &amp;</td>
<td><strong><a href="#removeIf">removeIf</a></strong>(Predicate <em>pred</em>)</td>
</tr>
<tr>
<td>QString::reverse_iterator</td>
<td><strong><a href="#rend">rend</a></strong>()</td>
</tr>
<tr>
<td>QString::const_reverse_iterator</td>
<td><strong><a href="#rend-1">rend</a></strong>() const</td>
</tr>
<tr>
<td>QString</td>
<td><strong><a href="#repeated">repeated</a></strong>(qsizetype <em>times</em>) const</td>
</tr>
<tr>
<td>QString &amp;</td>
<td><strong><a href="#replace">replace</a></strong>(qsizetype <em>position</em>, qsizetype <em>n</em>, const QString &amp;<em>after</em>)</td>
</tr>
<tr>
<td>QString &amp;</td>
<td><strong><a href="#replace-1">replace</a></strong>(qsizetype <em>position</em>, qsizetype <em>n</em>, QChar <em>after</em>)</td>
</tr>
<tr>
<td>QString &amp;</td>
<td><strong><a href="#replace-2">replace</a></strong>(qsizetype <em>position</em>, qsizetype <em>n</em>, const QChar *<em>unicode</em>, qsizetype <em>size</em>)</td>
</tr>
<tr>
<td>QString &amp;</td>
<td><strong><a href="#replace-3">replace</a></strong>(QChar <em>before</em>, QChar <em>after</em>, Qt::CaseSensitivity <em>cs</em> = Qt::CaseSensitive)</td>
</tr>
<tr>
<td>QString &amp;</td>
<td><strong><a href="#replace-4">replace</a></strong>(const QChar *<em>before</em>, qsizetype <em>blen</em>, const QChar *<em>after</em>, qsizetype <em>alen</em>, Qt::CaseSensitivity <em>cs</em> = Qt::CaseSensitive)</td>
</tr>
<tr>
<td>QString &amp;</td>
<td><strong><a href="#replace-5">replace</a></strong>(QLatin1String <em>before</em>, QLatin1String <em>after</em>, Qt::CaseSensitivity <em>cs</em> = Qt::CaseSensitive)</td>
</tr>
<tr>
<td>QString &amp;</td>
<td><strong><a href="#replace-6">replace</a></strong>(QLatin1String <em>before</em>, const QString &amp;<em>after</em>, Qt::CaseSensitivity <em>cs</em> = Qt::CaseSensitive)</td>
</tr>
<tr>
<td>QString &amp;</td>
<td><strong><a href="#replace-7">replace</a></strong>(const QString &amp;<em>before</em>, QLatin1String <em>after</em>, Qt::CaseSensitivity <em>cs</em> = Qt::CaseSensitive)</td>
</tr>
<tr>
<td>QString &amp;</td>
<td><strong><a href="#replace-8">replace</a></strong>(const QString &amp;<em>before</em>, const QString &amp;<em>after</em>, Qt::CaseSensitivity <em>cs</em> = Qt::CaseSensitive)</td>
</tr>
<tr>
<td>QString &amp;</td>
<td><strong><a href="#replace-9">replace</a></strong>(QChar <em>ch</em>, const QString &amp;<em>after</em>, Qt::CaseSensitivity <em>cs</em> = Qt::CaseSensitive)</td>
</tr>
<tr>
<td>QString &amp;</td>
<td><strong><a href="#replace-10">replace</a></strong>(QChar <em>c</em>, QLatin1String <em>after</em>, Qt::CaseSensitivity <em>cs</em> = Qt::CaseSensitive)</td>
</tr>
<tr>
<td>QString &amp;</td>
<td><strong><a href="#replace-11">replace</a></strong>(const QRegularExpression &amp;<em>re</em>, const QString &amp;<em>after</em>)</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="#reserve">reserve</a></strong>(qsizetype <em>size</em>)</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="#resize">resize</a></strong>(qsizetype <em>size</em>)</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="#resize-1">resize</a></strong>(qsizetype <em>size</em>, QChar <em>fillChar</em>)</td>
</tr>
<tr>
<td>QString</td>
<td><strong><a href="#right">right</a></strong>(qsizetype <em>n</em>) const</td>
</tr>
<tr>
<td>QString</td>
<td><strong><a href="#rightJustified">rightJustified</a></strong>(qsizetype <em>width</em>, QChar <em>fill</em> = QLatin1Char(‘ ‘), bool <em>truncate</em> = false) const</td>
</tr>
<tr>
<td>QString</td>
<td><strong><a href="#section">section</a></strong>(QChar <em>sep</em>, qsizetype <em>start</em>, qsizetype <em>end</em> = -1, QString::SectionFlags <em>flags</em> = SectionDefault) const</td>
</tr>
<tr>
<td>QString</td>
<td><strong><a href="#section-1">section</a></strong>(const QString &amp;<em>sep</em>, qsizetype <em>start</em>, qsizetype <em>end</em> = -1, QString::SectionFlags <em>flags</em> = SectionDefault) const</td>
</tr>
<tr>
<td>QString</td>
<td><strong><a href="#section-2">section</a></strong>(const QRegularExpression &amp;<em>re</em>, qsizetype <em>start</em>, qsizetype <em>end</em> = -1, QString::SectionFlags <em>flags</em> = SectionDefault) const</td>
</tr>
<tr>
<td>QString &amp;</td>
<td><strong><a href="#setNum">setNum</a></strong>(int <em>n</em>, int <em>base</em> = 10)</td>
</tr>
<tr>
<td>QString &amp;</td>
<td><strong><a href="#setNum-1">setNum</a></strong>(short <em>n</em>, int <em>base</em> = 10)</td>
</tr>
<tr>
<td>QString &amp;</td>
<td><strong><a href="#setNum-2">setNum</a></strong>(ushort <em>n</em>, int <em>base</em> = 10)</td>
</tr>
<tr>
<td>QString &amp;</td>
<td><strong><a href="#setNum-3">setNum</a></strong>(uint <em>n</em>, int <em>base</em> = 10)</td>
</tr>
<tr>
<td>QString &amp;</td>
<td><strong><a href="#setNum-4">setNum</a></strong>(long <em>n</em>, int <em>base</em> = 10)</td>
</tr>
<tr>
<td>QString &amp;</td>
<td><strong><a href="#setNum-5">setNum</a></strong>(ulong <em>n</em>, int <em>base</em> = 10)</td>
</tr>
<tr>
<td>QString &amp;</td>
<td><strong><a href="#setNum-6">setNum</a></strong>(qlonglong <em>n</em>, int <em>base</em> = 10)</td>
</tr>
<tr>
<td>QString &amp;</td>
<td><strong><a href="#setNum-7">setNum</a></strong>(qulonglong <em>n</em>, int <em>base</em> = 10)</td>
</tr>
<tr>
<td>QString &amp;</td>
<td><strong><a href="#setNum-8">setNum</a></strong>(float <em>n</em>, char <em>format</em> = ‘g’, int <em>precision</em> = 6)</td>
</tr>
<tr>
<td>QString &amp;</td>
<td><strong><a href="#setNum-9">setNum</a></strong>(double <em>n</em>, char <em>format</em> = ‘g’, int <em>precision</em> = 6)</td>
</tr>
<tr>
<td>QString &amp;</td>
<td><strong><a href="#setRawData">setRawData</a></strong>(const QChar *<em>unicode</em>, qsizetype <em>size</em>)</td>
</tr>
<tr>
<td>QString &amp;</td>
<td><strong><a href="#setUnicode">setUnicode</a></strong>(const QChar *<em>unicode</em>, qsizetype <em>size</em>)</td>
</tr>
<tr>
<td>QString &amp;</td>
<td><strong><a href="#setUtf16">setUtf16</a></strong>(const ushort *<em>unicode</em>, qsizetype <em>size</em>)</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="#shrink_to_fit">shrink_to_fit</a></strong>()</td>
</tr>
<tr>
<td>QString</td>
<td><strong><a href="#simplified">simplified</a></strong>() const</td>
</tr>
<tr>
<td>qsizetype</td>
<td><strong><a href="#size">size</a></strong>() const</td>
</tr>
<tr>
<td>QString</td>
<td><strong><a href="#sliced">sliced</a></strong>(qsizetype <em>pos</em>, qsizetype <em>n</em>) const</td>
</tr>
<tr>
<td>QString</td>
<td><strong><a href="#sliced-1">sliced</a></strong>(qsizetype <em>pos</em>) const</td>
</tr>
<tr>
<td>QStringList</td>
<td><strong><a href="#split">split</a></strong>(const QString &amp;<em>sep</em>, Qt::SplitBehavior <em>behavior</em> = Qt::KeepEmptyParts, Qt::CaseSensitivity <em>cs</em> = Qt::CaseSensitive) const</td>
</tr>
<tr>
<td>QStringList</td>
<td><strong><a href="#split-1">split</a></strong>(QChar <em>sep</em>, Qt::SplitBehavior <em>behavior</em> = Qt::KeepEmptyParts, Qt::CaseSensitivity <em>cs</em> = Qt::CaseSensitive) const</td>
</tr>
<tr>
<td>QStringList</td>
<td><strong><a href="#split-2">split</a></strong>(const QRegularExpression &amp;<em>re</em>, Qt::SplitBehavior <em>behavior</em> = Qt::KeepEmptyParts) const</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="#squeeze">squeeze</a></strong>()</td>
</tr>
<tr>
<td>bool</td>
<td><strong><a href="#startsWith">startsWith</a></strong>(const QString &amp;<em>s</em>, Qt::CaseSensitivity <em>cs</em> = Qt::CaseSensitive) const</td>
</tr>
<tr>
<td>bool</td>
<td><strong><a href="#startsWith-1">startsWith</a></strong>(QStringView <em>str</em>, Qt::CaseSensitivity <em>cs</em> = Qt::CaseSensitive) const</td>
</tr>
<tr>
<td>bool</td>
<td><strong><a href="#startsWith-2">startsWith</a></strong>(QLatin1String <em>s</em>, Qt::CaseSensitivity <em>cs</em> = Qt::CaseSensitive) const</td>
</tr>
<tr>
<td>bool</td>
<td><strong><a href="#startsWith-3">startsWith</a></strong>(QChar <em>c</em>, Qt::CaseSensitivity <em>cs</em> = Qt::CaseSensitive) const</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="#swap">swap</a></strong>(QString &amp;<em>other</em>)</td>
</tr>
<tr>
<td>CFStringRef</td>
<td><strong><a href="#toCFString">toCFString</a></strong>() const</td>
</tr>
<tr>
<td>QString</td>
<td><strong><a href="#toCaseFolded">toCaseFolded</a></strong>() const</td>
</tr>
<tr>
<td>double</td>
<td><strong><a href="#toDouble">toDouble</a></strong>(bool *<em>ok</em> = nullptr) const</td>
</tr>
<tr>
<td>float</td>
<td><strong><a href="#toFloat">toFloat</a></strong>(bool *<em>ok</em> = nullptr) const</td>
</tr>
<tr>
<td>QString</td>
<td><strong><a href="#toHtmlEscaped">toHtmlEscaped</a></strong>() const</td>
</tr>
<tr>
<td>int</td>
<td><strong><a href="#toInt">toInt</a></strong>(bool *<em>ok</em> = nullptr, int <em>base</em> = 10) const</td>
</tr>
<tr>
<td>QByteArray</td>
<td><strong><a href="#toLatin1">toLatin1</a></strong>() const</td>
</tr>
<tr>
<td>QByteArray</td>
<td><strong><a href="#toLocal8Bit">toLocal8Bit</a></strong>() const</td>
</tr>
<tr>
<td>long</td>
<td><strong><a href="#toLong">toLong</a></strong>(bool *<em>ok</em> = nullptr, int <em>base</em> = 10) const</td>
</tr>
<tr>
<td>qlonglong</td>
<td><strong><a href="#toLongLong">toLongLong</a></strong>(bool *<em>ok</em> = nullptr, int <em>base</em> = 10) const</td>
</tr>
<tr>
<td>QString</td>
<td><strong><a href="#toLower">toLower</a></strong>() const</td>
</tr>
<tr>
<td>NSString *</td>
<td><strong><a href="#toNSString">toNSString</a></strong>() const</td>
</tr>
<tr>
<td>short</td>
<td><strong><a href="#toShort">toShort</a></strong>(bool *<em>ok</em> = nullptr, int <em>base</em> = 10) const</td>
</tr>
<tr>
<td>std::string</td>
<td><strong><a href="#toStdString">toStdString</a></strong>() const</td>
</tr>
<tr>
<td>std::u16string</td>
<td><strong><a href="#toStdU16String">toStdU16String</a></strong>() const</td>
</tr>
<tr>
<td>std::u32string</td>
<td><strong><a href="#toStdU32String">toStdU32String</a></strong>() const</td>
</tr>
<tr>
<td>std::wstring</td>
<td><strong><a href="#toStdWString">toStdWString</a></strong>() const</td>
</tr>
<tr>
<td>uint</td>
<td><strong><a href="#toUInt">toUInt</a></strong>(bool *<em>ok</em> = nullptr, int <em>base</em> = 10) const</td>
</tr>
<tr>
<td>ulong</td>
<td><strong><a href="#toULong">toULong</a></strong>(bool *<em>ok</em> = nullptr, int <em>base</em> = 10) const</td>
</tr>
<tr>
<td>qulonglong</td>
<td><strong><a href="#toULongLong">toULongLong</a></strong>(bool *<em>ok</em> = nullptr, int <em>base</em> = 10) const</td>
</tr>
<tr>
<td>ushort</td>
<td><strong><a href="#toUShort">toUShort</a></strong>(bool *<em>ok</em> = nullptr, int <em>base</em> = 10) const</td>
</tr>
<tr>
<td>QList<uint></uint></td>
<td><strong><a href="#toUcs4">toUcs4</a></strong>() const</td>
</tr>
<tr>
<td>QString</td>
<td><strong><a href="#toUpper">toUpper</a></strong>() const</td>
</tr>
<tr>
<td>QByteArray</td>
<td><strong><a href="#toUtf8">toUtf8</a></strong>() const</td>
</tr>
<tr>
<td>qsizetype</td>
<td><strong><a href="#toWCharArray">toWCharArray</a></strong>(wchar_t *<em>array</em>) const</td>
</tr>
<tr>
<td>decltype(qTokenize(*this, std::forward<needle>(needle), flags…))</needle></td>
<td><strong><a href="#tokenize">tokenize</a></strong>(Needle &amp;&amp;<em>sep</em>, Flags… <em>flags</em>) const &amp;</td>
</tr>
<tr>
<td>decltype(qTokenize(std::move(*this), std::forward<needle>(needle), flags…))</needle></td>
<td><strong><a href="#tokenize-1">tokenize</a></strong>(Needle &amp;&amp;<em>sep</em>, Flags… <em>flags</em>) &amp;&amp;</td>
</tr>
<tr>
<td>QString</td>
<td><strong><a href="#trimmed">trimmed</a></strong>() const</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="#truncate">truncate</a></strong>(qsizetype <em>position</em>)</td>
</tr>
<tr>
<td>const QChar *</td>
<td><strong><a href="#unicode">unicode</a></strong>() const</td>
</tr>
<tr>
<td>const ushort *</td>
<td><strong><a href="#utf16">utf16</a></strong>() const</td>
</tr>
<tr>
<td>bool</td>
<td><strong><a href="#operator-not-eq-9">operator!=</a></strong>(const char *<em>other</em>) const</td>
</tr>
<tr>
<td>bool</td>
<td><strong><a href="#operator-not-eq-10">operator!=</a></strong>(const QByteArray &amp;<em>other</em>) const</td>
</tr>
<tr>
<td>QString &amp;</td>
<td><strong><a href="#operator-2b-eq">operator+=</a></strong>(const QString &amp;<em>other</em>)</td>
</tr>
<tr>
<td>QString &amp;</td>
<td><strong><a href="#operator-2b-eq-1">operator+=</a></strong>(QChar <em>ch</em>)</td>
</tr>
<tr>
<td>QString &amp;</td>
<td><strong><a href="#operator-2b-eq-2">operator+=</a></strong>(QStringView <em>str</em>)</td>
</tr>
<tr>
<td>QString &amp;</td>
<td><strong><a href="#operator-2b-eq-3">operator+=</a></strong>(QLatin1String <em>str</em>)</td>
</tr>
<tr>
<td>QString &amp;</td>
<td><strong><a href="#operator-2b-eq-4">operator+=</a></strong>(const char *<em>str</em>)</td>
</tr>
<tr>
<td>QString &amp;</td>
<td><strong><a href="#operator-2b-eq-5">operator+=</a></strong>(const QByteArray &amp;<em>ba</em>)</td>
</tr>
<tr>
<td>bool</td>
<td><strong><a href="#operator-lt-9">operator&lt;</a></strong>(const char *<em>other</em>) const</td>
</tr>
<tr>
<td>bool</td>
<td><strong><a href="#operator-lt-10">operator&lt;</a></strong>(const QByteArray &amp;<em>other</em>) const</td>
</tr>
<tr>
<td>bool</td>
<td><strong><a href="#operator-lt-eq-9">operator&lt;=</a></strong>(const char *<em>other</em>) const</td>
</tr>
<tr>
<td>bool</td>
<td><strong><a href="#operator-lt-eq-10">operator&lt;=</a></strong>(const QByteArray &amp;<em>other</em>) const</td>
</tr>
<tr>
<td>QString &amp;</td>
<td><strong><a href="#operator-eq-1">operator=</a></strong>(QChar <em>ch</em>)</td>
</tr>
<tr>
<td>QString &amp;</td>
<td><strong><a href="#operator-eq-2">operator=</a></strong>(QLatin1String <em>str</em>)</td>
</tr>
<tr>
<td>QString &amp;</td>
<td><strong><a href="#operator-eq-4">operator=</a></strong>(const char *<em>str</em>)</td>
</tr>
<tr>
<td>bool</td>
<td><strong><a href="#operator-eq-eq-9">operator==</a></strong>(const char *<em>other</em>) const</td>
</tr>
<tr>
<td>bool</td>
<td><strong><a href="#operator-eq-eq-10">operator==</a></strong>(const QByteArray &amp;<em>other</em>) const</td>
</tr>
<tr>
<td>bool</td>
<td><strong><a href="#operator-gt-9">operator&gt;</a></strong>(const char *<em>other</em>) const</td>
</tr>
<tr>
<td>bool</td>
<td><strong><a href="#operator-gt-10">operator&gt;</a></strong>(const QByteArray &amp;<em>other</em>) const</td>
</tr>
<tr>
<td>bool</td>
<td><strong><a href="#operator-gt-eq-9">operator&gt;=</a></strong>(const char *<em>other</em>) const</td>
</tr>
<tr>
<td>bool</td>
<td><strong><a href="#operator-gt-eq-10">operator&gt;=</a></strong>(const QByteArray &amp;<em>other</em>) const</td>
</tr>
<tr>
<td>QChar &amp;</td>
<td><strong>[operator<a href="#operator-5b-5d">]</a></strong>(qsizetype <em>position</em>)</td>
</tr>
<tr>
<td>const QChar</td>
<td><strong>[operator<a href="#operator-5b-5d-1">]</a></strong>(qsizetype <em>position</em>) const</td>
</tr>
</tbody></table>
<h2><span id="jing-tai-gong-gong-cheng-yuan">静态公共成员</span><a href="#jing-tai-gong-gong-cheng-yuan" class="header-anchor">#</a></h2><table>
<thead>
<tr>
<th>QString</th>
<th><strong><a href="#asprintf">asprintf</a></strong>(const char *<em>cformat</em>, …)</th>
</tr>
</thead>
<tbody><tr>
<td>int</td>
<td><strong><a href="#compare">compare</a></strong>(const QString &amp;<em>s1</em>, const QString &amp;<em>s2</em>, Qt::CaseSensitivity <em>cs</em> = Qt::CaseSensitive)</td>
</tr>
<tr>
<td>int</td>
<td><strong><a href="#compare-5">compare</a></strong>(const QString &amp;<em>s1</em>, QLatin1String <em>s2</em>, Qt::CaseSensitivity <em>cs</em> = Qt::CaseSensitive)</td>
</tr>
<tr>
<td>int</td>
<td><strong><a href="#compare-6">compare</a></strong>(QLatin1String <em>s1</em>, const QString &amp;<em>s2</em>, Qt::CaseSensitivity <em>cs</em> = Qt::CaseSensitive)</td>
</tr>
<tr>
<td>int</td>
<td><strong><a href="#compare-7">compare</a></strong>(const QString &amp;<em>s1</em>, QStringView <em>s2</em>, Qt::CaseSensitivity <em>cs</em> = Qt::CaseSensitive)</td>
</tr>
<tr>
<td>int</td>
<td><strong><a href="#compare-8">compare</a></strong>(QStringView <em>s1</em>, const QString &amp;<em>s2</em>, Qt::CaseSensitivity <em>cs</em> = Qt::CaseSensitive)</td>
</tr>
<tr>
<td>QString</td>
<td><strong><a href="#fromCFString">fromCFString</a></strong>(CFStringRef <em>string</em>)</td>
</tr>
<tr>
<td>QString</td>
<td><strong><a href="#fromLatin1">fromLatin1</a></strong>(const char *<em>str</em>, qsizetype <em>size</em>)</td>
</tr>
<tr>
<td>QString</td>
<td><strong><a href="#fromLatin1-1">fromLatin1</a></strong>(QByteArrayView <em>str</em>)</td>
</tr>
<tr>
<td>QString</td>
<td><strong><a href="#fromLatin1-2">fromLatin1</a></strong>(const QByteArray &amp;<em>str</em>)</td>
</tr>
<tr>
<td>QString</td>
<td><strong><a href="#fromLocal8Bit">fromLocal8Bit</a></strong>(const char *<em>str</em>, qsizetype <em>size</em>)</td>
</tr>
<tr>
<td>QString</td>
<td><strong><a href="#fromLocal8Bit-1">fromLocal8Bit</a></strong>(QByteArrayView <em>str</em>)</td>
</tr>
<tr>
<td>QString</td>
<td><strong><a href="#fromLocal8Bit-2">fromLocal8Bit</a></strong>(const QByteArray &amp;<em>str</em>)</td>
</tr>
<tr>
<td>QString</td>
<td><strong><a href="#fromNSString">fromNSString</a></strong>(const NSString *<em>string</em>)</td>
</tr>
<tr>
<td>QString</td>
<td><strong><a href="#fromRawData">fromRawData</a></strong>(const QChar *<em>unicode</em>, qsizetype <em>size</em>)</td>
</tr>
<tr>
<td>QString</td>
<td><strong><a href="#fromStdString">fromStdString</a></strong>(const std::string &amp;<em>str</em>)</td>
</tr>
<tr>
<td>QString</td>
<td><strong><a href="#fromStdU16String">fromStdU16String</a></strong>(const std::u16string &amp;<em>str</em>)</td>
</tr>
<tr>
<td>QString</td>
<td><strong><a href="#fromStdU32String">fromStdU32String</a></strong>(const std::u32string &amp;<em>str</em>)</td>
</tr>
<tr>
<td>QString</td>
<td><strong><a href="#fromStdWString">fromStdWString</a></strong>(const std::wstring &amp;<em>str</em>)</td>
</tr>
<tr>
<td>QString</td>
<td><strong><a href="#fromUcs4">fromUcs4</a></strong>(const char32_t *<em>unicode</em>, qsizetype <em>size</em> = -1)</td>
</tr>
<tr>
<td>QString</td>
<td><strong><a href="#fromUtf8">fromUtf8</a></strong>(const char *<em>str</em>, qsizetype <em>size</em>)</td>
</tr>
<tr>
<td>QString</td>
<td><strong><a href="#fromUtf8-1">fromUtf8</a></strong>(QByteArrayView <em>str</em>)</td>
</tr>
<tr>
<td>QString</td>
<td><strong><a href="#fromUtf8-2">fromUtf8</a></strong>(const QByteArray &amp;<em>str</em>)</td>
</tr>
<tr>
<td>QString</td>
<td><strong><a href="#fromUtf8-3">fromUtf8</a></strong>(const char8_t *<em>str</em>)</td>
</tr>
<tr>
<td>QString</td>
<td><strong><a href="#fromUtf8-4">fromUtf8</a></strong>(const char8_t *<em>str</em>, qsizetype <em>size</em>)</td>
</tr>
<tr>
<td>QString</td>
<td><strong><a href="#fromUtf16">fromUtf16</a></strong>(const char16_t *<em>unicode</em>, qsizetype <em>size</em> = -1)</td>
</tr>
<tr>
<td>QString</td>
<td><strong><a href="#fromWCharArray">fromWCharArray</a></strong>(const wchar_t *<em>string</em>, qsizetype <em>size</em> = -1)</td>
</tr>
<tr>
<td>int</td>
<td><strong><a href="#localeAwareCompare">localeAwareCompare</a></strong>(const QString &amp;<em>s1</em>, const QString &amp;<em>s2</em>)</td>
</tr>
<tr>
<td>int</td>
<td><strong><a href="#localeAwareCompare-3">localeAwareCompare</a></strong>(QStringView <em>s1</em>, QStringView <em>s2</em>)</td>
</tr>
<tr>
<td>QString</td>
<td><strong><a href="#number">number</a></strong>(long <em>n</em>, int <em>base</em> = 10)</td>
</tr>
<tr>
<td>QString</td>
<td><strong><a href="#number-1">number</a></strong>(int <em>n</em>, int <em>base</em> = 10)</td>
</tr>
<tr>
<td>QString</td>
<td><strong><a href="#number-2">number</a></strong>(uint <em>n</em>, int <em>base</em> = 10)</td>
</tr>
<tr>
<td>QString</td>
<td><strong><a href="#number-3">number</a></strong>(ulong <em>n</em>, int <em>base</em> = 10)</td>
</tr>
<tr>
<td>QString</td>
<td><strong><a href="#number-4">number</a></strong>(qlonglong <em>n</em>, int <em>base</em> = 10)</td>
</tr>
<tr>
<td>QString</td>
<td><strong><a href="#number-5">number</a></strong>(qulonglong <em>n</em>, int <em>base</em> = 10)</td>
</tr>
<tr>
<td>QString</td>
<td><strong><a href="#number-6">number</a></strong>(double <em>n</em>, char <em>format</em> = ‘g’, int <em>precision</em> = 6)</td>
</tr>
<tr>
<td>QString</td>
<td><strong><a href="#vasprintf">vasprintf</a></strong>(const char *<em>cformat</em>, va_list <em>ap</em>)</td>
</tr>
</tbody></table>
<h2><span id="fei-xiang-guan-cheng-yuan">非相关成员</span><a href="#fei-xiang-guan-cheng-yuan" class="header-anchor">#</a></h2><table>
<thead>
<tr>
<th>qsizetype</th>
<th><strong><a href="#erase-1">erase</a></strong>(QString &amp;<em>s</em>, const T &amp;<em>t</em>)</th>
</tr>
</thead>
<tbody><tr>
<td>qsizetype</td>
<td><strong><a href="#erase_if">erase_if</a></strong>(QString &amp;<em>s</em>, Predicate <em>pred</em>)</td>
</tr>
<tr>
<td>bool</td>
<td><strong><a href="#operator-not-eq">operator!=</a></strong>(const QString &amp;<em>s1</em>, const QString &amp;<em>s2</em>)</td>
</tr>
<tr>
<td>bool</td>
<td><strong><a href="#operator-not-eq-1">operator!=</a></strong>(const QString &amp;<em>s1</em>, QLatin1String <em>s2</em>)</td>
</tr>
<tr>
<td>bool</td>
<td><strong><a href="#operator-not-eq-11">operator!=</a></strong>(const char *<em>s1</em>, const QString &amp;<em>s2</em>)</td>
</tr>
<tr>
<td>QString</td>
<td><strong><a href="#operator-22-22_qs">operator””_qs</a></strong>(const char16_t *<em>str</em>, size_t <em>size</em>)</td>
</tr>
<tr>
<td>const QString</td>
<td><strong><a href="#operator-2b">operator+</a></strong>(const QString &amp;<em>s1</em>, const QString &amp;<em>s2</em>)</td>
</tr>
<tr>
<td>const QString</td>
<td><strong><a href="#operator-2b-1">operator+</a></strong>(const QString &amp;<em>s1</em>, const char *<em>s2</em>)</td>
</tr>
<tr>
<td>const QString</td>
<td><strong><a href="#operator-2b-2">operator+</a></strong>(const char *<em>s1</em>, const QString &amp;<em>s2</em>)</td>
</tr>
<tr>
<td>bool</td>
<td><strong><a href="#operator-lt-1">operator&lt;</a></strong>(const QString &amp;<em>s1</em>, const QString &amp;<em>s2</em>)</td>
</tr>
<tr>
<td>bool</td>
<td><strong><a href="#operator-lt-2">operator&lt;</a></strong>(const QString &amp;<em>s1</em>, QLatin1String <em>s2</em>)</td>
</tr>
<tr>
<td>bool</td>
<td><strong><a href="#operator-lt-3">operator&lt;</a></strong>(QLatin1String <em>s1</em>, const QString &amp;<em>s2</em>)</td>
</tr>
<tr>
<td>bool</td>
<td><strong><a href="#operator-lt-11">operator&lt;</a></strong>(const char *<em>s1</em>, const QString &amp;<em>s2</em>)</td>
</tr>
<tr>
<td>QDataStream &amp;</td>
<td><strong><a href="#operator-lt-lt">operator&lt;&lt;</a></strong>(QDataStream &amp;<em>stream</em>, const QString &amp;<em>string</em>)</td>
</tr>
<tr>
<td>bool</td>
<td><strong><a href="#operator-lt-eq">operator&lt;=</a></strong>(const QString &amp;<em>s1</em>, const QString &amp;<em>s2</em>)</td>
</tr>
<tr>
<td>bool</td>
<td><strong><a href="#operator-lt-eq-1">operator&lt;=</a></strong>(const QString &amp;<em>s1</em>, QLatin1String <em>s2</em>)</td>
</tr>
<tr>
<td>bool</td>
<td><strong><a href="#operator-lt-eq-2">operator&lt;=</a></strong>(QLatin1String <em>s1</em>, const QString &amp;<em>s2</em>)</td>
</tr>
<tr>
<td>bool</td>
<td><strong><a href="#operator-lt-eq-11">operator&lt;=</a></strong>(const char *<em>s1</em>, const QString &amp;<em>s2</em>)</td>
</tr>
<tr>
<td>bool</td>
<td><strong><a href="#operator-eq-eq-1">operator==</a></strong>(const QString &amp;<em>s1</em>, const QString &amp;<em>s2</em>)</td>
</tr>
<tr>
<td>bool</td>
<td><strong><a href="#operator-eq-eq-2">operator==</a></strong>(const QString &amp;<em>s1</em>, QLatin1String <em>s2</em>)</td>
</tr>
<tr>
<td>bool</td>
<td><strong><a href="#operator-eq-eq-3">operator==</a></strong>(QLatin1String <em>s1</em>, const QString &amp;<em>s2</em>)</td>
</tr>
<tr>
<td>bool</td>
<td><strong><a href="#operator-eq-eq-11">operator==</a></strong>(const char *<em>s1</em>, const QString &amp;<em>s2</em>)</td>
</tr>
<tr>
<td>bool</td>
<td><strong><a href="#operator-gt">operator&gt;</a></strong>(const QString &amp;<em>s1</em>, const QString &amp;<em>s2</em>)</td>
</tr>
<tr>
<td>bool</td>
<td><strong><a href="#operator-gt-1">operator&gt;</a></strong>(const QString &amp;<em>s1</em>, QLatin1String <em>s2</em>)</td>
</tr>
<tr>
<td>bool</td>
<td><strong><a href="#operator-gt-2">operator&gt;</a></strong>(QLatin1String <em>s1</em>, const QString &amp;<em>s2</em>)</td>
</tr>
<tr>
<td>bool</td>
<td><strong><a href="#operator-gt-11">operator&gt;</a></strong>(const char *<em>s1</em>, const QString &amp;<em>s2</em>)</td>
</tr>
<tr>
<td>bool</td>
<td><strong><a href="#operator-gt-eq">operator&gt;=</a></strong>(const QString &amp;<em>s1</em>, const QString &amp;<em>s2</em>)</td>
</tr>
<tr>
<td>bool</td>
<td><strong><a href="#operator-gt-eq-1">operator&gt;=</a></strong>(const QString &amp;<em>s1</em>, QLatin1String <em>s2</em>)</td>
</tr>
<tr>
<td>bool</td>
<td><strong><a href="#operator-gt-eq-2">operator&gt;=</a></strong>(QLatin1String <em>s1</em>, const QString &amp;<em>s2</em>)</td>
</tr>
<tr>
<td>bool</td>
<td><strong><a href="#operator-gt-eq-11">operator&gt;=</a></strong>(const char *<em>s1</em>, const QString &amp;<em>s2</em>)</td>
</tr>
<tr>
<td>QDataStream &amp;</td>
<td><strong><a href="#operator-gt-gt">operator&gt;&gt;</a></strong>(QDataStream &amp;<em>stream</em>, QString &amp;<em>string</em>)</td>
</tr>
</tbody></table>
<h2><span id="hong">宏</span><a href="#hong" class="header-anchor">#</a></h2><table>
<thead>
<tr>
<th></th>
<th><strong><a href="#QStringLiteral">QStringLiteral</a></strong>(<em>str</em>)</th>
</tr>
</thead>
<tbody><tr>
<td></td>
<td><strong><a href="#QT_NO_CAST_FROM_ASCII">QT_NO_CAST_FROM_ASCII</a></strong></td>
</tr>
<tr>
<td></td>
<td><strong><a href="#QT_NO_CAST_TO_ASCII">QT_NO_CAST_TO_ASCII</a></strong></td>
</tr>
<tr>
<td></td>
<td><strong><a href="#QT_RESTRICTED_CAST_FROM_ASCII">QT_RESTRICTED_CAST_FROM_ASCII</a></strong></td>
</tr>
</tbody></table>
<h2><span id="xiang-xi-miao-shu">详细描述</span><a href="#xiang-xi-miao-shu" class="header-anchor">#</a></h2><p>QString 存储一串 16 位的 <a href="qchar.html">QChar</a>，其中每个 <a href="qchar.html">QChar</a> 对应一个 UTF-16 代码单元。 （代码值高于 65535 的 Unicode 字符使用代理对存储，即两个连续的 <a href="qchar.html">QChar</a>s。）</p>
<p><a href="12-0-qdoc-commands-miscellaneous.html#unicode">Unicode</a> 是支持当今使用的大多数书写系统的国际标准。它是 US-ASCII (ANSI X3.4-1986) 和 Latin-1 (ISO 8859-1) 的超集，所有 US-ASCII/Latin-1 字符在相同的代码位置可用。</p>
<p>在幕后，QString 使用 <a href="implicit-sharing.html">隐式共享</a> (copy-on-write) 来减少内存使用并避免不必要的数据复制。这也有助于减少存储 16 位字符而不是 8 位字符的固有开销。</p>
<p>除了 QString，Qt 还提供了 <a href="qbytearray.html">QByteArray</a> 类来存储原始字节和传统的 8 位以 ‘\0’ 结尾的字符串。对于大多数用途，QString 是您要使用的类。它在整个 Qt API 中使用，并且 Unicode 支持确保如果您想在某个时候扩展应用程序的市场，您的应用程序将易于翻译。 <a href="qbytearray.html">QByteArray</a> 适用的两种主要情况是，当您需要存储原始二进制数据时，以及当内存保护至关重要时（如在嵌入式系统中）。</p>
<h3><span id="chu-shi-hua-zi-fu-chuan">初始化字符串</span><a href="#chu-shi-hua-zi-fu-chuan" class="header-anchor">#</a></h3><p>初始化 QString 的一种方法是简单地将 <code>const char *</code> 传递给它的构造函数。 例如，以下代码创建一个大小为 5 的 QString，其中包含数据”Hello”：</p>
<div class="code-wrapper"><pre><code class="hljs c++">QString str = <span class="hljs-string">"Hello"</span>;</code></pre></div>

<p>QString 使用 <a href="#fromUtf8">fromUtf8</a>() 函数将 <code>const char *</code> 数据转换为 Unicode。</p>
<p>在所有采用 <code>const char *</code> 参数的 QString 函数中，<code>const char *</code> 被解释为以 UTF-8 编码的经典 C 风格 ‘\0’ 终止的字符串。 <code>const char *</code> 参数为 <code>nullptr</code> 是合法的。</p>
<p>您还可以将字符串数据作为 <a href="qchar.html">QChar</a>s 的数组提供：</p>
<div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-type">static</span> <span class="hljs-type">const</span> QChar data[<span class="hljs-number">4</span>] = { <span class="hljs-number">0x0055</span>, <span class="hljs-number">0x006e</span>, <span class="hljs-number">0x10e3</span>, <span class="hljs-number">0x03a3</span> };
<span class="hljs-function">QString <span class="hljs-title">str</span><span class="hljs-params">(data, <span class="hljs-number">4</span>)</span></span>;</code></pre></div>

<p>QString 对 <a href="qchar.html">QChar</a> 数据进行了深层复制，因此您可以稍后对其进行修改而不会遇到副作用。 （如果出于性能原因您不想获取字符数据的深层副本，请改用 <a href="#fromRawData">QString::fromRawData</a>()。）</p>
<p>另一种方法是使用 <a href="#resize">resize</a>() 设置字符串的大小，并按字符初始化数据字符。 QString 使用从 0 开始的索引，就像 C++ 数组一样。 要访问特定索引位置的字符，可以使用 [operator<a href="#operator-5b-5d">]</a>()。 在非 <code>const</code> 字符串上，[operator<a href="#operator-5b-5d">]</a>() 返回对可用于赋值左侧的字符的引用。 对于例子：</p>
<div class="code-wrapper"><pre><code class="hljs C++">QString str;
str.<span class="hljs-built_in">resize</span>(<span class="hljs-number">4</span>);

str[<span class="hljs-number">0</span>] = <span class="hljs-built_in">QChar</span>(<span class="hljs-string">'U'</span>);
str[<span class="hljs-number">1</span>] = <span class="hljs-built_in">QChar</span>(<span class="hljs-string">'n'</span>);
str[<span class="hljs-number">2</span>] = <span class="hljs-built_in">QChar</span>(<span class="hljs-number">0x10e3</span>);
str[<span class="hljs-number">3</span>] = <span class="hljs-built_in">QChar</span>(<span class="hljs-number">0x03a3</span>);</code></pre></div>

<p>对于只读访问，另一种语法是使用 <a href="#at">at</a>() 函数：</p>
<div class="code-wrapper"><pre><code class="hljs c++">QString str;

<span class="hljs-keyword">for</span> (qsizetype i = <span class="hljs-number">0</span>; i &lt; str.<span class="hljs-built_in">size</span>(); ++i) {
    <span class="hljs-keyword">if</span> (str.<span class="hljs-built_in">at</span>(i) &gt;= <span class="hljs-built_in">QChar</span>(<span class="hljs-string">'a'</span>) &amp;&amp; str.<span class="hljs-built_in">at</span>(i) &lt;= <span class="hljs-built_in">QChar</span>(<span class="hljs-string">'f'</span>))
        <span class="hljs-built_in">qDebug</span>() &lt;&lt; <span class="hljs-string">"Found character in range [a-f]"</span>;
}</code></pre></div>

<p><a href="#at">at</a>() 函数可以比 [operator<a href="#operator-5b-5d">]</a>() 更快，因为它永远不会导致 [deep copy](implicit-sharing.html#deep- 复制）发生。 或者，使用 <a href="#first">first</a>()、<a href="#last">last</a>() 或 <a href="#sliced">sliced</a>() 函数一次提取多个字符。</p>
<p>QString 可以嵌入 ‘\0’ 字符（<a href="qchar.html#SpecialCharacter-enum">QChar::Null</a>）。 <a href="#size">size</a>() 函数总是返回整个字符串的大小，包括嵌入的 ‘\0’ 字符。</p>
<p>调用 <a href="#resize">resize</a>() 函数后，新分配的字符具有未定义的值。 要将字符串中的所有字符设置为特定值，请使用 <a href="#fill">fill</a>() 函数。</p>
<p>QString 提供了许多旨在简化字符串使用的重载。 例如，如果您想将 QString 与字符串文字进行比较，您可以编写如下代码，它将按预期工作：</p>
<div class="code-wrapper"><pre><code class="hljs c++">QString str;

<span class="hljs-keyword">if</span> (str == <span class="hljs-string">"auto"</span> || str == <span class="hljs-string">"extern"</span>
    || str == <span class="hljs-string">"static"</span> || str == <span class="hljs-string">"register"</span>) {
    <span class="hljs-comment">// ...</span>
}</code></pre></div>

<p>您还可以将字符串文字传递给以 QStrings 作为参数的函数，调用 QString(const char *) 构造函数。 类似地，您可以使用 <a href="qtglobal.html#qPrintable">qPrintable</a>() 宏将 QString 传递给接受<code>const char *</code>参数的函数，该宏将给定的 QString 作为<code>const char *</code>返回。 这相当于调用 <qstring>.<a href="#toLocal8Bit">toLocal8Bit</a>().<a href="#constData">constData</a>()。</qstring></p>
<h3><span id="cao-zuo-zi-fu-chuan-shu-ju">操作字符串数据</span><a href="#cao-zuo-zi-fu-chuan-shu-ju" class="header-anchor">#</a></h3><p>QString提供了以下修改字符数据的基本函数：<a href="#append">append</a>()、<a href="#prepend">prepend</a>()、<a href="#insert">insert</a>()、<a href="#replace">replace</a>( ) 和 <a href="#remove">删除</a>()。 对于例子：</p>
<div class="code-wrapper"><pre><code class="hljs c++">QString str = <span class="hljs-string">"and"</span>;
str.<span class="hljs-built_in">prepend</span>(<span class="hljs-string">"rock "</span>);     <span class="hljs-comment">// str == "rock and"</span>
str.<span class="hljs-built_in">append</span>(<span class="hljs-string">" roll"</span>);        <span class="hljs-comment">// str == "rock and roll"</span>
str.<span class="hljs-built_in">replace</span>(<span class="hljs-number">5</span>, <span class="hljs-number">3</span>, <span class="hljs-string">"&amp;"</span>);   <span class="hljs-comment">// str == "rock &amp; roll"</span></code></pre></div>

<p>在上面的示例中，<a href="#replace">replace</a>() 函数的前两个参数是开始替换的位置和应该替换的字符数。</p>
<p>当数据修改函数增加字符串的大小时，它们可能会导致为 QString 对象重新分配内存。当这种情况发生时，QString 会扩展超过它立即需要的空间，以便有空间进行进一步扩展而无需重新分配，直到字符串的大小大大增加。</p>
<p><a href="#insert">insert</a>()、<a href="#remove">remove</a>() 以及用不同大小之一替换子字符串时，<a href="#replace">replace</a>() 函数可能很慢（<a href="containers.html#linear-time">线性time</a>) 用于大字符串，因为它们需要将字符串中的许多字符移动至少一个内存位置。</p>
<p>如果您正在逐步构建一个 QString 并且提前知道 QString 将包含多少个字符，您可以调用 <a href="#reserve">reserve</a>()，要求 QString 预先分配一定数量的内存。您还可以调用 <a href="#capacity">容量</a>() 来找出 QString 实际分配了多少内存。</p>
<p>QString 提供 <a href="containers.html#stl-style-iterators">STL 风格的迭代器</a> (<a href="#const_iterator-typedef">QString::const_iterator</a> 和 <a href="#iterator-typedefx">QString::iterator</a>)。在实践中，迭代器在使用 C++ 标准库提供的通用算法时非常方便。</p>
<p><strong>注意：</strong> QString 上的迭代器，以及对单个字符的引用，在调用 QString 的任何非 <code>const</code> 方法时都不能依赖它来保持有效。在调用非 const 方法后访问这样的迭代器或引用会导致未定义的行为。当需要类似迭代器的功能的稳定性时，您应该使用索引而不是迭代器，因为它们与 QString 的内部状态无关，因此不会失效。</p>
<p><strong>注意：</strong> 由于 <a href="implicit-sharing.html">隐式共享</a>，给定 QString 上使用的第一个非 <code>const</code> 运算符或函数可能会导致它在内部执行其数据的深层复制。这会使字符串上的所有迭代器和对其中单个字符的引用无效。在第一个非 <code>const</code> 运算符之后，修改 QString 的操作可能会完全（在重新分配的情况下）或部分使迭代器和引用无效，但其他方法（例如 <a href="#begin">begin</a>() 或 [end](# end)()) 不会。在迭代器或引用失效后访问它会导致未定义的行为。</p>
<p>一个常见的要求是从字符串中删除空格字符（’\n’、’\t’、’’等）。如果要从 QString 的两端删除空格，请使用 <a href="#trimmed">trimmed</a>() 函数。如果要从两端删除空格并将多个连续的空格替换为字符串中的单个空格字符，请使用 <a href="#simplified">simplified</a>()。</p>
<p>如果要查找 QString 中特定字符或子字符串的所有出现，请使用 <a href="#indexOf">indexOf</a>() 或 <a href="#lastIndexOf">lastIndexOf</a>() 函数。前者从给定的索引位置开始向前搜索，后者向后搜索。如果找到它，两者都返回字符或子字符串的索引位置；否则，它们返回 -1。例如，这是一个典型的循环，它查找特定子字符串的所有出现：</p>
<div class="code-wrapper"><pre><code class="hljs c++">QString str = <span class="hljs-string">"We must be &lt;b&gt;bold&lt;/b&gt;, very &lt;b&gt;bold&lt;/b&gt;"</span>;
qsizetype j = <span class="hljs-number">0</span>;

<span class="hljs-keyword">while</span> ((j = str.<span class="hljs-built_in">indexOf</span>(<span class="hljs-string">"&lt;b&gt;"</span>, j)) != <span class="hljs-number">-1</span>) {
    <span class="hljs-built_in">qDebug</span>() &lt;&lt; <span class="hljs-string">"Found &lt;b&gt; tag at index position"</span> &lt;&lt; j;
    ++j;
}</code></pre></div>

<p>QString 提供了许多将数字转换为字符串和将字符串转换为数字的函数。 请参阅 <a href="#arg">arg</a>() 函数、<a href="#setNum">setNum</a>() 函数、<a href="#number">number</a>() 静态函数和 <a href="#toInt">toInt</a>()， <a href="#toDouble">toDouble</a>() 和类似的函数。</p>
<p>要获取字符串的大写或小写版本，请使用 <a href="#toUpper">toUpper</a>() 或 <a href="#toLower">toLower</a>()。</p>
<p>字符串列表由 <a href="qstringlist.html">QStringList</a> 类处理。 您可以使用 <a href="#split">split</a>() 函数将字符串拆分为字符串列表，并使用 [QStringList::join](qstringlist.html#join 将字符串列表连接为带有可选分隔符的单个字符串 )()。 您可以使用 <a href="qstringlist.html#filter">QStringList::filter</a>() 函数从包含特定子字符串或匹配特定 <a href="qregularexpression.html">QRegularExpression</a> 的字符串列表中获取字符串列表。</p>
<h3><span id="cha-xun-zi-fu-chuan-shu-ju">查询字符串数据</span><a href="#cha-xun-zi-fu-chuan-shu-ju" class="header-anchor">#</a></h3><p>如果您想查看 QString 是否以特定子字符串开头或结尾，请使用 <a href="#startsWith">startsWith</a>() 或 <a href="#endsWith">endsWith</a>()。 如果您只想检查 QString 是否包含特定字符或子字符串，请使用 <a href="#contains">contains</a>() 函数。 如果您想找出特定字符或子字符串在字符串中出现的次数，请使用 <a href="#count-1">count</a>()。</p>
<p>要获得指向实际字符数据的指针，请调用 <a href="#data">data</a>() 或 <a href="#constData">constData</a>()。 这些函数返回一个指向 <a href="qchar.html">QChar</a> 数据开头的指针。 指针保证保持有效，直到在 QString 上调用非 const 函数。</p>
<h4><span id="bi-jiao-zi-fu-chuan">比较字符串</span><a href="#bi-jiao-zi-fu-chuan" class="header-anchor">#</a></h4><p>QStrings 可以使用重载运算符进行比较，例如 <a href="#operator-lt-1">operator&lt;</a>()、<a href="#operator-lt-eq">operator&lt;=</a>()、[operator==](#operator-eq -eq-1)()、<a href="#operator-gt-eq">operator&gt;=</a>() 等等。 请注意，比较完全基于字符的数字 Unicode 值。 它非常快，但不是人类所期望的； 当这样的比较可用时，<a href="#localeAwareCompare">QString::localeAwareCompare</a>() 函数通常是对用户界面字符串进行排序的更好选择。</p>
<p>在类 Unix 平台（包括 Linux、macOS 和 iOS）上，当 Qt 与 ICU 库（通常是）链接时，会使用其区域设置感知排序。 否则，在 macOS 和 iOS 上，<a href="#localeAwareCompare">localeAwareCompare</a>() 根据国际首选项面板中的“排序列表顺序”设置进行比较。 在其他没有 ICU 的类 Unix 系统上，比较回退到系统库的<code>strcoll()</code>，</p>
<h3><span id="zai-bian-ma-zi-fu-chuan-shu-ju-he-qstring-zhi-jian-zhuan-huan">在编码字符串数据和 QString 之间转换</span><a href="#zai-bian-ma-zi-fu-chuan-shu-ju-he-qstring-zhi-jian-zhuan-huan" class="header-anchor">#</a></h3><p>QString 提供了以下三个函数，它们将字符串的 <code>const char *</code> 版本返回为 <a href="qbytearray.html">QByteArray</a>：<a href="#toUtf8">toUtf8</a>()、<a href="#toLatin1">toLatin1</a>() 和 <a href="#toLocal8Bit"> toLocal8Bit</a>()。</p>
<ul>
<li><a href="#toLatin1">toLatin1</a>() 返回一个 Latin-1 (ISO 8859-1) 编码的 8 位字符串。</li>
<li><a href="#toUtf8">toUtf8</a>() 返回一个 UTF-8 编码的 8 位字符串。 UTF-8 是 US-ASCII (ANSI X3.4-1986) 的超集，它通过多字节序列支持整个 Unicode 字符集。</li>
<li><a href="#toLocal8Bit">toLocal8Bit</a>() 使用系统的本地编码返回一个 8 位字符串。 这与 Unix 系统上的 <a href="#toUtf8">toUtf8</a>() 相同。</li>
</ul>
<p>为了从这些编码之一进行转换，QString 提供了 <a href="#fromLatin1">fromLatin1</a>()、<a href="#fromUtf8">fromUtf8</a>() 和 <a href="#fromLocal8Bit">fromLocal8Bit</a>()。通过 <a href="qstringencoder.html">QStringEncoder</a> 和 <a href="qstringdecoder.html">QStringDecoder</a> 类支持其他编码。</p>
<p>如上所述，QString 提供了许多函数和运算符，可以轻松地与 <code>const char *</code> 字符串进行互操作。但这个功能是一把双刃剑：如果所有字符串都是 US-ASCII 或 Latin-1，它会使 QString 更方便使用，但总是存在从或到 <code>const char *</code> 的隐式转换使用完成的风险错误的 8 位编码。为了最大限度地降低这些风险，您可以通过定义以下一些预处理器符号来关闭这些隐式转换：</p>
<ul>
<li><a href="#QT_NO_CAST_FROM_ASCII">QT_NO_CAST_FROM_ASCII</a> 禁用从 C 字符串文字和指向 Unicode 的指针的自动转换。</li>
<li><a href="#QT_RESTRICTED_CAST_FROM_ASCII">QT_RESTRICTED_CAST_FROM_ASCII</a> 允许从 C 字符和字符数组进行自动转换，但禁用从字符指针到 Unicode 的自动转换。</li>
<li><a href="#QT_NO_CAST_TO_ASCII">QT_NO_CAST_TO_ASCII</a> 禁用从 QString 到 C 字符串的自动转换。</li>
</ul>
<p>然后，您需要显式调用 <a href="#fromUtf8">fromUtf8</a>()、<a href="#fromLatin1">fromLatin1</a>() 或 <a href="#fromLocal8Bit">fromLocal8Bit</a>() 从 8 位字符串构造 QString，或使用 轻量级 <a href="qlatin1string.html">QLatin1String</a> 类，例如：</p>
<div class="code-wrapper"><pre><code class="hljs c++">QString url = <span class="hljs-built_in">QLatin1String</span>(<span class="hljs-string">"https://www.unicode.org/"</span>);</code></pre></div>

<p>Similarly, you must call <a href="#toLatin1">toLatin1</a>(), <a href="#toUtf8">toUtf8</a>(), or <a href="#toLocal8Bit">toLocal8Bit</a>() explicitly to convert the QString to an 8-bit string.</p>
<p><strong>C 程序员注意事项</strong></p>
<p>由于 C++ 的类型系统以及 QString 是 <a href="implicit-sharing.html">隐式共享</a> 的事实，QStrings 可能被视为 <code>int</code>s 或其他基本类型 .</p>
<p>例子:</p>
<div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-function">QString <span class="hljs-title">Widget::boolToString</span><span class="hljs-params">(<span class="hljs-type">bool</span> b)</span> </span>{    
    QString result;    
    <span class="hljs-keyword">if</span> (b)        
        result = <span class="hljs-string">"True"</span>;    
    <span class="hljs-keyword">else</span>        
        result = <span class="hljs-string">"False"</span>;    
    <span class="hljs-keyword">return</span> result;                                  
}</code></pre></div>

<p><code>result</code> 变量是分配在堆栈上的普通变量。 当 <code>return</code> 被调用时，因为我们是按值返回，所以会调用复制构造函数并返回字符串的副本。 由于隐式共享，不会发生实际复制。</p>
<h3><span id="null-zi-fu-chuan-he-empty-zi-fu-chuan-zhi-jian-de-qu-bie">NULL字符串和Empty字符串之间的区别</span><a href="#null-zi-fu-chuan-he-empty-zi-fu-chuan-zhi-jian-de-qu-bie" class="header-anchor">#</a></h3><p>由于历史原因，QString 区分空字符串和空字符串。 <em>null</em> 字符串是使用 QString 的默认构造函数或通过将 (<code>const char *</code>)0 传递给构造函数来初始化的字符串。 <em>empty</em> 字符串是大小为 0 的任何字符串。空字符串始终为空，但空字符串不一定为空：</p>
<div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-built_in">QString</span>().<span class="hljs-built_in">isNull</span>();               <span class="hljs-comment">// returns true</span>
<span class="hljs-built_in">QString</span>().<span class="hljs-built_in">isEmpty</span>();              <span class="hljs-comment">// returns true</span>

<span class="hljs-built_in">QString</span>(<span class="hljs-string">""</span>).<span class="hljs-built_in">isNull</span>();             <span class="hljs-comment">// returns false</span>
<span class="hljs-built_in">QString</span>(<span class="hljs-string">""</span>).<span class="hljs-built_in">isEmpty</span>();            <span class="hljs-comment">// returns true</span>

<span class="hljs-built_in">QString</span>(<span class="hljs-string">"abc"</span>).<span class="hljs-built_in">isNull</span>();          <span class="hljs-comment">// returns false</span>
<span class="hljs-built_in">QString</span>(<span class="hljs-string">"abc"</span>).<span class="hljs-built_in">isEmpty</span>();         <span class="hljs-comment">// returns false</span></code></pre></div>

<p>除了 <a href="#isNull">isNull</a>() 之外的所有函数都将空字符串视为空字符串。 例如，<a href="#toUtf8">toUtf8</a>().<a href="#constData">constData</a>() 为空字符串返回指向 ‘\0’ 字符的有效指针 (<em>not</em> nullptr)。 我们建议您始终使用 <a href="#isEmpty">isEmpty</a>() 函数并避免使用 <a href="#isNull">isNull</a>()。</p>
<h3><span id="shu-zi-ge-shi">数字格式</span><a href="#shu-zi-ge-shi" class="header-anchor">#</a></h3><p>当 <a href="#arg">QString::arg</a>() <code>'%'</code> 格式说明符包含 <code>'L'</code> 语言环境限定符，并且基数为 10（其默认值）时，使用默认语言环境。 这可以使用 <a href="qlocale.html#setDefault">QLocale::setDefault</a>() 来设置。 有关数字的本地化字符串表示的更精细控制，请参阅 <a href="qlocale.html#toString">QLocale::toString</a>()。 由 QString 完成的所有其他数字格式都遵循 C 语言环境的数字表示。</p>
<p>当 <a href="#arg">QString::arg</a>() 对数字应用左填充时，填充字符“0”被特殊处理。 如果数字为负数，则其减号将出现在零填充之前。 如果该字段已本地化，则使用适合区域设置的零字符代替“0”。 对于浮点数，这种特殊处理仅适用于数字是有限的。</p>
<h4><span id="fu-dian-ge-shi">浮点格式</span><a href="#fu-dian-ge-shi" class="header-anchor">#</a></h4><p>在将浮点数（<code>float</code> 或 <code>double</code>）表示为字符串的成员函数（例如，<a href="#arg">arg</a>()、<a href="#number">number</a>()）中，显示的形式可以是 由 <em>format</em> 和 <em>precision</em> 的选择控制，其含义与 <a href="qlocale.html#toString-8">QLocale::toString</a>(double, char, int) 相同。</p>
<p>如果选定的 <em>format</em> 包含指数，则本地化形式遵循区域设置对指数中数字的约定。 对于非本地化格式，指数显示其符号并包含至少两位数字，如果需要，左填充为零。</p>
<h3><span id="geng-gao-xiao-de-zi-fu-chuan-gou-zao">更高效的字符串构造</span><a href="#geng-gao-xiao-de-zi-fu-chuan-gou-zao" class="header-anchor">#</a></h3><p>许多字符串在编译时是已知的。 但是简单的构造函数 QString(“Hello”) 将复制字符串的内容，将内容视为 Latin-1。 为了避免这种情况，可以使用 <a href="#QStringLiteral">QStringLiteral</a> 宏在编译时直接创建所需的数据。 从文字构造 QString 不会在运行时导致任何开销。</p>
<p>一种效率稍低的方法是使用 <a href="qlatin1string.html">QLatin1String</a>。 这个类包装了一个 C 字符串文字，在编译时预先计算它的长度，然后可以用于更快地与 QStrings 进行比较并转换为 QStrings，而不是常规的 C 字符串文字。</p>
<p>使用 QString <code>'+'</code> 运算符，很容易从多个子字符串构造一个复杂的字符串。 你会经常写这样的代码：</p>
<div class="code-wrapper"><pre><code class="hljs c++">QString foo;
QString type = <span class="hljs-string">"long"</span>;

foo = <span class="hljs-built_in">QLatin1String</span>(<span class="hljs-string">"vector&lt;"</span>) + type + <span class="hljs-built_in">QLatin1String</span>(<span class="hljs-string">"&gt;::iterator"</span>);

<span class="hljs-keyword">if</span> (foo.<span class="hljs-built_in">startsWith</span>(<span class="hljs-string">"("</span> + type + <span class="hljs-string">") 0x"</span>))
    ...</code></pre></div>

<p>这些字符串结构中的任何一个都没有错，但是有一些隐藏的低效率。从 Qt 4.6 开始，您可以消除它们。</p>
<p>首先，“+”运算符的多次使用通常意味着多次内存分配。当连接 <em>n</em> 子字符串时，其中 <em>n &gt; 2</em>，可以有多达 <em>n - 1</em> 次对内存分配器的调用。</p>
<p>在 4.6 中，添加了一个内部模板类 <code>QStringBuilder</code> 以及一些辅助函数。这个类被标记为内部的并且不会出现在文档中，因为你不打算在你的代码中实例化它。它的使用将是自动的，如下所述。如果您想查看该类，可以在 <code>src/corelib/tools/qstringbuilder.cpp</code> 中找到它。</p>
<p><code>QStringBuilder</code> 使用表达式模板并重新实现了 <code>'%'</code> 操作符，这样当你使用 <code>'%'</code> 代替 <code>'+'</code> 进行字符串连接时，多个子字符串连接将被推迟到最终结果即将到来时分配给一个QString。此时，最终结果所需的内存量是已知的。然后调用内存分配器<em>一次</em>以获得所需的空间，并将子字符串一一复制到其中。</p>
<p>通过内联和减少引用计数可以获得额外的效率（从 <code>QStringBuilder</code> 创建的 QString 通常具有 1 的引用计数，而 <a href="#append">QString::append</a>() 需要额外的测试）。</p>
<p>有两种方法可以访问这种改进的字符串构造方法。直接的方法是在任何你想使用它的地方包含 <code>QStringBuilder</code>，并在连接字符串时使用 <code>'%'</code> 运算符而不是 <code>'+'</code>：</p>
<div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;QStringBuilder&gt;</span></span>

<span class="hljs-function">QString <span class="hljs-title">hello</span><span class="hljs-params">(<span class="hljs-string">"hello"</span>)</span></span>;
QStringView el = QStringView{ hello }.<span class="hljs-built_in">mid</span>(<span class="hljs-number">2</span>, <span class="hljs-number">3</span>);
<span class="hljs-function">QLatin1String <span class="hljs-title">world</span><span class="hljs-params">(<span class="hljs-string">"world"</span>)</span></span>;
QString message =  hello % el % world % <span class="hljs-built_in">QChar</span>(<span class="hljs-string">'!'</span>);</code></pre></div>

<p>最方便但不完全兼容源代码的更全局方法是在您的 .pro 文件中定义：</p>
<div class="code-wrapper"><pre><code class="hljs c++">DEFINES *= QT_USE_QSTRINGBUILDER</code></pre></div>

<p>并且 <code>'+'</code> 将在任何地方自动作为 <code>QStringBuilder</code> <code>'%'</code> 执行。</p>
<h3><span id="zui-da-da-xiao-he-nei-cun-bu-zu-qing-kuang">最大大小和内存不足情况</span><a href="#zui-da-da-xiao-he-nei-cun-bu-zu-qing-kuang" class="header-anchor">#</a></h3><p>QString 的最大大小取决于架构。大多数 64 位系统可以分配超过 2 GB 的内存，典型限制为 2^63 字节。实际值还取决于管理数据块所需的开销。因此，您可以预期最大大小为 2 GB 减去 32 位平台上的开销，以及 2^63 字节减去 64 位平台上的开销。可以存储在 QString 中的元素数量是这个最大大小除以 <a href="qchar.html">QChar</a> 的大小。</p>
<p>当内存分配失败时，如果应用程序使用异常支持编译，QString 会抛出一个 <code>std::bad_alloc</code> 异常。 Qt 容器中内存不足的情况是 Qt 抛出异常的唯一情况。如果异常被禁用，则内存不足是未定义的行为。</p>
<p>请注意，操作系统可能会对持有大量已分配内存的应用程序施加进一步的限制，尤其是大的连续块。此类考虑、此类行为的配置或任何缓解措施都超出了 Qt API 的范围。</p>
<p><strong>See also</strong> <a href="#fromRawData">fromRawData</a>(), <a href="qchar.html">QChar</a>, <a href="qstringview.html">QStringView</a>, <a href="qlatin1string.html">QLatin1String</a>, and <a href="qbytearray.html">QByteArray</a>.</p>
<h2><span id="cheng-yuan-lei-xing-wen-dang">成员类型文档</span><a href="#cheng-yuan-lei-xing-wen-dang" class="header-anchor">#</a></h2><h3><span id="qstring-constiterator">QString::ConstIterator</span><a href="#qstring-constiterator" class="header-anchor">#</a></h3><p><a href="#const_iterator-typedef">QString::const_iterator</a> 的 Qt 风格同义词。</p>
<h3><span id="qstring-iterator">QString::Iterator</span><a href="#qstring-iterator" class="header-anchor">#</a></h3><p><a href="#iterator-typedefx">QString::iterator</a> 的 Qt 风格同义词。</p>
<h3><span id="enum-qstring-normalizationform">enum QString::NormalizationForm</span><a href="#enum-qstring-normalizationform" class="header-anchor">#</a></h3><p>这个枚举描述了 Unicode 文本的各种规范化形式。</p>
<table>
<thead>
<tr>
<th>Constant</th>
<th>Value</th>
<th>Description</th>
</tr>
</thead>
<tbody><tr>
<td><code>QString::NormalizationForm_D</code></td>
<td><code>0</code></td>
<td>规范分解</td>
</tr>
<tr>
<td><code>QString::NormalizationForm_C</code></td>
<td><code>1</code></td>
<td>规范分解，然后是规范组合</td>
</tr>
<tr>
<td><code>QString::NormalizationForm_KD</code></td>
<td><code>2</code></td>
<td>兼容性分解</td>
</tr>
<tr>
<td><code>QString::NormalizationForm_KC</code></td>
<td><code>3</code></td>
<td>兼容性分解，然后是规范组合</td>
</tr>
</tbody></table>
<p><strong>See also</strong> <a href="#normalized">normalized</a>() and <a target="_blank" rel="noopener" href="https://www.unicode.org/reports/tr15/">Unicode Standard Annex #15</a>.</p>
<h3><span id="enum-qstring-sectionflag-flags-qstring-sectionflags">enum QString::SectionFlag flags QString::SectionFlags</span><a href="#enum-qstring-sectionflag-flags-qstring-sectionflags" class="header-anchor">#</a></h3><p>此枚举指定可用于影响 <a href="#section">section</a>() 函数关于分隔符和空字段的行为的各个方面的标志。</p>
<table>
<thead>
<tr>
<th>Constant</th>
<th>Value</th>
<th>Description</th>
</tr>
</thead>
<tbody><tr>
<td><code>QString::SectionDefault</code></td>
<td><code>0x00</code></td>
<td>计算空字段，不包括前导和尾随分隔符，并且区分大小写比较分隔符。</td>
</tr>
<tr>
<td><code>QString::SectionSkipEmpty</code></td>
<td><code>0x01</code></td>
<td>将空字段视为不存在，即就 <em>start</em> 和 <em>end</em> 而言，它们不被考虑。</td>
</tr>
<tr>
<td><code>QString::SectionIncludeLeadingSep</code></td>
<td><code>0x02</code></td>
<td>在结果字符串中包括前导分隔符（如果有）。</td>
</tr>
<tr>
<td><code>QString::SectionIncludeTrailingSep</code></td>
<td><code>0x04</code></td>
<td>在结果字符串中包含尾随分隔符（如果有）。</td>
</tr>
<tr>
<td><code>QString::SectionCaseInsensitiveSeps</code></td>
<td><code>0x08</code></td>
<td>不区分大小写地比较分隔符。</td>
</tr>
</tbody></table>
<p>SectionFlags 类型是 <a href="qflags.html">QFlags</a><sectionflag> 的 typedef。 它存储 SectionFlag 值的 OR 组合。</sectionflag></p>
<p><strong>See also</strong> <a href="#section">section</a>().</p>
<h3><span id="qstring-const-iterator">QString::const_iterator</span><a href="#qstring-const-iterator" class="header-anchor">#</a></h3><p><strong>See also</strong> <a href="#iterator-typedefx">QString::iterator</a>.</p>
<h3><span id="qstring-const-pointer">QString::const_pointer</span><a href="#qstring-const-pointer" class="header-anchor">#</a></h3><p>QString::const_pointer typedef 提供了一个指向 <a href>QString</a> 元素 (<a href="qchar.html">QChar</a>) 的 STL 风格的 const 指针。</p>
<h3><span id="qstring-const-reference">QString::const_reference</span><a href="#qstring-const-reference" class="header-anchor">#</a></h3><h3><span id="since-5-6-qstring-const-reverse-iterator"><code>[since 5.6]</code>QString::const_reverse_iterator</span><a href="#since-5-6-qstring-const-reverse-iterator" class="header-anchor">#</a></h3><p>此 typedef 是在 Qt 5.6 中引入的。</p>
<p><strong>See also</strong> <a href="#reverse_iterator-typedef">QString::reverse_iterator</a> and <a href="#const_iterator-typedef">QString::const_iterator</a>.</p>
<h3><span id="qstring-difference-type">QString::difference_type</span><a href="#qstring-difference-type" class="header-anchor">#</a></h3><h3><span id="qstring-iterator">QString::iterator</span><a href="#qstring-iterator" class="header-anchor">#</a></h3><p><strong>See also</strong> <a href="#const_iterator-typedef">QString::const_iterator</a>.</p>
<h3><span id="qstring-pointer">QString::pointer</span><a href="#qstring-pointer" class="header-anchor">#</a></h3><p>QString::pointer typedef 提供了一个指向 <a href>QString</a> 元素 (<a href="qchar.html">QChar</a>) 的 STL 样式指针。</p>
<h3><span id="qstring-reference">QString::reference</span><a href="#qstring-reference" class="header-anchor">#</a></h3><h3><span id="since-5-6-qstring-reverse-iterator"><code>[since 5.6]</code>QString::reverse_iterator</span><a href="#since-5-6-qstring-reverse-iterator" class="header-anchor">#</a></h3><p>此 typedef 是在 Qt 5.6 中引入的。</p>
<p><strong>See also</strong> <a href="#const_reverse_iterator-typedef">QString::const_reverse_iterator</a> and <a href="#iterator-typedefx">QString::iterator</a>.</p>
<h3><span id="qstring-size-type">QString::size_type</span><a href="#qstring-size-type" class="header-anchor">#</a></h3><h3><span id="qstring-value-type">QString::value_type</span><a href="#qstring-value-type" class="header-anchor">#</a></h3><h2><span id="cheng-yuan-han-shu-wen-dang">成员函数文档</span><a href="#cheng-yuan-han-shu-wen-dang" class="header-anchor">#</a></h2><h3><span id="since-6-0-template-lt-typename-needle-typename-flags-gt-decltype-qtokenize-std-move-this-std-forward-needle-flags-qstring-tokenize-needle-amp-amp-sep-flags-flags-amp-amp"><code>[since 6.0]</code>template &lt;typename Needle, typename Flags&gt; decltype((std::move(*this), std::forward<needle>(needle), flags…)) QString::tokenize(Needle &amp;&amp;<em>sep</em>, Flags… <em>flags</em>) &amp;&amp;</needle></span><a href="#since-6-0-template-lt-typename-needle-typename-flags-gt-decltype-qtokenize-std-move-this-std-forward-needle-flags-qstring-tokenize-needle-amp-amp-sep-flags-flags-amp-amp" class="header-anchor">#</a></h3><h3><span id="since-6-0-template-lt-typename-needle-typename-flags-gt-decltype-qtokenize-this-std-forward-needle-flags-qstring-tokenize-needle-amp-amp-sep-flags-flags-const-amp"><code>[since 6.0]</code>template &lt;typename Needle, typename Flags&gt; decltype((*this, std::forward<needle>(needle), flags…)) QString::tokenize(Needle &amp;&amp;<em>sep</em>, Flags… <em>flags</em>) const &amp;</needle></span><a href="#since-6-0-template-lt-typename-needle-typename-flags-gt-decltype-qtokenize-this-std-forward-needle-flags-qstring-tokenize-needle-amp-amp-sep-flags-flags-const-amp" class="header-anchor">#</a></h3><h3><span id="since-6-0-template-lt-typename-needle-typename-flags-gt-decltype-qtokenize-this-std-forward-needle-flags-qstring-tokenize-needle-amp-amp-sep-flags-flags-const-amp"><code>[since 6.0]</code>template &lt;typename Needle, typename Flags&gt; decltype((*this, std::forward<needle>(needle), flags…)) QString::tokenize(Needle &amp;&amp;<em>sep</em>, Flags… <em>flags</em>) const &amp;</needle></span><a href="#since-6-0-template-lt-typename-needle-typename-flags-gt-decltype-qtokenize-this-std-forward-needle-flags-qstring-tokenize-needle-amp-amp-sep-flags-flags-const-amp" class="header-anchor">#</a></h3><p>在出现 <em>sep</em> 的地方将字符串拆分为子字符串视图，并返回这些字符串的惰性序列。</p>
<p>相当于</p>
<div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">return</span> QStringTokenizer{std::forward&lt;Needle&gt;(sep), flags...};</code></pre></div>

<p>除非它在编译器中未启用 C++17 类模板参数推导 (CTAD) 的情况下工作。</p>
<p>请参阅 <a href="qstringtokenizer.html">QStringTokenizer</a> 了解 <em>sep</em> 和 <em>flags</em> 如何交互以形成结果。</p>
<p><strong>注意：</strong> 虽然此函数返回 <a href="qstringtokenizer.html">QStringTokenizer</a>，但您永远不应该明确命名它的模板参数。 如果您可以使用 C++17 类模板参数推导 (CTAD)，您可以编写</p>
<div class="code-wrapper"><pre><code class="hljs c++">QStringTokenizer result = sv.<span class="hljs-built_in">tokenize</span>(sep);</code></pre></div>

<p>（没有模板参数）。 如果不能使用 C++17 CTAD，则必须仅将返回值存储在 <code>auto</code> 变量中：</p>
<div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">auto</span> result = sv.<span class="hljs-built_in">tokenize</span>(sep);</code></pre></div>

<p>这是因为 <a href="qstringtokenizer.html">QStringTokenizer</a> 的模板参数对返回它们的特定 <a href="#tokenize">tokenize</a>() 重载具有非常微妙的依赖性，并且它们通常不对应于使用的类型 为分隔符。</p>
<p>该函数在 Qt 6.0 引入。</p>
<p><strong>See also</strong> <a href="qstringtokenizer.html">QStringTokenizer</a> and <a href="qstringtokenizer.html#qTokenize">qTokenize</a>().</p>
<h3><span id="since-5-14-template-qstring-qstring-arg-args-amp-amp-args-const"><code>[since 5.14]</code>template <typename args> <a href="#QString">QString</a> QString::arg(Args &amp;&amp;… <em>args</em>) const</typename></span><a href="#since-5-14-template-qstring-qstring-arg-args-amp-amp-args-const" class="header-anchor">#</a></h3><p>用来自 <em>args</em> 的相应参数替换此字符串中出现的 <code>%N</code>。 参数不是位置性的：<em>args</em> 中的第一个用最低的 <code>N</code>（全部）替换 <code>%N</code>，<em>args</em> 中的第二个用次低的 <code>N' 替换 </code>%N<code> </code>等</p>
<p><code>Args</code> 可以包含任何隐式转换为 <a href>QString</a>、<a href="qstringview.html">QStringView</a> 或 <a href="qlatin1string.html">QLatin1String</a> 的内容。</p>
<p>此外，还支持以下类型：<a href="qchar.html">QChar</a>、<a href="qlatin1char.html">QLatin1Char</a>。</p>
<p>该函数在 Qt 5.14 引入。</p>
<p><strong>See also</strong> <a href="#arg">QString::arg</a>().</p>
<h3><span id="qstring-qstring-const-qbytearray-amp-ba">QString::QString(const  &amp;<em>ba</em>)</span><a href="#qstring-qstring-const-qbytearray-amp-ba" class="header-anchor">#</a></h3><p>构造一个用字节数组 <em>ba</em> 初始化的字符串。 使用 <a href="#fromUtf8">fromUtf8</a>() 将给定的字节数组转换为 Unicode。 在第一个 0 字符处停止复制，否则复制整个字节数组。</p>
<p>您可以通过在编译应用程序时定义 <a href="#QT_NO_CAST_FROM_ASCII">QT_NO_CAST_FROM_ASCII</a> 来禁用此构造函数。 例如，如果您想确保所有用户可见的字符串都通过 <a href="qobject.html#tr">QObject::tr</a>()，这将很有用。</p>
<p><strong>See also</strong> <a href="#fromLatin1">fromLatin1</a>(), <a href="#fromLocal8Bit">fromLocal8Bit</a>(), and <a href="#fromUtf8">fromUtf8</a>().</p>
<h3><span id="qstring-qstring-const-char-str">QString::QString(const char *<em>str</em>)</span><a href="#qstring-qstring-const-char-str" class="header-anchor">#</a></h3><p>构造一个用 8 位字符串 <em>str</em> 初始化的字符串。 使用 <a href="#fromUtf8">fromUtf8</a>() 函数将给定的 const char 指针转换为 Unicode。</p>
<p>您可以通过在编译应用程序时定义 <a href="#QT_NO_CAST_FROM_ASCII">QT_NO_CAST_FROM_ASCII</a> 来禁用此构造函数。 例如，如果您想确保所有用户可见的字符串都通过 <a href="qobject.html#tr">QObject::tr</a>()，这将很有用。</p>
<p><strong>注意：</strong> 定义 <a href="#QT_RESTRICTED_CAST_FROM_ASCII">QT_RESTRICTED_CAST_FROM_ASCII</a> 也会禁用此构造函数，但会启用 <code>QString(const char (&amp;ch)[N])</code> 构造函数。 在这种情况下，未定义使用非文字输入、嵌入 NUL 字符或非 7 位字符的输入。</p>
<p><strong>See also</strong> <a href="#fromLatin1">fromLatin1</a>(), <a href="#fromLocal8Bit">fromLocal8Bit</a>(), and <a href="#fromUtf8">fromUtf8</a>().</p>
<h3><span id="since-5-2-qstring-qstring-qstring-amp-amp-other"><code>[since 5.2]</code>QString::QString( &amp;&amp;<em>other</em>)</span><a href="#since-5-2-qstring-qstring-qstring-amp-amp-other" class="header-anchor">#</a></h3><p>移动构造一个 QString 实例，使其指向 <em>other</em> 指向的同一个对象。</p>
<p>该函数在 Qt 5.2 引入。</p>
<h3><span id="qstring-qstring-const-qstring-amp-other">QString::QString(const  &amp;<em>other</em>)</span><a href="#qstring-qstring-const-qstring-amp-other" class="header-anchor">#</a></h3><p>构造 <em>other</em> 的副本。</p>
<p>这个操作需要<a href="containers.html#constant-time">常量时间</a>，因为QString是<a href="implicit-sharing.html">隐式共享</a>。 这使得从函数返回 QString 非常快。 如果共享实例被修改，它将被复制（写时复制），这需要<a href="containers.html#linear-time">线性时间</a>。</p>
<p><strong>See also</strong> <a href="#operator-eq">operator=</a>().</p>
<h3><span id="since-6-1-template-qstring-qstring-const-char8-t-str"><code>[since 6.1]</code>template <typename> QString::QString(const char8_t *<em>str</em>)</typename></span><a href="#since-6-1-template-qstring-qstring-const-char8-t-str" class="header-anchor">#</a></h3><p>构造一个用 UTF-8 字符串 <em>str</em> 初始化的字符串。 使用 <a href="#fromUtf8">fromUtf8</a>() 函数将给定的 const char8_t 指针转换为 Unicode。</p>
<p>该函数在 Qt 6.1 引入。</p>
<p><strong>See also</strong> <a href="#fromLatin1">fromLatin1</a>(), <a href="#fromLocal8Bit">fromLocal8Bit</a>(), and <a href="#fromUtf8">fromUtf8</a>().</p>
<h3><span id="qstring-qstring-qlatin1string-str">QString::QString( <em>str</em>)</span><a href="#qstring-qstring-qlatin1string-str" class="header-anchor">#</a></h3><p>构造 Latin-1 字符串 <em>str</em> 的副本。</p>
<p><strong>See also</strong> <a href="#fromLatin1">fromLatin1</a>().</p>
<h3><span id="qstring-qstring-qsizetype-size-qchar-ch">QString::QString(qsizetype <em>size</em>,  <em>ch</em>)</span><a href="#qstring-qstring-qsizetype-size-qchar-ch" class="header-anchor">#</a></h3><p>构造一个给定 <em>size</em> 的字符串，每个字符都设置为 <em>ch</em>。</p>
<p><strong>See also</strong> <a href="#fill">fill</a>().</p>
<h3><span id="qstring-qstring-qchar-ch">QString::QString( <em>ch</em>)</span><a href="#qstring-qstring-qchar-ch" class="header-anchor">#</a></h3><p>Constructs a string of size 1 containing the character <em>ch</em>.</p>
<h3><span id="qstring-qstring-const-qchar-unicode-qsizetype-size-1">QString::QString(const  *<em>unicode</em>, qsizetype <em>size</em> = -1)</span><a href="#qstring-qstring-const-qchar-unicode-qsizetype-size-1" class="header-anchor">#</a></h3><p>构造一个用 <a href="qchar.html">QChar</a> 数组 <em>unicode</em> 的前 <em>size</em> 个字符初始化的字符串。</p>
<p>如果 <em>unicode</em> 为 0，则构造一个空字符串。</p>
<p>如果<em>size</em> 为负数，则假定<em>unicode</em> 指向一个以\0’ 结尾的数组，并且它的长度是动态确定的。 终止的空字符不被视为字符串的一部分。</p>
<p>QString 对字符串数据进行深拷贝。 unicode 数据按原样复制，如果存在，则保留字节顺序标记。</p>
<p><strong>See also</strong> <a href="#fromRawData">fromRawData</a>().</p>
<h3><span id="qstring-qstring">QString::QString()</span><a href="#qstring-qstring" class="header-anchor">#</a></h3><p>构造一个空字符串。 空字符串也是空的。</p>
<p><strong>See also</strong> <a href="#isEmpty">isEmpty</a>().</p>
<h3><span id="qstring-amp-qstring-operator-const-qbytearray-amp-ba"> &amp;QString::operator=(const  &amp;<em>ba</em>)</span><a href="#qstring-amp-qstring-operator-const-qbytearray-amp-ba" class="header-anchor">#</a></h3><p>这个函数重载了 operator=().</p>
<p>将 <em>ba</em> 分配给此字符串。 使用 <a href="#fromUtf8">fromUtf8</a>() 函数将字节数组转换为 Unicode。 此函数在找到的第一个 NUL 字符或 <em>ba</em> 字节数组的结尾处停止转换。</p>
<p>您可以通过在编译应用程序时定义 <a href="#QT_NO_CAST_FROM_ASCII">QT_NO_CAST_FROM_ASCII</a> 来禁用此运算符。 例如，如果您想确保所有用户可见的字符串都通过 <a href="qobject.html#tr">QObject::tr</a>()，这将很有用。</p>
<h3><span id="since-5-2-qstring-amp-qstring-operator-qstring-amp-amp-other"><code>[since 5.2]</code> &amp;QString::operator=( &amp;&amp;<em>other</em>)</span><a href="#since-5-2-qstring-amp-qstring-operator-qstring-amp-amp-other" class="header-anchor">#</a></h3><p>将 <em>other</em> 移动分配给这个 <a href>QString</a> 实例。</p>
<p>该函数在 Qt 5.2 引入。</p>
<h3><span id="qstring-amp-qstring-operator-const-qstring-amp-other"> &amp;QString::operator=(const  &amp;<em>other</em>)</span><a href="#qstring-amp-qstring-operator-const-qstring-amp-other" class="header-anchor">#</a></h3><p>将 <em>other</em> 分配给该字符串并返回对该字符串的引用。</p>
<h3><span id="qstring-qstring">QString::~QString()</span><a href="#qstring-qstring" class="header-anchor">#</a></h3><p>销毁字符串。</p>
<h3><span id="qstring-amp-qstring-append-const-qstring-amp-str"> &amp;QString::append(const  &amp;<em>str</em>)</span><a href="#qstring-amp-qstring-append-const-qstring-amp-str" class="header-anchor">#</a></h3><p>将字符串 <em>str</em> 附加到此字符串的末尾。</p>
<p>例子:</p>
<div class="code-wrapper"><pre><code class="hljs c++">QString x = <span class="hljs-string">"free"</span>;
QString y = <span class="hljs-string">"dom"</span>;

x.<span class="hljs-built_in">append</span>(y);
<span class="hljs-comment">// x == "freedom"</span></code></pre></div>

<p>这与使用 <a href="#insert">insert</a>() 函数相同：</p>
<div class="code-wrapper"><pre><code class="hljs c++">x.<span class="hljs-built_in">insert</span>(x.<span class="hljs-built_in">size</span>(), y);</code></pre></div>

<p>append() 函数通常非常快（<a href="containers.html#constant-time">constant time</a>），因为 <a href>QString</a> 在字符串数据的末尾预先分配了额外的空间，因此它可以在不重新分配整个字符串的情况下增长 每一次。</p>
<p><strong>See also</strong> <a href="#operator-2b-eq">operator+=</a>(), <a href="#prepend">prepend</a>(), and <a href="#insert">insert</a>().</p>
<h3><span id="qstring-amp-qstring-append-qchar-ch"> &amp;QString::append( <em>ch</em>)</span><a href="#qstring-amp-qstring-append-qchar-ch" class="header-anchor">#</a></h3><p>这个函数重载了 append()。</p>
<p>将字符 <em>ch</em> 附加到此字符串。</p>
<h3><span id="since-5-0-qstring-amp-qstring-append-const-qchar-str-qsizetype-len"><code>[since 5.0]</code> &amp;QString::append(const  *<em>str</em>, qsizetype <em>len</em>)</span><a href="#since-5-0-qstring-amp-qstring-append-const-qchar-str-qsizetype-len" class="header-anchor">#</a></h3><p>这个函数重载了 append()。</p>
<p>将 <a href="qchar.html">QChar</a> 数组 <em>str</em> 中的 <em>len</em> 个字符附加到此字符串。</p>
<p>该函数在 Qt 5.0 引入。</p>
<h3><span id="qstring-amp-qstring-append-qlatin1string-str"> &amp;QString::append( <em>str</em>)</span><a href="#qstring-amp-qstring-append-qlatin1string-str" class="header-anchor">#</a></h3><p>这个函数重载了 append()。</p>
<p>将 Latin-1 字符串 <em>str</em> 附加到此字符串。</p>
<h3><span id="qstring-amp-qstring-append-const-char-str"> &amp;QString::append(const char *<em>str</em>)</span><a href="#qstring-amp-qstring-append-const-char-str" class="header-anchor">#</a></h3><p>这个函数重载了 append()。</p>
<p>将字符串 <em>str</em> 附加到此字符串。 使用 <a href="#fromUtf8">fromUtf8</a>() 函数将给定的 const char 指针转换为 Unicode。</p>
<p>您可以通过在编译应用程序时定义 <a href="#QT_NO_CAST_FROM_ASCII">QT_NO_CAST_FROM_ASCII</a> 来禁用此功能。 例如，如果您想确保所有用户可见的字符串都通过 <a href="qobject.html#tr">QObject::tr</a>()，这将很有用。</p>
<h3><span id="qstring-amp-qstring-append-const-qbytearray-amp-ba"> &amp;QString::append(const  &amp;<em>ba</em>)</span><a href="#qstring-amp-qstring-append-const-qbytearray-amp-ba" class="header-anchor">#</a></h3><p>这个函数重载了 append()。</p>
<p>将字节数组 <em>ba</em> 附加到此字符串。 使用 <a href="#fromUtf8">fromUtf8</a>() 函数将给定的字节数组转换为 Unicode。</p>
<p>您可以通过在编译应用程序时定义 <a href="#QT_NO_CAST_FROM_ASCII">QT_NO_CAST_FROM_ASCII</a> 来禁用此功能。 例如，如果您想确保所有用户可见的字符串都通过 <a href="qobject.html#tr">QObject::tr</a>()，这将很有用。</p>
<h3><span id="qstring-qstring-arg-const-qstring-amp-a-int-fieldwidth-0-qchar-fillchar-qlatin1char-const"> QString::arg(const  &amp;<em>a</em>, int <em>fieldWidth</em> = 0,  <em>fillChar</em> = QLatin1Char(‘ ‘)) const</span><a href="#qstring-qstring-arg-const-qstring-amp-a-int-fieldwidth-0-qchar-fillchar-qlatin1char-const" class="header-anchor">#</a></h3><p>返回此字符串的副本，其中编号最小的位置标记替换为字符串 <em>a</em>，即 <code>%1</code>、<code>%2</code>、…、<code>%99</code>。</p>
<p><em>fieldWidth</em> 指定参数 <em>a</em> 应占用的最小空间量。 如果 <em>a</em> 需要的空间小于 <em>fieldWidth</em>，则使用字符 <em>fillChar</em> 将其填充到 <em>fieldWidth</em>。 正的 <em>fieldWidth</em> 会产生右对齐的文本。 负的 <em>fieldWidth</em> 产生左对齐的文本。</p>
<p>这个例子展示了我们如何在处理文件列表时创建一个 <code>status</code> 字符串来报告进度：</p>
<div class="code-wrapper"><pre><code class="hljs c++">QString i;           <span class="hljs-comment">// current file's number</span>
QString total;       <span class="hljs-comment">// number of files to process</span>
QString fileName;    <span class="hljs-comment">// current file's name</span>

QString status = <span class="hljs-built_in">QString</span>(<span class="hljs-string">"Processing file %1 of %2: %3"</span>)
                .<span class="hljs-built_in">arg</span>(i).<span class="hljs-built_in">arg</span>(total).<span class="hljs-built_in">arg</span>(fileName);</code></pre></div>

<p>首先，<code>arg(i)</code> 替换了 <code>%1</code>。 然后 <code>arg(total)</code> 替换 <code>%2</code>。 最后，<code>arg(fileName)</code> 替换了 <code>%3</code>。</p>
<p>使用 arg() 优于 <a href="#asprintf">asprintf</a>() 的一个优点是，如果应用程序的字符串被翻译成其他语言，编号位置标记的顺序可以改变，但每个 arg() 仍将替换编号最小的 未替换的地点标记，无论它出现在哪里。 此外，如果位置标记 <code>%i</code> 在字符串中出现多次，则 arg() 会替换所有这些。</p>
<p>如果没有剩余的未替换位置标记，则输出警告消息并且结果未定义。 位置标记编号必须在 1 到 99 的范围内。</p>
<h3><span id="qstring-qstring-arg-qlonglong-a-int-fieldwidth-0-int-base-10-qchar-fillchar-qlatin1char-const"> QString::arg( <em>a</em>, int <em>fieldWidth</em> = 0, int <em>base</em> = 10,  <em>fillChar</em> = QLatin1Char(‘ ‘)) const</span><a href="#qstring-qstring-arg-qlonglong-a-int-fieldwidth-0-int-base-10-qchar-fillchar-qlatin1char-const" class="header-anchor">#</a></h3><p>此函数重载 arg()。</p>
<p><em>fieldWidth</em> 指定填充 <em>a</em> 并用字符 <em>fillChar</em> 填充的最小空间量。 正值生成右对齐文本； 负值产生左对齐的文本。</p>
<p><em>base</em> 参数指定将整数 <em>a</em> 转换为字符串时使用的基数。 基数必须介于 2 和 36 之间，其中 8 表示八进制数、10 位十进制数和 16 位十六进制数。</p>
<p><strong>See also</strong> <a href="#number-formats">Number Formats</a>.</p>
<h3><span id="qstring-qstring-arg-qulonglong-a-int-fieldwidth-0-int-base-10-qchar-fillchar-qlatin1char-const"> QString::arg( <em>a</em>, int <em>fieldWidth</em> = 0, int <em>base</em> = 10,  <em>fillChar</em> = QLatin1Char(‘ ‘)) const</span><a href="#qstring-qstring-arg-qulonglong-a-int-fieldwidth-0-int-base-10-qchar-fillchar-qlatin1char-const" class="header-anchor">#</a></h3><p>此函数重载 arg()。</p>
<p><em>fieldWidth</em> 指定填充 <em>a</em> 并用字符 <em>fillChar</em> 填充的最小空间量。 正值生成右对齐文本； 负值产生左对齐的文本。</p>
<p><em>base</em> 参数指定将整数 <em>a</em> 转换为字符串时使用的基数。 <em>base</em> 必须介于 2 和 36 之间，其中 8 表示八进制数、10 位十进制数和 16 位十六进制数。</p>
<p><strong>See also</strong> <a href="#number-formats">Number Formats</a>.</p>
<h3><span id="qstring-qstring-arg-long-a-int-fieldwidth-0-int-base-10-qchar-fillchar-qlatin1char-const"> QString::arg(long <em>a</em>, int <em>fieldWidth</em> = 0, int <em>base</em> = 10,  <em>fillChar</em> = QLatin1Char(‘ ‘)) const</span><a href="#qstring-qstring-arg-long-a-int-fieldwidth-0-int-base-10-qchar-fillchar-qlatin1char-const" class="header-anchor">#</a></h3><p>此函数重载 arg()。</p>
<p><em>fieldWidth</em> 指定填充 <em>a</em> 并用字符 <em>fillChar</em> 填充的最小空间量。 正值生成右对齐文本； 负值产生左对齐的文本。</p>
<p><em>a</em> 参数以给定的 <em>base</em> 表示，默认为 10，必须介于 2 和 36 之间。</p>
<p>‘%’ 后面可以跟一个 ‘L’，在这种情况下，序列被替换为 <em>a</em> 的本地化表示。 转换使用默认语言环境。 默认语言环境由应用程序启动时系统的语言环境设置确定。 它可以使用 <a href="qlocale.html#setDefault">QLocale::setDefault</a>() 进行更改。 如果 <em>base</em> 不是 10，则忽略“L”标志。</p>
<div class="code-wrapper"><pre><code class="hljs c++">QString str;
str = <span class="hljs-built_in">QString</span>(<span class="hljs-string">"Decimal 63 is %1 in hexadecimal"</span>)
    .<span class="hljs-built_in">arg</span>(<span class="hljs-number">63</span>, <span class="hljs-number">0</span>, <span class="hljs-number">16</span>);
<span class="hljs-comment">// str == "Decimal 63 is 3f in hexadecimal"</span>

QLocale::<span class="hljs-built_in">setDefault</span>(<span class="hljs-built_in">QLocale</span>(QLocale::English, QLocale::UnitedStates));
str = <span class="hljs-built_in">QString</span>(<span class="hljs-string">"%1 %L2 %L3"</span>)
    .<span class="hljs-built_in">arg</span>(<span class="hljs-number">12345</span>)
    .<span class="hljs-built_in">arg</span>(<span class="hljs-number">12345</span>)
    .<span class="hljs-built_in">arg</span>(<span class="hljs-number">12345</span>, <span class="hljs-number">0</span>, <span class="hljs-number">16</span>);
<span class="hljs-comment">// str == "12345 12,345 3039"</span></code></pre></div>

<p><strong>See also</strong> <a href="#number-formats">Number Formats</a>.</p>
<h3><span id="qstring-qstring-arg-ulong-a-int-fieldwidth-0-int-base-10-qchar-fillchar-qlatin1char-const"> QString::arg( <em>a</em>, int <em>fieldWidth</em> = 0, int <em>base</em> = 10,  <em>fillChar</em> = QLatin1Char(‘ ‘)) const</span><a href="#qstring-qstring-arg-ulong-a-int-fieldwidth-0-int-base-10-qchar-fillchar-qlatin1char-const" class="header-anchor">#</a></h3><p>此函数重载 arg()。</p>
<p><em>fieldWidth</em> 指定填充 <em>a</em> 并用字符 <em>fillChar</em> 填充的最小空间量。 正值生成右对齐文本； 负值产生左对齐的文本。</p>
<p><em>base</em> 参数指定将整数 <em>a</em> 转换为字符串时使用的基数。 基数必须介于 2 和 36 之间，其中 8 表示八进制数、10 位十进制数和 16 位十六进制数。</p>
<p><strong>See also</strong> <a href="#number-formats">Number Formats</a>.</p>
<h3><span id="qstring-qstring-arg-int-a-int-fieldwidth-0-int-base-10-qchar-fillchar-qlatin1char-const"> QString::arg(int <em>a</em>, int <em>fieldWidth</em> = 0, int <em>base</em> = 10,  <em>fillChar</em> = QLatin1Char(‘ ‘)) const</span><a href="#qstring-qstring-arg-int-a-int-fieldwidth-0-int-base-10-qchar-fillchar-qlatin1char-const" class="header-anchor">#</a></h3><p>此函数重载 arg()。</p>
<p><em>a</em> 参数以基数 <em>base</em> 表示，默认为 10，必须介于 2 和 36 之间。对于 10 以外的基数，<em>a</em> 被视为无符号整数。</p>
<p><em>fieldWidth</em> 指定填充 <em>a</em> 并用字符 <em>fillChar</em> 填充的最小空间量。 正值生成右对齐文本； 负值产生左对齐的文本。</p>
<p>‘%’ 后面可以跟一个 ‘L’，在这种情况下，序列被替换为 <em>a</em> 的本地化表示。 转换使用由 <a href="qlocale.html#setDefault">QLocale::setDefault</a>() 设置的默认语言环境。 如果未指定默认语言环境，则使用系统语言环境。 如果 <em>base</em> 不是 10，则忽略”L”标志。</p>
<div class="code-wrapper"><pre><code class="hljs c++">QString str;;
str = <span class="hljs-built_in">QString</span>(<span class="hljs-string">"Decimal 63 is %1 in hexadecimal"</span>)
    .<span class="hljs-built_in">arg</span>((<span class="hljs-number">63</span>, <span class="hljs-number">0</span>, <span class="hljs-number">16</span>);
         <span class="hljs-comment">// str == "Decimal 63 is 3f in hexadecimal"</span>
         QLocale::<span class="hljs-built_in">setDefault</span>((<span class="hljs-built_in">QLocale</span>(QLocale::English, QLocale::UnitedStates));));
str = <span class="hljs-built_in">QString</span>(<span class="hljs-string">"%1 %L2 %L3"</span>)
    .<span class="hljs-built_in">arg</span>(<span class="hljs-number">12345</span>)
    .<span class="hljs-built_in">arg</span>(<span class="hljs-number">12345</span>)
    .<span class="hljs-built_in">arg</span>(<span class="hljs-number">12345</span>, <span class="hljs-number">0</span>, <span class="hljs-number">16</span>);
<span class="hljs-comment">// str == "12345 12,345 3039"</span></code></pre></div>

<p><strong>See also</strong> <a href="#number-formats">Number Formats</a>.</p>
<h3><span id="qstring-qstring-arg-uint-a-int-fieldwidth-0-int-base-10-qchar-fillchar-qlatin1char-const"> QString::arg( <em>a</em>, int <em>fieldWidth</em> = 0, int <em>base</em> = 10,  <em>fillChar</em> = QLatin1Char(‘ ‘)) const</span><a href="#qstring-qstring-arg-uint-a-int-fieldwidth-0-int-base-10-qchar-fillchar-qlatin1char-const" class="header-anchor">#</a></h3><p>此函数重载 arg()。</p>
<p><em>base</em> 参数指定将整数 <em>a</em> 转换为字符串时使用的基数。 基数必须在 2 到 36 之间。</p>
<p><strong>See also</strong> <a href="#number-formats">Number Formats</a>.</p>
<h3><span id="qstring-qstring-arg-short-a-int-fieldwidth-0-int-base-10-qchar-fillchar-qlatin1char-const"> QString::arg(short <em>a</em>, int <em>fieldWidth</em> = 0, int <em>base</em> = 10,  <em>fillChar</em> = QLatin1Char(‘ ‘)) const</span><a href="#qstring-qstring-arg-short-a-int-fieldwidth-0-int-base-10-qchar-fillchar-qlatin1char-const" class="header-anchor">#</a></h3><p>此函数重载 arg()。</p>
<p><em>fieldWidth</em> 指定填充 <em>a</em> 并用字符 <em>fillChar</em> 填充的最小空间量。 正值生成右对齐文本； 负值产生左对齐的文本。</p>
<p><em>base</em> 参数指定将整数 <em>a</em> 转换为字符串时使用的基数。 基数必须介于 2 和 36 之间，其中 8 表示八进制数、10 位十进制数和 16 位十六进制数。</p>
<p><strong>See also</strong> <a href="#number-formats">Number Formats</a>.</p>
<h3><span id="qstring-qstring-arg-ushort-a-int-fieldwidth-0-int-base-10-qchar-fillchar-qlatin1char-const"> QString::arg( <em>a</em>, int <em>fieldWidth</em> = 0, int <em>base</em> = 10,  <em>fillChar</em> = QLatin1Char(‘ ‘)) const</span><a href="#qstring-qstring-arg-ushort-a-int-fieldwidth-0-int-base-10-qchar-fillchar-qlatin1char-const" class="header-anchor">#</a></h3><p>此函数重载 arg()。</p>
<p><em>fieldWidth</em> 指定填充 <em>a</em> 并用字符 <em>fillChar</em> 填充的最小空间量。 正值生成右对齐文本； 负值产生左对齐的文本。</p>
<p><em>base</em> 参数指定将整数 <em>a</em> 转换为字符串时使用的基数。 基数必须介于 2 和 36 之间，其中 8 表示八进制数、10 位十进制数和 16 位十六进制数。</p>
<p><strong>See also</strong> <a href="#number-formats">Number Formats</a>.</p>
<h3><span id="qstring-qstring-arg-double-a-int-fieldwidth-0-char-format-g-int-precision-1-qchar-fillchar-qlatin1char-const"> QString::arg(double <em>a</em>, int <em>fieldWidth</em> = 0, char <em>format</em> = ‘g’, int <em>precision</em> = -1,  <em>fillChar</em> = QLatin1Char(‘ ‘)) const</span><a href="#qstring-qstring-arg-double-a-int-fieldwidth-0-char-format-g-int-precision-1-qchar-fillchar-qlatin1char-const" class="header-anchor">#</a></h3><p>此函数重载 arg()。</p>
<p>参数 <em>a</em> 根据指定的 <em>format</em> 和 <em>precision</em> 进行格式化。 有关详细信息，请参阅 <a href="#floating-point-formats">浮点格式</a>。</p>
<p><em>fieldWidth</em> 指定填充 <em>a</em> 并用字符 <em>fillChar</em> 填充的最小空间量。 正值生成右对齐文本； 负值产生左对齐的文本。</p>
<div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-type">double</span> d = <span class="hljs-number">12.34</span>;
QString str = <span class="hljs-built_in">QString</span>(<span class="hljs-string">"delta: %1"</span>).<span class="hljs-built_in">arg</span>(d, <span class="hljs-number">0</span>, <span class="hljs-string">'E'</span>, <span class="hljs-number">3</span>);
<span class="hljs-comment">// str == "delta: 1.234E+01"</span></code></pre></div>

<p><strong>See also</strong> <a href="qlocale.html#toString">QLocale::toString</a>(), <a href="qlocale.html#FloatingPointPrecisionOption-enum">QLocale::FloatingPointPrecisionOption</a>, and <a href="#number-formats">Number Formats</a>.</p>
<h3><span id="qstring-qstring-arg-char-a-int-fieldwidth-0-qchar-fillchar-qlatin1char-const"> QString::arg(char <em>a</em>, int <em>fieldWidth</em> = 0,  <em>fillChar</em> = QLatin1Char(‘ ‘)) const</span><a href="#qstring-qstring-arg-char-a-int-fieldwidth-0-qchar-fillchar-qlatin1char-const" class="header-anchor">#</a></h3><p>此函数重载 arg()。</p>
<p><em>a</em> 参数被解释为 Latin-1 字符。</p>
<h3><span id="qstring-qstring-arg-qchar-a-int-fieldwidth-0-qchar-fillchar-qlatin1char-const"> QString::arg( <em>a</em>, int <em>fieldWidth</em> = 0,  <em>fillChar</em> = QLatin1Char(‘ ‘)) const</span><a href="#qstring-qstring-arg-qchar-a-int-fieldwidth-0-qchar-fillchar-qlatin1char-const" class="header-anchor">#</a></h3><p>此函数重载 arg()。</p>
<h3><span id="since-5-10-qstring-qstring-arg-qstringview-a-int-fieldwidth-0-qchar-fillchar-qlatin1char-const"><code>[since 5.10]</code> QString::arg( <em>a</em>, int <em>fieldWidth</em> = 0,  <em>fillChar</em> = QLatin1Char(‘ ‘)) const</span><a href="#since-5-10-qstring-qstring-arg-qstringview-a-int-fieldwidth-0-qchar-fillchar-qlatin1char-const" class="header-anchor">#</a></h3><p>这是一个重载函数。</p>
<p>返回此字符串的副本，其中编号最小的位置标记替换为字符串 <em>a</em>，即 <code>%1</code>、<code>%2</code>、…、<code>%99</code>。</p>
<p><em>fieldWidth</em> 指定 <em>a</em> 应占用的最小空间量。 如果 <em>a</em> 需要的空间小于 <em>fieldWidth</em>，则使用字符 <em>fillChar</em> 将其填充到 <em>fieldWidth</em>。 正的 <em>fieldWidth</em> 会产生右对齐的文本。 负的 <em>fieldWidth</em> 产生左对齐的文本。</p>
<p>这个例子展示了我们如何在处理文件列表时创建一个 <code>status</code> 字符串来报告进度：</p>
<div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-type">int</span> i;                <span class="hljs-comment">// current file's number</span>
<span class="hljs-type">int</span> total;            <span class="hljs-comment">// number of files to process</span>
QStringView fileName; <span class="hljs-comment">// current file's name</span>

QString status = <span class="hljs-built_in">QString</span>(<span class="hljs-string">"Processing file %1 of %2: %3"</span>)
                .<span class="hljs-built_in">arg</span>(i).<span class="hljs-built_in">arg</span>(total).<span class="hljs-built_in">arg</span>(fileName);</code></pre></div>

<p>首先，<code>arg(i)</code> 替换了 <code>%1</code>。 然后 <code>arg(total)</code> 替换 <code>%2</code>。 最后，<code>arg(fileName)</code> 替换了 <code>%3</code>。</p>
<p>使用 arg() 而不是 <a href="#asprintf">asprintf</a>() 的一个优点是，如果应用程序的字符串被翻译成其他语言，编号位置标记的顺序可以改变，但每个 arg() 仍将替换最低的 - 编号未替换的位置标记，无论它出现在哪里。 此外，如果位置标记 <code>%i</code> 在字符串中出现多次，则 arg() 会替换所有这些。</p>
<p>如果没有剩余的未替换的位置标记，则会打印一条警告消息并且结果是未定义的。 地标编号必须在 1 到 99 的范围内。</p>
<p>该函数在 Qt 5.10 引入。</p>
<h3><span id="since-5-10-qstring-qstring-arg-qlatin1string-a-int-fieldwidth-0-qchar-fillchar-qlatin1char-const"><code>[since 5.10]</code> QString::arg( <em>a</em>, int <em>fieldWidth</em> = 0,  <em>fillChar</em> = QLatin1Char(‘ ‘)) const</span><a href="#since-5-10-qstring-qstring-arg-qlatin1string-a-int-fieldwidth-0-qchar-fillchar-qlatin1char-const" class="header-anchor">#</a></h3><p>这是一个重载函数。</p>
<p>返回此字符串的副本，其中编号最小的位置标记替换为字符串 <em>a</em>，即 <code>%1</code>、<code>%2</code>、…、<code>%99</code>。</p>
<p><em>fieldWidth</em> 指定 <em>a</em> 应占用的最小空间量。 如果 <em>a</em> 需要的空间小于 <em>fieldWidth</em>，则使用字符 <em>fillChar</em> 将其填充到 <em>fieldWidth</em>。 正的 <em>fieldWidth</em> 会产生右对齐的文本。 负的 <em>fieldWidth</em> 产生左对齐的文本。</p>
<p>使用 arg() 而不是 <a href="#asprintf">asprintf</a>() 的一个优点是，如果应用程序的字符串被翻译成其他语言，编号位置标记的顺序可以改变，但每个 arg() 仍将替换最低的 - 编号未替换的位置标记，无论它出现在哪里。 此外，如果位置标记 <code>%i</code> 在字符串中出现多次，则 arg() 会替换所有这些。</p>
<p>如果没有剩余的未替换的位置标记，则会打印一条警告消息并且结果是未定义的。 地标编号必须在 1 到 99 的范围内。</p>
<p>该函数在 Qt 5.10 引入。</p>
<h3><span id="static-since-5-5-qstring-qstring-asprintf-const-char-cformat"><code>[static, since 5.5]</code> QString::asprintf(const char *<em>cformat</em>, …)</span><a href="#static-since-5-5-qstring-qstring-asprintf-const-char-cformat" class="header-anchor">#</a></h3><p>从格式字符串 <em>cformat</em> 和任意参数列表安全地构建格式化字符串。</p>
<p>格式字符串支持标准 C++ 库中 printf() 提供的转换说明符、长度修饰符和标志。 <em>cformat</em> 字符串和 <code>%s</code> 参数必须是 UTF-8 编码的。</p>
<p><strong>注意：</strong> <code>%lc</code> 转义序列需要 <code>char16_t</code> 或 <code>ushort</code> 类型的 unicode 字符（由 <a href="qchar.html#unicode">QChar::unicode</a>() 返回）。 <code>%ls</code> 转义序列需要一个指向 <code>char16_t</code> 或 ushort 类型的以零结尾的 unicode 字符数组的指针（由 <a href="#utf16">QString::utf16</a>() 返回）。这与标准 C++ 库中的 printf() 不一致，标准 C++ 库定义了 <code>%lc</code> 来打印 wchar_t 和 <code>%ls</code> 来打印 <code>wchar_t*</code>，并且还可能在大小为<code>wchar_t</code> 不是 16 位。</p>
<p><strong>警告：</strong> 我们不建议在新的 Qt 代码中使用 QString::asprintf()。相反，请考虑使用 <a href="qtextstream.html">QTextStream</a> 或 <a href="#arg">arg</a>()，它们都无缝支持 Unicode 字符串并且是类型安全的。这是一个使用 <a href="qtextstream.html">QTextStream</a> 的示例：</p>
<div class="code-wrapper"><pre><code class="hljs c++">QString result;
<span class="hljs-built_in">QTextStream</span>(&amp;result) &lt;&lt; <span class="hljs-string">"pi = "</span> &lt;&lt; <span class="hljs-number">3.14</span>;
<span class="hljs-comment">// result == "pi = 3.14"</span></code></pre></div>

<p>对于 <a href="qobject.html#tr">translations</a>，特别是如果字符串包含多个转义序列，您应该考虑改用 <a href="#arg">arg</a>() 函数。 这允许由翻译器控制替换的顺序。</p>
<p>该函数在 Qt 5.5 引入。</p>
<p><strong>See also</strong> <a href="#arg">arg</a>().</p>
<h3><span id="const-qchar-qstring-at-qsizetype-position-const">const  QString::at(qsizetype <em>position</em>) const</span><a href="#const-qchar-qstring-at-qsizetype-position-const" class="header-anchor">#</a></h3><p>返回字符串中给定索引 <em>position</em> 处的字符。</p>
<p><em>position</em> 必须是字符串中的有效索引位置（即 0 &lt;= <em>position</em> &lt; <a href="#size">size</a>()）。</p>
<p><strong>See also</strong> [operator<a href="#operator-5b-5d">]</a>().</p>
<h3><span id="since-5-10-qchar-qstring-back-const"><code>[since 5.10]</code> QString::back() const</span><a href="#since-5-10-qchar-qstring-back-const" class="header-anchor">#</a></h3><p>返回字符串中的最后一个字符。 与 <code>at(size() - 1)</code> 相同。</p>
<p>提供此功能是为了与 STL 兼容。</p>
<p><strong>警告：</strong> 对空字符串调用此函数构成未定义的行为。</p>
<p>该函数在 Qt 5.10 引入。</p>
<p><strong>See also</strong> <a href="#front">front</a>(), <a href="#at">at</a>(), and [operator<a href="#operator-5b-5d">]</a>().</p>
<h3><span id="since-5-10-qchar-amp-qstring-back"><code>[since 5.10]</code> &amp;QString::back()</span><a href="#since-5-10-qchar-amp-qstring-back" class="header-anchor">#</a></h3><p>返回对字符串中最后一个字符的引用。 与 <code>operator[](size() - 1)</code> 相同。</p>
<p>提供此功能是为了与 STL 兼容。</p>
<p><strong>警告：</strong> 对空字符串调用此函数构成未定义的行为。</p>
<p>该函数在 Qt 5.10 引入。</p>
<p><strong>See also</strong> <a href="#front">front</a>(), <a href="#at">at</a>(), and [operator<a href="#operator-5b-5d">]</a>().</p>
<h3><span id="qstring-iterator-qstring-begin"> QString::begin()</span><a href="#qstring-iterator-qstring-begin" class="header-anchor">#</a></h3><p>返回指向字符串中第一个字符的 <a href="containers.html#stl-style-iterators">STL 样式迭代器</a>。</p>
<p><strong>警告：</strong>返回的迭代器在分离或修改 <a href>QString</a> 时无效。</p>
<p><strong>See also</strong> <a href="#constBegin">constBegin</a>() and <a href="#end">end</a>().</p>
<h3><span id="qstring-const-iterator-qstring-begin-const"> QString::begin() const</span><a href="#qstring-const-iterator-qstring-begin-const" class="header-anchor">#</a></h3><p>此函数重载 begin()。</p>
<h3><span id="qsizetype-qstring-capacity-const">qsizetype QString::capacity() const</span><a href="#qsizetype-qstring-capacity-const" class="header-anchor">#</a></h3><p>返回在不强制重新分配的情况下可以存储在字符串中的最大字符数。</p>
<p>此函数的唯一目的是提供一种微调 <a href>QString</a> 内存使用的方法。 通常，您很少需要调用此函数。 如果您想知道字符串中有多少个字符，请调用 <a href="#size">size</a>()。</p>
<p><strong>注意：</strong> 静态分配的字符串将报告容量为 0，即使它不为空。</p>
<p><strong>注意：</strong> 分配的内存块中的可用空间位置未定义。 换句话说，不应该假设空闲内存总是位于初始化元素之后。</p>
<p><strong>See also</strong> <a href="#reserve">reserve</a>() and <a href="#squeeze">squeeze</a>().</p>
<h3><span id="since-5-0-qstring-const-iterator-qstring-cbegin-const"><code>[since 5.0]</code> QString::cbegin() const</span><a href="#since-5-0-qstring-const-iterator-qstring-cbegin-const" class="header-anchor">#</a></h3><p>返回指向字符串中第一个字符的 const <a href="containers.html#stl-style-iterators">STL 样式迭代器</a>。</p>
<p><strong>警告：</strong>返回的迭代器在分离或修改 <a href>QString</a> 时无效。</p>
<p>该函数在 Qt 5.0 引入。</p>
<p><strong>See also</strong> <a href="#begin">begin</a>() and <a href="#cend">cend</a>().</p>
<h3><span id="since-5-0-qstring-const-iterator-qstring-cend-const"><code>[since 5.0]</code> QString::cend() const</span><a href="#since-5-0-qstring-const-iterator-qstring-cend-const" class="header-anchor">#</a></h3><p>返回一个 const <a href="containers.html#stl-style-iterators">STL-style iterator</a> 指向字符串中最后一个字符之后。</p>
<p><strong>警告：</strong>返回的迭代器在分离或修改 <a href>QString</a> 时无效。</p>
<p>该函数在 Qt 5.0 引入。</p>
<p><strong>See also</strong> <a href="#cbegin">cbegin</a>() and <a href="#end">end</a>().</p>
<h3><span id="void-qstring-chop-qsizetype-n">void QString::chop(qsizetype <em>n</em>)</span><a href="#void-qstring-chop-qsizetype-n" class="header-anchor">#</a></h3><p>从字符串末尾删除 <em>n</em> 个字符。</p>
<p>如果 <em>n</em> 大于或等于 <a href="#size">size</a>()，则结果为空字符串； 如果 <em>n</em> 为负数，则相当于传递零。</p>
<p>例子:</p>
<div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-function">QString <span class="hljs-title">str</span><span class="hljs-params">(<span class="hljs-string">"LOGOUT\r\n"</span>)</span></span>;
str.<span class="hljs-built_in">chop</span>(<span class="hljs-number">2</span>);
<span class="hljs-comment">// str == "LOGOUT"</span></code></pre></div>

<p>如果要从字符串的<em>开头</em> 中删除字符，请改用 <a href="#remove">remove</a>()。</p>
<p><strong>See also</strong> <a href="#truncate">truncate</a>(), <a href="#resize">resize</a>(), <a href="#remove">remove</a>(), and <a href="qstringview.html#chop">QStringView::chop</a>().</p>
<h3><span id="since-5-10-qstring-qstring-chopped-qsizetype-len-const"><code>[since 5.10]</code> QString::chopped(qsizetype <em>len</em>) const</span><a href="#since-5-10-qstring-qstring-chopped-qsizetype-len-const" class="header-anchor">#</a></h3><p>返回一个包含 <a href="#size">size</a>() - <em>len</em> 此字符串最左边字符的字符串。</p>
<p><strong>注意：</strong> 如果 <em>len</em> 为负数或大于 <a href="#size">size</a>()，则行为未定义。</p>
<p>该函数在 Qt 5.10 引入。</p>
<p><strong>See also</strong> <a href="#endsWith">endsWith</a>(), <a href="#first">first</a>(), <a href="#last">last</a>(), <a href="#sliced">sliced</a>(), <a href="#chop">chop</a>(), and <a href="#truncate">truncate</a>().</p>
<h3><span id="void-qstring-clear">void QString::clear()</span><a href="#void-qstring-clear" class="header-anchor">#</a></h3><p>清除字符串的内容并使其为空。</p>
<p><strong>See also</strong> <a href="#resize">resize</a>() and <a href="#isNull">isNull</a>().</p>
<h3><span id="static-int-qstring-compare-const-qstring-amp-s1-const-qstring-amp-s2-qt-casesensitivity-cs-qt-casesensitive"><code>[static]</code>int QString::compare(const  &amp;<em>s1</em>, const  &amp;<em>s2</em>,  <em>cs</em> = Qt::CaseSensitive)</span><a href="#static-int-qstring-compare-const-qstring-amp-s1-const-qstring-amp-s2-qt-casesensitivity-cs-qt-casesensitive" class="header-anchor">#</a></h3><p>比较 <em>s1</em> 和 <em>s2</em>，如果 <em>s1</em> 小于、等于或大于 <em>s2</em>，则返回小于、等于或大于零的整数。</p>
<p>如果 <em>cs</em> 为 <a href="qt.html#CaseSensitivity-enum">Qt::CaseSensitive</a>，则比较区分大小写； 否则比较不区分大小写。</p>
<p>区分大小写的比较完全基于字符的数字 Unicode 值，速度非常快，但不是人类所期望的。 考虑使用 <a href="#localeAwareCompare">localeAwareCompare</a>() 对用户可见的字符串进行排序。</p>
<div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-type">int</span> x = QString::<span class="hljs-built_in">compare</span>(<span class="hljs-string">"aUtO"</span>, <span class="hljs-string">"AuTo"</span>, Qt::CaseInsensitive);  <span class="hljs-comment">// x == 0</span>
<span class="hljs-type">int</span> y = QString::<span class="hljs-built_in">compare</span>(<span class="hljs-string">"auto"</span>, <span class="hljs-string">"Car"</span>, Qt::CaseSensitive);     <span class="hljs-comment">// y &gt; 0</span>
<span class="hljs-type">int</span> z = QString::<span class="hljs-built_in">compare</span>(<span class="hljs-string">"auto"</span>, <span class="hljs-string">"Car"</span>, Qt::CaseInsensitive);   <span class="hljs-comment">// z &lt; 0</span></code></pre></div>

<p><strong>See also</strong> <a href="#operator-eq-eq-1">operator==</a>(), <a href="#operator-lt-1">operator&lt;</a>(), <a href="#operator-gt">operator&gt;</a>(), and <a href="#comparing-strings">Comparing Strings</a>.</p>
<h3><span id="int-qstring-compare-const-qstring-amp-other-qt-casesensitivity-cs-qt-casesensitive-const">int QString::compare(const  &amp;<em>other</em>,  <em>cs</em> = Qt::CaseSensitive) const</span><a href="#int-qstring-compare-const-qstring-amp-other-qt-casesensitivity-cs-qt-casesensitive-const" class="header-anchor">#</a></h3><p>这个函数重载了 compare().</p>
<p>在词法上将此字符串与 <em>other</em> 字符串进行比较，如果此字符串小于、等于或大于另一个字符串，则返回小于、等于或大于零的整数。</p>
<p>与 compare(*this, <em>other</em>, <em>cs</em>) 相同。</p>
<h3><span id="int-qstring-compare-qlatin1string-other-qt-casesensitivity-cs-qt-casesensitive-const">int QString::compare( <em>other</em>,  <em>cs</em> = Qt::CaseSensitive) const</span><a href="#int-qstring-compare-qlatin1string-other-qt-casesensitivity-cs-qt-casesensitive-const" class="header-anchor">#</a></h3><p>这个函数重载了 compare().</p>
<p>与 compare(*this, <em>other</em>, <em>cs</em>) 相同。</p>
<h3><span id="since-5-12-int-qstring-compare-qstringview-s-qt-casesensitivity-cs-qt-casesensitive-const"><code>[since 5.12]</code>int QString::compare( <em>s</em>,  <em>cs</em> = Qt::CaseSensitive) const</span><a href="#since-5-12-int-qstring-compare-qstringview-s-qt-casesensitivity-cs-qt-casesensitive-const" class="header-anchor">#</a></h3><p>这个函数重载了 compare().</p>
<p>使用区分大小写设置 <em>cs</em> 将其与 <em>s</em> 进行比较。</p>
<p>该函数在 Qt 5.12 引入。</p>
<h3><span id="since-5-14-int-qstring-compare-qchar-ch-qt-casesensitivity-cs-qt-casesensitive-const"><code>[since 5.14]</code>int QString::compare( <em>ch</em>,  <em>cs</em> = Qt::CaseSensitive) const</span><a href="#since-5-14-int-qstring-compare-qchar-ch-qt-casesensitivity-cs-qt-casesensitive-const" class="header-anchor">#</a></h3><p>这个函数重载了 compare().</p>
<p>使用区分大小写设置 <em>cs</em> 将其与 <em>ch</em> 进行比较。</p>
<p>该函数在 Qt 5.14 引入。</p>
<h3><span id="static-int-qstring-compare-const-qstring-amp-s1-qlatin1string-s2-qt-casesensitivity-cs-qt-casesensitive"><code>[static]</code>int QString::compare(const  &amp;<em>s1</em>,  <em>s2</em>,  <em>cs</em> = Qt::CaseSensitive)</span><a href="#static-int-qstring-compare-const-qstring-amp-s1-qlatin1string-s2-qt-casesensitivity-cs-qt-casesensitive" class="header-anchor">#</a></h3><p>这个函数重载了 compare().</p>
<p>使用区分大小写设置 <em>cs</em> 执行 <em>s1</em> 和 <em>s2</em> 的比较。</p>
<h3><span id="static-int-qstring-compare-qlatin1string-s1-const-qstring-amp-s2-qt-casesensitivity-cs-qt-casesensitive"><code>[static]</code>int QString::compare( <em>s1</em>, const  &amp;<em>s2</em>,  <em>cs</em> = Qt::CaseSensitive)</span><a href="#static-int-qstring-compare-qlatin1string-s1-const-qstring-amp-s2-qt-casesensitivity-cs-qt-casesensitive" class="header-anchor">#</a></h3><p>这个函数重载了 compare().</p>
<p>使用区分大小写设置 <em>cs</em> 执行 <em>s1</em> 和 <em>s2</em> 的比较。</p>
<h3><span id="static-int-qstring-compare-const-qstring-amp-s1-qstringview-s2-qt-casesensitivity-cs-qt-casesensitive"><code>[static]</code>int QString::compare(const  &amp;<em>s1</em>,  <em>s2</em>,  <em>cs</em> = Qt::CaseSensitive)</span><a href="#static-int-qstring-compare-const-qstring-amp-s1-qstringview-s2-qt-casesensitivity-cs-qt-casesensitive" class="header-anchor">#</a></h3><p>这个函数重载了 compare().</p>
<h3><span id="static-int-qstring-compare-qstringview-s1-const-qstring-amp-s2-qt-casesensitivity-cs-qt-casesensitive"><code>[static]</code>int QString::compare( <em>s1</em>, const  &amp;<em>s2</em>,  <em>cs</em> = Qt::CaseSensitive)</span><a href="#static-int-qstring-compare-qstringview-s1-const-qstring-amp-s2-qt-casesensitivity-cs-qt-casesensitive" class="header-anchor">#</a></h3><p>这个函数重载了 compare().</p>
<h3><span id="qstring-const-iterator-qstring-constbegin-const"> QString::constBegin() const</span><a href="#qstring-const-iterator-qstring-constbegin-const" class="header-anchor">#</a></h3><p>返回指向字符串中第一个字符的 const <a href="containers.html#stl-style-iterators">STL 样式迭代器</a>。</p>
<p><strong>警告：</strong>返回的迭代器在分离或修改 <a href>QString</a> 时无效。</p>
<p><strong>See also</strong> <a href="#begin">begin</a>() and <a href="#constEnd">constEnd</a>().</p>
<h3><span id="const-qchar-qstring-constdata-const">const  *QString::constData() const</span><a href="#const-qchar-qstring-constdata-const" class="header-anchor">#</a></h3><p>返回指向存储在 <a href>QString</a> 中的数据的指针。 指针可用于访问组成字符串的字符。</p>
<p>请注意，指针仅在未修改字符串时才有效。</p>
<p><strong>注意：</strong> 返回的字符串不能以 ‘\0’ 结尾。 使用 <a href="#size">size</a>() 确定数组的长度。</p>
<p><strong>See also</strong> <a href="#data">data</a>(), [operator<a href="#operator-5b-5d">]</a>(), and <a href="#fromRawData">fromRawData</a>().</p>
<h3><span id="qstring-const-iterator-qstring-constend-const"> QString::constEnd() const</span><a href="#qstring-const-iterator-qstring-constend-const" class="header-anchor">#</a></h3><p>返回一个 const <a href="containers.html#stl-style-iterators">STL-style iterator</a> 指向字符串中最后一个字符之后。</p>
<p><strong>警告：</strong>返回的迭代器在分离或修改 <a href>QString</a> 时无效。</p>
<p><strong>See also</strong> <a href="#constBegin">constBegin</a>() and <a href="#end">end</a>().</p>
<h3><span id="bool-qstring-contains-const-qstring-amp-str-qt-casesensitivity-cs-qt-casesensitive-const">bool QString::contains(const  &amp;<em>str</em>,  <em>cs</em> = Qt::CaseSensitive) const</span><a href="#bool-qstring-contains-const-qstring-amp-str-qt-casesensitivity-cs-qt-casesensitive-const" class="header-anchor">#</a></h3><p>如果此字符串包含字符串 <em>str</em> 的出现，则返回 <code>true</code>； 否则返回“假”。</p>
<p>如果 <em>cs</em> 是 <a href="qt.html#CaseSensitivity-enum">Qt::CaseSensitive</a> （默认），则搜索区分大小写； 否则搜索不区分大小写。</p>
<p>例子:</p>
<div class="code-wrapper"><pre><code class="hljs c++">QString str = <span class="hljs-string">"Peter Pan"</span>;
str.<span class="hljs-built_in">contains</span>((<span class="hljs-string">"peter"</span>, Qt::CaseInsensitive);    );    <span class="hljs-comment">// returns true</span></code></pre></div>

<p><strong>See also</strong> <a href="#indexOf">indexOf</a>() and <a href="#count-1">count</a>().</p>
<h3><span id="bool-qstring-contains-qchar-ch-qt-casesensitivity-cs-qt-casesensitive-const">bool QString::contains( <em>ch</em>,  <em>cs</em> = Qt::CaseSensitive) const</span><a href="#bool-qstring-contains-qchar-ch-qt-casesensitivity-cs-qt-casesensitive-const" class="header-anchor">#</a></h3><p>这个函数重载了 contains()。</p>
<p>如果此字符串包含出现的字符 <em>ch</em>，则返回 <code>true</code>； 否则返回“假”。</p>
<h3><span id="since-5-3-bool-qstring-contains-qlatin1string-str-qt-casesensitivity-cs-qt-casesensitive-const"><code>[since 5.3]</code>bool QString::contains( <em>str</em>,  <em>cs</em> = Qt::CaseSensitive) const</span><a href="#since-5-3-bool-qstring-contains-qlatin1string-str-qt-casesensitivity-cs-qt-casesensitive-const" class="header-anchor">#</a></h3><p>这个函数重载了 contains()。</p>
<p>如果此字符串包含出现的 latin-1 字符串 <em>str</em>，则返回 <code>true</code>； 否则返回“假”。</p>
<p>该函数在 Qt 5.3 引入。</p>
<h3><span id="since-5-14-bool-qstring-contains-qstringview-str-qt-casesensitivity-cs-qt-casesensitive-const"><code>[since 5.14]</code>bool QString::contains( <em>str</em>,  <em>cs</em> = Qt::CaseSensitive) const</span><a href="#since-5-14-bool-qstring-contains-qstringview-str-qt-casesensitivity-cs-qt-casesensitive-const" class="header-anchor">#</a></h3><p>这个函数重载了 contains()。</p>
<p>如果此字符串包含字符串视图 <em>str</em> 的出现，则返回 <code>true</code>； 否则返回“假”。</p>
<p>如果 <em>cs</em> 是 <a href="qt.html#CaseSensitivity-enum">Qt::CaseSensitive</a> （默认），则搜索区分大小写； 否则搜索不区分大小写。</p>
<p>该函数在 Qt 5.14 引入。</p>
<p><strong>See also</strong> <a href="#indexOf">indexOf</a>() and <a href="#count-1">count</a>().</p>
<h3><span id="since-5-1-bool-qstring-contains-const-qregularexpression-amp-re-qregularexpressionmatch-rmatch-nullptr-const"><code>[since 5.1]</code>bool QString::contains(const  &amp;<em>re</em>,  *<em>rmatch</em> = nullptr) const</span><a href="#since-5-1-bool-qstring-contains-const-qregularexpression-amp-re-qregularexpressionmatch-rmatch-nullptr-const" class="header-anchor">#</a></h3><p>如果正则表达式 <em>re</em> 匹配此字符串中的某处，则返回 <code>true</code>； 否则返回“假”。</p>
<p>如果匹配成功并且 <em>rmatch</em> 不是 <code>nullptr</code>，它还将匹配结果写入 <em>rmatch</em> 指向的 <a href="qregularexpressionmatch.html">QRegularExpressionMatch</a> 对象。</p>
<p>该函数在 Qt 5.1 引入。</p>
<p><strong>See also</strong> <a href="qregularexpression.html#match">QRegularExpression::match</a>().</p>
<h3><span id="qsizetype-qstring-count-const-qstring-amp-str-qt-casesensitivity-cs-qt-casesensitive-const">qsizetype QString::count(const  &amp;<em>str</em>,  <em>cs</em> = Qt::CaseSensitive) const</span><a href="#qsizetype-qstring-count-const-qstring-amp-str-qt-casesensitivity-cs-qt-casesensitive-const" class="header-anchor">#</a></h3><p>返回此字符串中字符串 <em>str</em> 的（可能重叠的）出现次数。</p>
<p>如果 <em>cs</em> 是 <a href="qt.html#CaseSensitivity-enum">Qt::CaseSensitive</a> （默认），则搜索区分大小写； 否则搜索不区分大小写。</p>
<p><strong>See also</strong> <a href="#contains">contains</a>() and <a href="#indexOf">indexOf</a>().</p>
<h3><span id="qsizetype-qstring-count-const">qsizetype QString::count() const</span><a href="#qsizetype-qstring-count-const" class="header-anchor">#</a></h3><p>这个函数重载了 count().</p>
<p>Same as <a href="#size">size</a>().</p>
<h3><span id="qsizetype-qstring-count-qchar-ch-qt-casesensitivity-cs-qt-casesensitive-const">qsizetype QString::count( <em>ch</em>,  <em>cs</em> = Qt::CaseSensitive) const</span><a href="#qsizetype-qstring-count-qchar-ch-qt-casesensitivity-cs-qt-casesensitive-const" class="header-anchor">#</a></h3><p>这个函数重载了 count().</p>
<p>返回字符串中字符 <em>ch</em> 的出现次数。</p>
<p>如果 <em>cs</em> 是 <a href="qt.html#CaseSensitivity-enum">Qt::CaseSensitive</a> （默认），则搜索区分大小写； 否则搜索不区分大小写。</p>
<p><strong>See also</strong> <a href="#contains">contains</a>() and <a href="#indexOf">indexOf</a>().</p>
<h3><span id="since-6-0-qsizetype-qstring-count-qstringview-str-qt-casesensitivity-cs-qt-casesensitive-const"><code>[since 6.0]</code>qsizetype QString::count( <em>str</em>,  <em>cs</em> = Qt::CaseSensitive) const</span><a href="#since-6-0-qsizetype-qstring-count-qstringview-str-qt-casesensitivity-cs-qt-casesensitive-const" class="header-anchor">#</a></h3><p>这个函数重载了 count().</p>
<p>返回此字符串中字符串视图 <em>str</em> 的出现次数（可能重叠）。</p>
<p>如果 <em>cs</em> 是 <a href="qt.html#CaseSensitivity-enum">Qt::CaseSensitive</a> （默认），则搜索区分大小写； 否则搜索不区分大小写。</p>
<p>该函数在 Qt 6.0 引入。</p>
<p><strong>See also</strong> <a href="#contains">contains</a>() and <a href="#indexOf">indexOf</a>().</p>
<h3><span id="since-5-0-qsizetype-qstring-count-const-qregularexpression-amp-re-const"><code>[since 5.0]</code>qsizetype QString::count(const  &amp;<em>re</em>) const</span><a href="#since-5-0-qsizetype-qstring-count-const-qregularexpression-amp-re-const" class="header-anchor">#</a></h3><p>这个函数重载了 count().</p>
<p>返回正则表达式 <em>re</em> 在字符串中匹配的次数。</p>
<p>由于历史原因，此函数计算重叠匹配，因此在下面的示例中，有四个“ana”或“ama”实例：</p>
<div class="code-wrapper"><pre><code class="hljs c++">QString str = <span class="hljs-string">"banana and panama"</span>;
str.<span class="hljs-built_in">count</span>(<span class="hljs-built_in">QRegularExpression</span>(<span class="hljs-string">"a[nm]a"</span>));    <span class="hljs-comment">// returns 4</span></code></pre></div>

<p>此行为不同于使用 <a href="qregularexpressionmatchiterator.html">QRegularExpressionMatchIterator</a> 简单地迭代字符串中的匹配项。</p>
<p>该函数在 Qt 5.0 引入。</p>
<p><strong>See also</strong> <a href="qregularexpression.html#globalMatch">QRegularExpression::globalMatch</a>().</p>
<h3><span id="since-5-6-qstring-const-reverse-iterator-qstring-crbegin-const"><code>[since 5.6]</code> QString::crbegin() const</span><a href="#since-5-6-qstring-const-reverse-iterator-qstring-crbegin-const" class="header-anchor">#</a></h3><p>返回一个 const <a href="containers.html#stl-style-iterators">STL-style</a> 反向迭代器，以相反的顺序指向字符串中的第一个字符。</p>
<p><strong>警告：</strong>返回的迭代器在分离或修改 <a href>QString</a> 时无效。</p>
<p>该函数在 Qt 5.6 引入。</p>
<p><strong>See also</strong> <a href="#begin">begin</a>(), <a href="#rbegin">rbegin</a>(), and <a href="#rend">rend</a>().</p>
<h3><span id="since-5-6-qstring-const-reverse-iterator-qstring-crend-const"><code>[since 5.6]</code> QString::crend() const</span><a href="#since-5-6-qstring-const-reverse-iterator-qstring-crend-const" class="header-anchor">#</a></h3><p>返回一个 const <a href="containers.html#stl-style-iterators">STL-style</a> 反向迭代器，以相反的顺序指向字符串中最后一个字符之后。</p>
<p><strong>警告：</strong>返回的迭代器在分离或修改 <a href>QString</a> 时无效。</p>
<p>该函数在 Qt 5.6 引入。</p>
<p><strong>See also</strong> <a href="#end">end</a>(), <a href="#rend">rend</a>(), and <a href="#rbegin">rbegin</a>().</p>
<h3><span id="qchar-qstring-data"> *QString::data()</span><a href="#qchar-qstring-data" class="header-anchor">#</a></h3><p>返回指向存储在 <a href>QString</a> 中的数据的指针。 指针可用于访问和修改组成字符串的字符。</p>
<p>与 <a href="#constData">constData</a>() 和 <a href="#unicode">unicode</a>() 不同，返回的数据始终以 ‘\0’ 结尾。</p>
<p>例子:</p>
<div class="code-wrapper"><pre><code class="hljs c++">QString str = <span class="hljs-string">"Hello world"</span>;
QChar *data = str.<span class="hljs-built_in">data</span>();
<span class="hljs-keyword">while</span> (!data-&gt;<span class="hljs-built_in">isNull</span>()) {
    <span class="hljs-built_in">qDebug</span>() &lt;&lt; data-&gt;<span class="hljs-built_in">unicode</span>();
    ++data;
}</code></pre></div>

<p>请注意，只有当字符串没有被其他方式修改时，指针才有效。 对于只读访问，<a href="#constData">constData</a>() 更快，因为它永远不会导致 <a href="implicit-sharing.html#deep-copy">deep copy</a> 发生。</p>
<p><strong>See also</strong> <a href="#constData">constData</a>() and [operator<a href="#operator-5b-5d">]</a>().</p>
<h3><span id="const-qchar-qstring-data-const">const  *QString::data() const</span><a href="#const-qchar-qstring-data-const" class="header-anchor">#</a></h3><p>这是一个重载函数。</p>
<p><strong>注意：</strong> 返回的字符串不能以 ‘\0’ 结尾。 使用 <a href="#size">size</a>() 确定数组的长度。</p>
<p><strong>See also</strong> <a href="#fromRawData">fromRawData</a>().</p>
<h3><span id="qstring-iterator-qstring-end"> QString::end()</span><a href="#qstring-iterator-qstring-end" class="header-anchor">#</a></h3><p>返回一个 <a href="containers.html#stl-style-iterators">STL 风格的迭代器</a> 指向字符串中最后一个字符之后。</p>
<p><strong>警告：</strong>返回的迭代器在分离或修改 <a href>QString</a> 时无效。</p>
<p><strong>See also</strong> <a href="#begin">begin</a>() and <a href="#constEnd">constEnd</a>().</p>
<h3><span id="qstring-const-iterator-qstring-end-const"> QString::end() const</span><a href="#qstring-const-iterator-qstring-end-const" class="header-anchor">#</a></h3><p>这个函数重载了 end().</p>
<h3><span id="bool-qstring-endswith-const-qstring-amp-s-qt-casesensitivity-cs-qt-casesensitive-const">bool QString::endsWith(const  &amp;<em>s</em>,  <em>cs</em> = Qt::CaseSensitive) const</span><a href="#bool-qstring-endswith-const-qstring-amp-s-qt-casesensitivity-cs-qt-casesensitive-const" class="header-anchor">#</a></h3><p>如果字符串以 <em>s</em> 结尾，则返回 <code>true</code>； 否则返回“假”。</p>
<p>如果 <em>cs</em> 是 <a href="qt.html#CaseSensitivity-enum">Qt::CaseSensitive</a> （默认），则搜索区分大小写； 否则搜索不区分大小写。</p>
<div class="code-wrapper"><pre><code class="hljs c++">QString str = <span class="hljs-string">"Bananas"</span>;
str.<span class="hljs-built_in">endsWith</span>(<span class="hljs-string">"anas"</span>);         <span class="hljs-comment">// returns true</span>
str.<span class="hljs-built_in">endsWith</span>(<span class="hljs-string">"pple"</span>);         <span class="hljs-comment">// returns false</span></code></pre></div>

<p><strong>See also</strong> <a href="#startsWith">startsWith</a>().</p>
<h3><span id="since-5-10-bool-qstring-endswith-qstringview-str-qt-casesensitivity-cs-qt-casesensitive-const"><code>[since 5.10]</code>bool QString::endsWith( <em>str</em>,  <em>cs</em> = Qt::CaseSensitive) const</span><a href="#since-5-10-bool-qstring-endswith-qstringview-str-qt-casesensitivity-cs-qt-casesensitive-const" class="header-anchor">#</a></h3><p>这个函数重载了 endsWith().</p>
<p>如果字符串以字符串视图 <em>str</em> 结尾，则返回 <code>true</code>； 否则返回“假”。</p>
<p>如果 <em>cs</em> 是 <a href="qt.html#CaseSensitivity-enum">Qt::CaseSensitive</a> （默认），则搜索区分大小写； 否则搜索不区分大小写。</p>
<p>该函数在 Qt 5.10 引入。</p>
<p><strong>See also</strong> <a href="#startsWith">startsWith</a>().</p>
<h3><span id="bool-qstring-endswith-qlatin1string-s-qt-casesensitivity-cs-qt-casesensitive-const">bool QString::endsWith( <em>s</em>,  <em>cs</em> = Qt::CaseSensitive) const</span><a href="#bool-qstring-endswith-qlatin1string-s-qt-casesensitivity-cs-qt-casesensitive-const" class="header-anchor">#</a></h3><p>这个函数重载了 endsWith().</p>
<h3><span id="bool-qstring-endswith-qchar-c-qt-casesensitivity-cs-qt-casesensitive-const">bool QString::endsWith( <em>c</em>,  <em>cs</em> = Qt::CaseSensitive) const</span><a href="#bool-qstring-endswith-qchar-c-qt-casesensitivity-cs-qt-casesensitive-const" class="header-anchor">#</a></h3><p>如果字符串以 <em>c</em> 结尾，则返回 <code>true</code>； 否则返回“假”。</p>
<p>这个函数重载了 endsWith()。</p>
<h3><span id="cong-6-1-kai-shi-qstring-iterator-qstring-erase-qstring-const-iterator-first-qstring-const-iterator-const-iterator-typedef-last"><code>[从 6.1 开始]</code> QString::erase( <em>first</em>, [QString::const_iterator](# const_iterator-typedef) <em>last</em>)</span><a href="#cong-6-1-kai-shi-qstring-iterator-qstring-erase-qstring-const-iterator-first-qstring-const-iterator-const-iterator-typedef-last" class="header-anchor">#</a></h3><p>从字符串中删除半开范围 [ <em>first</em> , <em>last</em> ) 中的字符。 返回一个迭代器，指向擦除前 <em>last</em> 引用的字符。</p>
<p>该函数在 Qt 6.1 中引入。</p>
<h3><span id="qstring-amp-qstring-fill-qchar-ch-qsizetype-size-1"> &amp;QString::fill( <em>ch</em>, qsizetype <em>size</em> = -1)</span><a href="#qstring-amp-qstring-fill-qchar-ch-qsizetype-size-1" class="header-anchor">#</a></h3><p>将字符串中的每个字符设置为字符 <em>ch</em>。 如果 <em>size</em> 不同于 -1（默认），则字符串会预先调整为 <em>size</em>。</p>
<p>例子:</p>
<div class="code-wrapper"><pre><code class="hljs c++">QString str = <span class="hljs-string">"Berlin"</span>;
str.<span class="hljs-built_in">fill</span>(<span class="hljs-string">'z'</span>);
<span class="hljs-comment">// str == "zzzzzz"</span>

str.<span class="hljs-built_in">fill</span>(<span class="hljs-string">'A'</span>, <span class="hljs-number">2</span>);
<span class="hljs-comment">// str == "AA"</span></code></pre></div>

<p><strong>See also</strong> <a href="#resize">resize</a>().</p>
<h3><span id="since-6-0-qstring-qstring-first-qsizetype-n-const"><code>[since 6.0]</code> QString::first(qsizetype <em>n</em>) const</span><a href="#since-6-0-qstring-qstring-first-qsizetype-n-const" class="header-anchor">#</a></h3><p>返回包含此字符串的前 <em>n</em> 个字符的字符串。</p>
<p><strong>注意：</strong> 当 <em>n</em> &lt; 0 或 *n* &gt; <a href="#size">size</a>() 时，行为未定义。</p>
<div class="code-wrapper"><pre><code class="hljs c++">QString x = <span class="hljs-string">"Pineapple"</span>;

QString y = x.<span class="hljs-built_in">first</span>((<span class="hljs-number">4</span>);            <span class="hljs-comment">// y == "Pine"</span></code></pre></div>

<p>该函数在 Qt 6.0 引入。</p>
<p><strong>See also</strong> <a href="#last">last</a>(), <a href="#sliced">sliced</a>(), <a href="#startsWith">startsWith</a>(), <a href="#chopped">chopped</a>(), <a href="#chop">chop</a>(), and <a href="#truncate">truncate</a>().</p>
<h3><span id="static-since-5-2-qstring-qstring-fromcfstring-cfstringref-string"><code>[static, since 5.2]</code> QString::fromCFString(CFStringRef <em>string</em>)</span><a href="#static-since-5-2-qstring-qstring-fromcfstring-cfstringref-string" class="header-anchor">#</a></h3><p>构造一个包含 <em>string</em> CFString 副本的新 <a href>QString</a>。</p>
<p><strong>注意：</strong> 此功能仅适用于 macOS 和 iOS。</p>
<p>该函数在 Qt 5.2 引入。</p>
<h3><span id="static-qstring-qstring-fromlatin1-const-char-str-qsizetype-size"><code>[static]</code> QString::fromLatin1(const char *<em>str</em>, qsizetype <em>size</em>)</span><a href="#static-qstring-qstring-fromlatin1-const-char-str-qsizetype-size" class="header-anchor">#</a></h3><p>返回使用 Latin-1 字符串 <em>str</em> 的前 <em>size</em> 个字符初始化的 <a href>QString</a>。</p>
<p>如果 <em>size</em> 是 <code>-1</code>，则使用 <code>strlen(str)</code> 代替。</p>
<p><strong>See also</strong> <a href="#toLatin1">toLatin1</a>(), <a href="#fromUtf8">fromUtf8</a>(), and <a href="#fromLocal8Bit">fromLocal8Bit</a>().</p>
<h3><span id="static-since-6-0-qstring-qstring-fromlatin1-qbytearrayview-str"><code>[static, since 6.0]</code> QString::fromLatin1( <em>str</em>)</span><a href="#static-since-6-0-qstring-qstring-fromlatin1-qbytearrayview-str" class="header-anchor">#</a></h3><p>这是一个重载函数。</p>
<p>返回用 Latin-1 字符串 <em>str</em> 初始化的 <a href>QString</a>。</p>
<p>该函数在 Qt 6.0 引入。</p>
<h3><span id="static-since-5-0-template-qstring-qstring-fromlatin1-const-qbytearray-amp-str"><code>[static, since 5.0]</code>template <typename> <a href="#QString">QString</a> QString::fromLatin1(const <a href="qbytearray.html">QByteArray</a> &amp;<em>str</em>)</typename></span><a href="#static-since-5-0-template-qstring-qstring-fromlatin1-const-qbytearray-amp-str" class="header-anchor">#</a></h3><p>这是一个重载函数。</p>
<p>返回用 Latin-1 字符串 <em>str</em> 初始化的 <a href>QString</a>。</p>
<p>该函数在 Qt 5.0 引入。</p>
<h3><span id="static-qstring-qstring-fromlocal8bit-const-char-str-qsizetype-size"><code>[static]</code> QString::fromLocal8Bit(const char *<em>str</em>, qsizetype <em>size</em>)</span><a href="#static-qstring-qstring-fromlocal8bit-const-char-str-qsizetype-size" class="header-anchor">#</a></h3><p>返回用 8 位字符串 <em>str</em> 的前 <em>size</em> 个字符初始化的 <a href>QString</a>。</p>
<p>如果 <em>size</em> 是 <code>-1</code>，则使用 <code>strlen(str)</code> 代替。</p>
<p>在 Unix 系统上，这等价于 <a href="#fromUtf8">fromUtf8</a>()，在 Windows 上，使用的是系统当前代码页。</p>
<p><strong>See also</strong> <a href="#toLocal8Bit">toLocal8Bit</a>(), <a href="#fromLatin1">fromLatin1</a>(), and <a href="#fromUtf8">fromUtf8</a>().</p>
<h3><span id="static-since-6-0-qstring-qstring-fromlocal8bit-qbytearrayview-str"><code>[static, since 6.0]</code> QString::fromLocal8Bit( <em>str</em>)</span><a href="#static-since-6-0-qstring-qstring-fromlocal8bit-qbytearrayview-str" class="header-anchor">#</a></h3><p>这是一个重载函数。</p>
<p>返回用 8 位字符串 <em>str</em> 初始化的 <a href>QString</a>。</p>
<p>该函数在 Qt 6.0 引入。</p>
<h3><span id="static-since-5-0-template-qstring-qstring-fromlocal8bit-const-qbytearray-amp-str"><code>[static, since 5.0]</code>template <typename> <a href="#QString">QString</a> QString::fromLocal8Bit(const <a href="qbytearray.html">QByteArray</a> &amp;<em>str</em>)</typename></span><a href="#static-since-5-0-template-qstring-qstring-fromlocal8bit-const-qbytearray-amp-str" class="header-anchor">#</a></h3><p>这是一个重载函数。</p>
<p>返回用 8 位字符串 <em>str</em> 初始化的 <a href>QString</a>。</p>
<p>该函数在 Qt 5.0 引入。</p>
<h3><span id="static-since-5-2-qstring-qstring-fromnsstring-const-nsstring-string"><code>[static, since 5.2]</code> QString::fromNSString(const NSString *<em>string</em>)</span><a href="#static-since-5-2-qstring-qstring-fromnsstring-const-nsstring-string" class="header-anchor">#</a></h3><p>构造一个包含 <em>string</em> NSString 副本的新 <a href>QString</a>。</p>
<p><strong>注意：</strong> 此功能仅适用于 macOS 和 iOS。</p>
<p>该函数在 Qt 5.2 引入。</p>
<h3><span id="static-qstring-qstring-fromrawdata-const-qchar-unicode-qsizetype-size"><code>[static]</code> QString::fromRawData(const  *<em>unicode</em>, qsizetype <em>size</em>)</span><a href="#static-qstring-qstring-fromrawdata-const-qchar-unicode-qsizetype-size" class="header-anchor">#</a></h3><p>构造一个 <a href>QString</a>，它使用数组 <em>unicode</em> 中的第一个 <em>size</em> Unicode 字符。 <em>unicode</em> 中的数据<em>不</em> 复制。 只要 <a href>QString</a>（或它的未修改副本）存在，调用者必须能够保证 <em>unicode</em> 不会被删除或修改。</p>
<p>任何修改 <a href>QString</a> 或其副本的尝试都将导致它创建数据的深层副本，以确保原始数据不被修改。</p>
<p>这是一个示例，说明我们如何在内存中的原始数据上使用 <a href="qregularexpression.html">QRegularExpression</a> 而无需将数据复制到 <a href>QString</a> 中：</p>
<div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-function">QRegularExpression <span class="hljs-title">pattern</span><span class="hljs-params">((<span class="hljs-string">"\u00A4"</span>);</span></span>
<span class="hljs-params"><span class="hljs-function"></span></span>
<span class="hljs-params"><span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">const</span> QChar unicode[] = {</span></span>
<span class="hljs-params"><span class="hljs-function">        {</span></span>
<span class="hljs-params"><span class="hljs-function">        <span class="hljs-number">0x005A</span>, <span class="hljs-number">0x007F</span>, <span class="hljs-number">0x00A4</span>, <span class="hljs-number">0x0060</span>,</span></span>
<span class="hljs-params"><span class="hljs-function">        <span class="hljs-number">0x1009</span>, <span class="hljs-number">0x0020</span>, <span class="hljs-number">0x0020</span></span></span>
<span class="hljs-params"><span class="hljs-function">        };</span></span>
<span class="hljs-params"><span class="hljs-function">qsizetype size = <span class="hljs-keyword">sizeof</span>(unicode) unicode)</span> / <span class="hljs-title">sizeof</span><span class="hljs-params">(QChar)</span></span>;

QString str = QString::<span class="hljs-built_in">fromRawData</span>(<span class="hljs-built_in">unicode</span>(unicode, size);
);
<span class="hljs-keyword">if</span> (<span class="hljs-built_in">str</span>(str.<span class="hljs-built_in">contains</span>(pattern) {
    (pattern) {
    <span class="hljs-comment">// ...</span>
}}</code></pre></div>

<p><strong>警告：</strong> 使用 fromRawData() 创建的字符串 <em>not</em> 以 ‘\0’ 结尾，除非原始数据在 <em>size</em> 位置包含 ‘\0’ 字符。 这意味着 <a href="#unicode">unicode</a>() 将<em>不会</em>返回以 ‘\0’ 结尾的字符串（尽管 <a href="#utf16">utf16</a>() 会这样做，但代价是复制原始数据）。</p>
<p><strong>另请参阅</strong> <a href="#fromUtf16">fromUtf16</a>() 和 <a href="#setRawData">setRawData</a>()。</p>
<h3><span id="static-qstring-qstring-fromstdstring-const-std-string-amp-str"><code>[static]</code> QString::fromStdString(const std::string &amp;<em>str</em>)</span><a href="#static-qstring-qstring-fromstdstring-const-std-string-amp-str" class="header-anchor">#</a></h3><p>返回 <em>str</em> 字符串的副本。 使用 <a href="#fromUtf8">fromUtf8</a>() 函数将给定的字符串转换为 Unicode。</p>
<p><strong>See also</strong> <a href="#fromLatin1">fromLatin1</a>(), <a href="#fromLocal8Bit">fromLocal8Bit</a>(), <a href="#fromUtf8">fromUtf8</a>(), and <a href="qbytearray.html#fromStdString">QByteArray::fromStdString</a>().</p>
<h3><span id="static-since-5-5-qstring-qstring-fromstdu16string-const-std-u16string-amp-str"><code>[static, since 5.5]</code> QString::fromStdU16String(const std::u16string &amp;<em>str</em>)</span><a href="#static-since-5-5-qstring-qstring-fromstdu16string-const-std-u16string-amp-str" class="header-anchor">#</a></h3><p>返回 <em>str</em> 字符串的副本。 假定给定字符串编码是👉 UTF-16.</p>
<p>该函数在 Qt 5.5 引入。</p>
<p><strong>See also</strong> <a href="#fromUtf16">fromUtf16</a>(), <a href="#fromStdWString">fromStdWString</a>(), and <a href="#fromStdU32String">fromStdU32String</a>().</p>
<h3><span id="static-since-5-5-qstring-qstring-fromstdu32string-const-std-u32string-amp-str"><code>[static, since 5.5]</code> QString::fromStdU32String(const std::u32string &amp;<em>str</em>)</span><a href="#static-since-5-5-qstring-qstring-fromstdu32string-const-std-u32string-amp-str" class="header-anchor">#</a></h3><p>返回 <em>str</em> 字符串的副本。 假定给定字符串编码是👉 UCS-4.</p>
<p>该函数在 Qt 5.5 引入。</p>
<p><strong>See also</strong> <a href="#fromUcs4">fromUcs4</a>(), <a href="#fromStdWString">fromStdWString</a>(), and <a href="#fromStdU16String">fromStdU16String</a>().</p>
<h3><span id="static-qstring-qstring-fromstdwstring-const-std-wstring-amp-str"><code>[static]</code> QString::fromStdWString(const std::wstring &amp;<em>str</em>)</span><a href="#static-qstring-qstring-fromstdwstring-const-std-wstring-amp-str" class="header-anchor">#</a></h3><p>返回 <em>str</em> 字符串的副本。 假定给定字符串编码是👉 utf16 如果 wchar_t 的大小是 2 个字节（例如在 windows 上），如果 wchar_t 的大小是 4 个字节（大多数 Unix 系统），则为 ucs4。</p>
<p><strong>See also</strong> <a href="#fromUtf16">fromUtf16</a>(), <a href="#fromLatin1">fromLatin1</a>(), <a href="#fromLocal8Bit">fromLocal8Bit</a>(), <a href="#fromUtf8">fromUtf8</a>(), <a href="#fromUcs4">fromUcs4</a>(), <a href="#fromStdU16String">fromStdU16String</a>(), and <a href="#fromStdU32String">fromStdU32String</a>().</p>
<h3><span id="static-since-5-3-qstring-qstring-fromucs4-const-char32-t-unicode-qsizetype-size-1"><code>[static, since 5.3]</code> QString::fromUcs4(const char32_t *<em>unicode</em>, qsizetype <em>size</em> = -1)</span><a href="#static-since-5-3-qstring-qstring-fromucs4-const-char32-t-unicode-qsizetype-size-1" class="header-anchor">#</a></h3><p>返回使用 Unicode 字符串 <em>unicode</em>（ISO-10646-UCS-4 编码）的前 <em>size</em> 个字符初始化的 <a href>QString</a>。</p>
<p>如果 <em>size</em> 为 -1（默认），<em>unicode</em> 必须以 \0’ 结尾。</p>
<p>该函数在 Qt 5.3 引入。</p>
<p><strong>See also</strong> <a href="#toUcs4">toUcs4</a>(), <a href="#fromUtf16">fromUtf16</a>(), <a href="#utf16">utf16</a>(), <a href="#setUtf16">setUtf16</a>(), <a href="#fromWCharArray">fromWCharArray</a>(), and <a href="#fromStdU32String">fromStdU32String</a>().</p>
<h3><span id="static-qstring-qstring-fromutf8-const-char-str-qsizetype-size"><code>[static]</code> QString::fromUtf8(const char *<em>str</em>, qsizetype <em>size</em>)</span><a href="#static-qstring-qstring-fromutf8-const-char-str-qsizetype-size" class="header-anchor">#</a></h3><p>返回使用 UTF-8 字符串 <em>str</em> 的前 <em>size</em> 字节初始化的 <a href>QString</a>。</p>
<p>如果 <em>size</em> 是 <code>-1</code>，则使用 <code>strlen(str)</code> 代替。</p>
<p>UTF-8 是一种 Unicode 编解码器，可以表示 Unicode 字符串中的所有字符，如 <a href>QString</a>。 但是，UTF-8 可能会出现无效序列，如果发现任何此类，它们将被替换为一个或多个“替换字符”，或被禁止。 这些包括非 Unicode 序列、非字符、超长序列或编码为 UTF-8 的代理代码点。</p>
<p>只要所有 UTF-8 字符在传入数据中终止，此函数就可用于增量处理传入数据。 字符串末尾的任何未终止字符都将被替换或抑制。 为了进行有状态解码，请使用 <a href="qstringdecoder.html">QStringDecoder</a>。</p>
<p><strong>See also</strong> <a href="#toUtf8">toUtf8</a>(), <a href="#fromLatin1">fromLatin1</a>(), and <a href="#fromLocal8Bit">fromLocal8Bit</a>().</p>
<h3><span id="static-since-6-0-qstring-qstring-fromutf8-qbytearrayview-str"><code>[static, since 6.0]</code> QString::fromUtf8( <em>str</em>)</span><a href="#static-since-6-0-qstring-qstring-fromutf8-qbytearrayview-str" class="header-anchor">#</a></h3><p>这是一个重载函数。</p>
<p>返回用 UTF-8 字符串 <em>str</em> 初始化的 <a href>QString</a>。</p>
<p>该函数在 Qt 6.0 引入。</p>
<h3><span id="static-since-5-0-template-qstring-qstring-fromutf8-const-qbytearray-amp-str"><code>[static, since 5.0]</code>template <typename> <a href="#QString">QString</a> QString::fromUtf8(const <a href="qbytearray.html">QByteArray</a> &amp;<em>str</em>)</typename></span><a href="#static-since-5-0-template-qstring-qstring-fromutf8-const-qbytearray-amp-str" class="header-anchor">#</a></h3><p>这是一个重载函数。</p>
<p>返回用 UTF-8 字符串 <em>str</em> 初始化的 <a href>QString</a>。</p>
<p>该函数在 Qt 5.0 引入。</p>
<h3><span id="static-since-6-1-template-qstring-qstring-fromutf8-const-char8-t-str"><code>[static, since 6.1]</code>template <typename> <a href="#QString">QString</a> QString::fromUtf8(const char8_t *<em>str</em>)</typename></span><a href="#static-since-6-1-template-qstring-qstring-fromutf8-const-char8-t-str" class="header-anchor">#</a></h3><p>这是一个重载函数。</p>
<p>此重载仅在以 C++20 模式编译时可用。</p>
<p>该函数在 Qt 6.1 引入。</p>
<h3><span id="static-since-6-0-template-qstring-qstring-fromutf8-const-char8-t-str-qsizetype-size"><code>[static, since 6.0]</code>template <typename> <a href="#QString">QString</a> QString::fromUtf8(const char8_t *<em>str</em>, qsizetype <em>size</em>)</typename></span><a href="#static-since-6-0-template-qstring-qstring-fromutf8-const-char8-t-str-qsizetype-size" class="header-anchor">#</a></h3><p>这是一个重载函数。</p>
<p>此重载仅在以 C++20 模式编译时可用。</p>
<p>该函数在 Qt 6.0 引入。</p>
<h3><span id="static-since-5-3-qstring-qstring-fromutf16-const-char16-t-unicode-qsizetype-size-1"><code>[static, since 5.3]</code> QString::fromUtf16(const char16_t *<em>unicode</em>, qsizetype <em>size</em> = -1)</span><a href="#static-since-5-3-qstring-qstring-fromutf16-const-char16-t-unicode-qsizetype-size-1" class="header-anchor">#</a></h3><p>返回使用 Unicode 字符串 <em>unicode</em>（ISO-10646-UTF-16 编码）的前 <em>size</em> 个字符初始化的 <a href>QString</a>。</p>
<p>如果 <em>size</em> 为 -1（默认，<em>unicode</em> 必须以 \0’ 结束）。</p>
<p>此函数检查字节顺序标记 (BOM)。 如果缺少，则假定主机字节顺序。</p>
<p>与其他 Unicode 转换相比，此函数速度较慢。 如果可能，请使用 <a href>QString</a>(const <a href="qchar.html">QChar</a> *, int) 或 <a href>QString</a>(const <a href="qchar.html">QChar</a> *)。</p>
<p><a href>QString</a> 对 Unicode 数据进行深拷贝。</p>
<p>该函数在 Qt 5.3 引入。</p>
<p><strong>See also</strong> <a href="#utf16">utf16</a>(), <a href="#setUtf16">setUtf16</a>(), and <a href="#fromStdU16String">fromStdU16String</a>().</p>
<h3><span id="static-qstring-qstring-fromwchararray-const-wchar-t-string-qsizetype-size-1"><code>[static]</code> QString::fromWCharArray(const wchar_t *<em>string</em>, qsizetype <em>size</em> = -1)</span><a href="#static-qstring-qstring-fromwchararray-const-wchar-t-string-qsizetype-size-1" class="header-anchor">#</a></h3><p>返回 <em>string</em> 的副本，其中 <em>string</em> 的编码取决于 wchar 的大小。 如果 wchar 是 4 个字节，<em>string</em> 被解释为 UCS-4，如果 wchar 是 2 个字节，它被解释为 UTF-16。</p>
<p>如果 <em>size</em> 为 -1（默认），则 <em>string</em> 必须以 ‘\0’ 结尾。</p>
<p><strong>See also</strong> <a href="#fromUtf16">fromUtf16</a>(), <a href="#fromLatin1">fromLatin1</a>(), <a href="#fromLocal8Bit">fromLocal8Bit</a>(), <a href="#fromUtf8">fromUtf8</a>(), <a href="#fromUcs4">fromUcs4</a>(), and <a href="#fromStdWString">fromStdWString</a>().</p>
<h3><span id="since-5-10-qchar-qstring-front-const"><code>[since 5.10]</code> QString::front() const</span><a href="#since-5-10-qchar-qstring-front-const" class="header-anchor">#</a></h3><p>返回字符串中的第一个字符。 与 <code>at(0)</code> 相同。</p>
<p>提供此功能是为了与 STL 兼容。</p>
<p><strong>警告：</strong> 对空字符串调用此函数构成未定义的行为。</p>
<p>该函数在 Qt 5.10 引入。</p>
<p><strong>See also</strong> <a href="#back">back</a>(), <a href="#at">at</a>(), and [operator<a href="#operator-5b-5d">]</a>().</p>
<h3><span id="since-5-10-qchar-amp-qstring-front"><code>[since 5.10]</code> &amp;QString::front()</span><a href="#since-5-10-qchar-amp-qstring-front" class="header-anchor">#</a></h3><p>返回对字符串中第一个字符的引用。 与 <code>operator[](0)</code> 相同。</p>
<p>提供此功能是为了与 STL 兼容。</p>
<p><strong>警告：</strong> 对空字符串调用此函数构成未定义的行为。</p>
<p>该函数在 Qt 5.10 引入。</p>
<p><strong>See also</strong> <a href="#back">back</a>(), <a href="#at">at</a>(), and [operator<a href="#operator-5b-5d">]</a>().</p>
<h3><span id="qsizetype-qstring-indexof-qlatin1string-str-qsizetype-from-0-qt-casesensitivity-cs-qt-casesensitive-const">qsizetype QString::indexOf( <em>str</em>, qsizetype <em>from</em> = 0,  <em>cs</em> = Qt::CaseSensitive) const</span><a href="#qsizetype-qstring-indexof-qlatin1string-str-qsizetype-from-0-qt-casesensitivity-cs-qt-casesensitive-const" class="header-anchor">#</a></h3><p>返回此字符串中第一次出现的字符串 <em>str</em> 的索引位置，从索引位置 <em>from</em> 向前搜索。 如果没有找到 <em>str</em>，则返回 -1。</p>
<p>如果 <em>cs</em> 是 <a href="qt.html#CaseSensitivity-enum">Qt::CaseSensitive</a> （默认），则搜索区分大小写； 否则搜索不区分大小写。</p>
<p>例子:</p>
<div class="code-wrapper"><pre><code class="hljs c++">QString x = <span class="hljs-string">"sticky question"</span>;

QString y = <span class="hljs-string">"sti"</span>;
x.<span class="hljs-built_in">indexOf</span>(y);                          <span class="hljs-comment">// returns 0</span>
x.<span class="hljs-built_in">indexOf</span>(y, <span class="hljs-number">1</span>);                       <span class="hljs-comment">// returns 10</span>
x.<span class="hljs-built_in">indexOf</span>(y, <span class="hljs-number">10</span>);                      <span class="hljs-comment">// returns 10</span>
x.<span class="hljs-built_in">indexOf</span>(y, <span class="hljs-number">11</span>);                      <span class="hljs-comment">// returns -1</span></code></pre></div>

<p>如果 <em>from</em> 为 -1，则从最后一个字符开始搜索； 如果是-2，则在倒数第二个字符处，依此类推。</p>
<p><strong>另请参阅</strong> <a href="#lastIndexOf">lastIndexOf</a>()、<a href="#contains">contains</a>() 和 <a href="#count-1">count</a>()。</p>
<h3><span id="qsizetype-qstring-indexof-qchar-ch-qsizetype-from-0-qt-casesensitivity-cs-qt-casesensitive-const">qsizetype QString::indexOf( <em>ch</em>, qsizetype <em>from</em> = 0,  <em>cs</em> = Qt::CaseSensitive）const</span><a href="#qsizetype-qstring-indexof-qchar-ch-qsizetype-from-0-qt-casesensitivity-cs-qt-casesensitive-const" class="header-anchor">#</a></h3><p>这个函数重载了 indexOf()。</p>
<p>返回字符串中字符 <em>ch</em> 第一次出现的索引位置，从索引位置 <em>from</em> 向前搜索。 如果无法找到 <em>ch</em>，则返回 -1。</p>
<h3><span id="qsizetype-qstring-indexof-const-qstring-amp-str-qsizetype-from-0-qt-casesensitivity-cs-qt-casesensitive-const">qsizetype QString::indexOf(const  &amp;<em>str</em>, qsizetype <em>from</em> = 0,  <em>cs</em> = Qt::CaseSensitive) const</span><a href="#qsizetype-qstring-indexof-const-qstring-amp-str-qsizetype-from-0-qt-casesensitivity-cs-qt-casesensitive-const" class="header-anchor">#</a></h3><p>返回此字符串中第一次出现的字符串 <em>str</em> 的索引位置，从索引位置 <em>from</em> 向前搜索。 如果没有找到 <em>str</em>，则返回 -1。</p>
<p>如果 <em>cs</em> 是 <a href="qt.html#CaseSensitivity-enum">Qt::CaseSensitive</a> （默认），则搜索区分大小写； 否则搜索不区分大小写。</p>
<p>例子:</p>
<div class="code-wrapper"><pre><code class="hljs c++">QString x = <span class="hljs-string">"sticky question"</span>;
QString y = <span class="hljs-string">"sti"</span>;
x.<span class="hljs-built_in">indexOf</span>(y);                              <span class="hljs-comment">// returns 0</span>
x.<span class="hljs-built_in">indexOf</span>(y, <span class="hljs-number">1</span>);                        <span class="hljs-comment">// returns 10</span>
x.<span class="hljs-built_in">indexOf</span>(y, <span class="hljs-number">10</span>);                      <span class="hljs-comment">// returns 10</span>
x.<span class="hljs-built_in">indexOf</span>(y, <span class="hljs-number">11</span>);                      <span class="hljs-comment">// returns -1</span></code></pre></div>

<p>如果 <em>from</em> 为 -1，则从最后一个字符开始搜索； 如果是-2，则在倒数第二个字符处，依此类推。</p>
<p><strong>See also</strong> <a href="#lastIndexOf">lastIndexOf</a>(), <a href="#contains">contains</a>(), and <a href="#count-1">count</a>().</p>
<h3><span id="since-5-14-qsizetype-qstring-indexof-qstringview-str-qsizetype-from-0-qt-casesensitivity-cs-qt-casesensitive-const"><code>[since 5.14]</code>qsizetype QString::indexOf( <em>str</em>, qsizetype <em>from</em> = 0,  <em>cs</em> = Qt::CaseSensitive) const</span><a href="#since-5-14-qsizetype-qstring-indexof-qstringview-str-qsizetype-from-0-qt-casesensitivity-cs-qt-casesensitive-const" class="header-anchor">#</a></h3><p>这个函数重载了 indexOf()。</p>
<p>返回此字符串中第一次出现的字符串视图 <em>str</em> 的索引位置，从索引位置 <em>from</em> 向前搜索。 如果没有找到 <em>str</em>，则返回 -1。</p>
<p>如果 <em>cs</em> 是 <a href="qt.html#CaseSensitivity-enum">Qt::CaseSensitive</a> （默认），则搜索区分大小写； 否则搜索不区分大小写。</p>
<p>如果 <em>from</em> 为 -1，则从最后一个字符开始搜索； 如果是-2，则在倒数第二个字符处，依此类推。</p>
<p>该函数在 Qt 5.14 引入。</p>
<p><strong>See also</strong> <a href="qstringview.html#indexOf">QStringView::indexOf</a>(), <a href="#lastIndexOf">lastIndexOf</a>(), <a href="#contains">contains</a>(), and <a href="#count-1">count</a>().</p>
<h3><span id="since-5-5-qsizetype-qstring-indexof-const-qregularexpression-amp-re-qsizetype-from-0-qregularexpressionmatch-rmatch-nullptr-const"><code>[since 5.5]</code>qsizetype QString::indexOf(const  &amp;<em>re</em>, qsizetype <em>from</em> = 0,  *<em>rmatch</em> = nullptr) const</span><a href="#since-5-5-qsizetype-qstring-indexof-const-qregularexpression-amp-re-qsizetype-from-0-qregularexpressionmatch-rmatch-nullptr-const" class="header-anchor">#</a></h3><p>返回字符串中正则表达式 <em>re</em> 的第一个匹配的索引位置，从索引位置 <em>from</em> 向前搜索。 如果 <em>re</em> 在任何地方都不匹配，则返回 -1。</p>
<p>如果匹配成功并且 <em>rmatch</em> 不是 <code>nullptr</code>，它还将匹配结果写入 <em>rmatch</em> 指向的 <a href="qregularexpressionmatch.html">QRegularExpressionMatch</a> 对象。</p>
<p>例子:</p>
<div class="code-wrapper"><pre><code class="hljs c++">QString str = <span class="hljs-string">"the minimum"</span>;
str.<span class="hljs-built_in">indexOf</span>(<span class="hljs-built_in">QRegularExpression</span>(<span class="hljs-string">"m[aeiou]"</span>), <span class="hljs-number">0</span>);       <span class="hljs-comment">// returns 4</span>

QString str = <span class="hljs-string">"the minimum"</span>;
QRegularExpressionMatch match;
str.<span class="hljs-built_in">indexOf</span>(<span class="hljs-built_in">QRegularExpression</span>(<span class="hljs-string">"m[aeiou]"</span>), <span class="hljs-number">0</span>, &amp;match);       <span class="hljs-comment">// returns 4</span>
<span class="hljs-comment">// match.captured() == mi</span></code></pre></div>

<p>该函数在 Qt 5.5 引入。</p>
<h3><span id="qstring-amp-qstring-insert-qsizetype-position-const-qstring-amp-str"> &amp;QString::insert(qsizetype <em>position</em>, const  &amp;<em>str</em>)</span><a href="#qstring-amp-qstring-insert-qsizetype-position-const-qstring-amp-str" class="header-anchor">#</a></h3><p>在给定索引 <em>position</em> 处插入字符串 <em>str</em> 并返回对该字符串的引用。ing.</p>
<p>例子:</p>
<div class="code-wrapper"><pre><code class="hljs c++">QString str = <span class="hljs-string">"Meal"</span>;
str.<span class="hljs-built_in">insert</span>(<span class="hljs-number">1</span>, <span class="hljs-built_in">QString</span>(<span class="hljs-string">"ontr"</span>));
<span class="hljs-comment">// str == "Montreal"</span></code></pre></div>

<p>该字符串会增长以适应插入。 如果 <em>position</em> 超出字符串的末尾，则将空格字符附加到字符串以到达此 <em>position</em>，然后是 <em>str</em>。</p>
<p><strong>See also</strong> <a href="#append">append</a>(), <a href="#prepend">prepend</a>(), <a href="#replace">replace</a>(), and <a href="#remove">remove</a>().</p>
<h3><span id="qstring-amp-qstring-insert-qsizetype-position-qchar-ch"> &amp;QString::insert(qsizetype <em>position</em>,  <em>ch</em>)</span><a href="#qstring-amp-qstring-insert-qsizetype-position-qchar-ch" class="header-anchor">#</a></h3><p>这个函数重载了 insert().</p>
<p>在字符串中的给定索引 <em>position</em> 处插入 <em>ch</em>。</p>
<p>该字符串会增长以适应插入。 如果 <em>position</em> 超出字符串的末尾，则将空格字符附加到字符串以到达此 <em>position</em>，然后是 <em>ch</em>。</p>
<h3><span id="qstring-amp-qstring-insert-qsizetype-position-const-qchar-unicode-qsizetype-size"> &amp;QString::insert(qsizetype <em>position</em>, const  *<em>unicode</em>, qsizetype <em>size</em>)</span><a href="#qstring-amp-qstring-insert-qsizetype-position-const-qchar-unicode-qsizetype-size" class="header-anchor">#</a></h3><p>这个函数重载了 insert().</p>
<p>在字符串中的给定索引 <em>position</em> 处插入 <a href="qchar.html">QChar</a> 数组 <em>unicode</em> 的第一个 <em>size</em> 字符。</p>
<p>该字符串会增长以适应插入。 如果 <em>position</em> 超出字符串的末尾，则将空格字符附加到字符串以到达此 <em>position</em>，然后是 <a href="qchar.html">QChar</a> 数组 <em>unicode</em> 的 <em>size</em> 字符。</p>
<h3><span id="since-6-0-qstring-amp-qstring-insert-qsizetype-position-qstringview-str"><code>[since 6.0]</code> &amp;QString::insert(qsizetype <em>position</em>,  <em>str</em>)</span><a href="#since-6-0-qstring-amp-qstring-insert-qsizetype-position-qstringview-str" class="header-anchor">#</a></h3><p>这个函数重载了 insert().</p>
<p>在给定索引 <em>position</em> 处插入字符串视图 <em>str</em> 并返回对该字符串的引用。</p>
<p>该字符串会增长以适应插入。 如果 <em>position</em> 超出字符串的末尾，则将空格字符附加到字符串以到达此 <em>position</em>，然后是 <em>str</em>。</p>
<p>该函数在 Qt 6.0 引入。</p>
<h3><span id="qstring-amp-qstring-insert-qsizetype-position-qlatin1string-str"> &amp;QString::insert(qsizetype <em>position</em>,  <em>str</em>)</span><a href="#qstring-amp-qstring-insert-qsizetype-position-qlatin1string-str" class="header-anchor">#</a></h3><p>这个函数重载了 insert().</p>
<p>在给定索引 <em>position</em> 处插入 Latin-1 字符串 <em>str</em>。</p>
<p>该字符串会增长以适应插入。 如果 <em>position</em> 超出字符串的末尾，则将空格字符附加到字符串以到达此 <em>position</em>，然后是 <em>str</em>。</p>
<h3><span id="since-5-5-qstring-amp-qstring-insert-qsizetype-position-const-char-str"><code>[since 5.5]</code> &amp;QString::insert(qsizetype <em>position</em>, const char *<em>str</em>)</span><a href="#since-5-5-qstring-amp-qstring-insert-qsizetype-position-const-char-str" class="header-anchor">#</a></h3><p>这个函数重载了 insert().</p>
<p>在给定索引 <em>position</em> 处插入 C 字符串 <em>str</em> 并返回对该字符串的引用。</p>
<p>该字符串会增长以适应插入。 如果 <em>position</em> 超出字符串的末尾，则将空格字符附加到字符串以到达此 <em>position</em>，然后是 <em>str</em>。</p>
<p>当定义了 <a href="#QT_NO_CAST_FROM_ASCII">QT_NO_CAST_FROM_ASCII</a> 时，此函数不可用。</p>
<p>该函数在 Qt 5.5 引入。</p>
<h3><span id="since-5-5-qstring-amp-qstring-insert-qsizetype-position-const-qbytearray-amp-str"><code>[since 5.5]</code> &amp;QString::insert(qsizetype <em>position</em>, const  &amp;<em>str</em>)</span><a href="#since-5-5-qstring-amp-qstring-insert-qsizetype-position-const-qbytearray-amp-str" class="header-anchor">#</a></h3><p>这个函数重载了 insert().</p>
<p>将 <em>str</em> 的内容解释为 UTF-8，在给定索引 <em>position</em> 处插入它编码的 Unicode 字符串，并返回对该字符串的引用。</p>
<p>该字符串会增长以适应插入。 如果 <em>position</em> 超出字符串的末尾，则将空格字符附加到字符串以到达此 <em>position</em>，然后是 <em>str</em>。</p>
<p>当定义了 <a href="#QT_NO_CAST_FROM_ASCII">QT_NO_CAST_FROM_ASCII</a> 时，此函数不可用。</p>
<p>该函数在 Qt 5.5 引入。</p>
<h3><span id="bool-qstring-isempty-const">bool QString::isEmpty() const</span><a href="#bool-qstring-isempty-const" class="header-anchor">#</a></h3><p>如果字符串没有字符，则返回 <code>true</code>； 否则返回“假”。</p>
<p>例子:</p>
<div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-built_in">QString</span>().<span class="hljs-built_in">isEmpty</span>();            <span class="hljs-comment">// returns true</span>
<span class="hljs-built_in">QString</span>(<span class="hljs-string">""</span>).<span class="hljs-built_in">isEmpty</span>();          <span class="hljs-comment">// returns true</span>
<span class="hljs-built_in">QString</span>(<span class="hljs-string">"x"</span>).<span class="hljs-built_in">isEmpty</span>();         <span class="hljs-comment">// returns false</span>
<span class="hljs-built_in">QString</span>(<span class="hljs-string">"abc"</span>).<span class="hljs-built_in">isEmpty</span>();       <span class="hljs-comment">// returns false</span></code></pre></div>

<p><strong>See also</strong> <a href="#size">size</a>().</p>
<h3><span id="since-5-12-bool-qstring-islower-const"><code>[since 5.12]</code>bool QString::isLower() const</span><a href="#since-5-12-bool-qstring-islower-const" class="header-anchor">#</a></h3><p>如果字符串是小写的，则返回 <code>true</code>，也就是说，它与它的 <a href="#toLower">toLower</a>() 折叠相同。</p>
<p>请注意，这<em>不</em>意味着字符串不包含大写字母（一些大写字母没有小写折叠；它们由 <a href="#toLower">toLower</a>() 保持不变）。 有关详细信息，请参阅 Unicode 标准，第 3.13 节。</p>
<p>该函数在 Qt 5.12 引入。</p>
<p><strong>See also</strong> <a href="qchar.html#toLower">QChar::toLower</a>() and <a href="#isUpper">isUpper</a>().</p>
<h3><span id="bool-qstring-isnull-const">bool QString::isNull() const</span><a href="#bool-qstring-isnull-const" class="header-anchor">#</a></h3><p>如果此字符串为空，则返回 <code>true</code>； 否则返回“假”。</p>
<p>例子:</p>
<div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-built_in">QString</span>().<span class="hljs-built_in">isNull</span>();             <span class="hljs-comment">// returns true</span>
<span class="hljs-built_in">QString</span>(<span class="hljs-string">""</span>).<span class="hljs-built_in">isNull</span>();           <span class="hljs-comment">// returns false</span>
<span class="hljs-built_in">QString</span>(<span class="hljs-string">"abc"</span>).<span class="hljs-built_in">isNull</span>();        <span class="hljs-comment">// returns false</span></code></pre></div>

<p>由于历史原因，Qt 对空字符串和空字符串进行了区分。 对于大多数应用程序来说，重要的是字符串是否包含任何数据，这可以使用 <a href="#isEmpty">isEmpty</a>() 函数来确定。</p>
<p><strong>See also</strong> <a href="#isEmpty">isEmpty</a>().</p>
<h3><span id="bool-qstring-isrighttoleft-const">bool QString::isRightToLeft() const</span><a href="#bool-qstring-isrighttoleft-const" class="header-anchor">#</a></h3><p>如果从右到左读取字符串，则返回 <code>true</code>。</p>
<p><strong>See also</strong> <a href="qstringview.html#isRightToLeft">QStringView::isRightToLeft</a>().</p>
<h3><span id="since-5-12-bool-qstring-isupper-const"><code>[since 5.12]</code>bool QString::isUpper() const</span><a href="#since-5-12-bool-qstring-isupper-const" class="header-anchor">#</a></h3><p>如果字符串是大写的，则返回 <code>true</code>，也就是说，它与它的 <a href="#toUpper">toUpper</a>() 折叠相同。</p>
<p>请注意，这<em>不</em>意味着字符串不包含小写字母（一些小写字母没有大写折叠；它们由 <a href="#toUpper">toUpper</a>() 保持不变）。 有关详细信息，请参阅 Unicode 标准，第 3.13 节。</p>
<p>该函数在 Qt 5.12 引入。</p>
<p><strong>See also</strong> <a href="qchar.html#toUpper">QChar::toUpper</a>() and <a href="#isLower">isLower</a>().</p>
<h3><span id="since-5-15-bool-qstring-isvalidutf16-const"><code>[since 5.15]</code>bool QString::isValidUtf16() const</span><a href="#since-5-15-bool-qstring-isvalidutf16-const" class="header-anchor">#</a></h3><p>如果字符串包含有效的 UTF-16 编码数据，则返回 <code>true</code>，否则返回 <code>false</code>。</p>
<p>请注意，此函数不对数据执行任何特殊验证； 它只是检查是否可以从 UTF-16 成功解码。 假定数据按主机字节顺序排列； BOM 的存在是没有意义的。</p>
<p>该函数在 Qt 5.15 引入。</p>
<p><strong>See also</strong> <a href="qstringview.html#isValidUtf16">QStringView::isValidUtf16</a>().</p>
<h3><span id="since-6-0-qstring-qstring-last-qsizetype-n-const"><code>[since 6.0]</code> QString::last(qsizetype <em>n</em>) const</span><a href="#since-6-0-qstring-qstring-last-qsizetype-n-const" class="header-anchor">#</a></h3><p>返回包含此字符串的最后 <em>n</em> 个字符的字符串。</p>
<p><strong>注意：</strong> 当 <em>n</em> &lt; 0 或 *n* &gt; <a href="#size">size</a>() 时，行为未定义。</p>
<div class="code-wrapper"><pre><code class="hljs c++">QString x = <span class="hljs-string">"Pineapple"</span>;
QString y = x.<span class="hljs-built_in">last</span>(<span class="hljs-number">5</span>);      <span class="hljs-comment">// y == "apple"</span></code></pre></div>

<p>该函数在 Qt 6.0 引入。</p>
<p><strong>See also</strong> <a href="#first">first</a>(), <a href="#sliced">sliced</a>(), <a href="#endsWith">endsWith</a>(), <a href="#chopped">chopped</a>(), <a href="#chop">chop</a>(), and <a href="#truncate">truncate</a>().</p>
<h3><span id="qsizetype-qstring-lastindexof-const-qstring-amp-str-qsizetype-from-qt-casesensitivity-cs-qt-casesensitive-const">qsizetype QString::lastIndexOf(const  &amp;<em>str</em>, qsizetype <em>from</em>,  <em>cs</em> = Qt::CaseSensitive) const</span><a href="#qsizetype-qstring-lastindexof-const-qstring-amp-str-qsizetype-from-qt-casesensitivity-cs-qt-casesensitive-const" class="header-anchor">#</a></h3><p>返回此字符串中最后一次出现的字符串 <em>str</em> 的索引位置，从索引位置 <em>from</em> 向后搜索。 如果 <em>from</em> 为 -1，则从最后一个字符开始搜索； 如果 <em>from</em> 为 -2，则在倒数第二个字符处，依此类推。 如果没有找到 <em>str</em>，则返回 -1。</p>
<p>如果 <em>cs</em> 是 <a href="qt.html#CaseSensitivity-enum">Qt::CaseSensitive</a> （默认），则搜索区分大小写； 否则搜索不区分大小写。</p>
<p>例子:</p>
<div class="code-wrapper"><pre><code class="hljs c++">QString x = <span class="hljs-string">"crazy azimuths"</span>;
QString y = <span class="hljs-string">"az"</span>;
x.<span class="hljs-built_in">lastIndexOf</span>(y);           <span class="hljs-comment">// returns 6</span>
x.<span class="hljs-built_in">lastIndexOf</span>(y, <span class="hljs-number">6</span>);        <span class="hljs-comment">// returns 6</span>
x.<span class="hljs-built_in">lastIndexOf</span>(y, <span class="hljs-number">5</span>);        <span class="hljs-comment">// returns 2</span>
x.<span class="hljs-built_in">lastIndexOf</span>(y, <span class="hljs-number">1</span>);        <span class="hljs-comment">// returns -1</span></code></pre></div>

<p><strong>注意：</strong> 当搜索长度为 0 的 <em>str</em> 时，数据末尾的匹配会被否定的 <em>from</em> 排除在搜索之外，即使通常认为 <code>-1</code> 是从搜索开始 字符串的结尾：结尾的匹配是<em>在</em>最后一个字符之后，所以它被排除在外。 要包含这样一个最终的空匹配，要么给 <em>from</em> 一个正值，要么完全省略 <em>from</em> 参数。</p>
<p><strong>See also</strong> <a href="#indexOf">indexOf</a>(), <a href="#contains">contains</a>(), and <a href="#count-1">count</a>().</p>
<h3><span id="qsizetype-qstring-lastindexof-qchar-ch-qsizetype-from-1-qt-casesensitivity-cs-qt-casesensitive-const">qsizetype QString::lastIndexOf( <em>ch</em>, qsizetype <em>from</em> = -1,  <em>cs</em> = Qt::CaseSensitive) const</span><a href="#qsizetype-qstring-lastindexof-qchar-ch-qsizetype-from-1-qt-casesensitivity-cs-qt-casesensitive-const" class="header-anchor">#</a></h3><p>这个函数重载了 lastIndexOf().</p>
<p>返回字符 <em>ch</em> 最后一次出现的索引位置，从位置 <em>from</em> 向后搜索。</p>
<h3><span id="since-6-2-qsizetype-qstring-lastindexof-qlatin1string-str-qt-casesensitivity-cs-qt-casesensitive-const"><code>[since 6.2]</code>qsizetype QString::lastIndexOf( <em>str</em>,  <em>cs</em> = Qt::CaseSensitive) const</span><a href="#since-6-2-qsizetype-qstring-lastindexof-qlatin1string-str-qt-casesensitivity-cs-qt-casesensitive-const" class="header-anchor">#</a></h3><p>这个函数重载了 lastIndexOf().</p>
<p>返回此字符串中最后一次出现的字符串 <em>str</em> 的索引位置。 如果没有找到 <em>str</em>，则返回 -1。</p>
<p>如果 <em>cs</em> 是 <a href="qt.html#CaseSensitivity-enum">Qt::CaseSensitive</a> （默认），则搜索区分大小写； 否则搜索不区分大小写。</p>
<p>例子:</p>
<div class="code-wrapper"><pre><code class="hljs c++">QString x = <span class="hljs-string">"crazy azimuths"</span>;

QString y = <span class="hljs-string">"az"</span>;
x.<span class="hljs-built_in">lastIndexOf</span>(y);           (y);           <span class="hljs-comment">// returns 6</span>
x.<span class="hljs-built_in">lastIndexOf</span>(<span class="hljs-built_in">y</span>(y, <span class="hljs-number">6</span>);                <span class="hljs-comment">// returns 6</span>
x.<span class="hljs-built_in">lastIndexOf</span>(<span class="hljs-built_in">y</span>(y, <span class="hljs-number">5</span>);                <span class="hljs-comment">// returns 2</span>
x.<span class="hljs-built_in">lastIndexOf</span>(<span class="hljs-built_in">y</span>(y, <span class="hljs-number">1</span>);                <span class="hljs-comment">// returns -1</span></code></pre></div>

<p>该函数在 Qt 6.2 引入。</p>
<p><strong>See also</strong> <a href="#indexOf">indexOf</a>(), <a href="#contains">contains</a>(), and <a href="#count-1">count</a>().</p>
<h3><span id="qsizetype-qstring-lastindexof-qlatin1string-str-qsizetype-from-qt-casesensitivity-cs-qt-casesensitive-const">qsizetype QString::lastIndexOf( <em>str</em>, qsizetype <em>from</em>,  <em>cs</em> = Qt::CaseSensitive) const</span><a href="#qsizetype-qstring-lastindexof-qlatin1string-str-qsizetype-from-qt-casesensitivity-cs-qt-casesensitive-const" class="header-anchor">#</a></h3><p>这个函数重载了 lastIndexOf().</p>
<p>返回此字符串中最后一次出现的字符串 <em>str</em> 的索引位置，从索引位置 <em>from</em> 向后搜索。 如果 <em>from</em> 为 -1，则从最后一个字符开始搜索； 如果 <em>from</em> 为 -2，则在倒数第二个字符处，依此类推。 如果没有找到 <em>str</em>，则返回 -1。</p>
<p>如果 <em>cs</em> 是 <a href="qt.html#CaseSensitivity-enum">Qt::CaseSensitive</a> （默认），则搜索区分大小写； 否则搜索不区分大小写。</p>
<p>例子:</p>
<div class="code-wrapper"><pre><code class="hljs c++">QString x = <span class="hljs-string">"crazy azimuths"</span>;
QString y = <span class="hljs-string">"az"</span>;
x.<span class="hljs-built_in">lastIndexOf</span>(y);           <span class="hljs-comment">// returns 6</span>
x.<span class="hljs-built_in">lastIndexOf</span>(y, <span class="hljs-number">6</span>);        <span class="hljs-comment">// returns 6</span>
x.<span class="hljs-built_in">lastIndexOf</span>(y, <span class="hljs-number">5</span>);        <span class="hljs-comment">// returns 2</span>
x.<span class="hljs-built_in">lastIndexOf</span>(y, <span class="hljs-number">1</span>);        <span class="hljs-comment">// returns -1</span></code></pre></div>

<p><strong>注意：</strong> 当搜索长度为 0 的 <em>str</em> 时，数据末尾的匹配会被否定的 <em>from</em> 排除在搜索之外，即使通常认为 <code>-1</code> 是从搜索开始 字符串的结尾：结尾的匹配是<em>在</em>最后一个字符之后，所以它被排除在外。 要包含这样一个最终的空匹配，要么给 <em>from</em> 一个正值，要么完全省略 <em>from</em> 参数。</p>
<p><strong>See also</strong> <a href="#indexOf">indexOf</a>(), <a href="#contains">contains</a>(), and <a href="#count-1">count</a>().</p>
<h3><span id="since-6-2-qsizetype-qstring-lastindexof-const-qstring-amp-str-qt-casesensitivity-cs-qt-casesensitive-const"><code>[since 6.2]</code>qsizetype QString::lastIndexOf(const  &amp;<em>str</em>,  <em>cs</em> = Qt::CaseSensitive) const</span><a href="#since-6-2-qsizetype-qstring-lastindexof-const-qstring-amp-str-qt-casesensitivity-cs-qt-casesensitive-const" class="header-anchor">#</a></h3><p>这个函数重载了 lastIndexOf().</p>
<p>返回此字符串中最后一次出现的字符串 <em>str</em> 的索引位置。 如果没有找到 <em>str</em>，则返回 -1。</p>
<p>如果 <em>cs</em> 是 <a href="qt.html#CaseSensitivity-enum">Qt::CaseSensitive</a> （默认），则搜索区分大小写； 否则搜索不区分大小写。</p>
<p>例子:</p>
<div class="code-wrapper"><pre><code class="hljs c++">QString x = <span class="hljs-string">"crazy azimuths"</span>;
QString y = <span class="hljs-string">"az"</span>;
x.<span class="hljs-built_in">lastIndexOf</span>(y);           <span class="hljs-comment">// returns 6</span>
x.<span class="hljs-built_in">lastIndexOf</span>(y, <span class="hljs-number">6</span>);        <span class="hljs-comment">// returns 6</span>
x.<span class="hljs-built_in">lastIndexOf</span>(y, <span class="hljs-number">5</span>);        <span class="hljs-comment">// returns 2</span>
x.<span class="hljs-built_in">lastIndexOf</span>(y, <span class="hljs-number">1</span>);        <span class="hljs-comment">// returns -1</span></code></pre></div>

<p>该函数在 Qt 6.2 引入。</p>
<p><strong>See also</strong> <a href="#indexOf">indexOf</a>(), <a href="#contains">contains</a>(), and <a href="#count-1">count</a>().</p>
<h3><span id="since-6-2-qsizetype-qstring-lastindexof-qstringview-str-qt-casesensitivity-cs-qt-casesensitive-const"><code>[since 6.2]</code>qsizetype QString::lastIndexOf( <em>str</em>,  <em>cs</em> = Qt::CaseSensitive) const</span><a href="#since-6-2-qsizetype-qstring-lastindexof-qstringview-str-qt-casesensitivity-cs-qt-casesensitive-const" class="header-anchor">#</a></h3><p>这个函数重载了 lastIndexOf().</p>
<p>返回此字符串中最后一次出现的字符串视图 <em>str</em> 的索引位置。 如果没有找到 <em>str</em>，则返回 -1。</p>
<p>如果 <em>cs</em> 是 <a href="qt.html#CaseSensitivity-enum">Qt::CaseSensitive</a> （默认），则搜索区分大小写； 否则搜索不区分大小写。</p>
<p>该函数在 Qt 6.2 引入。</p>
<p><strong>See also</strong> <a href="#indexOf">indexOf</a>(), <a href="#contains">contains</a>(), and <a href="#count-1">count</a>().</p>
<h3><span id="since-5-14-qsizetype-qstring-lastindexof-qstringview-str-qsizetype-from-qt-casesensitivity-cs-qt-casesensitive-const"><code>[since 5.14]</code>qsizetype QString::lastIndexOf( <em>str</em>, qsizetype <em>from</em>,  <em>cs</em> = Qt::CaseSensitive) const</span><a href="#since-5-14-qsizetype-qstring-lastindexof-qstringview-str-qsizetype-from-qt-casesensitivity-cs-qt-casesensitive-const" class="header-anchor">#</a></h3><p>这个函数重载了 lastIndexOf().</p>
<p>返回此字符串中最后一次出现的字符串视图 <em>str</em> 的索引位置，从索引位置 <em>from</em> 向后搜索。 如果 <em>from</em> 为 -1，则从最后一个字符开始搜索； 如果 <em>from</em> 为 -2，则在倒数第二个字符处，依此类推。 如果没有找到 <em>str</em>，则返回 -1。</p>
<p>如果 <em>cs</em> 是 <a href="qt.html#CaseSensitivity-enum">Qt::CaseSensitive</a> （默认），则搜索区分大小写； 否则搜索不区分大小写。</p>
<p><strong>注意：</strong> 当搜索长度为 0 的 <em>str</em> 时，数据末尾的匹配会被否定的 <em>from</em> 排除在搜索之外，即使通常认为 <code>-1</code> 是从搜索开始 字符串的结尾：结尾的匹配是<em>在</em>最后一个字符之后，所以它被排除在外。 要包含这样一个最终的空匹配，要么给 <em>from</em> 一个正值，要么完全省略 <em>from</em> 参数。</p>
<p>该函数在 Qt 5.14 引入。</p>
<p><strong>See also</strong> <a href="#indexOf">indexOf</a>(), <a href="#contains">contains</a>(), and <a href="#count-1">count</a>().</p>
<h3><span id="since-6-2-qsizetype-qstring-lastindexof-const-qregularexpression-amp-re-qregularexpressionmatch-rmatch-nullptr-const"><code>[since 6.2]</code>qsizetype QString::lastIndexOf(const  &amp;<em>re</em>,  *<em>rmatch</em> = nullptr) const</span><a href="#since-6-2-qsizetype-qstring-lastindexof-const-qregularexpression-amp-re-qregularexpressionmatch-rmatch-nullptr-const" class="header-anchor">#</a></h3><p>这个函数重载了 lastIndexOf().</p>
<p>Returns the index position of the last match of the regular expression <em>re</em> in the string. Returns -1 if <em>re</em> didn’t match anywhere.</p>
<p>如果匹配成功并且 <em>rmatch</em> 不是 <code>nullptr</code>，它还将匹配结果写入 <em>rmatch</em> 指向的 <a href="qregularexpressionmatch.html">QRegularExpressionMatch</a> 对象。</p>
<p>例子:</p>
<div class="code-wrapper"><pre><code class="hljs c++">QString str = <span class="hljs-string">"the minimum"</span>;
str.<span class="hljs-built_in">lastIndexOf</span>(<span class="hljs-built_in">QRegularExpression</span>(<span class="hljs-string">"m[aeiou]"</span>));      <span class="hljs-comment">// returns 8</span>

QString str = <span class="hljs-string">"the minimum"</span>;
QRegularExpressionMatch match;
str.<span class="hljs-built_in">lastIndexOf</span>(<span class="hljs-built_in">QRegularExpression</span>(<span class="hljs-string">"m[aeiou]"</span>), <span class="hljs-number">-1</span>, &amp;match);      <span class="hljs-comment">// returns 8</span>
<span class="hljs-comment">// match.captured() == mu</span></code></pre></div>

<p><strong>Note:</strong> Due to how the regular expression matching algorithm works, this function will actually match repeatedly from the beginning of the string until the end of the string is reached.</p>
<p>该函数在 Qt 6.2 引入。</p>
<h3><span id="since-5-5-qsizetype-qstring-lastindexof-const-qregularexpression-amp-re-qsizetype-from-qregularexpressionmatch-rmatch-nullptr-const"><code>[since 5.5]</code>qsizetype QString::lastIndexOf(const  &amp;<em>re</em>, qsizetype <em>from</em>,  *<em>rmatch</em> = nullptr) const</span><a href="#since-5-5-qsizetype-qstring-lastindexof-const-qregularexpression-amp-re-qsizetype-from-qregularexpressionmatch-rmatch-nullptr-const" class="header-anchor">#</a></h3><p>返回字符串中正则表达式 <em>re</em> 的最后一个匹配项的索引位置，该位置在索引位置 <em>from</em> 之前开始。 如果 <em>from</em> 为 -1，则从最后一个字符开始搜索； 如果 <em>from</em> 为 -2，则在倒数第二个字符处，依此类推。 如果 <em>re</em> 在任何地方都不匹配，则返回 -1。</p>
<p>如果匹配成功且 <em>rmatch</em> 不是 <code>nullptr</code>，它还将匹配结果写入 <em>rmatch</em> 指向的 <a href="qregularexpressionmatch.html">QRegularExpressionMatch</a> 对象</p>
<p>例子:</p>
<div class="code-wrapper"><pre><code class="hljs c++">QString str = <span class="hljs-string">"the minimum"</span>;
str.<span class="hljs-built_in">lastIndexOf</span>((<span class="hljs-built_in">QRegularExpression</span>(<span class="hljs-string">"m[aeiou]"</span>));            <span class="hljs-comment">// returns 8</span>

QString str = <span class="hljs-string">"the minimum"</span>;

QRegularExpressionMatch match;;
str.<span class="hljs-built_in">lastIndexOf</span>((<span class="hljs-built_in">QRegularExpression</span>(<span class="hljs-string">"m[aeiou]"</span>), <span class="hljs-number">-1</span>, &amp;match);      );      <span class="hljs-comment">// returns 8</span>
<span class="hljs-comment">// match.captured() == mu</span></code></pre></div>

<p><strong>注意：</strong> 由于正则表达式匹配算法的工作原理，这个函数实际上会从字符串的开头重复匹配，直到到达 <em>from</em> 位置。</p>
<p><strong>注意：</strong> 当搜索可能匹配 0 个字符的正则表达式 <em>re</em> 时，数据末尾的匹配会被否定的 <em>from</em> 排除在搜索之外，即使通常认为是 <code>-1</code> 的 as 从字符串的末尾开始搜索：末尾的匹配是<em>在</em>最后一个字符之后，所以它被排除在外。 要包含这样一个最终的空匹配，要么给 <em>from</em> 一个正值，要么完全省略 <em>from</em> 参数。</p>
<p>该函数在 Qt 5.5 引入。</p>
<h3><span id="qstring-qstring-left-qsizetype-n-const"> QString::left(qsizetype <em>n</em>) const</span><a href="#qstring-qstring-left-qsizetype-n-const" class="header-anchor">#</a></h3><p>返回包含字符串最左边 <em>n</em> 个字符的子字符串。</p>
<p>如果您知道 <em>n</em> 不能越界，请在新代码中使用 <a href="#first">first</a>() 代替，因为它更快。</p>
<p>如果 <em>n</em> 大于或等于 <a href="#size">size</a>() 或小于零，则返回整个字符串。</p>
<p><strong>See also</strong> <a href="#first">first</a>(), <a href="#last">last</a>(), <a href="#startsWith">startsWith</a>(), <a href="#chopped">chopped</a>(), <a href="#chop">chop</a>(), and <a href="#truncate">truncate</a>().</p>
<h3><span id="qstring-qstring-leftjustified-qsizetype-width-qchar-fill-qlatin1char-bool-truncate-false-const"> QString::leftJustified(qsizetype <em>width</em>,  <em>fill</em> = QLatin1Char(‘ ‘), bool <em>truncate</em> = false) const</span><a href="#qstring-qstring-leftjustified-qsizetype-width-qchar-fill-qlatin1char-bool-truncate-false-const" class="header-anchor">#</a></h3><p>返回一个大小为 <em>width</em> 的字符串，其中包含由 <em>fill</em> 字符填充的该字符串。</p>
<p>如果 <em>truncate</em> 为 <code>false</code> 并且字符串的 <a href="#size">size</a>() 大于 <em>width</em>，则返回的字符串是字符串的副本。</p>
<div class="code-wrapper"><pre><code class="hljs c++">QString s = <span class="hljs-string">"apple"</span>;
QString t = s.<span class="hljs-built_in">leftJustified</span>(<span class="hljs-number">8</span>, <span class="hljs-string">'.'</span>);    <span class="hljs-comment">// t == "apple..."</span></code></pre></div>

<p>如果 <em>truncate</em> 为 <code>true</code> 且字符串的 <a href="#size">size</a>() 大于 <em>width</em>，则删除位置 <em>width</em> 之后的字符串副本中的所有字符，副本为 回来。</p>
<div class="code-wrapper"><pre><code class="hljs c++">QString str = <span class="hljs-string">"Pineapple"</span>;
str = str.<span class="hljs-built_in">leftJustified</span>(<span class="hljs-number">5</span>, <span class="hljs-string">'.'</span>, <span class="hljs-literal">true</span>);    <span class="hljs-comment">// str == "Pinea"</span></code></pre></div>

<p><strong>See also</strong> <a href="#rightJustified">rightJustified</a>().</p>
<h3><span id="qsizetype-qstring-length-const">qsizetype QString::length() const</span><a href="#qsizetype-qstring-length-const" class="header-anchor">#</a></h3><p>返回此字符串中的字符数。 等效于 <a href="#size">size</a>()。</p>
<p><strong>See also</strong> <a href="#resize">resize</a>().</p>
<h3><span id="static-int-qstring-localeawarecompare-const-qstring-amp-s1-const-qstring-amp-s2"><code>[static]</code>int QString::localeAwareCompare(const  &amp;<em>s1</em>, const  &amp;<em>s2</em>)</span><a href="#static-int-qstring-localeawarecompare-const-qstring-amp-s1-const-qstring-amp-s2" class="header-anchor">#</a></h3><p>比较 <em>s1</em> 和 <em>s2</em>，如果 <em>s1</em> 小于、等于或大于 <em>s2</em>，则返回小于、等于或大于零的整数。</p>
<p>比较以区域设置和平台相关的方式执行。 使用此函数向用户呈现已排序的字符串列表。</p>
<p><strong>See also</strong> <a href="#compare">compare</a>(), <a href="qlocale.html">QLocale</a>, and <a href="#comparing-strings">Comparing Strings</a>.</p>
<h3><span id="int-qstring-localeawarecompare-const-qstring-amp-other-const">int QString::localeAwareCompare(const  &amp;<em>other</em>) const</span><a href="#int-qstring-localeawarecompare-const-qstring-amp-other-const" class="header-anchor">#</a></h3><p>这个函数重载了 localeAwareCompare().</p>
<p>将此字符串与 <em>other</em> 字符串进行比较，如果此字符串小于、等于或大于 <em>other</em> 字符串，则返回小于、等于或大于零的整数。</p>
<p>比较以区域设置和平台相关的方式执行。 使用此函数向用户呈现已排序的字符串列表。</p>
<p>Same as <code>localeAwareCompare(*this, other)</code>.</p>
<p><strong>See also</strong> <a href="#comparing-strings">Comparing Strings</a>.</p>
<h3><span id="since-6-0-int-qstring-localeawarecompare-qstringview-other-const"><code>[since 6.0]</code>int QString::localeAwareCompare( <em>other</em>) const</span><a href="#since-6-0-int-qstring-localeawarecompare-qstringview-other-const" class="header-anchor">#</a></h3><p>这个函数重载了 localeAwareCompare().</p>
<p>将此字符串与 <em>other</em> 字符串进行比较，如果此字符串小于、等于或大于 <em>other</em> 字符串，则返回小于、等于或大于零的整数。</p>
<p>比较以区域设置和平台相关的方式执行。 使用此函数向用户呈现已排序的字符串列表。</p>
<p>Same as <code>localeAwareCompare(*this, other)</code>.</p>
<p>该函数在 Qt 6.0 引入。</p>
<p><strong>See also</strong> <a href="#comparing-strings">Comparing Strings</a>.</p>
<h3><span id="static-since-6-0-int-qstring-localeawarecompare-qstringview-s1-qstringview-s2"><code>[static, since 6.0]</code>int QString::localeAwareCompare( <em>s1</em>,  <em>s2</em>)</span><a href="#static-since-6-0-int-qstring-localeawarecompare-qstringview-s1-qstringview-s2" class="header-anchor">#</a></h3><p>这个函数重载了 localeAwareCompare().</p>
<p>将<em>s1</em>与<em>s2</em>进行比较，如果<em>s1</em>小于、等于或大于<em>s2</em>，则返回一个小于、等于或大于零的整数。</p>
<p>比较以区域设置和平台相关的方式执行。使用此函数向用户呈现已排序的字符串列表。</p>
<p>该函数在 Qt 6.0 引入。</p>
<p><strong>See also</strong> <a href="#comparing-strings">Comparing Strings</a>.</p>
<h3><span id="qstring-qstring-mid-qsizetype-position-qsizetype-n-1-const"> QString::mid(qsizetype <em>position</em>, qsizetype <em>n</em> = -1) const</span><a href="#qstring-qstring-mid-qsizetype-position-qsizetype-n-1-const" class="header-anchor">#</a></h3><p>返回一个包含此字符串的<em>n</em>个字符的字符串，从指定<em>position</em>索引开始。</p>
<p>如果您知道 <em>position</em> 和 <em>n</em> 不能越界，请在新代码中使用 <a href="#sliced">sliced</a>() 代替，因为它更快。</p>
<p>如果 <em>position</em> 索引超过字符串的长度，则返回空字符串。 如果从给定 <em>position</em> 开始的字符串中可用的字符少于 <em>n</em>，或者如果 <em>n</em> 为 -1（默认值），则该函数返回从指定 <em>position</em> 开始的所有可用字符。</p>
<p><strong>See also</strong> <a href="#first">first</a>(), <a href="#last">last</a>(), <a href="#sliced">sliced</a>(), <a href="#chopped">chopped</a>(), <a href="#chop">chop</a>(), and <a href="#truncate">truncate</a>().</p>
<h3><span id="qstring-qstring-normalized-qstring-normalizationform-mode-qchar-unicodeversion-version-qchar-unicode-unassigned-const"> QString::normalized( <em>mode</em>,  <em>version</em> = QChar::Unicode_Unassigned) const</span><a href="#qstring-qstring-normalized-qstring-normalizationform-mode-qchar-unicodeversion-version-qchar-unicode-unassigned-const" class="header-anchor">#</a></h3><p>根据给定的 Unicode 标准 <em>version</em>，返回给定 Unicode 规范化 <em>mode</em> 中的字符串。</p>
<h3><span id="static-qstring-qstring-number-long-n-int-base-10"><code>[static]</code> QString::number(long <em>n</em>, int <em>base</em> = 10)</span><a href="#static-qstring-qstring-number-long-n-int-base-10" class="header-anchor">#</a></h3><p>根据指定的 <em>base</em> 返回与数字 <em>n</em> 等效的字符串。</p>
<p>默认情况下，基数为 10，并且必须介于 2 和 36 之间。对于 10 以外的基数，<em>n</em> 被视为无符号整数。</p>
<p>格式始终使用 <a href="qlocale.html#Language-enum">QLocale::C</a>，即 English/UnitedStates。 要获得数字的本地化字符串表示，请使用带有适当语言环境的 <a href="qlocale.html#toString">QLocale::toString</a>()。</p>
<div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-type">long</span> a = <span class="hljs-number">63</span>;
QString s = QString::<span class="hljs-built_in">number</span>(a, <span class="hljs-number">16</span>);             <span class="hljs-comment">// s == "3f"</span>
QString t = QString::<span class="hljs-built_in">number</span>(a, <span class="hljs-number">16</span>).<span class="hljs-built_in">toUpper</span>();     <span class="hljs-comment">// t == "3F"</span></code></pre></div>

<p><strong>See also</strong> <a href="#setNum">setNum</a>().</p>
<h3><span id="static-qstring-qstring-number-int-n-int-base-10"><code>[static]</code> QString::number(int <em>n</em>, int <em>base</em> = 10)</span><a href="#static-qstring-qstring-number-int-n-int-base-10" class="header-anchor">#</a></h3><p>这是一个重载函数。</p>
<h3><span id="static-qstring-qstring-number-uint-n-int-base-10"><code>[static]</code> QString::number( <em>n</em>, int <em>base</em> = 10)</span><a href="#static-qstring-qstring-number-uint-n-int-base-10" class="header-anchor">#</a></h3><p>这是一个重载函数。</p>
<h3><span id="static-qstring-qstring-number-ulong-n-int-base-10"><code>[static]</code> QString::number( <em>n</em>, int <em>base</em> = 10)</span><a href="#static-qstring-qstring-number-ulong-n-int-base-10" class="header-anchor">#</a></h3><p>这是一个重载函数。</p>
<h3><span id="static-qstring-qstring-number-qlonglong-n-int-base-10"><code>[static]</code> QString::number( <em>n</em>, int <em>base</em> = 10)</span><a href="#static-qstring-qstring-number-qlonglong-n-int-base-10" class="header-anchor">#</a></h3><p>这是一个重载函数。</p>
<h3><span id="static-qstring-qstring-number-qulonglong-n-int-base-10"><code>[static]</code> QString::number( <em>n</em>, int <em>base</em> = 10)</span><a href="#static-qstring-qstring-number-qulonglong-n-int-base-10" class="header-anchor">#</a></h3><p>这是一个重载函数。</p>
<h3><span id="static-qstring-qstring-number-double-n-char-format-g-int-precision-6"><code>[static]</code> QString::number(double <em>n</em>, char <em>format</em> = ‘g’, int <em>precision</em> = 6)</span><a href="#static-qstring-qstring-number-double-n-char-format-g-int-precision-6" class="header-anchor">#</a></h3><p>返回表示浮点数 <em>n</em> 的字符串。</p>
<p>返回一个表示 <em>n</em> 的字符串，根据指定的 <em>format</em> 和 <em>precision</em> 格式化。</p>
<p>对于具有指数的格式，指数将显示其符号并至少有两位数，如果需要，用零填充指数。</p>
<p><strong>另见</strong> <a href="#setNum">setNum</a>()、<a href="qlocale.html#toString">QLocale::toString</a>()、<a href="qlocale.html#FloatingPointPrecisionOption-enum">QLocale::FloatingPointPrecisionOption</a> 和 <a href="#number-formats"> 数字格式</a>。</p>
<h3><span id="qstring-amp-qstring-prepend-const-qstring-amp-str"> &amp;QString::prepend(const  &amp;<em>str</em>)</span><a href="#qstring-amp-qstring-prepend-const-qstring-amp-str" class="header-anchor">#</a></h3><p>将字符串 <em>str</em> 添加到此字符串的开头并返回对该字符串的引用。</p>
<p>这个操作通常非常快（<a href="containers.html#constant-time">constant time</a>），因为 <a href>QString</a> 在字符串数据的开头预先分配了额外的空间，所以它可以增长而无需每次都重新分配整个字符串 .</p>
<p>例子:</p>
<div class="code-wrapper"><pre><code class="hljs c++">QString x = <span class="hljs-string">"ship"</span>;
QString y = <span class="hljs-string">"air"</span>;
x.<span class="hljs-built_in">prepend</span>(y);
<span class="hljs-comment">// x == "airship"</span></code></pre></div>

<p><strong>See also</strong> <a href="#append">append</a>() and <a href="#insert">insert</a>().</p>
<h3><span id="qstring-amp-qstring-prepend-qchar-ch"> &amp;QString::prepend( <em>ch</em>)</span><a href="#qstring-amp-qstring-prepend-qchar-ch" class="header-anchor">#</a></h3><p>这个函数重载了 prepend().</p>
<p>将字符 <em>ch</em> 添加到此字符串。</p>
<h3><span id="since-5-5-qstring-amp-qstring-prepend-const-qchar-str-qsizetype-len"><code>[since 5.5]</code> &amp;QString::prepend(const  *<em>str</em>, qsizetype <em>len</em>)</span><a href="#since-5-5-qstring-amp-qstring-prepend-const-qchar-str-qsizetype-len" class="header-anchor">#</a></h3><p>这个函数重载了 prepend().</p>
<p>将 <a href="qchar.html">QChar</a> 数组 <em>str</em> 中的 <em>len</em> 字符添加到此字符串并返回对该字符串的引用。</p>
<p>该函数在 Qt 5.5 引入。</p>
<h3><span id="cong-6-0-kai-shi-qstring-amp-qstring-prepend-qstringview-str"><code>[从 6.0 开始]</code> &amp;QString::prepend( <em>str</em>)</span><a href="#cong-6-0-kai-shi-qstring-amp-qstring-prepend-qstringview-str" class="header-anchor">#</a></h3><p>这个函数重载了 prepend()。</p>
<p>将字符串视图 <em>str</em> 添加到此字符串的开头并返回对该字符串的引用。</p>
<p>该函数在 Qt 6.0 引入。</p>
<h3><span id="qstring-amp-qstring-prepend-qlatin1string-str"> &amp;QString::prepend( <em>str</em>)</span><a href="#qstring-amp-qstring-prepend-qlatin1string-str" class="header-anchor">#</a></h3><p>这个函数重载了 prepend().</p>
<p>将 Latin-1 字符串 <em>str</em> 添加到此字符串。</p>
<h3><span id="qstring-amp-qstring-prepend-const-char-str"> &amp;QString::prepend(const char *<em>str</em>)</span><a href="#qstring-amp-qstring-prepend-const-char-str" class="header-anchor">#</a></h3><p>这个函数重载了 prepend().</p>
<p>将字符串 <em>str</em> 添加到此字符串。 使用 <a href="#fromUtf8">fromUtf8</a>() 函数将 const char 指针转换为 Unicode。</p>
<p>您可以通过在编译应用程序时定义 <a href="#QT_NO_CAST_FROM_ASCII">QT_NO_CAST_FROM_ASCII</a> 来禁用此功能。 例如，如果您想确保所有用户可见的字符串都通过 <a href="qobject.html#tr">QObject::tr</a>()，这将很有用。</p>
<h3><span id="qstring-amp-qstring-prepend-const-qbytearray-amp-ba"> &amp;QString::prepend(const  &amp;<em>ba</em>)</span><a href="#qstring-amp-qstring-prepend-const-qbytearray-amp-ba" class="header-anchor">#</a></h3><p>这个函数重载了 prepend().</p>
<p>将字节数组 <em>ba</em> 添加到此字符串。 使用 <a href="#fromUtf8">fromUtf8</a>() 函数将字节数组转换为 Unicode。</p>
<p>您可以通过在编译应用程序时定义 <a href="#QT_NO_CAST_FROM_ASCII">QT_NO_CAST_FROM_ASCII</a> 来禁用此功能。 例如，如果您想确保所有用户可见的字符串都通过 <a href="qobject.html#tr">QObject::tr</a>()，这将很有用。</p>
<h3><span id="void-qstring-push-back-const-qstring-amp-other">void QString::push_back(const  &amp;<em>other</em>)</span><a href="#void-qstring-push-back-const-qstring-amp-other" class="header-anchor">#</a></h3><p>提供此函数是为了与 STL 兼容，将给定的 <em>other</em> 字符串附加到此字符串的末尾。 它相当于<code>append(other)</code>。</p>
<p><strong>See also</strong> <a href="#append">append</a>().</p>
<h3><span id="void-qstring-push-back-qchar-ch">void QString::push_back( <em>ch</em>)</span><a href="#void-qstring-push-back-qchar-ch" class="header-anchor">#</a></h3><p>这是一个重载函数。</p>
<p>将给定的 <em>ch</em> 字符附加到此字符串的末尾。</p>
<h3><span id="void-qstring-push-front-const-qstring-amp-other">void QString::push_front(const  &amp;<em>other</em>)</span><a href="#void-qstring-push-front-const-qstring-amp-other" class="header-anchor">#</a></h3><p>提供此函数是为了与 STL 兼容，将给定的 <em>other</em> 字符串添加到此字符串的开头。它相当于<code>prepend(other)</code>。</p>
<p><strong>另见</strong> <a href="#prepend">prepend</a>()。</p>
<h3><span id="void-qstring-push-front-qchar-ch">void QString::push_front( <em>ch</em>)</span><a href="#void-qstring-push-front-qchar-ch" class="header-anchor">#</a></h3><p>这是一个重载函数。</p>
<p>将给定的 <em>ch</em> 字符添加到此字符串的开头。</p>
<h3><span id="5-6-qi-qstring-reverse-iterator-qstring-rbegin"><code>[5.6 起]</code> QString::rbegin()</span><a href="#5-6-qi-qstring-reverse-iterator-qstring-rbegin" class="header-anchor">#</a></h3><p>返回一个 <a href="containers.html#stl-style-iterators">STL-style</a> 反向迭代器，以相反的顺序指向字符串中的第一个字符。</p>
<p><strong>：</strong>返回的 <a href>QString 在警告或修改</a> 时。</p>
<p>该函数在 Qt 5.6 引入。</p>
<p><strong>另请参阅</strong> <a href="#begin">begin</a>()、<a href="#crbegin">crbegin</a>() 和 <a href="#rend">rend</a>()。</p>
<h3><span id="5-6-qi-qstring-const-reverse-iterator-qstring-rbegin-const"><code>[5.6 起]</code> QString::rbegin() const</span><a href="#5-6-qi-qstring-const-reverse-iterator-qstring-rbegin-const" class="header-anchor">#</a></h3><p>这是一个重载函数。</p>
<p>该函数在 Qt 5.6 引入。</p>
<h3><span id="qstring-amp-qstring-remove-qsizetype-position-qsizetype-n"> &amp;QString::remove(qsizetype <em>position</em>, qsizetype <em>n</em>)</span><a href="#qstring-amp-qstring-remove-qsizetype-position-qsizetype-n" class="header-anchor">#</a></h3><p>从字符串中删除 <em>n</em> 个字符，从给定的 <em>position</em> 索引开始，并返回对字符串的引用。</p>
<p>如果指定的 <em>position</em> 索引在字符串内，但 <em>position</em> + <em>n</em> 超出字符串的末尾，则在指定的 <em>position</em> 处截断字符串。</p>
<div class="code-wrapper"><pre><code class="hljs c++">QString s = <span class="hljs-string">"Montreal"</span>;
s.<span class="hljs-built_in">remove</span>(<span class="hljs-number">1</span>, <span class="hljs-number">4</span>);
<span class="hljs-comment">// s == "Meal"</span></code></pre></div>

<p>元素删除将保留字符串的容量，并且不会减少分配的内存量。 要减少额外容量并释放尽可能多的内存，请在最后一次更改字符串大小后调用 <a href="#squeeze">squeeze</a>()。</p>
<p><strong>另请参阅</strong> <a href="#insert">insert</a>() 和 <a href="#replace">replace</a>()。</p>
<h3><span id="qstring-amp-qstring-remove-qchar-ch-qt-casesensitivity-cs-qt-casesensitive"> &amp;QString::remove( <em>ch</em>,  <em>cs</em> = Qt::CaseSensitive )</span><a href="#qstring-amp-qstring-remove-qchar-ch-qt-casesensitivity-cs-qt-casesensitive" class="header-anchor">#</a></h3><p>删除此字符串中出现的每个字符 <em>ch</em>，并返回对该字符串的引用。</p>
<p>如果 <em>cs</em> 是 <a href="qt.html#CaseSensitivity-enum">Qt::CaseSensitive</a> （默认），则搜索区分大小写； 否则搜索不区分大小写。</p>
<p>例子:</p>
<div class="code-wrapper"><pre><code class="hljs c++">QString t = <span class="hljs-string">"Ali Baba"</span>;
t.<span class="hljs-built_in">remove</span>(<span class="hljs-built_in">QChar</span>(<span class="hljs-string">'a'</span>), Qt::CaseInsensitive);
<span class="hljs-comment">// t == "li Bb"</span></code></pre></div>

<p>这与 <code>replace(ch, "", cs)</code> 相同。</p>
<p>元素删除将保留字符串的容量，并且不会减少分配的内存量。 要减少额外容量并释放尽可能多的内存，请在最后一次更改字符串大小后调用 <a href="#squeeze">squeeze</a>()。</p>
<p><strong>See also</strong> <a href="#replace">replace</a>().</p>
<h3><span id="since-5-11-qstring-amp-qstring-remove-qlatin1string-str-qt-casesensitivity-cs-qt-casesensitive"><code>[since 5.11]</code> &amp;QString::remove( <em>str</em>,  <em>cs</em> = Qt::CaseSensitive)</span><a href="#since-5-11-qstring-amp-qstring-remove-qlatin1string-str-qt-casesensitivity-cs-qt-casesensitive" class="header-anchor">#</a></h3><p>这是一个重载函数。</p>
<p>删除此字符串中给定 <em>str</em> 字符串的每次出现，并返回对该字符串的引用。</p>
<p>如果 <em>cs</em> 是 <a href="qt.html#CaseSensitivity-enum">Qt::CaseSensitive</a> （默认），则搜索区分大小写； 否则搜索不区分大小写。</p>
<p>这与 <code>replace(str, "", cs)</code> 相同。</p>
<p>元素删除将保留字符串的容量，并且不会减少分配的内存量。 要减少额外容量并释放尽可能多的内存，请在最后一次更改字符串大小后调用 <a href="#squeeze">squeeze</a>()。</p>
<p>这个函数是在 Qt 5.11 中引入的。</p>
<p><strong>See also</strong> <a href="#replace">replace</a>().</p>
<h3><span id="qstring-amp-qstring-remove-const-qstring-amp-str-qt-casesensitivity-cs-qt-casesensitive"> &amp;QString::remove(const  &amp;<em>str</em>,  <em>cs</em> = Qt::CaseSensitive)</span><a href="#qstring-amp-qstring-remove-const-qstring-amp-str-qt-casesensitivity-cs-qt-casesensitive" class="header-anchor">#</a></h3><p>删除此字符串中给定 <em>str</em> 字符串的每次出现，并返回对该字符串的引用。</p>
<p>如果 <em>cs</em> 是 <a href="qt.html#CaseSensitivity-enum">Qt::CaseSensitive</a> （默认），则搜索区分大小写； 否则搜索不区分大小写。</p>
<p>这与 <code>replace(str, "", cs)</code> 相同。</p>
<p>元素删除将保留字符串的容量，并且不会减少分配的内存量。 要减少额外容量并释放尽可能多的内存，请在最后一次更改字符串大小后调用 <a href="#squeeze">squeeze</a>()。</p>
<p><strong>See also</strong> <a href="#replace">replace</a>().</p>
<h3><span id="since-5-0-qstring-amp-qstring-remove-const-qregularexpression-amp-re"><code>[since 5.0]</code> &amp;QString::remove(const  &amp;<em>re</em>)</span><a href="#since-5-0-qstring-amp-qstring-remove-const-qregularexpression-amp-re" class="header-anchor">#</a></h3><p>删除字符串中所有出现的正则表达式 <em>re</em>，并返回对该字符串的引用。 对于例子：</p>
<div class="code-wrapper"><pre><code class="hljs c++">QString r = <span class="hljs-string">"Telephone"</span>;
r.<span class="hljs-built_in">remove</span>(<span class="hljs-built_in">QRegularExpression</span>(<span class="hljs-string">"[aeiou]."</span>));
<span class="hljs-comment">// r == "The"</span></code></pre></div>

<p>元素删除将保留字符串的容量，并且不会减少分配的内存量。 要减少额外容量并释放尽可能多的内存，请在最后一次更改字符串大小后调用 <a href="#squeeze">squeeze</a>()。</p>
<p>该函数在 Qt 5.0 引入。</p>
<p><strong>See also</strong> <a href="#indexOf">indexOf</a>(), <a href="#lastIndexOf">lastIndexOf</a>(), and <a href="#replace">replace</a>().</p>
<h3><span id="since-6-1-template-qstring-amp-qstring-removeif-predicate-pred"><code>[since 6.1]</code>template <typename predicate> <a href="#QString">QString</a> &amp;QString::removeIf(Predicate <em>pred</em>)</typename></span><a href="#since-6-1-template-qstring-amp-qstring-removeif-predicate-pred" class="header-anchor">#</a></h3><p>从字符串中删除谓词 <em>pred</em> 返回 true 的所有元素。 返回对字符串的引用。</p>
<p>该函数在 Qt 6.1 引入。</p>
<p><strong>See also</strong> <a href="#remove">remove</a>().</p>
<h3><span id="since-5-6-qstring-reverse-iterator-qstring-rend"><code>[since 5.6]</code> QString::rend()</span><a href="#since-5-6-qstring-reverse-iterator-qstring-rend" class="header-anchor">#</a></h3><p>返回一个 <a href="containers.html#stl-style-iterators">STL-style</a> 反向迭代器，以相反的顺序指向字符串中最后一个字符之后。</p>
<p><strong>警告：</strong>返回的迭代器在分离或修改 <a href>QString</a> 时无效。</p>
<p>该函数在 Qt 5.6 引入。</p>
<p><strong>See also</strong> <a href="#end">end</a>(), <a href="#crend">crend</a>(), and <a href="#rbegin">rbegin</a>().</p>
<h3><span id="since-5-6-qstring-const-reverse-iterator-qstring-rend-const"><code>[since 5.6]</code> QString::rend() const</span><a href="#since-5-6-qstring-const-reverse-iterator-qstring-rend-const" class="header-anchor">#</a></h3><p>这是一个重载函数。</p>
<p>该函数在 Qt 5.6 引入。</p>
<h3><span id="qstring-qstring-repeated-qsizetype-times-const"> QString::repeated(qsizetype <em>times</em>) const</span><a href="#qstring-qstring-repeated-qsizetype-times-const" class="header-anchor">#</a></h3><p>返回重复指定次数<em>times</em>的此字符串的副本。</p>
<p>如果 <em>times</em> 小于 1，则返回一个空字符串。</p>
<p>例子:</p>
<div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-function">QString <span class="hljs-title">str</span><span class="hljs-params">((<span class="hljs-string">"ab"</span>);</span></span>
<span class="hljs-params"><span class="hljs-function">str.repeated((<span class="hljs-number">4</span>);                        <span class="hljs-comment">// returns "abababab"</span></span></span></code></pre></div>

<h3><span id="qstring-amp-qstring-replace-qsizetype-position-qsizetype-n-const-qstring-amp-after"> &amp;QString::replace(qsizetype <em>position</em>, qsizetype <em>n</em>, const  &amp;<em>after</em>)</span><a href="#qstring-amp-qstring-replace-qsizetype-position-qsizetype-n-const-qstring-amp-after" class="header-anchor">#</a></h3><p>用字符串 <em>after</em> 替换从索引 <em>position</em> 开始的 <em>n</em> 个字符，并返回对该字符串的引用。</p>
<p><strong>注意：</strong> 如果指定的 <em>position</em> 索引在字符串内，但 <em>position</em> + <em>n</em> 超出字符串范围，则 <em>n</em> 将调整为在字符串末尾停止。</p>
<p>例子:</p>
<div class="code-wrapper"><pre><code class="hljs c++">QString x = <span class="hljs-string">"Say yes!"</span>;

QString y = <span class="hljs-string">"no"</span>;
x.<span class="hljs-built_in">replace</span>((<span class="hljs-number">4</span>, <span class="hljs-number">3</span>, y);
);
<span class="hljs-comment">// x == "Say no!"</span></code></pre></div>

<p><strong>See also</strong> <a href="#insert">insert</a>() and <a href="#remove">remove</a>().</p>
<h3><span id="qstring-amp-qstring-replace-qsizetype-position-qsizetype-n-qchar-after"> &amp;QString::replace(qsizetype <em>position</em>, qsizetype <em>n</em>,  <em>after</em>)</span><a href="#qstring-amp-qstring-replace-qsizetype-position-qsizetype-n-qchar-after" class="header-anchor">#</a></h3><p>这个函数重载了 replace().</p>
<p>用字符 <em>after</em> 替换从索引 <em>position</em> 开始的 <em>n</em> 个字符，并返回对该字符串的引用。</p>
<h3><span id="qstring-amp-qstring-replace-qsizetype-position-qsizetype-n-const-qchar-unicode-qsizetype-size"> &amp;QString::replace(qsizetype <em>position</em>, qsizetype <em>n</em>, const  *<em>unicode</em>, qsizetype <em>size</em>)</span><a href="#qstring-amp-qstring-replace-qsizetype-position-qsizetype-n-const-qchar-unicode-qsizetype-size" class="header-anchor">#</a></h3><p>这个函数重载了 replace().</p>
<p>用 <a href="qchar.html">QChar</a> 数组 <em>unicode</em> 的前 <em>size</em> 个字符替换从索引 <em>position</em> 开始的 <em>n</em> 个字符，并返回对该字符串的引用。</p>
<h3><span id="qstring-amp-qstring-replace-qchar-before-qchar-after-qt-casesensitivity-cs-qt-casesensitive"> &amp;QString::replace( <em>before</em>,  <em>after</em>,  <em>cs</em> = Qt::CaseSensitive)</span><a href="#qstring-amp-qstring-replace-qchar-before-qchar-after-qt-casesensitivity-cs-qt-casesensitive" class="header-anchor">#</a></h3><p>这个函数重载了 replace().</p>
<p>将每个出现的字符 <em>before</em> 替换为字符 <em>after</em> 并返回对该字符串的引用。</p>
<p>如果 <em>cs</em> 是 <a href="qt.html#CaseSensitivity-enum">Qt::CaseSensitive</a> （默认），则搜索区分大小写； 否则搜索不区分大小写。</p>
<h3><span id="qstring-amp-qstring-replace-const-qchar-before-qsizetype-blen-const-qchar-after-qsizetype-alen-qt-casesensitivity-cs-qt-casesensitive"> &amp;QString::replace(const  *<em>before</em>, qsizetype <em>blen</em>, const  *<em>after</em>, qsizetype <em>alen</em>,  <em>cs</em> = Qt::CaseSensitive)</span><a href="#qstring-amp-qstring-replace-const-qchar-before-qsizetype-blen-const-qchar-after-qsizetype-alen-qt-casesensitivity-cs-qt-casesensitive" class="header-anchor">#</a></h3><p>这个函数重载了 replace().</p>
<p>用 <em>after</em> 的前 <em>alen</em> 字符替换此字符串中出现的每个 <em>before</em> 的前 <em>blen</em> 字符，并返回对该字符串的引用。</p>
<p>如果 <em>cs</em> 是 <a href="qt.html#CaseSensitivity-enum">Qt::CaseSensitive</a> （默认），则搜索区分大小写； 否则搜索不区分大小写。</p>
<h3><span id="qstring-amp-qstring-replace-qlatin1string-before-qlatin1string-after-qt-casesensitivity-cs-qt-casesensitive"> &amp;QString::replace( <em>before</em>,  <em>after</em>,  <em>cs</em> = Qt::CaseSensitive)</span><a href="#qstring-amp-qstring-replace-qlatin1string-before-qlatin1string-after-qt-casesensitivity-cs-qt-casesensitive" class="header-anchor">#</a></h3><p>这个函数重载了 replace().</p>
<p>用字符串 <em>after</em> 替换每次出现的字符串 <em>before</em> 并返回对该字符串的引用。</p>
<p>如果 <em>cs</em> 是 <a href="qt.html#CaseSensitivity-enum">Qt::CaseSensitive</a> （默认），则搜索区分大小写； 否则搜索不区分大小写。</p>
<p><strong>注意：</strong> 替换后不会重新扫描文本。</p>
<h3><span id="qstring-amp-qstring-replace-qlatin1string-before-const-qstring-amp-after-qt-casesensitivity-cs-qt-casesensitive"> &amp;QString::replace( <em>before</em>, const  &amp;<em>after</em>,  <em>cs</em> = Qt::CaseSensitive)</span><a href="#qstring-amp-qstring-replace-qlatin1string-before-const-qstring-amp-after-qt-casesensitivity-cs-qt-casesensitive" class="header-anchor">#</a></h3><p>这个函数重载了 replace().</p>
<p>用字符串 <em>after</em> 替换每次出现的字符串 <em>before</em> 并返回对该字符串的引用。</p>
<p>如果 <em>cs</em> 是 <a href="qt.html#CaseSensitivity-enum">Qt::CaseSensitive</a> （默认），则搜索区分大小写； 否则搜索不区分大小写。</p>
<p><strong>注意：</strong> 替换后不会重新扫描文本。</p>
<h3><span id="qstring-amp-qstring-replace-const-qstring-amp-before-qlatin1string-after-qt-casesensitivity-cs-qt-casesensitive"> &amp;QString::replace(const  &amp;<em>before</em>,  <em>after</em>,  <em>cs</em> = Qt::CaseSensitive)</span><a href="#qstring-amp-qstring-replace-const-qstring-amp-before-qlatin1string-after-qt-casesensitivity-cs-qt-casesensitive" class="header-anchor">#</a></h3><p>这个函数重载了 replace().</p>
<p>用字符串 <em>after</em> 替换每次出现的字符串 <em>before</em> 并返回对该字符串的引用。</p>
<p>如果 <em>cs</em> 是 <a href="qt.html#CaseSensitivity-enum">Qt::CaseSensitive</a> （默认），则搜索区分大小写； 否则搜索不区分大小写。</p>
<p><strong>注意：</strong> 替换后不会重新扫描文本。</p>
<h3><span id="qstring-amp-qstring-replace-const-qstring-amp-before-const-qstring-amp-after-qt-casesensitivity-cs-qt-casesensitive"> &amp;QString::replace(const  &amp;<em>before</em>, const  &amp;<em>after</em>,  <em>cs</em> = Qt::CaseSensitive)</span><a href="#qstring-amp-qstring-replace-const-qstring-amp-before-const-qstring-amp-after-qt-casesensitivity-cs-qt-casesensitive" class="header-anchor">#</a></h3><p>这个函数重载了 replace().</p>
<p>用字符串 <em>after</em> 替换每次出现的字符串 <em>before</em> 并返回对该字符串的引用。</p>
<p>如果 <em>cs</em> 是 <a href="qt.html#CaseSensitivity-enum">Qt::CaseSensitive</a> （默认），则搜索区分大小写； 否则搜索不区分大小写。</p>
<p>例子:</p>
<div class="code-wrapper"><pre><code class="hljs c++">QString str = <span class="hljs-string">"colour behaviour flavour neighbour"</span>;
str.<span class="hljs-built_in">replace</span>(<span class="hljs-built_in">QString</span>(<span class="hljs-string">"ou"</span>), <span class="hljs-built_in">QString</span>(<span class="hljs-string">"o"</span>));
<span class="hljs-comment">// str == "color behavior flavor neighbor"</span></code></pre></div>

<p><strong>注意：</strong> 替换文本插入后不会重新扫描。</p>
<p>例子:</p>
<div class="code-wrapper"><pre><code class="hljs c++">QString equis = <span class="hljs-string">"xxxxxx"</span>;
equis.<span class="hljs-built_in">replace</span>(<span class="hljs-string">"xx"</span>, <span class="hljs-string">"x"</span>);
<span class="hljs-comment">// equis == "xxx"</span></code></pre></div>

<h3><span id="qstring-amp-qstring-replace-qchar-ch-const-qstring-amp-after-qt-casesensitivity-cs-qt-casesensitive"> &amp;QString::replace( <em>ch</em>, const  &amp;<em>after</em>,  <em>cs</em> = Qt::CaseSensitive)</span><a href="#qstring-amp-qstring-replace-qchar-ch-const-qstring-amp-after-qt-casesensitivity-cs-qt-casesensitive" class="header-anchor">#</a></h3><p>这个函数重载了 replace().</p>
<p>用字符串 <em>after</em> 替换每次出现的字符 <em>ch</em> 并返回对该字符串的引用。</p>
<p>如果 <em>cs</em> 是 <a href="qt.html#CaseSensitivity-enum">Qt::CaseSensitive</a> （默认），则搜索区分大小写； 否则搜索不区分大小写。</p>
<h3><span id="qstring-amp-qstring-replace-qchar-c-qlatin1string-after-qt-casesensitivity-cs-qt-casesensitive"> &amp;QString::replace( <em>c</em>,  <em>after</em>,  <em>cs</em> = Qt::CaseSensitive)</span><a href="#qstring-amp-qstring-replace-qchar-c-qlatin1string-after-qt-casesensitivity-cs-qt-casesensitive" class="header-anchor">#</a></h3><p>这个函数重载了 replace().</p>
<p>用字符串 <em>after</em> 替换每次出现的字符 <em>c</em> 并返回对该字符串的引用。</p>
<p>如果 <em>cs</em> 是 <a href="qt.html#CaseSensitivity-enum">Qt::CaseSensitive</a> （默认），则搜索区分大小写； 否则搜索不区分大小写。</p>
<p><strong>注意：</strong> 替换后不会重新扫描文本。</p>
<h3><span id="since-5-0-qstring-amp-qstring-replace-const-qregularexpression-amp-re-const-qstring-amp-after"><code>[since 5.0]</code> &amp;QString::replace(const  &amp;<em>re</em>, const  &amp;<em>after</em>)</span><a href="#since-5-0-qstring-amp-qstring-replace-const-qregularexpression-amp-re-const-qstring-amp-after" class="header-anchor">#</a></h3><p>这个函数重载了 replace().</p>
<p>用 <em>after</em> 替换字符串中所有出现的正则表达式 <em>re</em>。 返回对字符串的引用。 对于例子：</p>
<div class="code-wrapper"><pre><code class="hljs c++">QString s = <span class="hljs-string">"Banana"</span>;
s.<span class="hljs-built_in">replace</span>(<span class="hljs-built_in">QRegularExpression</span>(<span class="hljs-string">"a[mn]"</span>), <span class="hljs-string">"ox"</span>);
<span class="hljs-comment">// s == "Boxoxa"</span></code></pre></div>

<p>对于包含捕获组的正则表达式，<em>after</em> 中出现的 <strong>\1</strong>、<strong>\2</strong>、… 将替换为相应捕获组捕获的字符串。</p>
<div class="code-wrapper"><pre><code class="hljs c++">QString t = <span class="hljs-string">"A &lt;i&gt;bon mot&lt;/i&gt;."</span>;
t.<span class="hljs-built_in">replace</span>(<span class="hljs-built_in">QRegularExpression</span>(<span class="hljs-string">"&lt;i&gt;([^&lt;]*)&lt;/i&gt;"</span>), <span class="hljs-string">"\\emph{\\1}"</span>);
<span class="hljs-comment">// t == "A \\emph{bon mot}."</span></code></pre></div>

<p>该函数在 Qt 5.0 引入。</p>
<p><strong>See also</strong> <a href="#indexOf">indexOf</a>(), <a href="#lastIndexOf">lastIndexOf</a>(), <a href="#remove">remove</a>(), <a href="qregularexpression.html">QRegularExpression</a>, and <a href="qregularexpressionmatch.html">QRegularExpressionMatch</a>.</p>
<h3><span id="void-qstring-reserve-qsizetype-size">void QString::reserve(qsizetype <em>size</em>)</span><a href="#void-qstring-reserve-qsizetype-size" class="header-anchor">#</a></h3><p>确保字符串至少有 <em>size</em> 个字符的空间。</p>
<p>如果你事先知道字符串会有多大，你可以调用这个函数来节省在构建它的过程中重复的重新分配。这可以在增量构建字符串时提高性能。添加到字符串的一长串操作可能会触发多次重新分配，其中最后一次可能会给您留下比您真正需要的空间多得多的空间，这比在开始时进行一次正确大小的分配效率低。</p>
<p>如果对需要多少空间存有疑问，通常最好使用<em>size</em> 的上限，或对最可能大小的高度估计，如果严格的上限比这大得多。如果 <em>size</em> 被低估，一旦超过保留大小，字符串将根据需要增长，这可能导致分配比您最好的高估更大，并且会减慢触发它的操作。</p>
<p><strong>警告：</strong> reserve() 保留内存但不会更改字符串的大小。访问超出字符串末尾的数据是未定义的行为。如果您需要访问超出字符串当前结尾的内存，请使用 <a href="#resize">resize</a>()。</p>
<p>此函数对于需要构建长字符串并希望避免重复重新分配的代码很有用。在这个例子中，我们想要添加到字符串中，直到某个条件为 <code>true</code>，并且我们相当确定 size 足够大，以至于调用 reserve() 是值得的：</p>
<div class="code-wrapper"><pre><code class="hljs c++">QString result;;
qsizetype maxSize;;
<span class="hljs-type">bool</span> condition;<span class="hljs-type">bool</span> condition;
QChar nextChar;;

result.<span class="hljs-built_in">reserve</span>(maxSize);(maxSize);

<span class="hljs-keyword">while</span> (condition)(condition)
    result.<span class="hljs-built_in">append</span>(nextChar);(nextChar);

result.<span class="hljs-built_in">squeeze</span>();();</code></pre></div>

<p><strong>See also</strong> <a href="#squeeze">squeeze</a>(), <a href="#capacity">capacity</a>(), and <a href="#resize">resize</a>().</p>
<h3><span id="void-qstring-resize-qsizetype-size">void QString::resize(qsizetype <em>size</em>)</span><a href="#void-qstring-resize-qsizetype-size" class="header-anchor">#</a></h3><p>将字符串的大小设置为 <em>size</em> 个字符。</p>
<p>如果 <em>size</em> 大于当前大小，则将字符串扩展为 <em>size</em> 个字符长，并在末尾添加额外字符。 新字符未初始化。</p>
<p>如果 <em>size</em> 小于当前大小，则超出位置 <em>size</em> 的字符将从字符串中排除。</p>
<p><strong>注意：</strong> 虽然 resize() 会在需要时增加容量，但它永远不会缩小容量。 要消除多余的容量，请使用 <a href="#squeeze">squeeze</a>()。</p>
<p>例子:</p>
<div class="code-wrapper"><pre><code class="hljs c++">QString s = <span class="hljs-string">"Hello world"</span>;
s.<span class="hljs-built_in">resize</span>((<span class="hljs-number">5</span>);

<span class="hljs-comment">// s == "Hello"</span>

s.<span class="hljs-built_in">resize</span>((<span class="hljs-number">8</span>);

<span class="hljs-comment">// s == "Hello???" (where ? stands for any character)</span></code></pre></div>

<p>如果要在字符串中附加一定数量的相同字符，请使用 <a href="#resize-1">resize</a>(qsizetype, QChar) 重载。</p>
<p>如果要扩展字符串以使其达到特定宽度并用特定字符填充新位置，请使用 <a href="#leftJustified">leftJustified</a>() 函数：</p>
<p>如果 <em>size</em> 为负数，则相当于传递零。</p>
<div class="code-wrapper"><pre><code class="hljs c++">QString r = <span class="hljs-string">"Hello"</span>;
r = r.<span class="hljs-built_in">leftJustified</span>((<span class="hljs-number">10</span>, <span class="hljs-string">' '</span>);

<span class="hljs-comment">// r == "Hello     "</span></code></pre></div>

<p><strong>See also</strong> <a href="#truncate">truncate</a>(), <a href="#reserve">reserve</a>(), and <a href="#squeeze">squeeze</a>().</p>
<h3><span id="since-5-7-void-qstring-resize-qsizetype-size-qchar-fillchar"><code>[since 5.7]</code>void QString::resize(qsizetype <em>size</em>,  <em>fillChar</em>)</span><a href="#since-5-7-void-qstring-resize-qsizetype-size-qchar-fillchar" class="header-anchor">#</a></h3><p>这是一个重载函数。</p>
<p>与 <a href="#resize">resize</a>(qsizetype) 不同，此重载将新字符初始化为 <em>fillChar</em>：</p>
<div class="code-wrapper"><pre><code class="hljs c++">QString t = <span class="hljs-string">"Hello"</span>;
r.<span class="hljs-built_in">resize</span>(<span class="hljs-built_in">t</span>(t.<span class="hljs-built_in">size</span>() () + <span class="hljs-number">10</span>, <span class="hljs-string">'X'</span>);

<span class="hljs-comment">// t == "HelloXXXXXXXXXX"</span></code></pre></div>

<p>该函数在 Qt 5.7 引入。</p>
<h3><span id="qstring-qstring-right-qsizetype-n-const"> QString::right(qsizetype <em>n</em>) const</span><a href="#qstring-qstring-right-qsizetype-n-const" class="header-anchor">#</a></h3><p>返回一个包含字符串最右边 <em>n</em> 个字符的子字符串。</p>
<p>如果您知道 <em>n</em> 不能越界，请在新代码中使用 <a href="#last">last</a>() 代替，因为它更快。</p>
<p>如果 <em>n</em> 大于或等于 <a href="#size">size</a>() 或小于零，则返回整个字符串。</p>
<p><strong>See also</strong> <a href="#endsWith">endsWith</a>(), <a href="#last">last</a>(), <a href="#first">first</a>(), <a href="#sliced">sliced</a>(), <a href="#chopped">chopped</a>(), <a href="#chop">chop</a>(), and <a href="#truncate">truncate</a>().</p>
<h3><span id="qstring-qstring-rightjustified-qsizetype-width-qchar-fill-qlatin1char-bool-truncate-false-const"> QString::rightJustified(qsizetype <em>width</em>,  <em>fill</em> = QLatin1Char(‘ ‘), bool <em>truncate</em> = false) const</span><a href="#qstring-qstring-rightjustified-qsizetype-width-qchar-fill-qlatin1char-bool-truncate-false-const" class="header-anchor">#</a></h3><p>返回一个 <a href="#size">size</a>() <em>width</em> 字符串，其中包含 <em>fill</em> 字符，后跟字符串。 对于例子：</p>
<div class="code-wrapper"><pre><code class="hljs c++">QString s = <span class="hljs-string">"apple"</span>;

QString t = s.<span class="hljs-built_in">rightJustified</span>((<span class="hljs-number">8</span>, <span class="hljs-string">'.'</span>);        <span class="hljs-comment">// t == "...apple"</span></code></pre></div>

<p>如果 <em>truncate</em> 为 <code>false</code> 并且字符串的 <a href="#size">size</a>() 大于 <em>width</em>，则返回的字符串是字符串的副本。</p>
<p>如果 <em>truncate</em> 为真并且字符串的 <a href="#size">size</a>() 大于 <em>width</em>，则生成的字符串在位置 <em>width</em> 处被截断。</p>
<div class="code-wrapper"><pre><code class="hljs c++">QString str = <span class="hljs-string">"Pineapple"</span>;
str = str.<span class="hljs-built_in">rightJustified</span>((<span class="hljs-number">5</span>, <span class="hljs-string">'.'</span>, <span class="hljs-literal">true</span>);        <span class="hljs-comment">// str == "Pinea"</span></code></pre></div>

<p><strong>See also</strong> <a href="#leftJustified">leftJustified</a>().</p>
<h3><span id="qstring-qstring-section-qchar-sep-qsizetype-start-qsizetype-end-1-qstring-sectionflags-flags-sectiondefault-const"> QString::section( <em>sep</em>, qsizetype <em>start</em>, qsizetype <em>end</em> = -1,  <em>flags</em> = SectionDefault) const</span><a href="#qstring-qstring-section-qchar-sep-qsizetype-start-qsizetype-end-1-qstring-sectionflags-flags-sectiondefault-const" class="header-anchor">#</a></h3><p>此函数返回字符串的一部分。</p>
<p>此字符串被视为由字符 <em>sep</em> 分隔的字段序列。 返回的字符串由从位置 <em>start</em> 到位置 <em>end</em> 的字段组成。 如果未指定 <em>end</em>，则包括从位置 <em>start</em> 到字符串结尾的所有字段。 字段编号为 0、1、2 等，从左数起，-1、-2 等，从右到左数。</p>
<p><em>flags</em> 参数可用于影响函数行为的某些方面，例如 是否区分大小写，是否跳过空字段以及如何处理前导和尾随分隔符； 请参阅 <a href="#SectionFlag-enum">SectionFlags</a>。</p>
<div class="code-wrapper"><pre><code class="hljs c++">QString str;
QString csv = <span class="hljs-string">"forename,middlename,surname,phone"</span>;
QString path = <span class="hljs-string">"/usr/local/bin/myapp"</span>; <span class="hljs-comment">// First field is empty</span>
QString::SectionFlag flag = QString::SectionSkipEmpty;

str = csv.<span class="hljs-built_in">section</span>(<span class="hljs-string">','</span>, <span class="hljs-number">2</span>, <span class="hljs-number">2</span>);   <span class="hljs-comment">// str == "surname"</span>
str = path.<span class="hljs-built_in">section</span>(<span class="hljs-string">'/'</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>);  <span class="hljs-comment">// str == "bin/myapp"</span>
str = path.<span class="hljs-built_in">section</span>(<span class="hljs-string">'/'</span>, <span class="hljs-number">3</span>, <span class="hljs-number">3</span>, flag); <span class="hljs-comment">// str == "myapp"</span></code></pre></div>

<p>如果 <em>start</em> 或 <em>end</em> 为负数，我们从字符串的右侧开始计算字段，最右侧的字段为 -1，最右侧的字段为 -2，依此类推。</p>
<div class="code-wrapper"><pre><code class="hljs c++">str = csv.<span class="hljs-built_in">section</span>(<span class="hljs-string">','</span>, <span class="hljs-number">-3</span>, <span class="hljs-number">-2</span>);  <span class="hljs-comment">// str == "middlename,surname"</span>
str = path.<span class="hljs-built_in">section</span>(<span class="hljs-string">'/'</span>, <span class="hljs-number">-1</span>); <span class="hljs-comment">// str == "myapp"</span></code></pre></div>

<p><strong>See also</strong> <a href="#split">split</a>().</p>
<h3><span id="qstring-qstring-section-const-qstring-amp-sep-qsizetype-start-qsizetype-end-1-qstring-sectionflags-flags-sectiondefault-const"> QString::section(const  &amp;<em>sep</em>, qsizetype <em>start</em>, qsizetype <em>end</em> = -1,  <em>flags</em> = SectionDefault) const</span><a href="#qstring-qstring-section-const-qstring-amp-sep-qsizetype-start-qsizetype-end-1-qstring-sectionflags-flags-sectiondefault-const" class="header-anchor">#</a></h3><p>这个函数重载了 section().</p>
<div class="code-wrapper"><pre><code class="hljs c++">QString str;
QString data = <span class="hljs-string">"forename**middlename**surname**phone"</span>;

str = data.<span class="hljs-built_in">section</span>(<span class="hljs-string">"**"</span>, <span class="hljs-number">2</span>, <span class="hljs-number">2</span>); <span class="hljs-comment">// str == "surname"</span>
str = data.<span class="hljs-built_in">section</span>(<span class="hljs-string">"**"</span>, <span class="hljs-number">-3</span>, <span class="hljs-number">-2</span>); <span class="hljs-comment">// str == "middlename**surname"</span></code></pre></div>

<p><strong>See also</strong> <a href="#split">split</a>().</p>
<h3><span id="since-5-0-qstring-qstring-section-const-qregularexpression-amp-re-qsizetype-start-qsizetype-end-1-qstring-sectionflags-flags-sectiondefault-const"><code>[since 5.0]</code> QString::section(const  &amp;<em>re</em>, qsizetype <em>start</em>, qsizetype <em>end</em> = -1,  <em>flags</em> = SectionDefault) const</span><a href="#since-5-0-qstring-qstring-section-const-qregularexpression-amp-re-qsizetype-start-qsizetype-end-1-qstring-sectionflags-flags-sectiondefault-const" class="header-anchor">#</a></h3><p>这个函数重载了 section().</p>
<p>此字符串被视为由正则表达式 <em>re</em> 分隔的字段序列。</p>
<div class="code-wrapper"><pre><code class="hljs c++">QString line = <span class="hljs-string">"forename\tmiddlename  surname \t \t phone"</span>;
<span class="hljs-function">QRegularExpression <span class="hljs-title">sep</span><span class="hljs-params">(<span class="hljs-string">"\\s+"</span>)</span></span>;
str = line.<span class="hljs-built_in">section</span>(sep, <span class="hljs-number">2</span>, <span class="hljs-number">2</span>); <span class="hljs-comment">// str == "surname"</span>
str = line.<span class="hljs-built_in">section</span>(sep, <span class="hljs-number">-3</span>, <span class="hljs-number">-2</span>); <span class="hljs-comment">// str == "middlename  surname"</span></code></pre></div>

<p><strong>警告：</strong> 使用这个 <a href="qregularexpression.html">QRegularExpression</a> 版本比重载的字符串和字符版本要昂贵得多。</p>
<p>该函数在 Qt 5.0 引入。</p>
<p><strong>See also</strong> <a href="#split">split</a>() and <a href="#simplified">simplified</a>().</p>
<h3><span id="qstring-amp-qstring-setnum-int-n-int-base-10"> &amp;QString::setNum(int <em>n</em>, int <em>base</em> = 10)</span><a href="#qstring-amp-qstring-setnum-int-n-int-base-10" class="header-anchor">#</a></h3><p>将字符串设置为指定 <em>base</em> 中 <em>n</em> 的打印值，并返回对字符串的引用。</p>
<p>基数默认为 10，必须在 2 到 36 之间。</p>
<div class="code-wrapper"><pre><code class="hljs c++">QString str;
str.<span class="hljs-built_in">setNum</span>(<span class="hljs-number">1234</span>);       <span class="hljs-comment">// str == "1234"</span></code></pre></div>

<p>格式始终使用 <a href="qlocale.html#Language-enum">QLocale::C</a>，即 English/UnitedStates。 要获得数字的本地化字符串表示，请使用带有适当语言环境的 <a href="qlocale.html#toString">QLocale::toString</a>()。</p>
<p><strong>See also</strong> <a href="#number">number</a>().</p>
<h3><span id="qstring-amp-qstring-setnum-short-n-int-base-10"> &amp;QString::setNum(short <em>n</em>, int <em>base</em> = 10)</span><a href="#qstring-amp-qstring-setnum-short-n-int-base-10" class="header-anchor">#</a></h3><p>这是一个重载函数。</p>
<h3><span id="qstring-amp-qstring-setnum-ushort-n-int-base-10"> &amp;QString::setNum( <em>n</em>, int <em>base</em> = 10)</span><a href="#qstring-amp-qstring-setnum-ushort-n-int-base-10" class="header-anchor">#</a></h3><p>这是一个重载函数。</p>
<h3><span id="qstring-amp-qstring-setnum-uint-n-int-base-10"> &amp;QString::setNum( <em>n</em>, int <em>base</em> = 10)</span><a href="#qstring-amp-qstring-setnum-uint-n-int-base-10" class="header-anchor">#</a></h3><p>这是一个重载函数。</p>
<h3><span id="qstring-amp-qstring-setnum-long-n-int-base-10"> &amp;QString::setNum(long <em>n</em>, int <em>base</em> = 10)</span><a href="#qstring-amp-qstring-setnum-long-n-int-base-10" class="header-anchor">#</a></h3><p>这是一个重载函数。</p>
<h3><span id="qstring-amp-qstring-setnum-ulong-n-int-base-10"> &amp;QString::setNum( <em>n</em>, int <em>base</em> = 10)</span><a href="#qstring-amp-qstring-setnum-ulong-n-int-base-10" class="header-anchor">#</a></h3><p>这是一个重载函数。</p>
<h3><span id="qstring-amp-qstring-setnum-qlonglong-n-int-base-10"> &amp;QString::setNum( <em>n</em>, int <em>base</em> = 10)</span><a href="#qstring-amp-qstring-setnum-qlonglong-n-int-base-10" class="header-anchor">#</a></h3><p>这是一个重载函数。</p>
<h3><span id="qstring-amp-qstring-setnum-qulonglong-n-int-base-10"> &amp;QString::setNum( <em>n</em>, int <em>base</em> = 10)</span><a href="#qstring-amp-qstring-setnum-qulonglong-n-int-base-10" class="header-anchor">#</a></h3><p>这是一个重载函数。</p>
<h3><span id="qstring-amp-qstring-setnum-float-n-char-format-g-int-precision-6"> &amp;QString::setNum(float <em>n</em>, char <em>format</em> = ‘g’, int <em>precision</em> = 6)</span><a href="#qstring-amp-qstring-setnum-float-n-char-format-g-int-precision-6" class="header-anchor">#</a></h3><p>这是一个重载函数。</p>
<p>将字符串设置为 <em>n</em> 的打印值，根据给定的 <em>format</em> 和 <em>precision</em> 格式化，并返回对字符串的引用。</p>
<p>格式始终使用 <a href="qlocale.html#Language-enum">QLocale::C</a>，即 English/UnitedStates。 要获得数字的本地化字符串表示，请使用带有适当语言环境的 <a href="qlocale.html#toString">QLocale::toString</a>()。</p>
<p><strong>See also</strong> <a href="#number">number</a>().</p>
<h3><span id="qstring-amp-qstring-setnum-double-n-char-format-g-int-precision-6"> &amp;QString::setNum(double <em>n</em>, char <em>format</em> = ‘g’, int <em>precision</em> = 6)</span><a href="#qstring-amp-qstring-setnum-double-n-char-format-g-int-precision-6" class="header-anchor">#</a></h3><p>这是一个重载函数。</p>
<p>将字符串设置为 <em>n</em> 的打印值，根据给定的 <em>format</em> 和 <em>precision</em> 格式化，并返回对字符串的引用。</p>
<p><strong>See also</strong> <a href="#number">number</a>(), <a href="qlocale.html#FloatingPointPrecisionOption-enum">QLocale::FloatingPointPrecisionOption</a>, and <a href="#number-formats">Number Formats</a>.</p>
<h3><span id="qstring-amp-qstring-setrawdata-const-qchar-unicode-qsizetype-size"> &amp;QString::setRawData(const  *<em>unicode</em>, qsizetype <em>size</em>)</span><a href="#qstring-amp-qstring-setrawdata-const-qchar-unicode-qsizetype-size" class="header-anchor">#</a></h3><p>将字符串设置为 <em>n</em> 的打印值，根据给定的 <em>format</em> 和 <em>precision</em> 格式化，并 rResets <a href>QString</a> 以使用数组 <em>unicode</em> 中的第一个 <em>size</em> Unicode 字符。 <em>unicode</em> 中的数据<em>不</em> 复制。 只要 <a href>QString</a>（或它的未修改副本）存在，调用者必须能够保证 <em>unicode</em> 不会被删除或修改。</p>
<p>可以使用此函数代替 <a href="#fromRawData">fromRawData</a>() 来重新使用现有的 <a href>QString</a> 对象来节省内存重新分配。返回对字符串的引用。</p>
<p><strong>See also</strong> <a href="#fromRawData">fromRawData</a>().</p>
<h3><span id="qstring-amp-qstring-setunicode-const-qchar-unicode-qsizetype-size"> &amp;QString::setUnicode(const  *<em>unicode</em>, qsizetype <em>size</em>)</span><a href="#qstring-amp-qstring-setunicode-const-qchar-unicode-qsizetype-size" class="header-anchor">#</a></h3><p>将字符串大小调整为 <em>size</em> 字符并将 <em>unicode</em> 复制到字符串中。</p>
<p>如果 <em>unicode</em> 是 <code>nullptr</code>，则不会复制任何内容，但字符串仍会调整为 <em>size</em>。</p>
<p><strong>另请参阅</strong> <a href="#unicode">unicode</a>() 和 <a href="#setUtf16">setUtf16</a>()。</p>
<h3><span id="qstring-amp-qstring-setutf16-const-ushort-unicode-qsizetype-size"> &amp;QString::setUtf16(const  *<em>unicode</em>, qsizetype <em>size</em>)</span><a href="#qstring-amp-qstring-setutf16-const-ushort-unicode-qsizetype-size" class="header-anchor">#</a></h3><p>将字符串大小调整为 <em>size</em> 字符并将 <em>unicode</em> 复制到字符串中。</p>
<p>如果 <em>unicode</em> 是 <code>nullptr</code>，则不会复制任何内容，但字符串仍会调整为 <em>size</em>。</p>
<p>请注意，与 <a href="#fromUtf16">fromUtf16</a>() 不同，此函数不考虑 BOM 和可能不同的字节顺序。</p>
<p><strong>另请参阅</strong> <a href="#utf16">utf16</a>() 和 <a href="#setUnicode">setUnicode</a>()。</p>
<h3><span id="since-5-10-void-qstring-shrink-to-fit"><code>[since 5.10]</code>void QString::shrink_to_fit()</span><a href="#since-5-10-void-qstring-shrink-to-fit" class="header-anchor">#</a></h3><p>提供此功能是为了与 STL 输出。相当于 <a href="#squeeze">squeeze</a>()。</p>
<p>该函数在 Qt 5.10 引入。</p>
<p><strong>另请参阅</strong> <a href="#squeeze">挤压</a>()。</p>
<h3><span id="qstring-qstring-simplified-chang-liang"> QString::simplified() 常量</span><a href="#qstring-qstring-simplified-chang-liang" class="header-anchor">#</a></h3><p>返回一个字符串，该字符串从开头和结尾删除了空格，并且每个内部空格序列都替换为单个空格。</p>
<p>空格是指 <a href="qchar.html#isSpace">QChar::isSpace</a>() 返回 <code>true</code> 的任何字符。这包括 ASCII 字符“\t”、“\n”、“\v”、“\f”、“\r”和“”。</p>
<p>例子:</p>
<div class="code-wrapper"><pre><code class="hljs c++">QString str = <span class="hljs-string">"  lots\t of\nwhitespace\r\n "</span>;
str = str.<span class="hljs-built_in">simplified</span>();
<span class="hljs-comment">// str == "lots of whitespace";</span></code></pre></div>

<p><strong>See also</strong> <a href="#trimmed">trimmed</a>().</p>
<h3><span id="qsizetype-qstring-size-const">qsizetype QString::size() const</span><a href="#qsizetype-qstring-size-const" class="header-anchor">#</a></h3><p>返回此字符串中的字符数。</p>
<p>字符串中的最后一个字符位于 <code>size() - 1</code> 位置。</p>
<p>例子:</p>
<div class="code-wrapper"><pre><code class="hljs c++">QString str = <span class="hljs-string">"World"</span>;
qsizetype n = str.<span class="hljs-built_in">size</span>();   <span class="hljs-comment">// n == 5</span>
str.<span class="hljs-built_in">data</span>()[<span class="hljs-number">0</span>];              <span class="hljs-comment">// returns 'W'</span>
str.<span class="hljs-built_in">data</span>()[<span class="hljs-number">4</span>];              <span class="hljs-comment">// returns 'd'</span></code></pre></div>

<p><strong>See also</strong> <a href="#isEmpty">isEmpty</a>() and <a href="#resize">resize</a>().</p>
<h3><span id="since-6-0-qstring-qstring-sliced-qsizetype-pos-qsizetype-n-const"><code>[since 6.0]</code> QString::sliced(qsizetype <em>pos</em>, qsizetype <em>n</em>) const</span><a href="#since-6-0-qstring-qstring-sliced-qsizetype-pos-qsizetype-n-const" class="header-anchor">#</a></h3><p>返回一个包含此字符串的 <em>n</em> 个字符的字符串，从位置 <em>pos</em> 开始。</p>
<p><strong>注意：</strong> 当 <em>pos</em> &lt; 0、*n* &lt; 0 或 *pos* + *n* &gt; <a href="#size">size</a>() 时，行为未定义。</p>
<div class="code-wrapper"><pre><code class="hljs c++">QString x = <span class="hljs-string">"Nine pineapples"</span>;
QString y = x.<span class="hljs-built_in">sliced</span>(<span class="hljs-number">5</span>, <span class="hljs-number">4</span>);            <span class="hljs-comment">// y == "pine"</span>
QString z = x.<span class="hljs-built_in">sliced</span>(<span class="hljs-number">5</span>);               <span class="hljs-comment">// z == "pineapples"</span></code></pre></div>

<p>该函数在 Qt 6.0 引入。</p>
<p><strong>See also</strong> <a href="#first">first</a>(), <a href="#last">last</a>(), <a href="#chopped">chopped</a>(), <a href="#chop">chop</a>(), and <a href="#truncate">truncate</a>().</p>
<h3><span id="since-6-0-qstring-qstring-sliced-qsizetype-pos-const"><code>[since 6.0]</code> QString::sliced(qsizetype <em>pos</em>) const</span><a href="#since-6-0-qstring-qstring-sliced-qsizetype-pos-const" class="header-anchor">#</a></h3><p>这是一个重载函数。</p>
<p>返回一个字符串，该字符串包含从位置 <em>pos</em> 开始并延伸到其末尾的字符串部分。</p>
<p><strong>注意：</strong> 当 <em>pos</em> &lt; 0 或 *pos* &gt; <a href="#size">size</a>() 时行为未定义。</p>
<p>该函数在 Qt 6.0 引入。</p>
<p><strong>See also</strong> <a href="#first">first</a>(), <a href="#last">last</a>(), <a href="#sliced">sliced</a>(), <a href="#chopped">chopped</a>(), <a href="#chop">chop</a>(), and <a href="#truncate">truncate</a>().</p>
<h3><span id="since-5-14-qstringlist-qstring-split-const-qstring-amp-sep-qt-splitbehavior-behavior-qt-keepemptyparts-qt-casesensitivity-cs-qt-casesensitive-const"><code>[since 5.14]</code> QString::split(const  &amp;<em>sep</em>,  <em>behavior</em> = Qt::KeepEmptyParts,  <em>cs</em> = Qt::CaseSensitive) const</span><a href="#since-5-14-qstringlist-qstring-split-const-qstring-amp-sep-qt-splitbehavior-behavior-qt-keepemptyparts-qt-casesensitivity-cs-qt-casesensitive-const" class="header-anchor">#</a></h3><p>在出现 <em>sep</em> 的地方将字符串拆分为子字符串，并返回这些字符串的列表。如果 <em>sep</em> 不匹配字符串中的任何位置，split() 将返回包含此字符串的单元素列表。</p>
<p><em>cs</em> 指定 <em>sep</em> 是否应该区分大小写或不区分大小写。</p>
<p>如果 <em>behavior</em> 是 <a href="qt.html#SplitBehaviorFlags-enum">Qt::SkipEmptyParts</a>，则结果中不会出现空条目。默认情况下，保留空条目。</p>
<p>例子：</p>
<div class="code-wrapper"><pre><code class="hljs C++">QString str = <span class="hljs-built_in">QStringLiteral</span>(<span class="hljs-string">"a,,b,c"</span>);

QStringList list1 = str.<span class="hljs-built_in">split</span>(<span class="hljs-built_in">QLatin1Char</span>(<span class="hljs-string">','</span>));
<span class="hljs-comment">// list1: [ "a", "", "b", "c" ]</span>

QStringList list2 = str.<span class="hljs-built_in">split</span>(<span class="hljs-built_in">QLatin1Char</span>(<span class="hljs-string">','</span>), Qt::SkipEmptyParts);
<span class="hljs-comment">// list2: [ "a", "b", "c" ]</span></code></pre></div>

<p>如果 <em>sep</em> 为空，则 split() 返回一个空字符串，后跟每个字符串的字符，然后是另一个空字符串：</p>
<div class="code-wrapper"><pre><code class="hljs C++">QString str = <span class="hljs-string">"abc"</span>;
<span class="hljs-keyword">auto</span> parts = str.<span class="hljs-built_in">split</span>(<span class="hljs-built_in">QString</span>());
<span class="hljs-comment">// parts：{""、"a"、"b"、"c"、""}</span></code></pre></div>

<p>为了理解这种行为，回想一下空字符串在任何地方都匹配，所以上面的内容在性质上是相同的：</p>
<div class="code-wrapper"><pre><code class="hljs c++">QString str = <span class="hljs-string">"/a/b/c/"</span>;
<span class="hljs-keyword">auto</span> parts = str.<span class="hljs-built_in">split</span>(<span class="hljs-built_in">QLatin1Char</span>(<span class="hljs-string">'/'</span>));
<span class="hljs-comment">// parts: {"", "a", "b", "c", ""}</span></code></pre></div>

<p>该函数在 Qt 5.14 引入。</p>
<p><strong>See also</strong> <a href="qstringlist.html#join">QStringList::join</a>() and <a href="#section">section</a>().</p>
<h3><span id="since-5-14-qstringlist-qstring-split-qchar-sep-qt-splitbehavior-behavior-qt-keepemptyparts-qt-casesensitivity-cs-qt-casesensitive-const"><code>[since 5.14]</code> QString::split( <em>sep</em>,  <em>behavior</em> = Qt::KeepEmptyParts,  <em>cs</em> = Qt::CaseSensitive) const</span><a href="#since-5-14-qstringlist-qstring-split-qchar-sep-qt-splitbehavior-behavior-qt-keepemptyparts-qt-casesensitivity-cs-qt-casesensitive-const" class="header-anchor">#</a></h3><p>这是一个重载函数。</p>
<p>该函数在 Qt 5.14 引入。</p>
<h3><span id="since-5-14-qstringlist-qstring-split-const-qregularexpression-amp-re-qt-splitbehavior-behavior-qt-keepemptyparts-const"><code>[since 5.14]</code> QString::split(const  &amp;<em>re</em>,  <em>behavior</em> = Qt::KeepEmptyParts) const</span><a href="#since-5-14-qstringlist-qstring-split-const-qregularexpression-amp-re-qt-splitbehavior-behavior-qt-keepemptyparts-const" class="header-anchor">#</a></h3><p>这是一个重载函数。</p>
<p>将字符串拆分为正则表达式 <em>re</em> 匹配的子字符串，并返回这些字符串的列表。 如果 <em>re</em> 不匹配字符串中的任何位置，split() 将返回包含此字符串的单元素列表。</p>
<p>这是一个示例，我们使用一个或多个空格字符作为分隔符来提取句子中的单词：</p>
<div class="code-wrapper"><pre><code class="hljs C++">QString str;
QStringList list;

str = <span class="hljs-string">"Some  text\n\twith  strange whitespace."</span>;
list = str.<span class="hljs-built_in">split</span>(<span class="hljs-built_in">QRegularExpression</span>(<span class="hljs-string">"\\s+"</span>));
<span class="hljs-comment">// list: [ "Some", "text", "with", "strange", "whitespace." ]</span></code></pre></div>

<p>这是一个类似的例子，但这次我们使用任何非单词字符序列作为分隔符：</p>
<div class="code-wrapper"><pre><code class="hljs C++">str = <span class="hljs-string">"This time, a normal English sentence."</span>;
list = str.<span class="hljs-built_in">split</span>(<span class="hljs-built_in">QRegularExpression</span>(<span class="hljs-string">"\\W+"</span>), Qt::SkipEmptyParts);
<span class="hljs-comment">// list: [ "This", "time", "a", "normal", "English", "sentence" ]</span></code></pre></div>

<p>这是第三个示例，我们使用零长度断言 <strong>\b</strong> （单词边界）将字符串拆分为非单词和单词标记的交替序列：</p>
<div class="code-wrapper"><pre><code class="hljs C++">str = <span class="hljs-string">"Now: this sentence fragment."</span>;
list = str.<span class="hljs-built_in">split</span>(<span class="hljs-built_in">QRegularExpression</span>(<span class="hljs-string">"\\b"</span>));
<span class="hljs-comment">// list: [ "", "Now", ": ", "this", " ", "sentence", " ", "fragment", "." ]</span></code></pre></div>

<p>该函数在 Qt 5.14 引入。</p>
<p><strong>See also</strong> <a href="qstringlist.html#join">QStringList::join</a>() and <a href="#section">section</a>().</p>
<h3><span id="void-qstring-squeeze">void QString::squeeze()</span><a href="#void-qstring-squeeze" class="header-anchor">#</a></h3><p>释放存储字符数据不需要的任何内存。</p>
<p>此函数的唯一目的是提供一种微调 <a href>QString</a> 内存使用的方法。 通常，您很少需要调用此函数。</p>
<p><strong>See also</strong> <a href="#reserve">reserve</a>() and <a href="#capacity">capacity</a>().</p>
<h3><span id="bool-qstring-startswith-const-qstring-amp-s-qt-casesensitivity-cs-qt-casesensitive-const">bool QString::startsWith(const  &amp;<em>s</em>,  <em>cs</em> = Qt::CaseSensitive) const</span><a href="#bool-qstring-startswith-const-qstring-amp-s-qt-casesensitivity-cs-qt-casesensitive-const" class="header-anchor">#</a></h3><p>如果字符串以 <em>s</em> 开头，则返回 <code>true</code>； 否则返回“假”。</p>
<p>如果 <em>cs</em> 是 <a href="qt.html#CaseSensitivity-enum">Qt::CaseSensitive</a> （默认），则搜索区分大小写； 否则搜索不区分大小写。</p>
<div class="code-wrapper"><pre><code class="hljs C++">QString str = <span class="hljs-string">"Bananas"</span>;
str.<span class="hljs-built_in">startsWith</span>(<span class="hljs-string">"Ban"</span>);     <span class="hljs-comment">// returns true</span>
str.<span class="hljs-built_in">startsWith</span>(<span class="hljs-string">"Car"</span>);     <span class="hljs-comment">// returns false</span></code></pre></div>

<p><strong>See also</strong> <a href="#endsWith">endsWith</a>().</p>
<h3><span id="since-5-10-bool-qstring-startswith-qstringview-str-qt-casesensitivity-cs-qt-casesensitive-const"><code>[since 5.10]</code>bool QString::startsWith( <em>str</em>,  <em>cs</em> = Qt::CaseSensitive) const</span><a href="#since-5-10-bool-qstring-startswith-qstringview-str-qt-casesensitivity-cs-qt-casesensitive-const" class="header-anchor">#</a></h3><p>这是一个重载函数。</p>
<p>如果字符串以字符串视图 <em>str</em> 开头，则返回 <code>true</code>； 否则返回“假”。</p>
<p>如果 <em>cs</em> 为 <a href="qt.html#CaseSensitivity-enum">Qt::CaseSensitive</a> （默认），则搜索区分大小写； 否则搜索不区分大小写。</p>
<p>该函数在 Qt 5.10 引入。</p>
<p><strong>See also</strong> <a href="#endsWith">endsWith</a>().</p>
<h3><span id="bool-qstring-startswith-qlatin1string-s-qt-casesensitivity-cs-qt-casesensitive-const">bool QString::startsWith( <em>s</em>,  <em>cs</em> = Qt::CaseSensitive) const</span><a href="#bool-qstring-startswith-qlatin1string-s-qt-casesensitivity-cs-qt-casesensitive-const" class="header-anchor">#</a></h3><p>这个函数重载了 startsWith().</p>
<h3><span id="bool-qstring-startswith-qchar-c-qt-casesensitivity-cs-qt-casesensitive-const">bool QString::startsWith( <em>c</em>,  <em>cs</em> = Qt::CaseSensitive) const</span><a href="#bool-qstring-startswith-qchar-c-qt-casesensitivity-cs-qt-casesensitive-const" class="header-anchor">#</a></h3><p>这个函数重载了 startsWith().</p>
<p>如果字符串以 <em>c</em> 开头，则返回 <code>true</code>； 否则返回“假”。</p>
<h3><span id="void-qstring-swap-qstring-amp-other">void QString::swap( &amp;<em>other</em>)</span><a href="#void-qstring-swap-qstring-amp-other" class="header-anchor">#</a></h3><p>用此字符串交换字符串 <em>other</em>。 此操作非常快且永不失败。</p>
<h3><span id="5-2-qi-cfstringref-qstring-tocfstring-const"><code>[5.2 起]</code>CFStringRef QString::toCFString() const</span><a href="#5-2-qi-cfstringref-qstring-tocfstring-const" class="header-anchor">#</a></h3><p>从 <a href>QString</a> 创建一个 CFString。</p>
<p>调用者拥有 CFString 并负责释放它。</p>
<p><strong>注意：</strong> 此功能仅适用于 macOS 和 iOS。</p>
<p>该函数在 Qt 5.2 引入。</p>
<h3><span id="qstring-qstring-tocasefolded-const"> QString::toCaseFolded() const</span><a href="#qstring-qstring-tocasefolded-const" class="header-anchor">#</a></h3><p>返回字符串的大小写折叠等效项。 对于大多数 Unicode 字符，这与 <a href="#toLower">toLower</a>() 相同。</p>
<h3><span id="double-qstring-todouble-bool-ok-nullptr-const">double QString::toDouble(bool *<em>ok</em> = nullptr) const</span><a href="#double-qstring-todouble-bool-ok-nullptr-const" class="header-anchor">#</a></h3><p>返回转换为 <code>double</code> 值的字符串。</p>
<p>如果转换上溢，则返回无穷大；如果转换因其他原因（例如下溢）失败，则返回 0.0。</p>
<p>如果 <em>ok</em> 不是 <code>nullptr</code>，则将 *<em>ok</em> 设置为 <code>false</code> 会报告失败，将 *<em>ok</em> 设置为 <code>true</code> 会报告成功。</p>
<div class="code-wrapper"><pre><code class="hljs C++">QString str = <span class="hljs-string">"1234.56"</span>;
<span class="hljs-type">double</span> val = str.<span class="hljs-built_in">toDouble</span>();   <span class="hljs-comment">// val == 1234.56</span></code></pre></div>

<p><strong>警告：</strong> <a href>QString</a> 内容只能包含有效的数字字符，包括加号/减号、科学计数法中使用的字符 e 和小数点。 包含单位或附加字符会导致转换错误。</p>
<div class="code-wrapper"><pre><code class="hljs C++"><span class="hljs-type">bool</span> ok;
<span class="hljs-type">double</span> d;

d = <span class="hljs-built_in">QString</span>( <span class="hljs-string">"1234.56e-02"</span> ).<span class="hljs-built_in">toDouble</span>(&amp;ok); <span class="hljs-comment">// ok == true, d == 12.3456</span>

d = <span class="hljs-built_in">QString</span>( <span class="hljs-string">"1234.56e-02 Volt"</span> ).<span class="hljs-built_in">toDouble</span>(&amp;ok); <span class="hljs-comment">// ok == false, d == 0</span></code></pre></div>

<p>字符串转换将始终在“C”语言环境中进行。 对于依赖于语言环境的转换，请使用 <a href="qlocale.html#toDouble">QLocale::toDouble</a>()</p>
<div class="code-wrapper"><pre><code class="hljs C++">d = <span class="hljs-built_in">QString</span>( <span class="hljs-string">"1234,56"</span> ).<span class="hljs-built_in">toDouble</span>(&amp;ok); <span class="hljs-comment">// ok == false</span>
d = <span class="hljs-built_in">QString</span>( <span class="hljs-string">"1234.56"</span> ).<span class="hljs-built_in">toDouble</span>(&amp;ok); <span class="hljs-comment">// ok == true, d == 1234.56</span></code></pre></div>

<p>由于历史原因，此函数不处理千组分隔符。 如果您需要转换此类数字，请使用 <a href="qlocale.html#toDouble">QLocale::toDouble</a>()。</p>
<div class="code-wrapper"><pre><code class="hljs C++">d = <span class="hljs-built_in">QString</span>( <span class="hljs-string">"1,234,567.89"</span> ).<span class="hljs-built_in">toDouble</span>(&amp;ok); <span class="hljs-comment">// ok == false</span>
d = <span class="hljs-built_in">QString</span>( <span class="hljs-string">"1234567.89"</span> ).<span class="hljs-built_in">toDouble</span>(&amp;ok); <span class="hljs-comment">// ok == true</span></code></pre></div>

<p>此函数忽略前导和尾随空格。</p>
<p><strong>See also</strong> <a href="#number">number</a>(), <a href="qlocale.html#setDefault">QLocale::setDefault</a>(), <a href="qlocale.html#toDouble">QLocale::toDouble</a>(), and <a href="#trimmed">trimmed</a>().</p>
<h3><span id="float-qstring-tofloat-bool-ok-nullptr-const">float QString::toFloat(bool *<em>ok</em> = nullptr) const</span><a href="#float-qstring-tofloat-bool-ok-nullptr-const" class="header-anchor">#</a></h3><p>返回转换为 <code>float</code> 值的字符串。</p>
<p>如果转换上溢，则返回无穷大；如果转换因其他原因（例如下溢）失败，则返回 0.0。</p>
<p>如果 <em>ok</em> 不是 <code>nullptr</code>，则将 *<em>ok</em> 设置为 <code>false</code> 会报告失败，将 *<em>ok</em> 设置为 <code>true</code> 会报告成功。</p>
<p><strong>警告：</strong> <a href>QString</a> 内容只能包含有效的数字字符，包括加号/减号、科学计数法中使用的字符 e 和小数点。 包含单位或附加字符会导致转换错误。</p>
<p>字符串转换将始终在“C”语言环境中进行。 对于依赖于语言环境的转换，请使用 <a href="qlocale.html#toFloat">QLocale::toFloat</a>()</p>
<p>由于历史原因，此函数不处理千组分隔符。 如果您需要转换此类数字，请使用 <a href="qlocale.html#toFloat">QLocale::toFloat</a>()。</p>
<p>例子:</p>
<div class="code-wrapper"><pre><code class="hljs C++">QString str1 = <span class="hljs-string">"1234.56"</span>;
str1.<span class="hljs-built_in">toFloat</span>();             <span class="hljs-comment">// returns 1234.56</span>

<span class="hljs-type">bool</span> ok;
QString str2 = <span class="hljs-string">"R2D2"</span>;
str2.<span class="hljs-built_in">toFloat</span>(&amp;ok);          <span class="hljs-comment">// returns 0.0, sets ok to false</span>

QString str3 = <span class="hljs-string">"1234.56 Volt"</span>;
str3.<span class="hljs-built_in">toFloat</span>(&amp;ok);          <span class="hljs-comment">// returns 0.0, sets ok to false</span></code></pre></div>

<p>此函数忽略前导和尾随空格。</p>
<p><strong>See also</strong> <a href="#number">number</a>(), <a href="#toDouble">toDouble</a>(), <a href="#toInt">toInt</a>(), <a href="qlocale.html#toFloat">QLocale::toFloat</a>(), and <a href="#trimmed">trimmed</a>().</p>
<h3><span id="since-5-0-qstring-qstring-tohtmlescaped-const"><code>[since 5.0]</code> QString::toHtmlEscaped() const</span><a href="#since-5-0-qstring-qstring-tohtmlescaped-const" class="header-anchor">#</a></h3><p>Converts a plain text string to an HTML string with HTML metacharacters <code>&lt;</code>, <code>&gt;</code>, <code>&amp;</code>, and <code>"</code> replaced by HTML entities.</p>
<p>例子:</p>
<div class="code-wrapper"><pre><code class="hljs C++">QString plain = <span class="hljs-string">"#include &lt;QtCore&gt;"</span>
QString html = plain.<span class="hljs-built_in">toHtmlEscaped</span>();
<span class="hljs-comment">// html == "#include &amp;lt;QtCore&amp;gt;"</span></code></pre></div>

<p>该函数在 Qt 5.0 引入。</p>
<h3><span id="int-qstring-toint-bool-ok-nullptr-int-base-10-const">int QString::toInt(bool *<em>ok</em> = nullptr, int <em>base</em> = 10) const</span><a href="#int-qstring-toint-bool-ok-nullptr-int-base-10-const" class="header-anchor">#</a></h3><p>返回使用 base <em>base</em> 转换为 <code>int</code> 的字符串，默认为 10，必须介于 2 和 36 之间，或 0。如果转换失败，则返回 0。</p>
<p>如果 <em>ok</em> 不是 <code>nullptr</code>，则将 *<em>ok</em> 设置为 <code>false</code> 会报告失败，将 *<em>ok</em> 设置为 <code>true</code> 会报告成功。</p>
<p>如果 <em>base</em> 为 0，则使用 C 语言约定：如果字符串以“0x”开头，则使用 base 16； 如果字符串以“0”开头，则使用基数 8； 否则，使用基数 10。</p>
<p>字符串转换将始终在“C”语言环境中进行。 对于依赖于语言环境的转换，请使用 <a href="qlocale.html#toInt">QLocale::toInt</a>()</p>
<p>例子:</p>
<div class="code-wrapper"><pre><code class="hljs C++">QString str = <span class="hljs-string">"FF"</span>;
<span class="hljs-type">bool</span> ok;
<span class="hljs-type">int</span> hex = str.<span class="hljs-built_in">toInt</span>(&amp;ok, <span class="hljs-number">16</span>);       <span class="hljs-comment">// hex == 255, ok == true</span>
<span class="hljs-type">int</span> dec = str.<span class="hljs-built_in">toInt</span>(&amp;ok, <span class="hljs-number">10</span>);       <span class="hljs-comment">// dec == 0, ok == false</span></code></pre></div>

<p>此函数忽略前导和尾随空格。</p>
<p><strong>See also</strong> <a href="#number">number</a>(), <a href="#toUInt">toUInt</a>(), <a href="#toDouble">toDouble</a>(), and <a href="qlocale.html#toInt">QLocale::toInt</a>().</p>
<h3><span id="qbytearray-qstring-tolatin1-const"> QString::toLatin1() const</span><a href="#qbytearray-qstring-tolatin1-const" class="header-anchor">#</a></h3><p>以 <a href="qbytearray.html">QByteArray</a> 形式返回字符串的 Latin-1 表示形式。</p>
<p>如果字符串包含非拉丁语字符，则返回的字节数组未定义。 这些字符可能会被隐藏或替换为问号。</p>
<p><strong>See also</strong> <a href="#fromLatin1">fromLatin1</a>(), <a href="#toUtf8">toUtf8</a>(), <a href="#toLocal8Bit">toLocal8Bit</a>(), and <a href="qstringencoder.html">QStringEncoder</a>.</p>
<h3><span id="qbytearray-qstring-tolocal8bit-const"> QString::toLocal8Bit() const</span><a href="#qbytearray-qstring-tolocal8bit-const" class="header-anchor">#</a></h3><p>以 <a href="qbytearray.html">QByteArray</a> 形式返回字符串的本地 8 位表示。 如果字符串包含本地 8 位编码不支持的字符，则返回的字节数组未定义。</p>
<p>在 Unix 系统上，这相当于 <a href="#toUtf8">toUtf8</a>()，在 Windows 上，系统当前代码页正在使用。</p>
<p>如果此字符串包含任何无法在语言环境中编码的字符，则返回的字节数组是未定义的。 这些字符可能会被其他字符隐藏或替换。</p>
<p><strong>See also</strong> <a href="#fromLocal8Bit">fromLocal8Bit</a>(), <a href="#toLatin1">toLatin1</a>(), <a href="#toUtf8">toUtf8</a>(), and <a href="qstringencoder.html">QStringEncoder</a>.</p>
<h3><span id="long-qstring-tolong-bool-ok-nullptr-int-base-10-const">long QString::toLong(bool *<em>ok</em> = nullptr, int <em>base</em> = 10) const</span><a href="#long-qstring-tolong-bool-ok-nullptr-int-base-10-const" class="header-anchor">#</a></h3><p>返回使用 base <em>base</em> 转换为 <code>long</code> 的字符串，默认为 10，必须介于 2 和 36 之间，或 0。如果转换失败，则返回 0。</p>
<p>如果 <em>ok</em> 不是 <code>nullptr</code>，则将 *<em>ok</em> 设置为 <code>false</code> 会报告失败，将 *<em>ok</em> 设置为 <code>true</code> 会报告成功。</p>
<p>如果 <em>base</em> 为 0，则使用 C 语言约定：如果字符串以“0x”开头，则使用 base 16； 如果字符串以“0”开头，则使用基数 8； 否则，使用基数 10。</p>
<p>字符串转换将始终在“C”语言环境中进行。 对于依赖于语言环境的转换，请使用 <a href="qlocale.html#toLongLong">QLocale::toLongLong</a>()</p>
<p>例子:</p>
<div class="code-wrapper"><pre><code class="hljs C++">QString str = <span class="hljs-string">"FF"</span>;
<span class="hljs-type">bool</span> ok;

<span class="hljs-type">long</span> hex = str.<span class="hljs-built_in">toLong</span>(&amp;ok, <span class="hljs-number">16</span>);     <span class="hljs-comment">// hex == 255, ok == true</span>
<span class="hljs-type">long</span> dec = str.<span class="hljs-built_in">toLong</span>(&amp;ok, <span class="hljs-number">10</span>);     <span class="hljs-comment">// dec == 0, ok == false</span></code></pre></div>

<p>此函数忽略前导和尾随空格。</p>
<p><strong>See also</strong> <a href="#number">number</a>(), <a href="#toULong">toULong</a>(), <a href="#toInt">toInt</a>(), and <a href="qlocale.html#toInt">QLocale::toInt</a>().</p>
<h3><span id="qlonglong-qstring-tolonglong-bool-ok-nullptr-int-base-10-const"> QString::toLongLong(bool *<em>ok</em> = nullptr, int <em>base</em> = 10) const</span><a href="#qlonglong-qstring-tolonglong-bool-ok-nullptr-int-base-10-const" class="header-anchor">#</a></h3><p>返回使用 base <em>base</em> 转换为 <code>long long</code> 的字符串，默认为 10，必须介于 2 和 36 之间，或 0。如果转换失败，则返回 0。</p>
<p>如果 <em>ok</em> 不是 <code>nullptr</code>，则将 *<em>ok</em> 设置为 <code>false</code> 会报告失败，将 *<em>ok</em> 设置为 <code>true</code> 会报告成功。</p>
<p>如果 <em>base</em> 为 0，则使用 C 语言约定：如果字符串以“0x”开头，则使用 base 16； 如果字符串以“0”开头，则使用基数 8； 否则，使用基数 10。</p>
<p>字符串转换将始终在“C”语言环境中进行。 对于依赖于语言环境的转换，请使用 <a href="qlocale.html#toLongLong">QLocale::toLongLong</a>()</p>
<p>例子:</p>
<div class="code-wrapper"><pre><code class="hljs C++">QString str = <span class="hljs-string">"FF"</span>;
<span class="hljs-type">bool</span> ok;

qint64 hex = str.<span class="hljs-built_in">toLongLong</span>(&amp;ok, <span class="hljs-number">16</span>);      <span class="hljs-comment">// hex == 255, ok == true</span>
qint64 dec = str.<span class="hljs-built_in">toLongLong</span>(&amp;ok, <span class="hljs-number">10</span>);      <span class="hljs-comment">// dec == 0, ok == false</span></code></pre></div>

<p>此函数忽略前导和尾随空格。</p>
<p><strong>See also</strong> <a href="#number">number</a>(), <a href="#toULongLong">toULongLong</a>(), <a href="#toInt">toInt</a>(), and <a href="qlocale.html#toLongLong">QLocale::toLongLong</a>().</p>
<h3><span id="qstring-qstring-tolower-const"> QString::toLower() const</span><a href="#qstring-qstring-tolower-const" class="header-anchor">#</a></h3><p>返回字符串的小写副本。</p>
<div class="code-wrapper"><pre><code class="hljs C++">QString str = <span class="hljs-string">"The Qt PROJECT"</span>;
str = str.<span class="hljs-built_in">toLower</span>();        <span class="hljs-comment">// str == "the qt project"</span></code></pre></div>

<p>大小写转换将始终发生在“C”语言环境中。 对于依赖于语言环境的大小写折叠，请使用 <a href="qlocale.html#toLower">QLocale::toLower</a>()</p>
<p><strong>See also</strong> <a href="#toUpper">toUpper</a>() and <a href="qlocale.html#toLower">QLocale::toLower</a>().</p>
<h3><span id="since-5-2-nsstring-qstring-tonsstring-const"><code>[since 5.2]</code>NSString *QString::toNSString() const</span><a href="#since-5-2-nsstring-qstring-tonsstring-const" class="header-anchor">#</a></h3><p>从 <a href>QString</a> 创建一个 NSString。</p>
<p>NSString 是自动释放的。</p>
<p><strong>注意：</strong> 此功能仅适用于 macOS 和 iOS。</p>
<p>该函数在 Qt 5.2 引入。</p>
<h3><span id="short-qstring-toshort-bool-ok-nullptr-int-base-10-const">short QString::toShort(bool *<em>ok</em> = nullptr, int <em>base</em> = 10) const</span><a href="#short-qstring-toshort-bool-ok-nullptr-int-base-10-const" class="header-anchor">#</a></h3><p>返回使用 base <em>base</em> 转换为 <code>short</code> 的字符串，默认为 10，必须介于 2 和 36 之间，或 0。如果转换失败，则返回 0。</p>
<p>如果 <em>ok</em> 不是 <code>nullptr</code>，则将 *<em>ok</em> 设置为 <code>false</code> 会报告失败，将 *<em>ok</em> 设置为 <code>true</code> 会报告成功。</p>
<p>如果 <em>base</em> 为 0，则使用 C 语言约定：如果字符串以“0x”开头，则使用 base 16； 如果字符串以“0”开头，则使用基数 8； 否则，使用基数 10。</p>
<p>字符串转换将始终在“C”语言环境中进行。 对于依赖于语言环境的转换，请使用 <a href="qlocale.html#toShort">QLocale::toShort</a>()</p>
<p>例子:</p>
<div class="code-wrapper"><pre><code class="hljs C++">QString str = <span class="hljs-string">"FF"</span>;
<span class="hljs-type">bool</span> ok;

<span class="hljs-type">short</span> hex = str.<span class="hljs-built_in">toShort</span>(&amp;ok, <span class="hljs-number">16</span>);   <span class="hljs-comment">// hex == 255, ok == true</span>
<span class="hljs-type">short</span> dec = str.<span class="hljs-built_in">toShort</span>(&amp;ok, <span class="hljs-number">10</span>);   <span class="hljs-comment">// dec == 0, ok == false</span></code></pre></div>

<p>此函数忽略前导和尾随空格。</p>
<p><strong>See also</strong> <a href="#number">number</a>(), <a href="#toUShort">toUShort</a>(), <a href="#toInt">toInt</a>(), and <a href="qlocale.html#toShort">QLocale::toShort</a>().</p>
<h3><span id="std-string-qstring-tostdstring-const">std::string QString::toStdString() const</span><a href="#std-string-qstring-tostdstring-const" class="header-anchor">#</a></h3><p>返回包含在此 <a href>QString</a> 中的数据的 std::string 对象。 使用 <a href="#toUtf8">toUtf8</a>() 函数将 Unicode 数据转换为 8 位字符。</p>
<p>此方法在将 <a href>QString</a> 传递给接受 std::string 对象的函数时最有用。</p>
<p><strong>See also</strong> <a href="#toLatin1">toLatin1</a>(), <a href="#toUtf8">toUtf8</a>(), <a href="#toLocal8Bit">toLocal8Bit</a>(), and <a href="qbytearray.html#toStdString">QByteArray::toStdString</a>().</p>
<h3><span id="since-5-5-std-u16string-qstring-tostdu16string-const"><code>[since 5.5]</code>std::u16string QString::toStdU16String() const</span><a href="#since-5-5-std-u16string-qstring-tostdu16string-const" class="header-anchor">#</a></h3><p>返回包含在此 <a href>QString</a> 中的数据的 std::u16string 对象。 Unicode 数据与 <a href="#utf16">utf16</a>() 方法返回的数据相同。</p>
<p>该函数在 Qt 5.5 引入。</p>
<p><strong>See also</strong> <a href="#utf16">utf16</a>(), <a href="#toStdWString">toStdWString</a>(), and <a href="#toStdU32String">toStdU32String</a>().</p>
<h3><span id="since-5-5-std-u32string-qstring-tostdu32string-const"><code>[since 5.5]</code>std::u32string QString::toStdU32String() const</span><a href="#since-5-5-std-u32string-qstring-tostdu32string-const" class="header-anchor">#</a></h3><p>返回带有包含在此 <a href>QString</a> 中的数据的 std::u32string 对象。 Unicode 数据与 <a href="#toUcs4">toUcs4</a>() 方法返回的数据相同。</p>
<p>该函数在 Qt 5.5 引入。</p>
<p><strong>See also</strong> <a href="#toUcs4">toUcs4</a>(), <a href="#toStdWString">toStdWString</a>(), and <a href="#toStdU16String">toStdU16String</a>().</p>
<h3><span id="std-wstring-qstring-tostdwstring-const">std::wstring QString::toStdWString() const</span><a href="#std-wstring-qstring-tostdwstring-const" class="header-anchor">#</a></h3><p>返回带有包含在此 <a href>QString</a> 中的数据的 std::wstring 对象。 std::wstring 在 wchar_t 为 2 字节宽的平台（例如 windows）上以 utf16 编码，在 wchar_t 为 4 字节宽的平台（大多数 Unix 系统）上以 ucs4 编码。</p>
<p>此方法对于将 <a href>QString</a> 传递给接受 std::wstring 对象的函数非常有用。</p>
<p><strong>See also</strong> <a href="#utf16">utf16</a>(), <a href="#toLatin1">toLatin1</a>(), <a href="#toUtf8">toUtf8</a>(), <a href="#toLocal8Bit">toLocal8Bit</a>(), <a href="#toStdU16String">toStdU16String</a>(), and <a href="#toStdU32String">toStdU32String</a>().</p>
<h3><span id="uint-qstring-touint-bool-ok-nullptr-int-base-10-const"> QString::toUInt(bool *<em>ok</em> = nullptr, int <em>base</em> = 10) const</span><a href="#uint-qstring-touint-bool-ok-nullptr-int-base-10-const" class="header-anchor">#</a></h3><p>返回使用 base <em>base</em> 转换为 <code>unsigned int</code> 的字符串，默认为 10，必须介于 2 和 36 之间，或 0。如果转换失败，则返回 0。</p>
<p>如果 <em>ok</em> 不是 <code>nullptr</code>，则将 * <em>ok</em> 设置为 <code>false</code> 会报告失败，将 * <em>ok</em> 设置为 <code>true</code> 会报告成功。</p>
<p>如果 <em>base</em> 为 0，则使用 C 语言约定：如果字符串以“0x”开头，则使用 base 16； 如果字符串以“0”开头，则使用基数 8； 否则，使用基数 10。</p>
<p>字符串转换将始终在“C”语言环境中进行。 对于依赖于语言环境的转换，请使用 <a href="qlocale.html#toUInt">QLocale::toUInt</a>()</p>
<p>例子:</p>
<div class="code-wrapper"><pre><code class="hljs C++">QString str = <span class="hljs-string">"FF"</span>;
<span class="hljs-type">bool</span> ok;

uint hex = str.<span class="hljs-built_in">toUInt</span>(&amp;ok, <span class="hljs-number">16</span>);     <span class="hljs-comment">// hex == 255, ok == true</span>
uint dec = str.<span class="hljs-built_in">toUInt</span>(&amp;ok, <span class="hljs-number">10</span>);     <span class="hljs-comment">// dec == 0, ok == false</span></code></pre></div>

<p>此函数忽略前导和尾随空格。</p>
<p><strong>See also</strong> <a href="#number">number</a>(), <a href="#toInt">toInt</a>(), and <a href="qlocale.html#toUInt">QLocale::toUInt</a>().</p>
<h3><span id="ulong-qstring-toulong-bool-ok-nullptr-int-base-10-const"> QString::toULong(bool *<em>ok</em> = nullptr, int <em>base</em> = 10) const</span><a href="#ulong-qstring-toulong-bool-ok-nullptr-int-base-10-const" class="header-anchor">#</a></h3><p>返回使用 base <em>base</em> 转换为 <code>unsigned long</code> 的字符串，默认为 10，必须介于 2 和 36 之间，或 0。如果转换失败，则返回 0。</p>
<p>如果 <em>ok</em> 不是 <code>nullptr</code>，则将 *<em>ok</em> 设置为 <code>false</code> 会报告失败，将 *<em>ok</em> 设置为 <code>true</code> 会报告成功。</p>
<p>如果 <em>base</em> 为 0，则使用 C 语言约定：如果字符串以“0x”开头，则使用 base 16； 如果字符串以“0”开头，则使用基数 8； 否则，使用基数 10。</p>
<p>字符串转换将始终在“C”语言环境中进行。 对于依赖于语言环境的转换，请使用 <a href="qlocale.html#toULongLong">QLocale::toULongLong</a>()</p>
<p>例子:</p>
<div class="code-wrapper"><pre><code class="hljs C++">QString str = <span class="hljs-string">"FF"</span>;
<span class="hljs-type">bool</span> ok;

ulong hex = str.<span class="hljs-built_in">toULong</span>(&amp;ok, <span class="hljs-number">16</span>);   <span class="hljs-comment">// hex == 255, ok == true</span>
ulong dec = str.<span class="hljs-built_in">toULong</span>(&amp;ok, <span class="hljs-number">10</span>);   <span class="hljs-comment">// dec == 0, ok == false</span></code></pre></div>

<p>此函数忽略前导和尾随空格。</p>
<p><strong>See also</strong> <a href="#number">number</a>() and <a href="qlocale.html#toUInt">QLocale::toUInt</a>().</p>
<h3><span id="qulonglong-qstring-toulonglong-bool-ok-nullptr-int-base-10-const"> QString::toULongLong(bool *<em>ok</em> = nullptr, int <em>base</em> = 10) const</span><a href="#qulonglong-qstring-toulonglong-bool-ok-nullptr-int-base-10-const" class="header-anchor">#</a></h3><p>返回使用 base <em>base</em> 转换为 <code>unsigned long long</code> 的字符串，默认为 10，必须介于 2 和 36 之间，或 0。如果转换失败，则返回 0。</p>
<p>如果 <em>ok</em> 不是 <code>nullptr</code>，则将 *<em>ok</em> 设置为 <code>false</code> 会报告失败，将 *<em>ok</em> 设置为 <code>true</code> 会报告成功。</p>
<p>如果 <em>base</em> 为 0，则使用 C 语言约定：如果字符串以“0x”开头，则使用 base 16； 如果字符串以“0”开头，则使用基数 8； 否则，使用基数 10。</p>
<p>字符串转换将始终在“C”语言环境中进行。 对于依赖于语言环境的转换，请使用 <a href="qlocale.html#toULongLong">QLocale::toULongLong</a>()</p>
<p>例子:</p>
<div class="code-wrapper"><pre><code class="hljs C++">QString str = <span class="hljs-string">"FF"</span>;
<span class="hljs-type">bool</span> ok;

quint64 hex = str.<span class="hljs-built_in">toULongLong</span>(&amp;ok, <span class="hljs-number">16</span>);    <span class="hljs-comment">// hex == 255, ok == true</span>
quint64 dec = str.<span class="hljs-built_in">toULongLong</span>(&amp;ok, <span class="hljs-number">10</span>);    <span class="hljs-comment">// dec == 0, ok == false</span></code></pre></div>

<p>此函数忽略前导和尾随空格。</p>
<p><strong>See also</strong> <a href="#number">number</a>(), <a href="#toLongLong">toLongLong</a>(), and <a href="qlocale.html#toULongLong">QLocale::toULongLong</a>().</p>
<h3><span id="ushort-qstring-toushort-bool-ok-nullptr-int-base-10-const"> QString::toUShort(bool *<em>ok</em> = nullptr, int <em>base</em> = 10) const</span><a href="#ushort-qstring-toushort-bool-ok-nullptr-int-base-10-const" class="header-anchor">#</a></h3><p>返回使用 base <em>base</em> 转换为 <code>unsigned short</code> 的字符串，默认为 10，必须介于 2 和 36 之间，或 0。如果转换失败，则返回 0。</p>
<p>如果 <em>ok</em> 不是 <code>nullptr</code>，则将 *<em>ok</em> 设置为 <code>false</code> 会报告失败，将 *<em>ok</em> 设置为 <code>true</code> 会报告成功。</p>
<p>如果 <em>base</em> 为 0，则使用 C 语言约定：如果字符串以“0x”开头，则使用 base 16； 如果字符串以“0”开头，则使用基数 8； 否则，使用基数 10。</p>
<p>字符串转换将始终在“C”语言环境中进行。 对于依赖于语言环境的转换，请使用 <a href="qlocale.html#toUShort">QLocale::toUShort</a>()</p>
<p>例子:</p>
<div class="code-wrapper"><pre><code class="hljs C++">QString str = <span class="hljs-string">"FF"</span>;
<span class="hljs-type">bool</span> ok;<span class="hljs-type">bool</span> ok;

ushort hex = str.<span class="hljs-built_in">toUShort</span>((&amp;ok, <span class="hljs-number">16</span>);          <span class="hljs-comment">// hex == 255, ok == true</span>
ushort dec = str.<span class="hljs-built_in">toUShort</span>((&amp;ok, <span class="hljs-number">10</span>);          <span class="hljs-comment">// dec == 0, ok == false</span></code></pre></div>

<p>此函数忽略前导和尾随空格。</p>
<p><strong>See also</strong> <a href="#number">number</a>(), <a href="#toShort">toShort</a>(), and <a href="qlocale.html#toUShort">QLocale::toUShort</a>().</p>
<h3><span id="qlist-lt-uint-gt-qstring-toucs4-const">&lt;&gt; QString::toUcs4() const</span><a href="#qlist-lt-uint-gt-qstring-toucs4-const" class="header-anchor">#</a></h3><p>将字符串的 UCS-4/UTF-32 表示形式返回为 <a href="qlist.html">QList</a><uint>。</uint></p>
<p>UCS-4 是一种 Unicode 编解码器，因此它是无损的。 此字符串中的所有字符都将在 UCS-4 中编码。 此字符串中任何无效的代码单元序列都将替换为 Unicode 的替换字符（<a href="qchar.html#SpecialCharacter-enum">QChar::ReplacementCharacter</a>，对应于 <code>U+FFFD</code>）。</p>
<p>返回的列表不是以 \0’ 结尾的。</p>
<p><strong>See also</strong> <a href="#fromUtf8">fromUtf8</a>(), <a href="#toUtf8">toUtf8</a>(), <a href="#toLatin1">toLatin1</a>(), <a href="#toLocal8Bit">toLocal8Bit</a>(), <a href="qstringencoder.html">QStringEncoder</a>, <a href="#fromUcs4">fromUcs4</a>(), and <a href="#toWCharArray">toWCharArray</a>().</p>
<h3><span id="qstring-qstring-toupper-const"> QString::toUpper() const</span><a href="#qstring-qstring-toupper-const" class="header-anchor">#</a></h3><p>返回字符串的大写副本。</p>
<div class="code-wrapper"><pre><code class="hljs C++">QString str = <span class="hljs-string">"TeXt"</span>;
str = str.<span class="hljs-built_in">toUpper</span>();        <span class="hljs-comment">// str == "TEXT"</span></code></pre></div>

<p>大小写转换将始终发生在“C”语言环境中。 对于依赖于语言环境的大小写折叠，请使用 <a href="qlocale.html#toUpper">QLocale::toUpper</a>()</p>
<p><strong>See also</strong> <a href="#toLower">toLower</a>() and <a href="qlocale.html#toLower">QLocale::toLower</a>().</p>
<h3><span id="qbytearray-qstring-toutf8-const"> QString::toUtf8() const</span><a href="#qbytearray-qstring-toutf8-const" class="header-anchor">#</a></h3><p>以 <a href="qbytearray.html">QByteArray</a> 形式返回字符串的 UTF-8 表示形式。</p>
<p>UTF-8 是一种 Unicode 编解码器，可以表示 Unicode 字符串中的所有字符，如 <a href>QString</a>。</p>
<p><strong>See also</strong> <a href="#fromUtf8">fromUtf8</a>(), <a href="#toLatin1">toLatin1</a>(), <a href="#toLocal8Bit">toLocal8Bit</a>(), and <a href="qstringencoder.html">QStringEncoder</a>.</p>
<h3><span id="qsizetype-qstring-towchararray-wchar-t-array-const">qsizetype QString::toWCharArray(wchar_t *<em>array</em>) const</span><a href="#qsizetype-qstring-towchararray-wchar-t-array-const" class="header-anchor">#</a></h3><p>用此 <a href>QString</a> 对象中包含的数据填充 <em>array</em>。 该数组在 wchar_t 为 2 字节宽的平台（例如 windows）上以 UTF-16 编码，在 wchar_t 为 4 字节宽的平台（大多数 Unix 系统）上以 UCS-4 编码。</p>
<p><em>array</em> 必须由调用者分配并包含足够的空间来保存完整的字符串（分配与字符串长度相同的数组总是足够的）。</p>
<p>此函数返回 <em>array</em> 中字符串的实际长度。</p>
<p><strong>注意：</strong> 此函数不会将空字符附加到数组中。</p>
<p><strong>See also</strong> <a href="#utf16">utf16</a>(), <a href="#toUcs4">toUcs4</a>(), <a href="#toLatin1">toLatin1</a>(), <a href="#toUtf8">toUtf8</a>(), <a href="#toLocal8Bit">toLocal8Bit</a>(), <a href="#toStdWString">toStdWString</a>(), and <a href="qstringview.html#toWCharArray">QStringView::toWCharArray</a>().</p>
<h3><span id="qstring-qstring-trimmed-const"> QString::trimmed() const</span><a href="#qstring-qstring-trimmed-const" class="header-anchor">#</a></h3><p>返回从开头和结尾删除空格的字符串。</p>
<p>空格是指 <a href="qchar.html#isSpace">QChar::isSpace</a>() 返回 <code>true</code> 的任何字符。 这包括 ASCII 字符“\t”、“\n”、“\v”、“\f”、“\r”和“”。</p>
<p>例子:</p>
<div class="code-wrapper"><pre><code class="hljs C++">QString str = <span class="hljs-string">"  lots\t of\nwhitespace\r\n "</span>;
str = str.<span class="hljs-built_in">trimmed</span>();
<span class="hljs-comment">// str == "lots\t of\nwhitespace"</span></code></pre></div>

<p>与 <a href="#simplified">simplified</a>() 不同，trimmed() 只保留内部空白。</p>
<p><strong>See also</strong> <a href="#simplified">simplified</a>().</p>
<h3><span id="void-qstring-truncate-qsizetype-position">void QString::truncate(qsizetype <em>position</em>)</span><a href="#void-qstring-truncate-qsizetype-position" class="header-anchor">#</a></h3><p>在给定的 <em>position</em> 索引处截断字符串。</p>
<p>如果指定的 <em>position</em> 索引超出字符串的末尾，则不会发生任何事情。</p>
<p>例子:</p>
<div class="code-wrapper"><pre><code class="hljs C++">QString str = <span class="hljs-string">"Vladivostok"</span>;
str.<span class="hljs-built_in">truncate</span>((<span class="hljs-number">4</span>);

<span class="hljs-comment">// str == "Vlad"</span></code></pre></div>

<p>如果 <em>position</em> 为负数，则相当于传递零。</p>
<p><strong>另见</strong> <a href="#chop">chop</a>()、<a href="#resize">resize</a>()、<a href="#first">first</a>() 和 <a href="qstringview.html#truncate">QStringView::truncate</a> ()。</p>
<h3><span id="const-qchar-qstring-unicode-const">const  *QString::unicode() const</span><a href="#const-qchar-qstring-unicode-const" class="header-anchor">#</a></h3><p>返回字符串的 Unicode 表示。结果保持有效，直到字符串被修改。</p>
<p><strong>注意：</strong> 返回的字符串不能以 ‘\0’ 结尾。使用 <a href="#size">size</a>() 确定数组的长度。</p>
<p><strong>另请参阅</strong> <a href="#setUnicode">setUnicode</a>()、<a href="#utf16">utf16</a>() 和 <a href="#fromRawData">fromRawData</a>()。</p>
<h3><span id="const-ushort-qstring-utf16-const">const  *QString::utf16() const</span><a href="#const-ushort-qstring-utf16-const" class="header-anchor">#</a></h3><p>将 <a href>QString</a> 作为以 ‘\0’ 结尾的无符号短裤数组返回。结果保持有效，直到字符串被修改。</p>
<p>返回的字符串按主机字节顺序排列。</p>
<p><strong>另请参阅</strong> <a href="#setUtf16">setUtf16</a>() 和 <a href="#unicode">unicode</a>()。</p>
<h3><span id="static-since-5-5-qstring-qstring-vasprintf-const-char-cformat-va-list-ap"><code>[static, since 5.5]</code> QString::vasprintf(const char *<em>cformat</em>, va_list <em>ap</em>)</span><a href="#static-since-5-5-qstring-qstring-vasprintf-const-char-cformat-va-list-ap" class="header-anchor">#</a></h3><p>等效于 <a href="#asprintf">asprintf</a>() 的方法，但采用 va_list <em>ap</em> 而不是变量参数列表。有关 <em>cformat</em> 的说明，请参阅 <a href="#asprintf">asprintf</a>() 文档。</p>
<p>此方法不调用 va_end 宏，调用者负责在 <em>ap</em> 上调用 va_end。</p>
<p>该函数在 Qt 5.5 引入。</p>
<p><strong>See also</strong> <a href="#asprintf">asprintf</a>().</p>
<h3><span id="bool-qstring-operator-const-char-other-const">bool QString::operator!=(const char *<em>other</em>) const</span><a href="#bool-qstring-operator-const-char-other-const" class="header-anchor">#</a></h3><p>这个函数重载了 operator!=().</p>
<p><em>other</em> const char 指针使用 <a href="#fromUtf8">fromUtf8</a>() 函数转换为 <a href>QString</a>。</p>
<p>您可以通过在编译应用程序时定义 <a href="#QT_NO_CAST_FROM_ASCII">QT_NO_CAST_FROM_ASCII</a> 来禁用此运算符。 例如，如果您想确保所有用户可见的字符串都通过 <a href="qobject.html#tr">QObject::tr</a>()，这将很有用。</p>
<h3><span id="bool-qstring-operator-const-qbytearray-amp-other-const">bool QString::operator!=(const  &amp;<em>other</em>) const</span><a href="#bool-qstring-operator-const-qbytearray-amp-other-const" class="header-anchor">#</a></h3><p>这个函数重载了 operator!=().</p>
<p>使用 <a href="#fromUtf8">fromUtf8</a>() 函数将 <em>other</em> 字节数组转换为 <a href>QString</a>。 如果任何 NUL 字符 (‘\0’) 嵌入到字节数组中，它们将包含在转换中。</p>
<p>您可以通过在编译应用程序时定义 <a href="#QT_NO_CAST_FROM_ASCII">QT_NO_CAST_FROM_ASCII</a> 来禁用此运算符。 例如，如果您想确保所有用户可见的字符串都通过 <a href="qobject.html#tr">QObject::tr</a>()，这将很有用。</p>
<h3><span id="qstring-amp-qstring-operator-const-qstring-amp-other"> &amp;QString::operator+=(const  &amp;<em>other</em>)</span><a href="#qstring-amp-qstring-operator-const-qstring-amp-other" class="header-anchor">#</a></h3><p>将字符串 <em>other</em> 附加到该字符串的末尾并返回对该字符串的引用。</p>
<p>例子:</p>
<div class="code-wrapper"><pre><code class="hljs C++">QString x = <span class="hljs-string">"free"</span>;
QString y = <span class="hljs-string">"dom"</span>;
x += y;
<span class="hljs-comment">// x == "freedom"</span></code></pre></div>

<p>此操作通常非常快（<a href="containers.html#constant-time">constant time</a>），因为 <a href>QString</a> 在字符串数据的末尾预先分配了额外的空间，因此它可以增长而无需每次重新分配整个字符串。</p>
<p><strong>See also</strong> <a href="#append">append</a>() and <a href="#prepend">prepend</a>().</p>
<h3><span id="qstring-amp-qstring-operator-qchar-ch"> &amp;QString::operator+=( <em>ch</em>)</span><a href="#qstring-amp-qstring-operator-qchar-ch" class="header-anchor">#</a></h3><p>这个函数重载了 operator+=().</p>
<p>将字符 <em>ch</em> 附加到字符串。</p>
<h3><span id="since-6-0-qstring-amp-qstring-operator-qstringview-str"><code>[since 6.0]</code> &amp;QString::operator+=( <em>str</em>)</span><a href="#since-6-0-qstring-amp-qstring-operator-qstringview-str" class="header-anchor">#</a></h3><p>这个函数重载了 operator+=().</p>
<p>将字符串视图 <em>str</em> 附加到此字符串。</p>
<p>该函数在 Qt 6.0 引入。</p>
<h3><span id="qstring-amp-qstring-operator-qlatin1string-str"> &amp;QString::operator+=( <em>str</em>)</span><a href="#qstring-amp-qstring-operator-qlatin1string-str" class="header-anchor">#</a></h3><p>这个函数重载了 operator+=().</p>
<p>将 Latin-1 字符串 <em>str</em> 附加到此字符串。</p>
<h3><span id="qstring-amp-qstring-operator-const-char-str"> &amp;QString::operator+=(const char *<em>str</em>)</span><a href="#qstring-amp-qstring-operator-const-char-str" class="header-anchor">#</a></h3><p>这个函数重载了 operator+=().</p>
<p>将字符串 <em>str</em> 附加到此字符串。 使用 <a href="#fromUtf8">fromUtf8</a>() 函数将 const char 指针转换为 Unicode。</p>
<p>您可以通过在编译应用程序时定义 <a href="#QT_NO_CAST_FROM_ASCII">QT_NO_CAST_FROM_ASCII</a> 来禁用此功能。 例如，如果您想确保所有用户可见的字符串都通过 <a href="qobject.html#tr">QObject::tr</a>()，这将很有用。</p>
<h3><span id="qstring-amp-qstring-operator-const-qbytearray-amp-ba"> &amp;QString::operator+=(const  &amp;<em>ba</em>)</span><a href="#qstring-amp-qstring-operator-const-qbytearray-amp-ba" class="header-anchor">#</a></h3><p>这个函数重载了 operator+=().</p>
<p>将字节数组 <em>ba</em> 附加到此字符串。 使用 <a href="#fromUtf8">fromUtf8</a>() 函数将字节数组转换为 Unicode。 如果任何 NUL 字符 (‘\0’) 嵌入到 <em>ba</em> 字节数组中，它们将包含在转换中。</p>
<p>您可以通过在编译应用程序时定义 <a href="#QT_NO_CAST_FROM_ASCII">QT_NO_CAST_FROM_ASCII</a> 来禁用此功能。 例如，如果您想确保所有用户可见的字符串都通过 <a href="qobject.html#tr">QObject::tr</a>()，这将很有用。</p>
<h3><span id="bool-qstring-operator-lt-const-char-other-const">bool QString::operator&lt;(const char *<em>other</em>) const</span><a href="#bool-qstring-operator-lt-const-char-other-const" class="header-anchor">#</a></h3><p>如果此字符串在词法上小于字符串 <em>other</em>，则返回 <code>true</code>。 否则返回 <code>false</code>。</p>
<p>这个函数重载了 operator&lt;().</p>
<p><em>other</em> const char 指针使用 <a href="#fromUtf8">fromUtf8</a>() 函数转换为 <a href>QString</a>。</p>
<p>您可以通过在编译应用程序时定义 <a href="#QT_NO_CAST_FROM_ASCII">QT_NO_CAST_FROM_ASCII</a> 来禁用此运算符。 例如，如果您想确保所有用户可见的字符串都通过 <a href="qobject.html#tr">QObject::tr</a>()，这将很有用。</p>
<h3><span id="bool-qstring-operator-lt-const-qbytearray-amp-other-const">bool QString::operator&lt;(const  &amp;<em>other</em>) const</span><a href="#bool-qstring-operator-lt-const-qbytearray-amp-other-const" class="header-anchor">#</a></h3><p>这个函数重载了 operator&lt;().</p>
<p>使用 <a href="#fromUtf8">fromUtf8</a>() 函数将 <em>other</em> 字节数组转换为 <a href>QString</a>。 如果任何 NUL 字符 (‘\0’) 嵌入到字节数组中，它们将包含在转换中。</p>
<p>您可以在编译应用程序时禁用此运算符 <a href="#QT_NO_CAST_FROM_ASCII">QT_NO_CAST_FROM_ASCII</a>。 例如，如果您想确保所有用户可见的字符串都通过 <a href="qobject.html#tr">QObject::tr</a>()，这将很有用。</p>
<h3><span id="bool-qstring-operator-lt-const-char-other-const">bool QString::operator&lt;=(const char *<em>other</em>) const</span><a href="#bool-qstring-operator-lt-const-char-other-const" class="header-anchor">#</a></h3><p>这个函数重载了 operator&lt;=().</p>
<p><em>other</em> const char 指针使用 <a href="#fromUtf8">fromUtf8</a>() 函数转换为 <a href>QString</a>。</p>
<p>您可以通过在编译应用程序时定义 <a href="#QT_NO_CAST_FROM_ASCII">QT_NO_CAST_FROM_ASCII</a> 来禁用此运算符。 例如，如果您想确保所有用户可见的字符串都通过 <a href="qobject.html#tr">QObject::tr</a>()，这将很有用。</p>
<h3><span id="bool-qstring-operator-lt-const-qbytearray-amp-other-const">bool QString::operator&lt;=(const  &amp;<em>other</em>) const</span><a href="#bool-qstring-operator-lt-const-qbytearray-amp-other-const" class="header-anchor">#</a></h3><p>这个函数重载了 operator&lt;=().</p>
<p>使用 <a href="#fromUtf8">fromUtf8</a>() 函数将 <em>other</em> 字节数组转换为 <a href>QString</a>。 如果任何 NUL 字符 (‘\0’) 嵌入到字节数组中，它们将包含在转换中。</p>
<p>您可以通过在编译应用程序时定义 <a href="#QT_NO_CAST_FROM_ASCII">QT_NO_CAST_FROM_ASCII</a> 来禁用此运算符。 例如，如果您想确保所有用户可见的字符串都通过 <a href="qobject.html#tr">QObject::tr</a>()，这将很有用。</p>
<h3><span id="qstring-amp-qstring-operator-qchar-ch"> &amp;QString::operator=( <em>ch</em>)</span><a href="#qstring-amp-qstring-operator-qchar-ch" class="header-anchor">#</a></h3><p>这个函数重载了 operator=().</p>
<p>将字符串设置为包含单个字符 <em>ch</em>。</p>
<h3><span id="qstring-amp-qstring-operator-qlatin1string-str"> &amp;QString::operator=( <em>str</em>)</span><a href="#qstring-amp-qstring-operator-qlatin1string-str" class="header-anchor">#</a></h3><p>这个函数重载了 operator=().</p>
<p>将 Latin-1 字符串 <em>str</em> 分配给该字符串。</p>
<h3><span id="qstring-amp-qstring-operator-const-char-str"> &amp;QString::operator=(const char *<em>str</em>)</span><a href="#qstring-amp-qstring-operator-const-char-str" class="header-anchor">#</a></h3><p>这个函数重载了 operator=().</p>
<p>将 <em>str</em> 分配给此字符串。 使用 <a href="#fromUtf8">fromUtf8</a>() 函数将 const char 指针转换为 Unicode。</p>
<p>您可以通过在编译应用程序时定义 <a href="#QT_NO_CAST_FROM_ASCII">QT_NO_CAST_FROM_ASCII</a> 或 <a href="#QT_RESTRICTED_CAST_FROM_ASCII">QT_RESTRICTED_CAST_FROM_ASCII</a> 来禁用此运算符。 例如，如果您想确保所有用户可见的字符串都通过 <a href="qobject.html#tr">QObject::tr</a>()，这将很有用。</p>
<h3><span id="bool-qstring-operator-const-char-other-const">bool QString::operator==(const char *<em>other</em>) const</span><a href="#bool-qstring-operator-const-char-other-const" class="header-anchor">#</a></h3><p>这个函数重载了 operator==().</p>
<p><em>other</em> const char 指针使用 <a href="#fromUtf8">fromUtf8</a>() 函数转换为 <a href>QString</a>。</p>
<p>您可以通过在编译应用程序时定义 <a href="#QT_NO_CAST_FROM_ASCII">QT_NO_CAST_FROM_ASCII</a> 来禁用此运算符。 例如，如果您想确保所有用户可见的字符串都通过 <a href="qobject.html#tr">QObject::tr</a>()，这将很有用。</p>
<h3><span id="bool-qstring-operator-const-qbytearray-amp-other-const">bool QString::operator==(const  &amp;<em>other</em>) const</span><a href="#bool-qstring-operator-const-qbytearray-amp-other-const" class="header-anchor">#</a></h3><p>这个函数重载了 operator==().</p>
<p>使用 <a href="#fromUtf8">fromUtf8</a>() 函数将 <em>other</em> 字节数组转换为 <a href>QString</a>。 此函数在找到的第一个 NUL 字符或字节数组的末尾停止转换。</p>
<p>您可以通过在编译应用程序时定义 <a href="#QT_NO_CAST_FROM_ASCII">QT_NO_CAST_FROM_ASCII</a> 来禁用此运算符。 例如，如果您想确保所有用户可见的字符串都通过 <a href="qobject.html#tr">QObject::tr</a>()，这将很有用。</p>
<p>如果此字符串在词法上等于参数字符串 <em>other</em>，则返回 <code>true</code>。 否则返回 <code>false</code>。</p>
<h3><span id="bool-qstring-operator-gt-const-char-other-const">bool QString::operator&gt;(const char *<em>other</em>) const</span><a href="#bool-qstring-operator-gt-const-char-other-const" class="header-anchor">#</a></h3><p>这个函数重载了 operator&gt;().</p>
<p><em>other</em> const char 指针使用 <a href="#fromUtf8">fromUtf8</a>() 函数转换为 <a href>QString</a>。</p>
<p>您可以通过在编译应用程序时定义 <a href="#QT_NO_CAST_FROM_ASCII">QT_NO_CAST_FROM_ASCII</a> 来禁用此运算符。 例如，如果您想确保所有用户可见的字符串都通过 <a href="qobject.html#tr">QObject::tr</a>()，这将很有用。</p>
<h3><span id="bool-qstring-operator-gt-const-qbytearray-amp-other-const">bool QString::operator&gt;(const  &amp;<em>other</em>) const</span><a href="#bool-qstring-operator-gt-const-qbytearray-amp-other-const" class="header-anchor">#</a></h3><p>这个函数重载了 operator&gt;().</p>
<p>使用 <a href="#fromUtf8">fromUtf8</a>() 函数将 <em>other</em> 字节数组转换为 <a href>QString</a>。 如果任何 NUL 字符 (‘\0’) 嵌入到字节数组中，它们将包含在转换中。</p>
<p>您可以通过在编译应用程序时定义 <a href="#QT_NO_CAST_FROM_ASCII">QT_NO_CAST_FROM_ASCII</a> 来禁用此运算符。 例如，如果您想确保所有用户可见的字符串都通过 <a href="qobject.html#tr">QObject::tr</a>()，这将很有用。</p>
<h3><span id="bool-qstring-operator-gt-const-char-other-const">bool QString::operator&gt;=(const char *<em>other</em>) const</span><a href="#bool-qstring-operator-gt-const-char-other-const" class="header-anchor">#</a></h3><p>这个函数重载了 operator&gt;=().</p>
<p><em>other</em> const char 指针使用 <a href="#fromUtf8">fromUtf8</a>() 函数转换为 <a href>QString</a>。</p>
<p>您可以通过在编译应用程序时定义 <a href="#QT_NO_CAST_FROM_ASCII">QT_NO_CAST_FROM_ASCII</a> 来禁用此运算符。 例如，如果您想确保所有用户可见的字符串都通过 <a href="qobject.html#tr">QObject::tr</a>()，这将很有用。</p>
<h3><span id="bool-qstring-operator-gt-const-qbytearray-amp-other-const">bool QString::operator&gt;=(const  &amp;<em>other</em>) const</span><a href="#bool-qstring-operator-gt-const-qbytearray-amp-other-const" class="header-anchor">#</a></h3><p>这个函数重载了 operator&gt;=().</p>
<p>使用 <a href="#fromUtf8">fromUtf8</a>() 函数将 <em>other</em> 字节数组转换为 <a href>QString</a>。 如果任何 NUL 字符 (‘\0’) 嵌入到字节数组中，它们将包含在转换中。</p>
<p>您可以通过在编译应用程序时定义 <a href="#QT_NO_CAST_FROM_ASCII">QT_NO_CAST_FROM_ASCII</a> 来禁用此运算符。 例如，如果您想确保所有用户可见的字符串都通过 <a href="qobject.html#tr">QObject::tr</a>()，这将很有用。</p>
<h3><span id="qchar-amp-qstring-operator-qsizetype-position"> &amp;QString::operator[](qsizetype *position*)</span><a href="#qchar-amp-qstring-operator-qsizetype-position" class="header-anchor">#</a></h3><p>返回字符串中指定<em>position</em>处的字符作为可修改引用。</p>
<p>例子:</p>
<div class="code-wrapper"><pre><code class="hljs C++">QString str;

<span class="hljs-keyword">if</span> (str[<span class="hljs-number">0</span>] == <span class="hljs-built_in">QChar</span>(<span class="hljs-string">'?'</span>))
    str[<span class="hljs-number">0</span>] = <span class="hljs-built_in">QChar</span>(<span class="hljs-string">'_'</span>);</code></pre></div>

<p><strong>See also</strong> <a href="#at">at</a>().</p>
<h3><span id="const-qchar-qstring-operator-qsizetype-position-const">const  QString::operator[](qsizetype *position*) const</span><a href="#const-qchar-qstring-operator-qsizetype-position-const" class="header-anchor">#</a></h3><p>这个函数重载了 operator<a href></a>.</p>
<h2><span id="fei-xiang-guan-cheng-yuan">非相关成员</span><a href="#fei-xiang-guan-cheng-yuan" class="header-anchor">#</a></h2><h3><span id="since-6-1-template-qsizetype-erase-qstring-amp-s-const-t-amp-t"><code>[since 6.1]</code>template <typename t> qsizetype erase(<a href="#QString">QString</a> &amp;<em>s</em>, const T &amp;<em>t</em>)</typename></span><a href="#since-6-1-template-qsizetype-erase-qstring-amp-s-const-t-amp-t" class="header-anchor">#</a></h3><p>从字符串 <em>s</em> 中删除所有比较等于 <em>t</em> 的元素。 返回删除的元素数量（如果有）。</p>
<p>该函数在 Qt 6.1 引入。</p>
<p><strong>See also</strong> <a href="#erase_if">erase_if</a>.</p>
<h3><span id="since-6-1-template-qsizetype-erase-if-qstring-amp-s-predicate-pred"><code>[since 6.1]</code>template <typename predicate> qsizetype erase_if(<a href="#QString">QString</a> &amp;<em>s</em>, Predicate <em>pred</em>)</typename></span><a href="#since-6-1-template-qsizetype-erase-if-qstring-amp-s-predicate-pred" class="header-anchor">#</a></h3><p>从字符串 <em>s</em> 中删除谓词 <em>pred</em> 返回 true 的所有元素。 返回删除的元素数量（如果有）。</p>
<p>该函数在 Qt 6.1 引入。</p>
<p><strong>See also</strong> <a href="#erase">erase</a>.</p>
<h3><span id="bool-operator-const-qstring-amp-s1-const-qstring-amp-s2">bool operator!=(const  &amp;<em>s1</em>, const  &amp;<em>s2</em>)</span><a href="#bool-operator-const-qstring-amp-s1-const-qstring-amp-s2" class="header-anchor">#</a></h3><p>如果字符串 <em>s1</em> 不等于字符串 <em>s2</em>，则返回 <code>true</code>； 否则返回<code>false</code>。</p>
<p><strong>See also</strong> <a href="#comparing-strings">Comparing Strings</a>.</p>
<h3><span id="bool-operator-const-qstring-amp-s1-qlatin1string-s2">bool operator!=(const  &amp;<em>s1</em>,  <em>s2</em>)</span><a href="#bool-operator-const-qstring-amp-s1-qlatin1string-s2" class="header-anchor">#</a></h3><p>如果字符串 <em>s1</em> 不等于字符串 <em>s2</em>，则返回 <code>true</code>。 否则返回 <code>false</code>。</p>
<p>这个函数重载了 operator!=().</p>
<h3><span id="bool-operator-const-char-s1-const-qstring-amp-s2">bool operator!=(const char *<em>s1</em>, const  &amp;<em>s2</em>)</span><a href="#bool-operator-const-char-s1-const-qstring-amp-s2" class="header-anchor">#</a></h3><p>如果字符串 <em>s1</em> 不等于字符串 <em>s2</em>，则返回 <code>true</code>。 否则返回 <code>false</code>。</p>
<p>对于 <em>s1</em> != 0，这等价于 <code>compare(</code> <em>s1</em>, <em>s2</em> <code>) != 0</code>。 请注意，没有字符串等于 <em>s1</em> 为 0。</p>
<h3><span id="since-6-2-qstring-operator-qs-const-char16-t-str-size-t-size"><code>[since 6.2]</code> operator””_qs(const char16_t *<em>str</em>, size_t <em>size</em>)</span><a href="#since-6-2-qstring-operator-qs-const-char16-t-str-size-t-size" class="header-anchor">#</a></h3><p>从 char16_t 字符串文字 <em>str</em> 中的前 <em>size</em> 个字符创建 <a href>QString</a> 的文字运算符。</p>
<p><a href>QString</a> 是在编译时创建的，生成的字符串数据存储在编译目标文件的只读段中。 重复的文字可能共享相同的只读内存。 此功能可与 <a href="#QStringLiteral">QStringLiteral</a> 互换，但在代码中存在许多字符串文字时可以节省输入。</p>
<p>以下代码创建一个 <a href>QString</a>：</p>
<div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">auto</span> str = <span class="hljs-string">u"hello"</span>_qs;</code></pre></div>

<p>该函数在 Qt 6.2 引入。</p>
<p><strong>See also</strong> <a href="#QStringLiteral">QStringLiteral</a> and <a href="qbytearray.html#operator-22-22_qba">QtLiterals::operator””_qba</a>(const char *str, size_t size).</p>
<h3><span id="const-qstring-operator-const-qstring-amp-s1-const-qstring-amp-s2">const  operator+(const  &amp;<em>s1</em>, const  &amp;<em>s2</em>)</span><a href="#const-qstring-operator-const-qstring-amp-s1-const-qstring-amp-s2" class="header-anchor">#</a></h3><p>返回一个字符串，它是连接 <em>s1</em> 和 <em>s2</em> 的结果。</p>
<h3><span id="const-qstring-operator-const-qstring-amp-s1-const-char-s2">const  operator+(const  &amp;<em>s1</em>, const char *<em>s2</em>)</span><a href="#const-qstring-operator-const-qstring-amp-s1-const-char-s2" class="header-anchor">#</a></h3><p>返回一个字符串，它是连接 <em>s1</em> 和 <em>s2</em> 的结果（<em>s2</em> 使用 <a href="#fromUtf8">QString::fromUtf8</a>() 函数转换为 Unicode）。</p>
<p><strong>See also</strong> <a href="#fromUtf8">QString::fromUtf8</a>().</p>
<h3><span id="const-qstring-operator-const-char-s1-const-qstring-amp-s2">const  operator+(const char *<em>s1</em>, const  &amp;<em>s2</em>)</span><a href="#const-qstring-operator-const-char-s1-const-qstring-amp-s2" class="header-anchor">#</a></h3><p>返回一个字符串，它是连接 <em>s1</em> 和 <em>s2</em> 的结果（<em>s1</em> 使用 <a href="#fromUtf8">QString::fromUtf8</a>() 函数转换为 Unicode）。</p>
<p><strong>See also</strong> <a href="#fromUtf8">QString::fromUtf8</a>().</p>
<h3><span id="bool-operator-lt-const-qstring-amp-s1-const-qstring-amp-s2">bool operator&lt;(const  &amp;<em>s1</em>, const  &amp;<em>s2</em>)</span><a href="#bool-operator-lt-const-qstring-amp-s1-const-qstring-amp-s2" class="header-anchor">#</a></h3><p>这个函数重载了 operator&lt;().</p>
<p>如果字符串 <em>s1</em> 在词法上小于字符串 <em>s2</em>，则返回 <code>true</code>； 否则返回<code>false</code>。</p>
<p><strong>See also</strong> <a href="#comparing-strings">Comparing Strings</a>.</p>
<h3><span id="bool-operator-lt-const-qstring-amp-s1-qlatin1string-s2">bool operator&lt;(const  &amp;<em>s1</em>,  <em>s2</em>)</span><a href="#bool-operator-lt-const-qstring-amp-s1-qlatin1string-s2" class="header-anchor">#</a></h3><p>这个函数重载了 operator&lt;().</p>
<p>如果 <em>s1</em> 在词法上小于 <em>s2</em>，则返回 <code>true</code>； 否则返回“假”。</p>
<h3><span id="bool-operator-lt-qlatin1string-s1-const-qstring-amp-s2">bool operator&lt;( <em>s1</em>, const  &amp;<em>s2</em>)</span><a href="#bool-operator-lt-qlatin1string-s1-const-qstring-amp-s2" class="header-anchor">#</a></h3><p>这个函数重载了 operator&lt;().</p>
<p>如果 <em>s1</em> 在词法上小于 <em>s2</em>，则返回 <code>true</code>； 否则返回“假”。</p>
<h3><span id="bool-operator-lt-const-char-s1-const-qstring-amp-s2">bool operator&lt;(const char *<em>s1</em>, const  &amp;<em>s2</em>)</span><a href="#bool-operator-lt-const-char-s1-const-qstring-amp-s2" class="header-anchor">#</a></h3><p>如果 <em>s1</em> 在词法上小于 <em>s2</em>，则返回 <code>true</code>； 否则返回“假”。 For <em>s1</em> != 0, this is equivalent to <code>compare(s1, s2) &lt; 0</code>.</p>
<p><strong>See also</strong> <a href="#comparing-strings">Comparing Strings</a>.</p>
<h3><span id="qdatastream-amp-operator-lt-lt-qdatastream-amp-stream-const-qstring-amp-string"> &amp;operator&lt;&lt;( &amp;<em>stream</em>, const  &amp;<em>string</em>)</span><a href="#qdatastream-amp-operator-lt-lt-qdatastream-amp-stream-const-qstring-amp-string" class="header-anchor">#</a></h3><p>将给定的 <em>string</em> 写入指定的 <em>stream</em>。</p>
<p><strong>See also</strong> <a href="datastreamformat.html">Serializing Qt Data Types</a>.</p>
<h3><span id="bool-operator-lt-const-qstring-amp-s1-const-qstring-amp-s2">bool operator&lt;=(const  &amp;<em>s1</em>, const  &amp;<em>s2</em>)</span><a href="#bool-operator-lt-const-qstring-amp-s1-const-qstring-amp-s2" class="header-anchor">#</a></h3><p>如果字符串 <em>s1</em> 在词法上小于或等于字符串 <em>s2</em>，则返回 <code>true</code>； 否则返回<code>false</code>。</p>
<p><strong>See also</strong> <a href="#comparing-strings">Comparing Strings</a>.</p>
<h3><span id="bool-operator-lt-const-qstring-amp-s1-qlatin1string-s2">bool operator&lt;=(const  &amp;<em>s1</em>,  <em>s2</em>)</span><a href="#bool-operator-lt-const-qstring-amp-s1-qlatin1string-s2" class="header-anchor">#</a></h3><p>这个函数重载了 operator&lt;=().</p>
<p>如果 <em>s1</em> 在词法上小于或等于 <em>s2</em>，则返回 <code>true</code>； 否则返回<code>false</code>。</p>
<h3><span id="bool-operator-lt-qlatin1string-s1-const-qstring-amp-s2">bool operator&lt;=( <em>s1</em>, const  &amp;<em>s2</em>)</span><a href="#bool-operator-lt-qlatin1string-s1-const-qstring-amp-s2" class="header-anchor">#</a></h3><p>这个函数重载了 operator&lt;=().</p>
<p>如果 <em>s1</em> 在词法上小于或等于 <em>s2</em>，则返回 <code>true</code>； 否则返回<code>false</code>。</p>
<h3><span id="bool-operator-lt-const-char-s1-const-qstring-amp-s2">bool operator&lt;=(const char *<em>s1</em>, const  &amp;<em>s2</em>)</span><a href="#bool-operator-lt-const-char-s1-const-qstring-amp-s2" class="header-anchor">#</a></h3><p>如果 <em>s1</em> 在词法上小于或等于 <em>s2</em>，则返回 <code>true</code>； 否则返回<code>false</code>。 对于 <em>s1</em> != 0，这相当于 <code>compare(s1, s2) &lt;= 0</code>。</p>
<p><strong>See also</strong> <a href="#comparing-strings">Comparing Strings</a>.</p>
<h3><span id="bool-operator-const-qstring-amp-s1-const-qstring-amp-s2">bool operator==(const  &amp;<em>s1</em>, const  &amp;<em>s2</em>)</span><a href="#bool-operator-const-qstring-amp-s1-const-qstring-amp-s2" class="header-anchor">#</a></h3><p>这个函数重载了 operator==().</p>
<p>如果字符串 <em>s1</em> 等于字符串 <em>s2</em>，则返回 <code>true</code>； 否则返回<code>false</code>。</p>
<p><strong>See also</strong> <a href="#comparing-strings">Comparing Strings</a>.</p>
<h3><span id="bool-operator-const-qstring-amp-s1-qlatin1string-s2">bool operator==(const  &amp;<em>s1</em>,  <em>s2</em>)</span><a href="#bool-operator-const-qstring-amp-s1-qlatin1string-s2" class="header-anchor">#</a></h3><p>这个函数重载了 operator==().</p>
<p>如果字符串 <em>s1</em> 等于字符串 <em>s2</em>，则返回 <code>true</code>； 否则返回<code>false</code>。</p>
<h3><span id="bool-operator-qlatin1string-s1-const-qstring-amp-s2">bool operator==( <em>s1</em>, const  &amp;<em>s2</em>)</span><a href="#bool-operator-qlatin1string-s1-const-qstring-amp-s2" class="header-anchor">#</a></h3><p>这个函数重载了 operator==().</p>
<p>如果字符串 <em>s1</em> 等于字符串 <em>s2</em>，则返回 <code>true</code>； 否则返回<code>false</code>。</p>
<h3><span id="bool-operator-const-char-s1-const-qstring-amp-s2">bool operator==(const char *<em>s1</em>, const  &amp;<em>s2</em>)</span><a href="#bool-operator-const-char-s1-const-qstring-amp-s2" class="header-anchor">#</a></h3><p>这个函数重载了 operator==().</p>
<p>如果字符串 <em>s1</em> 等于字符串 <em>s2</em>，则返回 <code>true</code>； 否则返回<code>false</code>。 Note that no string is equal to <em>s1</em> being 0.</p>
<p>相当于<code>s1 != 0 &amp;&amp; compare(s1, s2) == 0</code>。</p>
<h3><span id="bool-operator-gt-const-qstring-amp-s1-const-qstring-amp-s2">bool operator&gt;(const  &amp;<em>s1</em>, const  &amp;<em>s2</em>)</span><a href="#bool-operator-gt-const-qstring-amp-s1-const-qstring-amp-s2" class="header-anchor">#</a></h3><p>如果字符串 <em>s1</em> 在词法上大于字符串 <em>s2</em>，则返回 <code>true</code>； 否则返回<code>false</code>。</p>
<p><strong>See also</strong> <a href="#comparing-strings">Comparing Strings</a>.</p>
<h3><span id="bool-operator-gt-const-qstring-amp-s1-qlatin1string-s2">bool operator&gt;(const  &amp;<em>s1</em>,  <em>s2</em>)</span><a href="#bool-operator-gt-const-qstring-amp-s1-qlatin1string-s2" class="header-anchor">#</a></h3><p>这个函数重载了 operator&gt;().</p>
<p>如果 <em>s1</em> 在词法上大于 <em>s2</em>，则返回 <code>true</code>； 否则返回<code>false</code>。</p>
<h3><span id="bool-operator-gt-qlatin1string-s1-const-qstring-amp-s2">bool operator&gt;( <em>s1</em>, const  &amp;<em>s2</em>)</span><a href="#bool-operator-gt-qlatin1string-s1-const-qstring-amp-s2" class="header-anchor">#</a></h3><p>这个函数重载了 operator&gt;().</p>
<p>如果 <em>s1</em> 在词法上大于 <em>s2</em>，则返回 <code>true</code>； 否则返回<code>false</code>。</p>
<h3><span id="bool-operator-gt-const-char-s1-const-qstring-amp-s2">bool operator&gt;(const char *<em>s1</em>, const  &amp;<em>s2</em>)</span><a href="#bool-operator-gt-const-char-s1-const-qstring-amp-s2" class="header-anchor">#</a></h3><p>如果 <em>s1</em> 在词法上大于 <em>s2</em>，则返回 <code>true</code>； 否则返回<code>false</code>。 Equivalent to <code>compare(s1, s2) &gt; 0</code>.</p>
<p><strong>See also</strong> <a href="#comparing-strings">Comparing Strings</a>.</p>
<h3><span id="bool-operator-gt-const-qstring-amp-s1-const-qstring-amp-s2">bool operator&gt;=(const  &amp;<em>s1</em>, const  &amp;<em>s2</em>)</span><a href="#bool-operator-gt-const-qstring-amp-s1-const-qstring-amp-s2" class="header-anchor">#</a></h3><p>如果字符串 <em>s1</em> 在词法上大于或等于字符串 <em>s2</em>，则返回 <code>true</code>； 否则返回“假”。</p>
<p><strong>See also</strong> <a href="#comparing-strings">Comparing Strings</a>.</p>
<h3><span id="bool-operator-gt-const-qstring-amp-s1-qlatin1string-s2">bool operator&gt;=(const  &amp;<em>s1</em>,  <em>s2</em>)</span><a href="#bool-operator-gt-const-qstring-amp-s1-qlatin1string-s2" class="header-anchor">#</a></h3><p>这个函数重载了 operator&gt;=().</p>
<p>如果 <em>s1</em> 在词法上大于或等于 <em>s2</em>，则返回 <code>true</code>； 否则返回<code>false</code>。</p>
<h3><span id="bool-operator-gt-qlatin1string-s1-const-qstring-amp-s2">bool operator&gt;=( <em>s1</em>, const  &amp;<em>s2</em>)</span><a href="#bool-operator-gt-qlatin1string-s1-const-qstring-amp-s2" class="header-anchor">#</a></h3><p>这个函数重载了 operator&gt;=().</p>
<p>如果 <em>s1</em> 在词法上大于或等于 <em>s2</em>，则返回 <code>true</code>； 否则返回<code>false</code>。</p>
<h3><span id="bool-operator-gt-const-char-s1-const-qstring-amp-s2">bool operator&gt;=(const char *<em>s1</em>, const  &amp;<em>s2</em>)</span><a href="#bool-operator-gt-const-char-s1-const-qstring-amp-s2" class="header-anchor">#</a></h3><p>如果 <em>s1</em> 在词法上大于或等于 <em>s2</em>，则返回 <code>true</code>； 否则返回<code>false</code>。 For <em>s1</em> != 0, this is equivalent to <code>compare(s1, s2) &gt;= 0</code>.</p>
<p><strong>See also</strong> <a href="#comparing-strings">Comparing Strings</a>.</p>
<h3><span id="qdatastream-amp-operator-gt-gt-qdatastream-amp-stream-qstring-amp-string"> &amp;operator&gt;&gt;( &amp;<em>stream</em>,  &amp;<em>string</em>)</span><a href="#qdatastream-amp-operator-gt-gt-qdatastream-amp-stream-qstring-amp-string" class="header-anchor">#</a></h3><p>从指定的 <em>stream</em> 中读取一个字符串到给定的 <em>string</em> 中。</p>
<p><strong>See also</strong> <a href="datastreamformat.html">Serializing Qt Data Types</a>.</p>
<h2><span id="hong-wen-dang">宏文档</span><a href="#hong-wen-dang" class="header-anchor">#</a></h2><h3><span id="qstringliteral-str">QStringLiteral(<em>str</em>)</span><a href="#qstringliteral-str" class="header-anchor">#</a></h3><p>宏在编译时从字符串文字 <em>str</em> 生成 <a href>QString</a> 的数据。 在这种情况下，从中创建一个 <a href>QString</a> 是免费的，并且生成的字符串数据存储在已编译目标文件的只读段中。</p>
<p>如果您的代码如下所示：</p>
<div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-comment">// hasAttribute takes a QString argument</span>
<span class="hljs-keyword">if</span> (<span class="hljs-built_in">node</span>(node.<span class="hljs-built_in">hasAttribute</span>((<span class="hljs-string">"http-contents-length"</span>))  <span class="hljs-comment">//...</span></code></pre></div>

<p>然后将创建一个临时的 <a href>QString</a> 以作为 <code>hasAttribute</code> 函数参数传递。 这可能非常昂贵，因为它涉及内存分配和将数据复制/转换为 <a href>QString</a> 的内部编码。</p>
<p>这个成本可以通过使用 QStringLiteral 来避免：</p>
<div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">if</span> (<span class="hljs-built_in">node</span>(node.<span class="hljs-built_in">hasAttribute</span>((<span class="hljs-built_in">QStringLiteral</span>(u<span class="hljs-string">u"http-contents-length"</span>)))  <span class="hljs-comment">//...</span></code></pre></div>

<p>在这种情况下，<a href>QString</a> 的内部数据将在编译时生成； 运行时不会发生转换或分配。</p>
<p>使用 QStringLiteral 而不是双引号的纯 C++ 字符串文字可以显着加快从编译时已知的数据创建 <a href>QString</a> 实例的速度。</p>
<p><strong>注意：</strong> <a href="qlatin1string.html">QLatin1String</a> 在将字符串传递给具有采用 <a href="qlatin1string.html">QLatin1String</a> 的重载的函数并且此重载避免转换为 <a href>QString </a>。 例如，QString::operator==() 可以直接与 <a href="qlatin1string.html">QLatin1String</a> 进行比较：</p>
<div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">if</span> (attribute.<span class="hljs-built_in">name</span>() == <span class="hljs-built_in">QLatin1String</span>(<span class="hljs-string">"http-contents-length"</span>)) <span class="hljs-comment">//...</span></code></pre></div>

<p><strong>注意：</strong> 一些编译器在编码包含 US-ASCII 字符集之外的字符的字符串时存在错误。 在这些情况下，请确保在字符串前面加上 <code>u</code>。 否则它是可选的。</p>
<p><strong>See also</strong> <a href="qbytearray.html#QByteArrayLiteral">QByteArrayLiteral</a>.</p>
<h3><span id="qt-no-cast-from-ascii">QT_NO_CAST_FROM_ASCII</span><a href="#qt-no-cast-from-ascii" class="header-anchor">#</a></h3><p>禁用从 8 位字符串 (<code>char *</code>) 到 Unicode QStrings，以及从 8 位 <code>char</code> 类型（<code>char</code> 和 <code>unsigned char</code>）到 <a href="qchar.html">QChar</a> 的自动转换。</p>
<p><strong>See also</strong> <a href="#QT_NO_CAST_TO_ASCII">QT_NO_CAST_TO_ASCII</a>, <a href="#QT_RESTRICTED_CAST_FROM_ASCII">QT_RESTRICTED_CAST_FROM_ASCII</a>, and <a href="qbytearray.html#QT_NO_CAST_FROM_BYTEARRAY">QT_NO_CAST_FROM_BYTEARRAY</a>.</p>
<h3><span id="qt-no-cast-to-ascii">QT_NO_CAST_TO_ASCII</span><a href="#qt-no-cast-to-ascii" class="header-anchor">#</a></h3><p>禁用从 <a href>QString</a> 到 8 位字符串 (<code>char *</code>) 的自动转换。</p>
<p><strong>See also</strong> <a href="#QT_NO_CAST_FROM_ASCII">QT_NO_CAST_FROM_ASCII</a>, <a href="#QT_RESTRICTED_CAST_FROM_ASCII">QT_RESTRICTED_CAST_FROM_ASCII</a>, and <a href="qbytearray.html#QT_NO_CAST_FROM_BYTEARRAY">QT_NO_CAST_FROM_BYTEARRAY</a>.</p>
<h3><span id="qt-restricted-cast-from-ascii">QT_RESTRICTED_CAST_FROM_ASCII</span><a href="#qt-restricted-cast-from-ascii" class="header-anchor">#</a></h3><p>禁用从源文字和 8 位数据到 unicode QStrings 的大多数自动转换，但允许使用 <code>QChar(char)</code> 和 <code>QString(const char (&amp;ch)[N]</code> 构造函数，以及 <code>QString::operator =(const char (&amp;ch)[N])</code> 赋值运算符。这提供了 <a href="#QT_NO_CAST_FROM_ASCII">QT_NO_CAST_FROM_ASCII</a> 的大部分类型安全优势，但不需要用户代码用 [QLatin1Char](qlatin1char 包装字符和字符串文字 .html)、<a href="qlatin1string.html">QLatin1String</a> 或类似名称。</p>
<p>将此宏与 7 位范围之外的源字符串、非文字或嵌入 NUL 字符的文字一起使用是未定义的。</p>
<p><strong>See also</strong> <a href="#QT_NO_CAST_FROM_ASCII">QT_NO_CAST_FROM_ASCII</a> and <a href="#QT_NO_CAST_TO_ASCII">QT_NO_CAST_TO_ASCII</a>.</p>

            </div>
            <hr>
            <div>
              <div class="post-metas mb-3">
                
                
                  <div class="post-meta">
                    <i class="iconfont icon-tags"></i>
                    
                      <a class="hover-with-bg" href="/tags/S/">S</a>
                    
                  </div>
                
              </div>
              
                <p class="note note-warning">
                  
                    本博客所有文章除特别声明外，均采用 <a target="_blank" href="https://creativecommons.org/licenses/by-sa/4.0/deed.zh" rel="nofollow noopener noopener">CC BY-SA 4.0 协议</a> ，转载请注明出处！
                  
                </p>
              
              
                <div class="post-prevnext">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/2022/03/02/QtDocumentCN/Src/V/QVariantPointer/QVariantPointer/">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">QVariantPointer类</span>
                        <span class="visible-mobile">上一篇</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2022/03/02/QtDocumentCN/Src/T/QTcpSocket/QTcpSocket/">
                        <span class="hidden-mobile">QTcpSocket类</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
              <!-- Comments -->
              <article class="comments" id="comments" lazyload>
                
                  
                
                
  <div id="lv-container" data-id="city" data-uid="MTAyMC81NTMzMi8zMTc5OQ==">
    <script type="text/javascript">
      Fluid.utils.loadComments('#lv-container', function() {
        Fluid.utils.createScript('https://cdn-city.livere.com/js/embed.dist.js');
      });
    </script>
    <noscript>Please enable JavaScript to view the comments</noscript>
  </div>


              </article>
            
          </article>
        </div>
      </div>
    </div>
    
      <div class="d-none d-lg-block col-lg-2 toc-container" id="toc-ctn">
        <div id="toc">
  <p class="toc-header"><i class="iconfont icon-list"></i>&nbsp;目录</p>
  <div class="toc-body" id="toc-body"></div>
</div>

      </div>
    
  </div>
</div>

<!-- Custom -->


    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v"
                 for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>
    

    
  </main>

  <footer class="text-center mt-5 py-3">
  <div class="footer-content">
     <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> 
  </div>
  

  

  
</footer>


  <!-- SCRIPTS -->
  
  <script  src="https://cdn.jsdelivr.net/npm/nprogress@0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/nprogress@0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js" ></script>
<script  src="https://cdn.jsdelivr.net/npm/bootstrap@4/dist/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>

<!-- Plugins -->


  <script  src="/js/local-search.js" ></script>



  
    <script  src="/js/img-lazyload.js" ></script>
  



  



  
    <script  src="https://cdn.jsdelivr.net/npm/tocbot@4/dist/tocbot.min.js" ></script>
  
  
    <script  src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3/dist/jquery.fancybox.min.js" ></script>
  
  
    <script  src="https://cdn.jsdelivr.net/npm/anchor-js@4/anchor.min.js" ></script>
  
  
    <script defer src="https://cdn.jsdelivr.net/npm/clipboard@2/dist/clipboard.min.js" ></script>
  






  <script  src="https://cdn.jsdelivr.net/npm/typed.js@2/lib/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var title = document.getElementById('subtitle').title;
      
        typing(title);
      
    })(window, document);
  </script>















<!-- 主题的启动项 保持在最底部 -->
<script  src="/js/boot.js" ></script>


</body>
</html>
