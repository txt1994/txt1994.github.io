

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=auto>



<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/logo.jpg">
  <link rel="icon" href="/img/logo.jpg">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
    <meta http-equiv="Content-Security-Policy" content="upgrade-insecure-requests">
  
  <meta name="theme-color" content="#6aa84f">
  <meta name="author" content="John Doe">
  <meta name="keywords" content="">
  
    <meta name="description" content="QByteArray Class 公共类型 公共函数 静态公共成员 相关非会员 宏 详细说明 最大大小和内存不足情况 C 语言环境和 ASCII 函数   会员类型文档 [since 5.2]enum QByteArray::Base64Option flags QByteArray::Base64Options QByteArray::const_iterator [since 5.6">
<meta property="og:type" content="article">
<meta property="og:title" content="QByteArray类">
<meta property="og:url" content="https://txt1994.github.io/2022/03/02/QtDocumentCN/Src/B/QByteArray/QByteArray/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:description" content="QByteArray Class 公共类型 公共函数 静态公共成员 相关非会员 宏 详细说明 最大大小和内存不足情况 C 语言环境和 ASCII 函数   会员类型文档 [since 5.2]enum QByteArray::Base64Option flags QByteArray::Base64Options QByteArray::const_iterator [since 5.6">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2022-03-02T04:52:47.000Z">
<meta property="article:modified_time" content="2022-03-18T16:35:33.567Z">
<meta property="article:author" content="John Doe">
<meta property="article:tag" content="B">
<meta name="twitter:card" content="summary_large_image">
  
  
  <title>QByteArray类 - Hexo</title>

  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4/dist/css/bootstrap.min.css" />


  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/github-markdown-css@4/github-markdown.min.css" />
  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/hint.css@2/hint.min.css" />

  
    
    
      
      <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@10/styles/github-gist.min.css" />
    
  

  
    <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3/dist/jquery.fancybox.min.css" />
  


<!-- 主题依赖的图标库，不要自行修改 -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_ba1fz6golrf.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_lbnruvf0jn.css">


<link  rel="stylesheet" href="/css/main.css" />

<!-- 自定义样式保持在最底部 -->

  
<link rel="stylesheet" href="/css/style.css">



  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    var CONFIG = {"hostname":"txt1994.github.io","root":"/","version":"1.8.14","typing":{"enable":true,"typeSpeed":70,"cursorChar":"_","loop":false},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"right","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"copy_btn":true,"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":false,"baidu":null,"google":null,"gtag":null,"tencent":{"sid":null,"cid":null},"woyaola":null,"cnzz":null,"leancloud":{"app_id":null,"app_key":null,"server_url":null,"path":"window.location.pathname","ignore_local":false}},"search_path":"/local-search.xml"};
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
<meta name="generator" content="Hexo 6.1.0">
<style>.github-emoji { position: relative; display: inline-block; width: 1.2em; min-height: 1.2em; overflow: hidden; vertical-align: top; color: transparent; }  .github-emoji > span { position: relative; z-index: 10; }  .github-emoji img, .github-emoji .fancybox { margin: 0 !important; padding: 0 !important; border: none !important; outline: none !important; text-decoration: none !important; user-select: none !important; cursor: auto !important; }  .github-emoji img { height: 1.2em !important; width: 1.2em !important; position: absolute !important; left: 50% !important; top: 50% !important; transform: translate(-50%, -50%) !important; user-select: none !important; cursor: auto !important; } .github-emoji-fallback { color: inherit; } .github-emoji-fallback img { opacity: 0 !important; }</style>
</head>


<body>
  <header style="height: 70vh;">
    <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/">
      <strong>txt1994s</strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/">
                <i class="iconfont icon-home-fill"></i>
                首页
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/">
                <i class="iconfont icon-archive-fill"></i>
                归档
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/">
                <i class="iconfont icon-tags-fill"></i>
                标签
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/">
                <i class="iconfont icon-user-fill"></i>
                关于
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/links/">
                <i class="iconfont icon-link-fill"></i>
                友联
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              &nbsp;<i class="iconfont icon-search"></i>&nbsp;
            </a>
          </li>
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">&nbsp;<i
                class="iconfont icon-dark" id="color-toggle-icon"></i>&nbsp;</a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

    <div class="banner" id="banner" parallax=true
         style="background: url('/img/default.png') no-repeat center center;
           background-size: cover;">
      <div class="full-bg-img">
        <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
          <div class="page-header text-center fade-in-up">
            <span class="h2" id="subtitle" title="QByteArray类">
              
            </span>

            
              <div class="mt-3">
  
  
    <span class="post-meta">
      <i class="iconfont icon-date-fill" aria-hidden="true"></i>
      <time datetime="2022-03-02 12:52" pubdate>
        2022年3月2日 下午
      </time>
    </span>
  
</div>

<div class="mt-1">
  
    <span class="post-meta mr-2">
      <i class="iconfont icon-chart"></i>
      75k 字
    </span>
  

  
    <span class="post-meta mr-2">
      <i class="iconfont icon-clock-fill"></i>
      
      
      623 分钟
    </span>
  

  
  
</div>

            
          </div>

          
        </div>
      </div>
    </div>
  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="d-none d-lg-block col-lg-2"></div>
    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div class="py-5" id="board">
          <article class="post-content mx-auto">
            <!-- SEO header -->
            <h1 style="display: none">QByteArray类</h1>
            
              <p class="note note-info">
                
                  本文最后更新于：2022年3月19日 凌晨
                
              </p>
            
            <div class="markdown-body">
              <div class="toc">

<!-- toc -->

<ul>
<li><a href="#qbytearray-class">QByteArray Class</a><ul>
<li><a href="#gong-gong-lei-xing">公共类型</a></li>
<li><a href="#gong-gong-han-shu">公共函数</a></li>
<li><a href="#jing-tai-gong-gong-cheng-yuan">静态公共成员</a></li>
<li><a href="#xiang-guan-fei-hui-yuan">相关非会员</a></li>
<li><a href="#hong">宏</a></li>
<li><a href="#xiang-xi-shuo-ming">详细说明</a><ul>
<li><a href="#zui-da-da-xiao-he-nei-cun-bu-zu-qing-kuang">最大大小和内存不足情况</a></li>
<li><a href="#c-yu-yan-huan-jing-he-ascii-han-shu">C 语言环境和 ASCII 函数</a></li>
</ul>
</li>
<li><a href="#hui-yuan-lei-xing-wen-dang">会员类型文档</a><ul>
<li><a href="#since-5-2-enum-qbytearray-base64option-flags-qbytearray-base64options"><code>[since 5.2]</code>enum QByteArray::Base64Option flags QByteArray::Base64Options</a></li>
<li><a href="#qbytearray-const-iterator">QByteArray::const_iterator</a></li>
<li><a href="#since-5-6-qbytearray-const-reverse-iterator"><code>[since 5.6]</code>QByteArray::const_reverse_iterator</a></li>
<li><a href="#qbytearray-iterator">QByteArray::iterator</a></li>
<li><a href="#since-5-6-qbytearray-reverse-iterator"><code>[since 5.6]</code>QByteArray::reverse_iterator</a></li>
</ul>
</li>
<li><a href="#cheng-yuan-han-shu-wen-dang">成员函数文档</a><ul>
<li><a href="#static-since-5-15-qbytearray-frombase64result-https-doc-qt-io-qt-6-qbytearray-frombase64result-html-qbytearray-frombase64encoding-qbytearray-qbytearray-md-qbytearray-base64-qbytearray-base64options-qbytearray-md-base64option-enum-options-base64encoding"><code>[static, since 5.15]</code></a><a target="_blank" rel="noopener" href="https://doc.qt.io/qt-6/qbytearray-frombase64result.html">QByteArray::FromBase64Result</a> QByteArray::fromBase64Encoding(<a href="QByteArray.md#QByteArray">QByteArray</a> &amp;&amp;<em>base64</em>, <a href="QByteArray.md#Base64Option-enum">QByteArray::Base64Options</a> <em>options</em> = Base64Encoding)</li>
<li><a href="#static-since-5-15-qbytearray-frombase64result-https-doc-qt-io-qt-6-qbytearray-frombase64result-html-qbytearray-frombase64encoding-const-qbytearray-qbytearray-md-qbytearray-base64-qbytearray-base64options-qbytearray-md-base64option-enum-options-base64encoding"><code>[static, since 5.15]</code></a><a target="_blank" rel="noopener" href="https://doc.qt.io/qt-6/qbytearray-frombase64result.html">QByteArray::FromBase64Result</a> QByteArray::fromBase64Encoding(const <a href="QByteArray.md#QByteArray">QByteArray</a> &amp;<em>base64</em>, <a href="QByteArray.md#Base64Option-enum">QByteArray::Base64Options</a> <em>options</em> = Base64Encoding)</li>
<li><a href="#const-char-qbytearray-operator-const-char-const">const char *QByteArray::operator const char *() const</a></li>
<li><a href="#const-void-qbytearray-operator-const-void-const">const void *QByteArray::operator const void *() const</a></li>
<li><a href="#since-5-2-qbytearray-qbytearray-qbytearray-qbytearray-md-qbytearray-other"><code>[since 5.2]</code>QByteArray::QByteArray(</a><a href="QByteArray.md#QByteArray">QByteArray</a> &amp;&amp;<em>other</em>)</li>
<li><a href="#qbytearray-qbytearray-const-qbytearray-qbytearray-md-qbytearray-other">QByteArray::QByteArray(const </a><a href="QByteArray.md#QByteArray">QByteArray</a> &amp;<em>other</em>)</li>
<li><a href="#qbytearray-qbytearray-qsizetype-size-char-ch">QByteArray::QByteArray(qsizetype <em>size</em>, char <em>ch</em>)</a></li>
<li><a href="#qbytearray-qbytearray-const-char-data-qsizetype-size-1">QByteArray::QByteArray(const char *<em>data</em>, qsizetype <em>size</em> = -1)</a></li>
<li><a href="#qbytearray-qbytearray">QByteArray::QByteArray()</a></li>
<li><a href="#since-5-2-qbytearray-qbytearray-md-qbytearray-qbytearray-operator-qbytearray-qbytearray-md-qbytearray-other"><code>[since 5.2]</code></a><a href="QByteArray.md#QByteArray">QByteArray</a> &amp;QByteArray::operator=(<a href="QByteArray.md#QByteArray">QByteArray</a> &amp;&amp;<em>other</em>)</li>
<li><a href="#qbytearray-qbytearray-md-qbytearray-qbytearray-operator-const-qbytearray-qbytearray-md-qbytearray-other">QByteArray</a></li>
<li><a href="#qbytearray-qbytearray">QByteArray::~QByteArray()</a></li>
<li><a href="#qbytearray-qbytearray-md-qbytearray-qbytearray-append-const-qbytearray-qbytearray-md-qbytearray-ba-1">QByteArray</a></li>
<li><a href="#qbytearray-qbytearray-md-qbytearray-qbytearray-append-char-ch-2">QByteArray</a></li>
<li><a href="#since-5-7-qbytearray-qbytearray-md-qbytearray-qbytearray-append-qsizetype-count-char-ch"><code>[since 5.7]</code></a><a href="QByteArray.md#QByteArray">QByteArray</a> &amp;QByteArray::append(qsizetype <em>count</em>, char <em>ch</em>)</li>
<li><a href="#qbytearray-qbytearray-md-qbytearray-qbytearray-append-const-char-str-3">QByteArray</a></li>
<li><a href="#qbytearray-qbytearray-md-qbytearray-qbytearray-append-const-char-str-qsizetype-len-4">QByteArray</a></li>
<li><a href="#qbytearray-qbytearray-md-qbytearray-qbytearray-append-qbytearrayview-https-doc-qt-io-qt-6-qbytearrayview-html-data-5">QByteArray</a></li>
<li><a href="#char-qbytearray-at-qsizetype-i-const">char QByteArray::at(qsizetype <em>i</em>) const</a></li>
<li><a href="#since-5-10-char-qbytearray-back-const"><code>[since 5.10]</code>char QByteArray::back() const</a></li>
<li><a href="#since-5-10-char-qbytearray-back"><code>[since 5.10]</code>char &amp;QByteArray::back()</a></li>
<li><a href="#qbytearray-iterator-qbytearray-md-iterator-typedef-qbytearray-begin-1">QByteArray::iterator</a></li>
<li><a href="#qbytearray-const-iterator-qbytearray-md-const-iterator-typedef-qbytearray-begin-const-1">QByteArray::const_iterator</a></li>
<li><a href="#qsizetype-qbytearray-capacity-const">qsizetype QByteArray::capacity() const</a></li>
<li><a href="#since-5-0-qbytearray-const-iterator-qbytearray-md-const-iterator-typedef-qbytearray-cbegin-const"><code>[since 5.0]</code></a><a href="QByteArray.md#const_iterator-typedef">QByteArray::const_iterator</a> QByteArray::cbegin() const</li>
<li><a href="#since-5-0-qbytearray-const-iterator-qbytearray-md-const-iterator-typedef-qbytearray-cend-const"><code>[since 5.0]</code></a><a href="QByteArray.md#const_iterator-typedef">QByteArray::const_iterator</a> QByteArray::cend() const</li>
<li><a href="#void-qbytearray-chop-qsizetype-n">void QByteArray::chop(qsizetype <em>n</em>)</a></li>
<li><a href="#since-5-10-qbytearray-qbytearray-md-qbytearray-qbytearray-chopped-qsizetype-len-const"><code>[since 5.10]</code></a><a href="QByteArray.md#QByteArray">QByteArray</a> QByteArray::chopped(qsizetype <em>len</em>) const</li>
<li><a href="#void-qbytearray-clear">void QByteArray::clear()</a></li>
<li><a href="#since-6-0-int-qbytearray-compare-qbytearrayview-https-doc-qt-io-qt-6-qbytearrayview-html-bv-qt-casesensitivity-https-doc-qt-io-qt-6-qt-html-casesensitivity-enum-cs-qt-casesensitive-const"><code>[since 6.0]</code>int QByteArray::compare(</a><a target="_blank" rel="noopener" href="https://doc.qt.io/qt-6/qbytearrayview.html">QByteArrayView</a> <em>bv</em>, <a target="_blank" rel="noopener" href="https://doc.qt.io/qt-6/qt.html#CaseSensitivity-enum">Qt::CaseSensitivity</a> <em>cs</em> = Qt::CaseSensitive) const</li>
<li><a href="#qbytearray-const-iterator-qbytearray-md-const-iterator-typedef-qbytearray-constbegin-const-2">QByteArray::const_iterator</a></li>
<li><a href="#const-char-qbytearray-constdata-const">const char *QByteArray::constData() const</a></li>
<li><a href="#qbytearray-const-iterator-qbytearray-md-const-iterator-typedef-qbytearray-constend-const-3">QByteArray::const_iterator</a></li>
<li><a href="#since-6-0-bool-qbytearray-contains-qbytearrayview-https-doc-qt-io-qt-6-qbytearrayview-html-bv-const"><code>[since 6.0]</code>bool QByteArray::contains(</a><a target="_blank" rel="noopener" href="https://doc.qt.io/qt-6/qbytearrayview.html">QByteArrayView</a> <em>bv</em>) const</li>
<li><a href="#bool-qbytearray-contains-char-ch-const">bool QByteArray::contains(char <em>ch</em>) const</a></li>
<li><a href="#since-6-0-qsizetype-qbytearray-count-qbytearrayview-https-doc-qt-io-qt-6-qbytearrayview-html-bv-const"><code>[since 6.0]</code>qsizetype QByteArray::count(</a><a target="_blank" rel="noopener" href="https://doc.qt.io/qt-6/qbytearrayview.html">QByteArrayView</a> <em>bv</em>) const</li>
<li><a href="#qsizetype-qbytearray-count-char-ch-const">qsizetype QByteArray::count(char <em>ch</em>) const</a></li>
<li><a href="#qsizetype-qbytearray-count-const">qsizetype QByteArray::count() const</a></li>
<li><a href="#since-5-6-qbytearray-const-reverse-iterator-qbytearray-md-const-reverse-iterator-typedef-qbytearray-crbegin-const"><code>[since 5.6]</code></a><a href="QByteArray.md#const_reverse_iterator-typedef">QByteArray::const_reverse_iterator</a> QByteArray::crbegin() const</li>
<li><a href="#since-5-6-qbytearray-const-reverse-iterator-qbytearray-md-const-reverse-iterator-typedef-qbytearray-crend-const"><code>[since 5.6]</code></a><a href="QByteArray.md#const_reverse_iterator-typedef">QByteArray::const_reverse_iterator</a> QByteArray::crend() const</li>
<li><a href="#char-qbytearray-data">char *QByteArray::data()</a></li>
<li><a href="#const-char-qbytearray-data-const">const char *QByteArray::data() const</a></li>
<li><a href="#qbytearray-iterator-qbytearray-md-iterator-typedef-qbytearray-end-2">QByteArray::iterator</a></li>
<li><a href="#qbytearray-const-iterator-qbytearray-md-const-iterator-typedef-qbytearray-end-const-4">QByteArray::const_iterator</a></li>
<li><a href="#since-6-0-bool-qbytearray-endswith-qbytearrayview-https-doc-qt-io-qt-6-qbytearrayview-html-bv-const"><code>[since 6.0]</code>bool QByteArray::endsWith(</a><a target="_blank" rel="noopener" href="https://doc.qt.io/qt-6/qbytearrayview.html">QByteArrayView</a> <em>bv</em>) const</li>
<li><a href="#bool-qbytearray-endswith-char-ch-const">bool QByteArray::endsWith(char <em>ch</em>) const</a></li>
<li><a href="#since-6-1-qbytearray-iterator-qbytearray-md-iterator-typedef-qbytearray-erase-qbytearray-const-iterator-qbytearray-md-const-iterator-typedef-first-qbytearray-const-iterator-qbytearray-md-const-iterator-typedef-last"><code>[since 6.1]</code></a><a href="QByteArray.md#iterator-typedef">QByteArray::iterator</a> QByteArray::erase(<a href="QByteArray.md#const_iterator-typedef">QByteArray::const_iterator</a> <em>first</em>, <a href="QByteArray.md#const_iterator-typedef">QByteArray::const_iterator</a> <em>last</em>)</li>
<li><a href="#qbytearray-qbytearray-md-qbytearray-qbytearray-fill-char-ch-qsizetype-size-1-6">QByteArray</a></li>
<li><a href="#since-6-0-qbytearray-qbytearray-md-qbytearray-qbytearray-first-qsizetype-n-const"><code>[since 6.0]</code></a><a href="QByteArray.md#QByteArray">QByteArray</a> QByteArray::first(qsizetype <em>n</em>) const</li>
<li><a href="#static-since-5-2-qbytearray-qbytearray-md-qbytearray-qbytearray-frombase64-const-qbytearray-qbytearray-md-qbytearray-base64-qbytearray-base64options-qbytearray-md-base64option-enum-options-base64encoding"><code>[static, since 5.2]</code></a><a href="QByteArray.md#QByteArray">QByteArray</a> QByteArray::fromBase64(const <a href="QByteArray.md#QByteArray">QByteArray</a> &amp;<em>base64</em>, <a href="QByteArray.md#Base64Option-enum">QByteArray::Base64Options</a> <em>options</em> = Base64Encoding)</li>
<li><a href="#static-since-5-3-qbytearray-qbytearray-md-qbytearray-qbytearray-fromcfdata-cfdataref-data"><code>[static, since 5.3]</code></a><a href="QByteArray.md#QByteArray">QByteArray</a> QByteArray::fromCFData(CFDataRef <em>data</em>)</li>
<li><a href="#static-qbytearray-qbytearray-md-qbytearray-qbytearray-fromhex-const-qbytearray-qbytearray-md-qbytearray-hexencoded"><code>[static]</code></a><a href="QByteArray.md#QByteArray">QByteArray</a> QByteArray::fromHex(const <a href="QByteArray.md#QByteArray">QByteArray</a> &amp;<em>hexEncoded</em>)</li>
<li><a href="#static-since-5-3-qbytearray-qbytearray-md-qbytearray-qbytearray-fromnsdata-const-nsdata-data"><code>[static, since 5.3]</code></a><a href="QByteArray.md#QByteArray">QByteArray</a> QByteArray::fromNSData(const NSData *<em>data</em>)</li>
<li><a href="#static-qbytearray-qbytearray-md-qbytearray-qbytearray-frompercentencoding-const-qbytearray-qbytearray-md-qbytearray-input-char-percent"><code>[static]</code></a><a href="QByteArray.md#QByteArray">QByteArray</a> QByteArray::fromPercentEncoding(const <a href="QByteArray.md#QByteArray">QByteArray</a> &amp;<em>input</em>, char <em>percent</em> = ‘%’)</li>
<li><a href="#static-since-5-3-qbytearray-qbytearray-md-qbytearray-qbytearray-fromrawcfdata-cfdataref-data"><code>[static, since 5.3]</code></a><a href="QByteArray.md#QByteArray">QByteArray</a> QByteArray::fromRawCFData(CFDataRef <em>data</em>)</li>
<li><a href="#static-qbytearray-qbytearray-md-qbytearray-qbytearray-fromrawdata-const-char-data-qsizetype-size"><code>[static]</code></a><a href="QByteArray.md#QByteArray">QByteArray</a> QByteArray::fromRawData(const char *<em>data</em>, qsizetype <em>size</em>)</li>
<li><a href="#static-since-5-3-qbytearray-qbytearray-md-qbytearray-qbytearray-fromrawnsdata-const-nsdata-data"><code>[static, since 5.3]</code></a><a href="QByteArray.md#QByteArray">QByteArray</a> QByteArray::fromRawNSData(const NSData *<em>data</em>)</li>
<li><a href="#static-since-5-4-qbytearray-qbytearray-md-qbytearray-qbytearray-fromstdstring-const-std-string-str"><code>[static, since 5.4]</code></a><a href="QByteArray.md#QByteArray">QByteArray</a> QByteArray::fromStdString(const std::string &amp;<em>str</em>)</li>
<li><a href="#since-5-10-char-qbytearray-front-const"><code>[since 5.10]</code>char QByteArray::front() const</a></li>
<li><a href="#since-5-10-char-qbytearray-front"><code>[since 5.10]</code>char &amp;QByteArray::front()</a></li>
<li><a href="#since-6-0-qsizetype-qbytearray-indexof-qbytearrayview-https-doc-qt-io-qt-6-qbytearrayview-html-bv-qsizetype-from-0-const"><code>[since 6.0]</code>qsizetype QByteArray::indexOf(</a><a target="_blank" rel="noopener" href="https://doc.qt.io/qt-6/qbytearrayview.html">QByteArrayView</a> <em>bv</em>, qsizetype <em>from</em> = 0) const</li>
<li><a href="#qsizetype-qbytearray-indexof-char-ch-qsizetype-from-0-const">qsizetype QByteArray::indexOf(char <em>ch</em>, qsizetype <em>from</em> = 0) const</a></li>
<li><a href="#since-6-0-qbytearray-qbytearray-md-qbytearray-qbytearray-insert-qsizetype-i-qbytearrayview-https-doc-qt-io-qt-6-qbytearrayview-html-data"><code>[since 6.0]</code></a><a href="QByteArray.md#QByteArray">QByteArray</a> &amp;QByteArray::insert(qsizetype <em>i</em>, <a target="_blank" rel="noopener" href="https://doc.qt.io/qt-6/qbytearrayview.html">QByteArrayView</a> <em>data</em>)</li>
<li><a href="#qbytearray-qbytearray-md-qbytearray-qbytearray-insert-qsizetype-i-const-char-s-7">QByteArray</a></li>
<li><a href="#qbytearray-qbytearray-md-qbytearray-qbytearray-insert-qsizetype-i-const-qbytearray-qbytearray-md-qbytearray-data-8">QByteArray</a></li>
<li><a href="#since-5-7-qbytearray-qbytearray-md-qbytearray-qbytearray-insert-qsizetype-i-qsizetype-count-char-ch"><code>[since 5.7]</code></a><a href="QByteArray.md#QByteArray">QByteArray</a> &amp;QByteArray::insert(qsizetype <em>i</em>, qsizetype <em>count</em>, char <em>ch</em>)</li>
<li><a href="#qbytearray-qbytearray-md-qbytearray-qbytearray-insert-qsizetype-i-char-ch-9">QByteArray</a></li>
<li><a href="#qbytearray-qbytearray-md-qbytearray-qbytearray-insert-qsizetype-i-const-char-data-qsizetype-len-10">QByteArray</a></li>
<li><a href="#bool-qbytearray-isempty-const">bool QByteArray::isEmpty() const</a></li>
<li><a href="#since-5-12-bool-qbytearray-islower-const"><code>[since 5.12]</code>bool QByteArray::isLower() const</a></li>
<li><a href="#bool-qbytearray-isnull-const">bool QByteArray::isNull() const</a></li>
<li><a href="#since-5-12-bool-qbytearray-isupper-const"><code>[since 5.12]</code>bool QByteArray::isUpper() const</a></li>
<li><a href="#since-6-0-qbytearray-qbytearray-md-qbytearray-qbytearray-last-qsizetype-n-const"><code>[since 6.0]</code></a><a href="QByteArray.md#QByteArray">QByteArray</a> QByteArray::last(qsizetype <em>n</em>) const</li>
<li><a href="#since-6-0-qsizetype-qbytearray-lastindexof-qbytearrayview-https-doc-qt-io-qt-6-qbytearrayview-html-bv-qsizetype-from-const"><code>[since 6.0]</code>qsizetype QByteArray::lastIndexOf(</a><a target="_blank" rel="noopener" href="https://doc.qt.io/qt-6/qbytearrayview.html">QByteArrayView</a> <em>bv</em>, qsizetype <em>from</em>) const</li>
<li><a href="#qsizetype-qbytearray-lastindexof-char-ch-qsizetype-from-1-const">qsizetype QByteArray::lastIndexOf(char <em>ch</em>, qsizetype <em>from</em> = -1) const</a></li>
<li><a href="#since-6-2-qsizetype-qbytearray-lastindexof-qbytearrayview-https-doc-qt-io-qt-6-qbytearrayview-html-bv-const"><code>[since 6.2]</code>qsizetype QByteArray::lastIndexOf(</a><a target="_blank" rel="noopener" href="https://doc.qt.io/qt-6/qbytearrayview.html">QByteArrayView</a> <em>bv</em>) const</li>
<li><a href="#qbytearray-qbytearray-md-qbytearray-qbytearray-left-qsizetype-len-const-11">QByteArray</a></li>
<li><a href="#qbytearray-qbytearray-md-qbytearray-qbytearray-leftjustified-qsizetype-width-char-fill-bool-truncate-false-const-12">QByteArray</a></li>
<li><a href="#qsizetype-qbytearray-length-const">qsizetype QByteArray::length() const</a></li>
<li><a href="#qbytearray-qbytearray-md-qbytearray-qbytearray-mid-qsizetype-pos-qsizetype-len-1-const-13">QByteArray</a></li>
<li><a href="#static-qbytearray-qbytearray-md-qbytearray-qbytearray-number-int-n-int-base-10"><code>[static]</code></a><a href="QByteArray.md#QByteArray">QByteArray</a> QByteArray::number(int <em>n</em>, int <em>base</em> = 10)</li>
<li><a href="#static-qbytearray-qbytearray-md-qbytearray-qbytearray-number-uint-https-doc-qt-io-qt-6-qtglobal-html-uint-typedef-n-int-base-10"><code>[static]</code></a><a href="QByteArray.md#QByteArray">QByteArray</a> QByteArray::number(<a target="_blank" rel="noopener" href="https://doc.qt.io/qt-6/qtglobal.html#uint-typedef">uint</a> <em>n</em>, int <em>base</em> = 10)</li>
<li><a href="#static-qbytearray-qbytearray-md-qbytearray-qbytearray-number-long-n-int-base-10"><code>[static]</code></a><a href="QByteArray.md#QByteArray">QByteArray</a> QByteArray::number(long <em>n</em>, int <em>base</em> = 10)</li>
<li><a href="#static-qbytearray-qbytearray-md-qbytearray-qbytearray-number-ulong-https-doc-qt-io-qt-6-qtglobal-html-ulong-typedef-n-int-base-10"><code>[static]</code></a><a href="QByteArray.md#QByteArray">QByteArray</a> QByteArray::number(<a target="_blank" rel="noopener" href="https://doc.qt.io/qt-6/qtglobal.html#ulong-typedef">ulong</a> <em>n</em>, int <em>base</em> = 10)</li>
<li><a href="#static-qbytearray-qbytearray-md-qbytearray-qbytearray-number-qlonglong-https-doc-qt-io-qt-6-qtglobal-html-qlonglong-typedef-n-int-base-10"><code>[static]</code></a><a href="QByteArray.md#QByteArray">QByteArray</a> QByteArray::number(<a target="_blank" rel="noopener" href="https://doc.qt.io/qt-6/qtglobal.html#qlonglong-typedef">qlonglong</a> <em>n</em>, int <em>base</em> = 10)</li>
<li><a href="#static-qbytearray-qbytearray-md-qbytearray-qbytearray-number-qulonglong-https-doc-qt-io-qt-6-qtglobal-html-qulonglong-typedef-n-int-base-10"><code>[static]</code></a><a href="QByteArray.md#QByteArray">QByteArray</a> QByteArray::number(<a target="_blank" rel="noopener" href="https://doc.qt.io/qt-6/qtglobal.html#qulonglong-typedef">qulonglong</a> <em>n</em>, int <em>base</em> = 10)</li>
<li><a href="#static-qbytearray-qbytearray-md-qbytearray-qbytearray-number-double-n-char-format-g-int-precision-6"><code>[static]</code></a><a href="QByteArray.md#QByteArray">QByteArray</a> QByteArray::number(double <em>n</em>, char <em>format</em> = ‘g’, int <em>precision</em> = 6)</li>
<li><a href="#qbytearray-qbytearray-md-qbytearray-qbytearray-prepend-qbytearrayview-https-doc-qt-io-qt-6-qbytearrayview-html-ba-14">QByteArray</a></li>
<li><a href="#qbytearray-qbytearray-md-qbytearray-qbytearray-prepend-char-ch-15">QByteArray</a></li>
<li><a href="#since-5-7-qbytearray-qbytearray-md-qbytearray-qbytearray-prepend-qsizetype-count-char-ch"><code>[since 5.7]</code></a><a href="QByteArray.md#QByteArray">QByteArray</a> &amp;QByteArray::prepend(qsizetype <em>count</em>, char <em>ch</em>)</li>
<li><a href="#qbytearray-qbytearray-md-qbytearray-qbytearray-prepend-const-char-str-16">QByteArray</a></li>
<li><a href="#qbytearray-qbytearray-md-qbytearray-qbytearray-prepend-const-char-str-qsizetype-len-17">QByteArray</a></li>
<li><a href="#qbytearray-qbytearray-md-qbytearray-qbytearray-prepend-const-qbytearray-qbytearray-md-qbytearray-ba-18">QByteArray</a></li>
<li><a href="#void-qbytearray-push-back-const-qbytearray-qbytearray-md-qbytearray-other">void QByteArray::push_back(const </a><a href="QByteArray.md#QByteArray">QByteArray</a> &amp;<em>other</em>)</li>
<li><a href="#void-qbytearray-push-back-char-ch">void QByteArray::push_back(char <em>ch</em>)</a></li>
<li><a href="#void-qbytearray-push-back-const-char-str">void QByteArray::push_back(const char *<em>str</em>)</a></li>
<li><a href="#since-6-0-void-qbytearray-push-back-qbytearrayview-https-doc-qt-io-qt-6-qbytearrayview-html-str"><code>[since 6.0]</code>void QByteArray::push_back(</a><a target="_blank" rel="noopener" href="https://doc.qt.io/qt-6/qbytearrayview.html">QByteArrayView</a> <em>str</em>)</li>
<li><a href="#void-qbytearray-push-front-const-qbytearray-qbytearray-md-qbytearray-other">void QByteArray::push_front(const </a><a href="QByteArray.md#QByteArray">QByteArray</a> &amp;<em>other</em>)</li>
<li><a href="#void-qbytearray-push-front-char-ch">void QByteArray::push_front(char <em>ch</em>)</a></li>
<li><a href="#void-qbytearray-push-front-const-char-str">void QByteArray::push_front(const char *<em>str</em>)</a></li>
<li><a href="#since-6-0-void-qbytearray-push-front-qbytearrayview-https-doc-qt-io-qt-6-qbytearrayview-html-str"><code>[since 6.0]</code>void QByteArray::push_front(</a><a target="_blank" rel="noopener" href="https://doc.qt.io/qt-6/qbytearrayview.html">QByteArrayView</a> <em>str</em>)</li>
<li><a href="#since-5-6-qbytearray-reverse-iterator-qbytearray-md-reverse-iterator-typedef-qbytearray-rbegin"><code>[since 5.6]</code></a><a href="QByteArray.md#reverse_iterator-typedef">QByteArray::reverse_iterator</a> QByteArray::rbegin()</li>
<li><a href="#since-5-6-qbytearray-const-reverse-iterator-qbytearray-md-const-reverse-iterator-typedef-qbytearray-rbegin-const"><code>[since 5.6]</code></a><a href="QByteArray.md#const_reverse_iterator-typedef">QByteArray::const_reverse_iterator</a> QByteArray::rbegin() const</li>
<li><a href="#qbytearray-qbytearray-md-qbytearray-qbytearray-remove-qsizetype-pos-qsizetype-len-19">QByteArray</a></li>
<li><a href="#since-6-1-template-typename-predicate-qbytearray-qbytearray-md-qbytearray-qbytearray-removeif-predicate-pred"><code>[since 6.1]</code>template <typename predicate> </typename></a><a href="QByteArray.md#QByteArray">QByteArray</a> &amp;QByteArray::removeIf(Predicate <em>pred</em>)</li>
<li><a href="#since-5-6-qbytearray-reverse-iterator-qbytearray-md-reverse-iterator-typedef-qbytearray-rend"><code>[since 5.6]</code></a><a href="QByteArray.md#reverse_iterator-typedef">QByteArray::reverse_iterator</a> QByteArray::rend()</li>
<li><a href="#since-5-6-qbytearray-const-reverse-iterator-qbytearray-md-const-reverse-iterator-typedef-qbytearray-rend-const"><code>[since 5.6]</code></a><a href="QByteArray.md#const_reverse_iterator-typedef">QByteArray::const_reverse_iterator</a> QByteArray::rend() const</li>
<li><a href="#qbytearray-qbytearray-md-qbytearray-qbytearray-repeated-qsizetype-times-const-20">QByteArray</a></li>
<li><a href="#qbytearray-qbytearray-md-qbytearray-qbytearray-replace-qsizetype-pos-qsizetype-len-qbytearrayview-https-doc-qt-io-qt-6-qbytearrayview-html-after-21">QByteArray</a></li>
<li><a href="#qbytearray-qbytearray-md-qbytearray-qbytearray-replace-qsizetype-pos-qsizetype-len-const-char-after-qsizetype-alen-22">QByteArray</a></li>
<li><a href="#qbytearray-qbytearray-md-qbytearray-qbytearray-replace-char-before-qbytearrayview-https-doc-qt-io-qt-6-qbytearrayview-html-after-23">QByteArray</a></li>
<li><a href="#qbytearray-qbytearray-md-qbytearray-qbytearray-replace-const-char-before-qsizetype-bsize-const-char-after-qsizetype-asize-24">QByteArray</a></li>
<li><a href="#since-6-0-qbytearray-qbytearray-md-qbytearray-qbytearray-replace-qbytearrayview-https-doc-qt-io-qt-6-qbytearrayview-html-before-qbytearrayview-https-doc-qt-io-qt-6-qbytearrayview-html-after"><code>[since 6.0]</code></a><a href="QByteArray.md#QByteArray">QByteArray</a> &amp;QByteArray::replace(<a target="_blank" rel="noopener" href="https://doc.qt.io/qt-6/qbytearrayview.html">QByteArrayView</a> <em>before</em>, <a target="_blank" rel="noopener" href="https://doc.qt.io/qt-6/qbytearrayview.html">QByteArrayView</a> <em>after</em>)</li>
<li><a href="#qbytearray-qbytearray-md-qbytearray-qbytearray-replace-char-before-char-after-25">QByteArray</a></li>
<li><a href="#void-qbytearray-reserve-qsizetype-size">void QByteArray::reserve(qsizetype <em>size</em>)</a></li>
<li><a href="#void-qbytearray-resize-qsizetype-size">void QByteArray::resize(qsizetype <em>size</em>)</a></li>
<li><a href="#qbytearray-qbytearray-md-qbytearray-qbytearray-right-qsizetype-len-const-26">QByteArray</a></li>
<li><a href="#qbytearray-qbytearray-md-qbytearray-qbytearray-rightjustified-qsizetype-width-char-fill-bool-truncate-false-const-27">QByteArray</a></li>
<li><a href="#qbytearray-qbytearray-md-qbytearray-qbytearray-setnum-int-n-int-base-10-28">QByteArray</a></li>
<li><a href="#qbytearray-qbytearray-md-qbytearray-qbytearray-setnum-short-n-int-base-10-29">QByteArray</a></li>
<li><a href="#qbytearray-qbytearray-md-qbytearray-qbytearray-setnum-ushort-https-doc-qt-io-qt-6-qtglobal-html-ushort-typedef-n-int-base-10-30">QByteArray</a></li>
<li><a href="#qbytearray-qbytearray-md-qbytearray-qbytearray-setnum-uint-https-doc-qt-io-qt-6-qtglobal-html-uint-typedef-n-int-base-10-31">QByteArray</a></li>
<li><a href="#qbytearray-qbytearray-md-qbytearray-qbytearray-setnum-long-n-int-base-10-32">QByteArray</a></li>
<li><a href="#qbytearray-qbytearray-md-qbytearray-qbytearray-setnum-ulong-https-doc-qt-io-qt-6-qtglobal-html-ulong-typedef-n-int-base-10-33">QByteArray</a></li>
<li><a href="#qbytearray-qbytearray-md-qbytearray-qbytearray-setnum-qlonglong-https-doc-qt-io-qt-6-qtglobal-html-qlonglong-typedef-n-int-base-10-34">QByteArray</a></li>
<li><a href="#qbytearray-qbytearray-md-qbytearray-qbytearray-setnum-qulonglong-https-doc-qt-io-qt-6-qtglobal-html-qulonglong-typedef-n-int-base-10-35">QByteArray</a></li>
<li><a href="#qbytearray-qbytearray-md-qbytearray-qbytearray-setnum-float-n-char-format-g-int-precision-6-36">QByteArray</a></li>
<li><a href="#qbytearray-qbytearray-md-qbytearray-qbytearray-setnum-double-n-char-format-g-int-precision-6-37">QByteArray</a></li>
<li><a href="#qbytearray-qbytearray-md-qbytearray-qbytearray-setrawdata-const-char-data-qsizetype-size-38">QByteArray</a></li>
<li><a href="#since-5-10-void-qbytearray-shrink-to-fit"><code>[since 5.10]</code>void QByteArray::shrink_to_fit()</a></li>
<li><a href="#qbytearray-qbytearray-md-qbytearray-qbytearray-simplified-const-39">QByteArray</a></li>
<li><a href="#qsizetype-qbytearray-size-const">qsizetype QByteArray::size() const</a></li>
<li><a href="#since-6-0-qbytearray-qbytearray-md-qbytearray-qbytearray-sliced-qsizetype-pos-qsizetype-n-const"><code>[since 6.0]</code></a><a href="QByteArray.md#QByteArray">QByteArray</a> QByteArray::sliced(qsizetype <em>pos</em>, qsizetype <em>n</em>) const</li>
<li><a href="#since-6-0-qbytearray-qbytearray-md-qbytearray-qbytearray-sliced-qsizetype-pos-const"><code>[since 6.0]</code></a><a href="QByteArray.md#QByteArray">QByteArray</a> QByteArray::sliced(qsizetype <em>pos</em>) const</li>
<li><a href="#qlist-https-doc-qt-io-qt-6-qlist-html-qbytearray-qbytearray-md-qbytearray-qbytearray-split-char-sep-const">QList</a></li>
<li><a href="#void-qbytearray-squeeze">void QByteArray::squeeze()</a></li>
<li><a href="#since-6-0-bool-qbytearray-startswith-qbytearrayview-https-doc-qt-io-qt-6-qbytearrayview-html-bv-const"><code>[since 6.0]</code>bool QByteArray::startsWith(</a><a target="_blank" rel="noopener" href="https://doc.qt.io/qt-6/qbytearrayview.html">QByteArrayView</a> <em>bv</em>) const</li>
<li><a href="#bool-qbytearray-startswith-char-ch-const">bool QByteArray::startsWith(char <em>ch</em>) const</a></li>
<li><a href="#void-qbytearray-swap-qbytearray-qbytearray-md-qbytearray-other">void QByteArray::swap(</a><a href="QByteArray.md#QByteArray">QByteArray</a> &amp;<em>other</em>)</li>
<li><a href="#since-5-2-qbytearray-qbytearray-md-qbytearray-qbytearray-tobase64-qbytearray-base64options-qbytearray-md-base64option-enum-options-base64encoding-const"><code>[since 5.2]</code></a><a href="QByteArray.md#QByteArray">QByteArray</a> QByteArray::toBase64(<a href="QByteArray.md#Base64Option-enum">QByteArray::Base64Options</a> <em>options</em> = Base64Encoding) const</li>
<li><a href="#since-5-3-cfdataref-qbytearray-tocfdata-const"><code>[since 5.3]</code>CFDataRef QByteArray::toCFData() const</a></li>
<li><a href="#double-qbytearray-todouble-bool-ok-nullptr-const">double QByteArray::toDouble(bool *<em>ok</em> = nullptr) const</a></li>
<li><a href="#float-qbytearray-tofloat-bool-ok-nullptr-const">float QByteArray::toFloat(bool *<em>ok</em> = nullptr) const</a></li>
<li><a href="#since-5-9-qbytearray-qbytearray-md-qbytearray-qbytearray-tohex-char-separator-0-const"><code>[since 5.9]</code></a><a href="QByteArray.md#QByteArray">QByteArray</a> QByteArray::toHex(char <em>separator</em> = ‘\0’) const</li>
<li><a href="#int-qbytearray-toint-bool-ok-nullptr-int-base-10-const">int QByteArray::toInt(bool *<em>ok</em> = nullptr, int <em>base</em> = 10) const</a></li>
<li><a href="#long-qbytearray-tolong-bool-ok-nullptr-int-base-10-const">long QByteArray::toLong(bool *<em>ok</em> = nullptr, int <em>base</em> = 10) const</a></li>
<li><a href="#qlonglong-https-doc-qt-io-qt-6-qtglobal-html-qlonglong-typedef-qbytearray-tolonglong-bool-ok-nullptr-int-base-10-const">qlonglong</a></li>
<li><a href="#qbytearray-qbytearray-md-qbytearray-qbytearray-tolower-const-40">QByteArray</a></li>
<li><a href="#since-5-3-nsdata-qbytearray-tonsdata-const"><code>[since 5.3]</code>NSData *QByteArray::toNSData() const</a></li>
<li><a href="#qbytearray-qbytearray-md-qbytearray-qbytearray-topercentencoding-const-qbytearray-qbytearray-md-qbytearray-exclude-qbytearray-const-qbytearray-qbytearray-md-qbytearray-include-qbytearray-char-percent-const-41">QByteArray</a></li>
<li><a href="#since-5-3-cfdataref-qbytearray-torawcfdata-const"><code>[since 5.3]</code>CFDataRef QByteArray::toRawCFData() const</a></li>
<li><a href="#since-5-3-nsdata-qbytearray-torawnsdata-const"><code>[since 5.3]</code>NSData *QByteArray::toRawNSData() const</a></li>
<li><a href="#short-qbytearray-toshort-bool-ok-nullptr-int-base-10-const">short QByteArray::toShort(bool *<em>ok</em> = nullptr, int <em>base</em> = 10) const</a></li>
<li><a href="#since-5-4-std-string-qbytearray-tostdstring-const"><code>[since 5.4]</code>std::string QByteArray::toStdString() const</a></li>
<li><a href="#uint-https-doc-qt-io-qt-6-qtglobal-html-uint-typedef-qbytearray-touint-bool-ok-nullptr-int-base-10-const">uint</a></li>
<li><a href="#ulong-https-doc-qt-io-qt-6-qtglobal-html-ulong-typedef-qbytearray-toulong-bool-ok-nullptr-int-base-10-const">ulong</a></li>
<li><a href="#qulonglong-https-doc-qt-io-qt-6-qtglobal-html-qulonglong-typedef-qbytearray-toulonglong-bool-ok-nullptr-int-base-10-const">qulonglong</a></li>
<li><a href="#ushort-https-doc-qt-io-qt-6-qtglobal-html-ushort-typedef-qbytearray-toushort-bool-ok-nullptr-int-base-10-const">ushort</a></li>
<li><a href="#qbytearray-qbytearray-md-qbytearray-qbytearray-toupper-const-42">QByteArray</a></li>
<li><a href="#qbytearray-qbytearray-md-qbytearray-qbytearray-trimmed-const-43">QByteArray</a></li>
<li><a href="#void-qbytearray-truncate-qsizetype-pos">void QByteArray::truncate(qsizetype <em>pos</em>)</a></li>
<li><a href="#bool-qbytearray-operator-const-qstring-https-doc-qt-io-qt-6-qstring-html-str-const">bool QByteArray::operator!=(const </a><a target="_blank" rel="noopener" href="https://doc.qt.io/qt-6/qstring.html">QString</a> &amp;<em>str</em>) const</li>
<li><a href="#qbytearray-qbytearray-md-qbytearray-qbytearray-operator-const-qbytearray-qbytearray-md-qbytearray-ba-44">QByteArray</a></li>
<li><a href="#qbytearray-qbytearray-md-qbytearray-qbytearray-operator-char-ch-45">QByteArray</a></li>
<li><a href="#qbytearray-qbytearray-md-qbytearray-qbytearray-operator-const-char-str-46">QByteArray</a></li>
<li><a href="#bool-qbytearray-operator-const-qstring-https-doc-qt-io-qt-6-qstring-html-str-const">bool QByteArray::operator&lt;(const </a><a target="_blank" rel="noopener" href="https://doc.qt.io/qt-6/qstring.html">QString</a> &amp;<em>str</em>) const</li>
<li><a href="#bool-qbytearray-operator-const-qstring-https-doc-qt-io-qt-6-qstring-html-str-const">bool QByteArray::operator&lt;=(const </a><a target="_blank" rel="noopener" href="https://doc.qt.io/qt-6/qstring.html">QString</a> &amp;<em>str</em>) const</li>
<li><a href="#qbytearray-qbytearray-md-qbytearray-qbytearray-operator-const-char-str-47">QByteArray</a></li>
<li><a href="#bool-qbytearray-operator-const-qstring-https-doc-qt-io-qt-6-qstring-html-str-const">bool QByteArray::operator==(const </a><a target="_blank" rel="noopener" href="https://doc.qt.io/qt-6/qstring.html">QString</a> &amp;<em>str</em>) const</li>
<li><a href="#bool-qbytearray-operator-const-qstring-https-doc-qt-io-qt-6-qstring-html-str-const">bool QByteArray::operator&gt;(const </a><a target="_blank" rel="noopener" href="https://doc.qt.io/qt-6/qstring.html">QString</a> &amp;<em>str</em>) const</li>
<li><a href="#bool-qbytearray-operator-const-qstring-https-doc-qt-io-qt-6-qstring-html-str-const">bool QByteArray::operator&gt;=(const </a><a target="_blank" rel="noopener" href="https://doc.qt.io/qt-6/qstring.html">QString</a> &amp;<em>str</em>) const</li>
<li><a href="#char-qbytearray-operator-qsizetype-i">char &amp;QByteArray::operator[](qsizetype *i*)</a></li>
<li><a href="#char-qbytearray-operator-qsizetype-i-const">char QByteArray::operator[](qsizetype *i*) const</a></li>
</ul>
</li>
<li><a href="#related-non-members">Related Non-Members</a><ul>
<li><a href="#since-6-1-template-typename-t-qsizetype-erase-qbytearray-qbytearray-md-qbytearray-ba-const-t-t"><code>[since 6.1]</code>template <typename t> qsizetype erase(</typename></a><a href="QByteArray.md#QByteArray">QByteArray</a> &amp;<em>ba</em>, const T &amp;<em>t</em>)</li>
<li><a href="#since-6-1-template-typename-predicate-qsizetype-erase-if-qbytearray-qbytearray-md-qbytearray-ba-predicate-pred"><code>[since 6.1]</code>template <typename predicate> qsizetype erase_if(</typename></a><a href="QByteArray.md#QByteArray">QByteArray</a> &amp;<em>ba</em>, Predicate <em>pred</em>)</li>
<li><a href="#since-5-9-quint16-https-doc-qt-io-qt-6-qtglobal-html-quint16-typedef-qchecksum-qbytearrayview-https-doc-qt-io-qt-6-qbytearrayview-html-data-qt-checksumtype-https-doc-qt-io-qt-6-qt-html-checksumtype-enum-standard-qt-checksumiso3309"><code>[since 5.9]</code></a><a target="_blank" rel="noopener" href="https://doc.qt.io/qt-6/qtglobal.html#quint16-typedef">quint16</a> qChecksum(<a target="_blank" rel="noopener" href="https://doc.qt.io/qt-6/qbytearrayview.html">QByteArrayView</a> <em>data</em>, <a target="_blank" rel="noopener" href="https://doc.qt.io/qt-6/qt.html#ChecksumType-enum">Qt::ChecksumType</a> <em>standard</em> = Qt::ChecksumIso3309)</li>
<li><a href="#qbytearray-qbytearray-md-qbytearray-qcompress-const-qbytearray-qbytearray-md-qbytearray-data-int-compressionlevel-1-48">QByteArray</a></li>
<li><a href="#qbytearray-qbytearray-md-qbytearray-qcompress-const-uchar-https-doc-qt-io-qt-6-qtglobal-html-uchar-typedef-data-qsizetype-nbytes-int-compressionlevel-1-49">QByteArray</a></li>
<li><a href="#qbytearray-qbytearray-md-qbytearray-quncompress-const-qbytearray-qbytearray-md-qbytearray-data-50">QByteArray</a></li>
<li><a href="#qbytearray-qbytearray-md-qbytearray-quncompress-const-uchar-https-doc-qt-io-qt-6-qtglobal-html-uchar-typedef-data-qsizetype-nbytes-51">QByteArray</a></li>
<li><a href="#int-qsnprintf-char-str-size-t-n-const-char-fmt">int qsnprintf(char *<em>str</em>, size_t <em>n</em>, const char *<em>fmt</em>, …)</a></li>
<li><a href="#int-qstrcmp-const-char-str1-const-char-str2">int qstrcmp(const char *<em>str1</em>, const char *<em>str2</em>)</a></li>
<li><a href="#char-qstrcpy-char-dst-const-char-src">char *qstrcpy(char *<em>dst</em>, const char *<em>src</em>)</a></li>
<li><a href="#char-qstrdup-const-char-src">char *qstrdup(const char *<em>src</em>)</a></li>
<li><a href="#int-qstricmp-const-char-str1-const-char-str2">int qstricmp(const char *<em>str1</em>, const char *<em>str2</em>)</a></li>
<li><a href="#size-t-qstrlen-const-char-str">size_t qstrlen(const char *<em>str</em>)</a></li>
<li><a href="#int-qstrncmp-const-char-str1-const-char-str2-size-t-len">int qstrncmp(const char *<em>str1</em>, const char *<em>str2</em>, size_t <em>len</em>)</a></li>
<li><a href="#char-qstrncpy-char-dst-const-char-src-size-t-len">char *qstrncpy(char *<em>dst</em>, const char *<em>src</em>, size_t <em>len</em>)</a></li>
<li><a href="#int-qstrnicmp-const-char-str1-const-char-str2-size-t-len">int qstrnicmp(const char *<em>str1</em>, const char *<em>str2</em>, size_t <em>len</em>)</a></li>
<li><a href="#size-t-qstrnlen-const-char-str-size-t-maxlen">size_t qstrnlen(const char *<em>str</em>, size_t <em>maxlen</em>)</a></li>
<li><a href="#int-qvsnprintf-char-str-size-t-n-const-char-fmt-va-list-ap">int qvsnprintf(char *<em>str</em>, size_t <em>n</em>, const char *<em>fmt</em>, va_list <em>ap</em>)</a></li>
<li><a href="#bool-operator-const-qbytearray-qbytearray-md-qbytearray-a1-const-qbytearray-qbytearray-md-qbytearray-a2">bool operator!=(const </a><a href="QByteArray.md#QByteArray">QByteArray</a> &amp;<em>a1</em>, const <a href="QByteArray.md#QByteArray">QByteArray</a> &amp;<em>a2</em>)</li>
<li><a href="#bool-operator-const-qbytearray-qbytearray-md-qbytearray-a1-const-char-a2">bool operator!=(const </a><a href="QByteArray.md#QByteArray">QByteArray</a> &amp;<em>a1</em>, const char *<em>a2</em>)</li>
<li><a href="#bool-operator-const-char-a1-const-qbytearray-qbytearray-md-qbytearray-a2">bool operator!=(const char *<em>a1</em>, const </a><a href="QByteArray.md#QByteArray">QByteArray</a> &amp;<em>a2</em>)</li>
<li><a href="#since-6-2-qbytearray-qbytearray-md-qbytearray-operator-qba-const-char-str-size-t-size"><code>[since 6.2]</code></a><a href="QByteArray.md#QByteArray">QByteArray</a> operator””_qba(const char *<em>str</em>, size_t <em>size</em>)</li>
<li><a href="#const-qbytearray-qbytearray-md-qbytearray-operator-const-qbytearray-qbytearray-md-qbytearray-a1-const-qbytearray-qbytearray-md-qbytearray-a2">const </a><a href="QByteArray.md#QByteArray">QByteArray</a> operator+(const <a href="QByteArray.md#QByteArray">QByteArray</a> &amp;<em>a1</em>, const <a href="QByteArray.md#QByteArray">QByteArray</a> &amp;<em>a2</em>)</li>
<li><a href="#const-qbytearray-qbytearray-md-qbytearray-operator-const-qbytearray-qbytearray-md-qbytearray-a1-const-char-a2">const </a><a href="QByteArray.md#QByteArray">QByteArray</a> operator+(const <a href="QByteArray.md#QByteArray">QByteArray</a> &amp;<em>a1</em>, const char *<em>a2</em>)</li>
<li><a href="#const-qbytearray-qbytearray-md-qbytearray-operator-const-qbytearray-qbytearray-md-qbytearray-a1-char-a2">const </a><a href="QByteArray.md#QByteArray">QByteArray</a> operator+(const <a href="QByteArray.md#QByteArray">QByteArray</a> &amp;<em>a1</em>, char <em>a2</em>)</li>
<li><a href="#const-qbytearray-qbytearray-md-qbytearray-operator-const-char-a1-const-qbytearray-qbytearray-md-qbytearray-a2">const </a><a href="QByteArray.md#QByteArray">QByteArray</a> operator+(const char *<em>a1</em>, const <a href="QByteArray.md#QByteArray">QByteArray</a> &amp;<em>a2</em>)</li>
<li><a href="#const-qbytearray-qbytearray-md-qbytearray-operator-char-a1-const-qbytearray-qbytearray-md-qbytearray-a2">const </a><a href="QByteArray.md#QByteArray">QByteArray</a> operator+(char <em>a1</em>, const <a href="QByteArray.md#QByteArray">QByteArray</a> &amp;<em>a2</em>)</li>
<li><a href="#bool-operator-const-qbytearray-qbytearray-md-qbytearray-a1-const-qbytearray-qbytearray-md-qbytearray-a2">bool operator&lt;(const </a><a href="QByteArray.md#QByteArray">QByteArray</a> &amp;<em>a1</em>, const <a href="QByteArray.md#QByteArray">QByteArray</a> &amp;<em>a2</em>)</li>
<li><a href="#bool-operator-const-qbytearray-qbytearray-md-qbytearray-a1-const-char-a2">bool operator&lt;(const </a><a href="QByteArray.md#QByteArray">QByteArray</a> &amp;<em>a1</em>, const char *<em>a2</em>)</li>
<li><a href="#bool-operator-const-char-a1-const-qbytearray-qbytearray-md-qbytearray-a2">bool operator&lt;(const char *<em>a1</em>, const </a><a href="QByteArray.md#QByteArray">QByteArray</a> &amp;<em>a2</em>)</li>
<li><a href="#qdatastream-https-doc-qt-io-qt-6-qdatastream-html-operator-qdatastream-https-doc-qt-io-qt-6-qdatastream-html-out-const-qbytearray-qbytearray-md-qbytearray-ba">QDataStream</a></li>
<li><a href="#bool-operator-const-qbytearray-qbytearray-md-qbytearray-a1-const-qbytearray-qbytearray-md-qbytearray-a2">bool operator&lt;=(const </a><a href="QByteArray.md#QByteArray">QByteArray</a> &amp;<em>a1</em>, const <a href="QByteArray.md#QByteArray">QByteArray</a> &amp;<em>a2</em>)</li>
<li><a href="#bool-operator-const-qbytearray-qbytearray-md-qbytearray-a1-const-char-a2">bool operator&lt;=(const </a><a href="QByteArray.md#QByteArray">QByteArray</a> &amp;<em>a1</em>, const char *<em>a2</em>)</li>
<li><a href="#bool-operator-const-char-a1-const-qbytearray-qbytearray-md-qbytearray-a2">bool operator&lt;=(const char *<em>a1</em>, const </a><a href="QByteArray.md#QByteArray">QByteArray</a> &amp;<em>a2</em>)</li>
<li><a href="#bool-operator-const-qbytearray-qbytearray-md-qbytearray-a1-const-qbytearray-qbytearray-md-qbytearray-a2">bool operator==(const </a><a href="QByteArray.md#QByteArray">QByteArray</a> &amp;<em>a1</em>, const <a href="QByteArray.md#QByteArray">QByteArray</a> &amp;<em>a2</em>)</li>
<li><a href="#bool-operator-const-qbytearray-qbytearray-md-qbytearray-a1-const-char-a2">bool operator==(const </a><a href="QByteArray.md#QByteArray">QByteArray</a> &amp;<em>a1</em>, const char *<em>a2</em>)</li>
<li><a href="#bool-operator-const-char-a1-const-qbytearray-qbytearray-md-qbytearray-a2">bool operator==(const char *<em>a1</em>, const </a><a href="QByteArray.md#QByteArray">QByteArray</a> &amp;<em>a2</em>)</li>
<li><a href="#bool-operator-const-qbytearray-qbytearray-md-qbytearray-a1-const-qbytearray-qbytearray-md-qbytearray-a2">bool operator&gt;(const </a><a href="QByteArray.md#QByteArray">QByteArray</a> &amp;<em>a1</em>, const <a href="QByteArray.md#QByteArray">QByteArray</a> &amp;<em>a2</em>)</li>
<li><a href="#bool-operator-const-qbytearray-qbytearray-md-qbytearray-a1-const-char-a2">bool operator&gt;(const </a><a href="QByteArray.md#QByteArray">QByteArray</a> &amp;<em>a1</em>, const char *<em>a2</em>)</li>
<li><a href="#bool-operator-const-char-a1-const-qbytearray-qbytearray-md-qbytearray-a2">bool operator&gt;(const char *<em>a1</em>, const </a><a href="QByteArray.md#QByteArray">QByteArray</a> &amp;<em>a2</em>)</li>
<li><a href="#bool-operator-const-qbytearray-qbytearray-md-qbytearray-a1-const-qbytearray-qbytearray-md-qbytearray-a2">bool operator&gt;=(const </a><a href="QByteArray.md#QByteArray">QByteArray</a> &amp;<em>a1</em>, const <a href="QByteArray.md#QByteArray">QByteArray</a> &amp;<em>a2</em>)</li>
<li><a href="#bool-operator-const-qbytearray-qbytearray-md-qbytearray-a1-const-char-a2">bool operator&gt;=(const </a><a href="QByteArray.md#QByteArray">QByteArray</a> &amp;<em>a1</em>, const char *<em>a2</em>)</li>
<li><a href="#bool-operator-const-char-a1-const-qbytearray-qbytearray-md-qbytearray-a2">bool operator&gt;=(const char *<em>a1</em>, const </a><a href="QByteArray.md#QByteArray">QByteArray</a> &amp;<em>a2</em>)</li>
<li><a href="#qdatastream-https-doc-qt-io-qt-6-qdatastream-html-operator-qdatastream-https-doc-qt-io-qt-6-qdatastream-html-in-qbytearray-qbytearray-md-qbytearray-ba-1">QDataStream</a></li>
</ul>
</li>
<li><a href="#hong-wen-dang">宏文档</a><ul>
<li><a href="#qbytearrayliteral-ba">QByteArrayLiteral(<em>ba</em>)</a></li>
<li><a href="#qt-no-cast-from-bytearray">QT_NO_CAST_FROM_BYTEARRAY</a></li>
</ul>
</li>
</ul>
</li>
</ul>
<!-- tocstop -->

</div>

<h1><span id="qbytearray-class">QByteArray Class</span><a href="#qbytearray-class" class="header-anchor">#</a></h1><p>QByteArray 类提供了一个字节数组. <a href="QByteArray.md#details">More…</a></p>
<table>
<thead>
<tr>
<th>Header:</th>
<th>#include <qbytearray></qbytearray></th>
</tr>
</thead>
<tbody><tr>
<td>CMake:</td>
<td>find_package(Qt6 COMPONENTS Core REQUIRED) target_link_libraries(mytarget PRIVATE Qt6::Core)</td>
</tr>
<tr>
<td>qmake:</td>
<td>QT += core</td>
</tr>
</tbody></table>
<ul>
<li><a target="_blank" rel="noopener" href="https://doc.qt.io/qt-6/qbytearray-members.html">List of all members, including inherited members</a></li>
</ul>
<p><strong>Note:</strong> 这个类中的所有函数都是<a target="_blank" rel="noopener" href="https://doc.qt.io/qt-6/17-qdoc-commands-thread.html#reentrant">reentrant</a>。</p>
<h2><span id="gong-gong-lei-xing">公共类型</span><a href="#gong-gong-lei-xing" class="header-anchor">#</a></h2><table>
<thead>
<tr>
<th>class</th>
<th><strong><a target="_blank" rel="noopener" href="https://doc.qt.io/qt-6/qbytearray-frombase64result.html">FromBase64Result</a></strong></th>
</tr>
</thead>
<tbody><tr>
<td>enum</td>
<td><strong><a href="QByteArray.md#Base64Option-enum">Base64Option</a></strong> { Base64Encoding, Base64UrlEncoding, KeepTrailingEquals, OmitTrailingEquals, IgnoreBase64DecodingErrors, AbortOnBase64DecodingErrors }</td>
</tr>
<tr>
<td>flags</td>
<td><strong><a href="QByteArray.md#Base64Option-enum">Base64Options</a></strong></td>
</tr>
<tr>
<td></td>
<td><strong><a href="QByteArray.md#const_iterator-typedef">const_iterator</a></strong></td>
</tr>
<tr>
<td></td>
<td><strong><a href="QByteArray.md#const_reverse_iterator-typedef">const_reverse_iterator</a></strong></td>
</tr>
<tr>
<td></td>
<td><strong><a href="QByteArray.md#iterator-typedef">iterator</a></strong></td>
</tr>
<tr>
<td></td>
<td><strong><a href="QByteArray.md#reverse_iterator-typedef">reverse_iterator</a></strong></td>
</tr>
</tbody></table>
<h2><span id="gong-gong-han-shu">公共函数</span><a href="#gong-gong-han-shu" class="header-anchor">#</a></h2><table>
<thead>
<tr>
<th></th>
<th><strong><a href="QByteArray.md#QByteArray-3">QByteArray</a></strong>(QByteArray &amp;&amp;<em>other</em>)</th>
</tr>
</thead>
<tbody><tr>
<td></td>
<td><strong><a href="QByteArray.md#QByteArray">QByteArray</a></strong>(const QByteArray &amp;<em>other</em>)</td>
</tr>
<tr>
<td></td>
<td><strong><a href="QByteArray.md#QByteArray-2">QByteArray</a></strong>(qsizetype <em>size</em>, char <em>ch</em>)</td>
</tr>
<tr>
<td></td>
<td><strong><a href="QByteArray.md#QByteArray-1">QByteArray</a></strong>(const char *<em>data</em>, qsizetype <em>size</em> = -1)</td>
</tr>
<tr>
<td></td>
<td><strong><a href="QByteArray.md#QByteArray">QByteArray</a></strong>()</td>
</tr>
<tr>
<td>QByteArray &amp;</td>
<td><strong><a href="QByteArray.md#operator-eq-2">operator=</a></strong>(QByteArray &amp;&amp;<em>other</em>)</td>
</tr>
<tr>
<td>QByteArray &amp;</td>
<td><strong><a href="QByteArray.md#operator-eq">operator=</a></strong>(const QByteArray &amp;<em>other</em>)</td>
</tr>
<tr>
<td></td>
<td><strong><a href="QByteArray.md#dtor.QByteArray">~QByteArray</a></strong>()</td>
</tr>
<tr>
<td>QByteArray &amp;</td>
<td><strong><a href="QByteArray.md#append">append</a></strong>(const QByteArray &amp;<em>ba</em>)</td>
</tr>
<tr>
<td>QByteArray &amp;</td>
<td><strong><a href="QByteArray.md#append-1">append</a></strong>(char <em>ch</em>)</td>
</tr>
<tr>
<td>QByteArray &amp;</td>
<td><strong><a href="QByteArray.md#append-2">append</a></strong>(qsizetype <em>count</em>, char <em>ch</em>)</td>
</tr>
<tr>
<td>QByteArray &amp;</td>
<td><strong><a href="QByteArray.md#append-3">append</a></strong>(const char *<em>str</em>)</td>
</tr>
<tr>
<td>QByteArray &amp;</td>
<td><strong><a href="QByteArray.md#append-4">append</a></strong>(const char *<em>str</em>, qsizetype <em>len</em>)</td>
</tr>
<tr>
<td>QByteArray &amp;</td>
<td><strong><a href="QByteArray.md#append-5">append</a></strong>(QByteArrayView <em>data</em>)</td>
</tr>
<tr>
<td>char</td>
<td><strong><a href="QByteArray.md#at">at</a></strong>(qsizetype <em>i</em>) const</td>
</tr>
<tr>
<td>char</td>
<td><strong><a href="QByteArray.md#back">back</a></strong>() const</td>
</tr>
<tr>
<td>char &amp;</td>
<td><strong><a href="QByteArray.md#back-1">back</a></strong>()</td>
</tr>
<tr>
<td>QByteArray::iterator</td>
<td><strong><a href="QByteArray.md#begin">begin</a></strong>()</td>
</tr>
<tr>
<td>QByteArray::const_iterator</td>
<td><strong><a href="QByteArray.md#begin-1">begin</a></strong>() const</td>
</tr>
<tr>
<td>qsizetype</td>
<td><strong><a href="QByteArray.md#capacity">capacity</a></strong>() const</td>
</tr>
<tr>
<td>QByteArray::const_iterator</td>
<td><strong><a href="QByteArray.md#cbegin">cbegin</a></strong>() const</td>
</tr>
<tr>
<td>QByteArray::const_iterator</td>
<td><strong><a href="QByteArray.md#cend">cend</a></strong>() const</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="QByteArray.md#chop">chop</a></strong>(qsizetype <em>n</em>)</td>
</tr>
<tr>
<td>QByteArray</td>
<td><strong><a href="QByteArray.md#chopped">chopped</a></strong>(qsizetype <em>len</em>) const</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="QByteArray.md#clear">clear</a></strong>()</td>
</tr>
<tr>
<td>int</td>
<td><strong><a href="QByteArray.md#compare">compare</a></strong>(QByteArrayView <em>bv</em>, Qt::CaseSensitivity <em>cs</em> = Qt::CaseSensitive) const</td>
</tr>
<tr>
<td>QByteArray::const_iterator</td>
<td><strong><a href="QByteArray.md#constBegin">constBegin</a></strong>() const</td>
</tr>
<tr>
<td>const char *</td>
<td><strong><a href="QByteArray.md#constData">constData</a></strong>() const</td>
</tr>
<tr>
<td>QByteArray::const_iterator</td>
<td><strong><a href="QByteArray.md#constEnd">constEnd</a></strong>() const</td>
</tr>
<tr>
<td>bool</td>
<td><strong><a href="QByteArray.md#contains">contains</a></strong>(QByteArrayView <em>bv</em>) const</td>
</tr>
<tr>
<td>bool</td>
<td><strong><a href="QByteArray.md#contains-1">contains</a></strong>(char <em>ch</em>) const</td>
</tr>
<tr>
<td>qsizetype</td>
<td><strong><a href="QByteArray.md#count">count</a></strong>(QByteArrayView <em>bv</em>) const</td>
</tr>
<tr>
<td>qsizetype</td>
<td><strong><a href="QByteArray.md#count-1">count</a></strong>(char <em>ch</em>) const</td>
</tr>
<tr>
<td>qsizetype</td>
<td><strong><a href="QByteArray.md#count-2">count</a></strong>() const</td>
</tr>
<tr>
<td>QByteArray::const_reverse_iterator</td>
<td><strong><a href="QByteArray.md#crbegin">crbegin</a></strong>() const</td>
</tr>
<tr>
<td>QByteArray::const_reverse_iterator</td>
<td><strong><a href="QByteArray.md#crend">crend</a></strong>() const</td>
</tr>
<tr>
<td>char *</td>
<td><strong><a href="QByteArray.md#data">data</a></strong>()</td>
</tr>
<tr>
<td>const char *</td>
<td><strong><a href="QByteArray.md#data-1">data</a></strong>() const</td>
</tr>
<tr>
<td>QByteArray::iterator</td>
<td><strong><a href="QByteArray.md#end">end</a></strong>()</td>
</tr>
<tr>
<td>QByteArray::const_iterator</td>
<td><strong><a href="QByteArray.md#end-1">end</a></strong>() const</td>
</tr>
<tr>
<td>bool</td>
<td><strong><a href="QByteArray.md#endsWith">endsWith</a></strong>(QByteArrayView <em>bv</em>) const</td>
</tr>
<tr>
<td>bool</td>
<td><strong><a href="QByteArray.md#endsWith-1">endsWith</a></strong>(char <em>ch</em>) const</td>
</tr>
<tr>
<td>QByteArray::iterator</td>
<td><strong><a href="QByteArray.md#erase">erase</a></strong>(QByteArray::const_iterator <em>first</em>, QByteArray::const_iterator <em>last</em>)</td>
</tr>
<tr>
<td>QByteArray &amp;</td>
<td><strong><a href="QByteArray.md#fill">fill</a></strong>(char <em>ch</em>, qsizetype <em>size</em> = -1)</td>
</tr>
<tr>
<td>QByteArray</td>
<td><strong><a href="QByteArray.md#first">first</a></strong>(qsizetype <em>n</em>) const</td>
</tr>
<tr>
<td>char</td>
<td><strong><a href="QByteArray.md#front">front</a></strong>() const</td>
</tr>
<tr>
<td>char &amp;</td>
<td><strong><a href="QByteArray.md#front-1">front</a></strong>()</td>
</tr>
<tr>
<td>qsizetype</td>
<td><strong><a href="QByteArray.md#indexOf">indexOf</a></strong>(QByteArrayView <em>bv</em>, qsizetype <em>from</em> = 0) const</td>
</tr>
<tr>
<td>qsizetype</td>
<td><strong><a href="QByteArray.md#indexOf-1">indexOf</a></strong>(char <em>ch</em>, qsizetype <em>from</em> = 0) const</td>
</tr>
<tr>
<td>QByteArray &amp;</td>
<td><strong><a href="QByteArray.md#insert">insert</a></strong>(qsizetype <em>i</em>, QByteArrayView <em>data</em>)</td>
</tr>
<tr>
<td>QByteArray &amp;</td>
<td><strong><a href="QByteArray.md#insert-1">insert</a></strong>(qsizetype <em>i</em>, const char *<em>s</em>)</td>
</tr>
<tr>
<td>QByteArray &amp;</td>
<td><strong><a href="QByteArray.md#insert-2">insert</a></strong>(qsizetype <em>i</em>, const QByteArray &amp;<em>data</em>)</td>
</tr>
<tr>
<td>QByteArray &amp;</td>
<td><strong><a href="QByteArray.md#insert-3">insert</a></strong>(qsizetype <em>i</em>, qsizetype <em>count</em>, char <em>ch</em>)</td>
</tr>
<tr>
<td>QByteArray &amp;</td>
<td><strong><a href="QByteArray.md#insert-4">insert</a></strong>(qsizetype <em>i</em>, char <em>ch</em>)</td>
</tr>
<tr>
<td>QByteArray &amp;</td>
<td><strong><a href="QByteArray.md#insert-5">insert</a></strong>(qsizetype <em>i</em>, const char *<em>data</em>, qsizetype <em>len</em>)</td>
</tr>
<tr>
<td>bool</td>
<td><strong><a href="QByteArray.md#isEmpty">isEmpty</a></strong>() const</td>
</tr>
<tr>
<td>bool</td>
<td><strong><a href="QByteArray.md#isLower">isLower</a></strong>() const</td>
</tr>
<tr>
<td>bool</td>
<td><strong><a href="QByteArray.md#isNull">isNull</a></strong>() const</td>
</tr>
<tr>
<td>bool</td>
<td><strong><a href="QByteArray.md#isUpper">isUpper</a></strong>() const</td>
</tr>
<tr>
<td>QByteArray</td>
<td><strong><a href="QByteArray.md#last">last</a></strong>(qsizetype <em>n</em>) const</td>
</tr>
<tr>
<td>qsizetype</td>
<td><strong><a href="QByteArray.md#lastIndexOf">lastIndexOf</a></strong>(QByteArrayView <em>bv</em>, qsizetype <em>from</em>) const</td>
</tr>
<tr>
<td>qsizetype</td>
<td><strong><a href="QByteArray.md#lastIndexOf-1">lastIndexOf</a></strong>(char <em>ch</em>, qsizetype <em>from</em> = -1) const</td>
</tr>
<tr>
<td>qsizetype</td>
<td><strong><a href="QByteArray.md#lastIndexOf-2">lastIndexOf</a></strong>(QByteArrayView <em>bv</em>) const</td>
</tr>
<tr>
<td>QByteArray</td>
<td><strong><a href="QByteArray.md#left">left</a></strong>(qsizetype <em>len</em>) const</td>
</tr>
<tr>
<td>QByteArray</td>
<td><strong><a href="QByteArray.md#leftJustified">leftJustified</a></strong>(qsizetype <em>width</em>, char <em>fill</em> = ‘ ‘, bool <em>truncate</em> = false) const</td>
</tr>
<tr>
<td>qsizetype</td>
<td><strong><a href="QByteArray.md#length">length</a></strong>() const</td>
</tr>
<tr>
<td>QByteArray</td>
<td><strong><a href="QByteArray.md#mid">mid</a></strong>(qsizetype <em>pos</em>, qsizetype <em>len</em> = -1) const</td>
</tr>
<tr>
<td>QByteArray &amp;</td>
<td><strong><a href="QByteArray.md#prepend">prepend</a></strong>(QByteArrayView <em>ba</em>)</td>
</tr>
<tr>
<td>QByteArray &amp;</td>
<td><strong><a href="QByteArray.md#prepend-1">prepend</a></strong>(char <em>ch</em>)</td>
</tr>
<tr>
<td>QByteArray &amp;</td>
<td><strong><a href="QByteArray.md#prepend-2">prepend</a></strong>(qsizetype <em>count</em>, char <em>ch</em>)</td>
</tr>
<tr>
<td>QByteArray &amp;</td>
<td><strong><a href="QByteArray.md#prepend-3">prepend</a></strong>(const char *<em>str</em>)</td>
</tr>
<tr>
<td>QByteArray &amp;</td>
<td><strong><a href="QByteArray.md#prepend-4">prepend</a></strong>(const char *<em>str</em>, qsizetype <em>len</em>)</td>
</tr>
<tr>
<td>QByteArray &amp;</td>
<td><strong><a href="QByteArray.md#prepend-5">prepend</a></strong>(const QByteArray &amp;<em>ba</em>)</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="QByteArray.md#push_back">push_back</a></strong>(const QByteArray &amp;<em>other</em>)</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="QByteArray.md#push_back-1">push_back</a></strong>(char <em>ch</em>)</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="QByteArray.md#push_back-2">push_back</a></strong>(const char *<em>str</em>)</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="QByteArray.md#push_back-3">push_back</a></strong>(QByteArrayView <em>str</em>)</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="QByteArray.md#push_front">push_front</a></strong>(const QByteArray &amp;<em>other</em>)</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="QByteArray.md#push_front-1">push_front</a></strong>(char <em>ch</em>)</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="QByteArray.md#push_front-2">push_front</a></strong>(const char *<em>str</em>)</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="QByteArray.md#push_front-3">push_front</a></strong>(QByteArrayView <em>str</em>)</td>
</tr>
<tr>
<td>QByteArray::reverse_iterator</td>
<td><strong><a href="QByteArray.md#rbegin">rbegin</a></strong>()</td>
</tr>
<tr>
<td>QByteArray::const_reverse_iterator</td>
<td><strong><a href="QByteArray.md#rbegin-1">rbegin</a></strong>() const</td>
</tr>
<tr>
<td>QByteArray &amp;</td>
<td><strong><a href="QByteArray.md#remove">remove</a></strong>(qsizetype <em>pos</em>, qsizetype <em>len</em>)</td>
</tr>
<tr>
<td>QByteArray &amp;</td>
<td><strong><a href="QByteArray.md#removeIf">removeIf</a></strong>(Predicate <em>pred</em>)</td>
</tr>
<tr>
<td>QByteArray::reverse_iterator</td>
<td><strong><a href="QByteArray.md#rend">rend</a></strong>()</td>
</tr>
<tr>
<td>QByteArray::const_reverse_iterator</td>
<td><strong><a href="QByteArray.md#rend-1">rend</a></strong>() const</td>
</tr>
<tr>
<td>QByteArray</td>
<td><strong><a href="QByteArray.md#repeated">repeated</a></strong>(qsizetype <em>times</em>) const</td>
</tr>
<tr>
<td>QByteArray &amp;</td>
<td><strong><a href="QByteArray.md#replace">replace</a></strong>(qsizetype <em>pos</em>, qsizetype <em>len</em>, QByteArrayView <em>after</em>)</td>
</tr>
<tr>
<td>QByteArray &amp;</td>
<td><strong><a href="QByteArray.md#replace-1">replace</a></strong>(qsizetype <em>pos</em>, qsizetype <em>len</em>, const char *<em>after</em>, qsizetype <em>alen</em>)</td>
</tr>
<tr>
<td>QByteArray &amp;</td>
<td><strong><a href="QByteArray.md#replace-2">replace</a></strong>(char <em>before</em>, QByteArrayView <em>after</em>)</td>
</tr>
<tr>
<td>QByteArray &amp;</td>
<td><strong><a href="QByteArray.md#replace-3">replace</a></strong>(const char *<em>before</em>, qsizetype <em>bsize</em>, const char *<em>after</em>, qsizetype <em>asize</em>)</td>
</tr>
<tr>
<td>QByteArray &amp;</td>
<td><strong><a href="QByteArray.md#replace-4">replace</a></strong>(QByteArrayView <em>before</em>, QByteArrayView <em>after</em>)</td>
</tr>
<tr>
<td>QByteArray &amp;</td>
<td><strong><a href="QByteArray.md#replace-5">replace</a></strong>(char <em>before</em>, char <em>after</em>)</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="QByteArray.md#reserve">reserve</a></strong>(qsizetype <em>size</em>)</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="QByteArray.md#resize">resize</a></strong>(qsizetype <em>size</em>)</td>
</tr>
<tr>
<td>QByteArray</td>
<td><strong><a href="QByteArray.md#right">right</a></strong>(qsizetype <em>len</em>) const</td>
</tr>
<tr>
<td>QByteArray</td>
<td><strong><a href="QByteArray.md#rightJustified">rightJustified</a></strong>(qsizetype <em>width</em>, char <em>fill</em> = ‘ ‘, bool <em>truncate</em> = false) const</td>
</tr>
<tr>
<td>QByteArray &amp;</td>
<td><strong><a href="QByteArray.md#setNum">setNum</a></strong>(int <em>n</em>, int <em>base</em> = 10)</td>
</tr>
<tr>
<td>QByteArray &amp;</td>
<td><strong><a href="QByteArray.md#setNum-1">setNum</a></strong>(short <em>n</em>, int <em>base</em> = 10)</td>
</tr>
<tr>
<td>QByteArray &amp;</td>
<td><strong><a href="QByteArray.md#setNum-2">setNum</a></strong>(ushort <em>n</em>, int <em>base</em> = 10)</td>
</tr>
<tr>
<td>QByteArray &amp;</td>
<td><strong><a href="QByteArray.md#setNum-3">setNum</a></strong>(uint <em>n</em>, int <em>base</em> = 10)</td>
</tr>
<tr>
<td>QByteArray &amp;</td>
<td><strong><a href="QByteArray.md#setNum-4">setNum</a></strong>(long <em>n</em>, int <em>base</em> = 10)</td>
</tr>
<tr>
<td>QByteArray &amp;</td>
<td><strong><a href="QByteArray.md#setNum-5">setNum</a></strong>(ulong <em>n</em>, int <em>base</em> = 10)</td>
</tr>
<tr>
<td>QByteArray &amp;</td>
<td><strong><a href="QByteArray.md#setNum-6">setNum</a></strong>(qlonglong <em>n</em>, int <em>base</em> = 10)</td>
</tr>
<tr>
<td>QByteArray &amp;</td>
<td><strong><a href="QByteArray.md#setNum-7">setNum</a></strong>(qulonglong <em>n</em>, int <em>base</em> = 10)</td>
</tr>
<tr>
<td>QByteArray &amp;</td>
<td><strong><a href="QByteArray.md#setNum-8">setNum</a></strong>(float <em>n</em>, char <em>format</em> = ‘g’, int <em>precision</em> = 6)</td>
</tr>
<tr>
<td>QByteArray &amp;</td>
<td><strong><a href="QByteArray.md#setNum-9">setNum</a></strong>(double <em>n</em>, char <em>format</em> = ‘g’, int <em>precision</em> = 6)</td>
</tr>
<tr>
<td>QByteArray &amp;</td>
<td><strong><a href="QByteArray.md#setRawData">setRawData</a></strong>(const char *<em>data</em>, qsizetype <em>size</em>)</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="QByteArray.md#shrink_to_fit">shrink_to_fit</a></strong>()</td>
</tr>
<tr>
<td>QByteArray</td>
<td><strong><a href="QByteArray.md#simplified">simplified</a></strong>() const</td>
</tr>
<tr>
<td>qsizetype</td>
<td><strong><a href="QByteArray.md#size">size</a></strong>() const</td>
</tr>
<tr>
<td>QByteArray</td>
<td><strong><a href="QByteArray.md#sliced">sliced</a></strong>(qsizetype <em>pos</em>, qsizetype <em>n</em>) const</td>
</tr>
<tr>
<td>QByteArray</td>
<td><strong><a href="QByteArray.md#sliced-1">sliced</a></strong>(qsizetype <em>pos</em>) const</td>
</tr>
<tr>
<td>QList<qbytearray></qbytearray></td>
<td><strong><a href="QByteArray.md#split">split</a></strong>(char <em>sep</em>) const</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="QByteArray.md#squeeze">squeeze</a></strong>()</td>
</tr>
<tr>
<td>bool</td>
<td><strong><a href="QByteArray.md#startsWith">startsWith</a></strong>(QByteArrayView <em>bv</em>) const</td>
</tr>
<tr>
<td>bool</td>
<td><strong><a href="QByteArray.md#startsWith-1">startsWith</a></strong>(char <em>ch</em>) const</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="QByteArray.md#swap">swap</a></strong>(QByteArray &amp;<em>other</em>)</td>
</tr>
<tr>
<td>QByteArray</td>
<td><strong><a href="QByteArray.md#toBase64">toBase64</a></strong>(QByteArray::Base64Options <em>options</em> = Base64Encoding) const</td>
</tr>
<tr>
<td>CFDataRef</td>
<td><strong><a href="QByteArray.md#toCFData">toCFData</a></strong>() const</td>
</tr>
<tr>
<td>double</td>
<td><strong><a href="QByteArray.md#toDouble">toDouble</a></strong>(bool *<em>ok</em> = nullptr) const</td>
</tr>
<tr>
<td>float</td>
<td><strong><a href="QByteArray.md#toFloat">toFloat</a></strong>(bool *<em>ok</em> = nullptr) const</td>
</tr>
<tr>
<td>QByteArray</td>
<td><strong><a href="QByteArray.md#toHex">toHex</a></strong>(char <em>separator</em> = ‘\0’) const</td>
</tr>
<tr>
<td>int</td>
<td><strong><a href="QByteArray.md#toInt">toInt</a></strong>(bool *<em>ok</em> = nullptr, int <em>base</em> = 10) const</td>
</tr>
<tr>
<td>long</td>
<td><strong><a href="QByteArray.md#toLong">toLong</a></strong>(bool *<em>ok</em> = nullptr, int <em>base</em> = 10) const</td>
</tr>
<tr>
<td>qlonglong</td>
<td><strong><a href="QByteArray.md#toLongLong">toLongLong</a></strong>(bool *<em>ok</em> = nullptr, int <em>base</em> = 10) const</td>
</tr>
<tr>
<td>QByteArray</td>
<td><strong><a href="QByteArray.md#toLower">toLower</a></strong>() const</td>
</tr>
<tr>
<td>NSData *</td>
<td><strong><a href="QByteArray.md#toNSData">toNSData</a></strong>() const</td>
</tr>
<tr>
<td>QByteArray</td>
<td><strong><a href="QByteArray.md#toPercentEncoding">toPercentEncoding</a></strong>(const QByteArray &amp;<em>exclude</em> = QByteArray(), const QByteArray &amp;<em>include</em> = QByteArray(), char <em>percent</em> = ‘%’) const</td>
</tr>
<tr>
<td>CFDataRef</td>
<td><strong><a href="QByteArray.md#toRawCFData">toRawCFData</a></strong>() const</td>
</tr>
<tr>
<td>NSData *</td>
<td><strong><a href="QByteArray.md#toRawNSData">toRawNSData</a></strong>() const</td>
</tr>
<tr>
<td>short</td>
<td><strong><a href="QByteArray.md#toShort">toShort</a></strong>(bool *<em>ok</em> = nullptr, int <em>base</em> = 10) const</td>
</tr>
<tr>
<td>std::string</td>
<td><strong><a href="QByteArray.md#toStdString">toStdString</a></strong>() const</td>
</tr>
<tr>
<td>uint</td>
<td><strong><a href="QByteArray.md#toUInt">toUInt</a></strong>(bool *<em>ok</em> = nullptr, int <em>base</em> = 10) const</td>
</tr>
<tr>
<td>ulong</td>
<td><strong><a href="QByteArray.md#toULong">toULong</a></strong>(bool *<em>ok</em> = nullptr, int <em>base</em> = 10) const</td>
</tr>
<tr>
<td>qulonglong</td>
<td><strong><a href="QByteArray.md#toULongLong">toULongLong</a></strong>(bool *<em>ok</em> = nullptr, int <em>base</em> = 10) const</td>
</tr>
<tr>
<td>ushort</td>
<td><strong><a href="QByteArray.md#toUShort">toUShort</a></strong>(bool *<em>ok</em> = nullptr, int <em>base</em> = 10) const</td>
</tr>
<tr>
<td>QByteArray</td>
<td><strong><a href="QByteArray.md#toUpper">toUpper</a></strong>() const</td>
</tr>
<tr>
<td>QByteArray</td>
<td><strong><a href="QByteArray.md#trimmed">trimmed</a></strong>() const</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="QByteArray.md#truncate">truncate</a></strong>(qsizetype <em>pos</em>)</td>
</tr>
<tr>
<td>const char *</td>
<td><strong><a href="QByteArray.md#operator-const-char--2a">operator const char *</a></strong>() const</td>
</tr>
<tr>
<td>const void *</td>
<td><strong><a href="QByteArray.md#operator-const-void--2a">operator const void *</a></strong>() const</td>
</tr>
<tr>
<td>bool</td>
<td><strong><a href="QByteArray.md#operator-not-eq">operator!=</a></strong>(const QString &amp;<em>str</em>) const</td>
</tr>
<tr>
<td>QByteArray &amp;</td>
<td><strong><a href="QByteArray.md#operator-2b-eq">operator+=</a></strong>(const QByteArray &amp;<em>ba</em>)</td>
</tr>
<tr>
<td>QByteArray &amp;</td>
<td><strong><a href="QByteArray.md#operator-2b-eq-1">operator+=</a></strong>(char <em>ch</em>)</td>
</tr>
<tr>
<td>QByteArray &amp;</td>
<td><strong><a href="QByteArray.md#operator-2b-eq-2">operator+=</a></strong>(const char *<em>str</em>)</td>
</tr>
<tr>
<td>bool</td>
<td><strong><a href="QByteArray.md#operator-lt">operator&lt;</a></strong>(const QString &amp;<em>str</em>) const</td>
</tr>
<tr>
<td>bool</td>
<td><strong><a href="QByteArray.md#operator-lt-eq">operator&lt;=</a></strong>(const QString &amp;<em>str</em>) const</td>
</tr>
<tr>
<td>QByteArray &amp;</td>
<td><strong><a href="QByteArray.md#operator-eq-1">operator=</a></strong>(const char *<em>str</em>)</td>
</tr>
<tr>
<td>bool</td>
<td><strong><a href="QByteArray.md#operator-eq-eq">operator==</a></strong>(const QString &amp;<em>str</em>) const</td>
</tr>
<tr>
<td>bool</td>
<td><strong><a href="QByteArray.md#operator-gt">operator&gt;</a></strong>(const QString &amp;<em>str</em>) const</td>
</tr>
<tr>
<td>bool</td>
<td><strong><a href="QByteArray.md#operator-gt-eq">operator&gt;=</a></strong>(const QString &amp;<em>str</em>) const</td>
</tr>
<tr>
<td>char &amp;</td>
<td><strong>[operator<a href="QByteArray.md#operator-5b-5d">]</a></strong>(qsizetype <em>i</em>)</td>
</tr>
<tr>
<td>char</td>
<td><strong>[operator<a href="QByteArray.md#operator-5b-5d-1">]</a></strong>(qsizetype <em>i</em>) const</td>
</tr>
</tbody></table>
<h2><span id="jing-tai-gong-gong-cheng-yuan">静态公共成员</span><a href="#jing-tai-gong-gong-cheng-yuan" class="header-anchor">#</a></h2><table>
<thead>
<tr>
<th>QByteArray</th>
<th><strong><a href="QByteArray.md#fromBase64">fromBase64</a></strong>(const QByteArray &amp;<em>base64</em>, QByteArray::Base64Options <em>options</em> = Base64Encoding)</th>
</tr>
</thead>
<tbody><tr>
<td>QByteArray::FromBase64Result</td>
<td><strong><a href="QByteArray.md#fromBase64Encoding">fromBase64Encoding</a></strong>(QByteArray &amp;&amp;<em>base64</em>, QByteArray::Base64Options <em>options</em> = Base64Encoding)</td>
</tr>
<tr>
<td>QByteArray::FromBase64Result</td>
<td><strong><a href="QByteArray.md#fromBase64Encoding-1">fromBase64Encoding</a></strong>(const QByteArray &amp;<em>base64</em>, QByteArray::Base64Options <em>options</em> = Base64Encoding)</td>
</tr>
<tr>
<td>QByteArray</td>
<td><strong><a href="QByteArray.md#fromCFData">fromCFData</a></strong>(CFDataRef <em>data</em>)</td>
</tr>
<tr>
<td>QByteArray</td>
<td><strong><a href="QByteArray.md#fromHex">fromHex</a></strong>(const QByteArray &amp;<em>hexEncoded</em>)</td>
</tr>
<tr>
<td>QByteArray</td>
<td><strong><a href="QByteArray.md#fromNSData">fromNSData</a></strong>(const NSData *<em>data</em>)</td>
</tr>
<tr>
<td>QByteArray</td>
<td><strong><a href="QByteArray.md#fromPercentEncoding">fromPercentEncoding</a></strong>(const QByteArray &amp;<em>input</em>, char <em>percent</em> = ‘%’)</td>
</tr>
<tr>
<td>QByteArray</td>
<td><strong><a href="QByteArray.md#fromRawCFData">fromRawCFData</a></strong>(CFDataRef <em>data</em>)</td>
</tr>
<tr>
<td>QByteArray</td>
<td><strong><a href="QByteArray.md#fromRawData">fromRawData</a></strong>(const char *<em>data</em>, qsizetype <em>size</em>)</td>
</tr>
<tr>
<td>QByteArray</td>
<td><strong><a href="QByteArray.md#fromRawNSData">fromRawNSData</a></strong>(const NSData *<em>data</em>)</td>
</tr>
<tr>
<td>QByteArray</td>
<td><strong><a href="QByteArray.md#fromStdString">fromStdString</a></strong>(const std::string &amp;<em>str</em>)</td>
</tr>
<tr>
<td>QByteArray</td>
<td><strong><a href="QByteArray.md#number">number</a></strong>(int <em>n</em>, int <em>base</em> = 10)</td>
</tr>
<tr>
<td>QByteArray</td>
<td><strong><a href="QByteArray.md#number-1">number</a></strong>(uint <em>n</em>, int <em>base</em> = 10)</td>
</tr>
<tr>
<td>QByteArray</td>
<td><strong><a href="QByteArray.md#number-2">number</a></strong>(long <em>n</em>, int <em>base</em> = 10)</td>
</tr>
<tr>
<td>QByteArray</td>
<td><strong><a href="QByteArray.md#number-3">number</a></strong>(ulong <em>n</em>, int <em>base</em> = 10)</td>
</tr>
<tr>
<td>QByteArray</td>
<td><strong><a href="QByteArray.md#number-4">number</a></strong>(qlonglong <em>n</em>, int <em>base</em> = 10)</td>
</tr>
<tr>
<td>QByteArray</td>
<td><strong><a href="QByteArray.md#number-5">number</a></strong>(qulonglong <em>n</em>, int <em>base</em> = 10)</td>
</tr>
<tr>
<td>QByteArray</td>
<td><strong><a href="QByteArray.md#number-6">number</a></strong>(double <em>n</em>, char <em>format</em> = ‘g’, int <em>precision</em> = 6)</td>
</tr>
</tbody></table>
<h2><span id="xiang-guan-fei-hui-yuan">相关非会员</span><a href="#xiang-guan-fei-hui-yuan" class="header-anchor">#</a></h2><table>
<thead>
<tr>
<th>qsizetype</th>
<th><strong><a href="QByteArray.md#erase-1">erase</a></strong>(QByteArray &amp;<em>ba</em>, const T &amp;<em>t</em>)</th>
</tr>
</thead>
<tbody><tr>
<td>qsizetype</td>
<td><strong><a href="QByteArray.md#erase_if">erase_if</a></strong>(QByteArray &amp;<em>ba</em>, Predicate <em>pred</em>)</td>
</tr>
<tr>
<td>quint16</td>
<td><strong><a href="QByteArray.md#qChecksum">qChecksum</a></strong>(QByteArrayView <em>data</em>, Qt::ChecksumType <em>standard</em> = Qt::ChecksumIso3309)</td>
</tr>
<tr>
<td>QByteArray</td>
<td><strong><a href="QByteArray.md#qCompress">qCompress</a></strong>(const QByteArray &amp;<em>data</em>, int <em>compressionLevel</em> = -1)</td>
</tr>
<tr>
<td>QByteArray</td>
<td><strong><a href="QByteArray.md#qCompress-1">qCompress</a></strong>(const uchar *<em>data</em>, qsizetype <em>nbytes</em>, int <em>compressionLevel</em> = -1)</td>
</tr>
<tr>
<td>QByteArray</td>
<td><strong><a href="QByteArray.md#qUncompress-1">qUncompress</a></strong>(const QByteArray &amp;<em>data</em>)</td>
</tr>
<tr>
<td>QByteArray</td>
<td><strong><a href="QByteArray.md#qUncompress-2">qUncompress</a></strong>(const uchar *<em>data</em>, qsizetype <em>nbytes</em>)</td>
</tr>
<tr>
<td>int</td>
<td><strong><a href="QByteArray.md#qsnprintf">qsnprintf</a></strong>(char *<em>str</em>, size_t <em>n</em>, const char *<em>fmt</em>, …)</td>
</tr>
<tr>
<td>int</td>
<td><strong><a href="QByteArray.md#qstrcmp">qstrcmp</a></strong>(const char *<em>str1</em>, const char *<em>str2</em>)</td>
</tr>
<tr>
<td>char *</td>
<td><strong><a href="QByteArray.md#qstrcpy">qstrcpy</a></strong>(char *<em>dst</em>, const char *<em>src</em>)</td>
</tr>
<tr>
<td>char *</td>
<td><strong><a href="QByteArray.md#qstrdup">qstrdup</a></strong>(const char *<em>src</em>)</td>
</tr>
<tr>
<td>int</td>
<td><strong><a href="QByteArray.md#qstricmp">qstricmp</a></strong>(const char *<em>str1</em>, const char *<em>str2</em>)</td>
</tr>
<tr>
<td>size_t</td>
<td><strong><a href="QByteArray.md#qstrlen">qstrlen</a></strong>(const char *<em>str</em>)</td>
</tr>
<tr>
<td>int</td>
<td><strong><a href="QByteArray.md#qstrncmp">qstrncmp</a></strong>(const char *<em>str1</em>, const char *<em>str2</em>, size_t <em>len</em>)</td>
</tr>
<tr>
<td>char *</td>
<td><strong><a href="QByteArray.md#qstrncpy">qstrncpy</a></strong>(char *<em>dst</em>, const char *<em>src</em>, size_t <em>len</em>)</td>
</tr>
<tr>
<td>int</td>
<td><strong><a href="QByteArray.md#qstrnicmp">qstrnicmp</a></strong>(const char *<em>str1</em>, const char *<em>str2</em>, size_t <em>len</em>)</td>
</tr>
<tr>
<td>size_t</td>
<td><strong><a href="QByteArray.md#qstrnlen">qstrnlen</a></strong>(const char *<em>str</em>, size_t <em>maxlen</em>)</td>
</tr>
<tr>
<td>int</td>
<td><strong><a href="QByteArray.md#qvsnprintf">qvsnprintf</a></strong>(char *<em>str</em>, size_t <em>n</em>, const char *<em>fmt</em>, va_list <em>ap</em>)</td>
</tr>
<tr>
<td>bool</td>
<td><strong><a href="QByteArray.md#operator-not-eq-1">operator!=</a></strong>(const QByteArray &amp;<em>a1</em>, const QByteArray &amp;<em>a2</em>)</td>
</tr>
<tr>
<td>bool</td>
<td><strong><a href="QByteArray.md#operator-not-eq-2">operator!=</a></strong>(const QByteArray &amp;<em>a1</em>, const char *<em>a2</em>)</td>
</tr>
<tr>
<td>bool</td>
<td><strong><a href="QByteArray.md#operator-not-eq-3">operator!=</a></strong>(const char *<em>a1</em>, const QByteArray &amp;<em>a2</em>)</td>
</tr>
<tr>
<td>QByteArray</td>
<td><strong><a href="QByteArray.md#operator-22-22_qba">operator””_qba</a></strong>(const char *<em>str</em>, size_t <em>size</em>)</td>
</tr>
<tr>
<td>const QByteArray</td>
<td><strong><a href="QByteArray.md#operator-2b">operator+</a></strong>(const QByteArray &amp;<em>a1</em>, const QByteArray &amp;<em>a2</em>)</td>
</tr>
<tr>
<td>const QByteArray</td>
<td><strong><a href="QByteArray.md#operator-2b-1">operator+</a></strong>(const QByteArray &amp;<em>a1</em>, const char *<em>a2</em>)</td>
</tr>
<tr>
<td>const QByteArray</td>
<td><strong><a href="QByteArray.md#operator-2b-2">operator+</a></strong>(const QByteArray &amp;<em>a1</em>, char <em>a2</em>)</td>
</tr>
<tr>
<td>const QByteArray</td>
<td><strong><a href="QByteArray.md#operator-2b-3">operator+</a></strong>(const char *<em>a1</em>, const QByteArray &amp;<em>a2</em>)</td>
</tr>
<tr>
<td>const QByteArray</td>
<td><strong><a href="QByteArray.md#operator-2b-4">operator+</a></strong>(char <em>a1</em>, const QByteArray &amp;<em>a2</em>)</td>
</tr>
<tr>
<td>bool</td>
<td><strong><a href="QByteArray.md#operator-lt-1">operator&lt;</a></strong>(const QByteArray &amp;<em>a1</em>, const QByteArray &amp;<em>a2</em>)</td>
</tr>
<tr>
<td>bool</td>
<td><strong><a href="QByteArray.md#operator-lt-2">operator&lt;</a></strong>(const QByteArray &amp;<em>a1</em>, const char *<em>a2</em>)</td>
</tr>
<tr>
<td>bool</td>
<td><strong><a href="QByteArray.md#operator-lt-3">operator&lt;</a></strong>(const char *<em>a1</em>, const QByteArray &amp;<em>a2</em>)</td>
</tr>
<tr>
<td>QDataStream &amp;</td>
<td><strong><a href="QByteArray.md#operator-lt-lt">operator&lt;&lt;</a></strong>(QDataStream &amp;<em>out</em>, const QByteArray &amp;<em>ba</em>)</td>
</tr>
<tr>
<td>bool</td>
<td><strong><a href="QByteArray.md#operator-lt-eq-1">operator&lt;=</a></strong>(const QByteArray &amp;<em>a1</em>, const QByteArray &amp;<em>a2</em>)</td>
</tr>
<tr>
<td>bool</td>
<td><strong><a href="QByteArray.md#operator-lt-eq-2">operator&lt;=</a></strong>(const QByteArray &amp;<em>a1</em>, const char *<em>a2</em>)</td>
</tr>
<tr>
<td>bool</td>
<td><strong><a href="QByteArray.md#operator-lt-eq-3">operator&lt;=</a></strong>(const char *<em>a1</em>, const QByteArray &amp;<em>a2</em>)</td>
</tr>
<tr>
<td>bool</td>
<td><strong><a href="QByteArray.md#operator-eq-eq-1">operator==</a></strong>(const QByteArray &amp;<em>a1</em>, const QByteArray &amp;<em>a2</em>)</td>
</tr>
<tr>
<td>bool</td>
<td><strong><a href="QByteArray.md#operator-eq-eq-2">operator==</a></strong>(const QByteArray &amp;<em>a1</em>, const char *<em>a2</em>)</td>
</tr>
<tr>
<td>bool</td>
<td><strong><a href="QByteArray.md#operator-eq-eq-3">operator==</a></strong>(const char *<em>a1</em>, const QByteArray &amp;<em>a2</em>)</td>
</tr>
<tr>
<td>bool</td>
<td><strong><a href="QByteArray.md#operator-gt-1">operator&gt;</a></strong>(const QByteArray &amp;<em>a1</em>, const QByteArray &amp;<em>a2</em>)</td>
</tr>
<tr>
<td>bool</td>
<td><strong><a href="QByteArray.md#operator-gt-2">operator&gt;</a></strong>(const QByteArray &amp;<em>a1</em>, const char *<em>a2</em>)</td>
</tr>
<tr>
<td>bool</td>
<td><strong><a href="QByteArray.md#operator-gt-3">operator&gt;</a></strong>(const char *<em>a1</em>, const QByteArray &amp;<em>a2</em>)</td>
</tr>
<tr>
<td>bool</td>
<td><strong><a href="QByteArray.md#operator-gt-eq-1">operator&gt;=</a></strong>(const QByteArray &amp;<em>a1</em>, const QByteArray &amp;<em>a2</em>)</td>
</tr>
<tr>
<td>bool</td>
<td><strong><a href="QByteArray.md#operator-gt-eq-2">operator&gt;=</a></strong>(const QByteArray &amp;<em>a1</em>, const char *<em>a2</em>)</td>
</tr>
<tr>
<td>bool</td>
<td><strong><a href="QByteArray.md#operator-gt-eq-3">operator&gt;=</a></strong>(const char *<em>a1</em>, const QByteArray &amp;<em>a2</em>)</td>
</tr>
<tr>
<td>QDataStream &amp;</td>
<td><strong><a href="QByteArray.md#operator-gt-gt">operator&gt;&gt;</a></strong>(QDataStream &amp;<em>in</em>, QByteArray &amp;<em>ba</em>)</td>
</tr>
</tbody></table>
<h2><span id="hong">宏</span><a href="#hong" class="header-anchor">#</a></h2><table>
<thead>
<tr>
<th></th>
<th><strong><a href="QByteArray.md#QByteArrayLiteral">QByteArrayLiteral</a></strong>(<em>ba</em>)</th>
</tr>
</thead>
<tbody><tr>
<td></td>
<td><strong><a href="QByteArray.md#QT_NO_CAST_FROM_BYTEARRAY">QT_NO_CAST_FROM_BYTEARRAY</a></strong></td>
</tr>
</tbody></table>
<h2><span id="xiang-xi-shuo-ming">详细说明</span><a href="#xiang-xi-shuo-ming" class="header-anchor">#</a></h2><p>QByteArray 可用于存储原始字节（包括<code>\0”）和传统的 8 位</code>\0”结尾的字符串。使用 QByteArray 比使用 <code>const char *</code> 方便得多。在幕后，它始终确保数据后跟一个 ‘\0’ 终止符，并使用 <a target="_blank" rel="noopener" href="https://doc.qt.io/qt-6/implicit-sharing.html">隐式共享</a> (copy- on-write）以减少内存使用并避免不必要的数据复制。</p>
<p>除了 QByteArray，Qt 还提供了 <a target="_blank" rel="noopener" href="https://doc.qt.io/qt-6/qstring.html">QString</a> 类来存储字符串数据。对于大多数用途，<a target="_blank" rel="noopener" href="https://doc.qt.io/qt-6/qstring.html">QString</a> 是您要使用的类。它将其内容理解为 Unicode 文本（使用 UTF-16 编码），其中 QByteArray 旨在避免对其存储的字节的编码或语义进行假设（除了一些使用 ASCII 的遗留案例）。此外，<a target="_blank" rel="noopener" href="https://doc.qt.io/qt-6/qstring.html">QString</a> 在整个 Qt API 中使用。 QByteArray 适用的两种主要情况是，当您需要存储原始二进制数据时，以及当内存保护至关重要时（例如，使用 Qt for Embedded Linux）。</p>
<p>初始化 QByteArray 的一种方法是简单地将 <code>const char *</code> 传递给它的构造函数。例如，以下代码创建一个大小为 5 的字节数组，其中包含数据“Hello”：</p>
<div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-function">QByteArray <span class="hljs-title">ba</span><span class="hljs-params">(<span class="hljs-string">"Hello"</span>)</span></span>;</code></pre></div>

<p>虽然 <a href="QByteArray.md#size">size</a>() 是 5，但字节数组还在末尾保留了一个额外的 ‘\0’ 字节，这样如果使用函数来请求指向底层数据的指针（例如调用 <a href="QByteArray.md#data">data</a>()），指向的数据是保证以 ‘\0’ 结尾。</p>
<p>QByteArray 对 <code>const char *</code> 数据进行了深层复制，因此您可以稍后对其进行修改而不会产生副作用。 （如果出于性能原因，您不想获取数据的深层副本，请使用 <a href="QByteArray.md#fromRawData">QByteArray::fromRawData</a>() 反而。）</p>
<p>另一种方法是使用 <a href="QByteArray.md#resize">resize</a>() 设置数组的大小并逐字节初始化数据。 QByteArray 使用从 0 开始的索引，就像 C++ 数组一样。要访问特定索引位置的字节，可以使用 operator<a href></a>。在非常量字节数组上，operator<a href></a> 返回对可以在赋值左侧使用的字节的引用。例如：</p>
<div class="code-wrapper"><pre><code class="hljs c++">QByteArray ba;
ba.<span class="hljs-built_in">resize</span>(<span class="hljs-number">5</span>);
ba[<span class="hljs-number">0</span>] = <span class="hljs-number">0x3c</span>;
ba[<span class="hljs-number">1</span>] = <span class="hljs-number">0xb8</span>;
ba[<span class="hljs-number">2</span>] = <span class="hljs-number">0x64</span>;
ba[<span class="hljs-number">3</span>] = <span class="hljs-number">0x18</span>;
ba[<span class="hljs-number">4</span>] = <span class="hljs-number">0xca</span>;</code></pre></div>

<p>对于只读访问，另一种语法是使用 <a href="QByteArray.md#at">at</a>()：</p>
<div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">for</span> (qsizetype i = <span class="hljs-number">0</span>; i &lt; ba.<span class="hljs-built_in">size</span>(); ++i) {
    <span class="hljs-keyword">if</span> (ba.<span class="hljs-built_in">at</span>(i) &gt;= <span class="hljs-string">'a'</span> &amp;&amp; ba.<span class="hljs-built_in">at</span>(i) &lt;= <span class="hljs-string">'f'</span>)
        cout &lt;&lt; <span class="hljs-string">"Found character in range [a-f]"</span> &lt;&lt; Qt::endl;
}</code></pre></div>

<p>at](QByteArray.md#at)() 可以比 operator<a href></a> 更快，因为它永远不会导致 [deep copy](<a target="_blank" rel="noopener" href="https://doc/">https://doc</a> .qt.io/qt-6/implicit-sharing.html#deep-copy) 发生。</p>
<p>要一次提取多个字节，请使用 <a href="QByteArray.md#first">first</a>(), [last](<a target="_blank" rel="noopener" href="https://doc.qt.io/">https://doc.qt.io/</a> qt-6/qbytearray.html#last)()，或<a href="QByteArray.md#sliced">切片</a>()。</p>
<p>QByteArray 可以嵌入 ‘\0’ 字节。 <a href="QByteArray.md#size">size</a>() 函数总是返回整个数组的大小，包括嵌入的 ‘\0’ 字节，但不包括终止的 ‘ \0’ 由 QByteArray 添加。</p>
<p> 例如：</p>
<div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-function">QByteArray <span class="hljs-title">ba1</span><span class="hljs-params">(<span class="hljs-string">"ca\0r\0t"</span>)</span></span>;
ba1.<span class="hljs-built_in">size</span>();                     <span class="hljs-comment">// Returns 2.</span>
ba1.<span class="hljs-built_in">constData</span>();                <span class="hljs-comment">// Returns "ca" with terminating \0.</span>

<span class="hljs-function">QByteArray <span class="hljs-title">ba2</span><span class="hljs-params">(<span class="hljs-string">"ca\0r\0t"</span>, <span class="hljs-number">3</span>)</span></span>;
ba2.<span class="hljs-built_in">size</span>();                     <span class="hljs-comment">// Returns 3.</span>
ba2.<span class="hljs-built_in">constData</span>();                <span class="hljs-comment">// Returns "ca\0" with terminating \0.</span>

<span class="hljs-function">QByteArray <span class="hljs-title">ba3</span><span class="hljs-params">(<span class="hljs-string">"ca\0r\0t"</span>, <span class="hljs-number">4</span>)</span></span>;
ba3.<span class="hljs-built_in">size</span>();                     <span class="hljs-comment">// Returns 4.</span>
ba3.<span class="hljs-built_in">constData</span>();                <span class="hljs-comment">// Returns "ca\0r" with terminating \0.</span>

<span class="hljs-type">const</span> <span class="hljs-type">char</span> cart[] = {<span class="hljs-string">'c'</span>, <span class="hljs-string">'a'</span>, <span class="hljs-string">'\0'</span>, <span class="hljs-string">'r'</span>, <span class="hljs-string">'\0'</span>, <span class="hljs-string">'t'</span>};
<span class="hljs-function">QByteArray <span class="hljs-title">ba4</span><span class="hljs-params">(QByteArray::fromRawData(cart, <span class="hljs-number">6</span>))</span></span>;
ba4.<span class="hljs-built_in">size</span>();                     <span class="hljs-comment">// Returns 6.</span>
ba4.<span class="hljs-built_in">constData</span>();                <span class="hljs-comment">// Returns "ca\0r\0t" without terminating \0.</span></code></pre></div>

<p>如果要获取数据的长度，不包括第一个 ‘\0’ 字节，请调用 <a href="QByteArray.md#qstrlen">qstrlen</a>() on字节数组。</p>
<p>调用 <a href="QByteArray.md#resize">resize</a>() 后，新分配的字节具有未定义的值。要将所有字节设置为特定值，请调用 <a href="QByteArray.md#fill">fill</a>()。</p>
<p>要获取指向实际字节的指针，请调用 <a href="QByteArray.md#data">data</a>() 或 [constData](<a target="_blank" rel="noopener" href="https://doc.qt.io/">https://doc.qt.io</a> /qt-6/qbytearray.html#constData)()。这些函数返回一个指向数据开头的指针。在 QByteArray 上调用非常量函数之前，指针保证保持有效。除非 QByteArray 是从 [原始数据] (QByteArray.md#fromRawData) 创建的，否则还保证数据以 ‘\0’ 字节结尾。这个 ‘\0’ 字节由 QByteArray 自动提供，不计入 <a href="QByteArray.md#size">size</a>()。</p>
<p>QByteArray 提供了以下修改字节数据的基本函数：<a href="QByteArray.md#append">append</a>()、<a href="QByteArray.md#prepend">prepend</a>(), <a href="QByteArray.md#insert">插入</a>(), [替换](https:// /doc.qt.io/qt-6/qbytearray.html#replace)() 和 <a href="QByteArray.md#remove">删除</a>()。</p>
<p>例如：</p>
<div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-function">QByteArray <span class="hljs-title">x</span><span class="hljs-params">(<span class="hljs-string">"and"</span>)</span></span>;
x.<span class="hljs-built_in">prepend</span>(<span class="hljs-string">"rock "</span>);         <span class="hljs-comment">// x == "rock and"</span>
x.<span class="hljs-built_in">append</span>(<span class="hljs-string">" roll"</span>);          <span class="hljs-comment">// x == "rock and roll"</span>
x.<span class="hljs-built_in">replace</span>(<span class="hljs-number">5</span>, <span class="hljs-number">3</span>, <span class="hljs-string">"&amp;"</span>);       <span class="hljs-comment">// x == "rock &amp; roll"</span></code></pre></div>

<p>在上面的例子中，<a href="QByteArray.md#replace">replace</a>() 函数的前两个参数是开始替换的位置和应该替换的字节数被替换。</p>
<p>当数据修改函数增加数组的大小时，它们可能会导致为 QByteArray 对象重新分配内存。发生这种情况时，QByteArray 会扩展超过它立即需要的数量，以便有空间进行进一步扩展而无需重新分配，直到数组的大小大大增加。</p>
<p><a href="QByteArray.md#insert">插入</a>()、[删除](QByteArray.md# remove)() 并且，当用不同大小之一替换子数组时，<a href="QByteArray.md#replace">replace</a>() 函数可能会很慢（<a target="_blank" rel="noopener" href="https://doc.qt.io/qt-6/containers.html#linear-time">线性时间</a>) 用于大型数组，因为它们需要将数组中的许多字节移动至少一个内存位置。</p>
<p>如果您正在逐步构建 QByteArray 并提前知道 QByteArray 将包含多少字节，您可以调用 <a href="QByteArray.md#reserve">reserve</a>()，要求 QByteArray 预先分配一定数量的内存。您还可以调用 <a href="QByteArray.md#capacity">容量</a>() 来了解 QByteArray 实际分配了多少内存。</p>
<p>请注意，由于 <a target="_blank" rel="noopener" href="https://doc.qt.io/qt-6/implicit-sharing.html">隐式共享</a>，使用非常量运算符和函数可能会导致 QByteArray 对数据进行深层复制。</p>
<p>QByteArray 提供 <a target="_blank" rel="noopener" href="https://doc.qt.io/qt-6/containers.html#stl-style-iterators">STL 风格的迭代器</a> ([QByteArray::const_iterator](<a target="_blank" rel="noopener" href="https://doc.qt.io/">https://doc.qt.io</a> /qt-6/qbytearray.html#const_iterator-typedef) 和 <a href="QByteArray.md#iterator-typedef">QByteArray::iterator</a>)。在实践中，迭代器在使用 C++ 标准库提供的通用算法时非常方便。</p>
<p><strong>注意：</strong> 迭代器和对单个 QByteArray 元素的引用会受到稳定性问题的影响。它们通常在修改 QByteArray 的操作（例如 <a href="QByteArray.md#insert">insert</a>() 或 <a href="QByteArray.md#remove">remove</a>()) 被调用。当需要稳定性和类似迭代器的功能时，您应该使用索引而不是迭代器，因为它们与 QByteArray 的内部状态无关，因此不会失效。</p>
<p><strong>注意：</strong> 在调用 QByteArray 的任何非常量方法时，不能依赖 QByteArray 上的迭代器以及对单个字节中的单个字节的引用来保持有效。在调用非常量方法之后访问这样的迭代器或引用会导致未定义的行为。当需要类似迭代器的功能稳定性时，您应该使用索引而不是迭代器，因为它们与 QByteArray 的内部状态无关，因此不会失效。</p>
<p>如果要查找 QByteArray 中特定字节或字节序列的所有出现，请使用 <a href="QByteArray.md#indexOf">indexOf</a>() 或 <a href="QByteArray.md#lastIndexOf">lastIndexOf</a>()。前者从给定的索引位置开始向前搜索，后者向后搜索。如果找到它，两者都返回字节序列的索引位置；否则，它们返回 -1。例如，这是一个典型的循环，用于查找特定字符串的所有出现：</p>
<div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-function">QByteArray <span class="hljs-title">ba</span><span class="hljs-params">(<span class="hljs-string">"We must be &lt;b&gt;bold&lt;/b&gt;, very &lt;b&gt;bold&lt;/b&gt;"</span>)</span></span>;
qsizetype j = <span class="hljs-number">0</span>;
<span class="hljs-keyword">while</span> ((j = ba.<span class="hljs-built_in">indexOf</span>(<span class="hljs-string">"&lt;b&gt;"</span>, j)) != <span class="hljs-number">-1</span>) {
    cout &lt;&lt; <span class="hljs-string">"Found &lt;b&gt; tag at index position "</span> &lt;&lt; j &lt;&lt; Qt::endl;
    ++j;
}</code></pre></div>

<p>如果您只是想检查 QByteArray 是否包含特定的字节序列，请使用 <a href="QByteArray.md#contains">contains</a>()。如果您想了解特定字节序列在字节数组中出现的次数，请使用 <a href="QByteArray.md#count-2">count</a>()。如果您想用另一个替换所有出现的特定值，请使用两个参数 <a href="QByteArray.md#replace">replace</a>() 重载之一。</p>
<p><a href="QByteArray.md">QByteArray</a>s可以使用operator&lt;(), operator&lt;=(), operator==(), operator&gt;等重载运算符进行比较=() 等等。比较完全基于字节的数值，速度非常快，但不是人类所期望的。 <a target="_blank" rel="noopener" href="https://doc.qt.io/qt-6/qstring.html#localeAwareCompare">QString::localeAwareCompare</a>() 是对用户界面字符串进行排序的更好选择。</p>
<p>由于历史原因，QByteArray 区分了空字节数组和空字节数组。 <em>null</em> 字节数组是使用 QByteArray 的默认构造函数或通过将 (const char *)0 传递给构造函数来初始化的字节数组。 <em>empty</em> 字节数组是大小为 0 的任何字节数组。空字节数组始终为空，但空字节数组不一定为空：</p>
<div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-built_in">QByteArray</span>().<span class="hljs-built_in">isNull</span>();          <span class="hljs-comment">// returns true</span>
<span class="hljs-built_in">QByteArray</span>().<span class="hljs-built_in">isEmpty</span>();         <span class="hljs-comment">// returns true</span>

<span class="hljs-built_in">QByteArray</span>(<span class="hljs-string">""</span>).<span class="hljs-built_in">isNull</span>();        <span class="hljs-comment">// returns false</span>
<span class="hljs-built_in">QByteArray</span>(<span class="hljs-string">""</span>).<span class="hljs-built_in">isEmpty</span>();       <span class="hljs-comment">// returns true</span>

<span class="hljs-built_in">QByteArray</span>(<span class="hljs-string">"abc"</span>).<span class="hljs-built_in">isNull</span>();     <span class="hljs-comment">// returns false</span>
<span class="hljs-built_in">QByteArray</span>(<span class="hljs-string">"abc"</span>).<span class="hljs-built_in">isEmpty</span>();    <span class="hljs-comment">// returns false</span></code></pre></div>

<p>除了 <a href="QByteArray.md#isNull">isNull</a>() 之外的所有函数都将空字节数组视为空字节数组。 例如，<a href="QByteArray.md#data">data</a>() 返回一个有效指针 (<em>not</em> nullptr) 指向一个空字节的 ‘\0’ 字节 数组和 QByteArray() 比较等于 QByteArray(“”)。 我们建议您始终使用 <a href="QByteArray.md#isEmpty">isEmpty</a>() 并避免使用 [isNull](<a target="_blank" rel="noopener" href="https://doc.qt.io/qt-">https://doc.qt.io/qt-</a> 6/qbytearray.html#isNull)()。</p>
<h3><span id="zui-da-da-xiao-he-nei-cun-bu-zu-qing-kuang">最大大小和内存不足情况</span><a href="#zui-da-da-xiao-he-nei-cun-bu-zu-qing-kuang" class="header-anchor">#</a></h3><p>QByteArray 的最大大小取决于架构。大多数 64 位系统可以分配超过 2 GB 的内存，典型限制为 2^63 字节。实际值还取决于管理数据块所需的开销。因此，您可以预期最大大小为 2 GB 减去 32 位平台上的开销，以及 2^63 字节减去 64 位平台上的开销。可以存储在 QByteArray 中的元素数量就是这个最大大小。</p>
<p>当内存分配失败时，如果正在使用异常支持编译应用程序，QByteArray 会抛出一个 <code>std::bad_alloc</code> 异常。 Qt 容器中内存不足的情况是 Qt 抛出异常的唯一情况。如果异常被禁用，则内存不足是未定义的行为。</p>
<p>请注意，操作系统可能会对持有大量已分配内存的应用程序施加进一步的限制，尤其是大的连续块。此类考虑、此类行为的配置或任何缓解措施都超出了 QByteArray API 的范围。</p>
<h3><span id="c-yu-yan-huan-jing-he-ascii-han-shu">C 语言环境和 ASCII 函数</span><a href="#c-yu-yan-huan-jing-he-ascii-han-shu" class="header-anchor">#</a></h3><p>QByteArray 通常将数据作为字节处理，不假定任何语义； 在它假定语义的地方，它使用 C 语言环境和 ASCII 编码。 <a target="_blank" rel="noopener" href="https://doc.qt.io/qt-6/qstring.html">QString</a> 支持标准 Unicode 编码，使用 <a target="_blank" rel="noopener" href="https://doc.qt.io/qt">QStringEncoder</a> 可能支持其他编码 -6/qstringencoder.html) 和 <a target="_blank" rel="noopener" href="https://doc.qt.io/qt-6/qstringdecoder.html">QStringDecoder</a> 转换为 Unicode。 对于特定于语言环境的文本解释，请使用 <a target="_blank" rel="noopener" href="https://doc.qt.io/qt-6/qlocale.html">QLocale</a> 或 [QString](<a target="_blank" rel="noopener" href="https://doc.qt.io/qt-6/">https://doc.qt.io/qt-6/</a> qstring.html)。</p>
<h4><span id="c-zi-fu-chuan">C 字符串</span><a href="#c-zi-fu-chuan" class="header-anchor">#</a></h4><p>传统的 C 字符串，也称为以 ‘\0’ 结尾的字符串，是字节序列，由起点指定并隐式包括每个字节，直到但不包括其后的第一个 ‘\0’ 字节。接受这样一个没有长度的指针的方法将把它解释为这个字节序列。通过构造，这样的序列不能包含`\0”字节。</p>
<p>其他重载接受起始指针和字节数；它们使用给定的字节数，跟在起始地址之后，不管它们中的任何一个是否恰好是 ‘\0’ 字节。在某些情况下，如果没有仅采用指针的重载，则传递 -1 的长度将导致该方法使用指针后第一个 ‘\0’ 字节的偏移量作为长度；只有在方法明确说明它这样做时才应该传递 -1 的长度（在这种情况下，它通常是默认参数）。</p>
<h4><span id="jian-ju-zi-fu">间距字符</span><a href="#jian-ju-zi-fu" class="header-anchor">#</a></h4><p>一个常见的要求是从字节数组中删除空格字符（<code>'\n'</code>、<code>'\t'</code>、<code>''</code>等）。如果要删除 QByteArray 两端的间距，请使用 <a href="QByteArray.md#trimmed">trimmed</a>()。如果您还想用字节数组中的单个空格字符替换每次运行的空格字符，请使用 <a href="QByteArray.md#simplified">simplified</a>()。出于这些目的，仅识别 ASCII 空格字符。</p>
<h4><span id="shu-zi-zi-fu-chuan-zhuan-huan">数字字符串转换</span><a href="#shu-zi-zi-fu-chuan-zhuan-huan" class="header-anchor">#</a></h4><p>执行数字数据类型和字符串表示之间转换的函数在 C 语言环境中执行，而与用户的语言环境设置无关。使用 <a target="_blank" rel="noopener" href="https://doc.qt.io/qt-6/qlocale.html">QLocale</a> 在数字和字符串之间执行区域感知转换。</p>
<h4><span id="zi-fu-da-xiao-xie">字符大小写</span><a href="#zi-fu-da-xiao-xie" class="header-anchor">#</a></h4><p>在 QByteArray 中，大小写和大小写无关比较的概念仅限于 ASCII。非 ASCII 字符被视为无大小写，因为它们的大小写取决于编码。这会影响支持不区分大小写选项或更改其参数大小写的函数。受此影响的函数包括 <a href="QByteArray.md#contains">contains</a>()、[indexOf](<a target="_blank" rel="noopener" href="https://doc.qt.io/qt-6/">https://doc.qt.io/qt-6/</a> qbytearray.html#indexOf)(), <a href="QByteArray.md#lastIndexOf">lastIndexOf</a>(), [isLower](<a target="_blank" rel="noopener" href="https://doc.qt.io/">https://doc.qt.io/</a> qt-6/qbytearray.html#isLower)(), <a href="QByteArray.md#isUpper">isUpper</a>(), [toLower](<a target="_blank" rel="noopener" href="https://doc/">https://doc</a>. qt.io/qt-6/qbytearray.html#toLower)() 和 <a href="QByteArray.md#toUpper">toUpper</a>()。</p>
<p>此问题不适用于 <a target="_blank" rel="noopener" href="https://doc.qt.io/qt-6/qstring.html">QString</a>，因为它们使用 Unicode 表示字符。</p>
<p><strong>另见</strong> <a target="_blank" rel="noopener" href="https://doc.qt.io/qt-6/qbytearrayview.html">QByteArrayView</a>、<a target="_blank" rel="noopener" href="https://doc.qt.io/qt-6/qstring.html">QString</a> 和 <a target="_blank" rel="noopener" href="https://doc.qt.io/qt-6/qbitarray.html">QBitArray</a>。</p>
<h2><span id="hui-yuan-lei-xing-wen-dang">会员类型文档</span><a href="#hui-yuan-lei-xing-wen-dang" class="header-anchor">#</a></h2><h3><span id="since-5-2-enum-qbytearray-base64option-flags-qbytearray-base64options"><code>[since 5.2]</code>enum QByteArray::Base64Option flags QByteArray::Base64Options</span><a href="#since-5-2-enum-qbytearray-base64option-flags-qbytearray-base64options" class="header-anchor">#</a></h3><p>此枚举包含可用于编码和解码 Base64 的选项。 Base64 由 <a target="_blank" rel="noopener" href="https://datatracker.ietf.org/doc/html/rfc4648">RFC 4648</a> 定义，具有以下选项：</p>
<table>
<thead>
<tr>
<th>Constant</th>
<th>Value</th>
<th>Description</th>
</tr>
</thead>
<tbody><tr>
<td><code>QByteArray::Base64Encoding</code></td>
<td><code>0</code></td>
<td>（默认）常规 Base64 字母表，简称为“base64”</td>
</tr>
<tr>
<td><code>QByteArray::Base64UrlEncoding</code></td>
<td><code>1</code></td>
<td>一种替代字母表，称为“base64url”，它替换字母表中的两个字符以对 URL 更友好。</td>
</tr>
<tr>
<td><code>QByteArray::KeepTrailingEquals</code></td>
<td><code>0</code></td>
<td>（默认）在编码数据的末尾保留尾随填充等号，因此数据的大小始终是四的倍数。</td>
</tr>
<tr>
<td><code>QByteArray::OmitTrailingEquals</code></td>
<td><code>2</code></td>
<td>省略在编码数据末尾添加填充等号。</td>
</tr>
<tr>
<td><code>QByteArray::IgnoreBase64DecodingErrors</code></td>
<td><code>0</code></td>
<td>解码 Base64 编码的数据时，忽略输入中的错误；无效字符被简单地跳过。此枚举值已在 Qt 5.15 中添加。</td>
</tr>
<tr>
<td><code>QByteArray::AbortOnBase64DecodingErrors</code></td>
<td><code>4</code></td>
<td>解码 Base64 编码数据时，在第一个解码错误处停止。此枚举值已在 Qt 5.15 中添加。</td>
</tr>
</tbody></table>
<p><a href="QByteArray.md#fromBase64Encoding">QByteArray::fromBase64Encoding</a>() 和 [QByteArray::fromBase64](<a target="_blank" rel="noopener" href="https://doc.qt.io/qt-6">https://doc.qt.io/qt-6</a> /qbytearray.html#fromBase64)() 忽略 KeepTrailingEquals 和 OmitTrailingEquals 选项。如果指定了 IgnoreBase64DecodingErrors 选项，它们将不会标记错误，以防尾随等号丢失或太多。如果改为指定 AbortOnBase64DecodingErrors，则输入必须没有填充或具有正确数量的等号。</p>
<p>这个枚举是在 Qt 5.2 中引入或修改的。</p>
<p>Base64Options 类型是 <a target="_blank" rel="noopener" href="https://doc.qt.io/qt-6/qflags.html">QFlags</a><base64option> 的 typedef。它存储 Base64Option 值的 OR 组合。</base64option></p>
<h3><span id="qbytearray-const-iterator">QByteArray::const_iterator</span><a href="#qbytearray-const-iterator" class="header-anchor">#</a></h3><p>此 typedef 为 <a href="QByteArray.md">QByteArray</a> 提供了一个 STL 样式的 const 迭代器。</p>
<p><strong>也可以看看</strong> <a href="QByteArray.md#const_reverse_iterator-typedef">QByteArray::const_reverse_iterator</a> and <a href="QByteArray.md#iterator-typedef">QByteArray::iterator</a>.</p>
<h3><span id="since-5-6-qbytearray-const-reverse-iterator"><code>[since 5.6]</code>QByteArray::const_reverse_iterator</span><a href="#since-5-6-qbytearray-const-reverse-iterator" class="header-anchor">#</a></h3><p>此 typedef 为 <a href="QByteArray.md">QByteArray</a> 提供了一个 STL 样式的 const 反向迭代器。</p>
<p>此 typedef 是在 Qt 5.6 中引入的。</p>
<p><strong>也可以看看</strong> <a href="QByteArray.md#reverse_iterator-typedef">QByteArray::reverse_iterator</a> and <a href="QByteArray.md#const_iterator-typedef">QByteArray::const_iterator</a>.</p>
<h3><span id="qbytearray-iterator">QByteArray::iterator</span><a href="#qbytearray-iterator" class="header-anchor">#</a></h3><p>这个 typedef 为 <a href="QByteArray.md">QByteArray</a> 提供了一个 STL 风格的非常量迭代器。</p>
<p><strong>也可以看看</strong> <a href="QByteArray.md#reverse_iterator-typedef">QByteArray::reverse_iterator</a> and <a href="QByteArray.md#const_iterator-typedef">QByteArray::const_iterator</a>.</p>
<h3><span id="since-5-6-qbytearray-reverse-iterator"><code>[since 5.6]</code>QByteArray::reverse_iterator</span><a href="#since-5-6-qbytearray-reverse-iterator" class="header-anchor">#</a></h3><p>此 typedef 为 <a href="QByteArray.md">QByteArray</a> 提供了一个 STL 样式的非常量反向迭代器。</p>
<p>此 typedef 是在 Qt 5.6 中引入的。</p>
<p><strong>也可以看看</strong> <a href="QByteArray.md#const_reverse_iterator-typedef">QByteArray::const_reverse_iterator</a> and <a href="QByteArray.md#iterator-typedef">QByteArray::iterator</a>.</p>
<h2><span id="cheng-yuan-han-shu-wen-dang">成员函数文档</span><a href="#cheng-yuan-han-shu-wen-dang" class="header-anchor">#</a></h2><h3><span id="static-since-5-15-qbytearray-frombase64result-qbytearray-frombase64encoding-qbytearray-amp-amp-base64-qbytearray-base64options-options-base64encoding"><code>[static, since 5.15]</code> QByteArray::fromBase64Encoding( &amp;&amp;<em>base64</em>,  <em>options</em> = Base64Encoding)</span><a href="#static-since-5-15-qbytearray-frombase64result-qbytearray-frombase64encoding-qbytearray-amp-amp-base64-qbytearray-base64options-options-base64encoding" class="header-anchor">#</a></h3><h3><span id="static-since-5-15-qbytearray-frombase64result-qbytearray-frombase64encoding-const-qbytearray-amp-base64-qbytearray-base64options-options-base64encoding"><code>[static, since 5.15]</code> QByteArray::fromBase64Encoding(const  &amp;<em>base64</em>,  <em>options</em> = Base64Encoding)</span><a href="#static-since-5-15-qbytearray-frombase64result-qbytearray-frombase64encoding-const-qbytearray-amp-base64-qbytearray-base64options-options-base64encoding" class="header-anchor">#</a></h3><p>这是一个重载函数。</p>
<p>使用 <em>options</em> 定义的选项解码 Base64 数组 <em>base64</em>。 如果 <em>options</em> 包含 <code>IgnoreBase64DecodingErrors</code>（默认值），则不检查输入的有效性； 跳过输入中的无效字符，使解码过程能够继续处理后续字符。 如果 <em>options</em> 包含 <code>AbortOnBase64DecodingErrors</code>，则解码将在第一个无效字符处停止。</p>
<p>例如：</p>
<div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">process</span><span class="hljs-params">(<span class="hljs-type">const</span> QByteArray &amp;)</span></span>;

<span class="hljs-keyword">if</span> (<span class="hljs-keyword">auto</span> result = QByteArray::<span class="hljs-built_in">fromBase64Encoding</span>(encodedData))
    <span class="hljs-built_in">process</span>(*result);</code></pre></div>

<p>用于解码 Base64 编码数据的算法在 <a target="_blank" rel="noopener" href="https://datatracker.ietf.org/doc/html/rfc4648">RFC 4648</a> 中定义。</p>
<p>返回一个 QByteArrayFromBase64Result 对象，包含解码的数据和一个指示解码是否成功的标志。 如果传递了 <code>AbortOnBase64DecodingErrors</code> 选项并且输入数据无效，则未指定解码数据包含的内容。</p>
<p>这个函数是在 Qt 5.15 中引入的。</p>
<p><strong>也可以看看</strong> <a href="QByteArray.md#toBase64">toBase64</a>().</p>
<h3><span id="const-char-qbytearray-operator-const-char-const">const char *QByteArray::operator const char *() const</span><a href="#const-char-qbytearray-operator-const-char-const" class="header-anchor">#</a></h3><h3><span id="const-void-qbytearray-operator-const-void-const">const void *QByteArray::operator const void *() const</span><a href="#const-void-qbytearray-operator-const-void-const" class="header-anchor">#</a></h3><p><strong>注意：</strong> 在新代码中使用 <a href="QByteArray.md#constData">constData</a>() 代替。</p>
<p>返回指向存储在字节数组中的数据的指针。 指针可用于访问组成数组的字节。 数据以`\0”结尾。</p>
<p>只要没有发生分离并且 <a href="QByteArray.md">QByteArray</a> 没有被修改，指针就保持有效。 此运算符对于将字节数组传递给接受 <code>const char *</code> 的函数非常有用。</p>
<p>您可以在编译应用程序时通过定义 <code>QT_NO_CAST_FROM_BYTEARRAY</code> 来禁用此运算符。</p>
<p>注意：<a href="QByteArray.md">QByteArray</a> 可以存储任何字节值，包括 ‘\0’，但大多数采用 <code>char *</code> 参数的函数假定数据结束 在他们遇到的第一个 ‘\0’ 处。</p>
<p><strong>也可以看看</strong> <a href="QByteArray.md#constData">constData</a>().</p>
<h3><span id="since-5-2-qbytearray-qbytearray-qbytearray-amp-amp-other"><code>[since 5.2]</code>QByteArray::QByteArray( &amp;&amp;<em>other</em>)</span><a href="#since-5-2-qbytearray-qbytearray-qbytearray-amp-amp-other" class="header-anchor">#</a></h3><p>移动构造一个 QByteArray 实例，使其指向 <em>other</em> 指向的同一个对象。</p>
<p>这个函数是在 Qt 5.2 中引入的。</p>
<h3><span id="qbytearray-qbytearray-const-qbytearray-amp-other">QByteArray::QByteArray(const  &amp;<em>other</em>)</span><a href="#qbytearray-qbytearray-const-qbytearray-amp-other" class="header-anchor">#</a></h3><p>构造 <em>other</em> 的副本。</p>
<p>这个操作需要<a target="_blank" rel="noopener" href="https://doc.qt.io/qt-6/containers.html#constant-time">恒定时间</a>，因为QByteArray是[隐式共享](<a target="_blank" rel="noopener" href="https://doc.qt.io/qt">https://doc.qt.io/qt</a> -6/隐式共享.html)。 这使得从函数返回 QByteArray 非常快。 如果共享实例被修改，它将被复制（写时复制），需要<a target="_blank" rel="noopener" href="https://doc.qt.io/qt-6/containers.html#linear-time">线性时间</a>。</p>
<p><strong>也可以看看</strong> <a href="QByteArray.md#operator-eq">operator=</a>().</p>
<h3><span id="qbytearray-qbytearray-qsizetype-size-char-ch">QByteArray::QByteArray(qsizetype <em>size</em>, char <em>ch</em>)</span><a href="#qbytearray-qbytearray-qsizetype-size-char-ch" class="header-anchor">#</a></h3><p>构造一个大小为 <em>size</em> 的字节数组，每个字节都设置为 <em>ch</em>。</p>
<p><strong>也可以看看</strong> <a href="QByteArray.md#fill">fill</a>().</p>
<h3><span id="qbytearray-qbytearray-const-char-data-qsizetype-size-1">QByteArray::QByteArray(const char *<em>data</em>, qsizetype <em>size</em> = -1)</span><a href="#qbytearray-qbytearray-const-char-data-qsizetype-size-1" class="header-anchor">#</a></h3><p>构造一个字节数组，其中包含数组 <em>data</em> 的前 <em>size</em> 个字节。</p>
<p>如果 <em>data</em> 为 0，则构造一个空字节数组。</p>
<p>如果 <em>size</em> 为负数，则假定 <em>data</em> 指向以 ‘\0’ 结尾的字符串，并且其长度是动态确定的。</p>
<p>QByteArray 对字符串数据进行深拷贝。</p>
<p><strong>也可以看看</strong> <a href="QByteArray.md#fromRawData">fromRawData</a>().</p>
<h3><span id="qbytearray-qbytearray">QByteArray::QByteArray()</span><a href="#qbytearray-qbytearray" class="header-anchor">#</a></h3><p>构造一个空字节数组。</p>
<p><strong>也可以看看</strong> <a href="QByteArray.md#isEmpty">isEmpty</a>().</p>
<h3><span id="since-5-2-qbytearray-amp-qbytearray-operator-qbytearray-amp-amp-other"><code>[since 5.2]</code> &amp;QByteArray::operator=( &amp;&amp;<em>other</em>)</span><a href="#since-5-2-qbytearray-amp-qbytearray-operator-qbytearray-amp-amp-other" class="header-anchor">#</a></h3><p>将 <em>other</em> 移动分配给此 <a href="QByteArray.md">QByteArray</a> 实例。</p>
<p>这个函数是在 Qt 5.2 中引入的。</p>
<h3><span id="qbytearray-amp-qbytearray-operator-const-qbytearray-amp-other"> &amp;QByteArray::operator=(const  &amp;<em>other</em>)</span><a href="#qbytearray-amp-qbytearray-operator-const-qbytearray-amp-other" class="header-anchor">#</a></h3><p>将 <em>other</em> 分配给此字节数组并返回对此字节数组的引用。</p>
<h3><span id="qbytearray-qbytearray">QByteArray::~QByteArray()</span><a href="#qbytearray-qbytearray" class="header-anchor">#</a></h3><p>Destroys the byte array.</p>
<h3><span id="qbytearray-amp-qbytearray-append-const-qbytearray-amp-ba"> &amp;QByteArray::append(const  &amp;<em>ba</em>)</span><a href="#qbytearray-amp-qbytearray-append-const-qbytearray-amp-ba" class="header-anchor">#</a></h3><p>将字节数组 <em>ba</em> 附加到此字节数组的末尾。</p>
<p>例子：</p>
<div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-function">QByteArray <span class="hljs-title">x</span><span class="hljs-params">(<span class="hljs-string">"free"</span>)</span></span>;
<span class="hljs-function">QByteArray <span class="hljs-title">y</span><span class="hljs-params">(<span class="hljs-string">"dom"</span>)</span></span>;
x.<span class="hljs-built_in">append</span>(y);
<span class="hljs-comment">// x == "freedom"</span></code></pre></div>

<p>这与 insert(<a href="QByteArray.md#size">size</a>(), <em>ba</em>) 相同。</p>
<p>注意：<a href="QByteArray.md">QByteArray</a> 是一个[隐式共享](<a target="_blank" rel="noopener" href="https://doc.qt.io/qt-6/implicit-sharing.html">https://doc.qt.io/qt-6/implicit-sharing.html</a> ） 班级。因此，如果您追加到一个空字节数组，那么字节数组将只共享保存在 *ba* 中的数据。在这种情况下，不会复制数据，需要 <a target="_blank" rel="noopener" href="https://doc.qt.io/qt-6/containers.html#constant-time">恒定时间</a>。如果共享实例被修改，它将被复制（写时复制），需要[线性时间]（<a target="_blank" rel="noopener" href="https://doc.qt.io/qt-6/containers.html#linear-time%EF%BC%89%E3%80%82">https://doc.qt.io/qt-6/containers.html#linear-time）。</a></p>
<p>如果要附加的字节数组不为空，则执行数据的深层复制，花费 <a target="_blank" rel="noopener" href="https://doc.qt.io/qt-6/containers.html#linear-time">线性时间</a>。</p>
<p>append() 函数通常非常快（<a target="_blank" rel="noopener" href="https://doc.qt.io/qt-6/containers.html#constant-time">constant time</a>），因为 [QByteArray](<a target="_blank" rel="noopener" href="https://doc/">https://doc</a>. qt.io/qt-6/qbytearray.html) 在数据末尾预先分配额外的空间，因此它可以增长而无需每次都重新分配整个数组。</p>
<p><strong>也可以看看</strong> <a href="QByteArray.md#operator-2b-eq">operator+=</a>(), <a href="QByteArray.md#prepend">prepend</a>(), and <a href="QByteArray.md#insert">insert</a>().</p>
<h3><span id="qbytearray-amp-qbytearray-append-char-ch"> &amp;QByteArray::append(char <em>ch</em>)</span><a href="#qbytearray-amp-qbytearray-append-char-ch" class="header-anchor">#</a></h3><p>这是一个重载函数。</p>
<p>将字节 <em>ch</em> 附加到此字节数组。</p>
<h3><span id="since-5-7-qbytearray-amp-qbytearray-append-qsizetype-count-char-ch"><code>[since 5.7]</code> &amp;QByteArray::append(qsizetype <em>count</em>, char <em>ch</em>)</span><a href="#since-5-7-qbytearray-amp-qbytearray-append-qsizetype-count-char-ch" class="header-anchor">#</a></h3><p>这是一个重载函数。</p>
<p>将 <em>count</em> 个字节 <em>ch</em> 副本附加到此字节数组并返回对此字节数组的引用。</p>
<p>如果 <em>count</em> 为负数或零，则不会将任何内容附加到字节数组。</p>
<p>这个函数是在 Qt 5.7 中引入的。</p>
<h3><span id="qbytearray-amp-qbytearray-append-const-char-str"> &amp;QByteArray::append(const char *<em>str</em>)</span><a href="#qbytearray-amp-qbytearray-append-const-char-str" class="header-anchor">#</a></h3><p>这是一个重载函数。</p>
<p>将 ‘\0’ 结尾的字符串 <em>str</em> 附加到此字节数组。</p>
<h3><span id="qbytearray-amp-qbytearray-append-const-char-str-qsizetype-len"> &amp;QByteArray::append(const char *<em>str</em>, qsizetype <em>len</em>)</span><a href="#qbytearray-amp-qbytearray-append-const-char-str-qsizetype-len" class="header-anchor">#</a></h3><p>这是一个重载函数。</p>
<p>将从 <em>str</em> 开始的第一个 <em>len</em> 字节附加到此字节数组并返回对此字节数组的引用。 附加的字节可能包括 ‘\0’ 字节。</p>
<p>如果 <em>len</em> 为负数，<em>str</em> 将被假定为以 ‘\0’ 结尾的字符串，并且要复制的长度将使用 [qstrlen] 自动确定（<a target="_blank" rel="noopener" href="https://doc.qt.io/qt-">https://doc.qt.io/qt-</a> 6/qbytearray.html#qstrlen)()。</p>
<p>如果 <em>len</em> 为零或 <em>str</em> 为空，则不会将任何内容附加到字节数组。 确保 <em>len</em> <em>not</em> 长于 <em>str</em>。</p>
<h3><span id="qbytearray-amp-qbytearray-append-qbytearrayview-data"> &amp;QByteArray::append( <em>data</em>)</span><a href="#qbytearray-amp-qbytearray-append-qbytearrayview-data" class="header-anchor">#</a></h3><p>这是一个重载函数。</p>
<p>将 <em>data</em> 附加到此字节数组。</p>
<h3><span id="char-qbytearray-at-qsizetype-i-const">char QByteArray::at(qsizetype <em>i</em>) const</span><a href="#char-qbytearray-at-qsizetype-i-const" class="header-anchor">#</a></h3><p>返回字节数组中索引位置 <em>i</em> 处的字节。</p>
<p><em>i</em> 必须是字节数组中的有效索引位置（即 0 &lt;= <em>i</em> &lt; <a href="QByteArray.md#size">size</a>()） .</p>
<p><strong>也可以看看</strong> [operator<a href="QByteArray.md#operator-5b-5d">]</a>().</p>
<h3><span id="since-5-10-char-qbytearray-back-const"><code>[since 5.10]</code>char QByteArray::back() const</span><a href="#since-5-10-char-qbytearray-back-const" class="header-anchor">#</a></h3><p>返回字节数组中的最后一个字节。 与 <code>at(size() - 1)</code> 相同。</p>
<p>提供此功能是为了与 STL 兼容。</p>
<p><strong>警告：</strong> 在空字节数组上调用此函数构成未定义的行为。</p>
<p>这个函数是在 Qt 5.10 中引入的。</p>
<p><strong>也可以看看</strong> <a href="QByteArray.md#front">front</a>(), <a href="QByteArray.md#at">at</a>(), and [operator<a href="QByteArray.md#operator-5b-5d">]</a>().</p>
<h3><span id="since-5-10-char-amp-qbytearray-back"><code>[since 5.10]</code>char &amp;QByteArray::back()</span><a href="#since-5-10-char-amp-qbytearray-back" class="header-anchor">#</a></h3><p>返回对字节数组中最后一个字节的引用。 与 <code>operator[](size() - 1)</code> 相同。</p>
<p>提供此功能是为了与 STL 兼容。</p>
<p><strong>警告：</strong> 在空字节数组上调用此函数构成未定义的行为。</p>
<p>这个函数是在 Qt 5.10 中引入的。</p>
<p><strong>也可以看看</strong> <a href="QByteArray.md#front">front</a>(), <a href="QByteArray.md#at">at</a>(), and [operator<a href="QByteArray.md#operator-5b-5d">]</a>().</p>
<h3><span id="qbytearray-iterator-qbytearray-begin"> QByteArray::begin()</span><a href="#qbytearray-iterator-qbytearray-begin" class="header-anchor">#</a></h3><p>返回指向字节数组中第一个字节的 <a target="_blank" rel="noopener" href="https://doc.qt.io/qt-6/containers.html#stl-style-iterators">STL 样式迭代器</a>。</p>
<p><strong>警告：</strong> 返回的迭代器在分离或修改 <a href="QByteArray.md">QByteArray</a> 时失效。</p>
<p><strong>也可以看看</strong> <a href="QByteArray.md#constBegin">constBegin</a>() and <a href="QByteArray.md#end">end</a>().</p>
<h3><span id="qbytearray-const-iterator-qbytearray-begin-const"> QByteArray::begin() const</span><a href="#qbytearray-const-iterator-qbytearray-begin-const" class="header-anchor">#</a></h3><p>此函数重载 begin()。</p>
<h3><span id="qsizetype-qbytearray-capacity-const">qsizetype QByteArray::capacity() const</span><a href="#qsizetype-qbytearray-capacity-const" class="header-anchor">#</a></h3><p>返回在不强制重新分配的情况下可以存储在字节数组中的最大字节数。</p>
<p>该函数的唯一目的是提供一种微调 <a href="QByteArray.md">QByteArray</a> 的内存使用的方法。 通常，您很少需要调用此函数。 如果您想知道字节数组中有多少字节，请调用 <a href="QByteArray.md#size">size</a>()。</p>
<p><strong>注意：</strong> 静态分配的字节数组将报告容量为 0，即使它不为空。</p>
<p><strong>注意：</strong> 分配的内存块中的可用空间位置未定义。 换句话说，不应该假设空闲内存总是位于初始化元素之后。</p>
<p><strong>也可以看看</strong> <a href="QByteArray.md#reserve">reserve</a>() and <a href="QByteArray.md#squeeze">squeeze</a>().</p>
<h3><span id="since-5-0-qbytearray-const-iterator-qbytearray-cbegin-const"><code>[since 5.0]</code> QByteArray::cbegin() const</span><a href="#since-5-0-qbytearray-const-iterator-qbytearray-cbegin-const" class="header-anchor">#</a></h3><p>返回指向字节数组中第一个字节的 const <a target="_blank" rel="noopener" href="https://doc.qt.io/qt-6/containers.html#stl-style-iterators">STL 样式迭代器</a>。</p>
<p><strong>警告：</strong> 返回的迭代器在分离或修改 <a href="QByteArray.md">QByteArray</a> 时失效。</p>
<p>此功能是在 Qt 5.0 中引入的。</p>
<p><strong>也可以看看</strong> <a href="QByteArray.md#begin">begin</a>() and <a href="QByteArray.md#cend">cend</a>().</p>
<h3><span id="since-5-0-qbytearray-const-iterator-qbytearray-cend-const"><code>[since 5.0]</code> QByteArray::cend() const</span><a href="#since-5-0-qbytearray-const-iterator-qbytearray-cend-const" class="header-anchor">#</a></h3><p>返回一个 const <a target="_blank" rel="noopener" href="https://doc.qt.io/qt-6/containers.html#stl-style-iterators">STL 样式迭代器</a> 指向字节数组中最后一个字节之后。</p>
<p><strong>警告：</strong> 返回的迭代器在分离或修改 <a href="QByteArray.md">QByteArray</a> 时失效。</p>
<p>此功能是在 Qt 5.0 中引入的。</p>
<p><strong>也可以看看</strong> <a href="QByteArray.md#cbegin">cbegin</a>() and <a href="QByteArray.md#end">end</a>().</p>
<h3><span id="void-qbytearray-chop-qsizetype-n">void QByteArray::chop(qsizetype <em>n</em>)</span><a href="#void-qbytearray-chop-qsizetype-n" class="header-anchor">#</a></h3><p>从字节数组的末尾删除 <em>n</em> 个字节。</p>
<p>如果 <em>n</em> 大于 <a href="QByteArray.md#size">size</a>()，则结果为空字节数组。</p>
<p>例子：</p>
<div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-function">QByteArray <span class="hljs-title">ba</span><span class="hljs-params">(<span class="hljs-string">"STARTTLS\r\n"</span>)</span></span>;
ba.<span class="hljs-built_in">chop</span>(<span class="hljs-number">2</span>);                 <span class="hljs-comment">// ba == "STARTTLS"</span></code></pre></div>

<p><strong>也可以看看</strong> <a href="QByteArray.md#truncate">truncate</a>(), <a href="QByteArray.md#resize">resize</a>(), and <a href="QByteArray.md#first">first</a>().</p>
<h3><span id="since-5-10-qbytearray-qbytearray-chopped-qsizetype-len-const"><code>[since 5.10]</code> QByteArray::chopped(qsizetype <em>len</em>) const</span><a href="#since-5-10-qbytearray-qbytearray-chopped-qsizetype-len-const" class="header-anchor">#</a></h3><p>返回一个字节数组，其中包含最左边的 <a href="QByteArray.md#size">size</a>() - 此字节数组的 <em>len</em> 个字节。</p>
<p><strong>注意：</strong> 如果 <em>len</em> 为负数或大于 <a href="QByteArray.md#size">size</a>()，则行为未定义。</p>
<p>这个函数是在 Qt 5.10 中引入的。</p>
<p><strong>也可以看看</strong> <a href="QByteArray.md#endsWith">endsWith</a>(), <a href="QByteArray.md#first">first</a>(), <a href="QByteArray.md#last">last</a>(), <a href="QByteArray.md#sliced">sliced</a>(), <a href="QByteArray.md#chop">chop</a>(), and <a href="QByteArray.md#truncate">truncate</a>().</p>
<h3><span id="void-qbytearray-clear">void QByteArray::clear()</span><a href="#void-qbytearray-clear" class="header-anchor">#</a></h3><p>清除字节数组的内容并使其为空。</p>
<p><strong>也可以看看</strong> <a href="QByteArray.md#resize">resize</a>() and <a href="QByteArray.md#isNull">isNull</a>().</p>
<h3><span id="since-6-0-int-qbytearray-compare-qbytearrayview-bv-qt-casesensitivity-cs-qt-casesensitive-const"><code>[since 6.0]</code>int QByteArray::compare( <em>bv</em>,  <em>cs</em> = Qt::CaseSensitive) const</span><a href="#since-6-0-int-qbytearray-compare-qbytearrayview-bv-qt-casesensitivity-cs-qt-casesensitive-const" class="header-anchor">#</a></h3><p>返回一个小于、等于或大于零的整数，具体取决于此 <a href="QByteArray.md">QByteArray</a> 是否在之前、相同位置或之后排序 <a target="_blank" rel="noopener" href="https://doc.qt.io/qt-6/qbytearrayview.html">QByteArrayView</a> <em>bv</em>。 根据区分大小写 <em>cs</em> 执行比较。</p>
<p>此功能是在 Qt 6.0 中引入的。</p>
<p><strong>也可以看看</strong> <a href="QByteArray.md#operator-eq-eq">operator==</a> and <a href="QByteArray.md#character-case">Character Case</a>.</p>
<h3><span id="qbytearray-const-iterator-qbytearray-constbegin-const"> QByteArray::constBegin() const</span><a href="#qbytearray-const-iterator-qbytearray-constbegin-const" class="header-anchor">#</a></h3><p>返回指向字节数组中第一个字节的 const <a target="_blank" rel="noopener" href="https://doc.qt.io/qt-6/containers.html#stl-style-iterators">STL 样式迭代器</a>。</p>
<p><strong>警告：</strong> 返回的迭代器在分离或修改 <a href="QByteArray.md">QByteArray</a> 时失效。</p>
<p><strong>也可以看看</strong> <a href="QByteArray.md#begin">begin</a>() and <a href="QByteArray.md#constEnd">constEnd</a>().</p>
<h3><span id="const-char-qbytearray-constdata-const">const char *QByteArray::constData() const</span><a href="#const-char-qbytearray-constdata-const" class="header-anchor">#</a></h3><p>返回指向存储在字节数组中的 const 数据的指针。 指针可用于访问组成数组的字节。 除非 <a href="QByteArray.md">QByteArray</a> 对象是从原始数据创建的，否则数据会以 ‘\0’ 结尾。</p>
<p>只要没有发生分离并且 <a href="QByteArray.md">QByteArray</a> 没有被修改，指针就保持有效。</p>
<p>这个函数在将字节数组传递给接受<code>const char *</code>的函数时非常有用。</p>
<p>注意：<a href="QByteArray.md">QByteArray</a> 可以存储任何字节值，包括 ‘\0’，但大多数采用 <code>char *</code> 参数的函数假定数据结束 在他们遇到的第一个 ‘\0’ 处。</p>
<p><strong>也可以看看</strong> <a href="QByteArray.md#data">data</a>(), [operator<a href="QByteArray.md#operator-5b-5d">]</a>(), and <a href="QByteArray.md#fromRawData">fromRawData</a>().</p>
<h3><span id="qbytearray-const-iterator-qbytearray-constend-const"> QByteArray::constEnd() const</span><a href="#qbytearray-const-iterator-qbytearray-constend-const" class="header-anchor">#</a></h3><p>返回一个 const <a target="_blank" rel="noopener" href="https://doc.qt.io/qt-6/containers.html#stl-style-iterators">STL 样式迭代器</a> 指向字节数组中最后一个字节之后。</p>
<p><strong>警告：</strong> 返回的迭代器在分离或修改 <a href="QByteArray.md">QByteArray</a> 时失效。</p>
<p><strong>也可以看看</strong> <a href="QByteArray.md#constBegin">constBegin</a>() and <a href="QByteArray.md#end">end</a>().</p>
<h3><span id="since-6-0-bool-qbytearray-contains-qbytearrayview-bv-const"><code>[since 6.0]</code>bool QByteArray::contains( <em>bv</em>) const</span><a href="#since-6-0-bool-qbytearray-contains-qbytearrayview-bv-const" class="header-anchor">#</a></h3><p>如果此字节数组包含 <em>bv</em> 查看的字节序列的出现，则返回 <code>true</code>； 否则返回<code>false</code>。</p>
<p>此功能是在 Qt 6.0 中引入的。</p>
<p><strong>也可以看看</strong> <a href="QByteArray.md#indexOf">indexOf</a>() and <a href="QByteArray.md#count-2">count</a>().</p>
<h3><span id="bool-qbytearray-contains-char-ch-const">bool QByteArray::contains(char <em>ch</em>) const</span><a href="#bool-qbytearray-contains-char-ch-const" class="header-anchor">#</a></h3><p>这是一个重载函数。</p>
<p>如果字节数组包含字节 <em>ch</em>，则返回 <code>true</code>； 否则返回<code>false</code>。</p>
<h3><span id="since-6-0-qsizetype-qbytearray-count-qbytearrayview-bv-const"><code>[since 6.0]</code>qsizetype QByteArray::count( <em>bv</em>) const</span><a href="#since-6-0-qsizetype-qbytearray-count-qbytearrayview-bv-const" class="header-anchor">#</a></h3><p>返回此字节数组中 <em>bv</em> 查看的字节序列的（可能重叠）出现次数。</p>
<p>此功能是在 Qt 6.0 中引入的。</p>
<p><strong>也可以看看</strong> <a href="QByteArray.md#contains">contains</a>() and <a href="QByteArray.md#indexOf">indexOf</a>().</p>
<h3><span id="qsizetype-qbytearray-count-char-ch-const">qsizetype QByteArray::count(char <em>ch</em>) const</span><a href="#qsizetype-qbytearray-count-char-ch-const" class="header-anchor">#</a></h3><p>这是一个重载函数。</p>
<p>返回字节数组中字节 <em>ch</em> 的出现次数。</p>
<p><strong>也可以看看</strong> <a href="QByteArray.md#contains">contains</a>() and <a href="QByteArray.md#indexOf">indexOf</a>().</p>
<h3><span id="qsizetype-qbytearray-count-const">qsizetype QByteArray::count() const</span><a href="#qsizetype-qbytearray-count-const" class="header-anchor">#</a></h3><p>这是一个重载函数。</p>
<p>和 <a href="QByteArray.md#size">size</a>().</p>
<h3><span id="since-5-6-qbytearray-const-reverse-iterator-qbytearray-crbegin-const"><code>[since 5.6]</code> QByteArray::crbegin() const</span><a href="#since-5-6-qbytearray-const-reverse-iterator-qbytearray-crbegin-const" class="header-anchor">#</a></h3><p>返回一个 const <a target="_blank" rel="noopener" href="https://doc.qt.io/qt-6/containers.html#stl-style-iterators">STL-style</a> 反向迭代器，以相反的顺序指向字节数组中的第一个字节。</p>
<p><strong>警告：</strong> 返回的迭代器在分离或修改 <a href="QByteArray.md">QByteArray</a> 时失效。</p>
<p>此功能是在 Qt 5.6 中引入的。</p>
<p><strong>也可以看看</strong> <a href="QByteArray.md#begin">begin</a>(), <a href="QByteArray.md#rbegin">rbegin</a>(), and <a href="QByteArray.md#rend">rend</a>().</p>
<h3><span id="since-5-6-qbytearray-const-reverse-iterator-qbytearray-crend-const"><code>[since 5.6]</code> QByteArray::crend() const</span><a href="#since-5-6-qbytearray-const-reverse-iterator-qbytearray-crend-const" class="header-anchor">#</a></h3><p>返回一个 const <a target="_blank" rel="noopener" href="https://doc.qt.io/qt-6/containers.html#stl-style-iterators">STL-style</a> 反向迭代器，以相反的顺序指向字节数组中最后一个字节之后 .</p>
<p><strong>警告：</strong> 返回的迭代器在分离或修改 <a href="QByteArray.md">QByteArray</a> 时失效。</p>
<p>此功能是在 Qt 5.6 中引入的。</p>
<p><strong>也可以看看</strong> <a href="QByteArray.md#end">end</a>(), <a href="QByteArray.md#rend">rend</a>(), and <a href="QByteArray.md#rbegin">rbegin</a>().</p>
<h3><span id="char-qbytearray-data">char *QByteArray::data()</span><a href="#char-qbytearray-data" class="header-anchor">#</a></h3><p>返回指向存储在字节数组中的数据的指针。 指针可用于访问和修改组成数组的字节。 数据以 ‘\0’ 结尾，即返回指针后可以访问的字节数为 <a href="QByteArray.md#size">size</a>() + 1，包括 ‘\0’ 终止符。</p>
<p>例子：</p>
<div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-function">QByteArray <span class="hljs-title">ba</span><span class="hljs-params">(<span class="hljs-string">"Hello world"</span>)</span></span>;
<span class="hljs-type">char</span> *data = ba.<span class="hljs-built_in">data</span>();
<span class="hljs-keyword">while</span> (*data) {
    cout &lt;&lt; <span class="hljs-string">"["</span> &lt;&lt; *data &lt;&lt; <span class="hljs-string">"]"</span> &lt;&lt; Qt::endl;
    ++data;
}</code></pre></div>

<p>只要没有发生分离并且 <a href="QByteArray.md">QByteArray</a> 没有被修改，指针就保持有效。</p>
<p>对于只读访问，<a href="QByteArray.md#constData">constData</a>() 更快，因为它不会导致 [deep copy](<a target="_blank" rel="noopener" href="https://doc/">https://doc</a>. qt.io/qt-6/implicit-sharing.html#deep-copy)发生。</p>
<p>这个函数在将字节数组传递给接受<code>const char *</code>的函数时非常有用。</p>
<p>以下示例复制了 data() 返回的 char*，但它会破坏堆并导致崩溃，因为它没有为末尾的 ‘\0’ 分配字节：</p>
<div class="code-wrapper"><pre><code class="hljs c++">QString tmp = <span class="hljs-string">"test"</span>;
QByteArray text = tmp.<span class="hljs-built_in">toLocal8Bit</span>();
<span class="hljs-type">char</span> *data = <span class="hljs-keyword">new</span> <span class="hljs-type">char</span>[text.<span class="hljs-built_in">size</span>()];
<span class="hljs-built_in">strcpy</span>(data, text.<span class="hljs-built_in">data</span>());
<span class="hljs-keyword">delete</span> [] data;</code></pre></div>

<p>这个分配了正确的空间量：</p>
<div class="code-wrapper"><pre><code class="hljs c++">QString tmp = <span class="hljs-string">"test"</span>;
QByteArray text = tmp.<span class="hljs-built_in">toLocal8Bit</span>();
<span class="hljs-type">char</span> *data = <span class="hljs-keyword">new</span> <span class="hljs-type">char</span>[text.<span class="hljs-built_in">size</span>() + <span class="hljs-number">1</span>];
<span class="hljs-built_in">strcpy</span>(data, text.<span class="hljs-built_in">data</span>());
<span class="hljs-keyword">delete</span> [] data;</code></pre></div>

<p>注意：<a href="QByteArray.md">QByteArray</a> 可以存储任何字节值，包括 ‘\0’，但大多数采用 <code>char *</code> 参数的函数假定数据结束 在他们遇到的第一个 ‘\0’ 处。</p>
<p><strong>也可以看看</strong> <a href="QByteArray.md#constData">constData</a>() and [operator<a href="QByteArray.md#operator-5b-5d">]</a>().</p>
<h3><span id="const-char-qbytearray-data-const">const char *QByteArray::data() const</span><a href="#const-char-qbytearray-data-const" class="header-anchor">#</a></h3><p>这是一个重载函数。</p>
<h3><span id="qbytearray-iterator-qbytearray-end"> QByteArray::end()</span><a href="#qbytearray-iterator-qbytearray-end" class="header-anchor">#</a></h3><p>返回一个 <a target="_blank" rel="noopener" href="https://doc.qt.io/qt-6/containers.html#stl-style-iterators">STL 风格的迭代器</a> 指向字节数组中最后一个字节之后。</p>
<p><strong>警告：</strong> 返回的迭代器在分离或修改 <a href="QByteArray.md">QByteArray</a> 时失效。</p>
<p><strong>也可以看看</strong> <a href="QByteArray.md#begin">begin</a>() and <a href="QByteArray.md#constEnd">constEnd</a>().</p>
<h3><span id="qbytearray-const-iterator-qbytearray-end-const"> QByteArray::end() const</span><a href="#qbytearray-const-iterator-qbytearray-end-const" class="header-anchor">#</a></h3><p>This function overloads end().</p>
<h3><span id="since-6-0-bool-qbytearray-endswith-qbytearrayview-bv-const"><code>[since 6.0]</code>bool QByteArray::endsWith( <em>bv</em>) const</span><a href="#since-6-0-bool-qbytearray-endswith-qbytearrayview-bv-const" class="header-anchor">#</a></h3><p>如果此字节数组以 <em>bv</em> 查看的字节序列结尾，则返回 <code>true</code>； 否则返回<code>false</code>。</p>
<p>例子：</p>
<div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-function">QByteArray <span class="hljs-title">url</span><span class="hljs-params">(<span class="hljs-string">"http://qt-project.org/doc/qt-5.0/qtdoc/index.html"</span>)</span></span>;
<span class="hljs-keyword">if</span> (url.<span class="hljs-built_in">endsWith</span>(<span class="hljs-string">".html"</span>))
    ...</code></pre></div>

<p>此功能是在 Qt 6.0 中引入的。</p>
<p><strong>也可以看看</strong> <a href="QByteArray.md#startsWith">startsWith</a>() and <a href="QByteArray.md#last">last</a>().</p>
<h3><span id="bool-qbytearray-endswith-char-ch-const">bool QByteArray::endsWith(char <em>ch</em>) const</span><a href="#bool-qbytearray-endswith-char-ch-const" class="header-anchor">#</a></h3><p>这是一个重载函数。</p>
<p>如果此字节数组以字节 <em>ch</em> 结尾，则返回 <code>true</code>； 否则返回<code>false</code>。</p>
<h3><span id="since-6-1-qbytearray-iterator-qbytearray-erase-qbytearray-const-iterator-first-qbytearray-const-iterator-last"><code>[since 6.1]</code> QByteArray::erase( <em>first</em>,  <em>last</em>)</span><a href="#since-6-1-qbytearray-iterator-qbytearray-erase-qbytearray-const-iterator-first-qbytearray-const-iterator-last" class="header-anchor">#</a></h3><p>从字节数组中删除半开范围 [ <em>first</em> , <em>last</em> ) 中的字符。 返回一个迭代器，指向擦除前 <em>last</em> 引用的字符。</p>
<p>此功能是在 Qt 6.1 中引入的。</p>
<h3><span id="qbytearray-amp-qbytearray-fill-char-ch-qsizetype-size-1"> &amp;QByteArray::fill(char <em>ch</em>, qsizetype <em>size</em> = -1)</span><a href="#qbytearray-amp-qbytearray-fill-char-ch-qsizetype-size-1" class="header-anchor">#</a></h3><p>将字节数组中的每个字节设置为 <em>ch</em>。 如果 <em>size</em> 不同于 -1（默认值），则字节数组的大小会预先调整为 <em>size</em> 大小。</p>
<p>例子：</p>
<div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-function">QByteArray <span class="hljs-title">ba</span><span class="hljs-params">(<span class="hljs-string">"Istambul"</span>)</span></span>;
ba.<span class="hljs-built_in">fill</span>(<span class="hljs-string">'o'</span>);
<span class="hljs-comment">// ba == "oooooooo"</span>

ba.<span class="hljs-built_in">fill</span>(<span class="hljs-string">'X'</span>, <span class="hljs-number">2</span>);
<span class="hljs-comment">// ba == "XX"</span></code></pre></div>

<p><strong>也可以看看</strong> <a href="QByteArray.md#resize">resize</a>().</p>
<h3><span id="since-6-0-qbytearray-qbytearray-first-qsizetype-n-const"><code>[since 6.0]</code> QByteArray::first(qsizetype <em>n</em>) const</span><a href="#since-6-0-qbytearray-qbytearray-first-qsizetype-n-const" class="header-anchor">#</a></h3><p>返回字节数组的前 <em>n</em> 个字节。</p>
<p><strong>注意：</strong> 当 <em>n</em> &lt; 0 或 *n* &gt; <a href="QByteArray.md#size">size</a>() 时，行为未定义。</p>
<p>例子：</p>
<div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-function">QByteArray <span class="hljs-title">x</span><span class="hljs-params">(<span class="hljs-string">"Pineapple"</span>)</span></span>;
QByteArray y = x.<span class="hljs-built_in">first</span>(<span class="hljs-number">4</span>);
<span class="hljs-comment">// y == "Pine"</span></code></pre></div>

<p>此功能是在 Qt 6.0 中引入的。</p>
<p><strong>也可以看看</strong> <a href="QByteArray.md#last">last</a>(), <a href="QByteArray.md#sliced">sliced</a>(), <a href="QByteArray.md#startsWith">startsWith</a>(), <a href="QByteArray.md#chopped">chopped</a>(), <a href="QByteArray.md#chop">chop</a>(), and <a href="QByteArray.md#truncate">truncate</a>().</p>
<h3><span id="static-since-5-2-qbytearray-qbytearray-frombase64-const-qbytearray-amp-base64-qbytearray-base64options-options-base64encoding"><code>[static, since 5.2]</code> QByteArray::fromBase64(const  &amp;<em>base64</em>,  <em>options</em> = Base64Encoding)</span><a href="#static-since-5-2-qbytearray-qbytearray-frombase64-const-qbytearray-amp-base64-qbytearray-base64options-options-base64encoding" class="header-anchor">#</a></h3><p>使用 <em>options</em> 定义的选项返回 Base64 数组 <em>base64</em> 的解码副本。 如果 <em>options</em> 包含 <code>IgnoreBase64DecodingErrors</code>（默认值），则不检查输入的有效性； 跳过输入中的无效字符，使解码过程能够继续处理后续字符。 如果 <em>options</em> 包含 <code>AbortOnBase64DecodingErrors</code>，则解码将在第一个无效字符处停止。</p>
<p>例如：</p>
<div class="code-wrapper"><pre><code class="hljs c++">QByteArray text = QByteArray::<span class="hljs-built_in">fromBase64</span>(<span class="hljs-string">"UXQgaXMgZ3JlYXQh"</span>);
text.<span class="hljs-built_in">data</span>();            <span class="hljs-comment">// returns "Qt is great!"</span>

QByteArray::<span class="hljs-built_in">fromBase64</span>(<span class="hljs-string">"PHA+SGVsbG8/PC9wPg=="</span>, QByteArray::Base64Encoding); <span class="hljs-comment">// returns "&lt;p&gt;Hello?&lt;/p&gt;"</span>
QByteArray::<span class="hljs-built_in">fromBase64</span>(<span class="hljs-string">"PHA-SGVsbG8_PC9wPg=="</span>, QByteArray::Base64UrlEncoding); <span class="hljs-comment">// returns "&lt;p&gt;Hello?&lt;/p&gt;"</span></code></pre></div>

<p>用于解码 Base64 编码数据的算法在 <a target="_blank" rel="noopener" href="https://datatracker.ietf.org/doc/html/rfc4648">RFC 4648</a> 中定义。</p>
<p>返回解码的数据，或者，如果传递了 <code>AbortOnBase64DecodingErrors</code> 选项并且输入数据无效，则返回一个空字节数组。</p>
<p><strong>注意：</strong> 在新代码中推荐使用 <a href="QByteArray.md#fromBase64Encoding">fromBase64Encoding</a>() 函数。</p>
<p>此功能是在 Qt 5.2 中引入的。</p>
<p><strong>也可以看看</strong> <a href="QByteArray.md#toBase64">toBase64</a>() and <a href="QByteArray.md#fromBase64Encoding">fromBase64Encoding</a>().</p>
<h3><span id="static-since-5-3-qbytearray-qbytearray-fromcfdata-cfdataref-data"><code>[static, since 5.3]</code> QByteArray::fromCFData(CFDataRef <em>data</em>)</span><a href="#static-since-5-3-qbytearray-qbytearray-fromcfdata-cfdataref-data" class="header-anchor">#</a></h3><p>构造一个包含 CFData <em>data</em> 副本的新 <a href="QByteArray.md">QByteArray</a>。</p>
<p>此功能是在 Qt 5.3 中引入的。</p>
<p><strong>也可以看看</strong> <a href="QByteArray.md#fromRawCFData">fromRawCFData</a>(), <a href="QByteArray.md#fromRawData">fromRawData</a>(), <a href="QByteArray.md#toRawCFData">toRawCFData</a>(), and <a href="QByteArray.md#toCFData">toCFData</a>().</p>
<h3><span id="static-qbytearray-qbytearray-fromhex-const-qbytearray-amp-hexencoded"><code>[static]</code> QByteArray::fromHex(const  &amp;<em>hexEncoded</em>)</span><a href="#static-qbytearray-qbytearray-fromhex-const-qbytearray-amp-hexencoded" class="header-anchor">#</a></h3><p>返回十六进制编码数组 <em>hexEncoded</em> 的解码副本。 不检查输入的有效性； 跳过输入中的无效字符，使解码过程能够继续处理后续字符。</p>
<p>For 例子：</p>
<div class="code-wrapper"><pre><code class="hljs c++">QByteArray text = QByteArray::<span class="hljs-built_in">fromHex</span>(<span class="hljs-string">"517420697320677265617421"</span>);
text.<span class="hljs-built_in">data</span>();            <span class="hljs-comment">// returns "Qt is great!"</span></code></pre></div>

<p><strong>也可以看看</strong> <a href="QByteArray.md#toHex">toHex</a>().</p>
<h3><span id="static-since-5-3-qbytearray-qbytearray-fromnsdata-const-nsdata-data"><code>[static, since 5.3]</code> QByteArray::fromNSData(const NSData *<em>data</em>)</span><a href="#static-since-5-3-qbytearray-qbytearray-fromnsdata-const-nsdata-data" class="header-anchor">#</a></h3><p>构造一个包含 NSData <em>data</em> 副本的新 <a href="QByteArray.md">QByteArray</a>。</p>
<p>此功能是在 Qt 5.3 中引入的。</p>
<p><strong>也可以看看</strong> <a href="QByteArray.md#fromRawNSData">fromRawNSData</a>(), <a href="QByteArray.md#fromRawData">fromRawData</a>(), <a href="QByteArray.md#toNSData">toNSData</a>(), and <a href="QByteArray.md#toRawNSData">toRawNSData</a>().</p>
<h3><span id="static-qbytearray-qbytearray-frompercentencoding-const-qbytearray-amp-input-char-percent"><code>[static]</code> QByteArray::fromPercentEncoding(const  &amp;<em>input</em>, char <em>percent</em> = ‘%’)</span><a href="#static-qbytearray-qbytearray-frompercentencoding-const-qbytearray-amp-input-char-percent" class="header-anchor">#</a></h3><p>返回 URI/URL 样式百分比编码的 <em>input</em> 的解码副本。 <em>percent</em> 参数允许您将 ‘%’ 字符替换为另一个字符（例如，’_’ 或 ‘=’）。</p>
<p>For 例子：</p>
<div class="code-wrapper"><pre><code class="hljs c++">QByteArray text = QByteArray::<span class="hljs-built_in">fromPercentEncoding</span>(<span class="hljs-string">"Qt%20is%20great%33"</span>);
text.<span class="hljs-built_in">data</span>();            <span class="hljs-comment">// returns "Qt is great!"</span></code></pre></div>

<p><strong>注意：</strong> 给定无效输入（例如包含序列“%G5”的字符串，它不是有效的十六进制数），输出也将无效。 举个例子：序列“%G5”可以解码为“W”。</p>
<p><strong>也可以看看</strong> <a href="QByteArray.md#toPercentEncoding">toPercentEncoding</a>() and <a target="_blank" rel="noopener" href="https://doc.qt.io/qt-6/qurl.html#fromPercentEncoding">QUrl::fromPercentEncoding</a>().</p>
<h3><span id="static-since-5-3-qbytearray-qbytearray-fromrawcfdata-cfdataref-data"><code>[static, since 5.3]</code> QByteArray::fromRawCFData(CFDataRef <em>data</em>)</span><a href="#static-since-5-3-qbytearray-qbytearray-fromrawcfdata-cfdataref-data" class="header-anchor">#</a></h3><p>构造一个使用 CFData <em>data</em> 字节的 <a href="QByteArray.md">QByteArray</a>。</p>
<p><em>data</em> 的字节不会被复制。</p>
<p>调用者保证只要这个 <a href="QByteArray.md">QByteArray</a> 对象存在，CFData 就不会被删除或修改。</p>
<p>此功能是在 Qt 5.3 中引入的。</p>
<p><strong>也可以看看</strong> <a href="QByteArray.md#fromCFData">fromCFData</a>(), <a href="QByteArray.md#fromRawData">fromRawData</a>(), <a href="QByteArray.md#toRawCFData">toRawCFData</a>(), and <a href="QByteArray.md#toCFData">toCFData</a>().</p>
<h3><span id="static-qbytearray-qbytearray-fromrawdata-const-char-data-qsizetype-size"><code>[static]</code> QByteArray::fromRawData(const char *<em>data</em>, qsizetype <em>size</em>)</span><a href="#static-qbytearray-qbytearray-fromrawdata-const-char-data-qsizetype-size" class="header-anchor">#</a></h3><p>构造一个使用 <em>data</em> 数组的前 <em>size</em> 字节的 <a href="QByteArray.md">QByteArray</a>。字节<em>不</em>复制。 <a href="QByteArray.md">QByteArray</a> 将包含 <em>data</em> 指针。调用者保证，只要这个 <a href="QByteArray.md">QByteArray</a> 和它的任何副本存在且没有被修改过，<em>data</em> 就不会被删除或修改.换句话说，因为<a href="QByteArray.md">QByteArray</a>是一个[隐式共享](<a target="_blank" rel="noopener" href="https://doc.qt.io/qt-6/implicit-">https://doc.qt.io/qt-6/implicit-</a> shared.html) 类且此函数返回的实例包含 <em>data</em> 指针，调用者不得删除 <em>data</em> 或直接修改它，只要返回 [QByteArray](<a target="_blank" rel="noopener" href="https://doc.qt.io/">https://doc.qt.io/</a> qt-6/qbytearray.html) 和任何副本都存在。但是，<a href="QByteArray.md">QByteArray</a> 不拥有 <em>data</em>，因此 [QByteArray](<a target="_blank" rel="noopener" href="https://doc.qt.io/qt">https://doc.qt.io/qt</a> -6/qbytearray.html) 析构函数永远不会删除原始 <em>data</em>，即使最后一个引用 <em>data</em> 的 <a href="QByteArray.md">QByteArray</a> 被销毁.</p>
<p>随后尝试修改返回的 <a href="QByteArray.md">QByteArray</a> 的内容或从中创建的任何副本将导致它创建 <em>data 的深层副本</em> 修改前的数组。这确保了原始 <em>data</em> 数组本身永远不会被 <a href="QByteArray.md">QByteArray</a> 修改。</p>
<p>这是一个示例，说明如何在内存中的原始数据上使用 <a target="_blank" rel="noopener" href="https://doc.qt.io/qt-6/qdatastream.html">QDataStream</a> 读取数据，而无需将原始数据复制到 [QByteArray](https ://doc.qt.io/qt-6/qbytearray.html)：</p>
<div class="code-wrapper"><pre><code class="hljs c++"> <span class="hljs-type">static</span> <span class="hljs-type">const</span> <span class="hljs-type">char</span> mydata[] = {
    <span class="hljs-string">'\x00'</span>, <span class="hljs-string">'\x00'</span>, <span class="hljs-string">'\x03'</span>, <span class="hljs-string">'\x84'</span>, <span class="hljs-string">'\x78'</span>, <span class="hljs-string">'\x9c'</span>, <span class="hljs-string">'\x3b'</span>, <span class="hljs-string">'\x76'</span>,
    <span class="hljs-string">'\xec'</span>, <span class="hljs-string">'\x18'</span>, <span class="hljs-string">'\xc3'</span>, <span class="hljs-string">'\x31'</span>, <span class="hljs-string">'\x0a'</span>, <span class="hljs-string">'\xf1'</span>, <span class="hljs-string">'\xcc'</span>, <span class="hljs-string">'\x99'</span>,
    ...
    <span class="hljs-string">'\x6d'</span>, <span class="hljs-string">'\x5b'</span>
};

QByteArray data = QByteArray::<span class="hljs-built_in">fromRawData</span>(mydata, <span class="hljs-built_in">sizeof</span>(mydata));
<span class="hljs-function">QDataStream <span class="hljs-title">in</span><span class="hljs-params">(&amp;data, QIODevice::ReadOnly)</span></span>;
...</code></pre></div>

<p><strong>警告：</strong> 使用 fromRawData() 创建的字节数组 <em>not</em> ‘\0’ 终止，除非原始数据在 <em>size</em> 位置包含 ‘\0’ 字节。 虽然这对于 <a target="_blank" rel="noopener" href="https://doc.qt.io/qt-6/qdatastream.html">QDataStream</a> 或 [indexOf](<a target="_blank" rel="noopener" href="https://doc.qt.io/qt-6/qbytearray">https://doc.qt.io/qt-6/qbytearray</a> .html#indexOf)()，将字节数组传递给一个接受“const char *”的函数，该函数应该是“\0”终止的。</p>
<p><strong>也可以看看</strong> <a href="QByteArray.md#setRawData">setRawData</a>(), <a href="QByteArray.md#data">data</a>(), and <a href="QByteArray.md#constData">constData</a>().</p>
<h3><span id="static-since-5-3-qbytearray-qbytearray-fromrawnsdata-const-nsdata-data"><code>[static, since 5.3]</code> QByteArray::fromRawNSData(const NSData *<em>data</em>)</span><a href="#static-since-5-3-qbytearray-qbytearray-fromrawnsdata-const-nsdata-data" class="header-anchor">#</a></h3><p>构造一个使用 NSData <em>data</em> 字节的 <a href="QByteArray.md">QByteArray</a>。</p>
<p><em>data</em> 的字节不会被复制。</p>
<p>调用者保证只要这个 <a href="QByteArray.md">QByteArray</a> 对象存在，NSData 就不会被删除或修改。</p>
<p>此功能是在 Qt 5.3 中引入的。</p>
<p><strong>也可以看看</strong> <a href="QByteArray.md#fromNSData">fromNSData</a>(), <a href="QByteArray.md#fromRawData">fromRawData</a>(), <a href="QByteArray.md#toRawNSData">toRawNSData</a>(), and <a href="QByteArray.md#toNSData">toNSData</a>().</p>
<h3><span id="static-since-5-4-qbytearray-qbytearray-fromstdstring-const-std-string-amp-str"><code>[static, since 5.4]</code> QByteArray::fromStdString(const std::string &amp;<em>str</em>)</span><a href="#static-since-5-4-qbytearray-qbytearray-fromstdstring-const-std-string-amp-str" class="header-anchor">#</a></h3><p>返回 <em>str</em> 字符串的副本作为 <a href="QByteArray.md">QByteArray</a>.</p>
<p>此功能是在 Qt 5.4 中引入的。</p>
<p><strong>也可以看看</strong> <a href="QByteArray.md#toStdString">toStdString</a>() and <a target="_blank" rel="noopener" href="https://doc.qt.io/qt-6/qstring.html#fromStdString">QString::fromStdString</a>().</p>
<h3><span id="since-5-10-char-qbytearray-front-const"><code>[since 5.10]</code>char QByteArray::front() const</span><a href="#since-5-10-char-qbytearray-front-const" class="header-anchor">#</a></h3><p>返回字节数组中的第一个字节。 和<code>at(0)</code>。</p>
<p>提供此功能是为了与 STL 兼容。</p>
<p><strong>警告：</strong> 在空字节数组上调用此函数构成未定义的行为。</p>
<p>此功能是在 Qt 5.10 中引入的。</p>
<p><strong>也可以看看</strong> <a href="QByteArray.md#back">back</a>(), <a href="QByteArray.md#at">at</a>(), and [operator<a href="QByteArray.md#operator-5b-5d">]</a>().</p>
<h3><span id="since-5-10-char-amp-qbytearray-front"><code>[since 5.10]</code>char &amp;QByteArray::front()</span><a href="#since-5-10-char-amp-qbytearray-front" class="header-anchor">#</a></h3><p>返回对字节数组中第一个字节的引用。 和 <code>operator[](0)</code>。</p>
<p>提供此功能是为了与 STL 兼容。</p>
<p><strong>警告：</strong> 在空字节数组上调用此函数构成未定义的行为。</p>
<p>此功能是在 Qt 5.10 中引入的。</p>
<p><strong>也可以看看</strong> <a href="QByteArray.md#back">back</a>(), <a href="QByteArray.md#at">at</a>(), and [operator<a href="QByteArray.md#operator-5b-5d">]</a>().</p>
<h3><span id="since-6-0-qsizetype-qbytearray-indexof-qbytearrayview-bv-qsizetype-from-0-const"><code>[since 6.0]</code>qsizetype QByteArray::indexOf( <em>bv</em>, qsizetype <em>from</em> = 0) const</span><a href="#since-6-0-qsizetype-qbytearray-indexof-qbytearrayview-bv-qsizetype-from-0-const" class="header-anchor">#</a></h3><p>返回此字节数组中 <em>bv</em> 查看的字节序列的第一次出现的开始的索引位置，从索引位置 <em>from</em> 向前搜索。 如果未找到匹配项，则返回 -1。</p>
<p>例子：</p>
<div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-function">QByteArray <span class="hljs-title">x</span><span class="hljs-params">(<span class="hljs-string">"sticky question"</span>)</span></span>;
<span class="hljs-function">QByteArrayView <span class="hljs-title">y</span><span class="hljs-params">(<span class="hljs-string">"sti"</span>)</span></span>;
x.<span class="hljs-built_in">indexOf</span>(y);               <span class="hljs-comment">// returns 0</span>
x.<span class="hljs-built_in">indexOf</span>(y, <span class="hljs-number">1</span>);            <span class="hljs-comment">// returns 10</span>
x.<span class="hljs-built_in">indexOf</span>(y, <span class="hljs-number">10</span>);           <span class="hljs-comment">// returns 10</span>
x.<span class="hljs-built_in">indexOf</span>(y, <span class="hljs-number">11</span>);           <span class="hljs-comment">// returns -1</span></code></pre></div>

<p>此功能是在 Qt 6.0 中引入的。</p>
<p><strong>也可以看看</strong> <a href="QByteArray.md#lastIndexOf">lastIndexOf</a>(), <a href="QByteArray.md#contains">contains</a>(), and <a href="QByteArray.md#count-2">count</a>().</p>
<h3><span id="qsizetype-qbytearray-indexof-char-ch-qsizetype-from-0-const">qsizetype QByteArray::indexOf(char <em>ch</em>, qsizetype <em>from</em> = 0) const</span><a href="#qsizetype-qbytearray-indexof-char-ch-qsizetype-from-0-const" class="header-anchor">#</a></h3><p>这是一个重载函数。</p>
<p>返回此字节数组中第一次出现字节 <em>ch</em> 的开始的索引位置，从索引位置 <em>from</em> 向前搜索。 如果未找到匹配项，则返回 -1。</p>
<p>例子：</p>
<div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-function">QByteArray <span class="hljs-title">ba</span><span class="hljs-params">(<span class="hljs-string">"ABCBA"</span>)</span></span>;
ba.<span class="hljs-built_in">indexOf</span>(<span class="hljs-string">"B"</span>);            <span class="hljs-comment">// returns 1</span>
ba.<span class="hljs-built_in">indexOf</span>(<span class="hljs-string">"B"</span>, <span class="hljs-number">1</span>);         <span class="hljs-comment">// returns 1</span>
ba.<span class="hljs-built_in">indexOf</span>(<span class="hljs-string">"B"</span>, <span class="hljs-number">2</span>);         <span class="hljs-comment">// returns 3</span>
ba.<span class="hljs-built_in">indexOf</span>(<span class="hljs-string">"X"</span>);            <span class="hljs-comment">// returns -1</span></code></pre></div>

<p><strong>也可以看看</strong> <a href="QByteArray.md#lastIndexOf">lastIndexOf</a>() and <a href="QByteArray.md#contains">contains</a>().</p>
<h3><span id="since-6-0-qbytearray-amp-qbytearray-insert-qsizetype-i-qbytearrayview-data"><code>[since 6.0]</code> &amp;QByteArray::insert(qsizetype <em>i</em>,  <em>data</em>)</span><a href="#since-6-0-qbytearray-amp-qbytearray-insert-qsizetype-i-qbytearrayview-data" class="header-anchor">#</a></h3><p>在索引位置 <em>i</em> 处插入 <em>data</em> 并返回对此字节数组的引用。</p>
<p>例子：</p>
<div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-function">QByteArray <span class="hljs-title">ba</span><span class="hljs-params">(<span class="hljs-string">"Meal"</span>)</span></span>;
ba.<span class="hljs-built_in">insert</span>(<span class="hljs-number">1</span>, <span class="hljs-built_in">QByteArrayView</span>(<span class="hljs-string">"ontr"</span>));
<span class="hljs-comment">// ba == "Montreal"</span></code></pre></div>

<p>对于大字节数组，此操作可能很慢（[线性时间]（<a target="_blank" rel="noopener" href="https://doc.qt.io/qt-6/containers.html#linear-time%EF%BC%89%EF%BC%89%EF%BC%8C%E5%9B%A0%E4%B8%BA%E5%AE%83%E9%9C%80%E8%A6%81%E7%A7%BB%E5%8A%A8%E7%B4%A2%E5%BC%95%E5%A4%84%E7%9A%84%E6%89%80%E6%9C%89%E5%AD%97%E8%8A%82">https://doc.qt.io/qt-6/containers.html#linear-time）），因为它需要移动索引处的所有字节</a>* i* 及以上至少在内存中的一个位置。</p>
<p>该数组会增长以适应插入。 如果 <em>i</em> 超出了数组的末尾，则首先用空格字符扩展数组以到达此 <em>i</em>。</p>
<p>此功能是在 Qt 6.0 中引入的。</p>
<p><strong>也可以看看</strong> <a href="QByteArray.md#append">append</a>(), <a href="QByteArray.md#prepend">prepend</a>(), <a href="QByteArray.md#replace">replace</a>(), and <a href="QByteArray.md#remove">remove</a>().</p>
<h3><span id="qbytearray-amp-qbytearray-insert-qsizetype-i-const-char-s"> &amp;QByteArray::insert(qsizetype <em>i</em>, const char *<em>s</em>)</span><a href="#qbytearray-amp-qbytearray-insert-qsizetype-i-const-char-s" class="header-anchor">#</a></h3><p>在索引位置 <em>i</em> 处插入 <em>s</em> 并返回对此字节数组的引用。</p>
<p>该数组会增长以适应插入。 如果 <em>i</em> 超出了数组的末尾，则首先用空格字符扩展数组以到达此 <em>i</em>。</p>
<p>该功能相当于<code>insert(i, QByteArrayView(s))</code></p>
<p><strong>也可以看看</strong> <a href="QByteArray.md#append">append</a>(), <a href="QByteArray.md#prepend">prepend</a>(), <a href="QByteArray.md#replace">replace</a>(), and <a href="QByteArray.md#remove">remove</a>().</p>
<h3><span id="qbytearray-amp-qbytearray-insert-qsizetype-i-const-qbytearray-amp-data"> &amp;QByteArray::insert(qsizetype <em>i</em>, const  &amp;<em>data</em>)</span><a href="#qbytearray-amp-qbytearray-insert-qsizetype-i-const-qbytearray-amp-data" class="header-anchor">#</a></h3><p>在索引位置 <em>i</em> 处插入 <em>data</em> 并返回对此字节数组的引用。</p>
<p>该数组会增长以适应插入。 如果 <em>i</em> 超出了数组的末尾，则首先用空格字符扩展数组以到达此 <em>i</em>。</p>
<p><strong>也可以看看</strong> <a href="QByteArray.md#append">append</a>(), <a href="QByteArray.md#prepend">prepend</a>(), <a href="QByteArray.md#replace">replace</a>(), and <a href="QByteArray.md#remove">remove</a>().</p>
<h3><span id="since-5-7-qbytearray-amp-qbytearray-insert-qsizetype-i-qsizetype-count-char-ch"><code>[since 5.7]</code> &amp;QByteArray::insert(qsizetype <em>i</em>, qsizetype <em>count</em>, char <em>ch</em>)</span><a href="#since-5-7-qbytearray-amp-qbytearray-insert-qsizetype-i-qsizetype-count-char-ch" class="header-anchor">#</a></h3><p>这是一个重载函数。</p>
<p>在字节数组中的索引位置 <em>i</em> 处插入 <em>count</em> 个字节 <em>ch</em> 副本。</p>
<p>该数组会增长以适应插入。 如果 <em>i</em> 超出了数组的末尾，则首先用空格字符扩展数组以到达此 <em>i</em>。</p>
<p>此功能是在 Qt 5.7 中引入的。</p>
<h3><span id="qbytearray-amp-qbytearray-insert-qsizetype-i-char-ch"> &amp;QByteArray::insert(qsizetype <em>i</em>, char <em>ch</em>)</span><a href="#qbytearray-amp-qbytearray-insert-qsizetype-i-char-ch" class="header-anchor">#</a></h3><p>这是一个重载函数。</p>
<p>在字节数组的索引位置 <em>i</em> 处插入字节 <em>ch</em>。</p>
<p>该数组会增长以适应插入。 如果 <em>i</em> 超出了数组的末尾，则首先用空格字符扩展数组以到达此 <em>i</em>。</p>
<h3><span id="qbytearray-amp-qbytearray-insert-qsizetype-i-const-char-data-qsizetype-len"> &amp;QByteArray::insert(qsizetype <em>i</em>, const char *<em>data</em>, qsizetype <em>len</em>)</span><a href="#qbytearray-amp-qbytearray-insert-qsizetype-i-const-char-data-qsizetype-len" class="header-anchor">#</a></h3><p>这是一个重载函数。</p>
<p>在字节数组中的位置 <em>i</em> 处插入 <em>len</em> 字节，从 <em>data</em> 开始。</p>
<p>该数组会增长以适应插入。 如果 <em>i</em> 超出了数组的末尾，则首先用空格字符扩展数组以到达此 <em>i</em>。</p>
<h3><span id="bool-qbytearray-isempty-const">bool QByteArray::isEmpty() const</span><a href="#bool-qbytearray-isempty-const" class="header-anchor">#</a></h3><p>如果字节数组的大小为 0，则返回 <code>true</code>； 否则返回“假”。</p>
<p>例子：</p>
<div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-built_in">QByteArray</span>().<span class="hljs-built_in">isEmpty</span>();         <span class="hljs-comment">// returns true</span>
<span class="hljs-built_in">QByteArray</span>(<span class="hljs-string">""</span>).<span class="hljs-built_in">isEmpty</span>();       <span class="hljs-comment">// returns true</span>
<span class="hljs-built_in">QByteArray</span>(<span class="hljs-string">"abc"</span>).<span class="hljs-built_in">isEmpty</span>();    <span class="hljs-comment">// returns false</span></code></pre></div>

<p><strong>也可以看看</strong> <a href="QByteArray.md#size">size</a>().</p>
<h3><span id="since-5-12-bool-qbytearray-islower-const"><code>[since 5.12]</code>bool QByteArray::isLower() const</span><a href="#since-5-12-bool-qbytearray-islower-const" class="header-anchor">#</a></h3><p>如果此字节数组仅包含小写 ASCII 字母，则返回 <code>true</code>，否则返回 <code>false</code>。</p>
<p>这个函数是在 Qt 5.12 中引入的。</p>
<p><strong>也可以看看</strong> <a href="QByteArray.md#isUpper">isUpper</a>() and <a href="QByteArray.md#toLower">toLower</a>().</p>
<h3><span id="bool-qbytearray-isnull-const">bool QByteArray::isNull() const</span><a href="#bool-qbytearray-isnull-const" class="header-anchor">#</a></h3><p>如果此字节数组为空，则返回 <code>true</code>； 否则返回<code>false</code>。</p>
<p>例子：</p>
<div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-built_in">QByteArray</span>().<span class="hljs-built_in">isNull</span>();          <span class="hljs-comment">// returns true</span>
<span class="hljs-built_in">QByteArray</span>(<span class="hljs-string">""</span>).<span class="hljs-built_in">isNull</span>();        <span class="hljs-comment">// returns false</span>
<span class="hljs-built_in">QByteArray</span>(<span class="hljs-string">"abc"</span>).<span class="hljs-built_in">isNull</span>();     <span class="hljs-comment">// returns false</span></code></pre></div>

<p>由于历史原因，Qt 对空字节数组和空字节数组进行了区分。 对于大多数应用程序来说，重要的是字节数组是否包含任何数据，这可以使用 <a href="QByteArray.md#isEmpty">isEmpty</a>() 来确定。</p>
<p><strong>也可以看看</strong> <a href="QByteArray.md#isEmpty">isEmpty</a>().</p>
<h3><span id="since-5-12-bool-qbytearray-isupper-const"><code>[since 5.12]</code>bool QByteArray::isUpper() const</span><a href="#since-5-12-bool-qbytearray-isupper-const" class="header-anchor">#</a></h3><p>如果此字节数组仅包含 ASCII 大写字母，则返回 <code>true</code>，否则返回 <code>false</code>。</p>
<p>这个函数是在 Qt 5.12 中引入的。</p>
<p><strong>也可以看看</strong> <a href="QByteArray.md#isLower">isLower</a>() and <a href="QByteArray.md#toUpper">toUpper</a>().</p>
<h3><span id="since-6-0-qbytearray-qbytearray-last-qsizetype-n-const"><code>[since 6.0]</code> QByteArray::last(qsizetype <em>n</em>) const</span><a href="#since-6-0-qbytearray-qbytearray-last-qsizetype-n-const" class="header-anchor">#</a></h3><p>返回字节数组的最后 <em>n</em> 个字节。</p>
<p><strong>注意：</strong> 当 <em>n</em> &lt; 0 或 *n* &gt; <a href="QByteArray.md#size">size</a>() 时，行为未定义。</p>
<p>例子：</p>
<div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-function">QByteArray <span class="hljs-title">x</span><span class="hljs-params">(<span class="hljs-string">"Pineapple"</span>)</span></span>;
QByteArray y = x.<span class="hljs-built_in">last</span>(<span class="hljs-number">5</span>);
<span class="hljs-comment">// y == "apple"</span></code></pre></div>

<p>此功能是在 Qt 6.0 中引入的。</p>
<p><strong>也可以看看</strong> <a href="QByteArray.md#first">first</a>(), <a href="QByteArray.md#sliced">sliced</a>(), <a href="QByteArray.md#endsWith">endsWith</a>(), <a href="QByteArray.md#chopped">chopped</a>(), <a href="QByteArray.md#chop">chop</a>(), and <a href="QByteArray.md#truncate">truncate</a>().</p>
<h3><span id="since-6-0-qsizetype-qbytearray-lastindexof-qbytearrayview-bv-qsizetype-from-const"><code>[since 6.0]</code>qsizetype QByteArray::lastIndexOf( <em>bv</em>, qsizetype <em>from</em>) const</span><a href="#since-6-0-qsizetype-qbytearray-lastindexof-qbytearrayview-bv-qsizetype-from-const" class="header-anchor">#</a></h3><p>返回此字节数组中 <em>bv</em> 查看的字节序列的最后一次出现的开始的索引位置，从索引位置 <em>from</em> 向后搜索。 如果 <em>from</em> 为 -1，则从最后一个字符开始搜索； 如果 <em>from</em> 为 -2，则在倒数第二个字符处，依此类推。 如果未找到匹配项，则返回 -1。</p>
<p>例子：</p>
<div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-function">QByteArray <span class="hljs-title">x</span><span class="hljs-params">(<span class="hljs-string">"crazy azimuths"</span>)</span></span>;
<span class="hljs-function">QByteArrayView <span class="hljs-title">y</span><span class="hljs-params">(<span class="hljs-string">"az"</span>)</span></span>;
x.<span class="hljs-built_in">lastIndexOf</span>(y);           <span class="hljs-comment">// returns 6</span>
x.<span class="hljs-built_in">lastIndexOf</span>(y, <span class="hljs-number">6</span>);        <span class="hljs-comment">// returns 6</span>
x.<span class="hljs-built_in">lastIndexOf</span>(y, <span class="hljs-number">5</span>);        <span class="hljs-comment">// returns 2</span>
x.<span class="hljs-built_in">lastIndexOf</span>(y, <span class="hljs-number">1</span>);        <span class="hljs-comment">// returns -1</span></code></pre></div>

<p><strong>注意：</strong> 当搜索长度为 0 的 <em>bv</em> 时，数据末尾的匹配会被否定的 <em>from</em> 排除在搜索之外，即使通常认为 <code>-1</code> 是从搜索开始 字节数组的末尾：末尾的匹配是<em>在</em>最后一个字符之后，因此它被排除在外。 要包含这样一个最终的空匹配，要么给 <em>from</em> 一个正值，要么完全省略 <em>from</em> 参数。</p>
<p>此功能是在 Qt 6.0 中引入的。</p>
<p><strong>也可以看看</strong> <a href="QByteArray.md#indexOf">indexOf</a>(), <a href="QByteArray.md#contains">contains</a>(), and <a href="QByteArray.md#count-2">count</a>().</p>
<h3><span id="qsizetype-qbytearray-lastindexof-char-ch-qsizetype-from-1-const">qsizetype QByteArray::lastIndexOf(char <em>ch</em>, qsizetype <em>from</em> = -1) const</span><a href="#qsizetype-qbytearray-lastindexof-char-ch-qsizetype-from-1-const" class="header-anchor">#</a></h3><p>这是一个重载函数。</p>
<p>返回此字节数组中最后一次出现字节 <em>ch</em> 的开始的索引位置，从索引位置 <em>from</em> 向后搜索。 如果 <em>from</em> 为 -1（默认值），则搜索从最后一个字节开始（索引 <a href="QByteArray.md#size">size</a>() - 1 ）。 如果未找到匹配项，则返回 -1。</p>
<p>例子：</p>
<div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-function">QByteArray <span class="hljs-title">ba</span><span class="hljs-params">(<span class="hljs-string">"ABCBA"</span>)</span></span>;
ba.<span class="hljs-built_in">lastIndexOf</span>(<span class="hljs-string">"B"</span>);        <span class="hljs-comment">// returns 3</span>
ba.<span class="hljs-built_in">lastIndexOf</span>(<span class="hljs-string">"B"</span>, <span class="hljs-number">3</span>);     <span class="hljs-comment">// returns 3</span>
ba.<span class="hljs-built_in">lastIndexOf</span>(<span class="hljs-string">"B"</span>, <span class="hljs-number">2</span>);     <span class="hljs-comment">// returns 1</span>
ba.<span class="hljs-built_in">lastIndexOf</span>(<span class="hljs-string">"X"</span>);        <span class="hljs-comment">// returns -1</span></code></pre></div>

<p><strong>也可以看看</strong> <a href="QByteArray.md#indexOf">indexOf</a>() and <a href="QByteArray.md#contains">contains</a>().</p>
<h3><span id="since-6-2-qsizetype-qbytearray-lastindexof-qbytearrayview-bv-const"><code>[since 6.2]</code>qsizetype QByteArray::lastIndexOf( <em>bv</em>) const</span><a href="#since-6-2-qsizetype-qbytearray-lastindexof-qbytearrayview-bv-const" class="header-anchor">#</a></h3><p>这是一个重载函数。</p>
<p>返回此字节数组中 <em>bv</em> 查看的字节序列的最后一次出现的开始的索引位置，从字节数组的末尾向后搜索。 如果未找到匹配项，则返回 -1。</p>
<p>例子：</p>
<div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-function">QByteArray <span class="hljs-title">x</span><span class="hljs-params">(<span class="hljs-string">"crazy azimuths"</span>)</span></span>;
<span class="hljs-function">QByteArrayView <span class="hljs-title">y</span><span class="hljs-params">(<span class="hljs-string">"az"</span>)</span></span>;
x.<span class="hljs-built_in">lastIndexOf</span>(y);           <span class="hljs-comment">// returns 6</span>
x.<span class="hljs-built_in">lastIndexOf</span>(y, <span class="hljs-number">6</span>);        <span class="hljs-comment">// returns 6</span>
x.<span class="hljs-built_in">lastIndexOf</span>(y, <span class="hljs-number">5</span>);        <span class="hljs-comment">// returns 2</span>
x.<span class="hljs-built_in">lastIndexOf</span>(y, <span class="hljs-number">1</span>);        <span class="hljs-comment">// returns -1</span></code></pre></div>

<p>此功能是在 Qt 6.2 中引入的。</p>
<p><strong>也可以看看</strong> <a href="QByteArray.md#indexOf">indexOf</a>(), <a href="QByteArray.md#contains">contains</a>(), and <a href="QByteArray.md#count-2">count</a>().</p>
<h3><span id="qbytearray-qbytearray-left-qsizetype-len-const"> QByteArray::left(qsizetype <em>len</em>) const</span><a href="#qbytearray-qbytearray-left-qsizetype-len-const" class="header-anchor">#</a></h3><p>返回一个字节数组，其中包含此字节数组的前 <em>len</em> 个字节。</p>
<p>如果您知道 <em>len</em> 不能越界，请在新代码中使用 <a href="QByteArray.md#first">first</a>() 代替，因为它更快。</p>
<p>如果 <em>len</em> 大于 <a href="QByteArray.md#size">size</a>()，则返回整个字节数组。</p>
<p>如果 <em>len</em> 小于 0，则返回一个空的 <a href="QByteArray.md">QByteArray</a>。</p>
<p><strong>也可以看看</strong> <a href="QByteArray.md#first">first</a>(), <a href="QByteArray.md#last">last</a>(), <a href="QByteArray.md#startsWith">startsWith</a>(), <a href="QByteArray.md#chopped">chopped</a>(), <a href="QByteArray.md#chop">chop</a>(), and <a href="QByteArray.md#truncate">truncate</a>().</p>
<h3><span id="qbytearray-qbytearray-leftjustified-qsizetype-width-char-fill-bool-truncate-false-const"> QByteArray::leftJustified(qsizetype <em>width</em>, char <em>fill</em> = ‘ ‘, bool <em>truncate</em> = false) const</span><a href="#qbytearray-qbytearray-leftjustified-qsizetype-width-char-fill-bool-truncate-false-const" class="header-anchor">#</a></h3><p>返回一个大小为 <em>width</em> 的字节数组，其中包含用 <em>fill</em> 字节填充的字节数组。</p>
<p>如果 <em>truncate</em> 为 false 且字节数组的 <a href="QByteArray.md#size">size</a>() 大于 <em>width</em>，则返回字节数组 是此字节数组的副本。</p>
<p>如果 <em>truncate</em> 为真且字节数组的 <a href="QByteArray.md#size">size</a>() 大于 <em>width</em>，则 删除位置 <em>width</em> 后的字节数组副本，并返回副本。</p>
<p>例子：</p>
<div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-function">QByteArray <span class="hljs-title">x</span><span class="hljs-params">(<span class="hljs-string">"apple"</span>)</span></span>;
QByteArray y = x.<span class="hljs-built_in">leftJustified</span>(<span class="hljs-number">8</span>, <span class="hljs-string">'.'</span>);   <span class="hljs-comment">// y == "apple..."</span></code></pre></div>

<p><strong>也可以看看</strong> <a href="QByteArray.md#rightJustified">rightJustified</a>().</p>
<h3><span id="qsizetype-qbytearray-length-const">qsizetype QByteArray::length() const</span><a href="#qsizetype-qbytearray-length-const" class="header-anchor">#</a></h3><p>和 <a href="QByteArray.md#size">size</a>().</p>
<h3><span id="qbytearray-qbytearray-mid-qsizetype-pos-qsizetype-len-1-const"> QByteArray::mid(qsizetype <em>pos</em>, qsizetype <em>len</em> = -1) const</span><a href="#qbytearray-qbytearray-mid-qsizetype-pos-qsizetype-len-1-const" class="header-anchor">#</a></h3><p>从该字节数组中返回一个包含 <em>len</em> 个字节的字节数组，从位置 <em>pos</em> 开始。</p>
<p>如果您知道 <em>pos</em> 和 <em>len</em> 不能越界，请在新代码中使用 <a href="QByteArray.md#sliced">sliced</a>()，因为 它更快。</p>
<p>如果 <em>len</em> 为 -1（默认值），或 <em>pos</em> + <em>len</em> &gt;= <a href="QByteArray.md#size">size</a>()，则返回 一个字节数组，包含从位置 <em>pos</em> 到字节数组末尾的所有字节。</p>
<p><strong>也可以看看</strong> <a href="QByteArray.md#first">first</a>(), <a href="QByteArray.md#last">last</a>(), <a href="QByteArray.md#sliced">sliced</a>(), <a href="QByteArray.md#chopped">chopped</a>(), <a href="QByteArray.md#chop">chop</a>(), and <a href="QByteArray.md#truncate">truncate</a>().</p>
<h3><span id="static-qbytearray-qbytearray-number-int-n-int-base-10"><code>[static]</code> QByteArray::number(int <em>n</em>, int <em>base</em> = 10)</span><a href="#static-qbytearray-qbytearray-number-int-n-int-base-10" class="header-anchor">#</a></h3><p>返回一个字节数组，将整数 <em>n</em> 表示为文本。</p>
<p>返回一个字节数组，其中包含一个表示 <em>n</em> 的字符串，使用指定的 <em>base</em>（默认为 10）。 支持以 2 到 36 为基数，对 9 以外的数字使用字母：A 是 10，B 是 11，依此类推。</p>
<p>例子：</p>
<div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-type">int</span> n = <span class="hljs-number">63</span>;
QByteArray::<span class="hljs-built_in">number</span>(n);              <span class="hljs-comment">// returns "63"</span>
QByteArray::<span class="hljs-built_in">number</span>(n, <span class="hljs-number">16</span>);          <span class="hljs-comment">// returns "3f"</span>
QByteArray::<span class="hljs-built_in">number</span>(n, <span class="hljs-number">16</span>).<span class="hljs-built_in">toUpper</span>();  <span class="hljs-comment">// returns "3F"</span></code></pre></div>

<p><strong>注：</strong>号码格式未本地化； 无论用户的语言环境如何，都会使用默认的 C 语言环境。 使用 <a target="_blank" rel="noopener" href="https://doc.qt.io/qt-6/qlocale.html">QLocale</a> 在数字和字符串之间执行区域感知转换。</p>
<p><strong>也可以看看</strong> <a href="QByteArray.md#setNum">setNum</a>() and <a href="QByteArray.md#toInt">toInt</a>().</p>
<h3><span id="static-qbytearray-qbytearray-number-uint-n-int-base-10"><code>[static]</code> QByteArray::number( <em>n</em>, int <em>base</em> = 10)</span><a href="#static-qbytearray-qbytearray-number-uint-n-int-base-10" class="header-anchor">#</a></h3><p>这是一个重载函数。</p>
<p><strong>也可以看看</strong> <a href="QByteArray.md#toUInt">toUInt</a>().</p>
<h3><span id="static-qbytearray-qbytearray-number-long-n-int-base-10"><code>[static]</code> QByteArray::number(long <em>n</em>, int <em>base</em> = 10)</span><a href="#static-qbytearray-qbytearray-number-long-n-int-base-10" class="header-anchor">#</a></h3><p>这是一个重载函数。</p>
<p><strong>也可以看看</strong> <a href="QByteArray.md#toLong">toLong</a>().</p>
<h3><span id="static-qbytearray-qbytearray-number-ulong-n-int-base-10"><code>[static]</code> QByteArray::number( <em>n</em>, int <em>base</em> = 10)</span><a href="#static-qbytearray-qbytearray-number-ulong-n-int-base-10" class="header-anchor">#</a></h3><p>这是一个重载函数。</p>
<p><strong>也可以看看</strong> <a href="QByteArray.md#toULong">toULong</a>().</p>
<h3><span id="static-qbytearray-qbytearray-number-qlonglong-n-int-base-10"><code>[static]</code> QByteArray::number( <em>n</em>, int <em>base</em> = 10)</span><a href="#static-qbytearray-qbytearray-number-qlonglong-n-int-base-10" class="header-anchor">#</a></h3><p>这是一个重载函数。</p>
<p><strong>也可以看看</strong> <a href="QByteArray.md#toLongLong">toLongLong</a>().</p>
<h3><span id="static-qbytearray-qbytearray-number-qulonglong-n-int-base-10"><code>[static]</code> QByteArray::number( <em>n</em>, int <em>base</em> = 10)</span><a href="#static-qbytearray-qbytearray-number-qulonglong-n-int-base-10" class="header-anchor">#</a></h3><p>这是一个重载函数。</p>
<p><strong>也可以看看</strong> <a href="QByteArray.md#toULongLong">toULongLong</a>().</p>
<h3><span id="static-qbytearray-qbytearray-number-double-n-char-format-g-int-precision-6"><code>[static]</code> QByteArray::number(double <em>n</em>, char <em>format</em> = ‘g’, int <em>precision</em> = 6)</span><a href="#static-qbytearray-qbytearray-number-double-n-char-format-g-int-precision-6" class="header-anchor">#</a></h3><p>这是一个重载函数。</p>
<p>返回一个字节数组，将浮点数 <em>n</em> 表示为文本。</p>
<p>返回一个字节数组，其中包含一个表示 <em>n</em> 的字符串，具有给定的 <em>format</em> 和 <em>precision</em>，与 [QString::number] 的含义相同（<a target="_blank" rel="noopener" href="https://doc.qt.io/qt-6/">https://doc.qt.io/qt-6/</a> qstring.html#number-6)(double, char, int)。 例如：</p>
<div class="code-wrapper"><pre><code class="hljs c++">QByteArray ba = QByteArray::<span class="hljs-built_in">number</span>(<span class="hljs-number">12.3456</span>, <span class="hljs-string">'E'</span>, <span class="hljs-number">3</span>);
<span class="hljs-comment">// ba == 1.235E+01</span></code></pre></div>

<p><strong>也可以看看</strong> <a href="QByteArray.md#toDouble">toDouble</a>() and <a target="_blank" rel="noopener" href="https://doc.qt.io/qt-6/qlocale.html#FloatingPointPrecisionOption-enum">QLocale::FloatingPointPrecisionOption</a>.</p>
<h3><span id="qbytearray-amp-qbytearray-prepend-qbytearrayview-ba"> &amp;QByteArray::prepend( <em>ba</em>)</span><a href="#qbytearray-amp-qbytearray-prepend-qbytearrayview-ba" class="header-anchor">#</a></h3><p>将字节数组视图 <em>ba</em> 添加到此字节数组并返回对此字节数组的引用。</p>
<p>这个操作通常非常快（[常量时间]（<a target="_blank" rel="noopener" href="https://doc.qt.io/qt-6/containers.html#constant-time%EF%BC%89%EF%BC%89%EF%BC%8C%E5%9B%A0%E4%B8%BA[QByteArray]%EF%BC%88https://doc.qt.io">https://doc.qt.io/qt-6/containers.html#constant-time）），因为[QByteArray]（https://doc.qt.io</a> /qt-6/qbytearray.html) 在数据的开头预先分配额外的空间，因此它可以增长而无需每次都重新分配整个数组。</p>
<p>例子：</p>
<div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-function">QByteArray <span class="hljs-title">x</span><span class="hljs-params">(<span class="hljs-string">"ship"</span>)</span></span>;
<span class="hljs-function">QByteArray <span class="hljs-title">y</span><span class="hljs-params">(<span class="hljs-string">"air"</span>)</span></span>;
x.<span class="hljs-built_in">prepend</span>(y);
<span class="hljs-comment">// x == "airship"</span></code></pre></div>

<p>这与 insert(0, <em>ba</em>) 相同。</p>
<p><strong>也可以看看</strong> <a href="QByteArray.md#append">append</a>() and <a href="QByteArray.md#insert">insert</a>().</p>
<h3><span id="qbytearray-amp-qbytearray-prepend-char-ch"> &amp;QByteArray::prepend(char <em>ch</em>)</span><a href="#qbytearray-amp-qbytearray-prepend-char-ch" class="header-anchor">#</a></h3><p>这是一个重载函数。</p>
<p>将字节 <em>ch</em> 添加到此字节数组。</p>
<h3><span id="since-5-7-qbytearray-amp-qbytearray-prepend-qsizetype-count-char-ch"><code>[since 5.7]</code> &amp;QByteArray::prepend(qsizetype <em>count</em>, char <em>ch</em>)</span><a href="#since-5-7-qbytearray-amp-qbytearray-prepend-qsizetype-count-char-ch" class="header-anchor">#</a></h3><p>这是一个重载函数。</p>
<p>将字节 <em>ch</em> 的 <em>count</em> 个副本添加到此字节数组中。</p>
<p>此功能是在 Qt 5.7 中引入的。</p>
<h3><span id="qbytearray-amp-qbytearray-prepend-const-char-str"> &amp;QByteArray::prepend(const char *<em>str</em>)</span><a href="#qbytearray-amp-qbytearray-prepend-const-char-str" class="header-anchor">#</a></h3><p>这是一个重载函数。</p>
<p>将 ‘\0’ 终止的字符串 <em>str</em> 添加到此字节数组。</p>
<h3><span id="qbytearray-amp-qbytearray-prepend-const-char-str-qsizetype-len"> &amp;QByteArray::prepend(const char *<em>str</em>, qsizetype <em>len</em>)</span><a href="#qbytearray-amp-qbytearray-prepend-const-char-str-qsizetype-len" class="header-anchor">#</a></h3><p>这是一个重载函数。</p>
<p>将从 <em>str</em> 开始的 <em>len</em> 字节添加到此字节数组。 前置字节可能包括`\0”字节。</p>
<h3><span id="qbytearray-amp-qbytearray-prepend-const-qbytearray-amp-ba"> &amp;QByteArray::prepend(const  &amp;<em>ba</em>)</span><a href="#qbytearray-amp-qbytearray-prepend-const-qbytearray-amp-ba" class="header-anchor">#</a></h3><p>这是一个重载函数。</p>
<p>将 <em>ba</em> 添加到此字节数组。</p>
<h3><span id="void-qbytearray-push-back-const-qbytearray-amp-other">void QByteArray::push_back(const  &amp;<em>other</em>)</span><a href="#void-qbytearray-push-back-const-qbytearray-amp-other" class="header-anchor">#</a></h3><p>提供此功能是为了与 STL 兼容。 它等价于 append(<em>other</em>)。</p>
<h3><span id="void-qbytearray-push-back-char-ch">void QByteArray::push_back(char <em>ch</em>)</span><a href="#void-qbytearray-push-back-char-ch" class="header-anchor">#</a></h3><p>这是一个重载函数。</p>
<p>和 append(<em>ch</em>)  一样. </p>
<h3><span id="void-qbytearray-push-back-const-char-str">void QByteArray::push_back(const char *<em>str</em>)</span><a href="#void-qbytearray-push-back-const-char-str" class="header-anchor">#</a></h3><p>这是一个重载函数。</p>
<p>和 append(<em>str</em>) 一样.</p>
<h3><span id="since-6-0-void-qbytearray-push-back-qbytearrayview-str"><code>[since 6.0]</code>void QByteArray::push_back( <em>str</em>)</span><a href="#since-6-0-void-qbytearray-push-back-qbytearrayview-str" class="header-anchor">#</a></h3><p>这是一个重载函数。</p>
<p>和 append(<em>str</em>) 一样.</p>
<p>此功能是在 Qt 6.0 中引入的。</p>
<h3><span id="void-qbytearray-push-front-const-qbytearray-amp-other">void QByteArray::push_front(const  &amp;<em>other</em>)</span><a href="#void-qbytearray-push-front-const-qbytearray-amp-other" class="header-anchor">#</a></h3><p>提供此功能是为了与 STL 兼容。 它相当于 prepend(<em>other</em>)。</p>
<h3><span id="void-qbytearray-push-front-char-ch">void QByteArray::push_front(char <em>ch</em>)</span><a href="#void-qbytearray-push-front-char-ch" class="header-anchor">#</a></h3><p>这是一个重载函数。</p>
<p>和 prepend(<em>ch</em>) 一样.</p>
<h3><span id="void-qbytearray-push-front-const-char-str">void QByteArray::push_front(const char *<em>str</em>)</span><a href="#void-qbytearray-push-front-const-char-str" class="header-anchor">#</a></h3><p>这是一个重载函数。</p>
<p>和 prepend(<em>str</em>) 一样.</p>
<h3><span id="since-6-0-void-qbytearray-push-front-qbytearrayview-str"><code>[since 6.0]</code>void QByteArray::push_front( <em>str</em>)</span><a href="#since-6-0-void-qbytearray-push-front-qbytearrayview-str" class="header-anchor">#</a></h3><p>这是一个重载函数。</p>
<p>和 prepend(<em>str</em>) 一样.</p>
<p>此功能是在 Qt 6.0 中引入的。</p>
<h3><span id="since-5-6-qbytearray-reverse-iterator-qbytearray-rbegin"><code>[since 5.6]</code> QByteArray::rbegin()</span><a href="#since-5-6-qbytearray-reverse-iterator-qbytearray-rbegin" class="header-anchor">#</a></h3><p>返回一个 <a target="_blank" rel="noopener" href="https://doc.qt.io/qt-6/containers.html#stl-style-iterators">STL-style</a> 反向迭代器，以相反的顺序指向字节数组中的第一个字节。</p>
<p><strong>警告：</strong> 返回的迭代器在分离或修改 <a href="QByteArray.md">QByteArray</a> 时失效。</p>
<p>此功能是在 Qt 5.6 中引入的。</p>
<p><strong>也可以看看</strong> <a href="QByteArray.md#begin">begin</a>(), <a href="QByteArray.md#crbegin">crbegin</a>(), and <a href="QByteArray.md#rend">rend</a>().</p>
<h3><span id="since-5-6-qbytearray-const-reverse-iterator-qbytearray-rbegin-const"><code>[since 5.6]</code> QByteArray::rbegin() const</span><a href="#since-5-6-qbytearray-const-reverse-iterator-qbytearray-rbegin-const" class="header-anchor">#</a></h3><p>这是一个重载函数。</p>
<p>此功能是在 Qt 5.6 中引入的。</p>
<h3><span id="qbytearray-amp-qbytearray-remove-qsizetype-pos-qsizetype-len"> &amp;QByteArray::remove(qsizetype <em>pos</em>, qsizetype <em>len</em>)</span><a href="#qbytearray-amp-qbytearray-remove-qsizetype-pos-qsizetype-len" class="header-anchor">#</a></h3><p>从数组中删除 <em>len</em> 字节，从索引位置 <em>pos</em> 开始，并返回对数组的引用。</p>
<p>如果 <em>pos</em> 超出范围，则不会发生任何事情。 如果 <em>pos</em> 有效，但 <em>pos</em> + <em>len</em> 大于数组的大小，则数组在位置 <em>pos</em> 处被截断。</p>
<p>例子：</p>
<div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-function">QByteArray <span class="hljs-title">ba</span><span class="hljs-params">(<span class="hljs-string">"Montreal"</span>)</span></span>;
ba.<span class="hljs-built_in">remove</span>(<span class="hljs-number">1</span>, <span class="hljs-number">4</span>);
<span class="hljs-comment">// ba == "Meal"</span></code></pre></div>

<p>元素删除将保留数组的容量，并且不会减少分配的内存量。 要减少额外容量并释放尽可能多的内存，请在最后一次更改数组大小后调用 <a href="QByteArray.md#squeeze">squeeze</a>()。</p>
<p><strong>也可以看看</strong> <a href="QByteArray.md#insert">insert</a>(), <a href="QByteArray.md#replace">replace</a>(), and <a href="QByteArray.md#squeeze">squeeze</a>().</p>
<h3><span id="since-6-1-template-qbytearray-amp-qbytearray-removeif-predicate-pred"><code>[since 6.1]</code>template <typename predicate> <a href="QByteArray.md#QByteArray">QByteArray</a> &amp;QByteArray::removeIf(Predicate <em>pred</em>)</typename></span><a href="#since-6-1-template-qbytearray-amp-qbytearray-removeif-predicate-pred" class="header-anchor">#</a></h3><p>从字节数组中删除谓词 <em>pred</em> 返回 true 的所有字节。 返回对字节数组的引用。</p>
<p>此功能是在 Qt 6.1 中引入的。</p>
<p><strong>也可以看看</strong> <a href="QByteArray.md#remove">remove</a>().</p>
<h3><span id="since-5-6-qbytearray-reverse-iterator-qbytearray-rend"><code>[since 5.6]</code> QByteArray::rend()</span><a href="#since-5-6-qbytearray-reverse-iterator-qbytearray-rend" class="header-anchor">#</a></h3><p>返回一个 <a target="_blank" rel="noopener" href="https://doc.qt.io/qt-6/containers.html#stl-style-iterators">STL-style</a> 反向迭代器，以相反的顺序指向字节数组中最后一个字节之后。</p>
<p><strong>警告：</strong> 返回的迭代器在分离或修改 <a href="QByteArray.md">QByteArray</a> 时失效。</p>
<p>此功能是在 Qt 5.6 中引入的。</p>
<p><strong>也可以看看</strong> <a href="QByteArray.md#end">end</a>(), <a href="QByteArray.md#crend">crend</a>(), and <a href="QByteArray.md#rbegin">rbegin</a>().</p>
<h3><span id="since-5-6-qbytearray-const-reverse-iterator-qbytearray-rend-const"><code>[since 5.6]</code> QByteArray::rend() const</span><a href="#since-5-6-qbytearray-const-reverse-iterator-qbytearray-rend-const" class="header-anchor">#</a></h3><p>这是一个重载函数。</p>
<p>此功能是在 Qt 5.6 中引入的。</p>
<h3><span id="qbytearray-qbytearray-repeated-qsizetype-times-const"> QByteArray::repeated(qsizetype <em>times</em>) const</span><a href="#qbytearray-qbytearray-repeated-qsizetype-times-const" class="header-anchor">#</a></h3><p>返回此字节数组的副本，重复指定次数<em>次</em>。</p>
<p>如果 <em>times</em> 小于 1，则返回一个空字节数组。</p>
<p>例子：</p>
<div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-function">QByteArray <span class="hljs-title">ba</span><span class="hljs-params">(<span class="hljs-string">"ab"</span>)</span></span>;
ba.<span class="hljs-built_in">repeated</span>(<span class="hljs-number">4</span>);             <span class="hljs-comment">// returns "abababab"</span></code></pre></div>

<h3><span id="qbytearray-amp-qbytearray-replace-qsizetype-pos-qsizetype-len-qbytearrayview-after"> &amp;QByteArray::replace(qsizetype <em>pos</em>, qsizetype <em>len</em>,  <em>after</em>)</span><a href="#qbytearray-amp-qbytearray-replace-qsizetype-pos-qsizetype-len-qbytearrayview-after" class="header-anchor">#</a></h3><p>将索引位置 <em>pos</em> 中的 <em>len</em> 个字节替换为 <em>after</em> 字节数组，并返回对该字节数组的引用。</p>
<p>例子：</p>
<div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-function">QByteArray <span class="hljs-title">x</span><span class="hljs-params">(<span class="hljs-string">"Say yes!"</span>)</span></span>;
<span class="hljs-function">QByteArray <span class="hljs-title">y</span><span class="hljs-params">(<span class="hljs-string">"no"</span>)</span></span>;
x.<span class="hljs-built_in">replace</span>(<span class="hljs-number">4</span>, <span class="hljs-number">3</span>, y);
<span class="hljs-comment">// x == "Say no!"</span></code></pre></div>

<p><strong>也可以看看</strong> <a href="QByteArray.md#insert">insert</a>() and <a href="QByteArray.md#remove">remove</a>().</p>
<h3><span id="qbytearray-amp-qbytearray-replace-qsizetype-pos-qsizetype-len-const-char-after-qsizetype-alen"> &amp;QByteArray::replace(qsizetype <em>pos</em>, qsizetype <em>len</em>, const char *<em>after</em>, qsizetype <em>alen</em>)</span><a href="#qbytearray-amp-qbytearray-replace-qsizetype-pos-qsizetype-len-const-char-after-qsizetype-alen" class="header-anchor">#</a></h3><p>这是一个重载函数。</p>
<p>将索引位置 <em>pos</em> 中的 <em>len</em> 字节替换为从 <em>after</em> 位置开始的 <em>alen</em> 字节。 插入的字节可能包括`\0”字节。</p>
<h3><span id="qbytearray-amp-qbytearray-replace-char-before-qbytearrayview-after"> &amp;QByteArray::replace(char <em>before</em>,  <em>after</em>)</span><a href="#qbytearray-amp-qbytearray-replace-char-before-qbytearrayview-after" class="header-anchor">#</a></h3><p>这是一个重载函数。</p>
<p>将每个出现的字节 <em>before</em> 替换为字节数组 <em>after</em>。</p>
<h3><span id="qbytearray-amp-qbytearray-replace-const-char-before-qsizetype-bsize-const-char-after-qsizetype-asize"> &amp;QByteArray::replace(const char *<em>before</em>, qsizetype <em>bsize</em>, const char *<em>after</em>, qsizetype <em>asize</em>)</span><a href="#qbytearray-amp-qbytearray-replace-const-char-before-qsizetype-bsize-const-char-after-qsizetype-asize" class="header-anchor">#</a></h3><p>这是一个重载函数。</p>
<p>用从 <em>after</em> 开始的 <em>asize</em> 字节替换每次出现的 <em>bsize</em> 字节，从 <em>before</em> 开始。 由于字符串的大小由 <em>bsize</em> 和 <em>asize</em> 给出，它们可能包含 ‘\0’ 字节并且不需要以 ‘\0’ 结尾。</p>
<h3><span id="since-6-0-qbytearray-amp-qbytearray-replace-qbytearrayview-before-qbytearrayview-after"><code>[since 6.0]</code> &amp;QByteArray::replace( <em>before</em>,  <em>after</em>)</span><a href="#since-6-0-qbytearray-amp-qbytearray-replace-qbytearrayview-before-qbytearrayview-after" class="header-anchor">#</a></h3><p>这是一个重载函数。</p>
<p>用字节数组 <em>after</em> 替换每次出现的字节数组 <em>before</em>。</p>
<p>例子：</p>
<div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-function">QByteArray <span class="hljs-title">ba</span><span class="hljs-params">(<span class="hljs-string">"colour behaviour flavour neighbour"</span>)</span></span>;
ba.<span class="hljs-built_in">replace</span>(<span class="hljs-built_in">QByteArray</span>(<span class="hljs-string">"ou"</span>), <span class="hljs-built_in">QByteArray</span>(<span class="hljs-string">"o"</span>));
<span class="hljs-comment">// ba == "color behavior flavor neighbor"</span></code></pre></div>

<p>此功能是在 Qt 6.0 中引入的。</p>
<h3><span id="qbytearray-amp-qbytearray-replace-char-before-char-after"> &amp;QByteArray::replace(char <em>before</em>, char <em>after</em>)</span><a href="#qbytearray-amp-qbytearray-replace-char-before-char-after" class="header-anchor">#</a></h3><p>这是一个重载函数。</p>
<p>用字节 <em>after</em> 替换每个出现的字节 <em>before</em>。</p>
<h3><span id="void-qbytearray-reserve-qsizetype-size">void QByteArray::reserve(qsizetype <em>size</em>)</span><a href="#void-qbytearray-reserve-qsizetype-size" class="header-anchor">#</a></h3><p>尝试为至少 <em>size</em> 字节分配内存。</p>
<p>如果你提前知道字节数组会有多大，你可以调用这个函数，如果你经常调用<a href="QByteArray.md#resize">resize</a>()你很可能会得到更好的表现。</p>
<p>如果对需要多少空间存有疑问，通常最好使用<em>size</em> 的上限，或对最可能大小的高度估计，如果严格的上限比这大得多。如果 <em>size</em> 被低估，一旦超过保留大小，数组将根据需要增长，这可能导致分配比您最好的高估更大，并且会减慢触发它的操作。</p>
<p><strong>警告：</strong> reserve() 保留内存但不会更改字节数组的大小。访问超出字节数组末尾的数据是未定义的行为。如果您需要访问超出数组当前末尾的内存，请使用 <a href="QByteArray.md#resize">resize</a>()。</p>
<p>该函数的唯一目的是提供一种微调 <a href="QByteArray.md">QByteArray</a> 的内存使用的方法。通常，您很少需要调用此函数。</p>
<p><strong>也可以看看</strong> <a href="QByteArray.md#squeeze">squeeze</a>() and <a href="QByteArray.md#capacity">capacity</a>().</p>
<h3><span id="void-qbytearray-resize-qsizetype-size">void QByteArray::resize(qsizetype <em>size</em>)</span><a href="#void-qbytearray-resize-qsizetype-size" class="header-anchor">#</a></h3><p>将字节数组的大小设置为 <em>size</em> 字节。</p>
<p>如果 <em>size</em> 大于当前大小，则扩展字节数组以使其成为 <em>size</em> 字节，并将额外的字节添加到末尾。 新字节未初始化。</p>
<p>如果 <em>size</em> 小于当前大小，超出位置 <em>size</em> 的字节将从字节数组中排除。</p>
<p><strong>注意：</strong> 虽然 resize() 会在需要时增加容量，但它永远不会缩小容量。 要消除多余的容量，请使用 <a href="QByteArray.md#squeeze">squeeze</a>()。</p>
<p><strong>也可以看看</strong> <a href="QByteArray.md#size">size</a>(), <a href="QByteArray.md#truncate">truncate</a>(), and <a href="QByteArray.md#squeeze">squeeze</a>().</p>
<h3><span id="qbytearray-qbytearray-right-qsizetype-len-const"> QByteArray::right(qsizetype <em>len</em>) const</span><a href="#qbytearray-qbytearray-right-qsizetype-len-const" class="header-anchor">#</a></h3><p>返回一个字节数组，其中包含此字节数组的最后 <em>len</em> 个字节。</p>
<p>如果您知道 <em>len</em> 不能越界，请在新代码中使用 <a href="QByteArray.md#last">last</a>() 代替，因为它更快。</p>
<p>如果 <em>len</em> 大于 <a href="QByteArray.md#size">size</a>()，则返回整个字节数组。</p>
<p>如果 <em>len</em> 小于 0，则返回一个空的 <a href="QByteArray.md">QByteArray</a>。</p>
<p><strong>也可以看看</strong> <a href="QByteArray.md#endsWith">endsWith</a>(), <a href="QByteArray.md#last">last</a>(), <a href="QByteArray.md#first">first</a>(), <a href="QByteArray.md#sliced">sliced</a>(), <a href="QByteArray.md#chopped">chopped</a>(), <a href="QByteArray.md#chop">chop</a>(), and <a href="QByteArray.md#truncate">truncate</a>().</p>
<h3><span id="qbytearray-qbytearray-rightjustified-qsizetype-width-char-fill-bool-truncate-false-const"> QByteArray::rightJustified(qsizetype <em>width</em>, char <em>fill</em> = ‘ ‘, bool <em>truncate</em> = false) const</span><a href="#qbytearray-qbytearray-rightjustified-qsizetype-width-char-fill-bool-truncate-false-const" class="header-anchor">#</a></h3><p>返回大小为 <em>width</em> 的字节数组，其中包含 <em>fill</em> 字节，后跟此字节数组。</p>
<p>如果 <em>truncate</em> 为 false 并且字节数组的大小大于 <em>width</em>，则返回的字节数组是该字节数组的副本。</p>
<p>如果 <em>truncate</em> 为真并且字节数组的大小大于 <em>width</em>，则生成的字节数组在位置 <em>width</em> 处被截断。</p>
<p>例子：</p>
<div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-function">QByteArray <span class="hljs-title">x</span><span class="hljs-params">(<span class="hljs-string">"apple"</span>)</span></span>;
QByteArray y = x.<span class="hljs-built_in">rightJustified</span>(<span class="hljs-number">8</span>, <span class="hljs-string">'.'</span>);    <span class="hljs-comment">// y == "...apple"</span></code></pre></div>

<p><strong>也可以看看</strong> <a href="QByteArray.md#leftJustified">leftJustified</a>().</p>
<h3><span id="qbytearray-amp-qbytearray-setnum-int-n-int-base-10"> &amp;QByteArray::setNum(int <em>n</em>, int <em>base</em> = 10)</span><a href="#qbytearray-amp-qbytearray-setnum-int-n-int-base-10" class="header-anchor">#</a></h3><p>将整数 <em>n</em> 表示为文本。</p>
<p>将此字节数组设置为表示基数 <em>base</em> 中的 <em>n</em> 的字符串（默认为 10）并返回对此字节数组的引用。 支持以 2 到 36 为基数，超过 9 的数字使用字母； A 是 10，B 是 11，依此类推。</p>
<p>例子：</p>
<div class="code-wrapper"><pre><code class="hljs c++">QByteArray ba;
<span class="hljs-type">int</span> n = <span class="hljs-number">63</span>;
ba.<span class="hljs-built_in">setNum</span>(n);           <span class="hljs-comment">// ba == "63"</span>
ba.<span class="hljs-built_in">setNum</span>(n, <span class="hljs-number">16</span>);       <span class="hljs-comment">// ba == "3f"</span></code></pre></div>

<p><strong>注意：</strong>号码格式未本地化； 无论用户的语言环境如何，都会使用默认的 C 语言环境。 使用 <a target="_blank" rel="noopener" href="https://doc.qt.io/qt-6/qlocale.html">QLocale</a> 在数字和字符串之间执行区域感知转换。</p>
<p><strong>也可以看看</strong> <a href="QByteArray.md#number">number</a>() and <a href="QByteArray.md#toInt">toInt</a>().</p>
<h3><span id="qbytearray-amp-qbytearray-setnum-short-n-int-base-10"> &amp;QByteArray::setNum(short <em>n</em>, int <em>base</em> = 10)</span><a href="#qbytearray-amp-qbytearray-setnum-short-n-int-base-10" class="header-anchor">#</a></h3><p>这是一个重载函数。</p>
<p><strong>也可以看看</strong> <a href="QByteArray.md#toShort">toShort</a>().</p>
<h3><span id="qbytearray-amp-qbytearray-setnum-ushort-n-int-base-10"> &amp;QByteArray::setNum( <em>n</em>, int <em>base</em> = 10)</span><a href="#qbytearray-amp-qbytearray-setnum-ushort-n-int-base-10" class="header-anchor">#</a></h3><p>这是一个重载函数。</p>
<p><strong>也可以看看</strong> <a href="QByteArray.md#toUShort">toUShort</a>().</p>
<h3><span id="qbytearray-amp-qbytearray-setnum-uint-n-int-base-10"> &amp;QByteArray::setNum( <em>n</em>, int <em>base</em> = 10)</span><a href="#qbytearray-amp-qbytearray-setnum-uint-n-int-base-10" class="header-anchor">#</a></h3><p>这是一个重载函数。</p>
<p><strong>也可以看看</strong> <a href="QByteArray.md#toUInt">toUInt</a>().</p>
<h3><span id="qbytearray-amp-qbytearray-setnum-long-n-int-base-10"> &amp;QByteArray::setNum(long <em>n</em>, int <em>base</em> = 10)</span><a href="#qbytearray-amp-qbytearray-setnum-long-n-int-base-10" class="header-anchor">#</a></h3><p>这是一个重载函数。</p>
<p><strong>也可以看看</strong> <a href="QByteArray.md#toLong">toLong</a>().</p>
<h3><span id="qbytearray-amp-qbytearray-setnum-ulong-n-int-base-10"> &amp;QByteArray::setNum( <em>n</em>, int <em>base</em> = 10)</span><a href="#qbytearray-amp-qbytearray-setnum-ulong-n-int-base-10" class="header-anchor">#</a></h3><p>这是一个重载函数。</p>
<p><strong>也可以看看</strong> <a href="QByteArray.md#toULong">toULong</a>().</p>
<h3><span id="qbytearray-amp-qbytearray-setnum-qlonglong-n-int-base-10"> &amp;QByteArray::setNum( <em>n</em>, int <em>base</em> = 10)</span><a href="#qbytearray-amp-qbytearray-setnum-qlonglong-n-int-base-10" class="header-anchor">#</a></h3><p>这是一个重载函数。</p>
<p><strong>也可以看看</strong> <a href="QByteArray.md#toLongLong">toLongLong</a>().</p>
<h3><span id="qbytearray-amp-qbytearray-setnum-qulonglong-n-int-base-10"> &amp;QByteArray::setNum( <em>n</em>, int <em>base</em> = 10)</span><a href="#qbytearray-amp-qbytearray-setnum-qulonglong-n-int-base-10" class="header-anchor">#</a></h3><p>这是一个重载函数。</p>
<p><strong>也可以看看</strong> <a href="QByteArray.md#toULongLong">toULongLong</a>().</p>
<h3><span id="qbytearray-amp-qbytearray-setnum-float-n-char-format-g-int-precision-6"> &amp;QByteArray::setNum(float <em>n</em>, char <em>format</em> = ‘g’, int <em>precision</em> = 6)</span><a href="#qbytearray-amp-qbytearray-setnum-float-n-char-format-g-int-precision-6" class="header-anchor">#</a></h3><p>这是一个重载函数。</p>
<p>将浮点数 <em>n</em> 表示为文本。</p>
<p>将此字节数组设置为表示 <em>n</em> 的字符串，具有给定的 <em>format</em> 和 <em>precision</em>（与 [QString::number] 的含义相同（<a target="_blank" rel="noopener" href="https://doc.qt.io/qt-6/">https://doc.qt.io/qt-6/</a> qstring.html#number-6)(double, char, int))，并返回对该字节数组的引用。</p>
<p><strong>也可以看看</strong> <a href="QByteArray.md#toFloat">toFloat</a>().</p>
<h3><span id="qbytearray-amp-qbytearray-setnum-double-n-char-format-g-int-precision-6"> &amp;QByteArray::setNum(double <em>n</em>, char <em>format</em> = ‘g’, int <em>precision</em> = 6)</span><a href="#qbytearray-amp-qbytearray-setnum-double-n-char-format-g-int-precision-6" class="header-anchor">#</a></h3><p>这是一个重载函数。</p>
<p>将浮点数 <em>n</em> 表示为文本。</p>
<p>将此字节数组设置为表示 <em>n</em> 的字符串，具有给定的 <em>format</em> 和 <em>precision</em>（与 [QString::number] 的含义相同（<a target="_blank" rel="noopener" href="https://doc.qt.io/qt-6/">https://doc.qt.io/qt-6/</a> qstring.html#number-6)(double, char, int))，并返回对该字节数组的引用。</p>
<p><strong>也可以看看</strong> <a href="QByteArray.md#toDouble">toDouble</a>() and <a target="_blank" rel="noopener" href="https://doc.qt.io/qt-6/qlocale.html#FloatingPointPrecisionOption-enum">QLocale::FloatingPointPrecisionOption</a>.</p>
<h3><span id="qbytearray-amp-qbytearray-setrawdata-const-char-data-qsizetype-size"> &amp;QByteArray::setRawData(const char *<em>data</em>, qsizetype <em>size</em>)</span><a href="#qbytearray-amp-qbytearray-setrawdata-const-char-data-qsizetype-size" class="header-anchor">#</a></h3><p>重置 <a href="QByteArray.md">QByteArray</a> 以使用 <em>data</em> 数组的第一个 <em>size</em> 字节。 字节<em>不</em>复制。 <a href="QByteArray.md">QByteArray</a> 将包含 <em>data</em> 指针。 调用者保证 <em>data</em> 不会被删除或修改，只要这个 <a href="QByteArray.md">QByteArray</a> 及其任何未修改的副本存在 .</p>
<p>可以使用此函数代替 <a href="QByteArray.md#fromRawData">fromRawData</a>() 来重新使用现有的 [QByteArray](<a target="_blank" rel="noopener" href="https://doc.qt/">https://doc.qt</a>. io/qt-6/qbytearray.html) 对象来保存内存重新分配。</p>
<p><strong>也可以看看</strong> <a href="QByteArray.md#fromRawData">fromRawData</a>(), <a href="QByteArray.md#data">data</a>(), and <a href="QByteArray.md#constData">constData</a>().</p>
<h3><span id="since-5-10-void-qbytearray-shrink-to-fit"><code>[since 5.10]</code>void QByteArray::shrink_to_fit()</span><a href="#since-5-10-void-qbytearray-shrink-to-fit" class="header-anchor">#</a></h3><p>This function is provided for STL compatibility. It is equivalent to <a href="QByteArray.md#squeeze">squeeze</a>().</p>
<p>此功能是在 Qt 5.10 中引入的。</p>
<h3><span id="qbytearray-qbytearray-simplified-const"> QByteArray::simplified() const</span><a href="#qbytearray-qbytearray-simplified-const" class="header-anchor">#</a></h3><p>返回此字节数组的副本，其中从开头和结尾删除了空格字符，其中每个内部空格字符序列都替换为单个空格。</p>
<p>空格字符是标准 C++ <code>isspace()</code> 函数在 C 语言环境中返回 <code>true</code> 的字符； 这些是 ASCII 字符制表符’\t’、换行符’’\n’、回车符’’\r’、垂直制表符’’\v’、换页符’’\f’和空格’’</p>
<p>例子：</p>
<div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-function">QByteArray <span class="hljs-title">ba</span><span class="hljs-params">(<span class="hljs-string">"  lots\t of\nwhitespace\r\n "</span>)</span></span>;
ba = ba.<span class="hljs-built_in">simplified</span>();
<span class="hljs-comment">// ba == "lots of whitespace";</span></code></pre></div>

<p><strong>也可以看看</strong> <a href="QByteArray.md#trimmed">trimmed</a>(), <a target="_blank" rel="noopener" href="https://doc.qt.io/qt-6/qchar.html#SpecialCharacter-enum">QChar::SpecialCharacter</a>, and <a href="QByteArray.md#spacing-characters">Spacing Characters</a>.</p>
<h3><span id="qsizetype-qbytearray-size-const">qsizetype QByteArray::size() const</span><a href="#qsizetype-qbytearray-size-const" class="header-anchor">#</a></h3><p>返回此字节数组中的字节数。</p>
<p>字节数组中的最后一个字节位于 size() - 1 位置。此外，<a href="QByteArray.md">QByteArray</a> 确保位置 size() 处的字节 总是’\0’，这样就可以使用<a href="QByteArray.md#data">data</a>()和[constData](https:// /doc.qt.io/qt-6/qbytearray.html#constData)() 作为期望以 ‘\0’ 结尾的字符串的函数的参数。 如果 <a href="QByteArray.md">QByteArray</a> 对象是从 [原始数据](<a target="_blank" rel="noopener" href="https://doc.qt.io/qt-6/qbytearray">https://doc.qt.io/qt-6/qbytearray</a>. html#fromRawData) 不包含尾随 ‘\0’ 终止字节，然后 <a href="QByteArray.md">QByteArray</a> 不会自动添加它，除非 <a target="_blank" rel="noopener" href="https://doc.qt.io/qt-6/implicit-sharing.html#deep-copy">深拷贝</a> 被创建。</p>
<p>例子：</p>
<div class="code-wrapper"><pre><code class="hljs awk">QByteArray ba(<span class="hljs-string">"Hello"</span>);
qsizetype n = ba.size();    <span class="hljs-regexp">//</span> n == <span class="hljs-number">5</span>
ba.data()[<span class="hljs-number">0</span>];               <span class="hljs-regexp">//</span> returns <span class="hljs-string">'H'</span>
ba.data()[<span class="hljs-number">4</span>];               <span class="hljs-regexp">//</span> returns <span class="hljs-string">'o'</span>
ba.data()[<span class="hljs-number">5</span>];               <span class="hljs-regexp">//</span> returns <span class="hljs-string">'\0'</span></code></pre></div>

<p><strong>也可以看看</strong> <a href="QByteArray.md#isEmpty">isEmpty</a>() and <a href="QByteArray.md#resize">resize</a>().</p>
<h3><span id="since-6-0-qbytearray-qbytearray-sliced-qsizetype-pos-qsizetype-n-const"><code>[since 6.0]</code> QByteArray::sliced(qsizetype <em>pos</em>, qsizetype <em>n</em>) const</span><a href="#since-6-0-qbytearray-qbytearray-sliced-qsizetype-pos-qsizetype-n-const" class="header-anchor">#</a></h3><p>返回一个字节数组，其中包含从位置 <em>pos</em> 开始的此对象的 <em>n</em> 个字节。</p>
<p><strong>注意：</strong> 当 <em>pos</em> &lt; 0、*n* &lt; 0 或 *pos* + *n* &gt; <a href="QByteArray.md#size">size</a> ()时行为未定义。</p>
<p>例子：</p>
<div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-function">QByteArray <span class="hljs-title">x</span><span class="hljs-params">(<span class="hljs-string">"Five pineapples"</span>)</span></span>;
QByteArray y = x.<span class="hljs-built_in">sliced</span>(<span class="hljs-number">5</span>, <span class="hljs-number">4</span>);     <span class="hljs-comment">// y == "pine"</span>
QByteArray z = x.<span class="hljs-built_in">sliced</span>(<span class="hljs-number">5</span>);        <span class="hljs-comment">// z == "pineapples"</span></code></pre></div>

<p>此功能是在 Qt 6.0 中引入的。</p>
<p><strong>也可以看看</strong> <a href="QByteArray.md#first">first</a>(), <a href="QByteArray.md#last">last</a>(), <a href="QByteArray.md#chopped">chopped</a>(), <a href="QByteArray.md#chop">chop</a>(), and <a href="QByteArray.md#truncate">truncate</a>().</p>
<h3><span id="since-6-0-qbytearray-qbytearray-sliced-qsizetype-pos-const"><code>[since 6.0]</code> QByteArray::sliced(qsizetype <em>pos</em>) const</span><a href="#since-6-0-qbytearray-qbytearray-sliced-qsizetype-pos-const" class="header-anchor">#</a></h3><p>这是一个重载函数。</p>
<p>返回一个字节数组，其中包含从此对象中位置 <em>pos</em> 开始并延伸到此对象末尾的字节。</p>
<p><strong>注意：</strong> 当 <em>pos</em> &lt; 0 或 *pos* &gt; <a href="QByteArray.md#size">size</a>() 时行为未定义。</p>
<p>此功能是在 Qt 6.0 中引入的。</p>
<p><strong>也可以看看</strong> <a href="QByteArray.md#first">first</a>(), <a href="QByteArray.md#last">last</a>(), <a href="QByteArray.md#sliced">sliced</a>(), <a href="QByteArray.md#chopped">chopped</a>(), <a href="QByteArray.md#chop">chop</a>(), and <a href="QByteArray.md#truncate">truncate</a>().</p>
<h3><span id="qlist-lt-qbytearray-gt-qbytearray-split-char-sep-const">&lt;&gt; QByteArray::split(char <em>sep</em>) const</span><a href="#qlist-lt-qbytearray-gt-qbytearray-split-char-sep-const" class="header-anchor">#</a></h3><p>在出现 <em>sep</em> 的地方将字节数组拆分为子数组，并返回这些数组的列表。 如果 <em>sep</em> 不匹配字节数组中的任何位置，split() 将返回包含此字节数组的单元素列表。</p>
<h3><span id="void-qbytearray-squeeze">void QByteArray::squeeze()</span><a href="#void-qbytearray-squeeze" class="header-anchor">#</a></h3><p>释放存储数组数据不需要的任何内存。</p>
<p>该函数的唯一目的是提供一种微调 <a href="QByteArray.md">QByteArray</a> 的内存使用的方法。 通常，您很少需要调用此函数。</p>
<p><strong>也可以看看</strong> <a href="QByteArray.md#reserve">reserve</a>() and <a href="QByteArray.md#capacity">capacity</a>().</p>
<h3><span id="since-6-0-bool-qbytearray-startswith-qbytearrayview-bv-const"><code>[since 6.0]</code>bool QByteArray::startsWith( <em>bv</em>) const</span><a href="#since-6-0-bool-qbytearray-startswith-qbytearrayview-bv-const" class="header-anchor">#</a></h3><p>如果此字节数组以 <em>bv</em> 查看的字节序列开头，则返回 <code>true</code>； 否则返回<code>false</code>。</p>
<p>例子：</p>
<div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-function">QByteArray <span class="hljs-title">url</span><span class="hljs-params">(<span class="hljs-string">"ftp://ftp.qt-project.org/"</span>)</span></span>;
<span class="hljs-keyword">if</span> (url.<span class="hljs-built_in">startsWith</span>(<span class="hljs-string">"ftp:"</span>))
    ...</code></pre></div>

<p>此功能是在 Qt 6.0 中引入的。</p>
<p><strong>也可以看看</strong> <a href="QByteArray.md#endsWith">endsWith</a>() and <a href="QByteArray.md#first">first</a>().</p>
<h3><span id="bool-qbytearray-startswith-char-ch-const">bool QByteArray::startsWith(char <em>ch</em>) const</span><a href="#bool-qbytearray-startswith-char-ch-const" class="header-anchor">#</a></h3><p>这是一个重载函数。</p>
<p>如果此字节数组以字节 <em>ch</em> 开头，则返回 <code>true</code>； 否则返回<code>false</code>。</p>
<h3><span id="void-qbytearray-swap-qbytearray-amp-other">void QByteArray::swap( &amp;<em>other</em>)</span><a href="#void-qbytearray-swap-qbytearray-amp-other" class="header-anchor">#</a></h3><p>用这个字节数组交换字节数组 <em>other</em>。 此操作非常快且永不失败。</p>
<h3><span id="since-5-2-qbytearray-qbytearray-tobase64-qbytearray-base64options-options-base64encoding-const"><code>[since 5.2]</code> QByteArray::toBase64( <em>options</em> = Base64Encoding) const</span><a href="#since-5-2-qbytearray-qbytearray-tobase64-qbytearray-base64options-options-base64encoding-const" class="header-anchor">#</a></h3><p>返回使用选项 <em>options</em> 编码的字节数组的副本。</p>
<div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-function">QByteArray <span class="hljs-title">text</span><span class="hljs-params">(<span class="hljs-string">"Qt is great!"</span>)</span></span>;
text.<span class="hljs-built_in">toBase64</span>();        <span class="hljs-comment">// returns "UXQgaXMgZ3JlYXQh"</span>

<span class="hljs-function">QByteArray <span class="hljs-title">text</span><span class="hljs-params">(<span class="hljs-string">"&lt;p&gt;Hello?&lt;/p&gt;"</span>)</span></span>;
text.<span class="hljs-built_in">toBase64</span>(QByteArray::Base64Encoding | QByteArray::OmitTrailingEquals);      <span class="hljs-comment">// returns "PHA+SGVsbG8/PC9wPg"</span>
text.<span class="hljs-built_in">toBase64</span>(QByteArray::Base64Encoding);                                       <span class="hljs-comment">// returns "PHA+SGVsbG8/PC9wPg=="</span>
text.<span class="hljs-built_in">toBase64</span>(QByteArray::Base64UrlEncoding);                                    <span class="hljs-comment">// returns "PHA-SGVsbG8_PC9wPg=="</span>
text.<span class="hljs-built_in">toBase64</span>(QByteArray::Base64UrlEncoding | QByteArray::OmitTrailingEquals);   <span class="hljs-comment">// returns "PHA-SGVsbG8_PC9wPg"</span></code></pre></div>

<p>用于对 Base64 编码数据进行编码的算法在 <a target="_blank" rel="noopener" href="https://datatracker.ietf.org/doc/html/rfc4648">RFC 4648</a> 中定义。</p>
<p>此功能是在 Qt 5.2 中引入的。</p>
<p><strong>也可以看看</strong> <a href="QByteArray.md#fromBase64">fromBase64</a>().</p>
<h3><span id="since-5-3-cfdataref-qbytearray-tocfdata-const"><code>[since 5.3]</code>CFDataRef QByteArray::toCFData() const</span><a href="#since-5-3-cfdataref-qbytearray-tocfdata-const" class="header-anchor">#</a></h3><p>从 <a href="QByteArray.md">QByteArray</a> 创建一个 CFData。</p>
<p>调用者拥有 CFData 对象并负责释放它。</p>
<p>此功能是在 Qt 5.3 中引入的。</p>
<p><strong>也可以看看</strong> <a href="QByteArray.md#toRawCFData">toRawCFData</a>(), <a href="QByteArray.md#fromCFData">fromCFData</a>(), <a href="QByteArray.md#fromRawCFData">fromRawCFData</a>(), and <a href="QByteArray.md#fromRawData">fromRawData</a>().</p>
<h3><span id="double-qbytearray-todouble-bool-ok-nullptr-const">double QByteArray::toDouble(bool *<em>ok</em> = nullptr) const</span><a href="#double-qbytearray-todouble-bool-ok-nullptr-const" class="header-anchor">#</a></h3><p>返回转换为 <code>double</code> 值的字节数组。</p>
<p>如果转换上溢，则返回无穷大；如果转换因其他原因（例如下溢）失败，则返回 0.0。</p>
<p>如果 <em>ok</em> 不是 <code>nullptr</code>，则将 *<em>ok</em> 设置为 <code>false</code> 会报告失败，将 *<em>ok</em> 设置为 <code>true</code> 会报告成功。</p>
<div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-function">QByteArray <span class="hljs-title">string</span><span class="hljs-params">(<span class="hljs-string">"1234.56"</span>)</span></span>;
<span class="hljs-type">bool</span> ok;
<span class="hljs-type">double</span> a = string.<span class="hljs-built_in">toDouble</span>(&amp;ok);   <span class="hljs-comment">// a == 1234.56, ok == true</span>

string = <span class="hljs-string">"1234.56 Volt"</span>;
a = str.<span class="hljs-built_in">toDouble</span>(&amp;ok);             <span class="hljs-comment">// a == 0, ok == false</span></code></pre></div>

<p><strong>警告：</strong> <a href="QByteArray.md">QByteArray</a> 内容只能包含有效的数字字符，包括加号/减号，科学中使用的字符 e 符号和小数点。 包含单位或附加字符会导致转换错误。</p>
<p><strong>注意：</strong>数字的转换是在默认的 C 语言环境中执行的，与用户的语言环境无关。 使用 <a target="_blank" rel="noopener" href="https://doc.qt.io/qt-6/qlocale.html">QLocale</a> 在数字和字符串之间执行区域感知转换。</p>
<p>此函数忽略前导和尾随空格。</p>
<p><strong>也可以看看</strong> <a href="QByteArray.md#number">number</a>().</p>
<h3><span id="float-qbytearray-tofloat-bool-ok-nullptr-const">float QByteArray::toFloat(bool *<em>ok</em> = nullptr) const</span><a href="#float-qbytearray-tofloat-bool-ok-nullptr-const" class="header-anchor">#</a></h3><p>返回转换为 <code>float</code> 值的字节数组。</p>
<p>如果转换上溢，则返回无穷大；如果转换因其他原因（例如下溢）失败，则返回 0.0。</p>
<p>如果 <em>ok</em> 不是 <code>nullptr</code>，则将 *<em>ok</em> 设置为 <code>false</code> 会报告失败，将 *<em>ok</em> 设置为 <code>true</code> 会报告成功。</p>
<div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-function">QByteArray <span class="hljs-title">string</span><span class="hljs-params">(<span class="hljs-string">"1234.56"</span>)</span></span>;
<span class="hljs-type">bool</span> ok;
<span class="hljs-type">float</span> a = string.<span class="hljs-built_in">toFloat</span>(&amp;ok);    <span class="hljs-comment">// a == 1234.56, ok == true</span>

string = <span class="hljs-string">"1234.56 Volt"</span>;
a = str.<span class="hljs-built_in">toFloat</span>(&amp;ok);              <span class="hljs-comment">// a == 0, ok == false</span></code></pre></div>

<p><strong>警告：</strong> <a href="QByteArray.md">QByteArray</a> 内容只能包含有效的数字字符，包括加号/减号，科学中使用的字符 e 符号和小数点。 包含单位或附加字符会导致转换错误。</p>
<p><strong>注意：</strong>数字的转换是在默认的 C 语言环境中执行的，与用户的语言环境无关。 使用 <a target="_blank" rel="noopener" href="https://doc.qt.io/qt-6/qlocale.html">QLocale</a> 在数字和字符串之间执行区域感知转换。</p>
<p>此函数忽略前导和尾随空格。</p>
<p><strong>也可以看看</strong> <a href="QByteArray.md#number">number</a>().</p>
<h3><span id="since-5-9-qbytearray-qbytearray-tohex-char-separator-0-const"><code>[since 5.9]</code> QByteArray::toHex(char <em>separator</em> = ‘\0’) const</span><a href="#since-5-9-qbytearray-qbytearray-tohex-char-separator-0-const" class="header-anchor">#</a></h3><p>返回字节数组的十六进制编码副本。</p>
<p>十六进制编码使用数字 0-9 和字母 a-f。</p>
<p>如果 <em>separator</em> 不是 ‘\0’，则在十六进制字节之间插入分隔符。</p>
<p>例子：</p>
<div class="code-wrapper"><pre><code class="hljs c++">QByteArray macAddress = QByteArray::<span class="hljs-built_in">fromHex</span>(<span class="hljs-string">"123456abcdef"</span>);
macAddress.<span class="hljs-built_in">toHex</span>(<span class="hljs-string">':'</span>); <span class="hljs-comment">// returns "12:34:56:ab:cd:ef"</span>
macAddress.<span class="hljs-built_in">toHex</span>(<span class="hljs-number">0</span>);   <span class="hljs-comment">// returns "123456abcdef"</span></code></pre></div>

<p>这个函数是在 Qt 5.9 中引入的。</p>
<p><strong>也可以看看</strong> <a href="QByteArray.md#fromHex">fromHex</a>().</p>
<h3><span id="int-qbytearray-toint-bool-ok-nullptr-int-base-10-const">int QByteArray::toInt(bool *<em>ok</em> = nullptr, int <em>base</em> = 10) const</span><a href="#int-qbytearray-toint-bool-ok-nullptr-int-base-10-const" class="header-anchor">#</a></h3><p>返回使用 base <em>base</em> 转换为 <code>int</code> 的字节数组，默认为 10。 支持基数 0 和 2 到 36，超过 9 的数字使用字母； A 是 10，B 是 11，依此类推。</p>
<p>如果 <em>base</em> 为 0，则使用以下规则自动确定基数： 如果字节数组以“0x”开头，则假定为十六进制（基数为 16）； 否则，如果它以“0”开头，则假定为八进制（以 8 为基数）； 否则假定为十进制。</p>
<p>如果转换失败，则返回 0。</p>
<p>如果 <em>ok</em> 不是 <code>nullptr</code>，则将 *<em>ok</em> 设置为 <code>false</code> 会报告失败，将 *<em>ok</em> 设置为 <code>true</code> 会报告成功。</p>
<div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-function">QByteArray <span class="hljs-title">str</span><span class="hljs-params">(<span class="hljs-string">"FF"</span>)</span></span>;
<span class="hljs-type">bool</span> ok;
<span class="hljs-type">int</span> hex = str.<span class="hljs-built_in">toInt</span>(&amp;ok, <span class="hljs-number">16</span>);     <span class="hljs-comment">// hex == 255, ok == true</span>
<span class="hljs-type">int</span> dec = str.<span class="hljs-built_in">toInt</span>(&amp;ok, <span class="hljs-number">10</span>);     <span class="hljs-comment">// dec == 0, ok == false</span></code></pre></div>

<p><strong>注意：</strong>数字的转换是在默认的 C 语言环境中执行的，与用户的语言环境无关。 使用 <a target="_blank" rel="noopener" href="https://doc.qt.io/qt-6/qlocale.html">QLocale</a> 在数字和字符串之间执行区域感知转换。</p>
<h3><span id="long-qbytearray-tolong-bool-ok-nullptr-int-base-10-const">long QByteArray::toLong(bool *<em>ok</em> = nullptr, int <em>base</em> = 10) const</span><a href="#long-qbytearray-tolong-bool-ok-nullptr-int-base-10-const" class="header-anchor">#</a></h3><p>返回使用 base <em>base</em> 转换为 <code>long</code> int 的字节数组，默认为 10。 支持基数 0 和 2 到 36，超过 9 的数字使用字母； A 是 10，B 是 11，依此类推。</p>
<p>如果 <em>base</em> 为 0，则使用以下规则自动确定基数： 如果字节数组以“0x”开头，则假定为十六进制（基数为 16）； 否则，如果它以“0”开头，则假定为八进制（以 8 为基数）； 否则假定为十进制。</p>
<p>如果转换失败，则返回 0。</p>
<p>如果 <em>ok</em> 不是 <code>nullptr</code>，则将 *<em>ok</em> 设置为 <code>false</code> 会报告失败，将 *<em>ok</em> 设置为 <code>true</code> 会报告成功。</p>
<div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-function">QByteArray <span class="hljs-title">str</span><span class="hljs-params">(<span class="hljs-string">"FF"</span>)</span></span>;
<span class="hljs-type">bool</span> ok;
<span class="hljs-type">long</span> hex = str.<span class="hljs-built_in">toLong</span>(&amp;ok, <span class="hljs-number">16</span>);   <span class="hljs-comment">// hex == 255, ok == true</span>
<span class="hljs-type">long</span> dec = str.<span class="hljs-built_in">toLong</span>(&amp;ok, <span class="hljs-number">10</span>);   <span class="hljs-comment">// dec == 0, ok == false</span></code></pre></div>

<p><strong>注意：</strong>数字的转换是在默认的 C 语言环境中执行的，与用户的语言环境无关。 使用 <a target="_blank" rel="noopener" href="https://doc.qt.io/qt-6/qlocale.html">QLocale</a> 在数字和字符串之间执行区域感知转换。</p>
<p><strong>也可以看看</strong> <a href="QByteArray.md#number">number</a>().</p>
<h3><span id="qlonglong-qbytearray-tolonglong-bool-ok-nullptr-int-base-10-const"> QByteArray::toLongLong(bool *<em>ok</em> = nullptr, int <em>base</em> = 10) const</span><a href="#qlonglong-qbytearray-tolonglong-bool-ok-nullptr-int-base-10-const" class="header-anchor">#</a></h3><p>返回使用 base <em>base</em> 转换为 <code>long long</code> 的字节数组，默认为 10。 支持基数 0 和 2 到 36，超过 9 的数字使用字母； A 是 10，B 是 11，依此类推。</p>
<p>如果 <em>base</em> 为 0，则使用以下规则自动确定基数： 如果字节数组以“0x”开头，则假定为十六进制（基数为 16）； 否则，如果它以“0”开头，则假定为八进制（以 8 为基数）； 否则假定为十进制。</p>
<p>如果转换失败，则返回 0。</p>
<p>如果 <em>ok</em> 不是 <code>nullptr</code>，则将 *<em>ok</em> 设置为 <code>false</code> 会报告失败，将 *<em>ok</em> 设置为 <code>true</code> 会报告成功。</p>
<p><strong>注意：</strong>数字的转换是在默认的 C 语言环境中执行的，与用户的语言环境无关。 使用 <a target="_blank" rel="noopener" href="https://doc.qt.io/qt-6/qlocale.html">QLocale</a> 在数字和字符串之间执行区域感知转换。</p>
<p><strong>也可以看看</strong> <a href="QByteArray.md#number">number</a>().</p>
<h3><span id="qbytearray-qbytearray-tolower-const"> QByteArray::toLower() const</span><a href="#qbytearray-qbytearray-tolower-const" class="header-anchor">#</a></h3><p>返回字节数组的副本，其中每个 ASCII 大写字母都转换为小写。</p>
<p>例子：</p>
<div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-function">QByteArray <span class="hljs-title">x</span><span class="hljs-params">(<span class="hljs-string">"Qt by THE QT COMPANY"</span>)</span></span>;
QByteArray y = x.<span class="hljs-built_in">toLower</span>();
<span class="hljs-comment">// y == "qt by the qt company"</span></code></pre></div>

<p><strong>也可以看看</strong> <a href="QByteArray.md#isLower">isLower</a>(), <a href="QByteArray.md#toUpper">toUpper</a>(), and <a href="QByteArray.md#character-case">Character Case</a>.</p>
<h3><span id="since-5-3-nsdata-qbytearray-tonsdata-const"><code>[since 5.3]</code>NSData *QByteArray::toNSData() const</span><a href="#since-5-3-nsdata-qbytearray-tonsdata-const" class="header-anchor">#</a></h3><p>从 <a href="QByteArray.md">QByteArray</a> 创建一个 NSData。</p>
<p>NSData 对象是自动释放的。</p>
<p>这个函数是在 Qt 5.3 中引入的。</p>
<p><strong>也可以看看</strong> <a href="QByteArray.md#fromNSData">fromNSData</a>(), <a href="QByteArray.md#fromRawNSData">fromRawNSData</a>(), <a href="QByteArray.md#fromRawData">fromRawData</a>(), and <a href="QByteArray.md#toRawNSData">toRawNSData</a>().</p>
<h3><span id="qbytearray-qbytearray-topercentencoding-const-qbytearray-amp-exclude-qbytearray-const-qbytearray-amp-include-qbytearray-char-percent-const"> QByteArray::toPercentEncoding(const  &amp;<em>exclude</em> = QByteArray(), const  &amp;<em>include</em> = QByteArray(), char <em>percent</em> = ‘%’) const</span><a href="#qbytearray-qbytearray-topercentencoding-const-qbytearray-amp-exclude-qbytearray-const-qbytearray-amp-include-qbytearray-char-percent-const" class="header-anchor">#</a></h3><p>返回此字节数组的 URI/URL 样式的百分比编码副本。 <em>percent</em> 参数允许您覆盖另一个默认的 ‘%’ 字符。</p>
<p>默认情况下，此函数将对所有不属于以下之一的字节进行编码：</p>
<p>ALPHA（“a”到“z”和“A”到“Z”）/ DIGIT（0到9）/“-”/“。” /“_”/“~”</p>
<p>为了防止字节被编码，将它们传递给 <em>exclude</em>。 要强制对字节进行编码，请将它们传递给 <em>include</em>。 <em>percent</em> 字符始终被编码。</p>
<p>例子：</p>
<div class="code-wrapper"><pre><code class="hljs c++">QByteArray text = <span class="hljs-string">"{a fishy string?}"</span>;
QByteArray ba = text.<span class="hljs-built_in">toPercentEncoding</span>(<span class="hljs-string">"{}"</span>, <span class="hljs-string">"s"</span>);
<span class="hljs-built_in">qDebug</span>(ba.<span class="hljs-built_in">constData</span>());
<span class="hljs-comment">// prints "{a fi%73hy %73tring%3F}"</span></code></pre></div>

<p>十六进制编码使用数字 0-9 和大写字母 A-F。</p>
<p><strong>也可以看看</strong> <a href="QByteArray.md#fromPercentEncoding">fromPercentEncoding</a>() and <a target="_blank" rel="noopener" href="https://doc.qt.io/qt-6/qurl.html#toPercentEncoding">QUrl::toPercentEncoding</a>().</p>
<h3><span id="since-5-3-cfdataref-qbytearray-torawcfdata-const"><code>[since 5.3]</code>CFDataRef QByteArray::toRawCFData() const</span><a href="#since-5-3-cfdataref-qbytearray-torawcfdata-const" class="header-anchor">#</a></h3><p>构造一个使用 <a href="QByteArray.md">QByteArray</a> 的字节的 CFData。</p>
<p><a href="QByteArray.md">QByteArray</a> 的字节不会被复制。</p>
<p>调用者保证只要这个CFData对象存在，<a href="QByteArray.md">QByteArray</a>就不会被删除或修改。</p>
<p>这个函数是在 Qt 5.3 中引入的。</p>
<p><strong>也可以看看</strong> <a href="QByteArray.md#toCFData">toCFData</a>(), <a href="QByteArray.md#fromRawCFData">fromRawCFData</a>(), <a href="QByteArray.md#fromCFData">fromCFData</a>(), and <a href="QByteArray.md#fromRawData">fromRawData</a>().</p>
<h3><span id="since-5-3-nsdata-qbytearray-torawnsdata-const"><code>[since 5.3]</code>NSData *QByteArray::toRawNSData() const</span><a href="#since-5-3-nsdata-qbytearray-torawnsdata-const" class="header-anchor">#</a></h3><p>构造一个使用 <a href="QByteArray.md">QByteArray</a> 的字节的 NSData。</p>
<p><a href="QByteArray.md">QByteArray</a> 的字节不会被复制。</p>
<p>调用者保证只要这个 NSData 对象存在，<a href="QByteArray.md">QByteArray</a> 就不会被删除或修改。</p>
<p>这个函数是在 Qt 5.3 中引入的。</p>
<p><strong>也可以看看</strong> <a href="QByteArray.md#fromRawNSData">fromRawNSData</a>(), <a href="QByteArray.md#fromNSData">fromNSData</a>(), <a href="QByteArray.md#fromRawData">fromRawData</a>(), and <a href="QByteArray.md#toNSData">toNSData</a>().</p>
<h3><span id="short-qbytearray-toshort-bool-ok-nullptr-int-base-10-const">short QByteArray::toShort(bool *<em>ok</em> = nullptr, int <em>base</em> = 10) const</span><a href="#short-qbytearray-toshort-bool-ok-nullptr-int-base-10-const" class="header-anchor">#</a></h3><p>返回使用 base <em>base</em> 转换为 <code>short</code> 的字节数组，默认为 10。 支持基数 0 和 2 到 36，超过 9 的数字使用字母； A 是 10，B 是 11，依此类推。</p>
<p>如果 <em>base</em> 为 0，则使用以下规则自动确定基数： 如果字节数组以“0x”开头，则假定为十六进制； 否则，如果以“0”开头，则假定为八进制； 否则假定为十进制。</p>
<p>如果转换失败，则返回 0。</p>
<p>如果 <em>ok</em> 不是 <code>nullptr</code>，则将 *<em>ok</em> 设置为 <code>false</code> 会报告失败，将 *<em>ok</em> 设置为 <code>true</code> 会报告成功。</p>
<p><strong>注意：</strong>数字的转换是在默认的 C 语言环境中执行的，与用户的语言环境无关。 使用 <a target="_blank" rel="noopener" href="https://doc.qt.io/qt-6/qlocale.html">QLocale</a> 在数字和字符串之间执行区域感知转换。</p>
<p><strong>也可以看看</strong> <a href="QByteArray.md#number">number</a>().</p>
<h3><span id="since-5-4-std-string-qbytearray-tostdstring-const"><code>[since 5.4]</code>std::string QByteArray::toStdString() const</span><a href="#since-5-4-std-string-qbytearray-tostdstring-const" class="header-anchor">#</a></h3><p>返回包含在此 <a href="QByteArray.md">QByteArray</a> 中的数据的 std::string 对象。</p>
<p>此运算符对于将 <a href="QByteArray.md">QByteArray</a> 传递给接受 std::string 对象的函数非常有用。</p>
<p>这个函数是在 Qt 5.4 中引入的。</p>
<p><strong>也可以看看</strong> <a href="QByteArray.md#fromStdString">fromStdString</a>() and <a target="_blank" rel="noopener" href="https://doc.qt.io/qt-6/qstring.html#toStdString">QString::toStdString</a>().</p>
<h3><span id="uint-qbytearray-touint-bool-ok-nullptr-int-base-10-const"> QByteArray::toUInt(bool *<em>ok</em> = nullptr, int <em>base</em> = 10) const</span><a href="#uint-qbytearray-touint-bool-ok-nullptr-int-base-10-const" class="header-anchor">#</a></h3><p>返回使用 base <em>base</em> 转换为 <code>unsigned int</code> 的字节数组，默认为 10。 支持基数 0 和 2 到 36，超过 9 的数字使用字母； A 是 10，B 是 11，依此类推。</p>
<p>如果 <em>base</em> 为 0，则使用以下规则自动确定基数： 如果字节数组以“0x”开头，则假定为十六进制（基数为 16）； 否则，如果它以“0”开头，则假定为八进制（以 8 为基数）； 否则假定为十进制。</p>
<p>如果转换失败，则返回 0。</p>
<p>如果 <em>ok</em> 不是 <code>nullptr</code>，则将 *<em>ok</em> 设置为 <code>false</code> 会报告失败，将 *<em>ok</em> 设置为 <code>true</code> 会报告成功。</p>
<p><strong>注意：</strong>数字的转换是在默认的 C 语言环境中执行的，与用户的语言环境无关。 使用 <a target="_blank" rel="noopener" href="https://doc.qt.io/qt-6/qlocale.html">QLocale</a> 在数字和字符串之间执行区域感知转换。</p>
<p><strong>也可以看看</strong> <a href="QByteArray.md#number">number</a>().</p>
<h3><span id="ulong-qbytearray-toulong-bool-ok-nullptr-int-base-10-const"> QByteArray::toULong(bool *<em>ok</em> = nullptr, int <em>base</em> = 10) const</span><a href="#ulong-qbytearray-toulong-bool-ok-nullptr-int-base-10-const" class="header-anchor">#</a></h3><p>返回使用 base <em>base</em> 转换为 <code>unsigned long int</code> 的字节数组，默认为 10。 支持基数 0 和 2 到 36，超过 9 的数字使用字母； A 是 10，B 是 11，依此类推。</p>
<p>如果 <em>base</em> 为 0，则使用以下规则自动确定基数： 如果字节数组以“0x”开头，则假定为十六进制（基数为 16）； 否则，如果它以“0”开头，则假定为八进制（以 8 为基数）； 否则假定为十进制。</p>
<p>如果转换失败，则返回 0。</p>
<p>如果 <em>ok</em> 不是 <code>nullptr</code>，则将 *<em>ok</em> 设置为 <code>false</code> 会报告失败，将 *<em>ok</em> 设置为 <code>true</code> 会报告成功。</p>
<p><strong>注意：</strong>数字的转换是在默认的 C 语言环境中执行的，与用户的语言环境无关。 使用 <a target="_blank" rel="noopener" href="https://doc.qt.io/qt-6/qlocale.html">QLocale</a> 在数字和字符串之间执行区域感知转换。</p>
<p><strong>也可以看看</strong> <a href="QByteArray.md#number">number</a>().</p>
<h3><span id="qulonglong-qbytearray-toulonglong-bool-ok-nullptr-int-base-10-const"> QByteArray::toULongLong(bool *<em>ok</em> = nullptr, int <em>base</em> = 10) const</span><a href="#qulonglong-qbytearray-toulonglong-bool-ok-nullptr-int-base-10-const" class="header-anchor">#</a></h3><p>返回使用 base <em>base</em> 转换为 <code>unsigned long long</code> 的字节数组，默认为 10。 支持基数 0 和 2 到 36，超过 9 的数字使用字母； A 是 10，B 是 11，依此类推。</p>
<p>如果 <em>base</em> 为 0，则使用以下规则自动确定基数： 如果字节数组以“0x”开头，则假定为十六进制（基数为 16）； 否则，如果它以“0”开头，则假定为八进制（以 8 为基数）； 否则假定为十进制。</p>
<p>如果转换失败，则返回 0。</p>
<p>如果 <em>ok</em> 不是 <code>nullptr</code>，则将 *<em>ok</em> 设置为 <code>false</code> 会报告失败，将 *<em>ok</em> 设置为 <code>true</code> 会报告成功。</p>
<p><strong>注意：</strong>数字的转换是在默认的 C 语言环境中执行的，与用户的语言环境无关。 使用 <a target="_blank" rel="noopener" href="https://doc.qt.io/qt-6/qlocale.html">QLocale</a> 在数字和字符串之间执行区域感知转换。</p>
<p><strong>也可以看看</strong> <a href="QByteArray.md#number">number</a>().</p>
<h3><span id="ushort-qbytearray-toushort-bool-ok-nullptr-int-base-10-const"> QByteArray::toUShort(bool *<em>ok</em> = nullptr, int <em>base</em> = 10) const</span><a href="#ushort-qbytearray-toushort-bool-ok-nullptr-int-base-10-const" class="header-anchor">#</a></h3><p>返回使用 base <em>base</em> 转换为 <code>unsigned short</code> 的字节数组，默认为 10。 支持基数 0 和 2 到 36，超过 9 的数字使用字母； A 是 10，B 是 11，依此类推。</p>
<p>如果 <em>base</em> 为 0，则使用以下规则自动确定基数： 如果字节数组以“0x”开头，则假定为十六进制； 否则，如果以“0”开头，则假定为八进制； 否则假定为十进制。</p>
<p>如果转换失败，则返回 0。</p>
<p>如果 <em>ok</em> 不是 <code>nullptr</code>，则将 *<em>ok</em> 设置为 <code>false</code> 会报告失败，将 *<em>ok</em> 设置为 <code>true</code> 会报告成功。</p>
<p><strong>注意：</strong>数字的转换是在默认的 C 语言环境中执行的，与用户的语言环境无关。 使用 <a target="_blank" rel="noopener" href="https://doc.qt.io/qt-6/qlocale.html">QLocale</a> 在数字和字符串之间执行区域感知转换。</p>
<p><strong>也可以看看</strong> <a href="QByteArray.md#number">number</a>().</p>
<h3><span id="qbytearray-qbytearray-toupper-const"> QByteArray::toUpper() const</span><a href="#qbytearray-qbytearray-toupper-const" class="header-anchor">#</a></h3><p>返回字节数组的副本，其中每个 ASCII 小写字母都转换为大写。</p>
<p>例子：</p>
<div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-function">QByteArray <span class="hljs-title">x</span><span class="hljs-params">(<span class="hljs-string">"Qt by THE QT COMPANY"</span>)</span></span>;
QByteArray y = x.<span class="hljs-built_in">toUpper</span>();
<span class="hljs-comment">// y == "QT BY THE QT COMPANY"</span></code></pre></div>

<p><strong>也可以看看</strong> <a href="QByteArray.md#isUpper">isUpper</a>(), <a href="QByteArray.md#toLower">toLower</a>(), and <a href="QByteArray.md#character-case">Character Case</a>.</p>
<h3><span id="qbytearray-qbytearray-trimmed-const"> QByteArray::trimmed() const</span><a href="#qbytearray-qbytearray-trimmed-const" class="header-anchor">#</a></h3><p>返回此字节数组的副本，其中删除了开头和结尾的空格字符。</p>
<p>空格字符是标准 C++ <code>isspace()</code> 函数在 C 语言环境中返回 <code>true</code> 的字符； 这些是 ASCII 字符制表符<code>\t</code>、换行符<code>\n</code>、回车符<code>\r</code>、垂直制表符<code>\v</code>、换页符<code>\f</code>和空格’’。</p>
<p>例子：</p>
<div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-function">QByteArray <span class="hljs-title">ba</span><span class="hljs-params">(<span class="hljs-string">"  lots\t of\nwhitespace\r\n "</span>)</span></span>;
ba = ba.<span class="hljs-built_in">trimmed</span>();
<span class="hljs-comment">// ba == "lots\t of\nwhitespace";</span></code></pre></div>

<p>Unlike <a href="QByteArray.md#simplified">simplified</a>(), trimmed() leaves internal spacing unchanged.</p>
<p><strong>也可以看看</strong> <a href="QByteArray.md#simplified">simplified</a>(), <a target="_blank" rel="noopener" href="https://doc.qt.io/qt-6/qchar.html#SpecialCharacter-enum">QChar::SpecialCharacter</a>, and <a href="QByteArray.md#spacing-characters">Spacing Characters</a>.</p>
<h3><span id="void-qbytearray-truncate-qsizetype-pos">void QByteArray::truncate(qsizetype <em>pos</em>)</span><a href="#void-qbytearray-truncate-qsizetype-pos" class="header-anchor">#</a></h3><p>截断索引位置 <em>pos</em> 处的字节数组。</p>
<p>如果 <em>pos</em> 超出数组的末尾，则不会发生任何事情。</p>
<p>例子：</p>
<div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-function">QByteArray <span class="hljs-title">ba</span><span class="hljs-params">(<span class="hljs-string">"Stockholm"</span>)</span></span>;
ba.<span class="hljs-built_in">truncate</span>(<span class="hljs-number">5</span>);             <span class="hljs-comment">// ba == "Stock"</span></code></pre></div>

<p><strong>也可以看看</strong> <a href="QByteArray.md#chop">chop</a>(), <a href="QByteArray.md#resize">resize</a>(), and <a href="QByteArray.md#first">first</a>().</p>
<h3><span id="bool-qbytearray-operator-const-qstring-amp-str-const">bool QByteArray::operator!=(const  &amp;<em>str</em>) const</span><a href="#bool-qbytearray-operator-const-qstring-amp-str-const" class="header-anchor">#</a></h3><p>如果此字节数组不等于 <em>str</em> 的 UTF-8 编码，则返回 <code>true</code>；否则返回<code>false</code>。</p>
<p>比较区分大小写。</p>
<p>您可以在编译应用程序时通过定义 <code>QT_NO_CAST_FROM_ASCII</code> 来禁用此运算符。然后你需要调用 <a target="_blank" rel="noopener" href="https://doc.qt.io/qt-6/qstring.html#fromUtf8">QString::fromUtf8</a>(), [QString::fromLatin1](<a target="_blank" rel="noopener" href="https://doc.qt/">https://doc.qt</a>. io/qt-6/qstring.html#fromLatin1)() 或 <a target="_blank" rel="noopener" href="https://doc.qt.io/qt-6/qstring.html#fromLocal8Bit">QString::fromLocal8Bit</a>() 如果你想明确在进行比较之前将字节数组转换为 <a target="_blank" rel="noopener" href="https://doc.qt.io/qt-6/qstring.html">QString</a>。</p>
<h3><span id="qbytearray-amp-qbytearray-operator-const-qbytearray-amp-ba"> &amp;QByteArray::operator+=(const  &amp;<em>ba</em>)</span><a href="#qbytearray-amp-qbytearray-operator-const-qbytearray-amp-ba" class="header-anchor">#</a></h3><p>将字节数组 <em>ba</em> 附加到此字节数组的末尾并返回对此字节数组的引用。</p>
<p>例子：</p>
<div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-function">QByteArray <span class="hljs-title">x</span><span class="hljs-params">(<span class="hljs-string">"free"</span>)</span></span>;
<span class="hljs-function">QByteArray <span class="hljs-title">y</span><span class="hljs-params">(<span class="hljs-string">"dom"</span>)</span></span>;
x += y;
<span class="hljs-comment">// x == "freedom"</span></code></pre></div>

<p>注意：<a href="QByteArray.md">QByteArray</a> 是一个[隐式共享](<a target="_blank" rel="noopener" href="https://doc.qt.io/qt-6/implicit-sharing.html">https://doc.qt.io/qt-6/implicit-sharing.html</a> ） 班级。 因此，如果您追加到一个空字节数组，那么字节数组将只共享保存在 *ba* 中的数据。 在这种情况下，不会复制数据，需要 <a target="_blank" rel="noopener" href="https://doc.qt.io/qt-6/containers.html#constant-time">恒定时间</a>。 如果共享实例被修改，它将被复制（写时复制），需要[线性时间]（<a target="_blank" rel="noopener" href="https://doc.qt.io/qt-6/containers.html#linear-time%EF%BC%89%E3%80%82">https://doc.qt.io/qt-6/containers.html#linear-time）。</a></p>
<p>如果要附加的字节数组不为空，则执行数据的深层复制，花费 <a target="_blank" rel="noopener" href="https://doc.qt.io/qt-6/containers.html#linear-time">线性时间</a>。</p>
<p>此操作通常不会受到分配开销的影响，因为 <a href="QByteArray.md">QByteArray</a> 在数据末尾预先分配了额外的空间，因此它可以增长而无需重新分配 每个附加操作。</p>
<p><strong>也可以看看</strong> <a href="QByteArray.md#append">append</a>() and <a href="QByteArray.md#prepend">prepend</a>().</p>
<h3><span id="qbytearray-amp-qbytearray-operator-char-ch"> &amp;QByteArray::operator+=(char <em>ch</em>)</span><a href="#qbytearray-amp-qbytearray-operator-char-ch" class="header-anchor">#</a></h3><p>这是一个重载函数。</p>
<p>将字节 <em>ch</em> 附加到此字节数组的末尾并返回对此字节数组的引用。</p>
<h3><span id="qbytearray-amp-qbytearray-operator-const-char-str"> &amp;QByteArray::operator+=(const char *<em>str</em>)</span><a href="#qbytearray-amp-qbytearray-operator-const-char-str" class="header-anchor">#</a></h3><p>这是一个重载函数。</p>
<p>将 ‘\0’ 结尾的字符串 <em>str</em> 附加到此字节数组的末尾并返回对此字节数组的引用。</p>
<h3><span id="bool-qbytearray-operator-lt-const-qstring-amp-str-const">bool QByteArray::operator&lt;(const  &amp;<em>str</em>) const</span><a href="#bool-qbytearray-operator-lt-const-qstring-amp-str-const" class="header-anchor">#</a></h3><p>如果此字节数组在词法上小于 <em>str</em> 的 UTF-8 编码，则返回 <code>true</code>； 否则返回<code>false</code>。</p>
<p>比较区分大小写。</p>
<p>您可以在编译应用程序时通过定义 <code>QT_NO_CAST_FROM_ASCII</code> 来禁用此运算符。 然后你需要调用 <a target="_blank" rel="noopener" href="https://doc.qt.io/qt-6/qstring.html#fromUtf8">QString::fromUtf8</a>(), [QString::fromLatin1](<a target="_blank" rel="noopener" href="https://doc.qt/">https://doc.qt</a>. io/qt-6/qstring.html#fromLatin1)() 或 <a target="_blank" rel="noopener" href="https://doc.qt.io/qt-6/qstring.html#fromLocal8Bit">QString::fromLocal8Bit</a>() 如果你想明确 在进行比较之前将字节数组转换为 <a target="_blank" rel="noopener" href="https://doc.qt.io/qt-6/qstring.html">QString</a>。</p>
<h3><span id="bool-qbytearray-operator-lt-const-qstring-amp-str-const">bool QByteArray::operator&lt;=(const  &amp;<em>str</em>) const</span><a href="#bool-qbytearray-operator-lt-const-qstring-amp-str-const" class="header-anchor">#</a></h3><p>如果此字节数组在词法上小于或等于 <em>str</em> 的 UTF-8 编码，则返回 <code>true</code>； 否则返回<code>false</code>。</p>
<p>比较区分大小写。</p>
<p>您可以在编译应用程序时通过定义 <code>QT_NO_CAST_FROM_ASCII</code> 来禁用此运算符。 然后你需要调用 <a target="_blank" rel="noopener" href="https://doc.qt.io/qt-6/qstring.html#fromUtf8">QString::fromUtf8</a>(), [QString::fromLatin1](<a target="_blank" rel="noopener" href="https://doc.qt/">https://doc.qt</a>. io/qt-6/qstring.html#fromLatin1)() 或 <a target="_blank" rel="noopener" href="https://doc.qt.io/qt-6/qstring.html#fromLocal8Bit">QString::fromLocal8Bit</a>() 如果你想明确 在进行比较之前将字节数组转换为 <a target="_blank" rel="noopener" href="https://doc.qt.io/qt-6/qstring.html">QString</a>。</p>
<h3><span id="qbytearray-amp-qbytearray-operator-const-char-str"> &amp;QByteArray::operator=(const char *<em>str</em>)</span><a href="#qbytearray-amp-qbytearray-operator-const-char-str" class="header-anchor">#</a></h3><p>这是一个重载函数。</p>
<p>将 <em>str</em> 分配给此字节数组。</p>
<h3><span id="bool-qbytearray-operator-const-qstring-amp-str-const">bool QByteArray::operator==(const  &amp;<em>str</em>) const</span><a href="#bool-qbytearray-operator-const-qstring-amp-str-const" class="header-anchor">#</a></h3><p>如果此字节数组等于 <em>str</em> 的 UTF-8 编码，则返回 <code>true</code>； 否则返回<code>false</code>。</p>
<p>比较区分大小写。</p>
<p>您可以在编译应用程序时通过定义 <code>QT_NO_CAST_FROM_ASCII</code> 来禁用此运算符。 然后你需要调用 <a target="_blank" rel="noopener" href="https://doc.qt.io/qt-6/qstring.html#fromUtf8">QString::fromUtf8</a>(), [QString::fromLatin1](<a target="_blank" rel="noopener" href="https://doc.qt/">https://doc.qt</a>. io/qt-6/qstring.html#fromLatin1)() 或 <a target="_blank" rel="noopener" href="https://doc.qt.io/qt-6/qstring.html#fromLocal8Bit">QString::fromLocal8Bit</a>() 如果你想明确 在进行比较之前将字节数组转换为 <a target="_blank" rel="noopener" href="https://doc.qt.io/qt-6/qstring.html">QString</a>。</p>
<h3><span id="bool-qbytearray-operator-gt-const-qstring-amp-str-const">bool QByteArray::operator&gt;(const  &amp;<em>str</em>) const</span><a href="#bool-qbytearray-operator-gt-const-qstring-amp-str-const" class="header-anchor">#</a></h3><p>如果此字节数组在词法上大于 <em>str</em> 的 UTF-8 编码，则返回 <code>true</code>； 否则返回<code>false</code>。</p>
<p>比较区分大小写。</p>
<p>您可以在编译应用程序时通过定义 <code>QT_NO_CAST_FROM_ASCII</code> 来禁用此运算符。 然后你需要调用 <a target="_blank" rel="noopener" href="https://doc.qt.io/qt-6/qstring.html#fromUtf8">QString::fromUtf8</a>(), [QString::fromLatin1](<a target="_blank" rel="noopener" href="https://doc.qt/">https://doc.qt</a>. io/qt-6/qstring.html#fromLatin1)() 或 <a target="_blank" rel="noopener" href="https://doc.qt.io/qt-6/qstring.html#fromLocal8Bit">QString::fromLocal8Bit</a>() 如果你想明确 在进行比较之前将字节数组转换为 <a target="_blank" rel="noopener" href="https://doc.qt.io/qt-6/qstring.html">QString</a>。</p>
<h3><span id="bool-qbytearray-operator-gt-const-qstring-amp-str-const">bool QByteArray::operator&gt;=(const  &amp;<em>str</em>) const</span><a href="#bool-qbytearray-operator-gt-const-qstring-amp-str-const" class="header-anchor">#</a></h3><p>如果此字节数组大于或等于 <em>str</em> 的 UTF-8 编码，则返回 <code>true</code>； 否则返回<code>false</code>。</p>
<p>比较区分大小写。</p>
<p>您可以在编译应用程序时通过定义 <code>QT_NO_CAST_FROM_ASCII</code> 来禁用此运算符。 然后你需要调用 <a target="_blank" rel="noopener" href="https://doc.qt.io/qt-6/qstring.html#fromUtf8">QString::fromUtf8</a>(), [QString::fromLatin1](<a target="_blank" rel="noopener" href="https://doc.qt/">https://doc.qt</a>. io/qt-6/qstring.html#fromLatin1)() 或 <a target="_blank" rel="noopener" href="https://doc.qt.io/qt-6/qstring.html#fromLocal8Bit">QString::fromLocal8Bit</a>() 如果你想明确 在进行比较之前将字节数组转换为 <a target="_blank" rel="noopener" href="https://doc.qt.io/qt-6/qstring.html">QString</a>。</p>
<h3><span id="char-amp-qbytearray-operator-qsizetype-i">char &amp;QByteArray::operator[](qsizetype *i*)</span><a href="#char-amp-qbytearray-operator-qsizetype-i" class="header-anchor">#</a></h3><p>返回索引位置 <em>i</em> 处的字节作为可修改的引用。</p>
<p><em>i</em> 必须是字节数组中的有效索引位置（即 0 &lt;= <em>i</em> &lt; <a href="QByteArray.md#size">size</a>()） .</p>
<p>例子：</p>
<div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-function">QByteArray <span class="hljs-title">ba</span><span class="hljs-params">(<span class="hljs-string">"Hello, world"</span>)</span></span>;
cout &lt;&lt; ba[<span class="hljs-number">0</span>]; <span class="hljs-comment">// prints H</span>
ba[<span class="hljs-number">7</span>] = <span class="hljs-string">'W'</span>;
<span class="hljs-comment">// ba == "Hello, World"</span></code></pre></div>

<p><strong>也可以看看</strong> <a href="QByteArray.md#at">at</a>().</p>
<h3><span id="char-qbytearray-operator-qsizetype-i-const">char QByteArray::operator[](qsizetype *i*) const</span><a href="#char-qbytearray-operator-qsizetype-i-const" class="header-anchor">#</a></h3><p>这是一个重载函数。</p>
<p>与 at(<em>i</em>) 相同。</p>
<h2><span id="related-non-members">Related Non-Members</span><a href="#related-non-members" class="header-anchor">#</a></h2><h3><span id="since-6-1-template-qsizetype-erase-qbytearray-amp-ba-const-t-amp-t"><code>[since 6.1]</code>template <typename t> qsizetype erase(<a href="QByteArray.md#QByteArray">QByteArray</a> &amp;<em>ba</em>, const T &amp;<em>t</em>)</typename></span><a href="#since-6-1-template-qsizetype-erase-qbytearray-amp-ba-const-t-amp-t" class="header-anchor">#</a></h3><p>从字节数组 <em>ba</em> 中删除所有比较等于 <em>t</em> 的元素。 返回删除的元素数量（如果有）。</p>
<p>这个函数是在 Qt 6.1 中引入的。</p>
<p><strong>也可以看看</strong> <a href="QByteArray.md#erase_if">erase_if</a>.</p>
<h3><span id="since-6-1-template-qsizetype-erase-if-qbytearray-amp-ba-predicate-pred"><code>[since 6.1]</code>template <typename predicate> qsizetype erase_if(<a href="QByteArray.md#QByteArray">QByteArray</a> &amp;<em>ba</em>, Predicate <em>pred</em>)</typename></span><a href="#since-6-1-template-qsizetype-erase-if-qbytearray-amp-ba-predicate-pred" class="header-anchor">#</a></h3><p>从字节数组 <em>ba</em> 中删除谓词 <em>pred</em> 返回 true 的所有元素。 返回删除的元素数量（如果有）。</p>
<p>这个函数是在 Qt 6.1 中引入的。</p>
<p><strong>也可以看看</strong> <a href="QByteArray.md#erase">erase</a>.</p>
<h3><span id="since-5-9-quint16-qchecksum-qbytearrayview-data-qt-checksumtype-standard-qt-checksumiso3309"><code>[since 5.9]</code> qChecksum( <em>data</em>,  <em>standard</em> = Qt::ChecksumIso3309)</span><a href="#since-5-9-quint16-qchecksum-qbytearrayview-data-qt-checksumtype-standard-qt-checksumiso3309" class="header-anchor">#</a></h3><p>返回 <em>data</em> 的 CRC-16 校验和。</p>
<p>校验和与字节顺序（字节序）无关，将根据<em>标准</em>中发布的算法进行计算。 默认情况下，使用 ISO 3309 (<a target="_blank" rel="noopener" href="https://doc.qt.io/qt-6/qt.html#ChecksumType-enum">Qt::ChecksumIso3309</a>) 中发布的算法。</p>
<p><strong>注意：</strong> 此函数是 CRC-16-CCITT 算法的 16 位缓存保存（16 项表）实现。</p>
<p>这个函数是在 Qt 5.9 中引入的。</p>
<h3><span id="qbytearray-qcompress-const-qbytearray-amp-data-int-compressionlevel-1"> qCompress(const  &amp;<em>data</em>, int <em>compressionLevel</em> = -1)</span><a href="#qbytearray-qcompress-const-qbytearray-amp-data-int-compressionlevel-1" class="header-anchor">#</a></h3><p>压缩 <em>data</em> 字节数组并在新的字节数组中返回压缩数据。</p>
<p><em>compressionLevel</em> 参数指定应该使用多少压缩。 有效值介于 0 和 9 之间，其中 9 对应于最大压缩（即较小的压缩数据），代价是使用较慢的算法。 较小的值 (8, 7, …, 1) 以稍快的速度提供连续较少的压缩。 值 0 对应于根本没有压缩。 默认值为 -1，它指定 zlib 的默认压缩。</p>
<p><strong>也可以看看</strong> <a href="QByteArray.md#qUncompress-1">qUncompress</a>(const QByteArray &amp;data).</p>
<h3><span id="qbytearray-qcompress-const-uchar-data-qsizetype-nbytes-int-compressionlevel-1"> qCompress(const  *<em>data</em>, qsizetype <em>nbytes</em>, int <em>compressionLevel</em> = -1)</span><a href="#qbytearray-qcompress-const-uchar-data-qsizetype-nbytes-int-compressionlevel-1" class="header-anchor">#</a></h3><p>这是一个重载函数。</p>
<p>在压缩级别 <em>compressionLevel</em> 压缩 <em>data</em> 的前 <em>nbytes</em> 并在新的字节数组中返回压缩数据。</p>
<h3><span id="qbytearray-quncompress-const-qbytearray-amp-data"> qUncompress(const  &amp;<em>data</em>)</span><a href="#qbytearray-quncompress-const-qbytearray-amp-data" class="header-anchor">#</a></h3><p>解压缩 <em>data</em> 字节数组并返回一个包含未压缩数据的新字节数组。</p>
<p>如果输入数据损坏，则返回一个空的 <a href="QByteArray.md">QByteArray</a>。</p>
<p>此功能将解压缩使用 <a href="QByteArray.md#qCompress">qCompress</a>() 压缩的数据，从这个和任何早期 Qt 版本，回到 Qt 3.1 添加此功能时 .</p>
<p><strong>注意：</strong> 如果要使用此函数解压缩使用 zlib 压缩的外部数据，首先需要在包含数据的字节数组中添加一个四字节的标头。 标头必须包含未压缩数据的预期长度（以字节为单位），以无符号、大端、32 位整数表示。</p>
<p><strong>也可以看看</strong> <a href="QByteArray.md#qCompress">qCompress</a>().</p>
<h3><span id="qbytearray-quncompress-const-uchar-data-qsizetype-nbytes"> qUncompress(const  *<em>data</em>, qsizetype <em>nbytes</em>)</span><a href="#qbytearray-quncompress-const-uchar-data-qsizetype-nbytes" class="header-anchor">#</a></h3><p>这是一个重载函数。</p>
<p>解压缩 <em>data</em> 的第一个 <em>nbytes</em> 并返回一个包含未压缩数据的新字节数组。</p>
<h3><span id="int-qsnprintf-char-str-size-t-n-const-char-fmt">int qsnprintf(char *<em>str</em>, size_t <em>n</em>, const char *<em>fmt</em>, …)</span><a href="#int-qsnprintf-char-str-size-t-n-const-char-fmt" class="header-anchor">#</a></h3><p>一个可移植的 snprintf() 函数，调用 qvsnprintf。</p>
<p><em>fmt</em> 是 <code>printf()</code> 格式字符串。 结果被放入 <em>str</em>，这是一个至少 <em>n</em> 字节的缓冲区。</p>
<p><strong>警告：</strong> 仅当您知道自己在做什么时才调用此函数，因为它在某些平台上显示不同的行为。 改用 <a target="_blank" rel="noopener" href="https://doc.qt.io/qt-6/qstring.html#asprintf">QString::asprintf</a>() 来格式化字符串。</p>
<p><strong>也可以看看</strong> <a href="QByteArray.md#qvsnprintf">qvsnprintf</a>() and <a target="_blank" rel="noopener" href="https://doc.qt.io/qt-6/qstring.html#asprintf">QString::asprintf</a>().</p>
<h3><span id="int-qstrcmp-const-char-str1-const-char-str2">int qstrcmp(const char *<em>str1</em>, const char *<em>str2</em>)</span><a href="#int-qstrcmp-const-char-str1-const-char-str2" class="header-anchor">#</a></h3><p>一个安全的<code>strcmp()</code>函数。</p>
<p>比较 <em>str1</em> 和 <em>str2</em>。 如果 <em>str1</em> 小于 <em>str2</em> 返回负值，如果 <em>str1</em> 等于 <em>str2</em> 返回 0，如果 <em>str1</em> 大于 <em>str2</em> 返回正值。</p>
<p>如果两个字符串都是<code>nullptr</code>，它们被认为是相等的； 否则，如果其中一个是 <code>nullptr</code>，则将其视为小于另一个（即使另一个是空字符串）。</p>
<p><strong>也可以看看</strong> <a href="QByteArray.md#qstrncmp">qstrncmp</a>(), <a href="QByteArray.md#qstricmp">qstricmp</a>(), <a href="QByteArray.md#qstrnicmp">qstrnicmp</a>(), <a href="QByteArray.md#character-case">Character Case</a>, and <a href="QByteArray.md#compare">QByteArray::compare</a>().</p>
<h3><span id="char-qstrcpy-char-dst-const-char-src">char *qstrcpy(char *<em>dst</em>, const char *<em>src</em>)</span><a href="#char-qstrcpy-char-dst-const-char-src" class="header-anchor">#</a></h3><p>将 <em>src</em> 中直到 ‘\0’ 的所有字符复制到 <em>dst</em> 中，并返回指向 <em>dst</em> 的指针。 如果 <em>src</em> 是 <code>nullptr</code>，它会立即返回 <code>nullptr</code>。</p>
<p>该函数假定 <em>dst</em> 足够大以容纳 <em>src</em> 的内容。</p>
<p><strong>注意：</strong> 如果 <em>dst</em> 和 <em>src</em> 重叠，则行为未定义。</p>
<p><strong>也可以看看</strong> <a href="QByteArray.md#qstrncpy">qstrncpy</a>().</p>
<h3><span id="char-qstrdup-const-char-src">char *qstrdup(const char *<em>src</em>)</span><a href="#char-qstrdup-const-char-src" class="header-anchor">#</a></h3><p>返回一个重复的字符串。</p>
<p>为 <em>src</em> 的副本分配空间，复制它，并返回一个指向副本的指针。 如果 <em>src</em> 是 <code>nullptr</code>，它会立即返回 <code>nullptr</code>。</p>
<p>所有权传递给调用者，因此必须使用 <code>delete[]</code> 删除返回的字符串。</p>
<h3><span id="int-qstricmp-const-char-str1-const-char-str2">int qstricmp(const char *<em>str1</em>, const char *<em>str2</em>)</span><a href="#int-qstricmp-const-char-str1-const-char-str2" class="header-anchor">#</a></h3><p>一个安全的 <code>stricmp()</code> 函数。</p>
<p>比较 <em>str1</em> 和 <em>str2</em>，忽略任何 ASCII 字符大小写的差异。</p>
<p>如果 <em>str1</em> 小于 <em>str2</em> 返回负值，如果 <em>str1</em> 等于 <em>str2</em> 返回 0，如果 <em>str1</em> 大于 <em>str2</em> 返回正值。</p>
<p>如果两个字符串都是<code>nullptr</code>，它们被认为是相等的； 否则，如果其中一个是 <code>nullptr</code>，则将其视为小于另一个（即使另一个是空字符串）。</p>
<p><strong>也可以看看</strong> <a href="QByteArray.md#qstrcmp">qstrcmp</a>(), <a href="QByteArray.md#qstrncmp">qstrncmp</a>(), <a href="QByteArray.md#qstrnicmp">qstrnicmp</a>(), <a href="QByteArray.md#character-case">Character Case</a>, and <a href="QByteArray.md#compare">QByteArray::compare</a>().</p>
<h3><span id="size-t-qstrlen-const-char-str">size_t qstrlen(const char *<em>str</em>)</span><a href="#size-t-qstrlen-const-char-str" class="header-anchor">#</a></h3><p>一个安全的 <code>strlen()</code> 函数。</p>
<p>返回终止 ‘\0’ 之前的字符数，如果 <em>str</em> 是 <code>nullptr</code>，则返回 0。</p>
<p><strong>也可以看看</strong> <a href="QByteArray.md#qstrnlen">qstrnlen</a>().</p>
<h3><span id="int-qstrncmp-const-char-str1-const-char-str2-size-t-len">int qstrncmp(const char *<em>str1</em>, const char *<em>str2</em>, size_t <em>len</em>)</span><a href="#int-qstrncmp-const-char-str1-const-char-str2-size-t-len" class="header-anchor">#</a></h3><p>一个安全的 <code>strncmp()</code> 函数。</p>
<p>最多比较 <em>str1</em> 和 <em>str2</em> 的 <em>len</em> 字节。</p>
<p>如果 <em>str1</em> 小于 <em>str2</em> 返回负值，如果 <em>str1</em> 等于 <em>str2</em> 返回 0，如果 <em>str1</em> 大于 <em>str2</em> 返回正值。</p>
<p>如果两个字符串都是<code>nullptr</code>，它们被认为是相等的； 否则，如果其中一个是 <code>nullptr</code>，则将其视为小于另一个（即使另一个是空字符串或 <em>len</em> 为 0）。</p>
<p><strong>也可以看看</strong> <a href="QByteArray.md#qstrcmp">qstrcmp</a>(), <a href="QByteArray.md#qstricmp">qstricmp</a>(), <a href="QByteArray.md#qstrnicmp">qstrnicmp</a>(), <a href="QByteArray.md#character-case">Character Case</a>, and <a href="QByteArray.md#compare">QByteArray::compare</a>().</p>
<h3><span id="char-qstrncpy-char-dst-const-char-src-size-t-len">char *qstrncpy(char *<em>dst</em>, const char *<em>src</em>, size_t <em>len</em>)</span><a href="#char-qstrncpy-char-dst-const-char-src-size-t-len" class="header-anchor">#</a></h3><p>一个安全的 <code>strncpy()</code> 函数。</p>
<p>最多从 <em>src</em> 复制 <em>len</em> 个字节（停止在 <em>len</em> 或终止的 ‘\0’ 以先到者为准）到 <em>dst</em> 并返回指向 <em>dst</em> 的指针。 保证 <em>dst</em> 以 ‘\0’ 结尾。 如果 <em>src</em> 或 <em>dst</em> 是 <code>nullptr</code>，则立即返回 <code>nullptr</code>。</p>
<p>此函数假定 <em>dst</em> 至少为 <em>len</em> 个字符长。</p>
<p><strong>注意：</strong> 如果 <em>dst</em> 和 <em>src</em> 重叠，则行为未定义。</p>
<p><strong>也可以看看</strong> <a href="QByteArray.md#qstrcpy">qstrcpy</a>().</p>
<h3><span id="int-qstrnicmp-const-char-str1-const-char-str2-size-t-len">int qstrnicmp(const char *<em>str1</em>, const char *<em>str2</em>, size_t <em>len</em>)</span><a href="#int-qstrnicmp-const-char-str1-const-char-str2-size-t-len" class="header-anchor">#</a></h3><p>一个安全的 <code>strnicmp()</code> 函数。</p>
<p>最多比较 <em>str1</em> 和 <em>str2</em> 的 <em>len</em> 字节，忽略任何 ASCII 字符大小写的差异。</p>
<p>如果 <em>str1</em> 小于 <em>str2</em> 返回负值，如果 <em>str1</em> 等于 <em>str2</em> 返回 0，如果 <em>str1</em> 大于 <em>str2</em> 返回正值。</p>
<p>如果两个字符串都是<code>nullptr</code>，它们被认为是相等的； 否则，如果其中一个是 <code>nullptr</code>，则将其视为小于另一个（即使另一个是空字符串或 <em>len</em> 为 0）。</p>
<p><strong>也可以看看</strong> <a href="QByteArray.md#qstrcmp">qstrcmp</a>(), <a href="QByteArray.md#qstrncmp">qstrncmp</a>(), <a href="QByteArray.md#qstricmp">qstricmp</a>(), <a href="QByteArray.md#character-case">Character Case</a>, and <a href="QByteArray.md#compare">QByteArray::compare</a>().</p>
<h3><span id="size-t-qstrnlen-const-char-str-size-t-maxlen">size_t qstrnlen(const char *<em>str</em>, size_t <em>maxlen</em>)</span><a href="#size-t-qstrnlen-const-char-str-size-t-maxlen" class="header-anchor">#</a></h3><p>一个安全的 <code>strlen()</code> 函数。<br>返回终止 ‘\0’ 之前的字符数，但最多 <em>maxlen</em>。 如果 <em>string</em> 是 <code>nullptr</code>，则返回 0。</p>
<p><strong>也可以看看</strong> <a href="QByteArray.md#qstrlen">qstrlen</a>().</p>
<h3><span id="int-qvsnprintf-char-str-size-t-n-const-char-fmt-va-list-ap">int qvsnprintf(char *<em>str</em>, size_t <em>n</em>, const char *<em>fmt</em>, va_list <em>ap</em>)</span><a href="#int-qvsnprintf-char-str-size-t-n-const-char-fmt-va-list-ap" class="header-anchor">#</a></h3><p>一个可移植的 <code>vsnprintf()</code> 函数。 将根据系统调用 <code>::vsnprintf()</code>、<code>::_vsnprintf()</code> 或 <code>::vsnprintf_s</code>，或回退到内部版本。</p>
<p><em>fmt</em> 是 <code>printf()</code> 格式字符串。 结果被放入 <em>str</em>，这是一个至少 <em>n</em> 字节的缓冲区。</p>
<p>调用者负责在 <em>ap</em> 上调用 <code>va_end()</code>。</p>
<p><strong>警告：</strong> 由于 vsnprintf() 在某些平台上显示不同的行为，您不应依赖返回值或您将始终返回 0 终止字符串的事实。</p>
<p>理想情况下，您永远不应调用此函数，而应使用 <a target="_blank" rel="noopener" href="https://doc.qt.io/qt-6/qstring.html#asprintf">QString::asprintf</a>() 代替。</p>
<p><strong>也可以看看</strong> <a href="QByteArray.md#qsnprintf">qsnprintf</a>() and <a target="_blank" rel="noopener" href="https://doc.qt.io/qt-6/qstring.html#asprintf">QString::asprintf</a>().</p>
<h3><span id="bool-operator-const-qbytearray-amp-a1-const-qbytearray-amp-a2">bool operator!=(const  &amp;<em>a1</em>, const  &amp;<em>a2</em>)</span><a href="#bool-operator-const-qbytearray-amp-a1-const-qbytearray-amp-a2" class="header-anchor">#</a></h3><p>这是一个重载函数。</p>
<p>如果字节数组 <em>a1</em> 不等于字节数组 <em>a2</em>，则返回 <code>true</code>； 否则返回<code>false</code>。</p>
<p><strong>也可以看看</strong> <a href="QByteArray.md#compare">QByteArray::compare</a>().</p>
<h3><span id="bool-operator-const-qbytearray-amp-a1-const-char-a2">bool operator!=(const  &amp;<em>a1</em>, const char *<em>a2</em>)</span><a href="#bool-operator-const-qbytearray-amp-a1-const-char-a2" class="header-anchor">#</a></h3><p>这是一个重载函数。</p>
<p>如果字节数组 <em>a1</em> 不等于以 ‘\0’ 结尾的字符串 <em>a2</em>，则返回 <code>true</code>； 否则返回<code>false</code>。</p>
<p><strong>也可以看看</strong> <a href="QByteArray.md#compare">QByteArray::compare</a>().</p>
<h3><span id="bool-operator-const-char-a1-const-qbytearray-amp-a2">bool operator!=(const char *<em>a1</em>, const  &amp;<em>a2</em>)</span><a href="#bool-operator-const-char-a1-const-qbytearray-amp-a2" class="header-anchor">#</a></h3><p>这是一个重载函数。</p>
<p>如果以 ‘\0’ 结尾的字符串 <em>a1</em> 不等于字节数组 <em>a2</em>，则返回 <code>true</code>； 否则返回<code>false</code>。</p>
<p><strong>也可以看看</strong> <a href="QByteArray.md#compare">QByteArray::compare</a>().</p>
<h3><span id="since-6-2-qbytearray-operator-qba-const-char-str-size-t-size"><code>[since 6.2]</code> operator””_qba(const char *<em>str</em>, size_t <em>size</em>)</span><a href="#since-6-2-qbytearray-operator-qba-const-char-str-size-t-size" class="header-anchor">#</a></h3><p>用字符字符串文字 <em>str</em> 中的前 <em>size</em> 个字符创建 <a href="QByteArray.md">QByteArray</a> 的文字运算符。</p>
<p><a href="QByteArray.md">QByteArray</a>是在编译时创建的，生成的字符串数据存储在编译后的目标文件的只读段中。 重复的文字可能共享相同的只读内存。 此功能可与 <a href="QByteArray.md#QByteArrayLiteral">QByteArrayLiteral</a> 互换，但在代码中存在许多字符串文字时可以节省输入。</p>
<p>以下代码创建了一个 <a href="QByteArray.md">QByteArray</a>：</p>
<div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">auto</span> str = <span class="hljs-string">"hello"</span>_qba;</code></pre></div>

<p>这个函数是在 Qt 6.2 中引入的。</p>
<p><strong>也可以看看</strong> <a href="QByteArray.md#QByteArrayLiteral">QByteArrayLiteral</a> and <a target="_blank" rel="noopener" href="https://doc.qt.io/qt-6/qstring.html#operator-22-22_qs">QtLiterals::operator””_qs</a>(const char16_t *str, size_t size).</p>
<h3><span id="const-qbytearray-operator-const-qbytearray-amp-a1-const-qbytearray-amp-a2">const  operator+(const  &amp;<em>a1</em>, const  &amp;<em>a2</em>)</span><a href="#const-qbytearray-operator-const-qbytearray-amp-a1-const-qbytearray-amp-a2" class="header-anchor">#</a></h3><p>返回一个字节数组，它是连接字节数组 <em>a1</em> 和字节数组 <em>a2</em> 的结果。</p>
<p><strong>也可以看看</strong> <a href="QByteArray.md#operator-2b-eq">QByteArray::operator+=</a>().</p>
<h3><span id="const-qbytearray-operator-const-qbytearray-amp-a1-const-char-a2">const  operator+(const  &amp;<em>a1</em>, const char *<em>a2</em>)</span><a href="#const-qbytearray-operator-const-qbytearray-amp-a1-const-char-a2" class="header-anchor">#</a></h3><p>这是一个重载函数。</p>
<p>返回一个字节数组，它是连接字节数组 <em>a1</em> 和以 ‘\0’ 结尾的字符串 <em>a2</em> 的结果。</p>
<h3><span id="const-qbytearray-operator-const-qbytearray-amp-a1-char-a2">const  operator+(const  &amp;<em>a1</em>, char <em>a2</em>)</span><a href="#const-qbytearray-operator-const-qbytearray-amp-a1-char-a2" class="header-anchor">#</a></h3><p>这是一个重载函数。</p>
<p>返回一个字节数组，它是连接字节数组 <em>a1</em> 和字节 <em>a2</em> 的结果。</p>
<h3><span id="const-qbytearray-operator-const-char-a1-const-qbytearray-amp-a2">const  operator+(const char *<em>a1</em>, const  &amp;<em>a2</em>)</span><a href="#const-qbytearray-operator-const-char-a1-const-qbytearray-amp-a2" class="header-anchor">#</a></h3><p>这是一个重载函数。</p>
<p>返回一个字节数组，它是连接以 ‘\0’ 结尾的字符串 <em>a1</em> 和字节数组 <em>a2</em> 的结果。</p>
<h3><span id="const-qbytearray-operator-char-a1-const-qbytearray-amp-a2">const  operator+(char <em>a1</em>, const  &amp;<em>a2</em>)</span><a href="#const-qbytearray-operator-char-a1-const-qbytearray-amp-a2" class="header-anchor">#</a></h3><p>这是一个重载函数。</p>
<p>返回一个字节数组，它是连接字节 <em>a1</em> 和字节数组 <em>a2</em> 的结果。</p>
<h3><span id="bool-operator-lt-const-qbytearray-amp-a1-const-qbytearray-amp-a2">bool operator&lt;(const  &amp;<em>a1</em>, const  &amp;<em>a2</em>)</span><a href="#bool-operator-lt-const-qbytearray-amp-a1-const-qbytearray-amp-a2" class="header-anchor">#</a></h3><p>这是一个重载函数。</p>
<p>如果字节数组 <em>a1</em> 在词法上小于字节数组 <em>a2</em>，则返回 <code>true</code>； 否则返回<code>false</code>。</p>
<p><strong>也可以看看</strong> <a href="QByteArray.md#compare">QByteArray::compare</a>().</p>
<h3><span id="bool-operator-lt-const-qbytearray-amp-a1-const-char-a2">bool operator&lt;(const  &amp;<em>a1</em>, const char *<em>a2</em>)</span><a href="#bool-operator-lt-const-qbytearray-amp-a1-const-char-a2" class="header-anchor">#</a></h3><p>这是一个重载函数。</p>
<p>如果字节数组 <em>a1</em> 在词法上小于以 ‘\0’ 结尾的字符串 <em>a2</em>，则返回 <code>true</code>； 否则返回<code>false</code>。</p>
<p><strong>也可以看看</strong> <a href="QByteArray.md#compare">QByteArray::compare</a>().</p>
<h3><span id="bool-operator-lt-const-char-a1-const-qbytearray-amp-a2">bool operator&lt;(const char *<em>a1</em>, const  &amp;<em>a2</em>)</span><a href="#bool-operator-lt-const-char-a1-const-qbytearray-amp-a2" class="header-anchor">#</a></h3><p>这是一个重载函数。</p>
<p>如果以 ‘\0’ 结尾的字符串 <em>a1</em> 在词法上小于字节数组 <em>a2</em>，则返回 <code>true</code>； 否则返回<code>false</code>。</p>
<p><strong>也可以看看</strong> <a href="QByteArray.md#compare">QByteArray::compare</a>().</p>
<h3><span id="qdatastream-amp-operator-lt-lt-qdatastream-amp-out-const-qbytearray-amp-ba"> &amp;operator&lt;&lt;( &amp;<em>out</em>, const  &amp;<em>ba</em>)</span><a href="#qdatastream-amp-operator-lt-lt-qdatastream-amp-out-const-qbytearray-amp-ba" class="header-anchor">#</a></h3><p>将字节数组 <em>ba</em> 写入流 <em>out</em> 并返回对流的引用。</p>
<p><strong>也可以看看</strong> <a target="_blank" rel="noopener" href="https://doc.qt.io/qt-6/datastreamformat.html">Serializing Qt Data Types</a>.</p>
<h3><span id="bool-operator-lt-const-qbytearray-amp-a1-const-qbytearray-amp-a2">bool operator&lt;=(const  &amp;<em>a1</em>, const  &amp;<em>a2</em>)</span><a href="#bool-operator-lt-const-qbytearray-amp-a1-const-qbytearray-amp-a2" class="header-anchor">#</a></h3><p>这是一个重载函数。</p>
<p>如果字节数组 <em>a1</em> 在词法上小于或等于字节数组 <em>a2</em>，则返回 <code>true</code>；否则返回<code>false</code>。</p>
<p><strong>也可以看看</strong> <a href="QByteArray.md#compare">QByteArray::compare</a>().</p>
<h3><span id="bool-operator-lt-const-qbytearray-amp-a1-const-char-a2">bool operator&lt;=(const  &amp;<em>a1</em>, const char *<em>a2</em>)</span><a href="#bool-operator-lt-const-qbytearray-amp-a1-const-char-a2" class="header-anchor">#</a></h3><p>这是一个重载函数。</p>
<p>如果字节数组 <em>a1</em> 在词法上小于或等于字节数组 <em>a2</em>，则返回 <code>true</code>； 否则返回<code>false</code>。</p>
<p><strong>也可以看看</strong> <a href="QByteArray.md#compare">QByteArray::compare</a>().</p>
<h3><span id="bool-operator-lt-const-char-a1-const-qbytearray-amp-a2">bool operator&lt;=(const char *<em>a1</em>, const  &amp;<em>a2</em>)</span><a href="#bool-operator-lt-const-char-a1-const-qbytearray-amp-a2" class="header-anchor">#</a></h3><p>这是一个重载函数。</p>
<p>如果以 ‘\0’ 结尾的字符串 <em>a1</em> 在词法上小于或等于字节数组 <em>a2</em>，则返回 <code>true</code>；否则返回<code>false</code>。</p>
<p><strong>也可以看看</strong> <a href="QByteArray.md#compare">QByteArray::compare</a>().</p>
<h3><span id="bool-operator-const-qbytearray-amp-a1-const-qbytearray-amp-a2">bool operator==(const  &amp;<em>a1</em>, const  &amp;<em>a2</em>)</span><a href="#bool-operator-const-qbytearray-amp-a1-const-qbytearray-amp-a2" class="header-anchor">#</a></h3><p>这是一个重载函数。</p>
<p>如果字节数组 <em>a1</em> 等于字节数组 <em>a2</em>，则返回 <code>true</code>；否则返回<code>false</code>。</p>
<p><strong>也可以看看</strong> <a href="QByteArray.md#compare">QByteArray::compare</a>().</p>
<h3><span id="bool-operator-const-qbytearray-amp-a1-const-char-a2">bool operator==(const  &amp;<em>a1</em>, const char *<em>a2</em>)</span><a href="#bool-operator-const-qbytearray-amp-a1-const-char-a2" class="header-anchor">#</a></h3><p>这是一个重载函数。</p>
<p>如果字节数组 <em>a1</em> 等于以 ‘\0’ 结尾的字符串 <em>a2</em>，则返回 <code>true</code>；否则返回<code>false</code>。</p>
<p><strong>也可以看看</strong> <a href="QByteArray.md#compare">QByteArray::compare</a>().</p>
<h3><span id="bool-operator-const-char-a1-const-qbytearray-amp-a2">bool operator==(const char *<em>a1</em>, const  &amp;<em>a2</em>)</span><a href="#bool-operator-const-char-a1-const-qbytearray-amp-a2" class="header-anchor">#</a></h3><p>这是一个重载函数。</p>
<p>如果以 ‘\0’ 结尾的字符串 <em>a1</em> 等于字节数组 <em>a2</em>，则返回 <code>true</code>；否则返回<code>false</code>。</p>
<p><strong>也可以看看</strong> <a href="QByteArray.md#compare">QByteArray::compare</a>().</p>
<h3><span id="bool-operator-gt-const-qbytearray-amp-a1-const-qbytearray-amp-a2">bool operator&gt;(const  &amp;<em>a1</em>, const  &amp;<em>a2</em>)</span><a href="#bool-operator-gt-const-qbytearray-amp-a1-const-qbytearray-amp-a2" class="header-anchor">#</a></h3><p>这是一个重载函数。</p>
<p>如果字节数组 <em>a1</em> 在词法上大于或等于字节数组 <em>a2</em>，则返回 <code>true</code>；否则返回<code>false</code>。</p>
<p><strong>也可以看看</strong> <a href="QByteArray.md#compare">QByteArray::compare</a>().</p>
<h3><span id="bool-operator-gt-const-qbytearray-amp-a1-const-char-a2">bool operator&gt;(const  &amp;<em>a1</em>, const char *<em>a2</em>)</span><a href="#bool-operator-gt-const-qbytearray-amp-a1-const-char-a2" class="header-anchor">#</a></h3><p>这是一个重载函数。</p>
<p>如果字节数组 <em>a1</em> 在词法上大于字节数组 <em>a2</em>，则返回 <code>true</code>；否则返回<code>false</code>。</p>
<p><strong>也可以看看</strong> <a href="QByteArray.md#compare">QByteArray::compare</a>().</p>
<h3><span id="bool-operator-gt-const-char-a1-const-qbytearray-amp-a2">bool operator&gt;(const char *<em>a1</em>, const  &amp;<em>a2</em>)</span><a href="#bool-operator-gt-const-char-a1-const-qbytearray-amp-a2" class="header-anchor">#</a></h3><p>这是一个重载函数。</p>
<p>如果字节数组 <em>a1</em> 在词法上大于以 ‘\0’ 结尾的字符串 <em>a2</em>，则返回 <code>true</code>；否则返回<code>false</code>。</p>
<p><strong>也可以看看</strong> <a href="QByteArray.md#compare">QByteArray::compare</a>().</p>
<h3><span id="bool-operator-gt-const-qbytearray-amp-a1-const-qbytearray-amp-a2">bool operator&gt;=(const  &amp;<em>a1</em>, const  &amp;<em>a2</em>)</span><a href="#bool-operator-gt-const-qbytearray-amp-a1-const-qbytearray-amp-a2" class="header-anchor">#</a></h3><p>这是一个重载函数。</p>
<p>如果以 ‘\0’ 结尾的字符串 <em>a1</em> 在词法上大于字节数组 <em>a2</em>，则返回 <code>true</code>；否则返回<code>false</code>。</p>
<p><strong>也可以看看</strong> <a href="QByteArray.md#compare">QByteArray::compare</a>().</p>
<h3><span id="bool-operator-gt-const-qbytearray-amp-a1-const-char-a2">bool operator&gt;=(const  &amp;<em>a1</em>, const char *<em>a2</em>)</span><a href="#bool-operator-gt-const-qbytearray-amp-a1-const-char-a2" class="header-anchor">#</a></h3><p>这是一个重载函数。</p>
<p>如果字节数组 <em>a1</em> 在词法上大于或等于以 ‘\0’ 结尾的字符串 <em>a2</em>，则返回 <code>true</code>； 否则返回<code>false</code>。</p>
<p><strong>也可以看看</strong> <a href="QByteArray.md#compare">QByteArray::compare</a>().</p>
<h3><span id="bool-operator-gt-const-char-a1-const-qbytearray-amp-a2">bool operator&gt;=(const char *<em>a1</em>, const  &amp;<em>a2</em>)</span><a href="#bool-operator-gt-const-char-a1-const-qbytearray-amp-a2" class="header-anchor">#</a></h3><p>这是一个重载函数。</p>
<p>如果以 ‘\0’ 结尾的字符串 <em>a1</em> 在词法上大于或等于字节数组 <em>a2</em>，则返回 <code>true</code>； 否则返回<code>false</code>。</p>
<p><strong>也可以看看</strong> <a href="QByteArray.md#compare">QByteArray::compare</a>().</p>
<h3><span id="qdatastream-amp-operator-gt-gt-qdatastream-amp-in-qbytearray-amp-ba"> &amp;operator&gt;&gt;( &amp;<em>in</em>,  &amp;<em>ba</em>)</span><a href="#qdatastream-amp-operator-gt-gt-qdatastream-amp-in-qbytearray-amp-ba" class="header-anchor">#</a></h3><p>从流 <em>in</em> 中将字节数组读入 <em>ba</em> 并返回对流的引用。</p>
<p><strong>也可以看看</strong> <a target="_blank" rel="noopener" href="https://doc.qt.io/qt-6/datastreamformat.html">Serializing Qt Data Types</a>.</p>
<h2><span id="hong-wen-dang">宏文档</span><a href="#hong-wen-dang" class="header-anchor">#</a></h2><h3><span id="qbytearrayliteral-ba">QByteArrayLiteral(<em>ba</em>)</span><a href="#qbytearrayliteral-ba" class="header-anchor">#</a></h3><p>该宏在编译时从字符串文字 <em>ba</em> 生成 <a href="QByteArray.md">QByteArray</a> 的数据。 在这种情况下，从中创建一个 <a href="QByteArray.md">QByteArray</a> 是免费的，并且生成的字节数组数据存储在编译对象的只读段中 文件。</p>
<p>例如：</p>
<div class="code-wrapper"><pre><code class="hljs c++">QByteArray ba = <span class="hljs-built_in">QByteArrayLiteral</span>(<span class="hljs-string">"byte array contents"</span>);</code></pre></div>

<p>使用 QByteArrayLiteral 而不是双引号的纯 C++ 字符串文字可以显着加快从编译时已知的数据创建 <a href="QByteArray.md">QByteArray</a> 实例。</p>
<p><strong>也可以看看</strong> <a target="_blank" rel="noopener" href="https://doc.qt.io/qt-6/qstring.html#QStringLiteral">QStringLiteral</a>.</p>
<h3><span id="qt-no-cast-from-bytearray">QT_NO_CAST_FROM_BYTEARRAY</span><a href="#qt-no-cast-from-bytearray" class="header-anchor">#</a></h3><p>禁用从 <a href="QByteArray.md">QByteArray</a> 到 const char * 或 const void * 的自动转换。</p>
<p><strong>也可以看看</strong> <a target="_blank" rel="noopener" href="https://doc.qt.io/qt-6/qstring.html#QT_NO_CAST_TO_ASCII">QT_NO_CAST_TO_ASCII</a> and <a target="_blank" rel="noopener" href="https://doc.qt.io/qt-6/qstring.html#QT_NO_CAST_FROM_ASCII">QT_NO_CAST_FROM_ASCII</a>.</p>

            </div>
            <hr>
            <div>
              <div class="post-metas mb-3">
                
                
                  <div class="post-meta">
                    <i class="iconfont icon-tags"></i>
                    
                      <a class="hover-with-bg" href="/tags/B/">B</a>
                    
                  </div>
                
              </div>
              
                <p class="note note-warning">
                  
                    本博客所有文章除特别声明外，均采用 <a target="_blank" href="https://creativecommons.org/licenses/by-sa/4.0/deed.zh" rel="nofollow noopener noopener">CC BY-SA 4.0 协议</a> ，转载请注明出处！
                  
                </p>
              
              
                <div class="post-prevnext">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/2022/03/02/QtDocumentCN/Src/B/QBitArray/QBitArray/">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">QBitArray类</span>
                        <span class="visible-mobile">上一篇</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2022/03/02/QtDocumentCN/Src/B/QByteArrayMatcher/QByteArrayMatcher/">
                        <span class="hidden-mobile">QByteArrayMatcher类</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
              <!-- Comments -->
              <article class="comments" id="comments" lazyload>
                
                  
                
                
  <div id="lv-container" data-id="city" data-uid="MTAyMC81NTMzMi8zMTc5OQ==">
    <script type="text/javascript">
      Fluid.utils.loadComments('#lv-container', function() {
        Fluid.utils.createScript('https://cdn-city.livere.com/js/embed.dist.js');
      });
    </script>
    <noscript>Please enable JavaScript to view the comments</noscript>
  </div>


              </article>
            
          </article>
        </div>
      </div>
    </div>
    
      <div class="d-none d-lg-block col-lg-2 toc-container" id="toc-ctn">
        <div id="toc">
  <p class="toc-header"><i class="iconfont icon-list"></i>&nbsp;目录</p>
  <div class="toc-body" id="toc-body"></div>
</div>

      </div>
    
  </div>
</div>

<!-- Custom -->


    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v"
                 for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>
    

    
  </main>

  <footer class="text-center mt-5 py-3">
  <div class="footer-content">
     <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> 
  </div>
  

  

  
</footer>


  <!-- SCRIPTS -->
  
  <script  src="https://cdn.jsdelivr.net/npm/nprogress@0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/nprogress@0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js" ></script>
<script  src="https://cdn.jsdelivr.net/npm/bootstrap@4/dist/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>

<!-- Plugins -->


  <script  src="/js/local-search.js" ></script>



  
    <script  src="/js/img-lazyload.js" ></script>
  



  



  
    <script  src="https://cdn.jsdelivr.net/npm/tocbot@4/dist/tocbot.min.js" ></script>
  
  
    <script  src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3/dist/jquery.fancybox.min.js" ></script>
  
  
    <script  src="https://cdn.jsdelivr.net/npm/anchor-js@4/anchor.min.js" ></script>
  
  
    <script defer src="https://cdn.jsdelivr.net/npm/clipboard@2/dist/clipboard.min.js" ></script>
  






  <script  src="https://cdn.jsdelivr.net/npm/typed.js@2/lib/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var title = document.getElementById('subtitle').title;
      
        typing(title);
      
    })(window, document);
  </script>















<!-- 主题的启动项 保持在最底部 -->
<script  src="/js/boot.js" ></script>


</body>
</html>
