

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=auto>



<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/logo.jpg">
  <link rel="icon" href="/img/logo.jpg">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
    <meta http-equiv="Content-Security-Policy" content="upgrade-insecure-requests">
  
  <meta name="theme-color" content="#6aa84f">
  <meta name="author" content="John Doe">
  <meta name="keywords" content="">
  
    <meta name="description" content="QPainter Class 公共类型 公共函数 详细描述 设置 绘制 绘制Pixmaps和图像 渲染质量 坐标变换 剪辑 构成模式 限制因素 性能   成员类型文档 enum QPainter::CompositionMode enum QPainter::PixmapFragmentHint flags QPainter::PixmapFragmentHints enum QPain">
<meta property="og:type" content="article">
<meta property="og:title" content="QPainter类">
<meta property="og:url" content="https://txt1994.github.io/2022/03/02/QtDocumentCN/Src/P/QPainter/QPainter/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:description" content="QPainter Class 公共类型 公共函数 详细描述 设置 绘制 绘制Pixmaps和图像 渲染质量 坐标变换 剪辑 构成模式 限制因素 性能   成员类型文档 enum QPainter::CompositionMode enum QPainter::PixmapFragmentHint flags QPainter::PixmapFragmentHints enum QPain">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://doc.qt.io/qt-6/images/qpainter-basicdrawing.png">
<meta property="og:image" content="https://doc.qt.io/qt-6/images/qpainter-painterpaths.png">
<meta property="og:image" content="https://doc.qt.io/qt-6/images/qpainter-vectordeformation.png">
<meta property="og:image" content="https://doc.qt.io/qt-6/images/qpainter-gradients.png">
<meta property="og:image" content="https://doc.qt.io/qt-6/images/qpainter-pathstroking.png">
<meta property="og:image" content="https://doc.qt.io/qt-6/images/qpainter-concentriccircles.png">
<meta property="og:image" content="https://doc.qt.io/qt-6/images/qpainter-clock.png">
<meta property="og:image" content="https://doc.qt.io/qt-6/images/qpainter-rotation.png">
<meta property="og:image" content="https://doc.qt.io/qt-6/images/qpainter-scale.png">
<meta property="og:image" content="https://doc.qt.io/qt-6/images/qpainter-translation.png">
<meta property="og:image" content="https://doc.qt.io/qt-6/images/qpainter-affinetransformations.png">
<meta property="og:image" content="https://doc.qt.io/qt-6/images/qpainter-compositiondemo.png">
<meta property="og:image" content="https://doc.qt.io/qt-6/images/qpainter-compositionmode1.png">
<meta property="og:image" content="https://doc.qt.io/qt-6/images/qpainter-compositionmode2.png">
<meta property="og:image" content="https://doc.qt.io/qt-6/images/qpainter-arc.png">
<meta property="og:image" content="https://doc.qt.io/qt-6/images/qpainter-chord.png">
<meta property="og:image" content="https://doc.qt.io/qt-6/images/qpainter-polygon.png">
<meta property="og:image" content="https://doc.qt.io/qt-6/images/qpainter-ellipse.png">
<meta property="og:image" content="https://doc.qt.io/qt-6/images/qpainter-line.png">
<meta property="og:image" content="https://doc.qt.io/qt-6/images/qpainter-path.png">
<meta property="og:image" content="https://doc.qt.io/qt-6/images/qpainter-pie.png">
<meta property="og:image" content="https://doc.qt.io/qt-6/images/qpainter-pie.png">
<meta property="og:image" content="https://doc.qt.io/qt-6/images/qpainter-polygon.png">
<meta property="og:image" content="https://doc.qt.io/qt-6/images/qpainter-rectangle.png">
<meta property="og:image" content="https://doc.qt.io/qt-6/images/qpainter-roundrect.png">
<meta property="og:image" content="https://doc.qt.io/qt-6/images/qpainter-text.png">
<meta property="og:image" content="https://doc.qt.io/qt-6/images/qpainter-text.png">
<meta property="og:image" content="https://doc.qt.io/qt-6/images/qpainter-text-bounds.png">
<meta property="og:image" content="https://doc.qt.io/qt-6/images/qpainter-text-bounds.png">
<meta property="article:published_time" content="2022-03-02T06:47:47.000Z">
<meta property="article:modified_time" content="2022-03-18T16:50:20.264Z">
<meta property="article:author" content="John Doe">
<meta property="article:tag" content="P">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="https://doc.qt.io/qt-6/images/qpainter-basicdrawing.png">
  
  
  <title>QPainter类 - Hexo</title>

  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4/dist/css/bootstrap.min.css" />


  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/github-markdown-css@4/github-markdown.min.css" />
  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/hint.css@2/hint.min.css" />

  
    
    
      
      <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@10/styles/github-gist.min.css" />
    
  

  
    <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3/dist/jquery.fancybox.min.css" />
  


<!-- 主题依赖的图标库，不要自行修改 -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_ba1fz6golrf.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_lbnruvf0jn.css">


<link  rel="stylesheet" href="/css/main.css" />

<!-- 自定义样式保持在最底部 -->

  
<link rel="stylesheet" href="/css/style.css">



  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    var CONFIG = {"hostname":"txt1994.github.io","root":"/","version":"1.8.14","typing":{"enable":true,"typeSpeed":70,"cursorChar":"_","loop":false},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"right","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"copy_btn":true,"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":false,"baidu":null,"google":null,"gtag":null,"tencent":{"sid":null,"cid":null},"woyaola":null,"cnzz":null,"leancloud":{"app_id":null,"app_key":null,"server_url":null,"path":"window.location.pathname","ignore_local":false}},"search_path":"/local-search.xml"};
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
<meta name="generator" content="Hexo 6.1.0">
<style>.github-emoji { position: relative; display: inline-block; width: 1.2em; min-height: 1.2em; overflow: hidden; vertical-align: top; color: transparent; }  .github-emoji > span { position: relative; z-index: 10; }  .github-emoji img, .github-emoji .fancybox { margin: 0 !important; padding: 0 !important; border: none !important; outline: none !important; text-decoration: none !important; user-select: none !important; cursor: auto !important; }  .github-emoji img { height: 1.2em !important; width: 1.2em !important; position: absolute !important; left: 50% !important; top: 50% !important; transform: translate(-50%, -50%) !important; user-select: none !important; cursor: auto !important; } .github-emoji-fallback { color: inherit; } .github-emoji-fallback img { opacity: 0 !important; }</style>
</head>


<body>
  <header style="height: 70vh;">
    <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/">
      <strong>txt1994s</strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/">
                <i class="iconfont icon-home-fill"></i>
                首页
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/">
                <i class="iconfont icon-archive-fill"></i>
                归档
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/">
                <i class="iconfont icon-tags-fill"></i>
                标签
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/">
                <i class="iconfont icon-user-fill"></i>
                关于
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/links/">
                <i class="iconfont icon-link-fill"></i>
                友联
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              &nbsp;<i class="iconfont icon-search"></i>&nbsp;
            </a>
          </li>
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">&nbsp;<i
                class="iconfont icon-dark" id="color-toggle-icon"></i>&nbsp;</a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

    <div class="banner" id="banner" parallax=true
         style="background: url('/img/default.png') no-repeat center center;
           background-size: cover;">
      <div class="full-bg-img">
        <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
          <div class="page-header text-center fade-in-up">
            <span class="h2" id="subtitle" title="QPainter类">
              
            </span>

            
              <div class="mt-3">
  
  
    <span class="post-meta">
      <i class="iconfont icon-date-fill" aria-hidden="true"></i>
      <time datetime="2022-03-02 14:47" pubdate>
        2022年3月2日 下午
      </time>
    </span>
  
</div>

<div class="mt-1">
  
    <span class="post-meta mr-2">
      <i class="iconfont icon-chart"></i>
      68k 字
    </span>
  

  
    <span class="post-meta mr-2">
      <i class="iconfont icon-clock-fill"></i>
      
      
      571 分钟
    </span>
  

  
  
</div>

            
          </div>

          
        </div>
      </div>
    </div>
  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="d-none d-lg-block col-lg-2"></div>
    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div class="py-5" id="board">
          <article class="post-content mx-auto">
            <!-- SEO header -->
            <h1 style="display: none">QPainter类</h1>
            
              <p class="note note-info">
                
                  本文最后更新于：2022年3月19日 凌晨
                
              </p>
            
            <div class="markdown-body">
              <div class="toc">

<!-- toc -->

<ul>
<li><a href="#qpainter-class">QPainter Class</a><ul>
<li><a href="#gong-gong-lei-xing">公共类型</a></li>
<li><a href="#gong-gong-han-shu">公共函数</a></li>
<li><a href="#xiang-xi-miao-shu">详细描述</a><ul>
<li><a href="#she-zhi">设置</a></li>
<li><a href="#hui-zhi">绘制</a></li>
<li><a href="#hui-zhi-pixmaps-he-tu-xiang">绘制Pixmaps和图像</a></li>
<li><a href="#xuan-ran-zhi-liang">渲染质量</a></li>
<li><a href="#zuo-biao-bian-huan">坐标变换</a></li>
<li><a href="#jian-ji">剪辑</a></li>
<li><a href="#gou-cheng-mo-shi">构成模式</a></li>
<li><a href="#xian-zhi-yin-su">限制因素</a></li>
<li><a href="#xing-neng">性能</a></li>
</ul>
</li>
<li><a href="#cheng-yuan-lei-xing-wen-dang">成员类型文档</a><ul>
<li><a href="#enum-qpainter-compositionmode">enum QPainter::CompositionMode</a></li>
<li><a href="#enum-qpainter-pixmapfragmenthint-flags-qpainter-pixmapfragmenthints">enum QPainter::PixmapFragmentHint flags QPainter::PixmapFragmentHints</a></li>
<li><a href="#enum-qpainter-renderhint-flags-qpainter-renderhints">enum QPainter::RenderHint flags QPainter::RenderHints</a></li>
</ul>
</li>
<li><a href="#cheng-yuan-han-shu-wen-dang">成员函数文档</a><ul>
<li><a href="#qpainter-qpainter-qpaintdevice-qt-6-qpaintdevice-html-device">QPainter::QPainter(</a><a href="qt-6/qpaintdevice.html">QPaintDevice</a> *<em>device</em>)</li>
<li><a href="#qpainter-qpainter">QPainter::QPainter()</a></li>
<li><a href="#qpainter-qpainter">QPainter::~QPainter()</a></li>
<li><a href="#const-qbrush-qt-6-qbrush-html-qpainter-background-const">const </a><a href="qt-6/qbrush.html">QBrush</a> &amp;QPainter::background() const</li>
<li><a href="#qt-bgmode-qt-6-qt-html-bgmode-enum-qpainter-backgroundmode-const">Qt::BGMode</a></li>
<li><a href="#bool-qpainter-begin-qpaintdevice-qt-6-qpaintdevice-html-device">bool QPainter::begin(</a><a href="qt-6/qpaintdevice.html">QPaintDevice</a> *<em>device</em>)</li>
<li><a href="#void-qpainter-beginnativepainting">void QPainter::beginNativePainting()</a></li>
<li><a href="#qrectf-qt-6-qrectf-html-qpainter-boundingrect-const-qrectf-qt-6-qrectf-html-rectangle-int-flags-const-qstring-qt-6-qstring-html-text">QRectF</a></li>
<li><a href="#qrect-qt-6-qrect-html-qpainter-boundingrect-const-qrect-qt-6-qrect-html-rectangle-int-flags-const-qstring-qt-6-qstring-html-text">QRect</a></li>
<li><a href="#qrect-qt-6-qrect-html-qpainter-boundingrect-int-x-int-y-int-w-int-h-int-flags-const-qstring-qt-6-qstring-html-text-1">QRect</a></li>
<li><a href="#qrectf-qt-6-qrectf-html-qpainter-boundingrect-const-qrectf-qt-6-qrectf-html-rectangle-const-qstring-qt-6-qstring-html-text-const-qtextoption-qt-6-qtextoption-html-option-qtextoption-1">QRectF</a></li>
<li><a href="#const-qbrush-qt-6-qbrush-html-qpainter-brush-const">const </a><a href="qt-6/qbrush.html">QBrush</a> &amp;QPainter::brush() const</li>
<li><a href="#qpoint-qt-6-qpoint-html-qpainter-brushorigin-const">QPoint</a></li>
<li><a href="#qrectf-qt-6-qrectf-html-qpainter-clipboundingrect-const-2">QRectF</a></li>
<li><a href="#qpainterpath-qt-6-qpainterpath-html-qpainter-clippath-const">QPainterPath</a></li>
<li><a href="#qregion-qt-6-qregion-html-qpainter-clipregion-const">QRegion</a></li>
<li><a href="#qtransform-qt-6-qtransform-html-qpainter-combinedtransform-const">QTransform</a></li>
<li><a href="#qpainter-compositionmode-compositionmode-enum-qpainter-compositionmode-const">QPainter::CompositionMode</a></li>
<li><a href="#qpaintdevice-qt-6-qpaintdevice-html-qpainter-device-const">QPaintDevice</a></li>
<li><a href="#const-qtransform-qt-6-qtransform-html-qpainter-devicetransform-const">const </a><a href="qt-6/qtransform.html">QTransform</a> &amp;QPainter::deviceTransform() const</li>
<li><a href="#void-qpainter-drawarc-const-qrectf-qt-6-qrectf-html-rectangle-int-startangle-int-spanangle">void QPainter::drawArc(const </a><a href="qt-6/qrectf.html">QRectF</a> &amp;<em>rectangle</em>, int <em>startAngle</em>, int <em>spanAngle</em>)</li>
<li><a href="#void-qpainter-drawarc-const-qrect-qt-6-qrect-html-rectangle-int-startangle-int-spanangle">void QPainter::drawArc(const </a><a href="qt-6/qrect.html">QRect</a> &amp;<em>rectangle</em>, int <em>startAngle</em>, int <em>spanAngle</em>)</li>
<li><a href="#void-qpainter-drawarc-int-x-int-y-int-width-int-height-int-startangle-int-spanangle">void QPainter::drawArc(int <em>x</em>, int <em>y</em>, int <em>width</em>, int <em>height</em>, int <em>startAngle</em>, int <em>spanAngle</em>)</a></li>
<li><a href="#void-qpainter-drawchord-const-qrectf-qt-6-qrectf-html-rectangle-int-startangle-int-spanangle">void QPainter::drawChord(const </a><a href="qt-6/qrectf.html">QRectF</a> &amp;<em>rectangle</em>, int <em>startAngle</em>, int <em>spanAngle</em>)</li>
<li><a href="#void-qpainter-drawchord-int-x-int-y-int-width-int-height-int-startangle-int-spanangle">void QPainter::drawChord(int <em>x</em>, int <em>y</em>, int <em>width</em>, int <em>height</em>, int <em>startAngle</em>, int <em>spanAngle</em>)</a></li>
<li><a href="#void-qpainter-drawchord-const-qrect-qt-6-qrect-html-rectangle-int-startangle-int-spanangle">void QPainter::drawChord(const </a><a href="qt-6/qrect.html">QRect</a> &amp;<em>rectangle</em>, int <em>startAngle</em>, int <em>spanAngle</em>)</li>
<li><a href="#void-qpainter-drawconvexpolygon-const-qpointf-qt-6-qpointf-html-points-int-pointcount">void QPainter::drawConvexPolygon(const </a><a href="qt-6/qpointf.html">QPointF</a> *<em>points</em>, int <em>pointCount</em>)</li>
<li><a href="#void-qpainter-drawconvexpolygon-const-qpolygonf-qt-6-qpolygonf-html-polygon">void QPainter::drawConvexPolygon(const </a><a href="qt-6/qpolygonf.html">QPolygonF</a> &amp;<em>polygon</em>)</li>
<li><a href="#void-qpainter-drawconvexpolygon-const-qpoint-qt-6-qpoint-html-points-int-pointcount">void QPainter::drawConvexPolygon(const </a><a href="qt-6/qpoint.html">QPoint</a> *<em>points</em>, int <em>pointCount</em>)</li>
<li><a href="#void-qpainter-drawconvexpolygon-const-qpolygon-qt-6-qpolygon-html-polygon">void QPainter::drawConvexPolygon(const </a><a href="qt-6/qpolygon.html">QPolygon</a> &amp;<em>polygon</em>)</li>
<li><a href="#void-qpainter-drawellipse-const-qrectf-qt-6-qrectf-html-rectangle">void QPainter::drawEllipse(const </a><a href="qt-6/qrectf.html">QRectF</a> &amp;<em>rectangle</em>)</li>
<li><a href="#void-qpainter-drawellipse-const-qrect-qt-6-qrect-html-rectangle">void QPainter::drawEllipse(const </a><a href="qt-6/qrect.html">QRect</a> &amp;<em>rectangle</em>)</li>
<li><a href="#void-qpainter-drawellipse-int-x-int-y-int-width-int-height">void QPainter::drawEllipse(int <em>x</em>, int <em>y</em>, int <em>width</em>, int <em>height</em>)</a></li>
<li><a href="#void-qpainter-drawellipse-const-qpointf-qt-6-qpointf-html-center-qreal-qt-6-qtglobal-html-qreal-typedef-rx-qreal-qt-6-qtglobal-html-qreal-typedef-ry">void QPainter::drawEllipse(const </a><a href="qt-6/qpointf.html">QPointF</a> &amp;<em>center</em>, <a href="qt-6/qtglobal.html#qreal-typedef">qreal</a> <em>rx</em>, <a href="qt-6/qtglobal.html#qreal-typedef">qreal</a> <em>ry</em>)</li>
<li><a href="#void-qpainter-drawellipse-const-qpoint-qt-6-qpoint-html-center-int-rx-int-ry">void QPainter::drawEllipse(const </a><a href="qt-6/qpoint.html">QPoint</a> &amp;<em>center</em>, int <em>rx</em>, int <em>ry</em>)</li>
<li><a href="#void-qpainter-drawglyphrun-const-qpointf-qt-6-qpointf-html-position-const-qglyphrun-qt-6-qglyphrun-html-glyphs">void QPainter::drawGlyphRun(const </a><a href="qt-6/qpointf.html">QPointF</a> &amp;<em>position</em>, const <a href="qt-6/qglyphrun.html">QGlyphRun</a> &amp;<em>glyphs</em>)</li>
<li><a href="#void-qpainter-drawimage-const-qrectf-qt-6-qrectf-html-target-const-qimage-qt-6-qimage-html-image-const-qrectf-qt-6-qrectf-html-source-qt-imageconversionflags-qt-6-qt-html-imageconversionflag-enum-flags-qt-autocolor">void QPainter::drawImage(const </a><a href="qt-6/qrectf.html">QRectF</a> &amp;<em>target</em>, const <a href="qt-6/qimage.html">QImage</a> &amp;<em>image</em>, const <a href="qt-6/qrectf.html">QRectF</a> &amp;<em>source</em>, <a href="qt-6/qt.html#ImageConversionFlag-enum">Qt::ImageConversionFlags</a> <em>flags</em> = Qt::AutoColor)</li>
<li><a href="#void-qpainter-drawimage-const-qrect-qt-6-qrect-html-target-const-qimage-qt-6-qimage-html-image-const-qrect-qt-6-qrect-html-source-qt-imageconversionflags-qt-6-qt-html-imageconversionflag-enum-flags-qt-autocolor">void QPainter::drawImage(const </a><a href="qt-6/qrect.html">QRect</a> &amp;<em>target</em>, const <a href="qt-6/qimage.html">QImage</a> &amp;<em>image</em>, const <a href="qt-6/qrect.html">QRect</a> &amp;<em>source</em>, <a href="qt-6/qt.html#ImageConversionFlag-enum">Qt::ImageConversionFlags</a> <em>flags</em> = Qt::AutoColor)</li>
<li><a href="#void-qpainter-drawimage-const-qpointf-qt-6-qpointf-html-point-const-qimage-qt-6-qimage-html-image-const-qrectf-qt-6-qrectf-html-source-qt-imageconversionflags-qt-6-qt-html-imageconversionflag-enum-flags-qt-autocolor">void QPainter::drawImage(const </a><a href="qt-6/qpointf.html">QPointF</a> &amp;<em>point</em>, const <a href="qt-6/qimage.html">QImage</a> &amp;<em>image</em>, const <a href="qt-6/qrectf.html">QRectF</a> &amp;<em>source</em>, <a href="qt-6/qt.html#ImageConversionFlag-enum">Qt::ImageConversionFlags</a> <em>flags</em> = Qt::AutoColor)</li>
<li><a href="#void-qpainter-drawimage-const-qpoint-qt-6-qpoint-html-point-const-qimage-qt-6-qimage-html-image-const-qrect-qt-6-qrect-html-source-qt-imageconversionflags-qt-6-qt-html-imageconversionflag-enum-flags-qt-autocolor">void QPainter::drawImage(const </a><a href="qt-6/qpoint.html">QPoint</a> &amp;<em>point</em>, const <a href="qt-6/qimage.html">QImage</a> &amp;<em>image</em>, const <a href="qt-6/qrect.html">QRect</a> &amp;<em>source</em>, <a href="qt-6/qt.html#ImageConversionFlag-enum">Qt::ImageConversionFlags</a> <em>flags</em> = Qt::AutoColor)</li>
<li><a href="#void-qpainter-drawimage-const-qrectf-qt-6-qrectf-html-rectangle-const-qimage-qt-6-qimage-html-image">void QPainter::drawImage(const </a><a href="qt-6/qrectf.html">QRectF</a> &amp;<em>rectangle</em>, const <a href="qt-6/qimage.html">QImage</a> &amp;<em>image</em>)</li>
<li><a href="#void-qpainter-drawimage-const-qrect-qt-6-qrect-html-rectangle-const-qimage-qt-6-qimage-html-image">void QPainter::drawImage(const </a><a href="qt-6/qrect.html">QRect</a> &amp;<em>rectangle</em>, const <a href="qt-6/qimage.html">QImage</a> &amp;<em>image</em>)</li>
<li><a href="#void-qpainter-drawimage-const-qpointf-qt-6-qpointf-html-point-const-qimage-qt-6-qimage-html-image">void QPainter::drawImage(const </a><a href="qt-6/qpointf.html">QPointF</a> &amp;<em>point</em>, const <a href="qt-6/qimage.html">QImage</a> &amp;<em>image</em>)</li>
<li><a href="#void-qpainter-drawimage-const-qpoint-qt-6-qpoint-html-point-const-qimage-qt-6-qimage-html-image">void QPainter::drawImage(const </a><a href="qt-6/qpoint.html">QPoint</a> &amp;<em>point</em>, const <a href="qt-6/qimage.html">QImage</a> &amp;<em>image</em>)</li>
<li><a href="#void-qpainter-drawimage-int-x-int-y-const-qimage-qt-6-qimage-html-image-int-sx-0-int-sy-0-int-sw-1-int-sh-1-qt-imageconversionflags-qt-6-qt-html-imageconversionflag-enum-flags-qt-autocolor">void QPainter::drawImage(int <em>x</em>, int <em>y</em>, const </a><a href="qt-6/qimage.html">QImage</a> &amp;<em>image</em>, int <em>sx</em> = 0, int <em>sy</em> = 0, int <em>sw</em> = -1, int <em>sh</em> = -1, <a href="qt-6/qt.html#ImageConversionFlag-enum">Qt::ImageConversionFlags</a> <em>flags</em> = Qt::AutoColor)</li>
<li><a href="#void-qpainter-drawline-const-qlinef-qt-6-qlinef-html-line">void QPainter::drawLine(const </a><a href="qt-6/qlinef.html">QLineF</a> &amp;<em>line</em>)</li>
<li><a href="#void-qpainter-drawline-const-qline-qt-6-qline-html-line">void QPainter::drawLine(const </a><a href="qt-6/qline.html">QLine</a> &amp;<em>line</em>)</li>
<li><a href="#void-qpainter-drawline-int-x1-int-y1-int-x2-int-y2">void QPainter::drawLine(int <em>x1</em>, int <em>y1</em>, int <em>x2</em>, int <em>y2</em>)</a></li>
<li><a href="#void-qpainter-drawline-const-qpoint-qt-6-qpoint-html-p1-const-qpoint-qt-6-qpoint-html-p2">void QPainter::drawLine(const </a><a href="qt-6/qpoint.html">QPoint</a> &amp;<em>p1</em>, const <a href="qt-6/qpoint.html">QPoint</a> &amp;<em>p2</em>)</li>
<li><a href="#void-qpainter-drawline-const-qpointf-qt-6-qpointf-html-p1-const-qpointf-qt-6-qpointf-html-p2">void QPainter::drawLine(const </a><a href="qt-6/qpointf.html">QPointF</a> &amp;<em>p1</em>, const <a href="qt-6/qpointf.html">QPointF</a> &amp;<em>p2</em>)</li>
<li><a href="#void-qpainter-drawlines-const-qlinef-qt-6-qlinef-html-lines-int-linecount">void QPainter::drawLines(const </a><a href="qt-6/qlinef.html">QLineF</a> *<em>lines</em>, int <em>lineCount</em>)</li>
<li><a href="#void-qpainter-drawlines-const-qlist-qt-6-qlist-html-qlinef-qt-6-qlinef-html-lines">void QPainter::drawLines(const </a><a href="qt-6/qlist.html">QList</a>&lt;<a href="qt-6/qlinef.html">QLineF</a>&gt; &amp;<em>lines</em>)</li>
<li><a href="#void-qpainter-drawlines-const-qpointf-qt-6-qpointf-html-pointpairs-int-linecount">void QPainter::drawLines(const </a><a href="qt-6/qpointf.html">QPointF</a> *<em>pointPairs</em>, int <em>lineCount</em>)</li>
<li><a href="#void-qpainter-drawlines-const-qlist-qt-6-qlist-html-qpointf-qt-6-qpointf-html-pointpairs">void QPainter::drawLines(const </a><a href="qt-6/qlist.html">QList</a>&lt;<a href="qt-6/qpointf.html">QPointF</a>&gt; &amp;<em>pointPairs</em>)</li>
<li><a href="#void-qpainter-drawlines-const-qline-qt-6-qline-html-lines-int-linecount">void QPainter::drawLines(const </a><a href="qt-6/qline.html">QLine</a> *<em>lines</em>, int <em>lineCount</em>)</li>
<li><a href="#void-qpainter-drawlines-const-qlist-qt-6-qlist-html-qline-qt-6-qline-html-lines">void QPainter::drawLines(const </a><a href="qt-6/qlist.html">QList</a>&lt;<a href="qt-6/qline.html">QLine</a>&gt; &amp;<em>lines</em>)</li>
<li><a href="#void-qpainter-drawlines-const-qpoint-qt-6-qpoint-html-pointpairs-int-linecount">void QPainter::drawLines(const </a><a href="qt-6/qpoint.html">QPoint</a> *<em>pointPairs</em>, int <em>lineCount</em>)</li>
<li><a href="#void-qpainter-drawlines-const-qlist-qt-6-qlist-html-qpoint-qt-6-qpoint-html-pointpairs">void QPainter::drawLines(const </a><a href="qt-6/qlist.html">QList</a>&lt;<a href="qt-6/qpoint.html">QPoint</a>&gt; &amp;<em>pointPairs</em>)</li>
<li><a href="#void-qpainter-drawpath-const-qpainterpath-qt-6-qpainterpath-html-path">void QPainter::drawPath(const </a><a href="qt-6/qpainterpath.html">QPainterPath</a> &amp;<em>path</em>)</li>
<li><a href="#void-qpainter-drawpicture-const-qpointf-qt-6-qpointf-html-point-const-qpicture-qt-6-qpicture-html-picture">void QPainter::drawPicture(const </a><a href="qt-6/qpointf.html">QPointF</a> &amp;<em>point</em>, const <a href="qt-6/qpicture.html">QPicture</a> &amp;<em>picture</em>)</li>
<li><a href="#void-qpainter-drawpicture-int-x-int-y-const-qpicture-qt-6-qpicture-html-picture">void QPainter::drawPicture(int <em>x</em>, int <em>y</em>, const </a><a href="qt-6/qpicture.html">QPicture</a> &amp;<em>picture</em>)</li>
<li><a href="#void-qpainter-drawpicture-const-qpoint-qt-6-qpoint-html-point-const-qpicture-qt-6-qpicture-html-picture">void QPainter::drawPicture(const </a><a href="qt-6/qpoint.html">QPoint</a> &amp;<em>point</em>, const <a href="qt-6/qpicture.html">QPicture</a> &amp;<em>picture</em>)</li>
<li><a href="#void-qpainter-drawpie-const-qrectf-qt-6-qrectf-html-rectangle-int-startangle-int-spanangle">void QPainter::drawPie(const </a><a href="qt-6/qrectf.html">QRectF</a> &amp;<em>rectangle</em>, int <em>startAngle</em>, int <em>spanAngle</em>)</li>
<li><a href="#void-qpainter-drawpie-int-x-int-y-int-width-int-height-int-startangle-int-spanangle">void QPainter::drawPie(int <em>x</em>, int <em>y</em>, int <em>width</em>, int <em>height</em>, int <em>startAngle</em>, int <em>spanAngle</em>)</a></li>
<li><a href="#void-qpainter-drawpie-const-qrect-qt-6-qrect-html-rectangle-int-startangle-int-spanangle">void QPainter::drawPie(const </a><a href="qt-6/qrect.html">QRect</a> &amp;<em>rectangle</em>, int <em>startAngle</em>, int <em>spanAngle</em>)</li>
<li><a href="#void-qpainter-drawpixmap-const-qrectf-qt-6-qrectf-html-target-const-qpixmap-qt-6-qpixmap-html-pixmap-const-qrectf-qt-6-qrectf-html-source">void QPainter::drawPixmap(const </a><a href="qt-6/qrectf.html">QRectF</a> &amp;<em>target</em>, const <a href="qt-6/qpixmap.html">QPixmap</a> &amp;<em>pixmap</em>, const <a href="qt-6/qrectf.html">QRectF</a> &amp;<em>source</em>)</li>
<li><a href="#void-qpainter-drawpixmap-const-qrect-qt-6-qrect-html-target-const-qpixmap-qt-6-qpixmap-html-pixmap-const-qrect-qt-6-qrect-html-source">void QPainter::drawPixmap(const </a><a href="qt-6/qrect.html">QRect</a> &amp;<em>target</em>, const <a href="qt-6/qpixmap.html">QPixmap</a> &amp;<em>pixmap</em>, const <a href="qt-6/qrect.html">QRect</a> &amp;<em>source</em>)</li>
<li><a href="#void-qpainter-drawpixmap-int-x-int-y-int-w-int-h-const-qpixmap-qt-6-qpixmap-html-pixmap-int-sx-int-sy-int-sw-int-sh">void QPainter::drawPixmap(int <em>x</em>, int <em>y</em>, int <em>w</em>, int <em>h</em>, const </a><a href="qt-6/qpixmap.html">QPixmap</a> &amp;<em>pixmap</em>, int <em>sx</em>, int <em>sy</em>, int <em>sw</em>, int <em>sh</em>)</li>
<li><a href="#void-qpainter-drawpixmap-int-x-int-y-const-qpixmap-qt-6-qpixmap-html-pixmap-int-sx-int-sy-int-sw-int-sh">void QPainter::drawPixmap(int <em>x</em>, int <em>y</em>, const </a><a href="qt-6/qpixmap.html">QPixmap</a> &amp;<em>pixmap</em>, int <em>sx</em>, int <em>sy</em>, int <em>sw</em>, int <em>sh</em>)</li>
<li><a href="#void-qpainter-drawpixmap-const-qpointf-qt-6-qpointf-html-point-const-qpixmap-qt-6-qpixmap-html-pixmap-const-qrectf-qt-6-qrectf-html-source">void QPainter::drawPixmap(const </a><a href="qt-6/qpointf.html">QPointF</a> &amp;<em>point</em>, const <a href="qt-6/qpixmap.html">QPixmap</a> &amp;<em>pixmap</em>, const <a href="qt-6/qrectf.html">QRectF</a> &amp;<em>source</em>)</li>
<li><a href="#void-qpainter-drawpixmap-const-qpoint-qt-6-qpoint-html-point-const-qpixmap-qt-6-qpixmap-html-pixmap-const-qrect-qt-6-qrect-html-source">void QPainter::drawPixmap(const </a><a href="qt-6/qpoint.html">QPoint</a> &amp;<em>point</em>, const <a href="qt-6/qpixmap.html">QPixmap</a> &amp;<em>pixmap</em>, const <a href="qt-6/qrect.html">QRect</a> &amp;<em>source</em>)</li>
<li><a href="#void-qpainter-drawpixmap-const-qpointf-qt-6-qpointf-html-point-const-qpixmap-qt-6-qpixmap-html-pixmap">void QPainter::drawPixmap(const </a><a href="qt-6/qpointf.html">QPointF</a> &amp;<em>point</em>, const <a href="qt-6/qpixmap.html">QPixmap</a> &amp;<em>pixmap</em>)</li>
<li><a href="#void-qpainter-drawpixmap-const-qpoint-qt-6-qpoint-html-point-const-qpixmap-qt-6-qpixmap-html-pixmap">void QPainter::drawPixmap(const </a><a href="qt-6/qpoint.html">QPoint</a> &amp;<em>point</em>, const <a href="qt-6/qpixmap.html">QPixmap</a> &amp;<em>pixmap</em>)</li>
<li><a href="#void-qpainter-drawpixmap-int-x-int-y-const-qpixmap-qt-6-qpixmap-html-pixmap">void QPainter::drawPixmap(int <em>x</em>, int <em>y</em>, const </a><a href="qt-6/qpixmap.html">QPixmap</a> &amp;<em>pixmap</em>)</li>
<li><a href="#void-qpainter-drawpixmap-const-qrect-qt-6-qrect-html-rectangle-const-qpixmap-qt-6-qpixmap-html-pixmap">void QPainter::drawPixmap(const </a><a href="qt-6/qrect.html">QRect</a> &amp;<em>rectangle</em>, const <a href="qt-6/qpixmap.html">QPixmap</a> &amp;<em>pixmap</em>)</li>
<li><a href="#void-qpainter-drawpixmap-int-x-int-y-int-width-int-height-const-qpixmap-qt-6-qpixmap-html-pixmap">void QPainter::drawPixmap(int <em>x</em>, int <em>y</em>, int <em>width</em>, int <em>height</em>, const </a><a href="qt-6/qpixmap.html">QPixmap</a> &amp;<em>pixmap</em>)</li>
<li><a href="#void-qpainter-drawpixmapfragments-const-qpainter-pixmapfragment-qt-6-qpainter-pixmapfragment-html-fragments-int-fragmentcount-const-qpixmap-qt-6-qpixmap-html-pixmap-qpainter-pixmapfragmenthints-pixmapfragmenthint-enum-hints-pixmapfragmenthints">void QPainter::drawPixmapFragments(const </a><a href="qt-6/qpainter-pixmapfragment.html">QPainter::PixmapFragment</a> *<em>fragments</em>, int <em>fragmentCount</em>, const <a href="qt-6/qpixmap.html">QPixmap</a> &amp;<em>pixmap</em>, <a href="#PixmapFragmentHint-enum">QPainter::PixmapFragmentHints</a> <em>hints</em> = PixmapFragmentHints())</li>
<li><a href="#void-qpainter-drawpoint-const-qpointf-qt-6-qpointf-html-position">void QPainter::drawPoint(const </a><a href="qt-6/qpointf.html">QPointF</a> &amp;<em>position</em>)</li>
<li><a href="#void-qpainter-drawpoint-const-qpoint-qt-6-qpoint-html-position">void QPainter::drawPoint(const </a><a href="qt-6/qpoint.html">QPoint</a> &amp;<em>position</em>)</li>
<li><a href="#void-qpainter-drawpoint-int-x-int-y">void QPainter::drawPoint(int <em>x</em>, int <em>y</em>)</a></li>
<li><a href="#void-qpainter-drawpoints-const-qpointf-qt-6-qpointf-html-points-int-pointcount">void QPainter::drawPoints(const </a><a href="qt-6/qpointf.html">QPointF</a> *<em>points</em>, int <em>pointCount</em>)</li>
<li><a href="#void-qpainter-drawpoints-const-qpolygonf-qt-6-qpolygonf-html-points">void QPainter::drawPoints(const </a><a href="qt-6/qpolygonf.html">QPolygonF</a> &amp;<em>points</em>)</li>
<li><a href="#void-qpainter-drawpoints-const-qpoint-qt-6-qpoint-html-points-int-pointcount">void QPainter::drawPoints(const </a><a href="qt-6/qpoint.html">QPoint</a> *<em>points</em>, int <em>pointCount</em>)</li>
<li><a href="#void-qpainter-drawpoints-const-qpolygon-qt-6-qpolygon-html-points">void QPainter::drawPoints(const </a><a href="qt-6/qpolygon.html">QPolygon</a> &amp;<em>points</em>)</li>
<li><a href="#void-qpainter-drawpolygon-const-qpointf-qt-6-qpointf-html-points-int-pointcount-qt-fillrule-qt-6-qt-html-fillrule-enum-fillrule-qt-oddevenfill">void QPainter::drawPolygon(const </a><a href="qt-6/qpointf.html">QPointF</a> *<em>points</em>, int <em>pointCount</em>, <a href="qt-6/qt.html#FillRule-enum">Qt::FillRule</a> <em>fillRule</em> = Qt::OddEvenFill)</li>
<li><a href="#void-qpainter-drawpolygon-const-qpolygonf-qt-6-qpolygonf-html-points-qt-fillrule-qt-6-qt-html-fillrule-enum-fillrule-qt-oddevenfill">void QPainter::drawPolygon(const </a><a href="qt-6/qpolygonf.html">QPolygonF</a> &amp;<em>points</em>, <a href="qt-6/qt.html#FillRule-enum">Qt::FillRule</a> <em>fillRule</em> = Qt::OddEvenFill)</li>
<li><a href="#void-qpainter-drawpolygon-const-qpoint-qt-6-qpoint-html-points-int-pointcount-qt-fillrule-qt-6-qt-html-fillrule-enum-fillrule-qt-oddevenfill">void QPainter::drawPolygon(const </a><a href="qt-6/qpoint.html">QPoint</a> *<em>points</em>, int <em>pointCount</em>, <a href="qt-6/qt.html#FillRule-enum">Qt::FillRule</a> <em>fillRule</em> = Qt::OddEvenFill)</li>
<li><a href="#void-qpainter-drawpolygon-const-qpolygon-qt-6-qpolygon-html-points-qt-fillrule-qt-6-qt-html-fillrule-enum-fillrule-qt-oddevenfill">void QPainter::drawPolygon(const </a><a href="qt-6/qpolygon.html">QPolygon</a> &amp;<em>points</em>, <a href="qt-6/qt.html#FillRule-enum">Qt::FillRule</a> <em>fillRule</em> = Qt::OddEvenFill)</li>
<li><a href="#void-qpainter-drawpolyline-const-qpointf-qt-6-qpointf-html-points-int-pointcount">void QPainter::drawPolyline(const </a><a href="qt-6/qpointf.html">QPointF</a> *<em>points</em>, int <em>pointCount</em>)</li>
<li><a href="#void-qpainter-drawpolyline-const-qpolygonf-qt-6-qpolygonf-html-points">void QPainter::drawPolyline(const </a><a href="qt-6/qpolygonf.html">QPolygonF</a> &amp;<em>points</em>)</li>
<li><a href="#void-qpainter-drawpolyline-const-qpoint-qt-6-qpoint-html-points-int-pointcount">void QPainter::drawPolyline(const </a><a href="qt-6/qpoint.html">QPoint</a> *<em>points</em>, int <em>pointCount</em>)</li>
<li><a href="#void-qpainter-drawpolyline-const-qpolygon-qt-6-qpolygon-html-points">void QPainter::drawPolyline(const </a><a href="qt-6/qpolygon.html">QPolygon</a> &amp;<em>points</em>)</li>
<li><a href="#void-qpainter-drawrect-const-qrectf-qt-6-qrectf-html-rectangle">void QPainter::drawRect(const </a><a href="qt-6/qrectf.html">QRectF</a> &amp;<em>rectangle</em>)</li>
<li><a href="#void-qpainter-drawrect-int-x-int-y-int-width-int-height">void QPainter::drawRect(int <em>x</em>, int <em>y</em>, int <em>width</em>, int <em>height</em>)</a></li>
<li><a href="#void-qpainter-drawrect-const-qrect-qt-6-qrect-html-rectangle">void QPainter::drawRect(const </a><a href="qt-6/qrect.html">QRect</a> &amp;<em>rectangle</em>)</li>
<li><a href="#void-qpainter-drawrects-const-qrectf-qt-6-qrectf-html-rectangles-int-rectcount">void QPainter::drawRects(const </a><a href="qt-6/qrectf.html">QRectF</a> *<em>rectangles</em>, int <em>rectCount</em>)</li>
<li><a href="#void-qpainter-drawrects-const-qlist-qt-6-qlist-html-qrectf-qt-6-qrectf-html-rectangles">void QPainter::drawRects(const </a><a href="qt-6/qlist.html">QList</a>&lt;<a href="qt-6/qrectf.html">QRectF</a>&gt; &amp;<em>rectangles</em>)</li>
<li><a href="#void-qpainter-drawrects-const-qrect-qt-6-qrect-html-rectangles-int-rectcount">void QPainter::drawRects(const </a><a href="qt-6/qrect.html">QRect</a> *<em>rectangles</em>, int <em>rectCount</em>)</li>
<li><a href="#void-qpainter-drawrects-const-qlist-qt-6-qlist-html-qrect-qt-6-qrect-html-rectangles">void QPainter::drawRects(const </a><a href="qt-6/qlist.html">QList</a>&lt;<a href="qt-6/qrect.html">QRect</a>&gt; &amp;<em>rectangles</em>)</li>
<li><a href="#void-qpainter-drawroundedrect-const-qrectf-qt-6-qrectf-html-rect-qreal-qt-6-qtglobal-html-qreal-typedef-xradius-qreal-qt-6-qtglobal-html-qreal-typedef-yradius-qt-sizemode-qt-6-qt-html-sizemode-enum-mode-qt-absolutesize">void QPainter::drawRoundedRect(const </a><a href="qt-6/qrectf.html">QRectF</a> &amp;<em>rect</em>, <a href="qt-6/qtglobal.html#qreal-typedef">qreal</a> <em>xRadius</em>, <a href="qt-6/qtglobal.html#qreal-typedef">qreal</a> <em>yRadius</em>, <a href="qt-6/qt.html#SizeMode-enum">Qt::SizeMode</a> <em>mode</em> = Qt::AbsoluteSize)</li>
<li><a href="#void-qpainter-drawroundedrect-int-x-int-y-int-w-int-h-qreal-qt-6-qtglobal-html-qreal-typedef-xradius-qreal-qt-6-qtglobal-html-qreal-typedef-yradius-qt-sizemode-qt-6-qt-html-sizemode-enum-mode-qt-absolutesize">void QPainter::drawRoundedRect(int <em>x</em>, int <em>y</em>, int <em>w</em>, int <em>h</em>, </a><a href="qt-6/qtglobal.html#qreal-typedef">qreal</a> <em>xRadius</em>, <a href="qt-6/qtglobal.html#qreal-typedef">qreal</a> <em>yRadius</em>, <a href="qt-6/qt.html#SizeMode-enum">Qt::SizeMode</a> <em>mode</em> = Qt::AbsoluteSize)</li>
<li><a href="#void-qpainter-drawroundedrect-const-qrect-qt-6-qrect-html-rect-qreal-qt-6-qtglobal-html-qreal-typedef-xradius-qreal-qt-6-qtglobal-html-qreal-typedef-yradius-qt-sizemode-qt-6-qt-html-sizemode-enum-mode-qt-absolutesize">void QPainter::drawRoundedRect(const </a><a href="qt-6/qrect.html">QRect</a> &amp;<em>rect</em>, <a href="qt-6/qtglobal.html#qreal-typedef">qreal</a> <em>xRadius</em>, <a href="qt-6/qtglobal.html#qreal-typedef">qreal</a> <em>yRadius</em>, <a href="qt-6/qt.html#SizeMode-enum">Qt::SizeMode</a> <em>mode</em> = Qt::AbsoluteSize)</li>
<li><a href="#void-qpainter-drawstatictext-const-qpointf-qt-6-qpointf-html-topleftposition-const-qstatictext-qt-6-qstatictext-html-statictext">void QPainter::drawStaticText(const </a><a href="qt-6/qpointf.html">QPointF</a> &amp;<em>topLeftPosition</em>, const <a href="qt-6/qstatictext.html">QStaticText</a> &amp;<em>staticText</em>)</li>
<li><a href="#void-qpainter-drawstatictext-const-qpoint-qt-6-qpoint-html-topleftposition-const-qstatictext-qt-6-qstatictext-html-statictext">void QPainter::drawStaticText(const </a><a href="qt-6/qpoint.html">QPoint</a> &amp;<em>topLeftPosition</em>, const <a href="qt-6/qstatictext.html">QStaticText</a> &amp;<em>staticText</em>)</li>
<li><a href="#void-qpainter-drawstatictext-int-left-int-top-const-qstatictext-qt-6-qstatictext-html-statictext">void QPainter::drawStaticText(int <em>left</em>, int <em>top</em>, const </a><a href="qt-6/qstatictext.html">QStaticText</a> &amp;<em>staticText</em>)</li>
<li><a href="#void-qpainter-drawtext-const-qrectf-qt-6-qrectf-html-rectangle-int-flags-const-qstring-qt-6-qstring-html-text-qrectf-qt-6-qrectf-html-boundingrect-nullptr">void QPainter::drawText(const </a><a href="qt-6/qrectf.html">QRectF</a> &amp;<em>rectangle</em>, int <em>flags</em>, const <a href="qt-6/qstring.html">QString</a> &amp;<em>text</em>, <a href="qt-6/qrectf.html">QRectF</a> *<em>boundingRect</em> = nullptr)</li>
<li><a href="#void-qpainter-drawtext-const-qpointf-qt-6-qpointf-html-position-const-qstring-qt-6-qstring-html-text">void QPainter::drawText(const </a><a href="qt-6/qpointf.html">QPointF</a> &amp;<em>position</em>, const <a href="qt-6/qstring.html">QString</a> &amp;<em>text</em>)</li>
<li><a href="#void-qpainter-drawtext-const-qpoint-qt-6-qpoint-html-position-const-qstring-qt-6-qstring-html-text">void QPainter::drawText(const </a><a href="qt-6/qpoint.html">QPoint</a> &amp;<em>position</em>, const <a href="qt-6/qstring.html">QString</a> &amp;<em>text</em>)</li>
<li><a href="#void-qpainter-drawtext-int-x-int-y-const-qstring-qt-6-qstring-html-text">void QPainter::drawText(int <em>x</em>, int <em>y</em>, const </a><a href="qt-6/qstring.html">QString</a> &amp;<em>text</em>)</li>
<li><a href="#void-qpainter-drawtext-const-qrect-qt-6-qrect-html-rectangle-int-flags-const-qstring-qt-6-qstring-html-text-qrect-qt-6-qrect-html-boundingrect-nullptr">void QPainter::drawText(const </a><a href="qt-6/qrect.html">QRect</a> &amp;<em>rectangle</em>, int <em>flags</em>, const <a href="qt-6/qstring.html">QString</a> &amp;<em>text</em>, <a href="qt-6/qrect.html">QRect</a> *<em>boundingRect</em> = nullptr)</li>
<li><a href="#void-qpainter-drawtext-int-x-int-y-int-width-int-height-int-flags-const-qstring-qt-6-qstring-html-text-qrect-qt-6-qrect-html-boundingrect-nullptr">void QPainter::drawText(int <em>x</em>, int <em>y</em>, int <em>width</em>, int <em>height</em>, int <em>flags</em>, const </a><a href="qt-6/qstring.html">QString</a> &amp;<em>text</em>, <a href="qt-6/qrect.html">QRect</a> *<em>boundingRect</em> = nullptr)</li>
<li><a href="#void-qpainter-drawtext-const-qrectf-qt-6-qrectf-html-rectangle-const-qstring-qt-6-qstring-html-text-const-qtextoption-qt-6-qtextoption-html-option-qtextoption">void QPainter::drawText(const </a><a href="qt-6/qrectf.html">QRectF</a> &amp;<em>rectangle</em>, const <a href="qt-6/qstring.html">QString</a> &amp;<em>text</em>, const <a href="qt-6/qtextoption.html">QTextOption</a> &amp;<em>option</em> = QTextOption())</li>
<li><a href="#void-qpainter-drawtiledpixmap-const-qrectf-qt-6-qrectf-html-rectangle-const-qpixmap-qt-6-qpixmap-html-pixmap-const-qpointf-qt-6-qpointf-html-position-qpointf">void QPainter::drawTiledPixmap(const </a><a href="qt-6/qrectf.html">QRectF</a> &amp;<em>rectangle</em>, const <a href="qt-6/qpixmap.html">QPixmap</a> &amp;<em>pixmap</em>, const <a href="qt-6/qpointf.html">QPointF</a> &amp;<em>position</em> = QPointF())</li>
<li><a href="#void-qpainter-drawtiledpixmap-int-x-int-y-int-width-int-height-const-qpixmap-qt-6-qpixmap-html-pixmap-int-sx-0-int-sy-0">void QPainter::drawTiledPixmap(int <em>x</em>, int <em>y</em>, int <em>width</em>, int <em>height</em>, const </a><a href="qt-6/qpixmap.html">QPixmap</a> &amp;<em>pixmap</em>, int <em>sx</em> = 0, int <em>sy</em> = 0)</li>
<li><a href="#void-qpainter-drawtiledpixmap-const-qrect-qt-6-qrect-html-rectangle-const-qpixmap-qt-6-qpixmap-html-pixmap-const-qpoint-qt-6-qpoint-html-position-qpoint">void QPainter::drawTiledPixmap(const </a><a href="qt-6/qrect.html">QRect</a> &amp;<em>rectangle</em>, const <a href="qt-6/qpixmap.html">QPixmap</a> &amp;<em>pixmap</em>, const <a href="qt-6/qpoint.html">QPoint</a> &amp;<em>position</em> = QPoint())</li>
<li><a href="#bool-qpainter-end">bool QPainter::end()</a></li>
<li><a href="#void-qpainter-endnativepainting">void QPainter::endNativePainting()</a></li>
<li><a href="#void-qpainter-eraserect-const-qrectf-qt-6-qrectf-html-rectangle">void QPainter::eraseRect(const </a><a href="qt-6/qrectf.html">QRectF</a> &amp;<em>rectangle</em>)</li>
<li><a href="#void-qpainter-eraserect-int-x-int-y-int-width-int-height">void QPainter::eraseRect(int <em>x</em>, int <em>y</em>, int <em>width</em>, int <em>height</em>)</a></li>
<li><a href="#void-qpainter-eraserect-const-qrect-qt-6-qrect-html-rectangle">void QPainter::eraseRect(const </a><a href="qt-6/qrect.html">QRect</a> &amp;<em>rectangle</em>)</li>
<li><a href="#void-qpainter-fillpath-const-qpainterpath-qt-6-qpainterpath-html-path-const-qbrush-qt-6-qbrush-html-brush">void QPainter::fillPath(const </a><a href="qt-6/qpainterpath.html">QPainterPath</a> &amp;<em>path</em>, const <a href="qt-6/qbrush.html">QBrush</a> &amp;<em>brush</em>)</li>
<li><a href="#void-qpainter-fillrect-const-qrectf-qt-6-qrectf-html-rectangle-const-qbrush-qt-6-qbrush-html-brush">void QPainter::fillRect(const </a><a href="qt-6/qrectf.html">QRectF</a> &amp;<em>rectangle</em>, const <a href="qt-6/qbrush.html">QBrush</a> &amp;<em>brush</em>)</li>
<li><a href="#void-qpainter-fillrect-int-x-int-y-int-width-int-height-const-qbrush-qt-6-qbrush-html-brush">void QPainter::fillRect(int <em>x</em>, int <em>y</em>, int <em>width</em>, int <em>height</em>, const </a><a href="qt-6/qbrush.html">QBrush</a> &amp;<em>brush</em>)</li>
<li><a href="#void-qpainter-fillrect-const-qrect-qt-6-qrect-html-rectangle-const-qbrush-qt-6-qbrush-html-brush">void QPainter::fillRect(const </a><a href="qt-6/qrect.html">QRect</a> &amp;<em>rectangle</em>, const <a href="qt-6/qbrush.html">QBrush</a> &amp;<em>brush</em>)</li>
<li><a href="#void-qpainter-fillrect-const-qrectf-qt-6-qrectf-html-rectangle-const-qcolor-qt-6-qcolor-html-color">void QPainter::fillRect(const </a><a href="qt-6/qrectf.html">QRectF</a> &amp;<em>rectangle</em>, const <a href="qt-6/qcolor.html">QColor</a> &amp;<em>color</em>)</li>
<li><a href="#void-qpainter-fillrect-int-x-int-y-int-width-int-height-const-qcolor-qt-6-qcolor-html-color">void QPainter::fillRect(int <em>x</em>, int <em>y</em>, int <em>width</em>, int <em>height</em>, const </a><a href="qt-6/qcolor.html">QColor</a> &amp;<em>color</em>)</li>
<li><a href="#void-qpainter-fillrect-const-qrect-qt-6-qrect-html-rectangle-const-qcolor-qt-6-qcolor-html-color">void QPainter::fillRect(const </a><a href="qt-6/qrect.html">QRect</a> &amp;<em>rectangle</em>, const <a href="qt-6/qcolor.html">QColor</a> &amp;<em>color</em>)</li>
<li><a href="#void-qpainter-fillrect-int-x-int-y-int-width-int-height-qt-globalcolor-qt-6-qt-html-globalcolor-enum-color">void QPainter::fillRect(int <em>x</em>, int <em>y</em>, int <em>width</em>, int <em>height</em>, </a><a href="qt-6/qt.html#GlobalColor-enum">Qt::GlobalColor</a> <em>color</em>)</li>
<li><a href="#void-qpainter-fillrect-const-qrect-qt-6-qrect-html-rectangle-qt-globalcolor-qt-6-qt-html-globalcolor-enum-color">void QPainter::fillRect(const </a><a href="qt-6/qrect.html">QRect</a> &amp;<em>rectangle</em>, <a href="qt-6/qt.html#GlobalColor-enum">Qt::GlobalColor</a> <em>color</em>)</li>
<li><a href="#void-qpainter-fillrect-const-qrectf-qt-6-qrectf-html-rectangle-qt-globalcolor-qt-6-qt-html-globalcolor-enum-color">void QPainter::fillRect(const </a><a href="qt-6/qrectf.html">QRectF</a> &amp;<em>rectangle</em>, <a href="qt-6/qt.html#GlobalColor-enum">Qt::GlobalColor</a> <em>color</em>)</li>
<li><a href="#void-qpainter-fillrect-int-x-int-y-int-width-int-height-qt-brushstyle-qt-6-qt-html-brushstyle-enum-style">void QPainter::fillRect(int <em>x</em>, int <em>y</em>, int <em>width</em>, int <em>height</em>, </a><a href="qt-6/qt.html#BrushStyle-enum">Qt::BrushStyle</a> <em>style</em>)</li>
<li><a href="#void-qpainter-fillrect-const-qrect-qt-6-qrect-html-rectangle-qt-brushstyle-qt-6-qt-html-brushstyle-enum-style">void QPainter::fillRect(const </a><a href="qt-6/qrect.html">QRect</a> &amp;<em>rectangle</em>, <a href="qt-6/qt.html#BrushStyle-enum">Qt::BrushStyle</a> <em>style</em>)</li>
<li><a href="#void-qpainter-fillrect-const-qrectf-qt-6-qrectf-html-rectangle-qt-brushstyle-qt-6-qt-html-brushstyle-enum-style">void QPainter::fillRect(const </a><a href="qt-6/qrectf.html">QRectF</a> &amp;<em>rectangle</em>, <a href="qt-6/qt.html#BrushStyle-enum">Qt::BrushStyle</a> <em>style</em>)</li>
<li><a href="#since-5-12-void-qpainter-fillrect-int-x-int-y-int-width-int-height-qgradient-preset-qt-6-qgradient-html-preset-enum-preset"><code>[since 5.12]</code>void QPainter::fillRect(int <em>x</em>, int <em>y</em>, int <em>width</em>, int <em>height</em>, </a><a href="qt-6/qgradient.html#Preset-enum">QGradient::Preset</a> <em>preset</em>)</li>
<li><a href="#since-5-12-void-qpainter-fillrect-const-qrect-qt-6-qrect-html-rectangle-qgradient-preset-qt-6-qgradient-html-preset-enum-preset"><code>[since 5.12]</code>void QPainter::fillRect(const </a><a href="qt-6/qrect.html">QRect</a> &amp;<em>rectangle</em>, <a href="qt-6/qgradient.html#Preset-enum">QGradient::Preset</a> <em>preset</em>)</li>
<li><a href="#since-5-12-void-qpainter-fillrect-const-qrectf-qt-6-qrectf-html-rectangle-qgradient-preset-qt-6-qgradient-html-preset-enum-preset"><code>[since 5.12]</code>void QPainter::fillRect(const </a><a href="qt-6/qrectf.html">QRectF</a> &amp;<em>rectangle</em>, <a href="qt-6/qgradient.html#Preset-enum">QGradient::Preset</a> <em>preset</em>)</li>
<li><a href="#const-qfont-qt-6-qfont-html-qpainter-font-const">const </a><a href="qt-6/qfont.html">QFont</a> &amp;QPainter::font() const</li>
<li><a href="#qfontinfo-qt-6-qfontinfo-html-qpainter-fontinfo-const">QFontInfo</a></li>
<li><a href="#qfontmetrics-qt-6-qfontmetrics-html-qpainter-fontmetrics-const">QFontMetrics</a></li>
<li><a href="#bool-qpainter-hasclipping-const">bool QPainter::hasClipping() const</a></li>
<li><a href="#bool-qpainter-isactive-const">bool QPainter::isActive() const</a></li>
<li><a href="#qt-layoutdirection-qt-6-qt-html-layoutdirection-enum-qpainter-layoutdirection-const">Qt::LayoutDirection</a></li>
<li><a href="#qreal-qt-6-qtglobal-html-qreal-typedef-qpainter-opacity-const">qreal</a></li>
<li><a href="#qpaintengine-qt-6-qpaintengine-html-qpainter-paintengine-const">QPaintEngine</a></li>
<li><a href="#const-qpen-qt-6-qpen-html-qpainter-pen-const">const </a><a href="qt-6/qpen.html">QPen</a> &amp;QPainter::pen() const</li>
<li><a href="#qpainter-renderhints-renderhint-enum-qpainter-renderhints-const">QPainter::RenderHints</a></li>
<li><a href="#void-qpainter-resettransform">void QPainter::resetTransform()</a></li>
<li><a href="#void-qpainter-restore">void QPainter::restore()</a></li>
<li><a href="#void-qpainter-rotate-qreal-qt-6-qtglobal-html-qreal-typedef-angle">void QPainter::rotate(</a><a href="qt-6/qtglobal.html#qreal-typedef">qreal</a> <em>angle</em>)</li>
<li><a href="#void-qpainter-save">void QPainter::save()</a></li>
<li><a href="#void-qpainter-scale-qreal-qt-6-qtglobal-html-qreal-typedef-sx-qreal-qt-6-qtglobal-html-qreal-typedef-sy">void QPainter::scale(</a><a href="qt-6/qtglobal.html#qreal-typedef">qreal</a> <em>sx</em>, <a href="qt-6/qtglobal.html#qreal-typedef">qreal</a> <em>sy</em>)</li>
<li><a href="#void-qpainter-setbackground-const-qbrush-qt-6-qbrush-html-brush">void QPainter::setBackground(const </a><a href="qt-6/qbrush.html">QBrush</a> &amp;<em>brush</em>)</li>
<li><a href="#void-qpainter-setbackgroundmode-qt-bgmode-qt-6-qt-html-bgmode-enum-mode">void QPainter::setBackgroundMode(</a><a href="qt-6/qt.html#BGMode-enum">Qt::BGMode</a> <em>mode</em>)</li>
<li><a href="#void-qpainter-setbrush-const-qbrush-qt-6-qbrush-html-brush">void QPainter::setBrush(const </a><a href="qt-6/qbrush.html">QBrush</a> &amp;<em>brush</em>)</li>
<li><a href="#void-qpainter-setbrush-qt-brushstyle-qt-6-qt-html-brushstyle-enum-style">void QPainter::setBrush(</a><a href="qt-6/qt.html#BrushStyle-enum">Qt::BrushStyle</a> <em>style</em>)</li>
<li><a href="#void-qpainter-setbrushorigin-const-qpointf-qt-6-qpointf-html-position">void QPainter::setBrushOrigin(const </a><a href="qt-6/qpointf.html">QPointF</a> &amp;<em>position</em>)</li>
<li><a href="#void-qpainter-setbrushorigin-int-x-int-y">void QPainter::setBrushOrigin(int <em>x</em>, int <em>y</em>)</a></li>
<li><a href="#void-qpainter-setbrushorigin-const-qpoint-qt-6-qpoint-html-position">void QPainter::setBrushOrigin(const </a><a href="qt-6/qpoint.html">QPoint</a> &amp;<em>position</em>)</li>
<li><a href="#void-qpainter-setclippath-const-qpainterpath-qt-6-qpainterpath-html-path-qt-clipoperation-qt-6-qt-html-clipoperation-enum-operation-qt-replaceclip">void QPainter::setClipPath(const </a><a href="qt-6/qpainterpath.html">QPainterPath</a> &amp;<em>path</em>, <a href="qt-6/qt.html#ClipOperation-enum">Qt::ClipOperation</a> <em>operation</em> = Qt::ReplaceClip)</li>
<li><a href="#void-qpainter-setcliprect-const-qrectf-qt-6-qrectf-html-rectangle-qt-clipoperation-qt-6-qt-html-clipoperation-enum-operation-qt-replaceclip">void QPainter::setClipRect(const </a><a href="qt-6/qrectf.html">QRectF</a> &amp;<em>rectangle</em>, <a href="qt-6/qt.html#ClipOperation-enum">Qt::ClipOperation</a> <em>operation</em> = Qt::ReplaceClip)</li>
<li><a href="#void-qpainter-setcliprect-const-qrect-qt-6-qrect-html-rectangle-qt-clipoperation-qt-6-qt-html-clipoperation-enum-operation-qt-replaceclip">void QPainter::setClipRect(const </a><a href="qt-6/qrect.html">QRect</a> &amp;<em>rectangle</em>, <a href="qt-6/qt.html#ClipOperation-enum">Qt::ClipOperation</a> <em>operation</em> = Qt::ReplaceClip)</li>
<li><a href="#void-qpainter-setcliprect-int-x-int-y-int-width-int-height-qt-clipoperation-qt-6-qt-html-clipoperation-enum-operation-qt-replaceclip">void QPainter::setClipRect(int <em>x</em>, int <em>y</em>, int <em>width</em>, int <em>height</em>, </a><a href="qt-6/qt.html#ClipOperation-enum">Qt::ClipOperation</a> <em>operation</em> = Qt::ReplaceClip)</li>
<li><a href="#void-qpainter-setclipregion-const-qregion-qt-6-qregion-html-region-qt-clipoperation-qt-6-qt-html-clipoperation-enum-operation-qt-replaceclip">void QPainter::setClipRegion(const </a><a href="qt-6/qregion.html">QRegion</a> &amp;<em>region</em>, <a href="qt-6/qt.html#ClipOperation-enum">Qt::ClipOperation</a> <em>operation</em> = Qt::ReplaceClip)</li>
<li><a href="#void-qpainter-setclipping-bool-enable">void QPainter::setClipping(bool <em>enable</em>)</a></li>
<li><a href="#void-qpainter-setcompositionmode-qpainter-compositionmode-compositionmode-enum-mode">void QPainter::setCompositionMode(</a><a href="#CompositionMode-enum">QPainter::CompositionMode</a> <em>mode</em>)</li>
<li><a href="#void-qpainter-setfont-const-qfont-qt-6-qfont-html-font">void QPainter::setFont(const </a><a href="qt-6/qfont.html">QFont</a> &amp;<em>font</em>)</li>
<li><a href="#void-qpainter-setlayoutdirection-qt-layoutdirection-qt-6-qt-html-layoutdirection-enum-direction">void QPainter::setLayoutDirection(</a><a href="qt-6/qt.html#LayoutDirection-enum">Qt::LayoutDirection</a> <em>direction</em>)</li>
<li><a href="#void-qpainter-setopacity-qreal-qt-6-qtglobal-html-qreal-typedef-opacity">void QPainter::setOpacity(</a><a href="qt-6/qtglobal.html#qreal-typedef">qreal</a> <em>opacity</em>)</li>
<li><a href="#void-qpainter-setpen-const-qpen-qt-6-qpen-html-pen">void QPainter::setPen(const </a><a href="qt-6/qpen.html">QPen</a> &amp;<em>pen</em>)</li>
<li><a href="#void-qpainter-setpen-const-qcolor-qt-6-qcolor-html-color">void QPainter::setPen(const </a><a href="qt-6/qcolor.html">QColor</a> &amp;<em>color</em>)</li>
<li><a href="#void-qpainter-setpen-qt-penstyle-qt-6-qt-html-penstyle-enum-style">void QPainter::setPen(</a><a href="qt-6/qt.html#PenStyle-enum">Qt::PenStyle</a> <em>style</em>)</li>
<li><a href="#void-qpainter-setrenderhint-qpainter-renderhint-renderhint-enum-hint-bool-on-true">void QPainter::setRenderHint(</a><a href="#RenderHint-enum">QPainter::RenderHint</a> <em>hint</em>, bool <em>on</em> = true)</li>
<li><a href="#void-qpainter-setrenderhints-qpainter-renderhints-renderhint-enum-hints-bool-on-true">void QPainter::setRenderHints(</a><a href="#RenderHint-enum">QPainter::RenderHints</a> <em>hints</em>, bool <em>on</em> = true)</li>
<li><a href="#void-qpainter-settransform-const-qtransform-qt-6-qtransform-html-transform-bool-combine-false">void QPainter::setTransform(const </a><a href="qt-6/qtransform.html">QTransform</a> &amp;<em>transform</em>, bool <em>combine</em> = false)</li>
<li><a href="#void-qpainter-setviewtransformenabled-bool-enable">void QPainter::setViewTransformEnabled(bool <em>enable</em>)</a></li>
<li><a href="#void-qpainter-setviewport-const-qrect-qt-6-qrect-html-rectangle">void QPainter::setViewport(const </a><a href="qt-6/qrect.html">QRect</a> &amp;<em>rectangle</em>)</li>
<li><a href="#void-qpainter-setviewport-int-x-int-y-int-width-int-height">void QPainter::setViewport(int <em>x</em>, int <em>y</em>, int <em>width</em>, int <em>height</em>)</a></li>
<li><a href="#void-qpainter-setwindow-const-qrect-qt-6-qrect-html-rectangle">void QPainter::setWindow(const </a><a href="qt-6/qrect.html">QRect</a> &amp;<em>rectangle</em>)</li>
<li><a href="#void-qpainter-setwindow-int-x-int-y-int-width-int-height">void QPainter::setWindow(int <em>x</em>, int <em>y</em>, int <em>width</em>, int <em>height</em>)</a></li>
<li><a href="#void-qpainter-setworldmatrixenabled-bool-enable">void QPainter::setWorldMatrixEnabled(bool <em>enable</em>)</a></li>
<li><a href="#void-qpainter-setworldtransform-const-qtransform-qt-6-qtransform-html-matrix-bool-combine-false">void QPainter::setWorldTransform(const </a><a href="qt-6/qtransform.html">QTransform</a> &amp;<em>matrix</em>, bool <em>combine</em> = false)</li>
<li><a href="#void-qpainter-shear-qreal-qt-6-qtglobal-html-qreal-typedef-sh-qreal-qt-6-qtglobal-html-qreal-typedef-sv">void QPainter::shear(</a><a href="qt-6/qtglobal.html#qreal-typedef">qreal</a> <em>sh</em>, <a href="qt-6/qtglobal.html#qreal-typedef">qreal</a> <em>sv</em>)</li>
<li><a href="#void-qpainter-strokepath-const-qpainterpath-qt-6-qpainterpath-html-path-const-qpen-qt-6-qpen-html-pen">void QPainter::strokePath(const </a><a href="qt-6/qpainterpath.html">QPainterPath</a> &amp;<em>path</em>, const <a href="qt-6/qpen.html">QPen</a> &amp;<em>pen</em>)</li>
<li><a href="#bool-qpainter-testrenderhint-qpainter-renderhint-renderhint-enum-hint-const">bool QPainter::testRenderHint(</a><a href="#RenderHint-enum">QPainter::RenderHint</a> <em>hint</em>) const</li>
<li><a href="#const-qtransform-qt-6-qtransform-html-qpainter-transform-const">const </a><a href="qt-6/qtransform.html">QTransform</a> &amp;QPainter::transform() const</li>
<li><a href="#void-qpainter-translate-const-qpointf-qt-6-qpointf-html-offset">void QPainter::translate(const </a><a href="qt-6/qpointf.html">QPointF</a> &amp;<em>offset</em>)</li>
<li><a href="#void-qpainter-translate-const-qpoint-qt-6-qpoint-html-offset">void QPainter::translate(const </a><a href="qt-6/qpoint.html">QPoint</a> &amp;<em>offset</em>)</li>
<li><a href="#void-qpainter-translate-qreal-qt-6-qtglobal-html-qreal-typedef-dx-qreal-qt-6-qtglobal-html-qreal-typedef-dy">void QPainter::translate(</a><a href="qt-6/qtglobal.html#qreal-typedef">qreal</a> <em>dx</em>, <a href="qt-6/qtglobal.html#qreal-typedef">qreal</a> <em>dy</em>)</li>
<li><a href="#bool-qpainter-viewtransformenabled-const">bool QPainter::viewTransformEnabled() const</a></li>
<li><a href="#qrect-qt-6-qrect-html-qpainter-viewport-const-2">QRect</a></li>
<li><a href="#qrect-qt-6-qrect-html-qpainter-window-const-3">QRect</a></li>
<li><a href="#bool-qpainter-worldmatrixenabled-const">bool QPainter::worldMatrixEnabled() const</a></li>
<li><a href="#const-qtransform-qt-6-qtransform-html-qpainter-worldtransform-const">const </a><a href="qt-6/qtransform.html">QTransform</a> &amp;QPainter::worldTransform() const</li>
</ul>
</li>
</ul>
</li>
</ul>
<!-- tocstop -->

</div>
# QPainter Class

<p>QPainter类在widget和其他绘画设备上执行低级别的绘画。 <a href="#%E8%AF%A6%E7%BB%86%E6%8F%8F%E8%BF%B0">More…</a></p>
<table>
<thead>
<tr>
<th>Header:</th>
<th>#include <qpainter></qpainter></th>
</tr>
</thead>
<tbody><tr>
<td>CMake:</td>
<td>find_package(Qt6 COMPONENTS Gui REQUIRED) target_link_libraries(mytarget PRIVATE Qt6::Gui)</td>
</tr>
<tr>
<td>qmake:</td>
<td>QT += gui</td>
</tr>
<tr>
<td>Inherited By:</td>
<td><a href="qt-6/qstylepainter.html">QStylePainter</a></td>
</tr>
</tbody></table>
<ul>
<li><a href="qt-6/qpainter-members.html">List of all members, including inherited members</a></li>
</ul>
<p><strong>注意：</strong>这个类中的所有函数都是<a href="qt-6/threads-reentrancy.html">可重入的</a>。</p>
<h2><span id="gong-gong-lei-xing">公共类型</span><a href="#gong-gong-lei-xing" class="header-anchor">#</a></h2><table>
<thead>
<tr>
<th>class</th>
<th><strong><a href="qt-6/qpainter-pixmapfragment.html">PixmapFragment</a></strong></th>
</tr>
</thead>
<tbody><tr>
<td>enum</td>
<td><strong><a href="#CompositionMode-enum">CompositionMode</a></strong> { CompositionMode_SourceOver, CompositionMode_DestinationOver, CompositionMode_Clear, CompositionMode_Source, CompositionMode_Destination, …, RasterOp_SourceOrNotDestination }</td>
</tr>
<tr>
<td>enum</td>
<td><strong><a href="#PixmapFragmentHint-enum">PixmapFragmentHint</a></strong> { OpaqueHint }</td>
</tr>
<tr>
<td>flags</td>
<td><strong><a href="#PixmapFragmentHint-enum">PixmapFragmentHints</a></strong></td>
</tr>
<tr>
<td>enum</td>
<td><strong><a href="#RenderHint-enum">RenderHint</a></strong> { Antialiasing, TextAntialiasing, SmoothPixmapTransform, VerticalSubpixelPositioning, LosslessImageRendering }</td>
</tr>
<tr>
<td>flags</td>
<td><strong><a href="#RenderHint-enum">RenderHints</a></strong></td>
</tr>
</tbody></table>
<h2><span id="gong-gong-han-shu">公共函数</span><a href="#gong-gong-han-shu" class="header-anchor">#</a></h2><table>
<thead>
<tr>
<th></th>
<th><strong><a href="#QPainter-1">QPainter</a></strong>(QPaintDevice *<em>device</em>)</th>
</tr>
</thead>
<tbody><tr>
<td></td>
<td><strong><a href="#QPainter">QPainter</a></strong>()</td>
</tr>
<tr>
<td></td>
<td><strong><a href="#dtor.QPainter">~QPainter</a></strong>()</td>
</tr>
<tr>
<td>const QBrush &amp;</td>
<td><strong><a href="#background">background</a></strong>() const</td>
</tr>
<tr>
<td>Qt::BGMode</td>
<td><strong><a href="#backgroundMode">backgroundMode</a></strong>() const</td>
</tr>
<tr>
<td>bool</td>
<td><strong><a href="#begin">begin</a></strong>(QPaintDevice *<em>device</em>)</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="#beginNativePainting">beginNativePainting</a></strong>()</td>
</tr>
<tr>
<td>QRectF</td>
<td><strong><a href="#boundingRect">boundingRect</a></strong>(const QRectF &amp;<em>rectangle</em>, int <em>flags</em>, const QString &amp;<em>text</em>)</td>
</tr>
<tr>
<td>QRect</td>
<td><strong><a href="#boundingRect-1">boundingRect</a></strong>(const QRect &amp;<em>rectangle</em>, int <em>flags</em>, const QString &amp;<em>text</em>)</td>
</tr>
<tr>
<td>QRect</td>
<td><strong><a href="#boundingRect-2">boundingRect</a></strong>(int <em>x</em>, int <em>y</em>, int <em>w</em>, int <em>h</em>, int <em>flags</em>, const QString &amp;<em>text</em>)</td>
</tr>
<tr>
<td>QRectF</td>
<td><strong><a href="#boundingRect-3">boundingRect</a></strong>(const QRectF &amp;<em>rectangle</em>, const QString &amp;<em>text</em>, const QTextOption &amp;<em>option</em> = QTextOption())</td>
</tr>
<tr>
<td>const QBrush &amp;</td>
<td><strong><a href="#brush">brush</a></strong>() const</td>
</tr>
<tr>
<td>QPoint</td>
<td><strong><a href="#brushOrigin">brushOrigin</a></strong>() const</td>
</tr>
<tr>
<td>QRectF</td>
<td><strong><a href="#clipBoundingRect">clipBoundingRect</a></strong>() const</td>
</tr>
<tr>
<td>QPainterPath</td>
<td><strong><a href="#clipPath">clipPath</a></strong>() const</td>
</tr>
<tr>
<td>QRegion</td>
<td><strong><a href="#clipRegion">clipRegion</a></strong>() const</td>
</tr>
<tr>
<td>QTransform</td>
<td><strong><a href="#combinedTransform">combinedTransform</a></strong>() const</td>
</tr>
<tr>
<td>QPainter::CompositionMode</td>
<td><strong><a href="#compositionMode">compositionMode</a></strong>() const</td>
</tr>
<tr>
<td>QPaintDevice *</td>
<td><strong><a href="#device">device</a></strong>() const</td>
</tr>
<tr>
<td>const QTransform &amp;</td>
<td><strong><a href="#deviceTransform">deviceTransform</a></strong>() const</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="#drawArc">drawArc</a></strong>(const QRectF &amp;<em>rectangle</em>, int <em>startAngle</em>, int <em>spanAngle</em>)</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="#drawArc-1">drawArc</a></strong>(const QRect &amp;<em>rectangle</em>, int <em>startAngle</em>, int <em>spanAngle</em>)</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="#drawArc-2">drawArc</a></strong>(int <em>x</em>, int <em>y</em>, int <em>width</em>, int <em>height</em>, int <em>startAngle</em>, int <em>spanAngle</em>)</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="#drawChord">drawChord</a></strong>(const QRectF &amp;<em>rectangle</em>, int <em>startAngle</em>, int <em>spanAngle</em>)</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="#drawChord-1">drawChord</a></strong>(int <em>x</em>, int <em>y</em>, int <em>width</em>, int <em>height</em>, int <em>startAngle</em>, int <em>spanAngle</em>)</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="#drawChord-2">drawChord</a></strong>(const QRect &amp;<em>rectangle</em>, int <em>startAngle</em>, int <em>spanAngle</em>)</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="#drawConvexPolygon">drawConvexPolygon</a></strong>(const QPointF *<em>points</em>, int <em>pointCount</em>)</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="#drawConvexPolygon-1">drawConvexPolygon</a></strong>(const QPolygonF &amp;<em>polygon</em>)</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="#drawConvexPolygon-2">drawConvexPolygon</a></strong>(const QPoint *<em>points</em>, int <em>pointCount</em>)</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="#drawConvexPolygon-3">drawConvexPolygon</a></strong>(const QPolygon &amp;<em>polygon</em>)</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="#drawEllipse">drawEllipse</a></strong>(const QRectF &amp;<em>rectangle</em>)</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="#drawEllipse-1">drawEllipse</a></strong>(const QRect &amp;<em>rectangle</em>)</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="#drawEllipse-2">drawEllipse</a></strong>(int <em>x</em>, int <em>y</em>, int <em>width</em>, int <em>height</em>)</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="#drawEllipse-3">drawEllipse</a></strong>(const QPointF &amp;<em>center</em>, qreal <em>rx</em>, qreal <em>ry</em>)</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="#drawEllipse-4">drawEllipse</a></strong>(const QPoint &amp;<em>center</em>, int <em>rx</em>, int <em>ry</em>)</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="#drawGlyphRun">drawGlyphRun</a></strong>(const QPointF &amp;<em>position</em>, const QGlyphRun &amp;<em>glyphs</em>)</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="#drawImage">drawImage</a></strong>(const QRectF &amp;<em>target</em>, const QImage &amp;<em>image</em>, const QRectF &amp;<em>source</em>, Qt::ImageConversionFlags <em>flags</em> = Qt::AutoColor)</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="#drawImage-1">drawImage</a></strong>(const QRect &amp;<em>target</em>, const QImage &amp;<em>image</em>, const QRect &amp;<em>source</em>, Qt::ImageConversionFlags <em>flags</em> = Qt::AutoColor)</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="#drawImage-2">drawImage</a></strong>(const QPointF &amp;<em>point</em>, const QImage &amp;<em>image</em>, const QRectF &amp;<em>source</em>, Qt::ImageConversionFlags <em>flags</em> = Qt::AutoColor)</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="#drawImage-3">drawImage</a></strong>(const QPoint &amp;<em>point</em>, const QImage &amp;<em>image</em>, const QRect &amp;<em>source</em>, Qt::ImageConversionFlags <em>flags</em> = Qt::AutoColor)</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="#drawImage-4">drawImage</a></strong>(const QRectF &amp;<em>rectangle</em>, const QImage &amp;<em>image</em>)</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="#drawImage-5">drawImage</a></strong>(const QRect &amp;<em>rectangle</em>, const QImage &amp;<em>image</em>)</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="#drawImage-6">drawImage</a></strong>(const QPointF &amp;<em>point</em>, const QImage &amp;<em>image</em>)</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="#drawImage-7">drawImage</a></strong>(const QPoint &amp;<em>point</em>, const QImage &amp;<em>image</em>)</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="#drawImage-8">drawImage</a></strong>(int <em>x</em>, int <em>y</em>, const QImage &amp;<em>image</em>, int <em>sx</em> = 0, int <em>sy</em> = 0, int <em>sw</em> = -1, int <em>sh</em> = -1, Qt::ImageConversionFlags <em>flags</em> = Qt::AutoColor)</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="#drawLine">drawLine</a></strong>(const QLineF &amp;<em>line</em>)</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="#drawLine-1">drawLine</a></strong>(const QLine &amp;<em>line</em>)</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="#drawLine-2">drawLine</a></strong>(int <em>x1</em>, int <em>y1</em>, int <em>x2</em>, int <em>y2</em>)</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="#drawLine-3">drawLine</a></strong>(const QPoint &amp;<em>p1</em>, const QPoint &amp;<em>p2</em>)</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="#drawLine-4">drawLine</a></strong>(const QPointF &amp;<em>p1</em>, const QPointF &amp;<em>p2</em>)</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="#drawLines">drawLines</a></strong>(const QLineF *<em>lines</em>, int <em>lineCount</em>)</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="#drawLines-1">drawLines</a></strong>(const QList<qlinef> &amp;<em>lines</em>)</qlinef></td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="#drawLines-2">drawLines</a></strong>(const QPointF *<em>pointPairs</em>, int <em>lineCount</em>)</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="#drawLines-3">drawLines</a></strong>(const QList<qpointf> &amp;<em>pointPairs</em>)</qpointf></td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="#drawLines-4">drawLines</a></strong>(const QLine *<em>lines</em>, int <em>lineCount</em>)</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="#drawLines-5">drawLines</a></strong>(const QList<qline> &amp;<em>lines</em>)</qline></td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="#drawLines-6">drawLines</a></strong>(const QPoint *<em>pointPairs</em>, int <em>lineCount</em>)</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="#drawLines-7">drawLines</a></strong>(const QList<qpoint> &amp;<em>pointPairs</em>)</qpoint></td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="#drawPath">drawPath</a></strong>(const QPainterPath &amp;<em>path</em>)</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="#drawPicture">drawPicture</a></strong>(const QPointF &amp;<em>point</em>, const QPicture &amp;<em>picture</em>)</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="#drawPicture-1">drawPicture</a></strong>(int <em>x</em>, int <em>y</em>, const QPicture &amp;<em>picture</em>)</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="#drawPicture-2">drawPicture</a></strong>(const QPoint &amp;<em>point</em>, const QPicture &amp;<em>picture</em>)</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="#drawPie">drawPie</a></strong>(const QRectF &amp;<em>rectangle</em>, int <em>startAngle</em>, int <em>spanAngle</em>)</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="#drawPie-1">drawPie</a></strong>(int <em>x</em>, int <em>y</em>, int <em>width</em>, int <em>height</em>, int <em>startAngle</em>, int <em>spanAngle</em>)</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="#drawPie-2">drawPie</a></strong>(const QRect &amp;<em>rectangle</em>, int <em>startAngle</em>, int <em>spanAngle</em>)</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="#drawPixmap">drawPixmap</a></strong>(const QRectF &amp;<em>target</em>, const QPixmap &amp;<em>pixmap</em>, const QRectF &amp;<em>source</em>)</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="#drawPixmap-1">drawPixmap</a></strong>(const QRect &amp;<em>target</em>, const QPixmap &amp;<em>pixmap</em>, const QRect &amp;<em>source</em>)</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="#drawPixmap-2">drawPixmap</a></strong>(int <em>x</em>, int <em>y</em>, int <em>w</em>, int <em>h</em>, const QPixmap &amp;<em>pixmap</em>, int <em>sx</em>, int <em>sy</em>, int <em>sw</em>, int <em>sh</em>)</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="#drawPixmap-3">drawPixmap</a></strong>(int <em>x</em>, int <em>y</em>, const QPixmap &amp;<em>pixmap</em>, int <em>sx</em>, int <em>sy</em>, int <em>sw</em>, int <em>sh</em>)</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="#drawPixmap-4">drawPixmap</a></strong>(const QPointF &amp;<em>point</em>, const QPixmap &amp;<em>pixmap</em>, const QRectF &amp;<em>source</em>)</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="#drawPixmap-5">drawPixmap</a></strong>(const QPoint &amp;<em>point</em>, const QPixmap &amp;<em>pixmap</em>, const QRect &amp;<em>source</em>)</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="#drawPixmap-6">drawPixmap</a></strong>(const QPointF &amp;<em>point</em>, const QPixmap &amp;<em>pixmap</em>)</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="#drawPixmap-7">drawPixmap</a></strong>(const QPoint &amp;<em>point</em>, const QPixmap &amp;<em>pixmap</em>)</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="#drawPixmap-8">drawPixmap</a></strong>(int <em>x</em>, int <em>y</em>, const QPixmap &amp;<em>pixmap</em>)</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="#drawPixmap-9">drawPixmap</a></strong>(const QRect &amp;<em>rectangle</em>, const QPixmap &amp;<em>pixmap</em>)</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="#drawPixmap-10">drawPixmap</a></strong>(int <em>x</em>, int <em>y</em>, int <em>width</em>, int <em>height</em>, const QPixmap &amp;<em>pixmap</em>)</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="#drawPixmapFragments">drawPixmapFragments</a></strong>(const QPainter::PixmapFragment *<em>fragments</em>, int <em>fragmentCount</em>, const QPixmap &amp;<em>pixmap</em>, QPainter::PixmapFragmentHints <em>hints</em> = PixmapFragmentHints())</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="#drawPoint">drawPoint</a></strong>(const QPointF &amp;<em>position</em>)</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="#drawPoint-1">drawPoint</a></strong>(const QPoint &amp;<em>position</em>)</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="#drawPoint-2">drawPoint</a></strong>(int <em>x</em>, int <em>y</em>)</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="#drawPoints">drawPoints</a></strong>(const QPointF *<em>points</em>, int <em>pointCount</em>)</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="#drawPoints-1">drawPoints</a></strong>(const QPolygonF &amp;<em>points</em>)</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="#drawPoints-2">drawPoints</a></strong>(const QPoint *<em>points</em>, int <em>pointCount</em>)</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="#drawPoints-3">drawPoints</a></strong>(const QPolygon &amp;<em>points</em>)</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="#drawPolygon">drawPolygon</a></strong>(const QPointF *<em>points</em>, int <em>pointCount</em>, Qt::FillRule <em>fillRule</em> = Qt::OddEvenFill)</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="#drawPolygon-1">drawPolygon</a></strong>(const QPolygonF &amp;<em>points</em>, Qt::FillRule <em>fillRule</em> = Qt::OddEvenFill)</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="#drawPolygon-2">drawPolygon</a></strong>(const QPoint *<em>points</em>, int <em>pointCount</em>, Qt::FillRule <em>fillRule</em> = Qt::OddEvenFill)</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="#drawPolygon-3">drawPolygon</a></strong>(const QPolygon &amp;<em>points</em>, Qt::FillRule <em>fillRule</em> = Qt::OddEvenFill)</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="#drawPolyline">drawPolyline</a></strong>(const QPointF *<em>points</em>, int <em>pointCount</em>)</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="#drawPolyline-1">drawPolyline</a></strong>(const QPolygonF &amp;<em>points</em>)</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="#drawPolyline-2">drawPolyline</a></strong>(const QPoint *<em>points</em>, int <em>pointCount</em>)</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="#drawPolyline-3">drawPolyline</a></strong>(const QPolygon &amp;<em>points</em>)</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="#drawRect">drawRect</a></strong>(const QRectF &amp;<em>rectangle</em>)</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="#drawRect-1">drawRect</a></strong>(int <em>x</em>, int <em>y</em>, int <em>width</em>, int <em>height</em>)</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="#drawRect-2">drawRect</a></strong>(const QRect &amp;<em>rectangle</em>)</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="#drawRects">drawRects</a></strong>(const QRectF *<em>rectangles</em>, int <em>rectCount</em>)</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="#drawRects-1">drawRects</a></strong>(const QList<qrectf> &amp;<em>rectangles</em>)</qrectf></td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="#drawRects-2">drawRects</a></strong>(const QRect *<em>rectangles</em>, int <em>rectCount</em>)</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="#drawRects-3">drawRects</a></strong>(const QList<qrect> &amp;<em>rectangles</em>)</qrect></td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="#drawRoundedRect">drawRoundedRect</a></strong>(const QRectF &amp;<em>rect</em>, qreal <em>xRadius</em>, qreal <em>yRadius</em>, Qt::SizeMode <em>mode</em> = Qt::AbsoluteSize)</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="#drawRoundedRect-1">drawRoundedRect</a></strong>(int <em>x</em>, int <em>y</em>, int <em>w</em>, int <em>h</em>, qreal <em>xRadius</em>, qreal <em>yRadius</em>, Qt::SizeMode <em>mode</em> = Qt::AbsoluteSize)</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="#drawRoundedRect-2">drawRoundedRect</a></strong>(const QRect &amp;<em>rect</em>, qreal <em>xRadius</em>, qreal <em>yRadius</em>, Qt::SizeMode <em>mode</em> = Qt::AbsoluteSize)</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="#drawStaticText">drawStaticText</a></strong>(const QPointF &amp;<em>topLeftPosition</em>, const QStaticText &amp;<em>staticText</em>)</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="#drawStaticText-1">drawStaticText</a></strong>(const QPoint &amp;<em>topLeftPosition</em>, const QStaticText &amp;<em>staticText</em>)</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="#drawStaticText-2">drawStaticText</a></strong>(int <em>left</em>, int <em>top</em>, const QStaticText &amp;<em>staticText</em>)</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="#drawText">drawText</a></strong>(const QRectF &amp;<em>rectangle</em>, int <em>flags</em>, const QString &amp;<em>text</em>, QRectF *<em>boundingRect</em> = nullptr)</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="#drawText">drawText</a></strong>(const QPointF &amp;<em>position</em>, const QString &amp;<em>text</em>)</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="#drawText-1">drawText</a></strong>(const QPoint &amp;<em>position</em>, const QString &amp;<em>text</em>)</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="#drawText-2">drawText</a></strong>(int <em>x</em>, int <em>y</em>, const QString &amp;<em>text</em>)</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="#drawText-3">drawText</a></strong>(const QRect &amp;<em>rectangle</em>, int <em>flags</em>, const QString &amp;<em>text</em>, QRect *<em>boundingRect</em> = nullptr)</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="#drawText-4">drawText</a></strong>(int <em>x</em>, int <em>y</em>, int <em>width</em>, int <em>height</em>, int <em>flags</em>, const QString &amp;<em>text</em>, QRect *<em>boundingRect</em> = nullptr)</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="#drawText-5">drawText</a></strong>(const QRectF &amp;<em>rectangle</em>, const QString &amp;<em>text</em>, const QTextOption &amp;<em>option</em> = QTextOption())</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="#drawTiledPixmap">drawTiledPixmap</a></strong>(const QRectF &amp;<em>rectangle</em>, const QPixmap &amp;<em>pixmap</em>, const QPointF &amp;<em>position</em> = QPointF())</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="#drawTiledPixmap-1">drawTiledPixmap</a></strong>(int <em>x</em>, int <em>y</em>, int <em>width</em>, int <em>height</em>, const QPixmap &amp;<em>pixmap</em>, int <em>sx</em> = 0, int <em>sy</em> = 0)</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="#drawTiledPixmap-2">drawTiledPixmap</a></strong>(const QRect &amp;<em>rectangle</em>, const QPixmap &amp;<em>pixmap</em>, const QPoint &amp;<em>position</em> = QPoint())</td>
</tr>
<tr>
<td>bool</td>
<td><strong><a href="#end">end</a></strong>()</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="#endNativePainting">endNativePainting</a></strong>()</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="#eraseRect">eraseRect</a></strong>(const QRectF &amp;<em>rectangle</em>)</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="#eraseRect-1">eraseRect</a></strong>(int <em>x</em>, int <em>y</em>, int <em>width</em>, int <em>height</em>)</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="#eraseRect-2">eraseRect</a></strong>(const QRect &amp;<em>rectangle</em>)</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="#fillPath">fillPath</a></strong>(const QPainterPath &amp;<em>path</em>, const QBrush &amp;<em>brush</em>)</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="#fillRect">fillRect</a></strong>(const QRectF &amp;<em>rectangle</em>, const QBrush &amp;<em>brush</em>)</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="#fillRect-1">fillRect</a></strong>(int <em>x</em>, int <em>y</em>, int <em>width</em>, int <em>height</em>, const QBrush &amp;<em>brush</em>)</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="#fillRect-2">fillRect</a></strong>(const QRect &amp;<em>rectangle</em>, const QBrush &amp;<em>brush</em>)</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="#fillRect-3">fillRect</a></strong>(const QRectF &amp;<em>rectangle</em>, const QColor &amp;<em>color</em>)</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="#fillRect-4">fillRect</a></strong>(int <em>x</em>, int <em>y</em>, int <em>width</em>, int <em>height</em>, const QColor &amp;<em>color</em>)</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="#fillRect-5">fillRect</a></strong>(const QRect &amp;<em>rectangle</em>, const QColor &amp;<em>color</em>)</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="#fillRect-6">fillRect</a></strong>(int <em>x</em>, int <em>y</em>, int <em>width</em>, int <em>height</em>, Qt::GlobalColor <em>color</em>)</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="#fillRect-7">fillRect</a></strong>(const QRect &amp;<em>rectangle</em>, Qt::GlobalColor <em>color</em>)</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="#fillRect-8">fillRect</a></strong>(const QRectF &amp;<em>rectangle</em>, Qt::GlobalColor <em>color</em>)</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="#fillRect-9">fillRect</a></strong>(int <em>x</em>, int <em>y</em>, int <em>width</em>, int <em>height</em>, Qt::BrushStyle <em>style</em>)</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="#fillRect-10">fillRect</a></strong>(const QRect &amp;<em>rectangle</em>, Qt::BrushStyle <em>style</em>)</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="#fillRect-11">fillRect</a></strong>(const QRectF &amp;<em>rectangle</em>, Qt::BrushStyle <em>style</em>)</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="#fillRect-12">fillRect</a></strong>(int <em>x</em>, int <em>y</em>, int <em>width</em>, int <em>height</em>, QGradient::Preset <em>preset</em>)</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="#fillRect-13">fillRect</a></strong>(const QRect &amp;<em>rectangle</em>, QGradient::Preset <em>preset</em>)</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="#fillRect-14">fillRect</a></strong>(const QRectF &amp;<em>rectangle</em>, QGradient::Preset <em>preset</em>)</td>
</tr>
<tr>
<td>const QFont &amp;</td>
<td><strong><a href="#font">font</a></strong>() const</td>
</tr>
<tr>
<td>QFontInfo</td>
<td><strong><a href="#fontInfo">fontInfo</a></strong>() const</td>
</tr>
<tr>
<td>QFontMetrics</td>
<td><strong><a href="#fontMetrics">fontMetrics</a></strong>() const</td>
</tr>
<tr>
<td>bool</td>
<td><strong><a href="#hasClipping">hasClipping</a></strong>() const</td>
</tr>
<tr>
<td>bool</td>
<td><strong><a href="#isActive">isActive</a></strong>() const</td>
</tr>
<tr>
<td>Qt::LayoutDirection</td>
<td><strong><a href="#layoutDirection">layoutDirection</a></strong>() const</td>
</tr>
<tr>
<td>qreal</td>
<td><strong><a href="#opacity">opacity</a></strong>() const</td>
</tr>
<tr>
<td>QPaintEngine *</td>
<td><strong><a href="#paintEngine">paintEngine</a></strong>() const</td>
</tr>
<tr>
<td>const QPen &amp;</td>
<td><strong><a href="#pen">pen</a></strong>() const</td>
</tr>
<tr>
<td>QPainter::RenderHints</td>
<td><strong><a href="#renderHints">renderHints</a></strong>() const</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="#resetTransform">resetTransform</a></strong>()</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="#restore">restore</a></strong>()</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="#rotate">rotate</a></strong>(qreal <em>angle</em>)</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="#save">save</a></strong>()</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="#scale">scale</a></strong>(qreal <em>sx</em>, qreal <em>sy</em>)</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="#setBackground">setBackground</a></strong>(const QBrush &amp;<em>brush</em>)</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="#setBackgroundMode">setBackgroundMode</a></strong>(Qt::BGMode <em>mode</em>)</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="#setBrush">setBrush</a></strong>(const QBrush &amp;<em>brush</em>)</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="#setBrush-1">setBrush</a></strong>(Qt::BrushStyle <em>style</em>)</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="#setBrushOrigin">setBrushOrigin</a></strong>(const QPointF &amp;<em>position</em>)</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="#setBrushOrigin-1">setBrushOrigin</a></strong>(int <em>x</em>, int <em>y</em>)</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="#setBrushOrigin-2">setBrushOrigin</a></strong>(const QPoint &amp;<em>position</em>)</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="#setClipPath">setClipPath</a></strong>(const QPainterPath &amp;<em>path</em>, Qt::ClipOperation <em>operation</em> = Qt::ReplaceClip)</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="#setClipRect">setClipRect</a></strong>(const QRectF &amp;<em>rectangle</em>, Qt::ClipOperation <em>operation</em> = Qt::ReplaceClip)</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="#setClipRect-1">setClipRect</a></strong>(const QRect &amp;<em>rectangle</em>, Qt::ClipOperation <em>operation</em> = Qt::ReplaceClip)</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="#setClipRect-2">setClipRect</a></strong>(int <em>x</em>, int <em>y</em>, int <em>width</em>, int <em>height</em>, Qt::ClipOperation <em>operation</em> = Qt::ReplaceClip)</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="#setClipRegion">setClipRegion</a></strong>(const QRegion &amp;<em>region</em>, Qt::ClipOperation <em>operation</em> = Qt::ReplaceClip)</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="#setClipping">setClipping</a></strong>(bool <em>enable</em>)</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="#setCompositionMode">setCompositionMode</a></strong>(QPainter::CompositionMode <em>mode</em>)</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="#setFont">setFont</a></strong>(const QFont &amp;<em>font</em>)</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="#setLayoutDirection">setLayoutDirection</a></strong>(Qt::LayoutDirection <em>direction</em>)</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="#setOpacity">setOpacity</a></strong>(qreal <em>opacity</em>)</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="#setPen">setPen</a></strong>(const QPen &amp;<em>pen</em>)</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="#setPen-1">setPen</a></strong>(const QColor &amp;<em>color</em>)</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="#setPen-2">setPen</a></strong>(Qt::PenStyle <em>style</em>)</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="#setRenderHint">setRenderHint</a></strong>(QPainter::RenderHint <em>hint</em>, bool <em>on</em> = true)</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="#setRenderHints">setRenderHints</a></strong>(QPainter::RenderHints <em>hints</em>, bool <em>on</em> = true)</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="#setTransform">setTransform</a></strong>(const QTransform &amp;<em>transform</em>, bool <em>combine</em> = false)</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="#setViewTransformEnabled">setViewTransformEnabled</a></strong>(bool <em>enable</em>)</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="#setViewport">setViewport</a></strong>(const QRect &amp;<em>rectangle</em>)</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="#setViewport-1">setViewport</a></strong>(int <em>x</em>, int <em>y</em>, int <em>width</em>, int <em>height</em>)</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="#setWindow">setWindow</a></strong>(const QRect &amp;<em>rectangle</em>)</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="#setWindow-1">setWindow</a></strong>(int <em>x</em>, int <em>y</em>, int <em>width</em>, int <em>height</em>)</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="#setWorldMatrixEnabled">setWorldMatrixEnabled</a></strong>(bool <em>enable</em>)</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="#setWorldTransform">setWorldTransform</a></strong>(const QTransform &amp;<em>matrix</em>, bool <em>combine</em> = false)</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="#shear">shear</a></strong>(qreal <em>sh</em>, qreal <em>sv</em>)</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="#strokePath">strokePath</a></strong>(const QPainterPath &amp;<em>path</em>, const QPen &amp;<em>pen</em>)</td>
</tr>
<tr>
<td>bool</td>
<td><strong><a href="#testRenderHint">testRenderHint</a></strong>(QPainter::RenderHint <em>hint</em>) const</td>
</tr>
<tr>
<td>const QTransform &amp;</td>
<td><strong><a href="#transform">transform</a></strong>() const</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="#translate">translate</a></strong>(const QPointF &amp;<em>offset</em>)</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="#translate-1">translate</a></strong>(const QPoint &amp;<em>offset</em>)</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="#translate-2">translate</a></strong>(qreal <em>dx</em>, qreal <em>dy</em>)</td>
</tr>
<tr>
<td>bool</td>
<td><strong><a href="#viewTransformEnabled">viewTransformEnabled</a></strong>() const</td>
</tr>
<tr>
<td>QRect</td>
<td><strong><a href="#viewport">viewport</a></strong>() const</td>
</tr>
<tr>
<td>QRect</td>
<td><strong><a href="#window">window</a></strong>() const</td>
</tr>
<tr>
<td>bool</td>
<td><strong><a href="#worldMatrixEnabled">worldMatrixEnabled</a></strong>() const</td>
</tr>
<tr>
<td>const QTransform &amp;</td>
<td><strong><a href="#worldTransform">worldTransform</a></strong>() const</td>
</tr>
</tbody></table>
<h2><span id="xiang-xi-miao-shu">详细描述</span><a href="#xiang-xi-miao-shu" class="header-anchor">#</a></h2><p>QPainter提供了高度优化的功能来完成GUI程序所需的大部分绘图。它可以绘制从简单的线条到复杂的形状，如馅饼和和弦的一切。它还可以绘制对齐的文本和像素图。通常情况下，它在一个 “自然 “坐标系中绘制，但它也可以进行视图和世界的转换。QPainter可以对任何继承了<a href="qt-6/qpaintdevice.html">QPaintDevice</a>类的对象进行操作。</p>
<p>QPainter的常见用途是在一个widget的paint事件里面。构建并定制(例如，设置笔或画笔)画师。然后绘制。记住在画完后要销毁QPainter对象。比如说:</p>
<div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">SimpleExampleWidget::paintEvent</span><span class="hljs-params">(QPaintEvent *)</span></span>
<span class="hljs-function"></span>{
    <span class="hljs-function">QPainter <span class="hljs-title">painter</span><span class="hljs-params">(<span class="hljs-keyword">this</span>)</span></span>;
    painter.<span class="hljs-built_in">setPen</span>(Qt::blue);
    painter.<span class="hljs-built_in">setFont</span>(<span class="hljs-built_in">QFont</span>(<span class="hljs-string">"Arial"</span>, <span class="hljs-number">30</span>));
    painter.<span class="hljs-built_in">drawText</span>(<span class="hljs-built_in">rect</span>(), Qt::AlignCenter, <span class="hljs-string">"Qt"</span>);
}</code></pre></div>

<p>QPainter的核心功能是绘制，但该类也提供了几个函数，允许你自定义QPainter的设置和它的渲染质量，还有一些函数可以实现剪裁。此外，你可以通过指定画家的组成模式来控制不同的形状如何合并在一起。</p>
<p><a href="#isActive">isActive</a>()函数表示绘画器是否被激活。画家是由 <a href="#begin">begin</a>() 函数和接受 <a href="qt-6/qpaintdevice.html">QPaintDevice</a> 参数的构造函数激活。<a href="#end">end</a>()函数和析构器会使其停用。</p>
<p>QPainter 与 <a href="qt-6/qpaintdevice.html">QPaintDevice</a> 和 <a href="qt-6/qpaintengine.html">QPaintEngine</a> 类一起，构成了 Qt 绘画系统的基础。QPainter是用于执行绘图操作的类。<a href="qt-6/qpaintdevice.html">QPaintDevice</a>表示一个可以用QPainter进行绘画的设备。<a href="qt-6/qpaintengine.html">QPaintEngine</a> 提供了绘画者用来在不同类型的设备上绘画的接口。如果绘画器处于活动状态，<a href="#device">device</a>()返回绘画器进行绘画的设备，<a href="#paintEngine">paintEngine</a>()返回绘画器当前正在操作的绘画引擎。更多信息请参见<a href="qt-6/paintsystem.html">Paint System</a>。</p>
<p>有时，让别人在一个不寻常的<a href="qt-6/qpaintdevice.html">QPaintDevice</a>上作画是可取的。QPainter支持一个静态函数来做这件事，setRedirected()。</p>
<p><strong>警告：</strong>当painttdevice是一个widget时，QPainter只能在paintEvent()函数内或paintEvent()调用的函数中使用。</p>
<h3><span id="she-zhi">设置</span><a href="#she-zhi" class="header-anchor">#</a></h3><p>有几个设置可以让你自定义，以使QPainter按照你的喜好来绘制。</p>
<ul>
<li><a href="#font">font</a>()是用于绘制文本的字体。如果画家 <a href="#isActive">isActive</a>()，你可以分别使用 <a href="#fontInfo">fontInfo</a>() 和 <a href="#fontMetrics">fontMetrics</a>() 函数来检索关于当前设置的字体及其度量的信息。</li>
<li><a href="#brush">brush</a>() 定义了用于填充形状的颜色或图案。</li>
<li><a href="#pen">pen</a>()定义了用于绘制线条或边界的颜色或纹路。</li>
<li><a href="#backgroundMode">backgroundMode</a>() 定义是否有 <a href="#background">background</a>() ，即它是 <a href="qt-6/qt.html#BGMode-enum">Qt::OpaqueMode</a> 或 <a href="qt-6/qt.html#BGMode-enum">Qt::TransparentMode</a> 。</li>
<li><a href="#background">background</a>() 只在 <a href="#backgroundMode">backgroundMode</a>() 是 <a href="qt-6/qt.html#BGMode-enum">Qt::OpaqueMode</a> 并且 <a href="#pen">pen</a>() 是硬笔画时适用。在这种情况下，它描述了僵局中背景像素的颜色。</li>
<li><a href="#brushOrigin">brushOrigin</a>()定义了平铺笔刷的原点，通常是 widget 的背景原点。</li>
<li><a href="#viewport">viewport</a>(), <a href="#window">window</a>(), <a href="#worldTransform">worldTransform</a>()组成了画师的坐标转换系统。更多信息，请参阅 <a href="#coordinate-transformations">Coordinate Transformations</a> 部分和 <a href="qt-6/coordsys.html">Coordinate System</a> 文档。</li>
<li><a href="#hasClipping">hasClipping</a>()告诉画师是否会夹住。(繪圖裝置也會夾擊。)如果繪圖器夾擊，它會夾擊到 <a href="#clipRegion">clipRegion</a> ()。</li>
<li>layoutDirection](#layoutDirection)()定义了绘图器在绘制文本时使用的布局方向。</li>
<li><a href="#worldMatrixEnabled">worldMatrixEnabled</a>()告知是否启用了世界转换。</li>
<li><a href="#viewTransformEnabled">viewTransformEnabled</a>()告知是否启用视图转换。</li>
</ul>
<p>请注意，其中一些设置反映了一些绘画设备中的设置，例如 <a href="#font-prop">QWidget::font</a>()。<a href="#begin">QPainter::begin</a>()函数(或者等同于QPainter构造函数)从绘画设备中复制这些属性。</p>
<p>你可以在任何时候通过调用 <a href="#save">save</a>() 函数来保存 QPainter 的状态，该函数将所有可用的设置保存在一个内部栈中。<a href="#restore">restore</a>()函数将它们弹回来。</p>
<h3><span id="hui-zhi">绘制</span><a href="#hui-zhi" class="header-anchor">#</a></h3><p>QPainter提供了绘制大多数基元的函数。<a href="#drawPoint">drawPoint</a>(), <a href="#drawPoints">drawPoints</a>(), <a href="#drawLine">drawLine</a>(), <a href="#drawRect">drawRect</a>(), <a href="#drawRoundedRect">drawRoundedRect</a>(), <a href="#drawEllipse">drawEllipse</a>(), <a href="#drawArc">drawArc</a> <a href="#drawPie">drawPie</a>(), <a href="#drawChord">drawChord</a>(), <a href="#drawPolyline">drawPolyline</a>(), <a href="#drawPolygon">drawPolygon</a>(), <a href="#drawConvexPolygon">drawConvexPolygon</a> () 和 drawCubicBezier() 。两个方便的函数，<a href="#drawRects">drawRects</a>()和<a href="#drawLines">drawLines</a>()，使用当前的笔和画笔在给定的<a href="qt-6/qrect.html">QRects</a>或<a href="qt-6/qline.html">QLines</a>的数组中绘制指定数量的矩形或线。</p>
<p>QPainter类还提供了<a href="#fillRect">fillRect</a>()函数，它用给定的<a href="qt-6/qrect.html">QRect</a>填充给定的<a href="qt-6/qbrush.html">QBrush</a>，以及<a href="#eraseRect">eraseRect</a>()函数，擦除给定矩形内部区域。</p>
<p>所有这些函数都有整数和浮点两种版本。</p>
<table>
<thead>
<tr>
<th><img src="https://doc.qt.io/qt-6/images/qpainter-basicdrawing.png" srcset="/img/loading.gif" lazyload alt="img"></th>
<th><strong>基本绘图实例</strong>*<a href="qt-6/qtwidgets-painting-basicdrawing-example.html">基本绘图</a>实例展示了如何使用QPainter类以各种风格显示基本图形基元。</th>
</tr>
</thead>
<tbody><tr>
<td></td>
<td></td>
</tr>
</tbody></table>
<p>如果你需要绘制一个复杂的形状，尤其是需要反复绘制，可以考虑创建一个<a href="qt-6/qpainterpath.html">QPainterPath</a>并使用<a href="#drawPath">drawPath</a>()来绘制。</p>
<table>
<thead>
<tr>
<th><strong>画家路径示例</strong><a href="qt-6/qpainterpath.html">QPainterPath</a>类提供了一个绘画操作的容器，使图形形状能够被构建和重复使用。<a href="qt-6/qtwidgets-painting-painterpaths-example.html">Painter Paths</a>示例显示了如何使用画家路径来构建复杂的形状进行渲染。</th>
<th><img src="https://doc.qt.io/qt-6/images/qpainter-painterpaths.png" srcset="/img/loading.gif" lazyload alt="img"></th>
</tr>
</thead>
<tbody><tr>
<td></td>
<td></td>
</tr>
</tbody></table>
<p>QPainter还提供了<a href="#fillPath">fillPath</a>()函数，它用给定的<a href="qt-6/qpainterpath.html">QBrush</a>填充给定的<a href>QPainterPath</a>，以及<a href>strokePath</a>函数，它画出给定路径的轮廓(即描画路径)。</p>
<p>也请看 <a href="qt-6/qtwidgets-painting-deform-example.html">Vector Deformation</a> 示例，它展示了如何使用高级矢量技术来绘制使用 <a href="qt-6/qpainterpath.html">QPainterPath</a> 的文本，<a href="qt-6/qtwidgets-painting-gradients-example.html">Gradients</a>的例子，展示了Qt中可用的不同类型的梯度,和 <a href="qt-6/qtwidgets-painting-pathstroke-example.html">Path Stroking</a>的例子，它展示了Qt的内置破折号图案，并展示了如何使用自定义图案来扩展可用图案的范围。</p>
<table>
<thead>
<tr>
<th align="center"><a href="qt-6/qtwidgets-painting-deform-example.html">Vector Deformation</a></th>
<th align="center"><a href="qt-6/qtwidgets-painting-gradients-example.html">Gradients</a></th>
<th align="center"><a href="qt-6/qtwidgets-painting-pathstroke-example.html">Path Stroking</a></th>
</tr>
</thead>
<tbody><tr>
<td align="center"><img src="https://doc.qt.io/qt-6/images/qpainter-vectordeformation.png" srcset="/img/loading.gif" lazyload alt="img"></td>
<td align="center"><img src="https://doc.qt.io/qt-6/images/qpainter-gradients.png" srcset="/img/loading.gif" lazyload alt="img"></td>
<td align="center"><img src="https://doc.qt.io/qt-6/images/qpainter-pathstroking.png" srcset="/img/loading.gif" lazyload alt="img"></td>
</tr>
</tbody></table>
<p>文本绘制是通过<a href="#drawText">drawText</a>()完成的。当你需要精细的定位时，<a href="#boundingRect">boundingRect</a>()会告诉你一个给定的<a href="#drawText">drawText</a>()命令将在哪里绘制。</p>
<h3><span id="hui-zhi-pixmaps-he-tu-xiang">绘制Pixmaps和图像</span><a href="#hui-zhi-pixmaps-he-tu-xiang" class="header-anchor">#</a></h3><p>有一些绘制像素图/图像的函数，即<a href="#drawPixmap">drawPixmap</a>()、<a href="#drawImage">drawImage</a>()和<a href="#drawTiledPixmap">drawTiledPixmap</a>()。<a href="#drawPixmap">drawPixmap</a>()和<a href="#drawImage">drawImage</a>()产生相同的结果，只是<a href="#drawPixmap">drawPixmap</a>()在屏幕上更快，而<a href="#drawImage">drawImage</a>()在<a href="qt-6/qprinter.html">QPrinter</a>或其他设备上可能更快。</p>
<p>有一个 <a href="#drawPicture">drawPicture</a>() 函数可以画出整个 <a href="qt-6/qpicture.html">QPicture</a> 的内容。<a href="#drawPicture">drawPicture</a>()函数是唯一一个无视所有绘画者设置的函数，因为<a href="qt-6/qpicture.html">QPicture</a>有它自己的设置。</p>
<h4><span id="hui-zhi-gao-fen-bian-lu-ban-ben-de-pixmaps-he-tu-xiang">绘制高分辨率版本的Pixmaps和图像</span><a href="#hui-zhi-gao-fen-bian-lu-ban-ben-de-pixmaps-he-tu-xiang" class="header-anchor">#</a></h4><p>高分辨率版本的像素图的<em>device pixel ratio</em>值大于1(见<a href="qt-6/qimagereader.html">QImageReader</a>, <a href="qt-6/qpixmap.html#devicePixelRatio">QPixmap::devicePixelRatio</a> ())。如果它与底层的<a href="qt-6/qpaintdevice.html">QPaintDevice</a>的值相匹配，它将被直接绘制到设备上，而不需要额外的转换。</p>
<p>例如，当把一个设备像素比为2 的64x64像素大小的<a href="qt-6/qpixmap.html">QPixmap</a>画到一个设备像素比也为2的高DPI屏幕上时，就是这种情况。 请注意，这个像素图在<em>用户空间</em>中实际上是32x32像素。Qt中基于像素图尺寸计算布局几何的代码路径将使用这个尺寸。这样做的净效果是，像素图被显示为高DPI像素图，而不是一个大像素图。</p>
<h3><span id="xuan-ran-zhi-liang">渲染质量</span><a href="#xuan-ran-zhi-liang" class="header-anchor">#</a></h3><p>为了使用QPainter获得最佳的渲染结果，你应该使用独立于平台的<a href="qt-6/qimage.html">QImage</a>作为绘制设备；也就是说，使用<a href="qt-6/qimage.html">QImage</a>将确保结果在任何平台上都有相同的像素表现。</p>
<p>QPainter类还通过其<a href="#RenderHint-enum">RenderHint</a>枚举和对浮点精度的支持提供了一种控制渲染质量的方法。所有用于绘制基元的函数都有一个浮点版本。这些经常与 <a href="#RenderHint-enum">QPainter::Antialiasing</a> 渲染提示结合使用。</p>
<table>
<thead>
<tr>
<th><img src="https://doc.qt.io/qt-6/images/qpainter-concentriccircles.png" srcset="/img/loading.gif" lazyload alt="img"></th>
<th><strong>同心圆例子</strong><a href="qt-6/qtwidgets-painting-concentriccircles-example.html">同心圆</a>例子显示了在绘制自定义部件时，使用浮点精度和抗锯齿可以获得更好的渲染质量。该应用程序的主窗口显示了几个部件，这些部件是使用精度和抗锯齿的不同组合绘制的。</th>
</tr>
</thead>
<tbody><tr>
<td></td>
<td></td>
</tr>
</tbody></table>
<p><a href="#RenderHint-enum">RenderHint</a>枚举指定了QPainter的标志，这些标志可能被任何给定的引擎尊重，也可能不被尊重。<a href="#RenderHint-enum">QPainter::Antialiasing</a>表示如果可能的话，引擎应该对基元的边缘进行抗锯齿处理，<a href="#RenderHint-enum">QPainter::TextAntialiasing</a>表示如果可能的话，引擎应该对文本进行抗锯齿处理，而<a href="#RenderHint-enum">QPainter::SmoothPixmapTransform</a> 表示引擎应该使用平滑像素图转换算法。</p>
<p><a href="#renderHints">renderHints</a>()函数返回一个标志，指定为这个画师设置的渲染提示。使用<a href="#setRenderHint">setRenderHint</a>()函数来设置或清除当前设置的<a href="#RenderHint-enum">RenderHints</a> 。</p>
<h3><span id="zuo-biao-bian-huan">坐标变换</span><a href="#zuo-biao-bian-huan" class="header-anchor">#</a></h3><p>通常情况下，QPainter在设备自己的坐标系(通常是像素)上操作，但QPainter对坐标转换有很好的支持。</p>
<table>
<thead>
<tr>
<th align="center">nop</th>
<th align="center"><a href="#rotate">rotate</a>()</th>
<th align="center"><a href="#scale">scale</a>()</th>
<th align="center"><a href="#translate">translate</a>()</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><img src="https://doc.qt.io/qt-6/images/qpainter-clock.png" srcset="/img/loading.gif" lazyload alt="img"></td>
<td align="center"><img src="https://doc.qt.io/qt-6/images/qpainter-rotation.png" srcset="/img/loading.gif" lazyload alt="img"></td>
<td align="center"><img src="https://doc.qt.io/qt-6/images/qpainter-scale.png" srcset="/img/loading.gif" lazyload alt="img"></td>
<td align="center"><img src="https://doc.qt.io/qt-6/images/qpainter-translation.png" srcset="/img/loading.gif" lazyload alt="img"></td>
</tr>
</tbody></table>
<p>最常用的变换是缩放、旋转、平移和剪切。使用<a href="#scale">scale</a>()函数将坐标系按给定的偏移量缩放，使用<a href="#rotate">rotate</a>()函数将其顺时针旋转，使用<a href="#translate">translate</a>()将其平移(即在各点上增加给定的偏移量)。你也可以使用<a href="#shear">shear</a>()函数将坐标系围绕原点扭转。参见<a href="qt-6/qtwidgets-painting-affine-example.html">Affine Transformations</a>的例子，以了解剪切坐标系的可视化情况。</p>
<p>也请参见 <a href="qt-6/qtwidgets-painting-transformations-example.html">Transformations</a> 示例，它显示了变换如何影响 QPainter 渲染图形基元的方式。特别是它显示了变换的顺序是如何影响结果的。</p>
<table>
<thead>
<tr>
<th><strong>仿射变换示例</strong><a href="qt-6/qtwidgets-painting-affine-example.html">仿射变换</a> 示例展示了 Qt 对绘画操作执行仿射变换的能力。 该演示还允许用户尝试转换操作并立即查看结果。</th>
<th><img src="https://doc.qt.io/qt-6/images/qpainter-affinetransformations.png" srcset="/img/loading.gif" lazyload alt="img"></th>
</tr>
</thead>
<tbody><tr>
<td></td>
<td></td>
</tr>
</tbody></table>
<p>所有的变换操作都对变换<a href="#worldTransform">worldTransform</a>()进行操作。矩阵将平面上的一个点转换为另一个点。关于变换矩阵的更多信息，请参阅 <a href="qt-6/coordsys.html">Coordinate System</a> 和 <a href="qt-6/qtransform.html">QTransform</a> 文档。</p>
<p><a href="#setWorldTransform">setWorldTransform</a>()函数可以替换或添加到当前设置的<a href="#worldTransform">worldTransform</a>()。<a href="#resetTransform">resetTransform</a>()函数可以重置任何使用<a href="#translate">translate</a>()、<a href="#scale">scale</a>()、<a href="#shear">shear</a>()、<a href="#rotate">rotate</a>()、<a href="#setWorldTransform">setWorldTransform</a>()、<a href="#setViewport">setViewport</a>() 和<a href="#setWindow">setWindow</a> ()函数进行的变换。<a href="#deviceTransform">deviceTransform</a>()返回从逻辑坐标转换到依赖于平台的绘画设备的设备坐标的矩阵。后一个函数只有在对平台依赖的手柄使用平台绘画命令时才需要，而且平台不做原生转换。</p>
<p>当用QPainter绘图时，我们用逻辑坐标指定点，然后将其转换为绘图设备的物理坐标。逻辑坐标到物理坐标的映射由QPainter的<a href="#combinedTransform">combinedTransform</a>()处理，它是<a href="#viewport">viewport</a>()和<a href="#window">window</a>()以及<a href="#worldTransform">worldTransform</a>()的结合。<a href="#viewport">viewport</a>()代表指定一个任意矩形的物理坐标，<a href="#window">window</a>()以逻辑坐标描述相同的矩形，而<a href="#worldTransform">worldTransform</a>()则与变换矩阵相同。</p>
<p>See also <a href="qt-6/coordsys.html">Coordinate System</a></p>
<h3><span id="jian-ji">剪辑</span><a href="#jian-ji" class="header-anchor">#</a></h3><p>QPainter可以将任何绘图操作剪辑到一个矩形、一个区域或一个矢量路径。当前的剪辑可以通过函数<a href="#clipRegion">clipRegion</a>()和<a href="#clipPath">clipPath</a>()获得。是选择路径还是区域(更快)取决于底层的<a href="#paintEngine">paintEngine</a>()。例如，<a href="qt-6/qimage.html">QImage</a>绘画引擎更倾向于路径，而X11绘画引擎更倾向于区域。设置一个剪辑是在绘画者的逻辑坐标中进行的。</p>
<p>在QPainter的剪辑之后，绘画设备也可以进行剪辑。例如，大多数widget都会剪掉被子widget使用的像素，大多数打印机也会剪掉纸张边缘附近的区域。这种额外的剪裁不会被<a href="#clipRegion">clipRegion</a>()或<a href="#hasClipping">hasClipping</a>()的返回值所反映。</p>
<h3><span id="gou-cheng-mo-shi">构成模式</span><a href="#gou-cheng-mo-shi" class="header-anchor">#</a></h3><p>QPainter提供了<a href="#CompositionMode-enum">CompositionMode</a>枚举，定义了数字图像合成的Porter-Duff规则；它描述了将一个图像(源)中的像素与另一个图像(目的)中的像素相结合的模型。</p>
<p>最常见的两种合成方式是<a href="#CompositionMode-enum">Source</a>和<a href="#CompositionMode-enum">SourceOver</a>。<a href="#CompositionMode-enum">Source</a>是用来将不透明的物体绘制到绘画设备上。在这种模式下，源文件中的每个像素都会取代目标文件中的相应像素。在<a href="#CompositionMode-enum">SourceOver</a>组合模式下，源对象是透明的，被画在目标对象的上面。</p>
<p>请注意，组合变换是按像素操作的。出于这个原因，使用图形基元本身和它的边界矩形之间有区别。边界矩形包含 alpha == 0 的像素(即围绕着基元的像素)。这些像素会覆盖其他图像的像素，有效地清除这些像素，而基元只覆盖它自己的区域。</p>
<table>
<thead>
<tr>
<th><img src="https://doc.qt.io/qt-6/images/qpainter-compositiondemo.png" srcset="/img/loading.gif" lazyload alt="img"></th>
<th><strong>组合模式实例</strong><a href="qt-6/qtwidgets-painting-composition-example.html">组合模式</a>实例，可在Qt的实例目录中找到，它允许你试验各种组合模式并立即看到结果。</th>
</tr>
</thead>
<tbody><tr>
<td></td>
<td></td>
</tr>
</tbody></table>
<h3><span id="xian-zhi-yin-su">限制因素</span><a href="#xian-zhi-yin-su" class="header-anchor">#</a></h3><p>如果你在Qt的基于光栅的绘画引擎中使用坐标，需要注意的是，虽然可以使用大于+/-215的坐标，但用这个范围以外的坐标进行的任何绘画都不能保证显示出来；绘画可能会被剪掉。这是由于在实现中使用了 “short int “的缘故。</p>
<p>当处理弯曲的形状时，由Qt的stroker生成的轮廓只是一个近似值。在大多数情况下，用另一条贝塞尔曲线段来表示贝塞尔曲线的轮廓是不可能的，因此Qt通过使用几条更小的曲线来逼近曲线的轮廓。由于性能的原因，Qt对这些轮廓使用的曲线数量是有限制的，因此当使用大的笔宽或比例时，轮廓的误差会增加。为了生成误差较小的轮廓，可以使用<a href="qt-6/qpainterpathstroker.html">QPainterPathStroker</a>类，它有setCurveThreshold成员函数，让用户指定误差容忍度。另一个解决方法是先将路径转换为多边形，然后再绘制多边形。</p>
<h3><span id="xing-neng">性能</span><a href="#xing-neng" class="header-anchor">#</a></h3><p>QPainter是一个丰富的框架，它允许开发者进行大量的图形操作，如梯度、组合模式和矢量图。而且QPainter可以在各种不同的硬件和软件堆栈中完成这些操作。自然，硬件和软件的底层组合对性能有一定的影响，而且由于排列组合的数量众多，要确保每一个操作在所有不同的组合模式、画笔、剪裁、变换等方面都能快速完成，几乎是不可能的任务。作为一种妥协，我们选择了QPainter API和后端中的一个子集，在这个子集中，性能被保证为在给定的硬件和软件组合中我们可以合理地得到它。</p>
<p>我们专注于高性能引擎的后端是。</p>
<ul>
<li>栅格 - 这个后端在纯软件中实现了所有的渲染，并且总是被用来渲染成QImages。为了获得最佳性能，只能使用格式类型<a href="qt-6/qimage.html#Format-enum">QImage::Format_ARGB32_Premultiplied</a>、<a href="qt-6/qimage.html#Format-enum">QImage::Format_RGB32</a>或<a href="qt-6/qimage.html#Format-enum">QImage::Format_RGB16</a>。任何其他格式，包括<a href="qt-6/qimage.html#Format-enum">QImage::Format_ARGB32</a>，其性能都会大大降低。这个引擎默认用于 <a href>QWidget</a> 和 <a href="qt-6/qpixmap.html">QPixmap</a> 。</li>
<li>OpenGL 2.0 (ES) - 这个后端是硬件加速图形的主要后端。它可以在支持OpenGL 2.0或OpenGL/ES 2.0规范的台式机和嵌入式设备上运行。这包括过去几年中生产的大多数图形芯片。该引擎可以通过使用QPainter到<a href="qt-6/qopenglwidget.html">QOpenGLWidget</a>来启用。</li>
</ul>
<p>这些操作是</p>
<ul>
<li>简单的变换，即平移和缩放，加上0、90、180、270度的旋转。</li>
<li><code>drawPixmap()</code>结合简单的变换和不透明的非平滑变换模式(<code>QPainter::SmoothPixmapTransform</code>未作为渲染提示启用)。</li>
<li>使用纯色、双色线性渐变和简单变换的矩形填充。</li>
<li>矩形剪裁有简单的变换和相交剪裁。</li>
<li>合成模式<code>QPainter::CompositionMode_Source</code>和<a href="#CompositionMode-enum">QPainter::CompositionMode_SourceOver</a>。</li>
<li>使用纯色和双色线性梯度填充的圆角矩形。</li>
<li>通过qDrawBorderPixmap的3x3修补像素图。</li>
</ul>
<p>这个列表给出了在一个对性能要求很高的应用中安全使用哪些功能的指示。对于某些设置，其他操作可能也很快，但在大量使用它们之前，建议在软件最终运行的系统上进行基准测试和验证。也有一些情况下可以使用昂贵的操作，例如当结果被缓存在<a href="qt-6/qpixmap.html">QPixmap</a>中时。</p>
<p><strong>See also</strong> <a href="qt-6/qpaintdevice.html">QPaintDevice</a>, <a href="qt-6/qpaintengine.html">QPaintEngine</a>, <a href="qt-6/qtsvg-index.html">Qt SVG</a>, <a href="qt-6/qtwidgets-painting-basicdrawing-example.html">Basic Drawing Example</a>, and <a href="qt-6/qdrawutil-h.html">Drawing Utility Functions</a>.</p>
<h2><span id="cheng-yuan-lei-xing-wen-dang">成员类型文档</span><a href="#cheng-yuan-lei-xing-wen-dang" class="header-anchor">#</a></h2><h3><span id="enum-qpainter-compositionmode">enum QPainter::CompositionMode</span><a href="#enum-qpainter-compositionmode" class="header-anchor">#</a></h3><p>定义了数字图像合成所支持的模式。合成模式用于指定一个图像（源）中的像素如何与另一个图像（目的）中的像素进行合并。</p>
<p>请注意，用RasterOp前缀表示的位数光栅操作模式，只在X11和光栅绘制引擎中得到原生支持。这意味着在Mac上使用这些模式的唯一方法是通过<a href="qt-6/qimage.html">QImage</a>。RasterOp表示的混合模式<em>不</em>支持带有alpha成分的笔和刷子。另外，打开<a href="#RenderHint-enum">QPainter::Antialiasing</a>渲染提示将有效地禁用RasterOp模式。</p>
<p><img src="https://doc.qt.io/qt-6/images/qpainter-compositionmode1.png" srcset="/img/loading.gif" lazyload alt="img"></p>
<p><img src="https://doc.qt.io/qt-6/images/qpainter-compositionmode2.png" srcset="/img/loading.gif" lazyload alt="img"></p>
<p>最常见的类型是SourceOver（通常称为alpha混合），源像素被混合在目标像素的上面，其方式是源的alpha分量定义了像素的半透明性。</p>
<p>一些合成模式需要源图像或目标图像中的alpha通道才能产生效 果。为了获得最佳性能，首选图像格式<a href="qt-6/qimage.html#Format-enum">Format_ARGB32_Premultiplied</a>。</p>
<p>当组合模式被设置时，它适用于所有绘画操作者、笔、刷子、渐变和像素图/图像绘制。</p>
<table>
<thead>
<tr>
<th>Constant</th>
<th>Value</th>
<th>Description</th>
</tr>
</thead>
<tbody><tr>
<td><code>QPainter::CompositionMode_SourceOver</code></td>
<td><code>0</code></td>
<td>这是默认模式。源点的alpha被用来混合目标点上面的像素。</td>
</tr>
<tr>
<td><code>QPainter::CompositionMode_DestinationOver</code></td>
<td><code>1</code></td>
<td>目的地的alpha被用来在源像素的基础上进行混合。该模式是CompositionMode_SourceOver的逆模式。</td>
</tr>
<tr>
<td><code>QPainter::CompositionMode_Clear</code></td>
<td><code>2</code></td>
<td>目的地的像素被清除（设置为完全透明），与源头无关。</td>
</tr>
<tr>
<td><code>QPainter::CompositionMode_Source</code></td>
<td><code>3</code></td>
<td>输出是源像素。(这意味着一个基本的复制操作，当源像素是不透明的时候，与SourceOver相同）。</td>
</tr>
<tr>
<td><code>QPainter::CompositionMode_Destination</code></td>
<td><code>4</code></td>
<td>输出是目标像素。这意味着混合没有效果。这种模式是CompositionMode_Source的逆向。</td>
</tr>
<tr>
<td><code>QPainter::CompositionMode_SourceIn</code></td>
<td><code>5</code></td>
<td>输出是源，其中的α被目的地的α所减少。</td>
</tr>
<tr>
<td><code>QPainter::CompositionMode_DestinationIn</code></td>
<td><code>6</code></td>
<td>输出是目的地，其中的阿尔法值被源的阿尔法值减少。这种模式是CompositionMode_SourceIn的逆模式。</td>
</tr>
<tr>
<td><code>QPainter::CompositionMode_SourceOut</code></td>
<td><code>7</code></td>
<td>输出是源，其中的阿尔法被目的地的倒数所减少。</td>
</tr>
<tr>
<td><code>QPainter::CompositionMode_DestinationOut</code></td>
<td><code>8</code></td>
<td>输出是目的地，其中的阿尔法被源的倒数减少。这种模式是CompositionMode_SourceOut的逆模式。</td>
</tr>
<tr>
<td><code>QPainter::CompositionMode_SourceAtop</code></td>
<td><code>9</code></td>
<td>源像素被混合在目标像素之上，源像素的alpha值被目标像素的alpha值减少。</td>
</tr>
<tr>
<td><code>QPainter::CompositionMode_DestinationAtop</code></td>
<td><code>10</code></td>
<td>目标像素被混合在源像素的上面，目标像素的alpha被目标像素的alpha减少。该模式是CompositionMode_SourceAtop的逆向模式。</td>
</tr>
<tr>
<td><code>QPainter::CompositionMode_Xor</code></td>
<td><code>11</code></td>
<td>源点的α值被目的地α值的倒数减少，与目的地合并，目的地的α值被源点α值的倒数减少。CompositionMode_Xor与bitwise Xor不一样。</td>
</tr>
<tr>
<td><code>QPainter::CompositionMode_Plus</code></td>
<td><code>12</code></td>
<td>源像素和目标像素的阿尔法和颜色都被加在一起。</td>
</tr>
<tr>
<td><code>QPainter::CompositionMode_Multiply</code></td>
<td><code>13</code></td>
<td>输出是源颜色乘以目标颜色。一个颜色与白色相乘，颜色不会改变，而一个颜色与黑色相乘，则产生黑色。</td>
</tr>
<tr>
<td><code>QPainter::CompositionMode_Screen</code></td>
<td><code>14</code></td>
<td>源色和目的色被倒置，然后相乘。用白色筛选一个颜色会产生白色，而用黑色筛选一个颜色会使颜色保持不变。</td>
</tr>
<tr>
<td><code>QPainter::CompositionMode_Overlay</code></td>
<td><code>15</code></td>
<td>根据目的色的不同，对颜色进行乘法或筛选。目的色与源色混合，以反映目的色的明度或暗度。</td>
</tr>
<tr>
<td><code>QPainter::CompositionMode_Darken</code></td>
<td><code>16</code></td>
<td>选择源色和目的色中较深的那一种。</td>
</tr>
<tr>
<td><code>QPainter::CompositionMode_Lighten</code></td>
<td><code>17</code></td>
<td>选择源色和目的色中较浅的那一种。</td>
</tr>
<tr>
<td><code>QPainter::CompositionMode_ColorDodge</code></td>
<td><code>18</code></td>
<td>目标颜色被提亮以反映源颜色。一个黑色的源色会使目标色保持不变。</td>
</tr>
<tr>
<td><code>QPainter::CompositionMode_ColorBurn</code></td>
<td><code>19</code></td>
<td>目标颜色被提亮以反映源颜色。目的地的颜色会变暗，以反映来源的颜色。白色的源色使目标色保持不变。</td>
</tr>
<tr>
<td><code>QPainter::CompositionMode_HardLight</code></td>
<td><code>20</code></td>
<td>根据源色的不同，对颜色进行乘法或筛选。浅色的源色会使目标色变浅，而深色的源色会使目标色变深。</td>
</tr>
<tr>
<td><code>QPainter::CompositionMode_SoftLight</code></td>
<td><code>21</code></td>
<td>根据源色使颜色变暗或变亮。类似于CompositionMode_HardLight。</td>
</tr>
<tr>
<td><code>QPainter::CompositionMode_Difference</code></td>
<td><code>22</code></td>
<td>从浅色中减去较深的颜色。用白色涂抹会颠倒目标色，而用黑色涂抹会使目标色保持不变。</td>
</tr>
<tr>
<td><code>QPainter::CompositionMode_Exclusion</code></td>
<td><code>23</code></td>
<td>与CompositionMode_Difference类似，但对比度较低。用白色涂抹会颠倒目标色，而用黑色涂抹会使目标色保持不变。</td>
</tr>
<tr>
<td><code>QPainter::RasterOp_SourceOrDestination</code></td>
<td><code>24</code></td>
<td>对源像素和目的像素进行位数OR操作（src OR dst）。</td>
</tr>
<tr>
<td><code>QPainter::RasterOp_SourceAndDestination</code></td>
<td><code>25</code></td>
<td>对源像素和目的像素进行位数和操作（src AND dst）。</td>
</tr>
<tr>
<td><code>QPainter::RasterOp_SourceXorDestination</code></td>
<td><code>26</code></td>
<td>对源像素和目的像素进行位数XOR操作（src XOR dst）。</td>
</tr>
<tr>
<td><code>QPainter::RasterOp_NotSourceAndNotDestination</code></td>
<td><code>27</code></td>
<td>对源像素和目的像素进行位数NOR操作（（NOT src）和（NOT dst）)。</td>
</tr>
<tr>
<td><code>QPainter::RasterOp_NotSourceOrNotDestination</code></td>
<td><code>28</code></td>
<td>对源像素和目的像素进行位数NAND操作（（NOT src）OR（NOT dst））。</td>
</tr>
<tr>
<td><code>QPainter::RasterOp_NotSourceXorDestination</code></td>
<td><code>29</code></td>
<td>做一个位操作，源像素被反转，然后与目标像素进行XOR（（NOT src）XOR dst）。</td>
</tr>
<tr>
<td><code>QPainter::RasterOp_NotSource</code></td>
<td><code>30</code></td>
<td>做一个位操作，源像素被倒置（NOT src）。</td>
</tr>
<tr>
<td><code>QPainter::RasterOp_NotSourceAndDestination</code></td>
<td><code>31</code></td>
<td>做一个位操作，将源码倒置，然后与目的码相加（（NOT src）AND dst）。</td>
</tr>
<tr>
<td><code>QPainter::RasterOp_SourceAndNotDestination</code></td>
<td><code>32</code></td>
<td>做一个位操作，将源像素与倒置的目标像素相加（src AND (NOT dst)）。</td>
</tr>
<tr>
<td><code>QPainter::RasterOp_NotSourceOrDestination</code></td>
<td><code>33</code></td>
<td>做一个位操作，将源码倒置，然后与目的码进行OR（（NOT src）OR dst）。</td>
</tr>
<tr>
<td><code>QPainter::RasterOp_ClearDestination</code></td>
<td><code>35</code></td>
<td>目的地的像素被清除（设置为0），与来源无关。</td>
</tr>
<tr>
<td><code>QPainter::RasterOp_SetDestination</code></td>
<td><code>36</code></td>
<td>目的地的像素被设置（设置为1），与源头无关。</td>
</tr>
<tr>
<td><code>QPainter::RasterOp_NotDestination</code></td>
<td><code>37</code></td>
<td>做一个位操作，目标像素被倒置（NOT dst）。</td>
</tr>
<tr>
<td><code>QPainter::RasterOp_SourceOrNotDestination</code></td>
<td><code>34</code></td>
<td>进行位操作，将源像素与反转的目标像素进行OR（src OR（NOT dst））。</td>
</tr>
</tbody></table>
<p><strong>See also</strong> <a href="#compositionMode">compositionMode</a>(), <a href="#setCompositionMode">setCompositionMode</a>(), <a href="#composition-modes">Composition Modes</a>, and <a href="qt-6/qtwidgets-painting-imagecomposition-example.html">Image Composition Example</a>.</p>
<h3><span id="enum-qpainter-pixmapfragmenthint-flags-qpainter-pixmapfragmenthints">enum QPainter::PixmapFragmentHint flags QPainter::PixmapFragmentHints</span><a href="#enum-qpainter-pixmapfragmenthint-flags-qpainter-pixmapfragmenthints" class="header-anchor">#</a></h3><table>
<thead>
<tr>
<th>Constant</th>
<th>Value</th>
<th>Description</th>
</tr>
</thead>
<tbody><tr>
<td><code>QPainter::OpaqueHint</code></td>
<td><code>0x01</code></td>
<td>表示要绘制的pixmap片段是不透明的。不透明片段的绘制速度可能会更快。</td>
</tr>
</tbody></table>
<p>PixmapFragmentHints类型是<a href="qt-6/qflags.html">QFlags</a><pixmapfragmenthint>的一个类型定义。它存储PixmapFragmentHint值的一个OR组合。</pixmapfragmenthint></p>
<p><strong>See also</strong> <a href="#drawPixmapFragments">QPainter::drawPixmapFragments</a>() and <a href="qt-6/qpainter-pixmapfragment.html">QPainter::PixmapFragment</a>.</p>
<h3><span id="enum-qpainter-renderhint-flags-qpainter-renderhints">enum QPainter::RenderHint flags QPainter::RenderHints</span><a href="#enum-qpainter-renderhint-flags-qpainter-renderhints" class="header-anchor">#</a></h3><p>渲染提示是用来给<a href>QPainter</a>指定标志的，这些标志可能被任何给定的引擎尊重，也可能不被尊重。</p>
<table>
<thead>
<tr>
<th>Constant</th>
<th>Value</th>
<th>Description</th>
</tr>
</thead>
<tbody><tr>
<td><code>QPainter::Antialiasing</code></td>
<td><code>0x01</code></td>
<td>表示如果可能的话，引擎应该对基元的边缘进行抗锯齿处理。</td>
</tr>
<tr>
<td><code>QPainter::TextAntialiasing</code></td>
<td><code>0x02</code></td>
<td>表示如果可能的话，引擎应该对文本进行抗锯齿处理。要强行关闭文本的抗锯齿功能，请不要使用这个提示。相反，在你的字体的样式策略上设置<a href="qt-6/qfont.html#StyleStrategy-enum">QFont::NoAntialias</a>。</td>
</tr>
<tr>
<td><code>QPainter::SmoothPixmapTransform</code></td>
<td><code>0x04</code></td>
<td>表示引擎应该使用平滑的像素图转换算法（如双线性）而不是最近的邻居。</td>
</tr>
<tr>
<td><code>QPainter::VerticalSubpixelPositioning</code></td>
<td><code>0x08</code></td>
<td>如果字体引擎支持的话，允许文本在垂直和水平方向上以小数点的方式定位。目前Freetype在所有的平台上，当提示偏好为<a href="qt-6/qfont.html#HintingPreference-enum">QFont::PreferNoHinting</a>时，都支持这个功能，在macOS上也支持。对于大多数使用情况，这不会提高视觉质量，但可能会增加内存消耗，并在一定程度上降低文本渲染性能。因此，不建议启用这个功能，除非用例需要它。一个这样的用例可能是将字形与其他视觉基元对齐。这个值是在Qt 6.1中添加的。</td>
</tr>
<tr>
<td><code>QPainter::LosslessImageRendering</code></td>
<td><code>0x40</code></td>
<td>尽可能地使用无损的图像渲染。目前，只有当<a href>QPainter</a>被用于通过<a href="qt-6/qprinter.html">QPrinter</a>或<a href="qt-6/qpdfwriter.html">QPdfWriter</a>输出PDF文件时，才会用到这个提示，其中<a href="#drawImage">drawImage</a>()/<a href="#drawPixmap">drawPixmap</a>()调用将使用无损压缩算法而不是有损JPEG压缩算法对图像编码。这个值是在Qt 5.13中添加的。</td>
</tr>
</tbody></table>
<p>RenderHints类型是<a href="qt-6/qflags.html">QFlags</a><renderhint>的一个类型定义。它存储了一个RenderHint值的OR组合。</renderhint></p>
<p><strong>See also</strong> <a href="#renderHints">renderHints</a>(), <a href="#setRenderHint">setRenderHint</a>(), <a href="#rendering-quality">Rendering Quality</a>, and <a href="qt-6/qtwidgets-painting-concentriccircles-example.html">Concentric Circles Example</a>.</p>
<h2><span id="cheng-yuan-han-shu-wen-dang">成员函数文档</span><a href="#cheng-yuan-han-shu-wen-dang" class="header-anchor">#</a></h2><h3><span id="qpainter-qpainter-qpaintdevice-device">QPainter::QPainter( *<em>device</em>)</span><a href="#qpainter-qpainter-qpaintdevice-device" class="header-anchor">#</a></h3><p>构建一个立即开始绘画的绘画器*设备。</p>
<p>这个构造函数对于短暂的绘画器来说很方便，例如在<a href="#paintEvent">QWidget::paintEvent</a>()中，应该只使用一次。构造函数为你调用<a href="#begin">begin</a>()，QPainter的析构函数自动调用<a href="#end">end</a>()。</p>
<p>下面是一个使用<a href="#begin">begin</a>()和<a href="#end">end</a>()的例子:</p>
<div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">MyWidget::paintEvent</span><span class="hljs-params">(QPaintEvent *)</span></span>
<span class="hljs-function"></span>{
    QPainter p;
    p.<span class="hljs-built_in">begin</span>(<span class="hljs-keyword">this</span>);
    p.<span class="hljs-built_in">drawLine</span>(drawingCode);        <span class="hljs-comment">// drawing code</span>
    p.<span class="hljs-built_in">end</span>();
}</code></pre></div>

<p>同样的例子，使用这个构造器:</p>
<div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">MyWidget::paintEvent</span><span class="hljs-params">(QPaintEvent *)</span></span>
<span class="hljs-function"></span>{
    <span class="hljs-function">QPainter <span class="hljs-title">p</span><span class="hljs-params">(<span class="hljs-keyword">this</span>)</span></span>;
    p.<span class="hljs-built_in">drawLine</span>(drawingCode);        <span class="hljs-comment">// drawing code</span>
}</code></pre></div>

<p>由于构造函数不能在绘画器初始化失败时提供反馈，你应该使用<a href="#begin">begin</a>()和<a href="#end">end</a>()来在外部设备上绘画，例如打印机。</p>
<p><strong>See also</strong> <a href="#begin">begin</a>() and <a href="#end">end</a>().</p>
<h3><span id="qpainter-qpainter">QPainter::QPainter()</span><a href="#qpainter-qpainter" class="header-anchor">#</a></h3><p>构建一个画家。</p>
<p><strong>See also</strong> <a href="#begin">begin</a>() and <a href="#end">end</a>().</p>
<h3><span id="qpainter-qpainter">QPainter::~QPainter()</span><a href="#qpainter-qpainter" class="header-anchor">#</a></h3><p>摧毁画家。</p>
<h3><span id="const-qbrush-amp-qpainter-background-const">const  &amp;QPainter::background() const</span><a href="#const-qbrush-amp-qpainter-background-const" class="header-anchor">#</a></h3><p>返回当前的背景画笔。</p>
<p><strong>See also</strong> <a href="#setBackground">setBackground</a>() and <a href="#settings">Settings</a>.</p>
<h3><span id="qt-bgmode-qpainter-backgroundmode-const"> QPainter::backgroundMode() const</span><a href="#qt-bgmode-qpainter-backgroundmode-const" class="header-anchor">#</a></h3><p>返回当前的背景模式。</p>
<p><strong>See also</strong> <a href="#setBackgroundMode">setBackgroundMode</a>() and <a href="#settings">Settings</a>.</p>
<h3><span id="bool-qpainter-begin-qpaintdevice-device">bool QPainter::begin( *<em>device</em>)</span><a href="#bool-qpainter-begin-qpaintdevice-device" class="header-anchor">#</a></h3><p>开始绘制<em>device</em>，如果成功，返回 “true”；否则返回 “false”。</p>
<p>注意，所有的绘画器设置（<a href="#setPen">setPen</a>(), <a href="#setBrush">setBrush</a>()等）在begin()被调用时都被重置为默认值。</p>
<p>可能发生的错误是严重的问题，比如说这些:</p>
<div class="code-wrapper"><pre><code class="hljs c++">painter-&gt;<span class="hljs-built_in">begin</span>(<span class="hljs-number">0</span>); <span class="hljs-comment">// impossible - paint device cannot be 0</span>

<span class="hljs-function">QPixmap <span class="hljs-title">image</span><span class="hljs-params">(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>)</span></span>;
painter-&gt;<span class="hljs-built_in">begin</span>(&amp;image); <span class="hljs-comment">// impossible - image.isNull() == true;</span>

painter-&gt;<span class="hljs-built_in">begin</span>(myWidget);
painter2-&gt;<span class="hljs-built_in">begin</span>(myWidget); <span class="hljs-comment">// impossible - only one painter at a time</span></code></pre></div>

<p>请注意，大多数情况下，你可以使用其中一个构造函数来代替begin()，而且<a href="#end">end</a>()在销毁时自动完成。</p>
<p><strong>警告：</strong>一个绘画设备一次只能由一个绘画者绘画。</p>
<p>**警告:**不支持在格式为<a href="qt-6/qimage.html#Format-enum">QImage::Format_Indexed8</a>的<a href="qt-6/qimage.html">QImage</a>上绘画。</p>
<p><strong>See also</strong> <a href="#end">end</a>() and <a href="#QPainter">QPainter</a>().</p>
<h3><span id="void-qpainter-beginnativepainting">void QPainter::beginNativePainting()</span><a href="#void-qpainter-beginnativepainting" class="header-anchor">#</a></h3><p>冲洗绘画管道，为用户直接向底层图形上下文发出命令做准备。之后必须调用<a href="#endNativePainting">endNativePainting</a>()。</p>
<p>注意，只有底层绘画引擎改变的状态会被重置为各自的默认状态。我们重置的状态可能会随着版本的变化而变化。目前在OpenGL 2引擎中，以下状态被重置。</p>
<ul>
<li>混合功能被禁用</li>
<li>深度、模版和剪刀测试被禁用</li>
<li>活动纹理单元被重置为0</li>
<li>深度掩码、深度函数和清除深度被重置为其默认值</li>
<li>网板遮罩、网板操作和网板功能被重置为它们的默认值</li>
<li>当前颜色被重置为纯白色</li>
</ul>
<p>例如，如果用户在beginNativePaint()/<a href="#endNativePainting">endNativePainting</a>()块中改变了OpenGL多边形模式，它将不会被<a href="#endNativePainting">endNativePainting</a>()重置为默认状态。这里有一个例子，显示了画师命令和原始OpenGL命令的混杂情况：</p>
<div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-function">QPainter <span class="hljs-title">painter</span><span class="hljs-params">(<span class="hljs-keyword">this</span>)</span></span>;
painter.<span class="hljs-built_in">fillRect</span>(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">128</span>, <span class="hljs-number">128</span>, Qt::green);
painter.<span class="hljs-built_in">beginNativePainting</span>();

<span class="hljs-built_in">glEnable</span>(GL_SCISSOR_TEST);
<span class="hljs-built_in">glScissor</span>(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">64</span>, <span class="hljs-number">64</span>);

<span class="hljs-built_in">glClearColor</span>(<span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>);
<span class="hljs-built_in">glClear</span>(GL_COLOR_BUFFER_BIT);

<span class="hljs-built_in">glDisable</span>(GL_SCISSOR_TEST);

painter.<span class="hljs-built_in">endNativePainting</span>();</code></pre></div>

<p><strong>See also</strong> <a href="#endNativePainting">endNativePainting</a>().</p>
<h3><span id="qrectf-qpainter-boundingrect-const-qrectf-amp-rectangle-int-flags-const-qstring-amp-text"> QPainter::boundingRect(const  &amp;<em>rectangle</em>, int <em>flags</em>, const  &amp;<em>text</em>)</span><a href="#qrectf-qpainter-boundingrect-const-qrectf-amp-rectangle-int-flags-const-qstring-amp-text" class="header-anchor">#</a></h3><p>返回<em>text</em>的边界矩形，因为它在使用当前设置的<a href="#font">font</a>()在给定的<em>rectangle</em>内用指定的<em>flags</em>绘制时将会出现；即该函数告诉你在给定相同参数时<a href="#drawText">drawText</a>()函数将绘制的位置。</p>
<p>如果使用指定的<em>flags</em>，<em>文本</em>不适合在给定的*矩形内，该函数会返回所需的矩形。</p>
<p><em>flags</em>参数是以下标志的位数之和:</p>
<ul>
<li><a href="qt-6/qt.html#AlignmentFlag-enum">Qt::AlignLeft</a></li>
<li><a href="qt-6/qt.html#AlignmentFlag-enum">Qt::AlignRight</a></li>
<li><a href="qt-6/qt.html#AlignmentFlag-enum">Qt::AlignHCenter</a></li>
<li><a href="qt-6/qt.html#AlignmentFlag-enum">Qt::AlignTop</a></li>
<li><a href="qt-6/qt.html#AlignmentFlag-enum">Qt::AlignBottom</a></li>
<li><a href="qt-6/qt.html#AlignmentFlag-enum">Qt::AlignVCenter</a></li>
<li><a href="qt-6/qt.html#AlignmentFlag-enum">Qt::AlignCenter</a></li>
<li><a href="qt-6/qt.html#TextFlag-enum">Qt::TextSingleLine</a></li>
<li><a href="qt-6/qt.html#TextFlag-enum">Qt::TextExpandTabs</a></li>
<li><a href="qt-6/qt.html#TextFlag-enum">Qt::TextShowMnemonic</a></li>
<li><a href="qt-6/qt.html#TextFlag-enum">Qt::TextWordWrap</a></li>
<li><a href="qt-6/qt.html#TextFlag-enum">Qt::TextIncludeTrailingSpaces</a></li>
</ul>
<p>如果几个水平对齐标志或几个垂直对齐标志被设置，那么产生的对齐方式是未定义的。</p>
<p><strong>See also</strong> <a href="#drawText">drawText</a>(), <a href="qt-6/qt.html#AlignmentFlag-enum">Qt::Alignment</a>, and <a href="qt-6/qt.html#TextFlag-enum">Qt::TextFlag</a>.</p>
<h3><span id="qrect-qpainter-boundingrect-const-qrect-amp-rectangle-int-flags-const-qstring-amp-text"> QPainter::boundingRect(const  &amp;<em>rectangle</em>, int <em>flags</em>, const  &amp;<em>text</em>)</span><a href="#qrect-qpainter-boundingrect-const-qrect-amp-rectangle-int-flags-const-qstring-amp-text" class="header-anchor">#</a></h3><p>这是一个重载函数。</p>
<p>返回<em>text</em>的边界矩形，因为它将在给定的<em>rectangle</em>内以指定的<em>flags</em>使用当前设置的<a href="#font">font</a>()绘制。</p>
<h3><span id="qrect-qpainter-boundingrect-int-x-int-y-int-w-int-h-int-flags-const-qstring-amp-text"> QPainter::boundingRect(int <em>x</em>, int <em>y</em>, int <em>w</em>, int <em>h</em>, int <em>flags</em>, const  &amp;<em>text</em>)</span><a href="#qrect-qpainter-boundingrect-int-x-int-y-int-w-int-h-int-flags-const-qstring-amp-text" class="header-anchor">#</a></h3><p>这是一个重载函数。</p>
<p>返回给定的<em>text</em>的边界矩形，因为它将出现在从点（<em>x</em>，<em>y</em>）开始的宽度为<em>w</em>，高度为<em>h</em>的矩形内。</p>
<h3><span id="qrectf-qpainter-boundingrect-const-qrectf-amp-rectangle-const-qstring-amp-text-const-qtextoption-amp-option-qtextoption"> QPainter::boundingRect(const  &amp;<em>rectangle</em>, const  &amp;<em>text</em>, const  &amp;<em>option</em> = QTextOption())</span><a href="#qrectf-qpainter-boundingrect-const-qrectf-amp-rectangle-const-qstring-amp-text-const-qtextoption-amp-option-qtextoption" class="header-anchor">#</a></h3><p>这是一个重载函数。</p>
<p>這個重载的函数不是以 <a href="qt-6/qt.html#AlignmentFlag-enum">Qt::AlignmentFlag</a> 和 <a href="qt-6/qt.html#TextFlag-enum">Qt::TextFlag</a> 的 bitwise OR 來指定标志，而是接受一個 <em>option</em> 的参数。<a href="qt-6/qtextoption.html">QTextOption</a> 类提供了对一般富文本属性的描述。</p>
<p><strong>See also</strong> <a href="qt-6/qtextoption.html">QTextOption</a>.</p>
<h3><span id="const-qbrush-amp-qpainter-brush-const">const  &amp;QPainter::brush() const</span><a href="#const-qbrush-amp-qpainter-brush-const" class="header-anchor">#</a></h3><p>返回画家的当前画笔。</p>
<p><strong>See also</strong> <a href="#setBrush">QPainter::setBrush</a>() and <a href="#settings">Settings</a>.</p>
<h3><span id="qpoint-qpainter-brushorigin-const"> QPainter::brushOrigin() const</span><a href="#qpoint-qpainter-brushorigin-const" class="header-anchor">#</a></h3><p>返回当前设置的画笔原点。</p>
<p><strong>See also</strong> <a href="#setBrushOrigin">setBrushOrigin</a>() and <a href="#settings">Settings</a>.</p>
<h3><span id="qrectf-qpainter-clipboundingrect-const"> QPainter::clipBoundingRect() const</span><a href="#qrectf-qpainter-clipboundingrect-const" class="header-anchor">#</a></h3><p>如果有一个剪辑，返回当前剪辑的边界矩形；否则返回一个空的矩形。注意，剪辑区域是以逻辑坐标给出的。</p>
<p>不保证边界矩形是紧密的。</p>
<p><strong>See also</strong> <a href="#setClipRect">setClipRect</a>(), <a href="#setClipPath">setClipath</a>(), and <a href="#setClipRegion">setClipRegion</a>().</p>
<h3><span id="qpainterpath-qpainter-clippath-const"> QPainter::clipPath() const</span><a href="#qpainterpath-qpainter-clippath-const" class="header-anchor">#</a></h3><p>返回逻辑坐标中的当前剪辑路径。</p>
<p><strong>警告：</strong> <a href>QPainter</a>不会明确地存储组合的剪辑，因为这是由底层的<a href="qt-6/qpaintengine.html">QPaintEngine</a>处理的，所以路径会根据需要重新创建并转换为当前逻辑坐标系。这有可能是一个昂贵的操作。</p>
<p><strong>See also</strong> <a href="#setClipPath">setClipPath</a>(), <a href="#clipRegion">clipRegion</a>(), and <a href="#setClipping">setClipping</a>().</p>
<h3><span id="qregion-qpainter-clipregion-const"> QPainter::clipRegion() const</span><a href="#qregion-qpainter-clipregion-const" class="header-anchor">#</a></h3><p>返回当前设置的剪辑区域。注意，剪辑区域是以逻辑坐标给出的。</p>
<p><strong>警告：</strong> <a href>QPainter</a>不会明确地存储组合的剪辑，因为这是由底层的<a href="qt-6/qpaintengine.html">QPaintEngine</a>处理的，所以路径会根据需要重新创建并转换为当前逻辑坐标系。这有可能是一个昂贵的操作。</p>
<p><strong>See also</strong> <a href="#setClipRegion">setClipRegion</a>(), <a href="#clipPath">clipPath</a>(), and <a href="#setClipping">setClipping</a>().</p>
<h3><span id="qtransform-qpainter-combinedtransform-const"> QPainter::combinedTransform() const</span><a href="#qtransform-qpainter-combinedtransform-const" class="header-anchor">#</a></h3><p>返回结合当前窗口/视口和世界变换的变换矩阵。</p>
<p><strong>See also</strong> <a href="#setWorldTransform">setWorldTransform</a>(), <a href="#setWindow">setWindow</a>(), and <a href="#setViewport">setViewport</a>().</p>
<h3><span id="qpainter-compositionmode-qpainter-compositionmode-const"> QPainter::compositionMode() const</span><a href="#qpainter-compositionmode-qpainter-compositionmode-const" class="header-anchor">#</a></h3><p>返回当前的合成模式。</p>
<p><strong>See also</strong> <a href="#CompositionMode-enum">CompositionMode</a> and <a href="#setCompositionMode">setCompositionMode</a>().</p>
<h3><span id="qpaintdevice-qpainter-device-const"> *QPainter::device() const</span><a href="#qpaintdevice-qpainter-device-const" class="header-anchor">#</a></h3><p>返回这个画师当前正在画的画具，如果画师没有活动，则返回<code>nullptr</code>。</p>
<p><strong>See also</strong> <a href="#isActive">isActive</a>().</p>
<h3><span id="const-qtransform-amp-qpainter-devicetransform-const">const  &amp;QPainter::deviceTransform() const</span><a href="#const-qtransform-amp-qpainter-devicetransform-const" class="header-anchor">#</a></h3><p>返回从逻辑坐标转换到平台依赖的绘画设备的设备坐标的矩阵。</p>
<p>只有 在对平台依赖的句柄（<a href="qt-6/qt.html#HANDLE-typedef">Qt::HANDLE</a>）使用平台绘画命令时，才*需要这个函数，而且平台不做本机转换。</p>
<p><a href="qt-6/qpaintengine.html#PaintEngineFeature-enum">QPaintEngine::PaintEngineFeature</a> 枚举可以被查询以确定平台是否执行转换。</p>
<p><strong>See also</strong> <a href="#worldTransform">worldTransform</a>() and <a href="qt-6/qpaintengine.html#hasFeature">QPaintEngine::hasFeature</a>().</p>
<h3><span id="void-qpainter-drawarc-const-qrectf-amp-rectangle-int-startangle-int-spanangle">void QPainter::drawArc(const  &amp;<em>rectangle</em>, int <em>startAngle</em>, int <em>spanAngle</em>)</span><a href="#void-qpainter-drawarc-const-qrectf-amp-rectangle-int-startangle-int-spanangle" class="header-anchor">#</a></h3><p>绘制由给定的<em>rectangle</em>、<em>startAngle</em>和<em>spanAngle</em>定义的圆弧。</p>
<p><em>startAngle</em>和<em>spanAngle</em>必须以1/16度指定，即一个完整的圆等于5760（16*360）。角度的正值意味着逆时针，而负值意味着顺时针方向。零度是在3点钟的位置。</p>
<table>
<thead>
<tr>
<th><img src="https://doc.qt.io/qt-6/images/qpainter-arc.png" srcset="/img/loading.gif" lazyload alt="img" style="zoom:200%;"></th>
<th><code>QRectF rectangle(10.0, 20.0, 80.0, 60.0); int startAngle = 30 * 16; int spanAngle = 120 * 16; QPainter painter(this); painter.drawArc(rectangle, startAngle, spanAngle);</code></th>
</tr>
</thead>
<tbody><tr>
<td></td>
<td></td>
</tr>
</tbody></table>
<p><strong>See also</strong> <a href="#drawPie">drawPie</a>(), <a href="#drawChord">drawChord</a>(), and <a href="qt-6/coordsys.html">Coordinate System</a>.</p>
<h3><span id="void-qpainter-drawarc-const-qrect-amp-rectangle-int-startangle-int-spanangle">void QPainter::drawArc(const  &amp;<em>rectangle</em>, int <em>startAngle</em>, int <em>spanAngle</em>)</span><a href="#void-qpainter-drawarc-const-qrect-amp-rectangle-int-startangle-int-spanangle" class="header-anchor">#</a></h3><p>这是一个重载函数。</p>
<p>绘制由给定的<em>rectangle</em>、<em>startAngle</em>和<em>spanAngle</em>定义的圆弧。</p>
<h3><span id="void-qpainter-drawarc-int-x-int-y-int-width-int-height-int-startangle-int-spanangle">void QPainter::drawArc(int <em>x</em>, int <em>y</em>, int <em>width</em>, int <em>height</em>, int <em>startAngle</em>, int <em>spanAngle</em>)</span><a href="#void-qpainter-drawarc-int-x-int-y-int-width-int-height-int-startangle-int-spanangle" class="header-anchor">#</a></h3><p>这是一个重载函数。</p>
<p>以指定的<em>width</em>和<em>height</em>，以及给定的<em>startAngle</em>和<em>spanAngle</em>，绘制矩形定义的弧线，从（<em>x</em>，<em>y</em>）开始。</p>
<h3><span id="void-qpainter-drawchord-const-qrectf-amp-rectangle-int-startangle-int-spanangle">void QPainter::drawChord(const  &amp;<em>rectangle</em>, int <em>startAngle</em>, int <em>spanAngle</em>)</span><a href="#void-qpainter-drawchord-const-qrectf-amp-rectangle-int-startangle-int-spanangle" class="header-anchor">#</a></h3><p>绘制由给定的<em>rectangle</em>、<em>startAngle</em>和<em>spanAngle</em>定义的弦。弦是用当前的<a href="#brush">画笔</a>()填充的。</p>
<p>startAngle和spanAngle必须以1/16度为单位指定，即一个完整的圆等于5760（16*360）。角度的正值意味着逆时针，而负值意味着顺时针方向。零度是在3点钟的位置。</p>
<table>
<thead>
<tr>
<th><img src="https://doc.qt.io/qt-6/images/qpainter-chord.png" srcset="/img/loading.gif" lazyload alt="img"></th>
<th><code>QRectF rectangle(10.0, 20.0, 80.0, 60.0); int startAngle = 30 * 16; int spanAngle = 120 * 16; QPainter painter(this); painter.drawChord(rect, startAngle, spanAngle);</code></th>
</tr>
</thead>
<tbody><tr>
<td></td>
<td></td>
</tr>
</tbody></table>
<p><strong>See also</strong> <a href="#drawArc">drawArc</a>(), <a href="#drawPie">drawPie</a>(), and <a href="qt-6/coordsys.html">Coordinate System</a>.</p>
<h3><span id="void-qpainter-drawchord-int-x-int-y-int-width-int-height-int-startangle-int-spanangle">void QPainter::drawChord(int <em>x</em>, int <em>y</em>, int <em>width</em>, int <em>height</em>, int <em>startAngle</em>, int <em>spanAngle</em>)</span><a href="#void-qpainter-drawchord-int-x-int-y-int-width-int-height-int-startangle-int-spanangle" class="header-anchor">#</a></h3><p>这是一个重载函数。</p>
<p>绘制由矩形定义的弦，从（<em>x</em>，<em>y</em>）开始，具有指定的<em>width</em>和<em>height</em>，以及给定的<em>startAngle</em>和<em>spanAngle</em>。</p>
<h3><span id="void-qpainter-drawchord-const-qrect-amp-rectangle-int-startangle-int-spanangle">void QPainter::drawChord(const  &amp;<em>rectangle</em>, int <em>startAngle</em>, int <em>spanAngle</em>)</span><a href="#void-qpainter-drawchord-const-qrect-amp-rectangle-int-startangle-int-spanangle" class="header-anchor">#</a></h3><p>这是一个重载函数。</p>
<p>绘制由给定的<em>rectangle</em>、<em>startAngle</em>和<em>spanAngle</em>定义的弦。</p>
<h3><span id="void-qpainter-drawconvexpolygon-const-qpointf-points-int-pointcount">void QPainter::drawConvexPolygon(const  *<em>points</em>, int <em>pointCount</em>)</span><a href="#void-qpainter-drawconvexpolygon-const-qpointf-points-int-pointcount" class="header-anchor">#</a></h3><p>使用当前的笔画出由数组<em>points</em>中的第一个<em>pointCount</em>点定义的凸形多边形。</p>
<table>
<thead>
<tr>
<th><img src="https://doc.qt.io/qt-6/images/qpainter-polygon.png" srcset="/img/loading.gif" lazyload alt="img" style="zoom:500%;"></th>
<th><code>static const QPointF points[4] = {    QPointF(10.0, 80.0),    QPointF(20.0, 10.0),    QPointF(80.0, 30.0),    QPointF(90.0, 70.0) }; QPainter painter(this); painter.drawConvexPolygon(points, 4);</code></th>
</tr>
</thead>
<tbody><tr>
<td></td>
<td></td>
</tr>
</tbody></table>
<p>第一个点隐含地连接到最后一个点，多边形用当前的<a href="#brush">brush</a>()填充。如果提供的多边形不是凸的，即它至少包含一个大于180度的角度，那么结果就无法定义。</p>
<p>在某些平台上（如X11），drawConvexPolygon()函数可能比<a href="#drawPolygon">drawPolygon</a>()函数快。</p>
<p><strong>See also</strong> <a href="#drawPolygon">drawPolygon</a>(), <a href="#drawPolyline">drawPolyline</a>(), and <a href="qt-6/coordsys.html">Coordinate System</a>.</p>
<h3><span id="void-qpainter-drawconvexpolygon-const-qpolygonf-amp-polygon">void QPainter::drawConvexPolygon(const  &amp;<em>polygon</em>)</span><a href="#void-qpainter-drawconvexpolygon-const-qpolygonf-amp-polygon" class="header-anchor">#</a></h3><p>这是一个重载函数。</p>
<p>使用当前的笔和画笔绘制由<em>polygon</em>定义的凸形多边形。</p>
<h3><span id="void-qpainter-drawconvexpolygon-const-qpoint-points-int-pointcount">void QPainter::drawConvexPolygon(const  *<em>points</em>, int <em>pointCount</em>)</span><a href="#void-qpainter-drawconvexpolygon-const-qpoint-points-int-pointcount" class="header-anchor">#</a></h3><p>这是一个重载函数。</p>
<p>使用当前的笔画出由数组<em>points</em>中的第一个<em>pointCount</em>点定义的凸形多边形。</p>
<h3><span id="void-qpainter-drawconvexpolygon-const-qpolygon-amp-polygon">void QPainter::drawConvexPolygon(const  &amp;<em>polygon</em>)</span><a href="#void-qpainter-drawconvexpolygon-const-qpolygon-amp-polygon" class="header-anchor">#</a></h3><p>这是一个重载函数。</p>
<p>使用当前的笔和画笔绘制由<em>polygon</em>定义的凸形多边形。</p>
<h3><span id="void-qpainter-drawellipse-const-qrectf-amp-rectangle">void QPainter::drawEllipse(const  &amp;<em>rectangle</em>)</span><a href="#void-qpainter-drawellipse-const-qrectf-amp-rectangle" class="header-anchor">#</a></h3><p>绘制由给定的<em>rectangle</em>定义的椭圆。</p>
<p>填充的椭圆的大小为<em>rectangle</em>.<a href="qt-6/qrect.html#size">size</a>()。描边的椭圆的大小为<em>rectangle</em>.<a href="qt-6/qrect.html#size">size</a>()加上笔宽。</p>
<table>
<thead>
<tr>
<th><img src="https://doc.qt.io/qt-6/images/qpainter-ellipse.png" srcset="/img/loading.gif" lazyload alt="img"></th>
<th><code>QRectF rectangle(10.0, 20.0, 80.0, 60.0); QPainter painter(this); painter.drawEllipse(rectangle);</code></th>
</tr>
</thead>
<tbody><tr>
<td></td>
<td></td>
</tr>
</tbody></table>
<p><strong>See also</strong> <a href="#drawPie">drawPie</a>() and <a href="qt-6/coordsys.html">Coordinate System</a>.</p>
<h3><span id="void-qpainter-drawellipse-const-qrect-amp-rectangle">void QPainter::drawEllipse(const  &amp;<em>rectangle</em>)</span><a href="#void-qpainter-drawellipse-const-qrect-amp-rectangle" class="header-anchor">#</a></h3><p>这是一个重载函数。</p>
<p>绘制由给定的<em>rectangle</em>定义的椭圆。</p>
<h3><span id="void-qpainter-drawellipse-int-x-int-y-int-width-int-height">void QPainter::drawEllipse(int <em>x</em>, int <em>y</em>, int <em>width</em>, int <em>height</em>)</span><a href="#void-qpainter-drawellipse-int-x-int-y-int-width-int-height" class="header-anchor">#</a></h3><p>这是一个重载函数。</p>
<p>绘制由始于（<em>x</em>，<em>y</em>）的矩形定义的椭圆，其<em>width</em>和<em>height</em>均已给定。</p>
<h3><span id="void-qpainter-drawellipse-const-qpointf-amp-center-qreal-rx-qreal-ry">void QPainter::drawEllipse(const  &amp;<em>center</em>,  <em>rx</em>,  <em>ry</em>)</span><a href="#void-qpainter-drawellipse-const-qpointf-amp-center-qreal-rx-qreal-ry" class="header-anchor">#</a></h3><p>这是一个重载函数。</p>
<p>绘制位于<em>center</em>的椭圆，半径为<em>rx</em>和<em>ry</em>。</p>
<h3><span id="void-qpainter-drawellipse-const-qpoint-amp-center-int-rx-int-ry">void QPainter::drawEllipse(const  &amp;<em>center</em>, int <em>rx</em>, int <em>ry</em>)</span><a href="#void-qpainter-drawellipse-const-qpoint-amp-center-int-rx-int-ry" class="header-anchor">#</a></h3><p>这是一个重载函数。</p>
<p>绘制位于<em>center</em>的椭圆，半径为<em>rx</em>和<em>ry</em>。</p>
<h3><span id="void-qpainter-drawglyphrun-const-qpointf-amp-position-const-qglyphrun-amp-glyphs">void QPainter::drawGlyphRun(const  &amp;<em>position</em>, const  &amp;<em>glyphs</em>)</span><a href="#void-qpainter-drawglyphrun-const-qpointf-amp-position-const-qglyphrun-amp-glyphs" class="header-anchor">#</a></h3><p>在<em>position</em>绘制由<em>glyphs</em>代表的字形。<em>position</em>给出了这串字形的基线边缘。这些字形将从<em>glyphs</em>上选择的字体中获取，并在<em>glyphs</em>中的位置给定的偏移量上获取。</p>
<p><strong>See also</strong> <a href="qt-6/qglyphrun.html#setRawFont">QGlyphRun::setRawFont</a>(), <a href="qt-6/qglyphrun.html#setPositions">QGlyphRun::setPositions</a>(), and <a href="qt-6/qglyphrun.html#setGlyphIndexes">QGlyphRun::setGlyphIndexes</a>().</p>
<h3><span id="void-qpainter-drawimage-const-qrectf-amp-target-const-qimage-amp-image-const-qrectf-amp-source-qt-imageconversionflags-flags-qt-autocolor">void QPainter::drawImage(const  &amp;<em>target</em>, const  &amp;<em>image</em>, const  &amp;<em>source</em>,  <em>flags</em> = Qt::AutoColor)</span><a href="#void-qpainter-drawimage-const-qrectf-amp-target-const-qimage-amp-image-const-qrectf-amp-source-qt-imageconversionflags-flags-qt-autocolor" class="header-anchor">#</a></h3><p>将给定的<em>image</em>的矩形部分<em>source</em>绘制到绘画设备的<em>target</em>矩形中。</p>
<p><strong>注意：</strong>如果图像和矩形的大小不一致，图像将被缩放以适应矩形。</p>
<p>**注意:**参见<a href="#drawing-high-resolution-versions-of-pixmaps-and-images">绘制高分辨率的像素图和图像</a>，了解这如何受<a href="qt-6/qimage.html#devicePixelRatio">QImage::devicePixelRatio</a>()影响。</p>
<p>如果图像需要修改以适应较低的分辨率结果（例如从32位转换到8位），使用<em>flags</em> 来指定你希望如何发生。</p>
<div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-function">QRectF <span class="hljs-title">target</span><span class="hljs-params">(<span class="hljs-number">10.0</span>, <span class="hljs-number">20.0</span>, <span class="hljs-number">80.0</span>, <span class="hljs-number">60.0</span>)</span></span>; 
<span class="hljs-function">QRectF <span class="hljs-title">source</span><span class="hljs-params">(<span class="hljs-number">0.0</span>, <span class="hljs-number">0.0</span>, <span class="hljs-number">70.0</span>, <span class="hljs-number">40.0</span>)</span></span>; 
<span class="hljs-function">QImage <span class="hljs-title">image</span><span class="hljs-params">(<span class="hljs-string">":/images/myImage.png"</span>)</span></span>; 
<span class="hljs-function">QPainter <span class="hljs-title">painter</span><span class="hljs-params">(<span class="hljs-keyword">this</span>)</span></span>; 
painter.<span class="hljs-built_in">drawImage</span>(target, image, source);</code></pre></div>

<p><strong>See also</strong> <a href="#drawPixmap">drawPixmap</a>() and <a href="qt-6/qimage.html#devicePixelRatio">QImage::devicePixelRatio</a>().</p>
<h3><span id="void-qpainter-drawimage-const-qrect-amp-target-const-qimage-amp-image-const-qrect-amp-source-qt-imageconversionflags-flags-qt-autocolor">void QPainter::drawImage(const  &amp;<em>target</em>, const  &amp;<em>image</em>, const  &amp;<em>source</em>,  <em>flags</em> = Qt::AutoColor)</span><a href="#void-qpainter-drawimage-const-qrect-amp-target-const-qimage-amp-image-const-qrect-amp-source-qt-imageconversionflags-flags-qt-autocolor" class="header-anchor">#</a></h3><p>这是一个重载函数。</p>
<p>将给定的<em>image</em>的矩形部分<em>source</em>绘制到绘画设备的<em>target</em>矩形中。</p>
<p><strong>注意：</strong>如果图像和矩形的大小不一致，图像将被缩放以适应矩形。</p>
<h3><span id="void-qpainter-drawimage-const-qpointf-amp-point-const-qimage-amp-image-const-qrectf-amp-source-qt-imageconversionflags-flags-qt-autocolor">void QPainter::drawImage(const  &amp;<em>point</em>, const  &amp;<em>image</em>, const  &amp;<em>source</em>,  <em>flags</em> = Qt::AutoColor)</span><a href="#void-qpainter-drawimage-const-qpointf-amp-point-const-qimage-amp-image-const-qrectf-amp-source-qt-imageconversionflags-flags-qt-autocolor" class="header-anchor">#</a></h3><p>这是一个重载函数。</p>
<p>绘制给定<em>image</em>的矩形部分<em>source</em>，其原点在给定的<em>point</em>。</p>
<h3><span id="void-qpainter-drawimage-const-qpoint-amp-point-const-qimage-amp-image-const-qrect-amp-source-qt-imageconversionflags-flags-qt-autocolor">void QPainter::drawImage(const  &amp;<em>point</em>, const  &amp;<em>image</em>, const  &amp;<em>source</em>,  <em>flags</em> = Qt::AutoColor)</span><a href="#void-qpainter-drawimage-const-qpoint-amp-point-const-qimage-amp-image-const-qrect-amp-source-qt-imageconversionflags-flags-qt-autocolor" class="header-anchor">#</a></h3><p>这是一个重载函数。</p>
<p>绘制给定<em>image</em>的矩形部分<em>source</em>，其原点在给定的<em>point</em>。</p>
<h3><span id="void-qpainter-drawimage-const-qrectf-amp-rectangle-const-qimage-amp-image">void QPainter::drawImage(const  &amp;<em>rectangle</em>, const  &amp;<em>image</em>)</span><a href="#void-qpainter-drawimage-const-qrectf-amp-rectangle-const-qimage-amp-image" class="header-anchor">#</a></h3><p>这是一个重载函数。</p>
<p>将给定的<em>image</em>绘制到给定的<em>rectangle</em>中。</p>
<p><strong>注意：</strong>如果图像和矩形尺寸不一致，图像将被缩放以适应矩形。</p>
<h3><span id="void-qpainter-drawimage-const-qrect-amp-rectangle-const-qimage-amp-image">void QPainter::drawImage(const  &amp;<em>rectangle</em>, const  &amp;<em>image</em>)</span><a href="#void-qpainter-drawimage-const-qrect-amp-rectangle-const-qimage-amp-image" class="header-anchor">#</a></h3><p>这是一个重载函数。</p>
<p>将给定的<em>image</em>绘制到给定的<em>rectangle</em>中。</p>
<p><strong>注意：</strong>如果图像和矩形尺寸不一致，图像将被缩放以适应矩形。</p>
<h3><span id="void-qpainter-drawimage-const-qpointf-amp-point-const-qimage-amp-image">void QPainter::drawImage(const  &amp;<em>point</em>, const  &amp;<em>image</em>)</span><a href="#void-qpainter-drawimage-const-qpointf-amp-point-const-qimage-amp-image" class="header-anchor">#</a></h3><p>这是一个重载函数。</p>
<p>在给定的<em>point</em>上绘制给定的<em>image</em>。</p>
<h3><span id="void-qpainter-drawimage-const-qpoint-amp-point-const-qimage-amp-image">void QPainter::drawImage(const  &amp;<em>point</em>, const  &amp;<em>image</em>)</span><a href="#void-qpainter-drawimage-const-qpoint-amp-point-const-qimage-amp-image" class="header-anchor">#</a></h3><p>这是一个重载函数。</p>
<p>在给定的<em>point</em>上绘制给定的<em>image</em>。</p>
<h3><span id="void-qpainter-drawimage-int-x-int-y-const-qimage-amp-image-int-sx-0-int-sy-0-int-sw-1-int-sh-1-qt-imageconversionflags-flags-qt-autocolor">void QPainter::drawImage(int <em>x</em>, int <em>y</em>, const  &amp;<em>image</em>, int <em>sx</em> = 0, int <em>sy</em> = 0, int <em>sw</em> = -1, int <em>sh</em> = -1,  <em>flags</em> = Qt::AutoColor)</span><a href="#void-qpainter-drawimage-int-x-int-y-const-qimage-amp-image-int-sx-0-int-sy-0-int-sw-1-int-sh-1-qt-imageconversionflags-flags-qt-autocolor" class="header-anchor">#</a></h3><p>这是一个重载函数。</p>
<p>在(<em>x</em>, <em>y</em>)处绘制图像，将<em>image</em>的一部分复制到绘图设备中。</p>
<p>(<em>x</em>, <em>y</em>)指定要画到的绘画设备的左上角的点。(<em>sx</em>, <em>sy</em>) 指定要绘制的<em>image</em>中的左上角。默认是（0，0）。</p>
<p>(<em>sw</em>, <em>sh</em>) 指定要绘制的图像的大小。默认情况下，（0，0）（和负数）意味着一直到图像的右下方。</p>
<h3><span id="void-qpainter-drawline-const-qlinef-amp-line">void QPainter::drawLine(const  &amp;<em>line</em>)</span><a href="#void-qpainter-drawline-const-qlinef-amp-line" class="header-anchor">#</a></h3><p>绘制一条由<em>line</em>定义的线。</p>
<table>
<thead>
<tr>
<th><img src="https://doc.qt.io/qt-6/images/qpainter-line.png" srcset="/img/loading.gif" lazyload alt="img"></th>
<th><code>QLineF line(10.0, 80.0, 90.0, 20.0); QPainter(this); painter.drawLine(line);</code></th>
</tr>
</thead>
<tbody><tr>
<td></td>
<td></td>
</tr>
</tbody></table>
<p><strong>See also</strong> <a href="#drawLines">drawLines</a>(), <a href="#drawPolyline">drawPolyline</a>(), and <a href="qt-6/coordsys.html">Coordinate System</a>.</p>
<h3><span id="void-qpainter-drawline-const-qline-amp-line">void QPainter::drawLine(const  &amp;<em>line</em>)</span><a href="#void-qpainter-drawline-const-qline-amp-line" class="header-anchor">#</a></h3><p>这是一个重载函数。</p>
<p>绘制一条由<em>line</em>定义的线。</p>
<h3><span id="void-qpainter-drawline-int-x1-int-y1-int-x2-int-y2">void QPainter::drawLine(int <em>x1</em>, int <em>y1</em>, int <em>x2</em>, int <em>y2</em>)</span><a href="#void-qpainter-drawline-int-x1-int-y1-int-x2-int-y2" class="header-anchor">#</a></h3><p>这是一个重载函数。</p>
<p>Draws a line from (<em>x1</em>, <em>y1</em>) to (<em>x2</em>, <em>y2</em>).</p>
<h3><span id="void-qpainter-drawline-const-qpoint-amp-p1-const-qpoint-amp-p2">void QPainter::drawLine(const  &amp;<em>p1</em>, const  &amp;<em>p2</em>)</span><a href="#void-qpainter-drawline-const-qpoint-amp-p1-const-qpoint-amp-p2" class="header-anchor">#</a></h3><p>这是一个重载函数。</p>
<p>从<em>p1</em>到<em>p2</em>画一条线。</p>
<h3><span id="void-qpainter-drawline-const-qpointf-amp-p1-const-qpointf-amp-p2">void QPainter::drawLine(const  &amp;<em>p1</em>, const  &amp;<em>p2</em>)</span><a href="#void-qpainter-drawline-const-qpointf-amp-p1-const-qpointf-amp-p2" class="header-anchor">#</a></h3><p>这是一个重载函数。</p>
<p>从<em>p1</em>到<em>p2</em>画一条线。</p>
<h3><span id="void-qpainter-drawlines-const-qlinef-lines-int-linecount">void QPainter::drawLines(const  *<em>lines</em>, int <em>lineCount</em>)</span><a href="#void-qpainter-drawlines-const-qlinef-lines-int-linecount" class="header-anchor">#</a></h3><p>使用当前的笔绘制数组中<em>lineCount</em>的第一行。</p>
<p><strong>See also</strong> <a href="#drawLine">drawLine</a>() and <a href="#drawPolyline">drawPolyline</a>().</p>
<h3><span id="void-qpainter-drawlines-const-qlist-lt-qlinef-gt-amp-lines">void QPainter::drawLines(const &lt;&gt; &amp;<em>lines</em>)</span><a href="#void-qpainter-drawlines-const-qlist-lt-qlinef-gt-amp-lines" class="header-anchor">#</a></h3><p>这是一个重载函数。</p>
<p>使用当前的笔和画笔绘制由列表<em>lines</em>定义的线条集。</p>
<h3><span id="void-qpainter-drawlines-const-qpointf-pointpairs-int-linecount">void QPainter::drawLines(const  *<em>pointPairs</em>, int <em>lineCount</em>)</span><a href="#void-qpainter-drawlines-const-qpointf-pointpairs-int-linecount" class="header-anchor">#</a></h3><p>这是一个重载函数。</p>
<p>使用当前的笔绘制数组<em>pointPairs</em>中的第一个<em>lineCount</em>线条。这些线被指定为成对的点，所以<em>pointPairs</em>中的条目数必须至少是*lineCount**2。</p>
<h3><span id="void-qpainter-drawlines-const-qlist-lt-qpointf-gt-amp-pointpairs">void QPainter::drawLines(const &lt;&gt; &amp;<em>pointPairs</em>)</span><a href="#void-qpainter-drawlines-const-qlist-lt-qpointf-gt-amp-pointpairs" class="header-anchor">#</a></h3><p>这是一个重载函数。</p>
<p>使用当前的笔为向量<em>pointPairs</em>中的每一对点画一条线。如果数组中的点是奇数，最后一个点将被忽略。</p>
<h3><span id="void-qpainter-drawlines-const-qline-lines-int-linecount">void QPainter::drawLines(const  *<em>lines</em>, int <em>lineCount</em>)</span><a href="#void-qpainter-drawlines-const-qline-lines-int-linecount" class="header-anchor">#</a></h3><p>这是一个重载函数。</p>
<p>使用当前的笔绘制数组中<em>lineCount</em>的第一行。</p>
<h3><span id="void-qpainter-drawlines-const-qlist-lt-qline-gt-amp-lines">void QPainter::drawLines(const &lt;&gt; &amp;<em>lines</em>)</span><a href="#void-qpainter-drawlines-const-qlist-lt-qline-gt-amp-lines" class="header-anchor">#</a></h3><p>这是一个重载函数。</p>
<p>使用当前的笔和画笔绘制由列表<em>lines</em>定义的线条集。</p>
<h3><span id="void-qpainter-drawlines-const-qpoint-pointpairs-int-linecount">void QPainter::drawLines(const  *<em>pointPairs</em>, int <em>lineCount</em>)</span><a href="#void-qpainter-drawlines-const-qpoint-pointpairs-int-linecount" class="header-anchor">#</a></h3><p>这是一个重载函数。</p>
<p>使用当前笔在数组 <em>point Pairs</em> 中绘制第一条 <em>line Count</em> 行。</p>
<h3><span id="void-qpainter-drawlines-const-qlist-lt-qpoint-gt-amp-pointpairs">void QPainter::drawLines(const &lt;&gt; &amp;<em>pointPairs</em>)</span><a href="#void-qpainter-drawlines-const-qlist-lt-qpoint-gt-amp-pointpairs" class="header-anchor">#</a></h3><p>这是一个重载函数。</p>
<p>使用当前的笔为向量<em>pointPairs</em>中的每一对点绘制一条线。</p>
<h3><span id="void-qpainter-drawpath-const-qpainterpath-amp-path">void QPainter::drawPath(const  &amp;<em>path</em>)</span><a href="#void-qpainter-drawpath-const-qpainterpath-amp-path" class="header-anchor">#</a></h3><p>绘制给定的画家<em>path</em>，用当前的笔画出轮廓，用当前的画笔画出填充。</p>
<table>
<thead>
<tr>
<th><img src="https://doc.qt.io/qt-6/images/qpainter-path.png" srcset="/img/loading.gif" lazyload alt="img" style="zoom:200%;"><img src="https://doc.qt.io/qt-6/images/qpainter-pie.png" srcset="/img/loading.gif" lazyload alt="img"></th>
<th><code>QPainterPath path; path.moveTo(20, 80); path.lineTo(20, 30); path.cubicTo(80, 0, 50, 50, 80, 80); QPainter painter(this); painter.drawPath(path);</code></th>
</tr>
</thead>
<tbody><tr>
<td></td>
<td></td>
</tr>
</tbody></table>
<p><strong>See also</strong> <a href="qt-6/qtwidgets-painting-painterpaths-example.html">the Painter Paths example</a> and <a href="qt-6/qtwidgets-painting-deform-example.html">the Vector Deformation example</a>.</p>
<h3><span id="void-qpainter-drawpicture-const-qpointf-amp-point-const-qpicture-amp-picture">void QPainter::drawPicture(const  &amp;<em>point</em>, const  &amp;<em>picture</em>)</span><a href="#void-qpainter-drawpicture-const-qpointf-amp-point-const-qpicture-amp-picture" class="header-anchor">#</a></h3><p>在给定的point上重放给定的<em>picture</em> 。</p>
<p><a href="qt-6/qpicture.html">QPicture</a>类是一个记录和重放<a href>QPainter</a>命令的绘画设备。一张图片以独立于平台的格式将绘制者的命令序列化到一个IO设备上。所有可以在widget或pixmap上绘制的东西也可以存储在图片中。</p>
<p>当调用<em>point</em> = <a href="qt-6/qpointf.html">QPointF</a>(0, 0)时，这个函数的作用与<a href="qt-6/qpicture.html#play">QPicture::play</a>()完全一样。</p>
<p><strong>注意：</strong>画师的状态被这个函数保留了。</p>
<div class="code-wrapper"><pre><code class="hljs c++">QPicture picture; 
<span class="hljs-function">QPointF <span class="hljs-title">point</span><span class="hljs-params">(<span class="hljs-number">10.0</span>, <span class="hljs-number">20.0</span>)</span></span>; 
picture.<span class="hljs-built_in">load</span>(<span class="hljs-string">"drawing.pic"</span>); 
<span class="hljs-function">QPainter <span class="hljs-title">painter</span><span class="hljs-params">(<span class="hljs-keyword">this</span>)</span></span>; 
painter.<span class="hljs-built_in">drawPicture</span>(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, picture);</code></pre></div>

<p><strong>See also</strong> <a href="qt-6/qpicture.html#play">QPicture::play</a>().</p>
<h3><span id="void-qpainter-drawpicture-int-x-int-y-const-qpicture-amp-picture">void QPainter::drawPicture(int <em>x</em>, int <em>y</em>, const  &amp;<em>picture</em>)</span><a href="#void-qpainter-drawpicture-int-x-int-y-const-qpicture-amp-picture" class="header-anchor">#</a></h3><p>这是一个重载函数。</p>
<p>在点（<em>x</em>，<em>y</em>）处绘制给定的<em>picture</em>。</p>
<h3><span id="void-qpainter-drawpicture-const-qpoint-amp-point-const-qpicture-amp-picture">void QPainter::drawPicture(const  &amp;<em>point</em>, const  &amp;<em>picture</em>)</span><a href="#void-qpainter-drawpicture-const-qpoint-amp-point-const-qpicture-amp-picture" class="header-anchor">#</a></h3><p>这是一个重载函数。</p>
<p>在给定的<em>point</em>重放给定的<em>picture</em>。</p>
<h3><span id="void-qpainter-drawpie-const-qrectf-amp-rectangle-int-startangle-int-spanangle">void QPainter::drawPie(const  &amp;<em>rectangle</em>, int <em>startAngle</em>, int <em>spanAngle</em>)</span><a href="#void-qpainter-drawpie-const-qrectf-amp-rectangle-int-startangle-int-spanangle" class="header-anchor">#</a></h3><p>绘制一个由给定的<em>rectangle</em>、<em>startAngle</em>和*spanAngle定义的饼。</p>
<p>饼是用当前的<a href="#brush">画笔</a>()填充的。</p>
<p>startAngle和spanAngle必须以1/16度为单位指定，即一个完整的圆等于5760（16*360）。角度的正值意味着逆时针，而负值意味着顺时针方向。零度是在3点钟的位置。</p>
<table>
<thead>
<tr>
<th><img src="https://doc.qt.io/qt-6/images/qpainter-pie.png" srcset="/img/loading.gif" lazyload alt="img"></th>
<th><code>QRectF rectangle(10.0, 20.0, 80.0, 60.0); int startAngle = 30 * 16; int spanAngle = 120 * 16; QPainter painter(this); painter.drawPie(rectangle, startAngle, spanAngle);</code></th>
</tr>
</thead>
<tbody><tr>
<td></td>
<td></td>
</tr>
</tbody></table>
<p><strong>See also</strong> <a href="#drawEllipse">drawEllipse</a>(), <a href="#drawChord">drawChord</a>(), and <a href="qt-6/coordsys.html">Coordinate System</a>.</p>
<h3><span id="void-qpainter-drawpie-int-x-int-y-int-width-int-height-int-startangle-int-spanangle">void QPainter::drawPie(int <em>x</em>, int <em>y</em>, int <em>width</em>, int <em>height</em>, int <em>startAngle</em>, int <em>spanAngle</em>)</span><a href="#void-qpainter-drawpie-int-x-int-y-int-width-int-height-int-startangle-int-spanangle" class="header-anchor">#</a></h3><p>这是一个重载函数。</p>
<p>以指定的<em>width</em>和<em>height</em>，以及给定的<em>startAngle</em>和<em>spanAngle</em>，绘制由矩形开始的(<em>x</em>, <em>y</em>)定义的饼图。</p>
<h3><span id="void-qpainter-drawpie-const-qrect-amp-rectangle-int-startangle-int-spanangle">void QPainter::drawPie(const  &amp;<em>rectangle</em>, int <em>startAngle</em>, int <em>spanAngle</em>)</span><a href="#void-qpainter-drawpie-const-qrect-amp-rectangle-int-startangle-int-spanangle" class="header-anchor">#</a></h3><p>这是一个重载函数。</p>
<p>绘制一个由给定的<em>rectangle</em>、<em>startAngle</em>和<em>spanAngle</em>定义的饼图·。</p>
<h3><span id="void-qpainter-drawpixmap-const-qrectf-amp-target-const-qpixmap-amp-pixmap-const-qrectf-amp-source">void QPainter::drawPixmap(const  &amp;<em>target</em>, const  &amp;<em>pixmap</em>, const  &amp;<em>source</em>)</span><a href="#void-qpainter-drawpixmap-const-qrectf-amp-target-const-qpixmap-amp-pixmap-const-qrectf-amp-source" class="header-anchor">#</a></h3><p>将给定的<em>pixmap</em>的矩形部分<em>source</em>绘制到绘画设备中给定的<em>target</em>。</p>
<p><strong>注意：</strong>如果像素图和矩形大小不一致，像素图会被缩放以适应矩形。</p>
<p>**注意:**参见<a href="#drawing-high-resolution-versions-of-pixmaps-and-images">绘制高分辨率版本的像素图和图像</a>，了解它是如何被<a href="qt-6/qpixmap.html#devicePixelRatio">QPixmap::devicePixelRatio</a>()影响。</p>
<div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-function">QRectF <span class="hljs-title">target</span><span class="hljs-params">(<span class="hljs-number">10.0</span>, <span class="hljs-number">20.0</span>, <span class="hljs-number">80.0</span>, <span class="hljs-number">60.0</span>)</span></span>; 
<span class="hljs-function">QRectF <span class="hljs-title">source</span><span class="hljs-params">(<span class="hljs-number">0.0</span>, <span class="hljs-number">0.0</span>, <span class="hljs-number">70.0</span>, <span class="hljs-number">40.0</span>)</span></span>;
<span class="hljs-function">QPixmap <span class="hljs-title">pixmap</span><span class="hljs-params">(<span class="hljs-string">":myPixmap.png"</span>)</span></span>; 
<span class="hljs-built_in">QPainter</span>(<span class="hljs-keyword">this</span>);
painter.<span class="hljs-built_in">drawPixmap</span>(target, pixmap, source);</code></pre></div>

<p>如果<em>pixmap</em>是一个<a href="qt-6/qbitmap.html">QBitmap</a>，它将使用笔的颜色 <strong>设置</strong>的位来绘制。如果 <a href="#backgroundMode">backgroundMode</a> 是 <a href="qt-6/qt.html#BGMode-enum">Qt::OpaqueMode</a> ，”未设置 “的位会使用背景笔刷的颜色绘制；如果 <a href="#backgroundMode">backgroundMode</a> 是 <a href="qt-6/qt.html#BGMode-enum">Qt::TransparentMode</a> ，<strong>未设置</strong> 的位是透明的。不支持用梯度或纹理颜色绘制位图。</p>
<p><strong>See also</strong> <a href="#drawImage">drawImage</a>() and <a href="qt-6/qpixmap.html#devicePixelRatio">QPixmap::devicePixelRatio</a>().</p>
<h3><span id="void-qpainter-drawpixmap-const-qrect-amp-target-const-qpixmap-amp-pixmap-const-qrect-amp-source">void QPainter::drawPixmap(const  &amp;<em>target</em>, const  &amp;<em>pixmap</em>, const  &amp;<em>source</em>)</span><a href="#void-qpainter-drawpixmap-const-qrect-amp-target-const-qpixmap-amp-pixmap-const-qrect-amp-source" class="header-anchor">#</a></h3><p>这是一个重载函数。</p>
<p>将给定的<em>pixmap</em>的矩形部分<em>source</em>绘制到绘画设备中给定的<em>target</em>。</p>
<p><strong>注意：</strong>如果像素图和矩形尺寸不一致，像素图将被缩放以适应矩形。</p>
<h3><span id="void-qpainter-drawpixmap-int-x-int-y-int-w-int-h-const-qpixmap-amp-pixmap-int-sx-int-sy-int-sw-int-sh">void QPainter::drawPixmap(int <em>x</em>, int <em>y</em>, int <em>w</em>, int <em>h</em>, const  &amp;<em>pixmap</em>, int <em>sx</em>, int <em>sy</em>, int <em>sw</em>, int <em>sh</em>)</span><a href="#void-qpainter-drawpixmap-int-x-int-y-int-w-int-h-const-qpixmap-amp-pixmap-int-sx-int-sy-int-sw-int-sh" class="header-anchor">#</a></h3><p>这是一个重载函数。</p>
<p>在(<em>x</em>, <em>y</em>)点绘制给定<em>pixmap</em>的原点(<em>sx</em>, <em>sy</em>)、宽度<em>sw</em>和高度<em>sh</em>的矩形部分，宽度为<em>w</em>，高度为<em>h</em>。如果sw或sh等于0，则使用像素图的宽度/高度，并通过偏移量sx/sy调整。</p>
<h3><span id="void-qpainter-drawpixmap-int-x-int-y-const-qpixmap-amp-pixmap-int-sx-int-sy-int-sw-int-sh">void QPainter::drawPixmap(int <em>x</em>, int <em>y</em>, const  &amp;<em>pixmap</em>, int <em>sx</em>, int <em>sy</em>, int <em>sw</em>, int <em>sh</em>)</span><a href="#void-qpainter-drawpixmap-int-x-int-y-const-qpixmap-amp-pixmap-int-sx-int-sy-int-sw-int-sh" class="header-anchor">#</a></h3><p>这是一个重载函数。</p>
<p>在(<em>x</em>, <em>y</em>)处绘制一个像素图，方法是将给定的<em>pixmap</em>的一部分复制到绘图设备中。</p>
<p>(<em>x</em>, <em>y</em>)指定要画到的绘画设备的左上角的点。(<em>sx</em>, <em>sy</em>) 指定要绘制的<em>pixmap</em>的左上角。默认为（0，0）。</p>
<p>(<em>sw</em>, <em>sh</em>) 指定要绘制的像素图的大小。默认情况下，(0, 0)（和负数）意味着一直到像素图的右下方。</p>
<h3><span id="void-qpainter-drawpixmap-const-qpointf-amp-point-const-qpixmap-amp-pixmap-const-qrectf-amp-source">void QPainter::drawPixmap(const  &amp;<em>point</em>, const  &amp;<em>pixmap</em>, const  &amp;<em>source</em>)</span><a href="#void-qpainter-drawpixmap-const-qpointf-amp-point-const-qpixmap-amp-pixmap-const-qrectf-amp-source" class="header-anchor">#</a></h3><p>这是一个重载函数。</p>
<p>绘制给定<em>pixmap</em>的矩形部分<em>source</em>，其原点在给定的<em>point</em>。</p>
<h3><span id="void-qpainter-drawpixmap-const-qpoint-amp-point-const-qpixmap-amp-pixmap-const-qrect-amp-source">void QPainter::drawPixmap(const  &amp;<em>point</em>, const  &amp;<em>pixmap</em>, const  &amp;<em>source</em>)</span><a href="#void-qpainter-drawpixmap-const-qpoint-amp-point-const-qpixmap-amp-pixmap-const-qrect-amp-source" class="header-anchor">#</a></h3><p>这是一个重载函数。</p>
<p>绘制给定<em>pixmap</em>的矩形部分<em>source</em>，其原点在给定的<em>point</em>。</p>
<h3><span id="void-qpainter-drawpixmap-const-qpointf-amp-point-const-qpixmap-amp-pixmap">void QPainter::drawPixmap(const  &amp;<em>point</em>, const  &amp;<em>pixmap</em>)</span><a href="#void-qpainter-drawpixmap-const-qpointf-amp-point-const-qpixmap-amp-pixmap" class="header-anchor">#</a></h3><p>这是一个重载函数。</p>
<p>绘制给定的<em>pixmap</em>，其原点在给定的<em>point</em>。</p>
<h3><span id="void-qpainter-drawpixmap-const-qpoint-amp-point-const-qpixmap-amp-pixmap">void QPainter::drawPixmap(const  &amp;<em>point</em>, const  &amp;<em>pixmap</em>)</span><a href="#void-qpainter-drawpixmap-const-qpoint-amp-point-const-qpixmap-amp-pixmap" class="header-anchor">#</a></h3><p>这是一个重载函数。</p>
<p>绘制给定的<em>pixmap</em>，其原点在给定的<em>point</em>。</p>
<h3><span id="void-qpainter-drawpixmap-int-x-int-y-const-qpixmap-amp-pixmap">void QPainter::drawPixmap(int <em>x</em>, int <em>y</em>, const  &amp;<em>pixmap</em>)</span><a href="#void-qpainter-drawpixmap-int-x-int-y-const-qpixmap-amp-pixmap" class="header-anchor">#</a></h3><p>这是一个重载函数。</p>
<p>在位置（<em>x</em>，<em>y</em>）上绘制给定的<em>pixmap</em>。</p>
<h3><span id="void-qpainter-drawpixmap-const-qrect-amp-rectangle-const-qpixmap-amp-pixmap">void QPainter::drawPixmap(const  &amp;<em>rectangle</em>, const  &amp;<em>pixmap</em>)</span><a href="#void-qpainter-drawpixmap-const-qrect-amp-rectangle-const-qpixmap-amp-pixmap" class="header-anchor">#</a></h3><p>这是一个重载函数。</p>
<p>将给定的<em>pixmap</em>绘制到给定的<em>rectangle</em>中。</p>
<p><strong>注意：</strong>如果像素图和矩形的大小不一致，像素图将被缩放以适应矩形。</p>
<h3><span id="void-qpainter-drawpixmap-int-x-int-y-int-width-int-height-const-qpixmap-amp-pixmap">void QPainter::drawPixmap(int <em>x</em>, int <em>y</em>, int <em>width</em>, int <em>height</em>, const  &amp;<em>pixmap</em>)</span><a href="#void-qpainter-drawpixmap-int-x-int-y-int-width-int-height-const-qpixmap-amp-pixmap" class="header-anchor">#</a></h3><p>这是一个重载函数。</p>
<p>将<em>pixmap</em>绘制到位置(<em>x</em>, <em>y</em>)的矩形中，并给定<em>width</em>和<em>height</em>。</p>
<h3><span id="void-qpainter-drawpixmapfragments-const-qpainter-pixmapfragment-fragments-int-fragmentcount-const-qpixmap-amp-pixmap-qpainter-pixmapfragmenthints-hints-pixmapfragmenthints">void QPainter::drawPixmapFragments(const  *<em>fragments</em>, int <em>fragmentCount</em>, const  &amp;<em>pixmap</em>,  <em>hints</em> = PixmapFragmentHints())</span><a href="#void-qpainter-drawpixmapfragments-const-qpainter-pixmapfragment-fragments-int-fragmentcount-const-qpixmap-amp-pixmap-qpainter-pixmapfragmenthints-hints-pixmapfragmenthints" class="header-anchor">#</a></h3><p>这个函数用来在多个位置以不同的比例、旋转和不透明度绘制<em>pixmap</em>或<em>pixmap</em>的一个子矩形。<em>fragments</em>是一个<em>fragmentCount</em>元素的数组，指定用于绘制每个像素图片段的参数。参数<em>hints</em>可以用来传递绘制提示。</p>
<p>这个函数可能比多次调用<a href="#drawPixmap">drawPixmap</a>()要快，因为后端可以优化状态变化。</p>
<p><strong>See also</strong> <a href="qt-6/qpainter-pixmapfragment.html">QPainter::PixmapFragment</a> and <a href="#PixmapFragmentHint-enum">QPainter::PixmapFragmentHint</a>.</p>
<h3><span id="void-qpainter-drawpoint-const-qpointf-amp-position">void QPainter::drawPoint(const  &amp;<em>position</em>)</span><a href="#void-qpainter-drawpoint-const-qpointf-amp-position" class="header-anchor">#</a></h3><p>使用当前笔的颜色在给定的<em>position</em>画一个单点。</p>
<p><strong>See also</strong> <a href="qt-6/coordsys.html">Coordinate System</a>.</p>
<h3><span id="void-qpainter-drawpoint-const-qpoint-amp-position">void QPainter::drawPoint(const  &amp;<em>position</em>)</span><a href="#void-qpainter-drawpoint-const-qpoint-amp-position" class="header-anchor">#</a></h3><p>这是一个重载函数。</p>
<p>使用当前笔的颜色在给定的<em>position</em>画一个单点。</p>
<h3><span id="void-qpainter-drawpoint-int-x-int-y">void QPainter::drawPoint(int <em>x</em>, int <em>y</em>)</span><a href="#void-qpainter-drawpoint-int-x-int-y" class="header-anchor">#</a></h3><p>这是一个重载函数。</p>
<p>在位置（<em>x</em>，<em>y</em>）上画一个单点。</p>
<h3><span id="void-qpainter-drawpoints-const-qpointf-points-int-pointcount">void QPainter::drawPoints(const  *<em>points</em>, int <em>pointCount</em>)</span><a href="#void-qpainter-drawpoints-const-qpointf-points-int-pointcount" class="header-anchor">#</a></h3><p>使用当前笔的颜色绘制数组<em>points</em>中的<em>pointCount</em>的第一个点。</p>
<p><strong>See also</strong> <a href="qt-6/coordsys.html">Coordinate System</a>.</p>
<h3><span id="void-qpainter-drawpoints-const-qpolygonf-amp-points">void QPainter::drawPoints(const  &amp;<em>points</em>)</span><a href="#void-qpainter-drawpoints-const-qpolygonf-amp-points" class="header-anchor">#</a></h3><p>这是一个重载函数。</p>
<p>绘制矢量中的点 <em>points</em>。</p>
<h3><span id="void-qpainter-drawpoints-const-qpoint-points-int-pointcount">void QPainter::drawPoints(const  *<em>points</em>, int <em>pointCount</em>)</span><a href="#void-qpainter-drawpoints-const-qpoint-points-int-pointcount" class="header-anchor">#</a></h3><p>这是一个重载函数。</p>
<p>使用当前笔的颜色绘制数组 <em>points</em> 中的第一个 <em>pointCount</em> 点。</p>
<h3><span id="void-qpainter-drawpoints-const-qpolygon-amp-points">void QPainter::drawPoints(const  &amp;<em>points</em>)</span><a href="#void-qpainter-drawpoints-const-qpolygon-amp-points" class="header-anchor">#</a></h3><p>这是一个重载函数。</p>
<p>绘制矢量中的点 <em>points</em>。</p>
<h3><span id="void-qpainter-drawpolygon-const-qpointf-points-int-pointcount-qt-fillrule-fillrule-qt-oddevenfill">void QPainter::drawPolygon(const  *<em>points</em>, int <em>pointCount</em>,  <em>fillRule</em> = Qt::OddEvenFill)</span><a href="#void-qpainter-drawpolygon-const-qpointf-points-int-pointcount-qt-fillrule-fillrule-qt-oddevenfill" class="header-anchor">#</a></h3><p>使用当前笔和画笔绘制由数组 <em>points</em> 中的第一个 <em>pointCount</em> 点定义的多边形。</p>
<table>
<thead>
<tr>
<th><img src="https://doc.qt.io/qt-6/images/qpainter-polygon.png" srcset="/img/loading.gif" lazyload alt="img" style="zoom:200%;"></th>
<th><code>static const QPointF points[4] = {    QPointF(10.0, 80.0),    QPointF(20.0, 10.0),    QPointF(80.0, 30.0),    QPointF(90.0, 70.0) }; QPainter painter(this); painter.drawPolygon(points, 4);</code></th>
</tr>
</thead>
<tbody><tr>
<td></td>
<td></td>
</tr>
</tbody></table>
<p>第一个点隐含地连接到最后一个点，并且多边形用当前的<a href="#brush">brush</a>()填充。</p>
<p>如果<em>fillRule</em>是<a href="qt-6/qt.html#FillRule-enum">Qt::WindingFill</a>，多边形将使用缠绕式填充算法进行填充。如果<em>fillRule</em>是<a href="qt-6/qt.html#FillRule-enum">Qt::OddEvenFill</a>，多边形将使用奇数-偶数填充算法填充。請參閱 <a href="qt-6/qt.html#FillRule-enum">Qt::FillRule</a> 以了解這些填充規則的更詳細描述。</p>
<p><strong>See also</strong> <a href="#drawConvexPolygon">drawConvexPolygon</a>(), <a href="#drawPolyline">drawPolyline</a>(), and <a href="qt-6/coordsys.html">Coordinate System</a>.</p>
<h3><span id="void-qpainter-drawpolygon-const-qpolygonf-amp-points-qt-fillrule-fillrule-qt-oddevenfill">void QPainter::drawPolygon(const  &amp;<em>points</em>,  <em>fillRule</em> = Qt::OddEvenFill)</span><a href="#void-qpainter-drawpolygon-const-qpolygonf-amp-points-qt-fillrule-fillrule-qt-oddevenfill" class="header-anchor">#</a></h3><p>这是一个重载函数。</p>
<p>使用填充规则<em>fillRule</em>，绘制由给定的<em>points</em>定义的多边形。</p>
<h3><span id="void-qpainter-drawpolygon-const-qpoint-points-int-pointcount-qt-fillrule-fillrule-qt-oddevenfill">void QPainter::drawPolygon(const  *<em>points</em>, int <em>pointCount</em>,  <em>fillRule</em> = Qt::OddEvenFill)</span><a href="#void-qpainter-drawpolygon-const-qpoint-points-int-pointcount-qt-fillrule-fillrule-qt-oddevenfill" class="header-anchor">#</a></h3><p>这是一个重载函数。</p>
<p>绘制由数组<em>points</em>中第一个<em>pointCount</em>点定义的多边形。</p>
<h3><span id="void-qpainter-drawpolygon-const-qpolygon-amp-points-qt-fillrule-fillrule-qt-oddevenfill">void QPainter::drawPolygon(const  &amp;<em>points</em>,  <em>fillRule</em> = Qt::OddEvenFill)</span><a href="#void-qpainter-drawpolygon-const-qpolygon-amp-points-qt-fillrule-fillrule-qt-oddevenfill" class="header-anchor">#</a></h3><p>这是一个重载函数。</p>
<p>使用填充规则<em>fillRule</em>，绘制由给定的<em>points</em>定义的多边形。</p>
<h3><span id="void-qpainter-drawpolyline-const-qpointf-points-int-pointcount">void QPainter::drawPolyline(const  *<em>points</em>, int <em>pointCount</em>)</span><a href="#void-qpainter-drawpolyline-const-qpointf-points-int-pointcount" class="header-anchor">#</a></h3><p>使用当前笔在<em>points</em>中绘制由第一个<em>pointCount</em>点定义的多段线。</p>
<p>注意，与<a href="#drawPolygon">drawPolygon</a>()函数不同的是，最后一个点<em>不</em>与第一个点相连，也不填充多段线。</p>
<div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-type">static</span> <span class="hljs-type">const</span> QPointF points[<span class="hljs-number">3</span>] = {    
    <span class="hljs-built_in">QPointF</span>(<span class="hljs-number">10.0</span>, <span class="hljs-number">80.0</span>),    
    <span class="hljs-built_in">QPointF</span>(<span class="hljs-number">20.0</span>, <span class="hljs-number">10.0</span>),    
    <span class="hljs-built_in">QPointF</span>(<span class="hljs-number">80.0</span>, <span class="hljs-number">30.0</span>), 
}; 
<span class="hljs-function">QPainter <span class="hljs-title">painter</span><span class="hljs-params">(<span class="hljs-keyword">this</span>)</span></span>; 
painter.<span class="hljs-built_in">drawPolyline</span>(points, <span class="hljs-number">3</span>);</code></pre></div>

<p><strong>See also</strong> <a href="#drawLines">drawLines</a>(), <a href="#drawPolygon">drawPolygon</a>(), and <a href="qt-6/coordsys.html">Coordinate System</a>.</p>
<h3><span id="void-qpainter-drawpolyline-const-qpolygonf-amp-points">void QPainter::drawPolyline(const  &amp;<em>points</em>)</span><a href="#void-qpainter-drawpolyline-const-qpolygonf-amp-points" class="header-anchor">#</a></h3><p>这是一个重载函数。</p>
<p>使用当前的笔绘制由给定的<em>points</em>定义的多段线。</p>
<h3><span id="void-qpainter-drawpolyline-const-qpoint-points-int-pointcount">void QPainter::drawPolyline(const  *<em>points</em>, int <em>pointCount</em>)</span><a href="#void-qpainter-drawpolyline-const-qpoint-points-int-pointcount" class="header-anchor">#</a></h3><p>这是一个重载函数。</p>
<p>使用当前的笔绘制由<em>points</em>中的第一个<em>pointCount</em>点定义的多段线。</p>
<h3><span id="void-qpainter-drawpolyline-const-qpolygon-amp-points">void QPainter::drawPolyline(const  &amp;<em>points</em>)</span><a href="#void-qpainter-drawpolyline-const-qpolygon-amp-points" class="header-anchor">#</a></h3><p>这是一个重载函数。</p>
<p>用当前的笔画出由给定的<em>点</em>定义的多段线。</p>
<h3><span id="void-qpainter-drawrect-const-qrectf-amp-rectangle">void QPainter::drawRect(const  &amp;<em>rectangle</em>)</span><a href="#void-qpainter-drawrect-const-qrectf-amp-rectangle" class="header-anchor">#</a></h3><p>用当前的笔和画笔画出当前的<em>rectangle</em>。</p>
<p>填充的矩形的大小为<em>rectangle</em>.size()。描边的矩形的大小为<em>矩形</em>.size()加上笔的宽度。</p>
<table>
<thead>
<tr>
<th><img src="https://doc.qt.io/qt-6/images/qpainter-rectangle.png" srcset="/img/loading.gif" lazyload alt="img" style="zoom:200%;"></th>
<th><code>QRectF rectangle(10.0, 20.0, 80.0, 60.0); QPainter painter(this); painter.drawRect(rectangle);</code></th>
</tr>
</thead>
<tbody><tr>
<td></td>
<td></td>
</tr>
</tbody></table>
<p><strong>See also</strong> <a href="#drawRects">drawRects</a>(), <a href="#drawPolygon">drawPolygon</a>(), and <a href="qt-6/coordsys.html">Coordinate System</a>.</p>
<h3><span id="void-qpainter-drawrect-int-x-int-y-int-width-int-height">void QPainter::drawRect(int <em>x</em>, int <em>y</em>, int <em>width</em>, int <em>height</em>)</span><a href="#void-qpainter-drawrect-int-x-int-y-int-width-int-height" class="header-anchor">#</a></h3><p>这是一个重载函数。</p>
<p>绘制一个左上角在(<em>x</em>, <em>y</em>)并具有给定的<em>宽度</em>和<em>高度</em>的矩形。</p>
<h3><span id="void-qpainter-drawrect-const-qrect-amp-rectangle">void QPainter::drawRect(const  &amp;<em>rectangle</em>)</span><a href="#void-qpainter-drawrect-const-qrect-amp-rectangle" class="header-anchor">#</a></h3><p>这是一个重载函数。</p>
<p>用当前的笔和画笔画出当前的<em>rectangle</em>。</p>
<h3><span id="void-qpainter-drawrects-const-qrectf-rectangles-int-rectcount">void QPainter::drawRects(const  *<em>rectangles</em>, int <em>rectCount</em>)</span><a href="#void-qpainter-drawrects-const-qrectf-rectangles-int-rectcount" class="header-anchor">#</a></h3><p>用当前的笔和画笔绘制给定的<em>矩形</em>中的第一个<em>rectCount</em>。</p>
<p><strong>See also</strong> <a href="#drawRect">drawRect</a>().</p>
<h3><span id="void-qpainter-drawrects-const-qlist-lt-qrectf-gt-amp-rectangles">void QPainter::drawRects(const &lt;&gt; &amp;<em>rectangles</em>)</span><a href="#void-qpainter-drawrects-const-qlist-lt-qrectf-gt-amp-rectangles" class="header-anchor">#</a></h3><p>这是一个重载函数。</p>
<p>用当前的笔和画笔绘制给定的<em>矩形</em>。</p>
<h3><span id="void-qpainter-drawrects-const-qrect-rectangles-int-rectcount">void QPainter::drawRects(const  *<em>rectangles</em>, int <em>rectCount</em>)</span><a href="#void-qpainter-drawrects-const-qrect-rectangles-int-rectcount" class="header-anchor">#</a></h3><p>这是一个重载函数。</p>
<p>使用当前的笔和画笔绘制给定的<em>矩形</em>的第一个<em>rectCount</em>。</p>
<h3><span id="void-qpainter-drawrects-const-qlist-lt-qrect-gt-amp-rectangles">void QPainter::drawRects(const &lt;&gt; &amp;<em>rectangles</em>)</span><a href="#void-qpainter-drawrects-const-qlist-lt-qrect-gt-amp-rectangles" class="header-anchor">#</a></h3><p>这是一个重载函数。</p>
<p>用当前的笔和画笔绘制给定的<em>矩形</em>。</p>
<h3><span id="void-qpainter-drawroundedrect-const-qrectf-amp-rect-qreal-xradius-qreal-yradius-qt-sizemode-mode-qt-absolutesize">void QPainter::drawRoundedRect(const  &amp;<em>rect</em>,  <em>xRadius</em>,  <em>yRadius</em>,  <em>mode</em> = Qt::AbsoluteSize)</span><a href="#void-qpainter-drawroundedrect-const-qrectf-amp-rect-qreal-xradius-qreal-yradius-qt-sizemode-mode-qt-absolutesize" class="header-anchor">#</a></h3><p>用圆角画出给定的矩形<em>rect</em>。</p>
<p>参数<em>xRadius</em>和<em>yRadius</em>指定定义圆角矩形的椭圆的半径。当<em>mode</em>是<a href="qt-6/qt.html#SizeMode-enum">Qt::RelativeSize</a>时，<em>xRadius</em>和<em>yRadius</em>分别以矩形宽度和高度的一半的百分比指定，并且应该在0.0到100.0之间。</p>
<p>一个填充的矩形的大小为rect.size()。描边的矩形的大小为rect.size()加上笔的宽度。</p>
<table>
<thead>
<tr>
<th><img src="https://doc.qt.io/qt-6/images/qpainter-roundrect.png" srcset="/img/loading.gif" lazyload alt="img" style="zoom:200%;"></th>
<th><code>QRectF rectangle(10.0, 20.0, 80.0, 60.0); QPainter painter(this); painter.drawRoundedRect(rectangle, 20.0, 15.0);</code></th>
</tr>
</thead>
<tbody><tr>
<td></td>
<td></td>
</tr>
</tbody></table>
<p><strong>See also</strong> <a href="#drawRect">drawRect</a>() and <a href="qt-6/qpen.html">QPen</a>.</p>
<h3><span id="void-qpainter-drawroundedrect-int-x-int-y-int-w-int-h-qreal-xradius-qreal-yradius-qt-sizemode-mode-qt-absolutesize">void QPainter::drawRoundedRect(int <em>x</em>, int <em>y</em>, int <em>w</em>, int <em>h</em>,  <em>xRadius</em>,  <em>yRadius</em>,  <em>mode</em> = Qt::AbsoluteSize)</span><a href="#void-qpainter-drawroundedrect-int-x-int-y-int-w-int-h-qreal-xradius-qreal-yradius-qt-sizemode-mode-qt-absolutesize" class="header-anchor">#</a></h3><p>这是一个重载函数。</p>
<p>绘制给定的矩形<em>x</em>、<em>y</em>、<em>w</em>、<em>h</em>，并采用圆角。</p>
<h3><span id="void-qpainter-drawroundedrect-const-qrect-amp-rect-qreal-xradius-qreal-yradius-qt-sizemode-mode-qt-absolutesize">void QPainter::drawRoundedRect(const  &amp;<em>rect</em>,  <em>xRadius</em>,  <em>yRadius</em>,  <em>mode</em> = Qt::AbsoluteSize)</span><a href="#void-qpainter-drawroundedrect-const-qrect-amp-rect-qreal-xradius-qreal-yradius-qt-sizemode-mode-qt-absolutesize" class="header-anchor">#</a></h3><p>这是一个重载函数。</p>
<p>绘制给定的带有圆角的矩形<em>rect</em>。</p>
<h3><span id="void-qpainter-drawstatictext-const-qpointf-amp-topleftposition-const-qstatictext-amp-statictext">void QPainter::drawStaticText(const  &amp;<em>topLeftPosition</em>, const  &amp;<em>staticText</em>)</span><a href="#void-qpainter-drawstatictext-const-qpointf-amp-topleftposition-const-qstatictext-amp-statictext" class="header-anchor">#</a></h3><p>在给定的<em>topLeftPosition</em>处绘制给定的<em>staticText</em>。</p>
<p>绘制的文本将使用绘画器上设置的字体和变换。如果绘制器上设置的字体和/或变换与用于初始化<a href="qt-6/qstatictext.html">QStaticText</a>的布局不同，那么就必须重新计算布局。使用<a href="qt-6/qstatictext.html#prepare">QStaticText::prepare</a>()来初始化<em>staticText</em>的字体和变换，它将在以后被绘制。</p>
<p>如果<em>topLeftPosition</em>与<em>staticText</em>初始化时或最后一次绘制时不一样，那么在将文本翻译到新的位置时将会有一点开销。</p>
<p><strong>注意：</strong>如果画师的变换不是仿射的，那么<em>staticText</em>将使用对<a href="#drawText">drawText</a>()的常规调用来绘制，从而失去任何提高性能的可能性。</p>
<p><strong>注意：</strong> y-position被用作字体的顶部。</p>
<p><strong>See also</strong> <a href="qt-6/qstatictext.html">QStaticText</a>.</p>
<h3><span id="void-qpainter-drawstatictext-const-qpoint-amp-topleftposition-const-qstatictext-amp-statictext">void QPainter::drawStaticText(const  &amp;<em>topLeftPosition</em>, const  &amp;<em>staticText</em>)</span><a href="#void-qpainter-drawstatictext-const-qpoint-amp-topleftposition-const-qstatictext-amp-statictext" class="header-anchor">#</a></h3><p>这是一个重载函数。</p>
<p>在<em>topLeftPosition</em>处绘制<em>staticText</em>。</p>
<p><strong>注意：</strong>y位置被用作字体的顶部。</p>
<h3><span id="void-qpainter-drawstatictext-int-left-int-top-const-qstatictext-amp-statictext">void QPainter::drawStaticText(int <em>left</em>, int <em>top</em>, const  &amp;<em>staticText</em>)</span><a href="#void-qpainter-drawstatictext-int-left-int-top-const-qstatictext-amp-statictext" class="header-anchor">#</a></h3><p>这是一个重载函数。</p>
<p>在坐标<em>left</em>和<em>top</em>处绘制<em>staticText</em>。</p>
<p><strong>注意：</strong>y位置被用作字体的顶部。</p>
<h3><span id="void-qpainter-drawtext-const-qrectf-amp-rectangle-int-flags-const-qstring-amp-text-qrectf-boundingrect-nullptr">void QPainter::drawText(const  &amp;<em>rectangle</em>, int <em>flags</em>, const  &amp;<em>text</em>,  *<em>boundingRect</em> = nullptr)</span><a href="#void-qpainter-drawtext-const-qrectf-amp-rectangle-int-flags-const-qstring-amp-text-qrectf-boundingrect-nullptr" class="header-anchor">#</a></h3><p>这是一个重载函数。</p>
<p>在提供的<em>rectangle</em>内绘制给定的<em>文本。</em>rectangle<em>和对齐方式**flags</em>定义了<em>text</em>的锚。</p>
<table>
<thead>
<tr>
<th><img src="https://doc.qt.io/qt-6/images/qpainter-text.png" srcset="/img/loading.gif" lazyload alt="img"></th>
<th><code>QPainter painter(this); painter.drawText(rect, Qt::AlignCenter, tr("Qt\nProject"));</code></th>
</tr>
</thead>
<tbody><tr>
<td></td>
<td></td>
</tr>
</tbody></table>
<p>如果不为空，<em>boundingRect</em>将被设置为包围整个文本的边界矩形。例如，在下面的图片中，虚线代表函数计算出的<em>boundingRect</em>，而虚线代表<em>rectangle</em>：</p>
<table>
<thead>
<tr>
<th><img src="https://doc.qt.io/qt-6/images/qpainter-text.png" srcset="/img/loading.gif" lazyload alt="img" style="zoom:600%;"></th>
<th><code>QPainter painter(this); QFont font = painter.font(); font.setPixelSize(48); painter.setFont(font); const QRect rectangle = QRect(0, 0, 100, 50); QRect boundingRect; painter.drawText(rectangle, 0, tr("Hello"), &amp;boundingRect); QPen pen = painter.pen(); pen.setStyle(Qt::DotLine); painter.setPen(pen); painter.drawRect(boundingRect.adjusted(0, 0, -pen.width(), -pen.width())); pen.setStyle(Qt::DashLine); painter.setPen(pen); painter.drawRect(rectangle.adjusted(0, 0, -pen.width(), -pen.width()));</code></th>
</tr>
</thead>
<tbody><tr>
<td></td>
<td></td>
</tr>
</tbody></table>
<p>参数<em>flags</em>是以下标志的位数OR：</p>
<ul>
<li><a href="qt-6/qt.html#AlignmentFlag-enum">Qt::AlignLeft</a></li>
<li><a href="qt-6/qt.html#AlignmentFlag-enum">Qt::AlignRight</a></li>
<li><a href="qt-6/qt.html#AlignmentFlag-enum">Qt::AlignHCenter</a></li>
<li><a href="qt-6/qt.html#AlignmentFlag-enum">Qt::AlignJustify</a></li>
<li><a href="qt-6/qt.html#AlignmentFlag-enum">Qt::AlignTop</a></li>
<li><a href="qt-6/qt.html#AlignmentFlag-enum">Qt::AlignBottom</a></li>
<li><a href="qt-6/qt.html#AlignmentFlag-enum">Qt::AlignVCenter</a></li>
<li><a href="qt-6/qt.html#AlignmentFlag-enum">Qt::AlignCenter</a></li>
<li><a href="qt-6/qt.html#TextFlag-enum">Qt::TextDontClip</a></li>
<li><a href="qt-6/qt.html#TextFlag-enum">Qt::TextSingleLine</a></li>
<li><a href="qt-6/qt.html#TextFlag-enum">Qt::TextExpandTabs</a></li>
<li><a href="qt-6/qt.html#TextFlag-enum">Qt::TextShowMnemonic</a></li>
<li><a href="qt-6/qt.html#TextFlag-enum">Qt::TextWordWrap</a></li>
<li><a href="qt-6/qt.html#TextFlag-enum">Qt::TextIncludeTrailingSpaces</a></li>
</ul>
<p>默认情况下，<a href>QPainter</a>绘制的文本是抗锯齿的。</p>
<p><strong>注意：</strong> <em>rectangle</em> 的y坐标被用作字体的顶部。</p>
<p><strong>See also</strong> <a href="qt-6/qt.html#AlignmentFlag-enum">Qt::AlignmentFlag</a>, <a href="qt-6/qt.html#TextFlag-enum">Qt::TextFlag</a>, <a href="#boundingRect">boundingRect</a>(), and <a href="#layoutDirection">layoutDirection</a>().</p>
<h3><span id="void-qpainter-drawtext-const-qpointf-amp-position-const-qstring-amp-text">void QPainter::drawText(const  &amp;<em>position</em>, const  &amp;<em>text</em>)</span><a href="#void-qpainter-drawtext-const-qpointf-amp-position-const-qstring-amp-text" class="header-anchor">#</a></h3><p>以当前定义的文本方向绘制给定的<em>text</em>，从给定的<em>position</em>开始。</p>
<p>这个函数不处理换行符（\n），因为它不能将文本分成多行，也不能显示换行符。如果你想画出带有换行符的多行文本，或者你想让文本被包裹起来，请使用QPainter::drawText()重载，它需要一个矩形来代替。</p>
<p>默认情况下，<a href>QPainter</a>绘制的文本是抗锯齿的。</p>
<p><strong>注意：</strong> y-position被用作字体的基线。</p>
<p><strong>See also</strong> <a href="#setFont">setFont</a>() and <a href="#setPen">setPen</a>().</p>
<h3><span id="void-qpainter-drawtext-const-qpoint-amp-position-const-qstring-amp-text">void QPainter::drawText(const  &amp;<em>position</em>, const  &amp;<em>text</em>)</span><a href="#void-qpainter-drawtext-const-qpoint-amp-position-const-qstring-amp-text" class="header-anchor">#</a></h3><p>这是一个重载函数。</p>
<p>以当前定义的文本方向绘制给定的<em>text</em>，从给定的<em>position</em>开始。</p>
<p>默认情况下，<a href>QPainter</a>绘制的文本是抗锯齿的。</p>
<p><strong>注意：</strong> y-position被用作字体的基线。</p>
<p><strong>See also</strong> <a href="#setFont">setFont</a>() and <a href="#setPen">setPen</a>().</p>
<h3><span id="void-qpainter-drawtext-int-x-int-y-const-qstring-amp-text">void QPainter::drawText(int <em>x</em>, int <em>y</em>, const  &amp;<em>text</em>)</span><a href="#void-qpainter-drawtext-int-x-int-y-const-qstring-amp-text" class="header-anchor">#</a></h3><p>这是一个重载函数。</p>
<p>在位置（<em>x</em>, <em>y</em>）上绘制给定的<em>text</em>，使用画家当前定义的文本方向。</p>
<p>默认情况下，<a href>QPainter</a>绘制的文本是抗锯齿的。</p>
<p><strong>注意：</strong> y-位置被用作字体的基线。</p>
<p><strong>See also</strong> <a href="#setFont">setFont</a>() and <a href="#setPen">setPen</a>().</p>
<h3><span id="void-qpainter-drawtext-const-qrect-amp-rectangle-int-flags-const-qstring-amp-text-qrect-boundingrect-nullptr">void QPainter::drawText(const  &amp;<em>rectangle</em>, int <em>flags</em>, const  &amp;<em>text</em>,  *<em>boundingRect</em> = nullptr)</span><a href="#void-qpainter-drawtext-const-qrect-amp-rectangle-int-flags-const-qstring-amp-text-qrect-boundingrect-nullptr" class="header-anchor">#</a></h3><p>这是一个重载函数。</p>
<p>根据指定的<em>flags</em>，在提供的<em>rectangle**内绘制给定的</em>text*。</p>
<p><em>boundingRect</em>（如果不是空的话）被设置为包围整个文本的边界矩形的内容。例如，在下面的图片中，虚线代表函数计算的<em>boundingRect</em>，而虚线代表<em>rectangle</em>:</p>
<table>
<thead>
<tr>
<th><img src="https://doc.qt.io/qt-6/images/qpainter-text-bounds.png" srcset="/img/loading.gif" lazyload alt="img" style="zoom:2000%;"></th>
<th><code>QPainter painter(this); QFont font = painter.font(); font.setPixelSize(48); painter.setFont(font); const QRect rectangle = QRect(0, 0, 100, 50); QRect boundingRect; painter.drawText(rectangle, 0, tr("Hello"), &amp;boundingRect); QPen pen = painter.pen(); pen.setStyle(Qt::DotLine); painter.setPen(pen); painter.drawRect(boundingRect.adjusted(0, 0, -pen.width(), -pen.width())); pen.setStyle(Qt::DashLine); painter.setPen(pen); painter.drawRect(rectangle.adjusted(0, 0, -pen.width(), -pen.width()));</code></th>
</tr>
</thead>
<tbody><tr>
<td></td>
<td></td>
</tr>
</tbody></table>
<p>默认情况下，<a href>QPainter</a>绘制的文本是抗锯齿的。</p>
<p><strong>注意：</strong>  <em>rectangle</em>的y坐标被用作字体的顶部。</p>
<p><strong>See also</strong> <a href="#setFont">setFont</a>() and <a href="#setPen">setPen</a>().</p>
<h3><span id="void-qpainter-drawtext-int-x-int-y-int-width-int-height-int-flags-const-qstring-amp-text-qrect-boundingrect-nullptr">void QPainter::drawText(int <em>x</em>, int <em>y</em>, int <em>width</em>, int <em>height</em>, int <em>flags</em>, const  &amp;<em>text</em>,  *<em>boundingRect</em> = nullptr)</span><a href="#void-qpainter-drawtext-int-x-int-y-int-width-int-height-int-flags-const-qstring-amp-text-qrect-boundingrect-nullptr" class="header-anchor">#</a></h3><p>这是一个重载函数。</p>
<p>在原点（<em>x</em>, <em>y</em>）、<em>width</em>和<em>height</em>的矩形内绘制给定的<em>text</em>。</p>
<p>如果不为空，<em>boundingRect</em>将被设置为包围整个文本的边界矩形的内容。例如，在下面的图片中，虚线代表函数计算出的<em>boundingRect</em>，而虚线代表由<em>x</em>、<em>y</em>、<em>width</em>和<em>height</em>定义的矩形:</p>
<table>
<thead>
<tr>
<th><img src="https://doc.qt.io/qt-6/images/qpainter-text-bounds.png" srcset="/img/loading.gif" lazyload alt="img" style="zoom:600%;"></th>
<th><code>QPainter painter(this); QFont font = painter.font(); font.setPixelSize(48); painter.setFont(font); const QRect rectangle = QRect(0, 0, 100, 50); QRect boundingRect; painter.drawText(rectangle, 0, tr("Hello"), &amp;boundingRect); QPen pen = painter.pen(); pen.setStyle(Qt::DotLine); painter.setPen(pen); painter.drawRect(boundingRect.adjusted(0, 0, -pen.width(), -pen.width())); pen.setStyle(Qt::DashLine); painter.setPen(pen); painter.drawRect(rectangle.adjusted(0, 0, -pen.width(), -pen.width()));</code></th>
</tr>
</thead>
<tbody><tr>
<td></td>
<td></td>
</tr>
</tbody></table>
<p>参数<em>flags</em>是以下标志的位数OR。</p>
<ul>
<li><a href="qt-6/qt.html#AlignmentFlag-enum">Qt::AlignLeft</a></li>
<li><a href="qt-6/qt.html#AlignmentFlag-enum">Qt::AlignRight</a></li>
<li><a href="qt-6/qt.html#AlignmentFlag-enum">Qt::AlignHCenter</a></li>
<li><a href="qt-6/qt.html#AlignmentFlag-enum">Qt::AlignJustify</a></li>
<li><a href="qt-6/qt.html#AlignmentFlag-enum">Qt::AlignTop</a></li>
<li><a href="qt-6/qt.html#AlignmentFlag-enum">Qt::AlignBottom</a></li>
<li><a href="qt-6/qt.html#AlignmentFlag-enum">Qt::AlignVCenter</a></li>
<li><a href="qt-6/qt.html#AlignmentFlag-enum">Qt::AlignCenter</a></li>
<li><a href="qt-6/qt.html#TextFlag-enum">Qt::TextSingleLine</a></li>
<li><a href="qt-6/qt.html#TextFlag-enum">Qt::TextExpandTabs</a></li>
<li><a href="qt-6/qt.html#TextFlag-enum">Qt::TextShowMnemonic</a></li>
<li><a href="qt-6/qt.html#TextFlag-enum">Qt::TextWordWrap</a></li>
</ul>
<p>默认情况下，<a href>QPainter</a>绘制的文本是反锯齿的。</p>
<p><strong>注意：</strong> y-position被用作字体的顶部。</p>
<p><strong>See also</strong> <a href="qt-6/qt.html#AlignmentFlag-enum">Qt::AlignmentFlag</a>, <a href="qt-6/qt.html#TextFlag-enum">Qt::TextFlag</a>, <a href="#setFont">setFont</a>(), and <a href="#setPen">setPen</a>().</p>
<h3><span id="void-qpainter-drawtext-const-qrectf-amp-rectangle-const-qstring-amp-text-const-qtextoption-amp-option-qtextoption">void QPainter::drawText(const  &amp;<em>rectangle</em>, const  &amp;<em>text</em>, const  &amp;<em>option</em> = QTextOption())</span><a href="#void-qpainter-drawtext-const-qrectf-amp-rectangle-const-qstring-amp-text-const-qtextoption-amp-option-qtextoption" class="header-anchor">#</a></h3><p>这是一个重载函数。</p>
<p>在使用<em>option</em>指定的<em>rectangle</em>中绘制给定的<em>text</em>，以控制其定位、方向和方位。在<em>option</em>中给出的选项覆盖那些在<a href>QPainter</a>对象本身设置的选项。</p>
<p>默认情况下，<a href>QPainter</a>绘制的文本是抗锯齿的。</p>
<p><strong>注意：</strong> <em>rectangle</em>的y坐标被用作字体的顶部。</p>
<p><strong>See also</strong> <a href="#setFont">setFont</a>() and <a href="#setPen">setPen</a>().</p>
<h3><span id="void-qpainter-drawtiledpixmap-const-qrectf-amp-rectangle-const-qpixmap-amp-pixmap-const-qpointf-amp-position-qpointf">void QPainter::drawTiledPixmap(const  &amp;<em>rectangle</em>, const  &amp;<em>pixmap</em>, const  &amp;<em>position</em> = QPointF())</span><a href="#void-qpainter-drawtiledpixmap-const-qrectf-amp-rectangle-const-qpixmap-amp-pixmap-const-qpointf-amp-position-qpointf" class="header-anchor">#</a></h3><p>在给定的<em>rectangle</em>内绘制一个平铺的<em>pixmap</em>，其原点在给定的<em>position</em>。</p>
<p>调用drawTiledPixmap()类似于多次调用<a href="#drawPixmap">drawPixmap</a>()来用一个像素图填充（平铺）一个区域，但根据底层窗口系统的不同，可能会更有效。</p>
<p>drawTiledPixmap()在高dpi显示器（设备像素比&gt;1）上会产生与正常dpi显示器相同的视觉平铺模式。在<em>pixmap</em>上设置devicePixelRatio来控制平铺的大小。例如，将其设置为2，可将磁贴宽度和高度减半（在1x和2x显示器上），并在2x显示器上产生高分辨率输出。</p>
<p><em>position</em> 偏移量总是在绘图仪坐标系中，与显示设备像素比例无关。</p>
<p><strong>See also</strong> <a href="#drawPixmap">drawPixmap</a>().</p>
<h3><span id="void-qpainter-drawtiledpixmap-int-x-int-y-int-width-int-height-const-qpixmap-amp-pixmap-int-sx-0-int-sy-0">void QPainter::drawTiledPixmap(int <em>x</em>, int <em>y</em>, int <em>width</em>, int <em>height</em>, const  &amp;<em>pixmap</em>, int <em>sx</em> = 0, int <em>sy</em> = 0)</span><a href="#void-qpainter-drawtiledpixmap-int-x-int-y-int-width-int-height-const-qpixmap-amp-pixmap-int-sx-0-int-sy-0" class="header-anchor">#</a></h3><p>这是一个重载函数。</p>
<p>在指定的矩形范围内绘制一个平铺的<em>pixmap</em>。</p>
<p>(<em>x</em>, <em>y</em>)指定要画到的绘画设备的左上角；有给定的<em>宽度</em>和<em>高度</em>。(<em>sx</em>, <em>sy</em>) 指定要绘制的<em>pixmap</em>的左上角；默认为（0, 0）。</p>
<h3><span id="void-qpainter-drawtiledpixmap-const-qrect-amp-rectangle-const-qpixmap-amp-pixmap-const-qpoint-amp-position-qpoint">void QPainter::drawTiledPixmap(const  &amp;<em>rectangle</em>, const  &amp;<em>pixmap</em>, const  &amp;<em>position</em> = QPoint())</span><a href="#void-qpainter-drawtiledpixmap-const-qrect-amp-rectangle-const-qpixmap-amp-pixmap-const-qpoint-amp-position-qpoint" class="header-anchor">#</a></h3><p>这是一个重载函数。</p>
<p>在给定的<em>rectangle</em>内绘制一个平铺的<em>pixmap</em>，其原点在给定的<em>position</em> 。</p>
<h3><span id="bool-qpainter-end">bool QPainter::end()</span><a href="#bool-qpainter-end" class="header-anchor">#</a></h3><p>结束绘制。绘制时使用的任何资源都被释放。你通常不需要调用这个，因为它是由析构器调用的。</p>
<p>如果绘画器不再活动，返回 “true”；否则返回 “false”。</p>
<p><strong>See also</strong> <a href="#begin">begin</a>() and <a href="#isActive">isActive</a>().</p>
<h3><span id="void-qpainter-endnativepainting">void QPainter::endNativePainting()</span><a href="#void-qpainter-endnativepainting" class="header-anchor">#</a></h3><p>在手动发出本地绘画命令后恢复绘画器。在调用任何其他绘画命令之前，让绘画器恢复它所依赖的任何本地状态。</p>
<p><strong>See also</strong> <a href="#beginNativePainting">beginNativePainting</a>().</p>
<h3><span id="void-qpainter-eraserect-const-qrectf-amp-rectangle">void QPainter::eraseRect(const  &amp;<em>rectangle</em>)</span><a href="#void-qpainter-eraserect-const-qrectf-amp-rectangle" class="header-anchor">#</a></h3><p>擦除给定的<em>rectangle</em>内的区域。相当于调用：</p>
<div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-built_in">fillRect</span>(rectangle, <span class="hljs-built_in">background</span>());</code></pre></div>

<p><strong>See also</strong> <a href="#fillRect">fillRect</a>().</p>
<h3><span id="void-qpainter-eraserect-int-x-int-y-int-width-int-height">void QPainter::eraseRect(int <em>x</em>, int <em>y</em>, int <em>width</em>, int <em>height</em>)</span><a href="#void-qpainter-eraserect-int-x-int-y-int-width-int-height" class="header-anchor">#</a></h3><p>这是一个重载函数。</p>
<p>擦除从（<em>x</em>，<em>y</em>）开始的矩形内的区域，给定的<em>width</em>和<em>height</em>.</p>
<h3><span id="void-qpainter-eraserect-const-qrect-amp-rectangle">void QPainter::eraseRect(const  &amp;<em>rectangle</em>)</span><a href="#void-qpainter-eraserect-const-qrect-amp-rectangle" class="header-anchor">#</a></h3><p>这是一个重载函数。</p>
<p>擦除给定的<em>rectangle</em>内的区域。</p>
<h3><span id="void-qpainter-fillpath-const-qpainterpath-amp-path-const-qbrush-amp-brush">void QPainter::fillPath(const  &amp;<em>path</em>, const  &amp;<em>brush</em>)</span><a href="#void-qpainter-fillpath-const-qpainterpath-amp-path-const-qbrush-amp-brush" class="header-anchor">#</a></h3><p>使用给定的<em>brush</em>填充给定的<em>path</em>。轮廓不被绘制。</p>
<p>另外，你可以指定一个<a href="qt-6/qcolor.html">QColor</a>而不是<a href="qt-6/qbrush.html">QBrush</a>；<a href="qt-6/qbrush.html">QBrush</a>构造函数（接受一个<a href="qt-6/qcolor.html">QColor</a>参数）将自动创建一个实体图案刷。</p>
<p><strong>See also</strong> <a href="#drawPath">drawPath</a>().</p>
<h3><span id="void-qpainter-fillrect-const-qrectf-amp-rectangle-const-qbrush-amp-brush">void QPainter::fillRect(const  &amp;<em>rectangle</em>, const  &amp;<em>brush</em>)</span><a href="#void-qpainter-fillrect-const-qrectf-amp-rectangle-const-qbrush-amp-brush" class="header-anchor">#</a></h3><p>用指定的<em>brush</em>填充给定的<em>rectangle</em>。</p>
<p>或者，你可以指定一个<a href="qt-6/qcolor.html">QColor</a>而不是<a href="qt-6/qbrush.html">QBrush</a>；<a href="qt-6/qbrush.html">QBrush</a>构造函数（接受一个<a href="qt-6/qcolor.html">QColor</a>参数）会自动创建一个纯色的画笔。</p>
<p><strong>See also</strong> <a href="#drawRect">drawRect</a>().</p>
<h3><span id="void-qpainter-fillrect-int-x-int-y-int-width-int-height-const-qbrush-amp-brush">void QPainter::fillRect(int <em>x</em>, int <em>y</em>, int <em>width</em>, int <em>height</em>, const  &amp;<em>brush</em>)</span><a href="#void-qpainter-fillrect-int-x-int-y-int-width-int-height-const-qbrush-amp-brush" class="header-anchor">#</a></h3><p>这是一个重载函数。</p>
<p>使用给定的<em>brush</em>，在(<em>x</em>, <em>y</em>)开始的矩形中填充给定的<em>width</em>和<em>height</em>。</p>
<h3><span id="void-qpainter-fillrect-const-qrect-amp-rectangle-const-qbrush-amp-brush">void QPainter::fillRect(const  &amp;<em>rectangle</em>, const  &amp;<em>brush</em>)</span><a href="#void-qpainter-fillrect-const-qrect-amp-rectangle-const-qbrush-amp-brush" class="header-anchor">#</a></h3><p>这是一个重载函数。</p>
<p>用指定的 <em>brush</em> 填充给定的 <em>rectangle</em>。</p>
<h3><span id="void-qpainter-fillrect-const-qrectf-amp-rectangle-const-qcolor-amp-color">void QPainter::fillRect(const  &amp;<em>rectangle</em>, const  &amp;<em>color</em>)</span><a href="#void-qpainter-fillrect-const-qrectf-amp-rectangle-const-qcolor-amp-color" class="header-anchor">#</a></h3><p>这是一个重载函数。</p>
<p>用指定的 <em>color</em> 填充给定的 <em>rectangle</em>。</p>
<h3><span id="void-qpainter-fillrect-int-x-int-y-int-width-int-height-const-qcolor-amp-color">void QPainter::fillRect(int <em>x</em>, int <em>y</em>, int <em>width</em>, int <em>height</em>, const  &amp;<em>color</em>)</span><a href="#void-qpainter-fillrect-int-x-int-y-int-width-int-height-const-qcolor-amp-color" class="header-anchor">#</a></h3><p>这是一个重载函数。</p>
<p>填充从（<em>x</em>，<em>y</em>）开始的矩形，给定的<em>width</em>和<em>height</em>，使用给定的<em>color</em>。</p>
<h3><span id="void-qpainter-fillrect-const-qrect-amp-rectangle-const-qcolor-amp-color">void QPainter::fillRect(const  &amp;<em>rectangle</em>, const  &amp;<em>color</em>)</span><a href="#void-qpainter-fillrect-const-qrect-amp-rectangle-const-qcolor-amp-color" class="header-anchor">#</a></h3><p>这是一个重载函数。</p>
<p>用指定的<em>color</em>填充给定的<em>rectangle</em>。</p>
<h3><span id="void-qpainter-fillrect-int-x-int-y-int-width-int-height-qt-globalcolor-color">void QPainter::fillRect(int <em>x</em>, int <em>y</em>, int <em>width</em>, int <em>height</em>,  <em>color</em>)</span><a href="#void-qpainter-fillrect-int-x-int-y-int-width-int-height-qt-globalcolor-color" class="header-anchor">#</a></h3><p>这是一个重载函数。</p>
<p>填充从（<em>x</em>, <em>y</em>）开始的矩形，使用给定的<em>width</em>和<em>height</em>，使用给定的<em>color</em>。</p>
<h3><span id="void-qpainter-fillrect-const-qrect-amp-rectangle-qt-globalcolor-color">void QPainter::fillRect(const  &amp;<em>rectangle</em>,  <em>color</em>)</span><a href="#void-qpainter-fillrect-const-qrect-amp-rectangle-qt-globalcolor-color" class="header-anchor">#</a></h3><p>这是一个重载函数。</p>
<p>用指定的<em>color</em>填充给定的<em>rectangle</em>。</p>
<h3><span id="void-qpainter-fillrect-const-qrectf-amp-rectangle-qt-globalcolor-color">void QPainter::fillRect(const  &amp;<em>rectangle</em>,  <em>color</em>)</span><a href="#void-qpainter-fillrect-const-qrectf-amp-rectangle-qt-globalcolor-color" class="header-anchor">#</a></h3><p>这是一个重载函数。</p>
<p>用指定的<em>color</em>填充给定的<em>rectangle</em>。</p>
<h3><span id="void-qpainter-fillrect-int-x-int-y-int-width-int-height-qt-brushstyle-style">void QPainter::fillRect(int <em>x</em>, int <em>y</em>, int <em>width</em>, int <em>height</em>,  <em>style</em>)</span><a href="#void-qpainter-fillrect-int-x-int-y-int-width-int-height-qt-brushstyle-style" class="header-anchor">#</a></h3><p>这是一个重载函数。</p>
<p>以指定的<em>width</em>和<em>height</em>填充从(<em>x</em>, <em>y</em>)开始的矩形，使用指定的<em>style</em>画笔。</p>
<h3><span id="void-qpainter-fillrect-const-qrect-amp-rectangle-qt-brushstyle-style">void QPainter::fillRect(const  &amp;<em>rectangle</em>,  <em>style</em>)</span><a href="#void-qpainter-fillrect-const-qrect-amp-rectangle-qt-brushstyle-style" class="header-anchor">#</a></h3><p>这是一个重载函数。</p>
<p>用指定的画笔<em>style</em>填充给定的<em>rectangle</em>。</p>
<h3><span id="void-qpainter-fillrect-const-qrectf-amp-rectangle-qt-brushstyle-style">void QPainter::fillRect(const  &amp;<em>rectangle</em>,  <em>style</em>)</span><a href="#void-qpainter-fillrect-const-qrectf-amp-rectangle-qt-brushstyle-style" class="header-anchor">#</a></h3><p>这是一个重载函数。</p>
<p>用指定的画笔<em>style</em>填充给定的<em>rectangle</em>。</p>
<h3><span id="since-5-12-void-qpainter-fillrect-int-x-int-y-int-width-int-height-qgradient-preset-preset"><code>[since 5.12]</code>void QPainter::fillRect(int <em>x</em>, int <em>y</em>, int <em>width</em>, int <em>height</em>,  <em>preset</em>)</span><a href="#since-5-12-void-qpainter-fillrect-int-x-int-y-int-width-int-height-qgradient-preset-preset" class="header-anchor">#</a></h3><p>这是一个重载函数</p>
<p>使用给定的梯度<em>preset</em>，以给定的<em>width</em>和<em>height</em>填充从（<em>x</em>，<em>y</em>）开始的矩形。</p>
<p>这个函数引入于Qt 5.12</p>
<h3><span id="since-5-12-void-qpainter-fillrect-const-qrect-amp-rectangle-qgradient-preset-preset"><code>[since 5.12]</code>void QPainter::fillRect(const  &amp;<em>rectangle</em>,  <em>preset</em>)</span><a href="#since-5-12-void-qpainter-fillrect-const-qrect-amp-rectangle-qgradient-preset-preset" class="header-anchor">#</a></h3><p>这是一个重载函数。</p>
<p>用指定的梯度<em>preset</em>填充给定的<em>rectangle</em>。</p>
<p>这个函数引入于Qt 5.12。</p>
<h3><span id="since-5-12-void-qpainter-fillrect-const-qrectf-amp-rectangle-qgradient-preset-preset"><code>[since 5.12]</code>void QPainter::fillRect(const  &amp;<em>rectangle</em>,  <em>preset</em>)</span><a href="#since-5-12-void-qpainter-fillrect-const-qrectf-amp-rectangle-qgradient-preset-preset" class="header-anchor">#</a></h3><p>这是一个重载函数。</p>
<p>用指定的梯度<em>preset</em>填充给定的<em>rectangle</em>。</p>
<p>这个函数引入于Qt 5.12。</p>
<h3><span id="const-qfont-amp-qpainter-font-const">const  &amp;QPainter::font() const</span><a href="#const-qfont-amp-qpainter-font-const" class="header-anchor">#</a></h3><p>返回当前设置的用于绘制文本的字体。</p>
<p><strong>See also</strong> <a href="#setFont">setFont</a>(), <a href="#drawText">drawText</a>(), and <a href="#settings">Settings</a>.</p>
<h3><span id="qfontinfo-qpainter-fontinfo-const"> QPainter::fontInfo() const</span><a href="#qfontinfo-qpainter-fontinfo-const" class="header-anchor">#</a></h3><p>如果绘图器处于活动状态，返回绘图器的字体信息。否则，返回值是未定义的。</p>
<p><strong>See also</strong> <a href="#font">font</a>(), <a href="#isActive">isActive</a>(), and <a href="#settings">Settings</a>.</p>
<h3><span id="qfontmetrics-qpainter-fontmetrics-const"> QPainter::fontMetrics() const</span><a href="#qfontmetrics-qpainter-fontmetrics-const" class="header-anchor">#</a></h3><p>如果画师处于活动状态，返回画师的字体度量。否则，返回值是未定义的。</p>
<p><strong>See also</strong> <a href="#font">font</a>(), <a href="#isActive">isActive</a>(), and <a href="#settings">Settings</a>.</p>
<h3><span id="bool-qpainter-hasclipping-const">bool QPainter::hasClipping() const</span><a href="#bool-qpainter-hasclipping-const" class="header-anchor">#</a></h3><p>如果设置了剪裁，返回<code>true</code>；否则返回<code>false</code>。</p>
<p><strong>See also</strong> <a href="#setClipping">setClipping</a>() and <a href="#clipping">Clipping</a>.</p>
<h3><span id="bool-qpainter-isactive-const">bool QPainter::isActive() const</span><a href="#bool-qpainter-isactive-const" class="header-anchor">#</a></h3><p>如果<a href="#begin">begin</a>()已经被调用，<a href="#end">end</a>()尚未被调用，则返回<code>true</code>；否则返回<code>false</code>。</p>
<p><strong>See also</strong> <a href="#begin">begin</a>() and <a href="qt-6/qpaintdevice.html#paintingActive">QPaintDevice::paintingActive</a>().</p>
<h3><span id="qt-layoutdirection-qpainter-layoutdirection-const"> QPainter::layoutDirection() const</span><a href="#qt-layoutdirection-qpainter-layoutdirection-const" class="header-anchor">#</a></h3><p>返回绘图器在绘制文本时使用的布局方向。</p>
<p><strong>See also</strong> <a href="qt-6/qtextoption.html#textDirection">QTextOption::textDirection</a>(), <a href="#setLayoutDirection">setLayoutDirection</a>(), <a href="#drawText">drawText</a>(), and <a href="#settings">Settings</a>.</p>
<h3><span id="qreal-qpainter-opacity-const"> QPainter::opacity() const</span><a href="#qreal-qpainter-opacity-const" class="header-anchor">#</a></h3><p>返回绘图器的不透明度。默认值是1。</p>
<p><strong>See also</strong> <a href="#setOpacity">setOpacity</a>().</p>
<h3><span id="qpaintengine-qpainter-paintengine-const"> *QPainter::paintEngine() const</span><a href="#qpaintengine-qpainter-paintengine-const" class="header-anchor">#</a></h3><p>如果绘图器处于活动状态，返回绘图器当前操作的绘图引擎；否则返回0。</p>
<p><strong>See also</strong> <a href="#isActive">isActive</a>().</p>
<h3><span id="const-qpen-amp-qpainter-pen-const">const  &amp;QPainter::pen() const</span><a href="#const-qpen-amp-qpainter-pen-const" class="header-anchor">#</a></h3><p>返回绘图器的当前笔。</p>
<p><strong>See also</strong> <a href="#setPen">setPen</a>() and <a href="#settings">Settings</a>.</p>
<h3><span id="qpainter-renderhints-qpainter-renderhints-const"> QPainter::renderHints() const</span><a href="#qpainter-renderhints-qpainter-renderhints-const" class="header-anchor">#</a></h3><p>返回一个标志，指定为这个绘图器设置的渲染提示。</p>
<p><strong>See also</strong> <a href="#setRenderHints">setRenderHints</a>(), <a href="#testRenderHint">testRenderHint</a>(), and <a href="#rendering-quality">Rendering Quality</a>.</p>
<h3><span id="void-qpainter-resettransform">void QPainter::resetTransform()</span><a href="#void-qpainter-resettransform" class="header-anchor">#</a></h3><p>重置任何使用<a href="#translate">translate</a>()、<a href="#scale">scale</a>()、<a href="#shear">shear</a>()、<a href="#rotate">rotate</a>()、<a href="#setWorldTransform">setWorldTransform</a>()、<a href="#setViewport">setViewport</a>() 和<a href="#setWindow">setWindow</a> ()进行的变换。</p>
<p><strong>See also</strong> <a href="#coordinate-transformations">Coordinate Transformations</a>.</p>
<h3><span id="void-qpainter-restore">void QPainter::restore()</span><a href="#void-qpainter-restore" class="header-anchor">#</a></h3><p>恢复当前画师的状态（从堆栈中弹出一个保存的状态）。</p>
<p><strong>See also</strong> <a href="#save">save</a>().</p>
<h3><span id="void-qpainter-rotate-qreal-angle">void QPainter::rotate( <em>angle</em>)</span><a href="#void-qpainter-rotate-qreal-angle" class="header-anchor">#</a></h3><p>顺时针旋转坐标系。给定的<em>angle</em>参数是度数。</p>
<p><strong>See also</strong> <a href="#setWorldTransform">setWorldTransform</a>() and <a href="#coordinate-transformations">Coordinate Transformations</a>.</p>
<h3><span id="void-qpainter-save">void QPainter::save()</span><a href="#void-qpainter-save" class="header-anchor">#</a></h3><p>保存当前绘图器的状态（将状态推到堆栈上）。保存()后必须有相应的<a href="#restore">restore</a>()；<a href="#end">end</a>()函数将堆栈展开。</p>
<p><strong>See also</strong> <a href="#restore">restore</a>().</p>
<h3><span id="void-qpainter-scale-qreal-sx-qreal-sy">void QPainter::scale( <em>sx</em>,  <em>sy</em>)</span><a href="#void-qpainter-scale-qreal-sx-qreal-sy" class="header-anchor">#</a></h3><p>通过(<em>sx</em>, <em>sy</em>)缩放坐标系。</p>
<p><strong>See also</strong> <a href="#setWorldTransform">setWorldTransform</a>() and <a href="#coordinate-transformations">Coordinate Transformations</a>.</p>
<h3><span id="void-qpainter-setbackground-const-qbrush-amp-brush">void QPainter::setBackground(const  &amp;<em>brush</em>)</span><a href="#void-qpainter-setbackground-const-qbrush-amp-brush" class="header-anchor">#</a></h3><p>将画师的背景笔刷设置为给定的<em>brush</em>。</p>
<p>背景画笔是在绘制不透明的文本、僵硬的线条和位图时被填入的画笔。</p>
<p>背景画笔在透明背景模式下没有作用（这是默认的）。</p>
<p><strong>See also</strong> <a href="#background">background</a>(), <a href="#setBackgroundMode">setBackgroundMode</a>(), and <a href="#settings">Settings</a>.</p>
<h3><span id="void-qpainter-setbackgroundmode-qt-bgmode-mode">void QPainter::setBackgroundMode( <em>mode</em>)</span><a href="#void-qpainter-setbackgroundmode-qt-bgmode-mode" class="header-anchor">#</a></h3><p>将绘图器的背景模式设置为给定的<em>mode</em>。</p>
<p><a href="qt-6/qt.html#BGMode-enum">Qt::TransparentMode</a>（默认）绘制有条纹的线条和文本，而不设置背景像素。<a href="qt-6/qt.html#BGMode-enum">Qt::OpaqueMode</a> 用当前的背景颜色填充这些空间。</p>
<p>请注意，為了透明地绘制位图或图像，你必須使用 <a href="qt-6/qpixmap.html#setMask">QPixmap::setMask</a>()。</p>
<p><strong>See also</strong> <a href="#backgroundMode">backgroundMode</a>(), <a href="#setBackground">setBackground</a>(), and <a href="#settings">Settings</a>.</p>
<h3><span id="void-qpainter-setbrush-const-qbrush-amp-brush">void QPainter::setBrush(const  &amp;<em>brush</em>)</span><a href="#void-qpainter-setbrush-const-qbrush-amp-brush" class="header-anchor">#</a></h3><p>将画师的画笔设置为给定的<em>brush</em>。</p>
<p>画家的笔刷定义了形状的填充方式。</p>
<p><strong>See also</strong> <a href="#brush">brush</a>() and <a href="#settings">Settings</a>.</p>
<h3><span id="void-qpainter-setbrush-qt-brushstyle-style">void QPainter::setBrush( <em>style</em>)</span><a href="#void-qpainter-setbrush-qt-brushstyle-style" class="header-anchor">#</a></h3><p>这是一个重载函数。</p>
<p>将画笔设置为黑色和指定的<em>style</em>。</p>
<h3><span id="void-qpainter-setbrushorigin-const-qpointf-amp-position">void QPainter::setBrushOrigin(const  &amp;<em>position</em>)</span><a href="#void-qpainter-setbrushorigin-const-qpointf-amp-position" class="header-anchor">#</a></h3><p>将画笔原点设置为<strong>position</strong>。</p>
<p>画笔原点指定了画家画笔的（0, 0）坐标。</p>
<p>请注意，在Qt 3中，<a href="#brushOrigin">brushOrigin</a>()对于采用父对象的背景是必要的，但现在不再是这样了，因为Qt 4绘图器不会绘制背景，除非你通过设置该对象的<a href="#autoFillBackground-prop">autoFillBackground</a>属性为true来明确告诉它这么做。</p>
<p><strong>See also</strong> <a href="#brushOrigin">brushOrigin</a>() and <a href="#settings">Settings</a>.</p>
<h3><span id="void-qpainter-setbrushorigin-int-x-int-y">void QPainter::setBrushOrigin(int <em>x</em>, int <em>y</em>)</span><a href="#void-qpainter-setbrushorigin-int-x-int-y" class="header-anchor">#</a></h3><p>这是一个重载函数。</p>
<p>将画笔的原点设置为点（<strong>x</strong>，<strong>y</strong>）。</p>
<h3><span id="void-qpainter-setbrushorigin-const-qpoint-amp-position">void QPainter::setBrushOrigin(const  &amp;<em>position</em>)</span><a href="#void-qpainter-setbrushorigin-const-qpoint-amp-position" class="header-anchor">#</a></h3><p>这是一个重载函数。</p>
<p>将画笔的原点设置为给定的<strong>position</strong>。</p>
<h3><span id="void-qpainter-setclippath-const-qpainterpath-amp-path-qt-clipoperation-operation-qt-replaceclip">void QPainter::setClipPath(const  &amp;<em>path</em>,  <em>operation</em> = Qt::ReplaceClip)</span><a href="#void-qpainter-setclippath-const-qpainterpath-amp-path-qt-clipoperation-operation-qt-replaceclip" class="header-anchor">#</a></h3><p>启用剪裁，并将画师的剪裁路径设置为给定的<strong>路径</strong>，使用剪裁<strong>operation</strong>。</p>
<p>注意，剪辑路径是以逻辑（画师）坐标指定的。</p>
<p><strong>See also</strong> <a href="#clipPath">clipPath</a>(), <a href="#clipRegion">clipRegion</a>(), and <a href="#clipping">Clipping</a>.</p>
<h3><span id="void-qpainter-setcliprect-const-qrectf-amp-rectangle-qt-clipoperation-operation-qt-replaceclip">void QPainter::setClipRect(const  &amp;<em>rectangle</em>,  <em>operation</em> = Qt::ReplaceClip)</span><a href="#void-qpainter-setcliprect-const-qrectf-amp-rectangle-qt-clipoperation-operation-qt-replaceclip" class="header-anchor">#</a></h3><p>启用剪裁，并使用给定的剪裁<strong>operation</strong>将剪裁区域设置为给定的<strong>rectangle</strong>。默认的操作是替换当前的剪辑矩形。</p>
<p>注意，剪辑矩形是以逻辑（画家）坐标指定的。</p>
<p><strong>See also</strong> <a href="#clipRegion">clipRegion</a>(), <a href="#setClipping">setClipping</a>(), and <a href="#clipping">Clipping</a>.</p>
<h3><span id="void-qpainter-setcliprect-const-qrect-amp-rectangle-qt-clipoperation-operation-qt-replaceclip">void QPainter::setClipRect(const  &amp;<em>rectangle</em>,  <em>operation</em> = Qt::ReplaceClip)</span><a href="#void-qpainter-setcliprect-const-qrect-amp-rectangle-qt-clipoperation-operation-qt-replaceclip" class="header-anchor">#</a></h3><p>这是一个重载函数。</p>
<p>启用剪切，并使用给定的剪切<strong>operation</strong>将剪切区域设置为给定的<strong>rectangle</strong>。</p>
<h3><span id="void-qpainter-setcliprect-int-x-int-y-int-width-int-height-qt-clipoperation-operation-qt-replaceclip">void QPainter::setClipRect(int <em>x</em>, int <em>y</em>, int <em>width</em>, int <em>height</em>,  <em>operation</em> = Qt::ReplaceClip)</span><a href="#void-qpainter-setcliprect-int-x-int-y-int-width-int-height-qt-clipoperation-operation-qt-replaceclip" class="header-anchor">#</a></h3><p>启用剪裁，并将剪裁区域设置为从（<strong>x</strong>，<strong>y</strong>）开始的矩形，其<strong>width</strong>和<strong>height</strong>为给定值。</p>
<h3><span id="void-qpainter-setclipregion-const-qregion-amp-region-qt-clipoperation-operation-qt-replaceclip">void QPainter::setClipRegion(const  &amp;<em>region</em>,  <em>operation</em> = Qt::ReplaceClip)</span><a href="#void-qpainter-setclipregion-const-qregion-amp-region-qt-clipoperation-operation-qt-replaceclip" class="header-anchor">#</a></h3><p>使用指定的剪辑<strong>operation</strong>将剪辑区域设置为给定的*区域。默认的剪辑操作是替换当前的剪辑区域。</p>
<p>注意，剪辑区域是以逻辑坐标给出的。</p>
<p><strong>See also</strong> <a href="#clipRegion">clipRegion</a>(), <a href="#setClipRect">setClipRect</a>(), and <a href="#clipping">Clipping</a>.</p>
<h3><span id="void-qpainter-setclipping-bool-enable">void QPainter::setClipping(bool <em>enable</em>)</span><a href="#void-qpainter-setclipping-bool-enable" class="header-anchor">#</a></h3><p>如果<strong>enable</strong>为真，则启用剪裁；如果<strong>enable</strong>为假，则禁用剪裁。</p>
<p><strong>See also</strong> <a href="#hasClipping">hasClipping</a>() and <a href="#clipping">Clipping</a>.</p>
<h3><span id="void-qpainter-setcompositionmode-qpainter-compositionmode-mode">void QPainter::setCompositionMode( <em>mode</em>)</span><a href="#void-qpainter-setcompositionmode-qpainter-compositionmode-mode" class="header-anchor">#</a></h3><p>将合成模式设置为给定的<strong>mode</strong>。</p>
<p>****警告：****只有在<a href="qt-6/qimage.html">QImage</a>上操作的<a href>QPainter</a>才完全支持所有的组合模式。如<a href="#compositionMode">compositionMode</a>()所述，RasterOp模式在X11中被支持。</p>
<p><strong>See also</strong> <a href="#compositionMode">compositionMode</a>().</p>
<h3><span id="void-qpainter-setfont-const-qfont-amp-font">void QPainter::setFont(const  &amp;<em>font</em>)</span><a href="#void-qpainter-setfont-const-qfont-amp-font" class="header-anchor">#</a></h3><p>将绘图器的字体设置为给定的<strong>font</strong>。</p>
<p>这个字体会被后续的<a href="#drawText">drawText</a>()函数使用。文字的颜色与笔的颜色相同。</p>
<p>如果你设置的字体不可用，Qt会找到一个接近的匹配。<a href="#font">font</a>()将返回你用setFont()设置的内容，而<a href="#fontInfo">fontInfo</a>()则返回实际使用的字体（可能是相同的）。</p>
<p><strong>See also</strong> <a href="#font">font</a>(), <a href="#drawText">drawText</a>(), and <a href="#settings">Settings</a>.</p>
<h3><span id="void-qpainter-setlayoutdirection-qt-layoutdirection-direction">void QPainter::setLayoutDirection( <em>direction</em>)</span><a href="#void-qpainter-setlayoutdirection-qt-layoutdirection-direction" class="header-anchor">#</a></h3><p>设置绘图器在绘制文本时使用的布局方向，以指定的<strong>direction</strong>。</p>
<p>默认是<a href="qt-6/qt.html#LayoutDirection-enum">Qt::LayoutDirectionAuto</a>，它将隐含地从绘制的文本中确定方向。</p>
<p><strong>See also</strong> <a href="qt-6/qtextoption.html#setTextDirection">QTextOption::setTextDirection</a>(), <a href="#layoutDirection">layoutDirection</a>(), <a href="#drawText">drawText</a>(), and <a href="#settings">Settings</a>.</p>
<h3><span id="void-qpainter-setopacity-qreal-opacity">void QPainter::setOpacity( <em>opacity</em>)</span><a href="#void-qpainter-setopacity-qreal-opacity" class="header-anchor">#</a></h3><p>將绘图器的不透明度設定為<strong>opacity</strong>。这个值应该在0.0到1.0之间，其中0.0是完全透明，1.0是完全不透明。</p>
<p>在绘图器上设置的不透明度将单独适用于所有绘图操作。</p>
<p><strong>See also</strong> <a href="#opacity">opacity</a>().</p>
<h3><span id="void-qpainter-setpen-const-qpen-amp-pen">void QPainter::setPen(const  &amp;<em>pen</em>)</span><a href="#void-qpainter-setpen-const-qpen-amp-pen" class="header-anchor">#</a></h3><p>将绘图器的笔设置为给定的<strong>pen</strong>。</p>
<p><strong>pen</strong>定义了如何绘制线条和轮廓，它也定义了文本颜色。</p>
<p><strong>See also</strong> <a href="#pen">pen</a>() and <a href="#settings">Settings</a>.</p>
<h3><span id="void-qpainter-setpen-const-qcolor-amp-color">void QPainter::setPen(const  &amp;<em>color</em>)</span><a href="#void-qpainter-setpen-const-qcolor-amp-color" class="header-anchor">#</a></h3><p>这是一个重载函数。</p>
<p>設定繪圖者的筆具有 <a href="qt-6/qt.html#PenStyle-enum">Qt::SolidLine</a>的樣式，寬度為1，以及指定的 <strong>color</strong>。</p>
<h3><span id="void-qpainter-setpen-qt-penstyle-style">void QPainter::setPen( <em>style</em>)</span><a href="#void-qpainter-setpen-qt-penstyle-style" class="header-anchor">#</a></h3><p>这是一个重载函数。</p>
<p>设置画家的笔具有给定的<strong>风格</strong>、宽度1和黑色。</p>
<h3><span id="void-qpainter-setrenderhint-qpainter-renderhint-hint-bool-on-true">void QPainter::setRenderHint( <em>hint</em>, bool <em>on</em> = true)</span><a href="#void-qpainter-setrenderhint-qpainter-renderhint-hint-bool-on-true" class="header-anchor">#</a></h3><p>如果<strong>on</strong>为真，则在绘图器上设置给定的渲染*提示；否则清除渲染提示。</p>
<p><strong>See also</strong> <a href="#setRenderHints">setRenderHints</a>(), <a href="#renderHints">renderHints</a>(), and <a href="#rendering-quality">Rendering Quality</a>.</p>
<h3><span id="void-qpainter-setrenderhints-qpainter-renderhints-hints-bool-on-true">void QPainter::setRenderHints( <em>hints</em>, bool <em>on</em> = true)</span><a href="#void-qpainter-setrenderhints-qpainter-renderhints-hints-bool-on-true" class="header-anchor">#</a></h3><p>如果<strong>on</strong>为真，则在绘图器上设置给定的渲染*提示；否则清除渲染提示。</p>
<p><strong>See also</strong> <a href="#setRenderHint">setRenderHint</a>(), <a href="#renderHints">renderHints</a>(), and <a href="#rendering-quality">Rendering Quality</a>.</p>
<h3><span id="void-qpainter-settransform-const-qtransform-amp-transform-bool-combine-false">void QPainter::setTransform(const  &amp;<em>transform</em>, bool <em>combine</em> = false)</span><a href="#void-qpainter-settransform-const-qtransform-amp-transform-bool-combine-false" class="header-anchor">#</a></h3><p>设置世界变换矩阵。如果<strong>combine</strong>为真，指定的<strong>变换</strong>将与当前的矩阵相结合；否则，它将取代当前的矩阵。</p>
<p><strong>See also</strong> <a href="#transform">transform</a>() and <a href="#setWorldTransform">setWorldTransform</a>().</p>
<h3><span id="void-qpainter-setviewtransformenabled-bool-enable">void QPainter::setViewTransformEnabled(bool <em>enable</em>)</span><a href="#void-qpainter-setviewtransformenabled-bool-enable" class="header-anchor">#</a></h3><p>如果<strong>enable</strong>为真，则启用视图变换；如果<strong>enable</strong>为假，则禁用视图变换。</p>
<p><strong>See also</strong> <a href="#viewTransformEnabled">viewTransformEnabled</a>() and <a href="qt-6/coordsys.html#window-viewport-conversion">Window-Viewport Conversion</a>.</p>
<h3><span id="void-qpainter-setviewport-const-qrect-amp-rectangle">void QPainter::setViewport(const  &amp;<em>rectangle</em>)</span><a href="#void-qpainter-setviewport-const-qrect-amp-rectangle" class="header-anchor">#</a></h3><p>将画师的视口矩形设置为给定的<strong>rectangle</strong>，并启用视图转换。</p>
<p>视口矩形是视图变换的一部分。视口指定了设备的坐标系统。它的姐妹，<a href="#window">window</a>()，指定了逻辑坐标系统。</p>
<p>默认的视口矩形与设备的矩形相同。</p>
<p><strong>See also</strong> <a href="#viewport">viewport</a>(), <a href="#viewTransformEnabled">viewTransformEnabled</a>(), and <a href="qt-6/coordsys.html#window-viewport-conversion">Window-Viewport Conversion</a>.</p>
<h3><span id="void-qpainter-setviewport-int-x-int-y-int-width-int-height">void QPainter::setViewport(int <em>x</em>, int <em>y</em>, int <em>width</em>, int <em>height</em>)</span><a href="#void-qpainter-setviewport-int-x-int-y-int-width-int-height" class="header-anchor">#</a></h3><p>这是一个重载函数。</p>
<p>设置画师的视口矩形为从(<strong>x</strong>, <strong>y</strong>)开始的矩形，并给定<strong>width</strong>和<strong>height</strong>。</p>
<h3><span id="void-qpainter-setwindow-const-qrect-amp-rectangle">void QPainter::setWindow(const  &amp;<em>rectangle</em>)</span><a href="#void-qpainter-setwindow-const-qrect-amp-rectangle" class="header-anchor">#</a></h3><p>设置画家的窗口为给定的<strong>rectangle</strong>，并启用视图转换。</p>
<p>窗口的矩形是视图变换的一部分。窗口指定了逻辑坐标系统。它的姐妹，<a href="#viewport">viewport</a>()，指定设备坐标系。</p>
<p>默认的窗口矩形与设备的矩形相同。</p>
<p><strong>See also</strong> <a href="#window">window</a>(), <a href="#viewTransformEnabled">viewTransformEnabled</a>(), and <a href="qt-6/coordsys.html#window-viewport-conversion">Window-Viewport Conversion</a>.</p>
<h3><span id="void-qpainter-setwindow-int-x-int-y-int-width-int-height">void QPainter::setWindow(int <em>x</em>, int <em>y</em>, int <em>width</em>, int <em>height</em>)</span><a href="#void-qpainter-setwindow-int-x-int-y-int-width-int-height" class="header-anchor">#</a></h3><p>这是一个重载函数。</p>
<p>将画师的窗口设置为从(<strong>x</strong>, <strong>y</strong>)和给定的<strong>width</strong>和<strong>height</strong>开始的矩形。</p>
<h3><span id="void-qpainter-setworldmatrixenabled-bool-enable">void QPainter::setWorldMatrixEnabled(bool <em>enable</em>)</span><a href="#void-qpainter-setworldmatrixenabled-bool-enable" class="header-anchor">#</a></h3><p>如果<strong>enable</strong>为真，则启用变换；如果<strong>enable</strong>为假，则禁用变换。世界变换矩阵不会被改变。</p>
<p><strong>See also</strong> <a href="#worldMatrixEnabled">worldMatrixEnabled</a>(), <a href="#worldTransform">worldTransform</a>(), and <a href="#coordinate-transformations">Coordinate Transformations</a>.</p>
<h3><span id="void-qpainter-setworldtransform-const-qtransform-amp-matrix-bool-combine-false">void QPainter::setWorldTransform(const  &amp;<em>matrix</em>, bool <em>combine</em> = false)</span><a href="#void-qpainter-setworldtransform-const-qtransform-amp-matrix-bool-combine-false" class="header-anchor">#</a></h3><p>设置世界变换矩阵。如果<strong>combine</strong>为真，指定的<strong>矩阵</strong>将与当前矩阵结合；否则，它将取代当前矩阵。</p>
<p><strong>See also</strong> <a href="#worldTransform">worldTransform</a>(), <a href="#transform">transform</a>(), and <a href="#setTransform">setTransform</a>().</p>
<h3><span id="void-qpainter-shear-qreal-sh-qreal-sv">void QPainter::shear( <em>sh</em>,  <em>sv</em>)</span><a href="#void-qpainter-shear-qreal-sh-qreal-sv" class="header-anchor">#</a></h3><p>通过（<strong>sh</strong>，<strong>sv</strong>）剪切坐标系。</p>
<p><strong>See also</strong> <a href="#setWorldTransform">setWorldTransform</a>() and <a href="#coordinate-transformations">Coordinate Transformations</a>.</p>
<h3><span id="void-qpainter-strokepath-const-qpainterpath-amp-path-const-qpen-amp-pen">void QPainter::strokePath(const  &amp;<em>path</em>, const  &amp;<em>pen</em>)</span><a href="#void-qpainter-strokepath-const-qpainterpath-amp-path-const-qpen-amp-pen" class="header-anchor">#</a></h3><p>用<strong>pen</strong>指定的笔绘制路径<strong>path</strong>的轮廓（笔触）。</p>
<p><strong>See also</strong> <a href="#fillPath">fillPath</a>() and <a href="#drawing">Drawing</a>.</p>
<h3><span id="bool-qpainter-testrenderhint-qpainter-renderhint-hint-const">bool QPainter::testRenderHint( <em>hint</em>) const</span><a href="#bool-qpainter-testrenderhint-qpainter-renderhint-hint-const" class="header-anchor">#</a></h3><p>如果<strong>hint</strong>被设置，返回 “true”；否则返回 “false”。</p>
<p><strong>See also</strong> <a href="#renderHints">renderHints</a>() and <a href="#setRenderHint">setRenderHint</a>().</p>
<h3><span id="const-qtransform-amp-qpainter-transform-const">const  &amp;QPainter::transform() const</span><a href="#const-qtransform-amp-qpainter-transform-const" class="header-anchor">#</a></h3><p><a href="#worldTransform">worldTransform</a>()的别名。返回世界变换矩阵。</p>
<p><strong>See also</strong> <a href="#setTransform">setTransform</a>() and <a href="#worldTransform">worldTransform</a>().</p>
<h3><span id="void-qpainter-translate-const-qpointf-amp-offset">void QPainter::translate(const  &amp;<em>offset</em>)</span><a href="#void-qpainter-translate-const-qpointf-amp-offset" class="header-anchor">#</a></h3><p>通过给定的<em>offset</em>平移坐标系；即给定的<em>offset</em>被添加到点上。</p>
<p><strong>See also</strong> <a href="#setWorldTransform">setWorldTransform</a>() and <a href="#coordinate-transformations">Coordinate Transformations</a>.</p>
<h3><span id="void-qpainter-translate-const-qpoint-amp-offset">void QPainter::translate(const  &amp;<em>offset</em>)</span><a href="#void-qpainter-translate-const-qpoint-amp-offset" class="header-anchor">#</a></h3><p>这是一个重载函数。</p>
<p>通过给定的<em>offset</em>平移坐标系。</p>
<h3><span id="void-qpainter-translate-qreal-dx-qreal-dy">void QPainter::translate( <em>dx</em>,  <em>dy</em>)</span><a href="#void-qpainter-translate-qreal-dx-qreal-dy" class="header-anchor">#</a></h3><p>这是一个重载函数。</p>
<p>通过矢量（<em>dx</em>, <em>dy</em>）平移坐标系。</p>
<h3><span id="bool-qpainter-viewtransformenabled-const">bool QPainter::viewTransformEnabled() const</span><a href="#bool-qpainter-viewtransformenabled-const" class="header-anchor">#</a></h3><p>如果视图转换被启用，返回 “true”；否则返回false。</p>
<p><strong>See also</strong> <a href="#setViewTransformEnabled">setViewTransformEnabled</a>() and <a href="#worldTransform">worldTransform</a>().</p>
<h3><span id="qrect-qpainter-viewport-const"> QPainter::viewport() const</span><a href="#qrect-qpainter-viewport-const" class="header-anchor">#</a></h3><p>返回视口的矩形。</p>
<p><strong>See also</strong> <a href="#setViewport">setViewport</a>() and <a href="#setViewTransformEnabled">setViewTransformEnabled</a>().</p>
<h3><span id="qrect-qpainter-window-const"> QPainter::window() const</span><a href="#qrect-qpainter-window-const" class="header-anchor">#</a></h3><p>返回窗口矩形。</p>
<p><strong>See also</strong> <a href="#setWindow">setWindow</a>() and <a href="#setViewTransformEnabled">setViewTransformEnabled</a>().</p>
<h3><span id="bool-qpainter-worldmatrixenabled-const">bool QPainter::worldMatrixEnabled() const</span><a href="#bool-qpainter-worldmatrixenabled-const" class="header-anchor">#</a></h3><p>如果世界转换被启用，返回<code>true</code>；否则返回false。</p>
<p><strong>See also</strong> <a href="#setWorldMatrixEnabled">setWorldMatrixEnabled</a>(), <a href="#worldTransform">worldTransform</a>(), and <a href="qt-6/coordsys.html">Coordinate System</a>.</p>
<h3><span id="const-qtransform-amp-qpainter-worldtransform-const">const  &amp;QPainter::worldTransform() const</span><a href="#const-qtransform-amp-qpainter-worldtransform-const" class="header-anchor">#</a></h3><p>返回世界变换矩阵。</p>
<p><strong>See also</strong> <a href="#setWorldTransform">setWorldTransform</a>().</p>

            </div>
            <hr>
            <div>
              <div class="post-metas mb-3">
                
                
                  <div class="post-meta">
                    <i class="iconfont icon-tags"></i>
                    
                      <a class="hover-with-bg" href="/tags/P/">P</a>
                    
                  </div>
                
              </div>
              
                <p class="note note-warning">
                  
                    本博客所有文章除特别声明外，均采用 <a target="_blank" href="https://creativecommons.org/licenses/by-sa/4.0/deed.zh" rel="nofollow noopener noopener">CC BY-SA 4.0 协议</a> ，转载请注明出处！
                  
                </p>
              
              
                <div class="post-prevnext">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/2022/03/02/QtDocumentCN/Src/P/QtPlugin/QtPlugin/">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">QtPlugin类</span>
                        <span class="visible-mobile">上一篇</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2022/03/02/QtDocumentCN/Src/R/QReadLocker/QReadLocker/">
                        <span class="hidden-mobile">QReadLocker类</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
              <!-- Comments -->
              <article class="comments" id="comments" lazyload>
                
                  
                
                
  <div id="lv-container" data-id="city" data-uid="MTAyMC81NTMzMi8zMTc5OQ==">
    <script type="text/javascript">
      Fluid.utils.loadComments('#lv-container', function() {
        Fluid.utils.createScript('https://cdn-city.livere.com/js/embed.dist.js');
      });
    </script>
    <noscript>Please enable JavaScript to view the comments</noscript>
  </div>


              </article>
            
          </article>
        </div>
      </div>
    </div>
    
      <div class="d-none d-lg-block col-lg-2 toc-container" id="toc-ctn">
        <div id="toc">
  <p class="toc-header"><i class="iconfont icon-list"></i>&nbsp;目录</p>
  <div class="toc-body" id="toc-body"></div>
</div>

      </div>
    
  </div>
</div>

<!-- Custom -->


    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v"
                 for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>
    

    
  </main>

  <footer class="text-center mt-5 py-3">
  <div class="footer-content">
     <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> 
  </div>
  

  

  
</footer>


  <!-- SCRIPTS -->
  
  <script  src="https://cdn.jsdelivr.net/npm/nprogress@0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/nprogress@0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js" ></script>
<script  src="https://cdn.jsdelivr.net/npm/bootstrap@4/dist/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>

<!-- Plugins -->


  <script  src="/js/local-search.js" ></script>



  
    <script  src="/js/img-lazyload.js" ></script>
  



  



  
    <script  src="https://cdn.jsdelivr.net/npm/tocbot@4/dist/tocbot.min.js" ></script>
  
  
    <script  src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3/dist/jquery.fancybox.min.js" ></script>
  
  
    <script  src="https://cdn.jsdelivr.net/npm/anchor-js@4/anchor.min.js" ></script>
  
  
    <script defer src="https://cdn.jsdelivr.net/npm/clipboard@2/dist/clipboard.min.js" ></script>
  






  <script  src="https://cdn.jsdelivr.net/npm/typed.js@2/lib/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var title = document.getElementById('subtitle').title;
      
        typing(title);
      
    })(window, document);
  </script>















<!-- 主题的启动项 保持在最底部 -->
<script  src="/js/boot.js" ></script>


</body>
</html>
