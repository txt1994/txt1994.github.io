

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=auto>



<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/logo.jpg">
  <link rel="icon" href="/img/logo.jpg">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
    <meta http-equiv="Content-Security-Policy" content="upgrade-insecure-requests">
  
  <meta name="theme-color" content="#6aa84f">
  <meta name="author" content="John Doe">
  <meta name="keywords" content="">
  
    <meta name="description" content="QPixmap Class 公共函数 静态公共成员 相关非成员 详细描述 读取和写入图像文件 Pixmap资料 Pixmap转换 像素图转换   成员函数文档 QPixmap::QPixmap(QPixmap &amp;&amp;other) QPixmap::QPixmap(const QPixmap &amp;pixmap) QPixmap::QPixmap(const char *">
<meta property="og:type" content="article">
<meta property="og:title" content="QPixmap类">
<meta property="og:url" content="https://txt1994.github.io/2022/03/02/QtDocumentCN/Src/P/QPixmap/QPixmap/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:description" content="QPixmap Class 公共函数 静态公共成员 相关非成员 详细描述 读取和写入图像文件 Pixmap资料 Pixmap转换 像素图转换   成员函数文档 QPixmap::QPixmap(QPixmap &amp;&amp;other) QPixmap::QPixmap(const QPixmap &amp;pixmap) QPixmap::QPixmap(const char *">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://doc.qt.io/qt-6/images/qimage-scaling.png">
<meta property="article:published_time" content="2022-03-02T06:47:47.000Z">
<meta property="article:modified_time" content="2022-03-18T16:50:39.983Z">
<meta property="article:author" content="John Doe">
<meta property="article:tag" content="P">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="https://doc.qt.io/qt-6/images/qimage-scaling.png">
  
  
  <title>QPixmap类 - Hexo</title>

  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4/dist/css/bootstrap.min.css" />


  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/github-markdown-css@4/github-markdown.min.css" />
  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/hint.css@2/hint.min.css" />

  
    
    
      
      <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@10/styles/github-gist.min.css" />
    
  

  
    <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3/dist/jquery.fancybox.min.css" />
  


<!-- 主题依赖的图标库，不要自行修改 -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_ba1fz6golrf.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_lbnruvf0jn.css">


<link  rel="stylesheet" href="/css/main.css" />

<!-- 自定义样式保持在最底部 -->

  
<link rel="stylesheet" href="/css/style.css">



  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    var CONFIG = {"hostname":"txt1994.github.io","root":"/","version":"1.8.14","typing":{"enable":true,"typeSpeed":70,"cursorChar":"_","loop":false},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"right","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"copy_btn":true,"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":false,"baidu":null,"google":null,"gtag":null,"tencent":{"sid":null,"cid":null},"woyaola":null,"cnzz":null,"leancloud":{"app_id":null,"app_key":null,"server_url":null,"path":"window.location.pathname","ignore_local":false}},"search_path":"/local-search.xml"};
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
<meta name="generator" content="Hexo 6.1.0">
<style>.github-emoji { position: relative; display: inline-block; width: 1.2em; min-height: 1.2em; overflow: hidden; vertical-align: top; color: transparent; }  .github-emoji > span { position: relative; z-index: 10; }  .github-emoji img, .github-emoji .fancybox { margin: 0 !important; padding: 0 !important; border: none !important; outline: none !important; text-decoration: none !important; user-select: none !important; cursor: auto !important; }  .github-emoji img { height: 1.2em !important; width: 1.2em !important; position: absolute !important; left: 50% !important; top: 50% !important; transform: translate(-50%, -50%) !important; user-select: none !important; cursor: auto !important; } .github-emoji-fallback { color: inherit; } .github-emoji-fallback img { opacity: 0 !important; }</style>
</head>


<body>
  <header style="height: 70vh;">
    <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/">
      <strong>txt1994s</strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/">
                <i class="iconfont icon-home-fill"></i>
                首页
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/">
                <i class="iconfont icon-archive-fill"></i>
                归档
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/">
                <i class="iconfont icon-tags-fill"></i>
                标签
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/">
                <i class="iconfont icon-user-fill"></i>
                关于
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/links/">
                <i class="iconfont icon-link-fill"></i>
                友联
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              &nbsp;<i class="iconfont icon-search"></i>&nbsp;
            </a>
          </li>
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">&nbsp;<i
                class="iconfont icon-dark" id="color-toggle-icon"></i>&nbsp;</a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

    <div class="banner" id="banner" parallax=true
         style="background: url('/img/default.png') no-repeat center center;
           background-size: cover;">
      <div class="full-bg-img">
        <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
          <div class="page-header text-center fade-in-up">
            <span class="h2" id="subtitle" title="QPixmap类">
              
            </span>

            
              <div class="mt-3">
  
  
    <span class="post-meta">
      <i class="iconfont icon-date-fill" aria-hidden="true"></i>
      <time datetime="2022-03-02 14:47" pubdate>
        2022年3月2日 下午
      </time>
    </span>
  
</div>

<div class="mt-1">
  
    <span class="post-meta mr-2">
      <i class="iconfont icon-chart"></i>
      19k 字
    </span>
  

  
    <span class="post-meta mr-2">
      <i class="iconfont icon-clock-fill"></i>
      
      
      161 分钟
    </span>
  

  
  
</div>

            
          </div>

          
        </div>
      </div>
    </div>
  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="d-none d-lg-block col-lg-2"></div>
    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div class="py-5" id="board">
          <article class="post-content mx-auto">
            <!-- SEO header -->
            <h1 style="display: none">QPixmap类</h1>
            
              <p class="note note-info">
                
                  本文最后更新于：2022年3月19日 凌晨
                
              </p>
            
            <div class="markdown-body">
              <div class="toc">

<!-- toc -->

<ul>
<li><a href="#qpixmap-class">QPixmap Class</a><ul>
<li><a href="#gong-gong-han-shu">公共函数</a></li>
<li><a href="#jing-tai-gong-gong-cheng-yuan">静态公共成员</a></li>
<li><a href="#xiang-guan-fei-cheng-yuan">相关非成员</a></li>
<li><a href="#xiang-xi-miao-shu">详细描述</a><ul>
<li><a href="#du-qu-he-xie-ru-tu-xiang-wen-jian">读取和写入图像文件</a></li>
<li><a href="#pixmap-zi-liao">Pixmap资料</a></li>
<li><a href="#pixmap-zhuan-huan">Pixmap转换</a></li>
<li><a href="#xiang-su-tu-zhuan-huan">像素图转换</a></li>
</ul>
</li>
<li><a href="#cheng-yuan-han-shu-wen-dang">成员函数文档</a><ul>
<li><a href="#qpixmap-qpixmap-qpixmap-qpixmap-other">QPixmap::QPixmap(</a><a href="#QPixmap">QPixmap</a> &amp;&amp;<em>other</em>)</li>
<li><a href="#qpixmap-qpixmap-const-qpixmap-qpixmap-pixmap">QPixmap::QPixmap(const </a><a href="#QPixmap">QPixmap</a> &amp;<em>pixmap</em>)</li>
<li><a href="#qpixmap-qpixmap-const-char-const-xpm">QPixmap::QPixmap(const char *const [] <em>xpm</em>)</a></li>
<li><a href="#qpixmap-qpixmap-const-qstring-qstring-html-filename-const-char-format-nullptr-qt-imageconversionflags-qt-html-imageconversionflag-enum-flags-qt-autocolor">QPixmap::QPixmap(const </a><a href="qstring.html">QString</a> &amp;<em>fileName</em>, const char *<em>format</em> = nullptr, <a href="qt.html#ImageConversionFlag-enum">Qt::ImageConversionFlags</a> <em>flags</em> = Qt::AutoColor)</li>
<li><a href="#qpixmap-qpixmap-const-qsize-qsize-html-size">QPixmap::QPixmap(const </a><a href="qsize.html">QSize</a> &amp;<em>size</em>)</li>
<li><a href="#qpixmap-qpixmap-int-width-int-height">QPixmap::QPixmap(int <em>width</em>, int <em>height</em>)</a></li>
<li><a href="#qpixmap-qpixmap">QPixmap::QPixmap()</a></li>
<li><a href="#since-5-2-qpixmap-qpixmap-qpixmap-operator-qpixmap-qpixmap-other"><code>[since 5.2]</code></a><a href="#QPixmap">QPixmap</a> &amp;QPixmap::operator=(<a href="#QPixmap">QPixmap</a> &amp;&amp;<em>other</em>)</li>
<li><a href="#qpixmap-qpixmap-qpixmap-operator-const-qpixmap-qpixmap-pixmap">QPixmap</a></li>
<li><a href="#virtual-qpixmap-qpixmap"><code>[virtual]</code>QPixmap::~QPixmap()</a></li>
<li><a href="#qint64-qtglobal-html-qint64-typedef-qpixmap-cachekey-const">qint64</a></li>
<li><a href="#bool-qpixmap-convertfromimage-const-qimage-qimage-html-image-qt-imageconversionflags-qt-html-imageconversionflag-enum-flags-qt-autocolor">bool QPixmap::convertFromImage(const </a><a href="qimage.html">QImage</a> &amp;<em>image</em>, <a href="qt.html#ImageConversionFlag-enum">Qt::ImageConversionFlags</a> <em>flags</em> = Qt::AutoColor)</li>
<li><a href="#qpixmap-qpixmap-qpixmap-copy-const-qrect-qrect-html-rectangle-qrect-const-1">QPixmap</a></li>
<li><a href="#qpixmap-qpixmap-qpixmap-copy-int-x-int-y-int-width-int-height-const-2">QPixmap</a></li>
<li><a href="#qbitmap-qbitmap-html-qpixmap-createheuristicmask-bool-cliptight-true-const">QBitmap</a></li>
<li><a href="#qbitmap-qbitmap-html-qpixmap-createmaskfromcolor-const-qcolor-qcolor-html-maskcolor-qt-maskmode-qt-html-maskmode-enum-mode-qt-maskincolor-const-1">QBitmap</a></li>
<li><a href="#static-int-qpixmap-defaultdepth"><code>[static]</code>int QPixmap::defaultDepth()</a></li>
<li><a href="#int-qpixmap-depth-const">int QPixmap::depth() const</a></li>
<li><a href="#void-qpixmap-detach">void QPixmap::detach()</a></li>
<li><a href="#qsizef-qsizef-html-qpixmap-deviceindependentsize-const">QSizeF</a></li>
<li><a href="#qreal-qtglobal-html-qreal-typedef-qpixmap-devicepixelratio-const">qreal</a></li>
<li><a href="#void-qpixmap-fill-const-qcolor-qcolor-html-color-qt-white">void QPixmap::fill(const </a><a href="qcolor.html">QColor</a> &amp;<em>color</em> = Qt::white)</li>
<li><a href="#static-qpixmap-qpixmap-qpixmap-fromimage-const-qimage-qimage-html-image-qt-imageconversionflags-qt-html-imageconversionflag-enum-flags-qt-autocolor"><code>[static]</code></a><a href="#QPixmap">QPixmap</a> QPixmap::fromImage(const <a href="qimage.html">QImage</a> &amp;<em>image</em>, <a href="qt.html#ImageConversionFlag-enum">Qt::ImageConversionFlags</a> <em>flags</em> = Qt::AutoColor)</li>
<li><a href="#static-since-5-3-qpixmap-qpixmap-qpixmap-fromimage-qimage-qimage-html-image-qt-imageconversionflags-qt-html-imageconversionflag-enum-flags-qt-autocolor"><code>[static, since 5.3]</code></a><a href="#QPixmap">QPixmap</a> QPixmap::fromImage(<a href="qimage.html">QImage</a> &amp;&amp;<em>image</em>, <a href="qt.html#ImageConversionFlag-enum">Qt::ImageConversionFlags</a> <em>flags</em> = Qt::AutoColor)</li>
<li><a href="#static-qpixmap-qpixmap-qpixmap-fromimagereader-qimagereader-qimagereader-html-imagereader-qt-imageconversionflags-qt-html-imageconversionflag-enum-flags-qt-autocolor"><code>[static]</code></a><a href="#QPixmap">QPixmap</a> QPixmap::fromImageReader(<a href="qimagereader.html">QImageReader</a> *<em>imageReader</em>, <a href="qt.html#ImageConversionFlag-enum">Qt::ImageConversionFlags</a> <em>flags</em> = Qt::AutoColor)</li>
<li><a href="#bool-qpixmap-hasalpha-const">bool QPixmap::hasAlpha() const</a></li>
<li><a href="#bool-qpixmap-hasalphachannel-const">bool QPixmap::hasAlphaChannel() const</a></li>
<li><a href="#int-qpixmap-height-const">int QPixmap::height() const</a></li>
<li><a href="#bool-qpixmap-isnull-const">bool QPixmap::isNull() const</a></li>
<li><a href="#bool-qpixmap-isqbitmap-const">bool QPixmap::isQBitmap() const</a></li>
<li><a href="#bool-qpixmap-load-const-qstring-qstring-html-filename-const-char-format-nullptr-qt-imageconversionflags-qt-html-imageconversionflag-enum-flags-qt-autocolor">bool QPixmap::load(const </a><a href="qstring.html">QString</a> &amp;<em>fileName</em>, const char *<em>format</em> = nullptr, <a href="qt.html#ImageConversionFlag-enum">Qt::ImageConversionFlags</a> <em>flags</em> = Qt::AutoColor)</li>
<li><a href="#bool-qpixmap-loadfromdata-const-uchar-qtglobal-html-uchar-typedef-data-uint-qtglobal-html-uint-typedef-len-const-char-format-nullptr-qt-imageconversionflags-qt-html-imageconversionflag-enum-flags-qt-autocolor">bool QPixmap::loadFromData(const </a><a href="qtglobal.html#uchar-typedef">uchar</a> *<em>data</em>, <a href="qtglobal.html#uint-typedef">uint</a> <em>len</em>, const char *<em>format</em> = nullptr, <a href="qt.html#ImageConversionFlag-enum">Qt::ImageConversionFlags</a> <em>flags</em> = Qt::AutoColor)</li>
<li><a href="#bool-qpixmap-loadfromdata-const-qbytearray-qbytearray-html-data-const-char-format-nullptr-qt-imageconversionflags-qt-html-imageconversionflag-enum-flags-qt-autocolor">bool QPixmap::loadFromData(const </a><a href="qbytearray.html">QByteArray</a> &amp;<em>data</em>, const char *<em>format</em> = nullptr, <a href="qt.html#ImageConversionFlag-enum">Qt::ImageConversionFlags</a> <em>flags</em> = Qt::AutoColor)</li>
<li><a href="#qbitmap-qbitmap-html-qpixmap-mask-const-2">QBitmap</a></li>
<li><a href="#qrect-qrect-html-qpixmap-rect-const">QRect</a></li>
<li><a href="#bool-qpixmap-save-const-qstring-qstring-html-filename-const-char-format-nullptr-int-quality-1-const">bool QPixmap::save(const </a><a href="qstring.html">QString</a> &amp;<em>fileName</em>, const char *<em>format</em> = nullptr, int <em>quality</em> = -1) const</li>
<li><a href="#bool-qpixmap-save-qiodevice-qiodevice-html-device-const-char-format-nullptr-int-quality-1-const">bool QPixmap::save(</a><a href="qiodevice.html">QIODevice</a> *<em>device</em>, const char *<em>format</em> = nullptr, int <em>quality</em> = -1) const</li>
<li><a href="#qpixmap-qpixmap-qpixmap-scaled-const-qsize-qsize-html-size-qt-aspectratiomode-qt-html-aspectratiomode-enum-aspectratiomode-qt-ignoreaspectratio-qt-transformationmode-qt-html-transformationmode-enum-transformmode-qt-fasttransformation-const-3">QPixmap</a></li>
<li><a href="#qpixmap-qpixmap-qpixmap-scaled-int-width-int-height-qt-aspectratiomode-qt-html-aspectratiomode-enum-aspectratiomode-qt-ignoreaspectratio-qt-transformationmode-qt-html-transformationmode-enum-transformmode-qt-fasttransformation-const-4">QPixmap</a></li>
<li><a href="#qpixmap-qpixmap-qpixmap-scaledtoheight-int-height-qt-transformationmode-qt-html-transformationmode-enum-mode-qt-fasttransformation-const-5">QPixmap</a></li>
<li><a href="#qpixmap-qpixmap-qpixmap-scaledtowidth-int-width-qt-transformationmode-qt-html-transformationmode-enum-mode-qt-fasttransformation-const-6">QPixmap</a></li>
<li><a href="#void-qpixmap-scroll-int-dx-int-dy-int-x-int-y-int-width-int-height-qregion-qregion-html-exposed-nullptr">void QPixmap::scroll(int <em>dx</em>, int <em>dy</em>, int <em>x</em>, int <em>y</em>, int <em>width</em>, int <em>height</em>, </a><a href="qregion.html">QRegion</a> *<em>exposed</em> = nullptr)</li>
<li><a href="#void-qpixmap-scroll-int-dx-int-dy-const-qrect-qrect-html-rect-qregion-qregion-html-exposed-nullptr">void QPixmap::scroll(int <em>dx</em>, int <em>dy</em>, const </a><a href="qrect.html">QRect</a> &amp;<em>rect</em>, <a href="qregion.html">QRegion</a> *<em>exposed</em> = nullptr)</li>
<li><a href="#void-qpixmap-setdevicepixelratio-qreal-qtglobal-html-qreal-typedef-scalefactor">void QPixmap::setDevicePixelRatio(</a><a href="qtglobal.html#qreal-typedef">qreal</a> <em>scaleFactor</em>)</li>
<li><a href="#void-qpixmap-setmask-const-qbitmap-qbitmap-html-mask">void QPixmap::setMask(const </a><a href="qbitmap.html">QBitmap</a> &amp;<em>mask</em>)</li>
<li><a href="#qsize-qsize-html-qpixmap-size-const">QSize</a></li>
<li><a href="#void-qpixmap-swap-qpixmap-qpixmap-other">void QPixmap::swap(</a><a href="#QPixmap">QPixmap</a> &amp;<em>other</em>)</li>
<li><a href="#qimage-qimage-html-qpixmap-toimage-const">QImage</a></li>
<li><a href="#qpixmap-qpixmap-qpixmap-transformed-const-qtransform-qtransform-html-transform-qt-transformationmode-qt-html-transformationmode-enum-mode-qt-fasttransformation-const-7">QPixmap</a></li>
<li><a href="#static-qtransform-qtransform-html-qpixmap-truematrix-const-qtransform-qtransform-html-matrix-int-width-int-height"><code>[static]</code></a><a href="qtransform.html">QTransform</a> QPixmap::trueMatrix(const <a href="qtransform.html">QTransform</a> &amp;<em>matrix</em>, int <em>width</em>, int <em>height</em>)</li>
<li><a href="#int-qpixmap-width-const">int QPixmap::width() const</a></li>
<li><a href="#qvariant-qvariant-html-qpixmap-operator-qvariant-const">QVariant</a></li>
<li><a href="#bool-qpixmap-operator-const">bool QPixmap::operator!() const</a></li>
</ul>
</li>
<li><a href="#xiang-guan-fei-cheng-yuan-1">相关非成员</a><ul>
<li><a href="#qdatastream-qdatastream-html-operator-qdatastream-qdatastream-html-stream-const-qpixmap-qpixmap-pixmap">QDataStream</a></li>
<li><a href="#qdatastream-qdatastream-html-operator-qdatastream-qdatastream-html-stream-qpixmap-qpixmap-pixmap-1">QDataStream</a></li>
</ul>
</li>
</ul>
</li>
</ul>
<!-- tocstop -->

</div>
# QPixmap Class

<p>QPixmap类是一个屏幕外的图像表示，可以作为一个绘画设备使用。<a href="#%E8%AF%A6%E7%BB%86%E6%8F%8F%E8%BF%B0">More…</a></p>
<table>
<thead>
<tr>
<th>Header:</th>
<th>#include <qpixmap></qpixmap></th>
</tr>
</thead>
<tbody><tr>
<td>CMake:</td>
<td>find_package(Qt6 COMPONENTS Gui REQUIRED) target_link_libraries(mytarget PRIVATE Qt6::Gui)</td>
</tr>
<tr>
<td>qmake:</td>
<td>QT += gui</td>
</tr>
<tr>
<td>Inherits:</td>
<td><a href="qpaintdevice.html">QPaintDevice</a></td>
</tr>
<tr>
<td>Inherited By:</td>
<td><a href="qbitmap.html">QBitmap</a></td>
</tr>
</tbody></table>
<ul>
<li><a href="qpixmap-members.html">List of all members, including inherited members</a></li>
</ul>
<h2><span id="gong-gong-han-shu">公共函数</span><a href="#gong-gong-han-shu" class="header-anchor">#</a></h2><table>
<thead>
<tr>
<th></th>
<th><strong><a href="#QPixmap-5">QPixmap</a></strong>(QPixmap &amp;&amp;<em>other</em>)</th>
</tr>
</thead>
<tbody><tr>
<td></td>
<td><strong><a href="#QPixmap-4">QPixmap</a></strong>(const QPixmap &amp;<em>pixmap</em>)</td>
</tr>
<tr>
<td></td>
<td><strong><a href="#QPixmap-3">QPixmap</a></strong>(const char *const [] <em>xpm</em>)</td>
</tr>
<tr>
<td></td>
<td><strong><a href="#QPixmap-2">QPixmap</a></strong>(const QString &amp;<em>fileName</em>, const char *<em>format</em> = nullptr, Qt::ImageConversionFlags <em>flags</em> = Qt::AutoColor)</td>
</tr>
<tr>
<td></td>
<td><strong><a href="#QPixmap-1">QPixmap</a></strong>(const QSize &amp;<em>size</em>)</td>
</tr>
<tr>
<td></td>
<td><strong><a href="#QPixmap">QPixmap</a></strong>(int <em>width</em>, int <em>height</em>)</td>
</tr>
<tr>
<td></td>
<td><strong><a href="#QPixmap">QPixmap</a></strong>()</td>
</tr>
<tr>
<td>QPixmap &amp;</td>
<td><strong><a href="#operator-eq-1">operator=</a></strong>(QPixmap &amp;&amp;<em>other</em>)</td>
</tr>
<tr>
<td>QPixmap &amp;</td>
<td><strong><a href="#operator-eq">operator=</a></strong>(const QPixmap &amp;<em>pixmap</em>)</td>
</tr>
<tr>
<td>virtual</td>
<td><strong><a href="#dtor.QPixmap">~QPixmap</a></strong>()</td>
</tr>
<tr>
<td>qint64</td>
<td><strong><a href="#cacheKey">cacheKey</a></strong>() const</td>
</tr>
<tr>
<td>bool</td>
<td><strong><a href="#convertFromImage">convertFromImage</a></strong>(const QImage &amp;<em>image</em>, Qt::ImageConversionFlags <em>flags</em> = Qt::AutoColor)</td>
</tr>
<tr>
<td>QPixmap</td>
<td><strong><a href="#copy">copy</a></strong>(const QRect &amp;<em>rectangle</em> = QRect()) const</td>
</tr>
<tr>
<td>QPixmap</td>
<td><strong><a href="#copy-1">copy</a></strong>(int <em>x</em>, int <em>y</em>, int <em>width</em>, int <em>height</em>) const</td>
</tr>
<tr>
<td>QBitmap</td>
<td><strong><a href="#createHeuristicMask">createHeuristicMask</a></strong>(bool <em>clipTight</em> = true) const</td>
</tr>
<tr>
<td>QBitmap</td>
<td><strong><a href="#createMaskFromColor">createMaskFromColor</a></strong>(const QColor &amp;<em>maskColor</em>, Qt::MaskMode <em>mode</em> = Qt::MaskInColor) const</td>
</tr>
<tr>
<td>int</td>
<td><strong><a href="#depth">depth</a></strong>() const</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="#detach">detach</a></strong>()</td>
</tr>
<tr>
<td>QSizeF</td>
<td><strong><a href="#deviceIndependentSize">deviceIndependentSize</a></strong>() const</td>
</tr>
<tr>
<td>qreal</td>
<td><strong><a href="#devicePixelRatio">devicePixelRatio</a></strong>() const</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="#fill">fill</a></strong>(const QColor &amp;<em>color</em> = Qt::white)</td>
</tr>
<tr>
<td>bool</td>
<td><strong><a href="#hasAlpha">hasAlpha</a></strong>() const</td>
</tr>
<tr>
<td>bool</td>
<td><strong><a href="#hasAlphaChannel">hasAlphaChannel</a></strong>() const</td>
</tr>
<tr>
<td>int</td>
<td><strong><a href="#height">height</a></strong>() const</td>
</tr>
<tr>
<td>bool</td>
<td><strong><a href="#isNull">isNull</a></strong>() const</td>
</tr>
<tr>
<td>bool</td>
<td><strong><a href="#isQBitmap">isQBitmap</a></strong>() const</td>
</tr>
<tr>
<td>bool</td>
<td><strong><a href="#load">load</a></strong>(const QString &amp;<em>fileName</em>, const char *<em>format</em> = nullptr, Qt::ImageConversionFlags <em>flags</em> = Qt::AutoColor)</td>
</tr>
<tr>
<td>bool</td>
<td><strong><a href="#loadFromData">loadFromData</a></strong>(const uchar *<em>data</em>, uint <em>len</em>, const char *<em>format</em> = nullptr, Qt::ImageConversionFlags <em>flags</em> = Qt::AutoColor)</td>
</tr>
<tr>
<td>bool</td>
<td><strong><a href="#loadFromData-1">loadFromData</a></strong>(const QByteArray &amp;<em>data</em>, const char *<em>format</em> = nullptr, Qt::ImageConversionFlags <em>flags</em> = Qt::AutoColor)</td>
</tr>
<tr>
<td>QBitmap</td>
<td><strong><a href="#mask">mask</a></strong>() const</td>
</tr>
<tr>
<td>QRect</td>
<td><strong><a href="#rect">rect</a></strong>() const</td>
</tr>
<tr>
<td>bool</td>
<td><strong><a href="#save">save</a></strong>(const QString &amp;<em>fileName</em>, const char *<em>format</em> = nullptr, int <em>quality</em> = -1) const</td>
</tr>
<tr>
<td>bool</td>
<td><strong><a href="#save-1">save</a></strong>(QIODevice *<em>device</em>, const char *<em>format</em> = nullptr, int <em>quality</em> = -1) const</td>
</tr>
<tr>
<td>QPixmap</td>
<td><strong><a href="#scaled">scaled</a></strong>(const QSize &amp;<em>size</em>, Qt::AspectRatioMode <em>aspectRatioMode</em> = Qt::IgnoreAspectRatio, Qt::TransformationMode <em>transformMode</em> = Qt::FastTransformation) const</td>
</tr>
<tr>
<td>QPixmap</td>
<td><strong><a href="#scaled-1">scaled</a></strong>(int <em>width</em>, int <em>height</em>, Qt::AspectRatioMode <em>aspectRatioMode</em> = Qt::IgnoreAspectRatio, Qt::TransformationMode <em>transformMode</em> = Qt::FastTransformation) const</td>
</tr>
<tr>
<td>QPixmap</td>
<td><strong><a href="#scaledToHeight">scaledToHeight</a></strong>(int <em>height</em>, Qt::TransformationMode <em>mode</em> = Qt::FastTransformation) const</td>
</tr>
<tr>
<td>QPixmap</td>
<td><strong><a href="#scaledToWidth">scaledToWidth</a></strong>(int <em>width</em>, Qt::TransformationMode <em>mode</em> = Qt::FastTransformation) const</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="#scroll">scroll</a></strong>(int <em>dx</em>, int <em>dy</em>, int <em>x</em>, int <em>y</em>, int <em>width</em>, int <em>height</em>, QRegion *<em>exposed</em> = nullptr)</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="#scroll-1">scroll</a></strong>(int <em>dx</em>, int <em>dy</em>, const QRect &amp;<em>rect</em>, QRegion *<em>exposed</em> = nullptr)</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="#setDevicePixelRatio">setDevicePixelRatio</a></strong>(qreal <em>scaleFactor</em>)</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="#setMask">setMask</a></strong>(const QBitmap &amp;<em>mask</em>)</td>
</tr>
<tr>
<td>QSize</td>
<td><strong><a href="#size">size</a></strong>() const</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="#swap">swap</a></strong>(QPixmap &amp;<em>other</em>)</td>
</tr>
<tr>
<td>QImage</td>
<td><strong><a href="#toImage">toImage</a></strong>() const</td>
</tr>
<tr>
<td>QPixmap</td>
<td><strong><a href="#transformed">transformed</a></strong>(const QTransform &amp;<em>transform</em>, Qt::TransformationMode <em>mode</em> = Qt::FastTransformation) const</td>
</tr>
<tr>
<td>int</td>
<td><strong><a href="#width">width</a></strong>() const</td>
</tr>
<tr>
<td>QVariant</td>
<td><strong><a href="#operator-QVariant">operator QVariant</a></strong>() const</td>
</tr>
<tr>
<td>bool</td>
<td><strong><a href="#operator-not">operator!</a></strong>() const</td>
</tr>
</tbody></table>
<h2><span id="jing-tai-gong-gong-cheng-yuan">静态公共成员</span><a href="#jing-tai-gong-gong-cheng-yuan" class="header-anchor">#</a></h2><table>
<thead>
<tr>
<th>int</th>
<th><strong><a href="#defaultDepth">defaultDepth</a></strong>()</th>
</tr>
</thead>
<tbody><tr>
<td>QPixmap</td>
<td><strong><a href="#fromImage">fromImage</a></strong>(const QImage &amp;<em>image</em>, Qt::ImageConversionFlags <em>flags</em> = Qt::AutoColor)</td>
</tr>
<tr>
<td>QPixmap</td>
<td><strong><a href="#fromImage-1">fromImage</a></strong>(QImage &amp;&amp;<em>image</em>, Qt::ImageConversionFlags <em>flags</em> = Qt::AutoColor)</td>
</tr>
<tr>
<td>QPixmap</td>
<td><strong><a href="#fromImageReader">fromImageReader</a></strong>(QImageReader *<em>imageReader</em>, Qt::ImageConversionFlags <em>flags</em> = Qt::AutoColor)</td>
</tr>
<tr>
<td>QTransform</td>
<td><strong><a href="#trueMatrix">trueMatrix</a></strong>(const QTransform &amp;<em>matrix</em>, int <em>width</em>, int <em>height</em>)</td>
</tr>
</tbody></table>
<h2><span id="xiang-guan-fei-cheng-yuan">相关非成员</span><a href="#xiang-guan-fei-cheng-yuan" class="header-anchor">#</a></h2><table>
<thead>
<tr>
<th>QDataStream &amp;</th>
<th><strong><a href="#operator-lt-lt">operator&lt;&lt;</a></strong>(QDataStream &amp;<em>stream</em>, const QPixmap &amp;<em>pixmap</em>)</th>
</tr>
</thead>
<tbody><tr>
<td>QDataStream &amp;</td>
<td><strong><a href="#operator-gt-gt-1">operator&gt;&gt;</a></strong>(QDataStream &amp;<em>stream</em>, QPixmap &amp;<em>pixmap</em>)</td>
</tr>
</tbody></table>
<h2><span id="xiang-xi-miao-shu">详细描述</span><a href="#xiang-xi-miao-shu" class="header-anchor">#</a></h2><p>Qt提供了四个处理图像数据的类。<a href="qimage.html">QImage</a>, QPixmap, <a href="qbitmap.html">QBitmap</a> 和 <a href="qpicture.html">QPicture</a>。<a href="qimage.html">QImage</a>是为I/O以及直接像素访问和操作而设计和优化的，而QPixmap是为在屏幕上显示图像而设计和优化的。<a href="qbitmap.html">QBitmap</a>只是一个继承了QPixmap的方便类，确保深度为1。 <a href="#isQBitmap">isQBitmap</a>()函数如果一个QPixmap对象真的是位图，则返回<code>true</code>，否则返回<code>false</code>。最后，<a href="qpicture.html">QPicture</a>类是一个绘画设备，可以记录和复制<a href="qpainter.html">QPainter</a>命令。</p>
<p>使用<a href="qlabel.html">QLabel</a>或<a href="qabstractbutton.html">QAbstractButton</a>的一个子类（如<a href="qpushbutton.html">QPushButton</a>和<a href="qtoolbutton.html">QToolButton</a>）可以很容易地将一个QPixmap显示在屏幕上。<a href="qlabel.html">QLabel</a>有一个pixmap属性，而<a href="qabstractbutton.html">QAbstractButton</a>有一个图标属性。</p>
<p>QPixmap对象可以通过值来传递，因为QPixmap类使用隐式数据共享。更多信息，请参见 <a href="implicit-sharing.html">隐式数据共享</a> 文档。QPixmap对象也可以被流化。</p>
<p>注意，像素图中的像素数据是内部的，由底层窗口系统管理。因为QPixmap是一个<a href="qpaintdevice.html">QPaintDevice</a>子类，<a href="qpainter.html">QPainter</a>可以用来直接在像素图上绘画。像素只能通过<a href="qpainter.html">QPainter</a>函数或通过将QPixmap转换为<a href="qimage.html">QImage</a>来访问。然而，<a href="#fill">fill</a>()函数可用于用给定的颜色初始化整个像素图。</p>
<p>有一些函数可以在<a href="qimage.html">QImage</a>和QPixmap之间转换。通常，<a href="qimage.html">QImage</a>类被用来加载一个图像文件，在<a href="qimage.html">QImage</a>对象被转换为QPixmap并显示在屏幕上之前，可以选择对图像数据进行操作。或者，如果不需要处理，图像文件可以直接加载到QPixmap中。</p>
<p>QPixmap提供了一个函数集合，可以用来获取关于像素图的各种信息。此外，还有几个函数可以对像素图进行转换。</p>
<h3><span id="du-qu-he-xie-ru-tu-xiang-wen-jian">读取和写入图像文件</span><a href="#du-qu-he-xie-ru-tu-xiang-wen-jian" class="header-anchor">#</a></h3><p>QPixmap提供了几种读取图像文件的方法。文件可以在构造QPixmap对象时加载，也可以在以后使用<a href="#load">load</a>()或<a href="#loadFromData">loadFromData</a>()函数。当加载图像时，文件名可以是指磁盘上的一个实际文件，也可以是指应用程序的一个嵌入式资源。参见<a href="resources.html">The Qt Resource System</a>概述，了解如何在应用程序的可执行文件中嵌入图像和其他资源文件的细节。</p>
<p>只需调用<a href="#save">save</a>()函数来保存一个QPixmap对象。</p>
<p>支持的文件格式的完整列表可以通过 <a href="qimagereader.html#supportedImageFormats">QImageReader::supportedImageFormats</a>() 和 <a href="qimagewriter.html#supportedImageFormats">QImageWriter::supportedImageFormats</a>() 函数获得。新的文件格式可以作为插件添加。默认情况下，Qt支持以下格式：</p>
<table>
<thead>
<tr>
<th align="center">Format</th>
<th align="center">Description</th>
<th align="center">Qt’s support</th>
</tr>
</thead>
<tbody><tr>
<td align="center">BMP</td>
<td align="center">Windows Bitmap</td>
<td align="center">Read/write</td>
</tr>
<tr>
<td align="center">GIF</td>
<td align="center">Graphic Interchange Format (optional)</td>
<td align="center">Read</td>
</tr>
<tr>
<td align="center">JPG</td>
<td align="center">Joint Photographic Experts Group</td>
<td align="center">Read/write</td>
</tr>
<tr>
<td align="center">JPEG</td>
<td align="center">Joint Photographic Experts Group</td>
<td align="center">Read/write</td>
</tr>
<tr>
<td align="center">PNG</td>
<td align="center">Portable Network Graphics</td>
<td align="center">Read/write</td>
</tr>
<tr>
<td align="center">PBM</td>
<td align="center">Portable Bitmap</td>
<td align="center">Read</td>
</tr>
<tr>
<td align="center">PGM</td>
<td align="center">Portable Graymap</td>
<td align="center">Read</td>
</tr>
<tr>
<td align="center">PPM</td>
<td align="center">Portable Pixmap</td>
<td align="center">Read/write</td>
</tr>
<tr>
<td align="center">XBM</td>
<td align="center">X11 Bitmap</td>
<td align="center">Read/write</td>
</tr>
<tr>
<td align="center">XPM</td>
<td align="center">X11 Pixmap</td>
<td align="center">Read/write</td>
</tr>
</tbody></table>
<h3><span id="pixmap-zi-liao">Pixmap资料</span><a href="#pixmap-zi-liao" class="header-anchor">#</a></h3><p>QPixmap提供了一个函数集合，可以用来获取关于像素图的各种信息：</p>
<table>
<thead>
<tr>
<th align="center"></th>
<th align="center">可用功能</th>
</tr>
</thead>
<tbody><tr>
<td align="center">几何图形</td>
<td align="center"><a href="#size">size</a>()、<a href="#width">width</a>()和<a href="#height">height</a>()函数提供关于像素图大小的信息。<a href="#rect">rect</a>()函数返回图像的包围矩形。</td>
</tr>
<tr>
<td align="center">阿尔法部分</td>
<td align="center"><a href="#hasAlphaChannel">hasAlphaChannel</a>()如果像素图有一个遵守alpha通道的格式，则返回 “true”，否则返回 “false”。<a href="#hasAlpha">hasAlpha</a>()、<a href="#setMask">setMask</a>()和<a href="#mask">mask</a>()函数是遗留的，不应该被使用。它们可能非常慢。<a href="#createHeuristicMask">createHeuristicMask</a>() 函数为此像素图创建并返回 1-bpp 启发式掩码（即 <a href="qbitmap.html">QBitmap</a>）。它的工作方式是从一个角上选择一种颜色，然后从所有的边缘开始削去该颜色的像素。<a href="#createMaskFromColor">createMaskFromColor</a>()函数根据给定的颜色为这个像素图创建并返回一个蒙版(即一个<a href="qbitmap.html">QBitmap</a>)。</td>
</tr>
<tr>
<td align="center">低层信息</td>
<td align="center"><a href="#depth">depth</a>()函数返回像素图的深度。<a href="#defaultDepth">defaultDepth</a>()函数返回默认深度，即应用程序在给定屏幕上使用的深度。<a href="#cacheKey">cacheKey</a>()函数返回一个数字，唯一标识QPixmap对象的内容。</td>
</tr>
</tbody></table>
<h3><span id="pixmap-zhuan-huan">Pixmap转换</span><a href="#pixmap-zhuan-huan" class="header-anchor">#</a></h3><p>一个QPixmap对象可以使用<a href="#toImage">toImage</a>()函数转换为一个<a href="qimage.html">QImage</a>。同样地，一个<a href="qimage.html">QImage</a>可以用<a href="#fromImage">fromImage</a>()转换为一个QPixmap。如果这个操作太昂贵，你可以使用<a href="qbitmap.html#fromImage">QBitmap::fromImage</a>()代替。</p>
<p>要将QPixmap转换为HICON或从HICON转换，你可以分别使用QtWinExtras函数QtWin::toHICON() 和QtWin::fromHICON()。</p>
<h3><span id="xiang-su-tu-zhuan-huan">像素图转换</span><a href="#xiang-su-tu-zhuan-huan" class="header-anchor">#</a></h3><p>QPixmap支持一些函数来创建一个新的像素图，它是原始像素图的一个转换版本。</p>
<p><a href="#scaled">scaled</a>()、<a href="#scaledToWidth">scaledToWidth</a>()和<a href="#scaledToHeight">scaledToHeight</a>()函数返回像素图的缩放副本，而<a href="#copy">copy</a>()函数创建一个QPixmap，是原图的纯拷贝。</p>
<p>transformed](#transformed)()函数返回一个用给定的变换矩阵和变换模式进行变换的像素图副本。在内部，变换矩阵被调整以补偿不需要的平移，即<a href="#transformed">transformed</a>()返回包含原始像素图的所有变换点的最小的像素图。静态的<a href="#trueMatrix">trueMatrix</a>()函数返回用于转换像素图的实际矩阵。</p>
<p><strong>See also</strong> <a href="qbitmap.html">QBitmap</a>, <a href="qimage.html">QImage</a>, <a href="qimagereader.html">QImageReader</a>, and <a href="qimagewriter.html">QImageWriter</a>.</p>
<h2><span id="cheng-yuan-han-shu-wen-dang">成员函数文档</span><a href="#cheng-yuan-han-shu-wen-dang" class="header-anchor">#</a></h2><h3><span id="qpixmap-qpixmap-qpixmap-amp-amp-other">QPixmap::QPixmap( &amp;&amp;<em>other</em>)</span><a href="#qpixmap-qpixmap-qpixmap-amp-amp-other" class="header-anchor">#</a></h3><p>从 <em>other</em> 移动构造一个 QPixmap 实例。</p>
<p><strong>See also</strong> <a href="#swap">swap</a>() and <a href="#operator-eq-1">operator=</a>(QPixmap&amp;&amp;).</p>
<h3><span id="qpixmap-qpixmap-const-qpixmap-amp-pixmap">QPixmap::QPixmap(const  &amp;<em>pixmap</em>)</span><a href="#qpixmap-qpixmap-const-qpixmap-amp-pixmap" class="header-anchor">#</a></h3><p>构造一个作为给定 <em>pixmap</em> 副本的像素图。</p>
<p><strong>See also</strong> <a href="#copy">copy</a>().</p>
<h3><span id="qpixmap-qpixmap-const-char-const-xpm">QPixmap::QPixmap(const char *const [] <em>xpm</em>)</span><a href="#qpixmap-qpixmap-const-char-const-xpm" class="header-anchor">#</a></h3><p>从给定的 <em>xpm</em> 数据构造一个像素图，该数据必须是有效的 XPM 图像。</p>
<p>错误会被默默忽略。</p>
<p>请注意，可以通过使用不寻常的声明稍微压缩 XPM 变量：</p>
<div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-type">static</span> <span class="hljs-type">const</span> <span class="hljs-type">char</span> * <span class="hljs-type">const</span> start_xpm[] = {
    <span class="hljs-string">"16 15 8 1"</span>,
    <span class="hljs-string">"a c #cec6bd"</span>,
    <span class="hljs-comment">// etc.</span>
};</code></pre></div>

<p>额外的 <code>const</code> 使整个定义成为只读的，当应用程序存储在 ROM 中时，这稍微更有效（例如，当代码在共享库中时）和 ROMable。</p>
<h3><span id="qpixmap-qpixmap-const-qstring-amp-filename-const-char-format-nullptr-qt-imageconversionflags-flags-qt-autocolor">QPixmap::QPixmap(const  &amp;<em>fileName</em>, const char *<em>format</em> = nullptr,  <em>flags</em> = Qt::AutoColor)</span><a href="#qpixmap-qpixmap-const-qstring-amp-filename-const-char-format-nullptr-qt-imageconversionflags-flags-qt-autocolor" class="header-anchor">#</a></h3><p>从具有给定 <em>fileName</em> 的文件构造一个像素图。如果文件不存在或格式未知，则像素图变为空像素图。</p>
<p>加载器尝试使用指定的<em>format</em>读取像素图。如果没有指定 <em>format</em>（这是默认值），加载程序会探测文件以查找文件头以猜测文件格式。</p>
<p>文件名既可以指磁盘上的实际文件，也可以指应用程序的嵌入式资源之一。有关如何在应用程序的可执行文件中嵌入图像和其他资源文件的详细信息，请参阅 <a href="resources.html">资源系统</a> 概述。</p>
<p>如果需要修改图像以适应较低分辨率的结果（例如从 32 位转换为 8 位），请使用 <em>flags</em> 来控制转换。</p>
<p><em>fileName</em>、<em>format</em> 和 <em>flags</em> 参数被传递给 <a href="#load">load</a>()。这意味着 <em>fileName</em> 中的数据没有被编译成二进制文件。如果 <em>fileName</em> 包含相对路径（例如，仅文件名），则必须找到相对于运行时工作目录的相关文件。</p>
<p><strong>See also</strong> <a href="#reading-and-writing-image-files">Reading and Writing Image Files</a>.</p>
<h3><span id="qpixmap-qpixmap-const-qsize-amp-size">QPixmap::QPixmap(const  &amp;<em>size</em>)</span><a href="#qpixmap-qpixmap-const-qsize-amp-size" class="header-anchor">#</a></h3><p>这是一个重载函数。</p>
<p>构造一个给定<em>size</em> 的像素图。</p>
<p><strong>警告：</strong> 这将创建一个带有未初始化数据的 QPixmap。 在使用 <a href="qpainter.html">QPainter</a> 绘制之前，调用 <a href="#fill">fill</a>() 以使用适当的颜色填充像素图。</p>
<h3><span id="qpixmap-qpixmap-int-width-int-height">QPixmap::QPixmap(int <em>width</em>, int <em>height</em>)</span><a href="#qpixmap-qpixmap-int-width-int-height" class="header-anchor">#</a></h3><p>用给定的 <em>width</em> 和 <em>height</em> 构造一个像素图。 如果 <em>width</em> 或 <em>height</em> 为零，则构造一个空像素图。</p>
<p><strong>警告：</strong> 这将创建一个带有未初始化数据的 QPixmap。 在使用 <a href="qpainter.html">QPainter</a> 绘制之前，调用 <a href="#fill">fill</a>() 以使用适当的颜色填充像素图。</p>
<p><strong>See also</strong> <a href="#isNull">isNull</a>().</p>
<h3><span id="qpixmap-qpixmap">QPixmap::QPixmap()</span><a href="#qpixmap-qpixmap" class="header-anchor">#</a></h3><p>构造一个 null 像素图。</p>
<p><strong>See also</strong> <a href="#isNull">isNull</a>().</p>
<h3><span id="since-5-2-qpixmap-amp-qpixmap-operator-qpixmap-amp-amp-other"><code>[since 5.2]</code> &amp;QPixmap::operator=( &amp;&amp;<em>other</em>)</span><a href="#since-5-2-qpixmap-amp-qpixmap-operator-qpixmap-amp-amp-other" class="header-anchor">#</a></h3><p>将 <em>other</em> 移动分配给此 <a href>QPixmap</a> 实例。</p>
<p>这个函数引入于Qt 5.2。</p>
<h3><span id="qpixmap-amp-qpixmap-operator-const-qpixmap-amp-pixmap"> &amp;QPixmap::operator=(const  &amp;<em>pixmap</em>)</span><a href="#qpixmap-amp-qpixmap-operator-const-qpixmap-amp-pixmap" class="header-anchor">#</a></h3><p>将给定的 <em>pixmap</em> 分配给此像素图并返回对此像素图的引用。</p>
<p><strong>See also</strong> <a href="#copy">copy</a>() and <a href="#QPixmap">QPixmap</a>().</p>
<h3><span id="virtual-qpixmap-qpixmap"><code>[virtual]</code>QPixmap::~QPixmap()</span><a href="#virtual-qpixmap-qpixmap" class="header-anchor">#</a></h3><p>销毁像素图。</p>
<h3><span id="qint64-qpixmap-cachekey-const"> QPixmap::cacheKey() const</span><a href="#qint64-qpixmap-cachekey-const" class="header-anchor">#</a></h3><p>返回一个标识此 <a href>QPixmap</a> 的数字。 如果不同的 <a href>QPixmap</a> 对象引用相同的内容，则它们只能具有相同的缓存键。</p>
<p>当像素图改变时，cacheKey() 会改变。</p>
<h3><span id="bool-qpixmap-convertfromimage-const-qimage-amp-image-qt-imageconversionflags-flags-qt-autocolor">bool QPixmap::convertFromImage(const  &amp;<em>image</em>,  <em>flags</em> = Qt::AutoColor)</span><a href="#bool-qpixmap-convertfromimage-const-qimage-amp-image-qt-imageconversionflags-flags-qt-autocolor" class="header-anchor">#</a></h3><p>使用指定的 <em>flags</em> 将这个像素图的数据替换为给定的 <em>image</em> 以控制转换。 <em>flags</em> 参数是 <a href="qt.html#ImageConversionFlag-enum">Qt::ImageConversionFlags</a> 的按位或。 为 <em>flags</em> 传递 0 设置所有默认选项。 如果结果是此像素图不为空，则返回 <code>true</code>。</p>
<p>注意：此功能是 Qt 4.6 及更早版本中 Qt 3 支持的一部分。 它已在 4.7 中提升为官方 API 状态，以支持更新像素图的图像，而无需像 <a href="#fromImage">fromImage</a>() 那样创建新的 <a href>QPixmap</a>。</p>
<p><strong>See also</strong> <a href="#fromImage">fromImage</a>().</p>
<h3><span id="qpixmap-qpixmap-copy-const-qrect-amp-rectangle-qrect-const"> QPixmap::copy(const  &amp;<em>rectangle</em> = QRect()) const</span><a href="#qpixmap-qpixmap-copy-const-qrect-amp-rectangle-qrect-const" class="header-anchor">#</a></h3><p>返回一个由给定的<em>rectangle</em>指定的像素图子集的深度拷贝。关于深度拷贝的更多信息，请参阅<a href="implicit-sharing.html">隐式数据共享</a>文档。</p>
<p>如果给定的<em>rectangle</em>是空的，整个图像就被复制了。</p>
<p><strong>See also</strong> <a href="#operator-eq">operator=</a>(), <a href="#QPixmap">QPixmap</a>(), and <a href="#pixmap-transformations">Pixmap Transformations</a>.</p>
<h3><span id="qpixmap-qpixmap-copy-int-x-int-y-int-width-int-height-const"> QPixmap::copy(int <em>x</em>, int <em>y</em>, int <em>width</em>, int <em>height</em>) const</span><a href="#qpixmap-qpixmap-copy-int-x-int-y-int-width-int-height-const" class="header-anchor">#</a></h3><p>这是一个重载函数。</p>
<p>返回由矩形<a href="qrect.html">QRect</a>(<em>x</em>, <em>y</em>, <em>width</em>, <em>height</em>)指定的像素图的子集的深度拷贝。</p>
<h3><span id="qbitmap-qpixmap-createheuristicmask-bool-cliptight-true-const"> QPixmap::createHeuristicMask(bool <em>clipTight</em> = true) const</span><a href="#qbitmap-qpixmap-createheuristicmask-bool-cliptight-true-const" class="header-anchor">#</a></h3><p>为这个像素图创建并返回一个启发式掩码。</p>
<p>该函数的工作原理是从一个角中选择一种颜色，然后从所有的边缘开始削去该颜色的像素。如果<em>clipTight</em>为真（默认），蒙版的大小刚好可以覆盖像素；否则，蒙版会比数据像素大。</p>
<p>遮罩可能不完美，但应该是合理的，所以你可以做如下事情:</p>
<div class="code-wrapper"><pre><code class="hljs c++">QPixmap myPixmap;
myPixmap.<span class="hljs-built_in">setMask</span>(myPixmap.<span class="hljs-built_in">createHeuristicMask</span>());</code></pre></div>

<p>这个函数很慢，因为它涉及到向/从<a href="qimage.html">QImage</a>的转换，以及非琐碎的计算。</p>
<p><strong>See also</strong> <a href="qimage.html#createHeuristicMask">QImage::createHeuristicMask</a>() and <a href="#createMaskFromColor">createMaskFromColor</a>().</p>
<h3><span id="qbitmap-qpixmap-createmaskfromcolor-const-qcolor-amp-maskcolor-qt-maskmode-mode-qt-maskincolor-const"> QPixmap::createMaskFromColor(const  &amp;<em>maskColor</em>,  <em>mode</em> = Qt::MaskInColor) const</span><a href="#qbitmap-qpixmap-createmaskfromcolor-const-qcolor-amp-maskcolor-qt-maskmode-mode-qt-maskincolor-const" class="header-anchor">#</a></h3><p>基于给定的<em>maskColor</em>，为这个像素图创建并返回一个掩码。如果<em>mode</em>是<a href="qt.html#MaskMode-enum">Qt::MaskInColor</a>，所有符合 maskColor 的像素将是透明的。如果<em>mode</em>是<a href="qt.html#MaskMode-enum">Qt::MaskOutColor</a>，所有与MaskColor匹配的像素将是不透明的。</p>
<p>这个函数很慢，因为它涉及到向/从<a href="qimage.html">QImage</a>转换。</p>
<p><strong>See also</strong> <a href="#createHeuristicMask">createHeuristicMask</a>() and <a href="qimage.html#createMaskFromColor">QImage::createMaskFromColor</a>().</p>
<h3><span id="static-int-qpixmap-defaultdepth"><code>[static]</code>int QPixmap::defaultDepth()</span><a href="#static-int-qpixmap-defaultdepth" class="header-anchor">#</a></h3><p>返回应用程序使用的默认像素图深度。</p>
<p>在所有平台上，主屏幕的深度将被返回。</p>
<p><strong>注意：</strong> 在调用此函数之前，必须先创建<a href="qguiapplication.html">QGuiApplication</a>。</p>
<p><strong>See also</strong> <a href="#depth">depth</a>(), <a href="qcolormap.html#depth">QColormap::depth</a>(), and <a href="#pixmap-information">Pixmap Information</a>.</p>
<h3><span id="int-qpixmap-depth-const">int QPixmap::depth() const</span><a href="#int-qpixmap-depth-const" class="header-anchor">#</a></h3><p>返回像素图的深度。</p>
<p>像素图的深度也被称为每像素位数（bpp）或像素图的位平面。一个空的像素图的深度是0。</p>
<p><strong>See also</strong> <a href="#defaultDepth">defaultDepth</a>() and <a href="#pixmap-information">Pixmap Information</a>.</p>
<h3><span id="void-qpixmap-detach">void QPixmap::detach()</span><a href="#void-qpixmap-detach" class="header-anchor">#</a></h3><p>将像素图从共享的像素图数据中分离出来。</p>
<p>每当一个像素图的内容要发生变化时，Qt就会自动将其分离。这在几乎所有修改像素图的<a href>QPixmap</a>成员函数（<a href="#fill">fill</a>(), <a href="#fromImage">fromImage</a>(), <a href="#load">load</a>()等），以及在像素图的[QPainter::begin]（qpainter.html#begin）()中完成。</p>
<p>有两种例外情况，即在调用handle()或x11PictureHandle()函数（仅在X11上可用）时，必须明确地调用detach()。否则，使用系统调用所做的任何修改，都会在共享数据上进行。</p>
<p>如果只有一个引用或者像素图还没有被初始化，detach()函数会立即返回。</p>
<h3><span id="qsizef-qpixmap-deviceindependentsize-const"> QPixmap::deviceIndependentSize() const</span><a href="#qsizef-qpixmap-deviceindependentsize-const" class="header-anchor">#</a></h3><p>返回像素图的尺寸，与设备无关的像素。</p>
<p>在用户界面尺寸计算中使用像素图尺寸时，应使用该值。</p>
<p>返回值相当于pixmap.<a href="#size">size</a>() / pixmap.<a href="#devicePixelRatio">devicePixelRatio</a>()。</p>
<h3><span id="qreal-qpixmap-devicepixelratio-const"> QPixmap::devicePixelRatio() const</span><a href="#qreal-qpixmap-devicepixelratio-const" class="header-anchor">#</a></h3><p>返回该像素图的设备像素比。这是<em>device pixels</em>和<em>device independent pixels</em>之间的比率。</p>
<p>在根据像素图的尺寸计算布局几何时使用这个函数。<a href="qsize.html">QSize</a> layoutSize = image.[size]（#size）() / image.devicePixelRatio()</p>
<p>默认值是1.0。</p>
<p><strong>See also</strong> <a href="#setDevicePixelRatio">setDevicePixelRatio</a>() and <a href="qimagereader.html">QImageReader</a>.</p>
<h3><span id="void-qpixmap-fill-const-qcolor-amp-color-qt-white">void QPixmap::fill(const  &amp;<em>color</em> = Qt::white)</span><a href="#void-qpixmap-fill-const-qcolor-amp-color-qt-white" class="header-anchor">#</a></h3><p>用给定的<em>color</em> 填充像素图。</p>
<p>当像素图被画上时，这个函数的效果是未定义的。</p>
<p><strong>See also</strong> <a href="#pixmap-transformations">Pixmap Transformations</a>.</p>
<h3><span id="static-qpixmap-qpixmap-fromimage-const-qimage-amp-image-qt-imageconversionflags-flags-qt-autocolor"><code>[static]</code> QPixmap::fromImage(const  &amp;<em>image</em>,  <em>flags</em> = Qt::AutoColor)</span><a href="#static-qpixmap-qpixmap-fromimage-const-qimage-amp-image-qt-imageconversionflags-flags-qt-autocolor" class="header-anchor">#</a></h3><p>将给定的<em>image</em>转换为像素图，使用指定的<em>flags</em>来控制该转换。参数<em>flags</em>是<a href="qt.html#ImageConversionFlag-enum">Qt::ImageConversionFlags</a>的一个位数OR。为<em>flags</em>传入0会设置所有的默认选项。</p>
<p>如果是单色和8位图像，图像首先被转换为32位像素图，然后用颜色表中的颜色填充。如果这个操作太昂贵，你可以使用<a href="qbitmap.html#fromImage">QBitmap::fromImage</a>()代替。</p>
<p><strong>See also</strong> <a href="#fromImageReader">fromImageReader</a>(), <a href="#toImage">toImage</a>(), and <a href="#pixmap-conversion">Pixmap Conversion</a>.</p>
<h3><span id="static-since-5-3-qpixmap-qpixmap-fromimage-qimage-amp-amp-image-qt-imageconversionflags-flags-qt-autocolor"><code>[static, since 5.3]</code> QPixmap::fromImage( &amp;&amp;<em>image</em>,  <em>flags</em> = Qt::AutoColor)</span><a href="#static-since-5-3-qpixmap-qpixmap-fromimage-qimage-amp-amp-image-qt-imageconversionflags-flags-qt-autocolor" class="header-anchor">#</a></h3><p>这是一个重载函数。</p>
<p>将给定的<em>image</em>转换为像素图，如果可能的话，不进行复制。</p>
<p>这个函数引入于Qt 5.3。</p>
<h3><span id="static-qpixmap-qpixmap-fromimagereader-qimagereader-imagereader-qt-imageconversionflags-flags-qt-autocolor"><code>[static]</code> QPixmap::fromImageReader( *<em>imageReader</em>,  <em>flags</em> = Qt::AutoColor)</span><a href="#static-qpixmap-qpixmap-fromimagereader-qimagereader-imagereader-qt-imageconversionflags-flags-qt-autocolor" class="header-anchor">#</a></h3><p>从直接从<em>imageReader</em>读取的图像创建一个<a href>QPixmap</a>。参数<em>flags</em>是<a href="qt.html#ImageConversionFlag-enum">Qt::ImageConversionFlags</a>的bitwise-OR。为<em>flags</em>传入0会设置所有的默认选项。</p>
<p>在某些系统上，直接读取图像到<a href>QPixmap</a>比读取<a href="qimage.html">QImage</a>转换到<a href>QPixmap</a>使用的内存更少。</p>
<p><strong>See also</strong> <a href="#fromImage">fromImage</a>(), <a href="#toImage">toImage</a>(), and <a href="#pixmap-conversion">Pixmap Conversion</a>.</p>
<h3><span id="bool-qpixmap-hasalpha-const">bool QPixmap::hasAlpha() const</span><a href="#bool-qpixmap-hasalpha-const" class="header-anchor">#</a></h3><p>如果这个像素图有一个alpha通道，<em>or</em>有一个掩码，则返回 “true”，否则返回 “false”。</p>
<p><strong>See also</strong> <a href="#hasAlphaChannel">hasAlphaChannel</a>() and <a href="#mask">mask</a>().</p>
<h3><span id="bool-qpixmap-hasalphachannel-const">bool QPixmap::hasAlphaChannel() const</span><a href="#bool-qpixmap-hasalphachannel-const" class="header-anchor">#</a></h3><p>如果像素图有一个方面阿尔法通道的格式，返回 “true”，否则返回 “false”。</p>
<p><strong>See also</strong> <a href="#hasAlpha">hasAlpha</a>().</p>
<h3><span id="int-qpixmap-height-const">int QPixmap::height() const</span><a href="#int-qpixmap-height-const" class="header-anchor">#</a></h3><p>返回pixmap的高度。</p>
<p><strong>See also</strong> <a href="#size">size</a>() and <a href="#pixmap-information">Pixmap Information</a>.</p>
<h3><span id="bool-qpixmap-isnull-const">bool QPixmap::isNull() const</span><a href="#bool-qpixmap-isnull-const" class="header-anchor">#</a></h3><p>如果这是一个空的像素图，返回 “true”；否则返回 “false”。</p>
<p>一个空的像素图有零宽度、零高度和没有内容。你不能在一个空像素图中画画。</p>
<h3><span id="bool-qpixmap-isqbitmap-const">bool QPixmap::isQBitmap() const</span><a href="#bool-qpixmap-isqbitmap-const" class="header-anchor">#</a></h3><p>如果这是一个<a href="qbitmap.html">QBitmap</a>，返回 “true”；否则返回 “false”。</p>
<h3><span id="bool-qpixmap-load-const-qstring-amp-filename-const-char-format-nullptr-qt-imageconversionflags-flags-qt-autocolor">bool QPixmap::load(const  &amp;<em>fileName</em>, const char *<em>format</em> = nullptr,  <em>flags</em> = Qt::AutoColor)</span><a href="#bool-qpixmap-load-const-qstring-amp-filename-const-char-format-nullptr-qt-imageconversionflags-flags-qt-autocolor" class="header-anchor">#</a></h3><p>从给定的<em>fileName</em>的文件中加载一个像素图。如果像素图被成功加载，则返回true；否则像素图无效，并返回false。</p>
<p>加载器试图使用指定的<em>format</em>来读取像素图。如果没有指定<em>format</em>(这是默认的)，加载器会探测文件的头来猜测文件格式。</p>
<p>文件名可以是指磁盘上的一个实际文件，也可以是指应用程序的一个嵌入式资源。关于如何在应用程序的可执行文件中嵌入像素图和其他资源文件的细节，请参阅<a href="resources.html">资源系统</a>概述。</p>
<p>如果需要修改数据以适应较低分辨率的结果（例如从32位转换到8位），请使用<em>flags</em>来控制转换。</p>
<p>请注意，当在主线程中从文件加载时，QPixmaps被自动添加到<a href="qpixmapcache.html">QPixmapCache</a>中；使用的键是内部的，不能被获取。</p>
<p><strong>See also</strong> <a href="#loadFromData">loadFromData</a>() and <a href="#reading-and-writing-image-files">Reading and Writing Image Files</a>.</p>
<h3><span id="bool-qpixmap-loadfromdata-const-uchar-data-uint-len-const-char-format-nullptr-qt-imageconversionflags-flags-qt-autocolor">bool QPixmap::loadFromData(const  *<em>data</em>,  <em>len</em>, const char *<em>format</em> = nullptr,  <em>flags</em> = Qt::AutoColor)</span><a href="#bool-qpixmap-loadfromdata-const-uchar-data-uint-len-const-char-format-nullptr-qt-imageconversionflags-flags-qt-autocolor" class="header-anchor">#</a></h3><p>从给定的二进制<em>data</em>的<em>len</em>第一个字节加载一个像素图。如果像素图被成功加载，返回 “true”；否则像素图无效，返回 “false”。</p>
<p>加载器尝试使用指定的<em>format</em>来读取像素图。如果没有指定<em>format</em>(这是默认的)，加载器会探测文件的头来猜测文件格式。</p>
<p>如果需要修改数据以适应较低分辨率的结果（例如，从32位转换到8位），请使用<em>flags</em>来控制转换。</p>
<p><strong>See also</strong> <a href="#load">load</a>() and <a href="#reading-and-writing-image-files">Reading and Writing Image Files</a>.</p>
<h3><span id="bool-qpixmap-loadfromdata-const-qbytearray-amp-data-const-char-format-nullptr-qt-imageconversionflags-flags-qt-autocolor">bool QPixmap::loadFromData(const  &amp;<em>data</em>, const char *<em>format</em> = nullptr,  <em>flags</em> = Qt::AutoColor)</span><a href="#bool-qpixmap-loadfromdata-const-qbytearray-amp-data-const-char-format-nullptr-qt-imageconversionflags-flags-qt-autocolor" class="header-anchor">#</a></h3><p>这是一个重载函数。</p>
<p>使用指定的<em>format</em>和转换<em>flags</em>从二进制<em>data</em>加载一个像素图。</p>
<h3><span id="qbitmap-qpixmap-mask-const"> QPixmap::mask() const</span><a href="#qbitmap-qpixmap-mask-const" class="header-anchor">#</a></h3><p>从像素图的 Alpha 通道中提取位图掩码。</p>
<p><strong>警告：</strong>这可能是一项昂贵的操作。 像素图的掩码是从像素数据中动态提取的。</p>
<p><strong>See also</strong> <a href="#setMask">setMask</a>() and <a href="#pixmap-information">Pixmap Information</a>.</p>
<h3><span id="qrect-qpixmap-rect-const"> QPixmap::rect() const</span><a href="#qrect-qpixmap-rect-const" class="header-anchor">#</a></h3><p>返回像素图的封闭矩形。</p>
<p><strong>See also</strong> <a href="#pixmap-information">Pixmap Information</a>.</p>
<h3><span id="bool-qpixmap-save-const-qstring-amp-filename-const-char-format-nullptr-int-quality-1-const">bool QPixmap::save(const  &amp;<em>fileName</em>, const char *<em>format</em> = nullptr, int <em>quality</em> = -1) const</span><a href="#bool-qpixmap-save-const-qstring-amp-filename-const-char-format-nullptr-int-quality-1-const" class="header-anchor">#</a></h3><p>使用指定的图像文件<em>format</em>和<em>quality</em> 系数，将像素图保存到给定的<em>fileName</em>的文件中。如果成功返回 “true”，否则返回 “false”。</p>
<p> <em>quality</em> 系数必须在[0,100]或-1范围内。指定0来获得小的压缩文件，100来获得大的未压缩文件，而-1则使用默认设置。</p>
<p>如果<em>format</em>是<code>nullptr</code>，将从<em>fileName</em>的后缀中选择一种图像格式。</p>
<p><strong>See also</strong> <a href="#reading-and-writing-image-files">Reading and Writing Image Files</a>.</p>
<h3><span id="bool-qpixmap-save-qiodevice-device-const-char-format-nullptr-int-quality-1-const">bool QPixmap::save( *<em>device</em>, const char *<em>format</em> = nullptr, int <em>quality</em> = -1) const</span><a href="#bool-qpixmap-save-qiodevice-device-const-char-format-nullptr-int-quality-1-const" class="header-anchor">#</a></h3><p>这是一个重载函数。</p>
<p>此函数使用指定的图像文件 <em>format</em> 和 <em>quality</em> 因子将 <a href>QPixmap</a> 写入给定的 <em>device</em>。 例如，这可以用于将像素图直接保存到 <a href="qbytearray.html">QByteArray</a> 中：</p>
<div class="code-wrapper"><pre><code class="hljs c++">QPixmap pixmap;
QByteArray bytes;
<span class="hljs-function">QBuffer <span class="hljs-title">buffer</span><span class="hljs-params">(&amp;bytes)</span></span>;
buffer.<span class="hljs-built_in">open</span>(QIODevice::WriteOnly);
pixmap.<span class="hljs-built_in">save</span>(&amp;buffer, <span class="hljs-string">"PNG"</span>); <span class="hljs-comment">// writes pixmap into bytes in PNG format</span></code></pre></div>

<h3><span id="qpixmap-qpixmap-scaled-const-qsize-amp-size-qt-aspectratiomode-aspectratiomode-qt-ignoreaspectratio-qt-transformationmode-transformmode-qt-fasttransformation-const"> QPixmap::scaled(const  &amp;<em>size</em>,  <em>aspectRatioMode</em> = Qt::IgnoreAspectRatio,  <em>transformMode</em> = Qt::FastTransformation) const</span><a href="#qpixmap-qpixmap-scaled-const-qsize-amp-size-qt-aspectratiomode-aspectratiomode-qt-ignoreaspectratio-qt-transformationmode-transformmode-qt-fasttransformation-const" class="header-anchor">#</a></h3><p>使用<em>aspectRatioMode</em>和<em>transformMode</em>指定的长宽比和变换模式，将像素图缩放到给定的<em>size</em>。</p>
<p><img src="https://doc.qt.io/qt-6/images/qimage-scaling.png" srcset="/img/loading.gif" lazyload alt="img"></p>
<ul>
<li>如果<em>aspectRatioMode</em>是<a href="qt.html#AspectRatioMode-enum">Qt::IgnoreAspectRatio</a>，像素图会被缩放到<em>size</em>。</li>
<li>如果<em>aspectRatioMode</em>是<a href="qt.html#AspectRatioMode-enum">Qt::KeepAspectRatio</a>，像素图会被缩放到<em>size</em>内尽可能大的矩形，保留长宽比。</li>
<li>如果<em>aspectRatioMode</em>是<a href="qt.html#AspectRatioMode-enum">Qt::KeepAspectRatioByExpanding</a>，像素图会被缩放到<em>size</em>以外尽可能小的矩形，保留长宽比。</li>
</ul>
<p>如果给定的<em>size</em>是空的，这个函数返回一个空的像素图。</p>
<p>在某些情况下，将像素图绘制到有比例设置的绘图器上比缩放像素图更有利。例如，当绘图器是基于OpenGL的，或者当比例因子快速变化时，就是这种情况。</p>
<p><strong>See also</strong> <a href="#isNull">isNull</a>() and <a href="#pixmap-transformations">Pixmap Transformations</a>.</p>
<h3><span id="qpixmap-qpixmap-scaled-int-width-int-height-qt-aspectratiomode-aspectratiomode-qt-ignoreaspectratio-qt-transformationmode-transformmode-qt-fasttransformation-const"> QPixmap::scaled(int <em>width</em>, int <em>height</em>,  <em>aspectRatioMode</em> = Qt::IgnoreAspectRatio,  <em>transformMode</em> = Qt::FastTransformation) const</span><a href="#qpixmap-qpixmap-scaled-int-width-int-height-qt-aspectratiomode-aspectratiomode-qt-ignoreaspectratio-qt-transformationmode-transformmode-qt-fasttransformation-const" class="header-anchor">#</a></h3><p>这是一个重载函数。</p>
<p>根据给定的<em>aspectRatioMode</em>和<em>transformMode</em>，将像素图的副本缩放为给定的<em>width</em>和<em>height</em>的矩形。</p>
<p>如果<em>width</em>或<em>height</em>是零或负数，这个函数会返回一个空的像素图。</p>
<h3><span id="qpixmap-qpixmap-scaledtoheight-int-height-qt-transformationmode-mode-qt-fasttransformation-const"> QPixmap::scaledToHeight(int <em>height</em>,  <em>mode</em> = Qt::FastTransformation) const</span><a href="#qpixmap-qpixmap-scaledtoheight-int-height-qt-transformationmode-mode-qt-fasttransformation-const" class="header-anchor">#</a></h3><p>返回图像的一个缩放副本。返回的图像使用指定的转换<em>mode</em>被缩放到给定的<em>height</em>。像素图的宽度会被自动计算，以便保留像素图的长宽比。</p>
<p>如果<em>height</em>为0或负数，将返回一个空的像素图。</p>
<p><strong>See also</strong> <a href="#isNull">isNull</a>() and <a href="#pixmap-transformations">Pixmap Transformations</a>.</p>
<h3><span id="qpixmap-qpixmap-scaledtowidth-int-width-qt-transformationmode-mode-qt-fasttransformation-const"> QPixmap::scaledToWidth(int <em>width</em>,  <em>mode</em> = Qt::FastTransformation) const</span><a href="#qpixmap-qpixmap-scaledtowidth-int-width-qt-transformationmode-mode-qt-fasttransformation-const" class="header-anchor">#</a></h3><p>返回图像的一个缩放副本。返回的图像使用指定的转换<em>mode</em>被缩放到给定的<em>width</em>。像素图的高度是自动计算的，因此像素图的长宽比被保留了。</p>
<p>如果<em>width</em>为0或负数，将返回一个空的像素图。</p>
<p><strong>See also</strong> <a href="#isNull">isNull</a>() and <a href="#pixmap-transformations">Pixmap Transformations</a>.</p>
<h3><span id="void-qpixmap-scroll-int-dx-int-dy-int-x-int-y-int-width-int-height-qregion-exposed-nullptr">void QPixmap::scroll(int <em>dx</em>, int <em>dy</em>, int <em>x</em>, int <em>y</em>, int <em>width</em>, int <em>height</em>,  *<em>exposed</em> = nullptr)</span><a href="#void-qpixmap-scroll-int-dx-int-dy-int-x-int-y-int-width-int-height-qregion-exposed-nullptr" class="header-anchor">#</a></h3><p>这个方便的函数相当于调用QPixmap::roll(<em>dx</em>, <em>dy</em>, <a href="qrect.html">QRect</a>(<em>x</em>, <em>y</em>, <em>width</em>, <em>height</em>), <em>exposed</em>)。</p>
<p><strong>See also</strong> <a href="qwidget.html#scroll">QWidget::scroll</a>() and <a href="qgraphicsitem.html#scroll">QGraphicsItem::scroll</a>().</p>
<h3><span id="void-qpixmap-scroll-int-dx-int-dy-const-qrect-amp-rect-qregion-exposed-nullptr">void QPixmap::scroll(int <em>dx</em>, int <em>dy</em>, const  &amp;<em>rect</em>,  *<em>exposed</em> = nullptr)</span><a href="#void-qpixmap-scroll-int-dx-int-dy-const-qrect-amp-rect-qregion-exposed-nullptr" class="header-anchor">#</a></h3><p>按（<em>dx</em>，<em>dy</em>）滚动此像素图的<em>rect</em>区域。暴露的区域保持不变。你可以选择传递一个指向空<a href="qregion.html">QRegion</a>的指针，以获得被滚动操作<em>exposed</em>出来的区域。</p>
<div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-function">QPixmap <span class="hljs-title">pixmap</span><span class="hljs-params">(<span class="hljs-string">"background.png"</span>)</span></span>;
QRegion exposed;
pixmap.<span class="hljs-built_in">scroll</span>(<span class="hljs-number">10</span>, <span class="hljs-number">10</span>, pixmap.<span class="hljs-built_in">rect</span>(), &amp;exposed);</code></pre></div>

<p>当像素图上有一个活跃的画师时，你不能滚动。</p>
<p><strong>See also</strong> <a href="qwidget.html#scroll">QWidget::scroll</a>() and <a href="qgraphicsitem.html#scroll">QGraphicsItem::scroll</a>().</p>
<h3><span id="void-qpixmap-setdevicepixelratio-qreal-scalefactor">void QPixmap::setDevicePixelRatio( <em>scaleFactor</em>)</span><a href="#void-qpixmap-setdevicepixelratio-qreal-scalefactor" class="header-anchor">#</a></h3><p>设置像素图的设备像素比。这是图像像素和与设备无关的像素之间的比率。</p>
<p>默认的<em>scaleFactor</em>是1.0。把它设置成其他的东西有两个效果。</p>
<p>在像素图上打开的QPainters将被缩放。例如，在一个200x200的图像上绘画，如果比例为2.0，将导致有效的（与设备无关的）绘画范围为100x100。</p>
<p>Qt中基于像素图大小计算布局几何的代码路径会考虑到这个比例。<a href="qsize.html">QSize</a> layoutSize = pixmap.<a href="#size">size</a>() / pixmap.<a href="#devicePixelRatio">devicePixelRatio</a>() 这样做的净效果是，像素图被显示为高DPI像素图，而不是一个大像素图（参见<a href="qpainter.html#drawing-high-resolution-versions-pixmaps-and-images">绘制高分辨率版本的像素图和图像</a>）。</p>
<p><strong>See also</strong> <a href="#devicePixelRatio">devicePixelRatio</a>() and <a href="#deviceIndependentSize">deviceIndependentSize</a>().</p>
<h3><span id="void-qpixmap-setmask-const-qbitmap-amp-mask">void QPixmap::setMask(const  &amp;<em>mask</em>)</span><a href="#void-qpixmap-setmask-const-qbitmap-amp-mask" class="header-anchor">#</a></h3><p>设置一个掩码位图。</p>
<p>这个函数将<em>mask</em>与像素图的alpha通道合并。遮罩上的像素值为1意味着该像素图的像素是不变的；值为0意味着该像素是透明的。遮罩的大小必须与这个像素图相同。</p>
<p>设置一个空的遮罩会重置遮罩，使之前的透明像素变成黑色。当像素图被画上时，这个函数的效果是不确定的。</p>
<p><strong>警告：</strong>这是一个潜在的昂贵操作。</p>
<p><strong>See also</strong> <a href="#mask">mask</a>(), <a href="#pixmap-transformations">Pixmap Transformations</a>, and <a href="qbitmap.html">QBitmap</a>.</p>
<h3><span id="qsize-qpixmap-size-const"> QPixmap::size() const</span><a href="#qsize-qpixmap-size-const" class="header-anchor">#</a></h3><p>返回像素图的大小。</p>
<p><strong>See also</strong> <a href="#width">width</a>(), <a href="#height">height</a>(), and <a href="#pixmap-information">Pixmap Information</a>.</p>
<h3><span id="void-qpixmap-swap-qpixmap-amp-other">void QPixmap::swap( &amp;<em>other</em>)</span><a href="#void-qpixmap-swap-qpixmap-amp-other" class="header-anchor">#</a></h3><p>将像素图<em>other</em> 与此像素图交换。这个操作非常快，而且从不失败。</p>
<h3><span id="qimage-qpixmap-toimage-const"> QPixmap::toImage() const</span><a href="#qimage-qpixmap-toimage-const" class="header-anchor">#</a></h3><p>将像素图转换为[QImage]（qimage.html）。如果转换失败，返回一个空图像。</p>
<p>如果像素图有1位深度，返回的图像也将是1位深度。具有更多比特的图像将以一种密切代表底层系统的格式返回。通常这将是<a href="qimage.html#Format-enum">QImage::Format_ARGB32_Premultiplied</a>，用于带有阿尔法的像素图；<a href="qimage.html#Format-enum">QImage::Format_RGB32</a>或<a href="qimage.html#Format-enum">QImage::Format_RGB16</a> 用于没有阿尔法的像素图。</p>
<p>请注意，目前，单色图像的阿尔法掩码被忽略了。</p>
<p><strong>See also</strong> <a href="#fromImage">fromImage</a>() and <a href="qimage.html#image-formats">Image Formats</a>.</p>
<h3><span id="qpixmap-qpixmap-transformed-const-qtransform-amp-transform-qt-transformationmode-mode-qt-fasttransformation-const"> QPixmap::transformed(const  &amp;<em>transform</em>,  <em>mode</em> = Qt::FastTransformation) const</span><a href="#qpixmap-qpixmap-transformed-const-qtransform-amp-transform-qt-transformationmode-mode-qt-fasttransformation-const" class="header-anchor">#</a></h3><p>返回一个使用给定的变换<em>transform</em>和变换<em>mode</em>进行变换的像素图的副本。原始像素图不被改变。</p>
<p>变换<em>transform</em>在内部进行了调整，以补偿不需要的平移；也就是说，产生的像素图是包含原始像素图的所有变换点的最小的像素图。使用<a href="#trueMatrix">trueMatrix</a>()函数来检索用于转换像素图的实际矩阵。</p>
<p>这个函数很慢，因为它涉及到向<a href="qimage.html">QImage</a>的转换，非琐碎的计算和向<a href>QPixmap</a>的转换。</p>
<p><strong>See also</strong> <a href="#trueMatrix">trueMatrix</a>() and <a href="#pixmap-transformations">Pixmap Transformations</a>.</p>
<h3><span id="static-qtransform-qpixmap-truematrix-const-qtransform-amp-matrix-int-width-int-height"><code>[static]</code> QPixmap::trueMatrix(const  &amp;<em>matrix</em>, int <em>width</em>, int <em>height</em>)</span><a href="#static-qtransform-qpixmap-truematrix-const-qtransform-amp-matrix-int-width-int-height" class="header-anchor">#</a></h3><p>返回用于转换像素图的实际矩阵，该矩阵具有给定的<em>width</em>、<em>height</em>和<em>matrix</em>。</p>
<p>当使用<a href="#transformed">transformed</a>()函数转换像素图时，转换矩阵会被内部调整以补偿不需要的平移，即<a href="#transformed">transformed</a>()返回包含原始像素图的所有转换点的最小像素图。这个函数返回修改后的矩阵，它将原像素图中的点正确地映射到新的像素图中。</p>
<p><strong>See also</strong> <a href="#transformed">transformed</a>() and <a href="#pixmap-transformations">Pixmap Transformations</a>.</p>
<h3><span id="int-qpixmap-width-const">int QPixmap::width() const</span><a href="#int-qpixmap-width-const" class="header-anchor">#</a></h3><p>返回像素图的宽度。</p>
<p><strong>See also</strong> <a href="#size">size</a>() and <a href="#pixmap-information">Pixmap Information</a>.</p>
<h3><span id="qvariant-qpixmap-operator-qvariant-const"> QPixmap::operator QVariant() const</span><a href="#qvariant-qpixmap-operator-qvariant-const" class="header-anchor">#</a></h3><p>返回像素图为<a href="qvariant.html">QVariant</a>。</p>
<h3><span id="bool-qpixmap-operator-const">bool QPixmap::operator!() const</span><a href="#bool-qpixmap-operator-const" class="header-anchor">#</a></h3><p>如果这是一个空的像素图，返回 “true”；否则返回 “false”。</p>
<p><strong>See also</strong> <a href="#isNull">isNull</a>().</p>
<h2><span id="xiang-guan-fei-cheng-yuan">相关非成员</span><a href="#xiang-guan-fei-cheng-yuan" class="header-anchor">#</a></h2><h3><span id="qdatastream-amp-operator-lt-lt-qdatastream-amp-stream-const-qpixmap-amp-pixmap"> &amp;operator&lt;&lt;( &amp;<em>stream</em>, const  &amp;<em>pixmap</em>)</span><a href="#qdatastream-amp-operator-lt-lt-qdatastream-amp-stream-const-qpixmap-amp-pixmap" class="header-anchor">#</a></h3><p>将给定的<em>pixmap</em>作为PNG图像写入给定的<em>stream</em>。注意，将流写入文件不会产生一个有效的图像文件。</p>
<p><strong>See also</strong> <a href="#save">QPixmap::save</a>() and <a href="datastreamformat.html">Serializing Qt Data Types</a>.</p>
<h3><span id="qdatastream-amp-operator-gt-gt-qdatastream-amp-stream-qpixmap-amp-pixmap"> &amp;operator&gt;&gt;( &amp;<em>stream</em>,  &amp;<em>pixmap</em>)</span><a href="#qdatastream-amp-operator-gt-gt-qdatastream-amp-stream-qpixmap-amp-pixmap" class="header-anchor">#</a></h3><p>从给定的<em>stream</em>中读取一个图像到给定的<em>pixmap</em>中。</p>
<p><strong>See also</strong> <a href="#load">QPixmap::load</a>() and <a href="datastreamformat.html">Serializing Qt Data Types</a>.</p>

            </div>
            <hr>
            <div>
              <div class="post-metas mb-3">
                
                
                  <div class="post-meta">
                    <i class="iconfont icon-tags"></i>
                    
                      <a class="hover-with-bg" href="/tags/P/">P</a>
                    
                  </div>
                
              </div>
              
                <p class="note note-warning">
                  
                    本博客所有文章除特别声明外，均采用 <a target="_blank" href="https://creativecommons.org/licenses/by-sa/4.0/deed.zh" rel="nofollow noopener noopener">CC BY-SA 4.0 协议</a> ，转载请注明出处！
                  
                </p>
              
              
                <div class="post-prevnext">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/2022/03/02/QtDocumentCN/Src/P/QtPlugin/QtPlugin/">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">QtPlugin类</span>
                        <span class="visible-mobile">上一篇</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2022/03/02/QtDocumentCN/Src/P/The_Property_System/The_Property_System/">
                        <span class="hidden-mobile">QProperty类</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
              <!-- Comments -->
              <article class="comments" id="comments" lazyload>
                
                  
                
                
  <div id="lv-container" data-id="city" data-uid="MTAyMC81NTMzMi8zMTc5OQ==">
    <script type="text/javascript">
      Fluid.utils.loadComments('#lv-container', function() {
        Fluid.utils.createScript('https://cdn-city.livere.com/js/embed.dist.js');
      });
    </script>
    <noscript>Please enable JavaScript to view the comments</noscript>
  </div>


              </article>
            
          </article>
        </div>
      </div>
    </div>
    
      <div class="d-none d-lg-block col-lg-2 toc-container" id="toc-ctn">
        <div id="toc">
  <p class="toc-header"><i class="iconfont icon-list"></i>&nbsp;目录</p>
  <div class="toc-body" id="toc-body"></div>
</div>

      </div>
    
  </div>
</div>

<!-- Custom -->


    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v"
                 for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>
    

    
  </main>

  <footer class="text-center mt-5 py-3">
  <div class="footer-content">
     <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> 
  </div>
  

  

  
</footer>


  <!-- SCRIPTS -->
  
  <script  src="https://cdn.jsdelivr.net/npm/nprogress@0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/nprogress@0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js" ></script>
<script  src="https://cdn.jsdelivr.net/npm/bootstrap@4/dist/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>

<!-- Plugins -->


  <script  src="/js/local-search.js" ></script>



  
    <script  src="/js/img-lazyload.js" ></script>
  



  



  
    <script  src="https://cdn.jsdelivr.net/npm/tocbot@4/dist/tocbot.min.js" ></script>
  
  
    <script  src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3/dist/jquery.fancybox.min.js" ></script>
  
  
    <script  src="https://cdn.jsdelivr.net/npm/anchor-js@4/anchor.min.js" ></script>
  
  
    <script defer src="https://cdn.jsdelivr.net/npm/clipboard@2/dist/clipboard.min.js" ></script>
  






  <script  src="https://cdn.jsdelivr.net/npm/typed.js@2/lib/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var title = document.getElementById('subtitle').title;
      
        typing(title);
      
    })(window, document);
  </script>















<!-- 主题的启动项 保持在最底部 -->
<script  src="/js/boot.js" ></script>


</body>
</html>
