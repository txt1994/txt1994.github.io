

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=auto>



<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/logo.jpg">
  <link rel="icon" href="/img/logo.jpg">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
    <meta http-equiv="Content-Security-Policy" content="upgrade-insecure-requests">
  
  <meta name="theme-color" content="#6aa84f">
  <meta name="author" content="John Doe">
  <meta name="keywords" content="">
  
    <meta name="description" content="QUrl Class 公共类型 公共函数 静态公共成员 相关非成员 宏 详细描述 成员类型文档 [since 5.0]enum QUrl::ComponentFormattingOption flags QUrl::ComponentFormattingOptions enum QUrl::ParsingMode enum QUrl::UrlFormattingOption flags">
<meta property="og:type" content="article">
<meta property="og:title" content="QUrl类">
<meta property="og:url" content="https://txt1994.github.io/2022/03/02/QtDocumentCN/Src/U/QUrl/QUrl/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:description" content="QUrl Class 公共类型 公共函数 静态公共成员 相关非成员 宏 详细描述 成员类型文档 [since 5.0]enum QUrl::ComponentFormattingOption flags QUrl::ComponentFormattingOptions enum QUrl::ParsingMode enum QUrl::UrlFormattingOption flags">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://doc.qt.io/qt-6/images/qurl-authority.png">
<meta property="og:image" content="https://doc.qt.io/qt-6/images/qurl-fragment.png">
<meta property="og:image" content="https://doc.qt.io/qt-6/images/qurl-ftppath.png">
<meta property="og:image" content="https://doc.qt.io/qt-6/images/qurl-mailtopath.png">
<meta property="og:image" content="https://doc.qt.io/qt-6/images/qurl-authority2.png">
<meta property="og:image" content="https://doc.qt.io/qt-6/images/qurl-authority3.png">
<meta property="article:published_time" content="2022-03-02T06:47:47.000Z">
<meta property="article:modified_time" content="2022-03-18T16:56:49.975Z">
<meta property="article:author" content="John Doe">
<meta property="article:tag" content="U">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="https://doc.qt.io/qt-6/images/qurl-authority.png">
  
  
  <title>QUrl类 - Hexo</title>

  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4/dist/css/bootstrap.min.css" />


  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/github-markdown-css@4/github-markdown.min.css" />
  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/hint.css@2/hint.min.css" />

  
    
    
      
      <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@10/styles/github-gist.min.css" />
    
  

  
    <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3/dist/jquery.fancybox.min.css" />
  


<!-- 主题依赖的图标库，不要自行修改 -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_ba1fz6golrf.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_lbnruvf0jn.css">


<link  rel="stylesheet" href="/css/main.css" />

<!-- 自定义样式保持在最底部 -->

  
<link rel="stylesheet" href="/css/style.css">



  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    var CONFIG = {"hostname":"txt1994.github.io","root":"/","version":"1.8.14","typing":{"enable":true,"typeSpeed":70,"cursorChar":"_","loop":false},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"right","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"copy_btn":true,"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":false,"baidu":null,"google":null,"gtag":null,"tencent":{"sid":null,"cid":null},"woyaola":null,"cnzz":null,"leancloud":{"app_id":null,"app_key":null,"server_url":null,"path":"window.location.pathname","ignore_local":false}},"search_path":"/local-search.xml"};
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
<meta name="generator" content="Hexo 6.1.0">
<style>.github-emoji { position: relative; display: inline-block; width: 1.2em; min-height: 1.2em; overflow: hidden; vertical-align: top; color: transparent; }  .github-emoji > span { position: relative; z-index: 10; }  .github-emoji img, .github-emoji .fancybox { margin: 0 !important; padding: 0 !important; border: none !important; outline: none !important; text-decoration: none !important; user-select: none !important; cursor: auto !important; }  .github-emoji img { height: 1.2em !important; width: 1.2em !important; position: absolute !important; left: 50% !important; top: 50% !important; transform: translate(-50%, -50%) !important; user-select: none !important; cursor: auto !important; } .github-emoji-fallback { color: inherit; } .github-emoji-fallback img { opacity: 0 !important; }</style>
</head>


<body>
  <header style="height: 70vh;">
    <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/">
      <strong>txt1994s</strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/">
                <i class="iconfont icon-home-fill"></i>
                首页
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/">
                <i class="iconfont icon-archive-fill"></i>
                归档
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/">
                <i class="iconfont icon-tags-fill"></i>
                标签
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/">
                <i class="iconfont icon-user-fill"></i>
                关于
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/links/">
                <i class="iconfont icon-link-fill"></i>
                友联
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              &nbsp;<i class="iconfont icon-search"></i>&nbsp;
            </a>
          </li>
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">&nbsp;<i
                class="iconfont icon-dark" id="color-toggle-icon"></i>&nbsp;</a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

    <div class="banner" id="banner" parallax=true
         style="background: url('/img/default.png') no-repeat center center;
           background-size: cover;">
      <div class="full-bg-img">
        <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
          <div class="page-header text-center fade-in-up">
            <span class="h2" id="subtitle" title="QUrl类">
              
            </span>

            
              <div class="mt-3">
  
  
    <span class="post-meta">
      <i class="iconfont icon-date-fill" aria-hidden="true"></i>
      <time datetime="2022-03-02 14:47" pubdate>
        2022年3月2日 下午
      </time>
    </span>
  
</div>

<div class="mt-1">
  
    <span class="post-meta mr-2">
      <i class="iconfont icon-chart"></i>
      35k 字
    </span>
  

  
    <span class="post-meta mr-2">
      <i class="iconfont icon-clock-fill"></i>
      
      
      294 分钟
    </span>
  

  
  
</div>

            
          </div>

          
        </div>
      </div>
    </div>
  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="d-none d-lg-block col-lg-2"></div>
    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div class="py-5" id="board">
          <article class="post-content mx-auto">
            <!-- SEO header -->
            <h1 style="display: none">QUrl类</h1>
            
              <p class="note note-info">
                
                  本文最后更新于：2022年3月19日 凌晨
                
              </p>
            
            <div class="markdown-body">
              <div class="toc">

<!-- toc -->

<ul>
<li><a href="#qurl-class">QUrl Class</a><ul>
<li><a href="#gong-gong-lei-xing">公共类型</a></li>
<li><a href="#gong-gong-han-shu">公共函数</a></li>
<li><a href="#jing-tai-gong-gong-cheng-yuan">静态公共成员</a></li>
<li><a href="#xiang-guan-fei-cheng-yuan">相关非成员</a></li>
<li><a href="#hong">宏</a></li>
<li><a href="#xiang-xi-miao-shu">详细描述</a></li>
<li><a href="#cheng-yuan-lei-xing-wen-dang">成员类型文档</a><ul>
<li><a href="#since-5-0-enum-qurl-componentformattingoption-flags-qurl-componentformattingoptions"><code>[since 5.0]</code>enum QUrl::ComponentFormattingOption flags QUrl::ComponentFormattingOptions</a></li>
<li><a href="#enum-qurl-parsingmode">enum QUrl::ParsingMode</a></li>
<li><a href="#enum-qurl-urlformattingoption-flags-qurl-formattingoptions">enum QUrl::UrlFormattingOption flags QUrl::FormattingOptions</a></li>
<li><a href="#since-5-4-enum-qurl-userinputresolutionoption-flags-qurl-userinputresolutionoptions"><code>[since 5.4]</code>enum QUrl::UserInputResolutionOption flags QUrl::UserInputResolutionOptions</a></li>
</ul>
</li>
<li><a href="#cheng-yuan-han-shu-wen-dang">成员函数文档</a><ul>
<li><a href="#since-5-2-qurl-qurl-qurl-qurl-other"><code>[since 5.2]</code>QUrl::QUrl(</a><a href="#QUrl">QUrl</a> &amp;&amp;<em>other</em>)</li>
<li><a href="#qurl-qurl-const-qstring-qstring-html-url-qurl-parsingmode-parsingmode-enum-parsingmode-tolerantmode">QUrl::QUrl(const </a><a href="qstring.html">QString</a> &amp;<em>url</em>, <a href="#ParsingMode-enum">QUrl::ParsingMode</a> <em>parsingMode</em> = TolerantMode)</li>
<li><a href="#qurl-qurl-const-qurl-qurl-other">QUrl::QUrl(const </a><a href="#QUrl">QUrl</a> &amp;<em>other</em>)</li>
<li><a href="#qurl-qurl">QUrl::QUrl()</a></li>
<li><a href="#since-5-2-qurl-qurl-qurl-operator-qurl-qurl-other"><code>[since 5.2]</code></a><a href="#QUrl">QUrl</a> &amp;QUrl::operator=(<a href="#QUrl">QUrl</a> &amp;&amp;<em>other</em>)</li>
<li><a href="#qurl-qurl-qurl-operator-const-qstring-qstring-html-url">QUrl</a></li>
<li><a href="#qurl-qurl-qurl-operator-const-qurl-qurl-url-1">QUrl</a></li>
<li><a href="#qurl-qurl">QUrl::~QUrl()</a></li>
<li><a href="#since-5-2-qurl-qurl-qurl-adjusted-qurl-formattingoptions-urlformattingoption-enum-options-const"><code>[since 5.2]</code></a><a href="#QUrl">QUrl</a> QUrl::adjusted(<a href="#UrlFormattingOption-enum">QUrl::FormattingOptions</a> <em>options</em>) const</li>
<li><a href="#qstring-qstring-html-qurl-authority-qurl-componentformattingoptions-componentformattingoption-enum-options-prettydecoded-const">QString</a></li>
<li><a href="#void-qurl-clear">void QUrl::clear()</a></li>
<li><a href="#qstring-qstring-html-qurl-errorstring-const-1">QString</a></li>
<li><a href="#since-5-2-qstring-qstring-html-qurl-filename-qurl-componentformattingoptions-componentformattingoption-enum-options-fullydecoded-const"><code>[since 5.2]</code></a><a href="qstring.html">QString</a> QUrl::fileName(<a href="#ComponentFormattingOption-enum">QUrl::ComponentFormattingOptions</a> <em>options</em> = FullyDecoded) const</li>
<li><a href="#qstring-qstring-html-qurl-fragment-qurl-componentformattingoptions-componentformattingoption-enum-options-prettydecoded-const-2">QString</a></li>
<li><a href="#static-qstring-qstring-html-qurl-fromace-const-qbytearray-qbytearray-html-domain"><code>[static]</code></a><a href="qstring.html">QString</a> QUrl::fromAce(const <a href="qbytearray.html">QByteArray</a> &amp;<em>domain</em>)</li>
<li><a href="#static-since-5-2-qurl-qurl-qurl-fromcfurl-cfurlref-url"><code>[static, since 5.2]</code></a><a href="#QUrl">QUrl</a> QUrl::fromCFURL(CFURLRef <em>url</em>)</li>
<li><a href="#static-qurl-qurl-qurl-fromencoded-const-qbytearray-qbytearray-html-input-qurl-parsingmode-parsingmode-enum-parsingmode-tolerantmode"><code>[static]</code></a><a href="#QUrl">QUrl</a> QUrl::fromEncoded(const <a href="qbytearray.html">QByteArray</a> &amp;<em>input</em>, <a href="#ParsingMode-enum">QUrl::ParsingMode</a> <em>parsingMode</em> = TolerantMode)</li>
<li><a href="#static-qurl-qurl-qurl-fromlocalfile-const-qstring-qstring-html-localfile"><code>[static]</code></a><a href="#QUrl">QUrl</a> QUrl::fromLocalFile(const <a href="qstring.html">QString</a> &amp;<em>localFile</em>)</li>
<li><a href="#static-since-5-2-qurl-qurl-qurl-fromnsurl-const-nsurl-url"><code>[static, since 5.2]</code></a><a href="#QUrl">QUrl</a> QUrl::fromNSURL(const NSURL *<em>url</em>)</li>
<li><a href="#static-qstring-qstring-html-qurl-frompercentencoding-const-qbytearray-qbytearray-html-input"><code>[static]</code></a><a href="qstring.html">QString</a> QUrl::fromPercentEncoding(const <a href="qbytearray.html">QByteArray</a> &amp;<em>input</em>)</li>
<li><a href="#static-since-5-1-qlist-qlist-html-qurl-qurl-qurl-fromstringlist-const-qstringlist-qstringlist-html-urls-qurl-parsingmode-parsingmode-enum-mode-tolerantmode"><code>[static, since 5.1]</code></a><a href="qlist.html">QList</a>&lt;<a href="#QUrl">QUrl</a>&gt; QUrl::fromStringList(const <a href="qstringlist.html">QStringList</a> &amp;<em>urls</em>, <a href="#ParsingMode-enum">QUrl::ParsingMode</a> <em>mode</em> = TolerantMode)</li>
<li><a href="#static-since-5-4-qurl-qurl-qurl-fromuserinput-const-qstring-qstring-html-userinput-const-qstring-qstring-html-workingdirectory-qstring-qurl-userinputresolutionoptions-userinputresolutionoption-enum-options-defaultresolution"><code>[static, since 5.4]</code></a><a href="#QUrl">QUrl</a> QUrl::fromUserInput(const <a href="qstring.html">QString</a> &amp;<em>userInput</em>, const <a href="qstring.html">QString</a> &amp;<em>workingDirectory</em> = QString(), <a href="#UserInputResolutionOption-enum">QUrl::UserInputResolutionOptions</a> <em>options</em> = DefaultResolution)</li>
<li><a href="#bool-qurl-hasfragment-const">bool QUrl::hasFragment() const</a></li>
<li><a href="#bool-qurl-hasquery-const">bool QUrl::hasQuery() const</a></li>
<li><a href="#qstring-qstring-html-qurl-host-qurl-componentformattingoptions-componentformattingoption-enum-options-fullydecoded-const-3">QString</a></li>
<li><a href="#static-qstringlist-qstringlist-html-qurl-idnwhitelist"><code>[static]</code></a><a href="qstringlist.html">QStringList</a> QUrl::idnWhitelist()</li>
<li><a href="#bool-qurl-isempty-const">bool QUrl::isEmpty() const</a></li>
<li><a href="#bool-qurl-islocalfile-const">bool QUrl::isLocalFile() const</a></li>
<li><a href="#bool-qurl-isparentof-const-qurl-qurl-childurl-const">bool QUrl::isParentOf(const </a><a href="#QUrl">QUrl</a> &amp;<em>childUrl</em>) const</li>
<li><a href="#bool-qurl-isrelative-const">bool QUrl::isRelative() const</a></li>
<li><a href="#bool-qurl-isvalid-const">bool QUrl::isValid() const</a></li>
<li><a href="#since-5-2-bool-qurl-matches-const-qurl-qurl-url-qurl-formattingoptions-urlformattingoption-enum-options-const"><code>[since 5.2]</code>bool QUrl::matches(const </a><a href="#QUrl">QUrl</a> &amp;<em>url</em>, <a href="#UrlFormattingOption-enum">QUrl::FormattingOptions</a> <em>options</em>) const</li>
<li><a href="#qstring-qstring-html-qurl-password-qurl-componentformattingoptions-componentformattingoption-enum-options-fullydecoded-const-4">QString</a></li>
<li><a href="#qstring-qstring-html-qurl-path-qurl-componentformattingoptions-componentformattingoption-enum-options-fullydecoded-const-5">QString</a></li>
<li><a href="#int-qurl-port-int-defaultport-1-const">int QUrl::port(int <em>defaultPort</em> = -1) const</a></li>
<li><a href="#qstring-qstring-html-qurl-query-qurl-componentformattingoptions-componentformattingoption-enum-options-prettydecoded-const-6">QString</a></li>
<li><a href="#qurl-qurl-qurl-resolved-const-qurl-qurl-relative-const-2">QUrl</a></li>
<li><a href="#qstring-qstring-html-qurl-scheme-const-7">QString</a></li>
<li><a href="#void-qurl-setauthority-const-qstring-qstring-html-authority-qurl-parsingmode-parsingmode-enum-mode-tolerantmode">void QUrl::setAuthority(const </a><a href="qstring.html">QString</a> &amp;<em>authority</em>, <a href="#ParsingMode-enum">QUrl::ParsingMode</a> <em>mode</em> = TolerantMode)</li>
<li><a href="#void-qurl-setfragment-const-qstring-qstring-html-fragment-qurl-parsingmode-parsingmode-enum-mode-tolerantmode">void QUrl::setFragment(const </a><a href="qstring.html">QString</a> &amp;<em>fragment</em>, <a href="#ParsingMode-enum">QUrl::ParsingMode</a> <em>mode</em> = TolerantMode)</li>
<li><a href="#void-qurl-sethost-const-qstring-qstring-html-host-qurl-parsingmode-parsingmode-enum-mode-decodedmode">void QUrl::setHost(const </a><a href="qstring.html">QString</a> &amp;<em>host</em>, <a href="#ParsingMode-enum">QUrl::ParsingMode</a> <em>mode</em> = DecodedMode)</li>
<li><a href="#static-void-qurl-setidnwhitelist-const-qstringlist-qstringlist-html-list"><code>[static]</code>void QUrl::setIdnWhitelist(const </a><a href="qstringlist.html">QStringList</a> &amp;<em>list</em>)</li>
<li><a href="#void-qurl-setpassword-const-qstring-qstring-html-password-qurl-parsingmode-parsingmode-enum-mode-decodedmode">void QUrl::setPassword(const </a><a href="qstring.html">QString</a> &amp;<em>password</em>, <a href="#ParsingMode-enum">QUrl::ParsingMode</a> <em>mode</em> = DecodedMode)</li>
<li><a href="#void-qurl-setpath-const-qstring-qstring-html-path-qurl-parsingmode-parsingmode-enum-mode-decodedmode">void QUrl::setPath(const </a><a href="qstring.html">QString</a> &amp;<em>path</em>, <a href="#ParsingMode-enum">QUrl::ParsingMode</a> <em>mode</em> = DecodedMode)</li>
<li><a href="#void-qurl-setport-int-port">void QUrl::setPort(int <em>port</em>)</a></li>
<li><a href="#void-qurl-setquery-const-qstring-qstring-html-query-qurl-parsingmode-parsingmode-enum-mode-tolerantmode">void QUrl::setQuery(const </a><a href="qstring.html">QString</a> &amp;<em>query</em>, <a href="#ParsingMode-enum">QUrl::ParsingMode</a> <em>mode</em> = TolerantMode)</li>
<li><a href="#since-5-0-void-qurl-setquery-const-qurlquery-qurlquery-html-query"><code>[since 5.0]</code>void QUrl::setQuery(const </a><a href="qurlquery.html">QUrlQuery</a> &amp;<em>query</em>)</li>
<li><a href="#void-qurl-setscheme-const-qstring-qstring-html-scheme">void QUrl::setScheme(const </a><a href="qstring.html">QString</a> &amp;<em>scheme</em>)</li>
<li><a href="#void-qurl-seturl-const-qstring-qstring-html-url-qurl-parsingmode-parsingmode-enum-parsingmode-tolerantmode">void QUrl::setUrl(const </a><a href="qstring.html">QString</a> &amp;<em>url</em>, <a href="#ParsingMode-enum">QUrl::ParsingMode</a> <em>parsingMode</em> = TolerantMode)</li>
<li><a href="#void-qurl-setuserinfo-const-qstring-qstring-html-userinfo-qurl-parsingmode-parsingmode-enum-mode-tolerantmode">void QUrl::setUserInfo(const </a><a href="qstring.html">QString</a> &amp;<em>userInfo</em>, <a href="#ParsingMode-enum">QUrl::ParsingMode</a> <em>mode</em> = TolerantMode)</li>
<li><a href="#void-qurl-setusername-const-qstring-qstring-html-username-qurl-parsingmode-parsingmode-enum-mode-decodedmode">void QUrl::setUserName(const </a><a href="qstring.html">QString</a> &amp;<em>userName</em>, <a href="#ParsingMode-enum">QUrl::ParsingMode</a> <em>mode</em> = DecodedMode)</li>
<li><a href="#void-qurl-swap-qurl-qurl-other">void QUrl::swap(</a><a href="#QUrl">QUrl</a> &amp;<em>other</em>)</li>
<li><a href="#static-qbytearray-qbytearray-html-qurl-toace-const-qstring-qstring-html-domain"><code>[static]</code></a><a href="qbytearray.html">QByteArray</a> QUrl::toAce(const <a href="qstring.html">QString</a> &amp;<em>domain</em>)</li>
<li><a href="#since-5-2-cfurlref-qurl-tocfurl-const"><code>[since 5.2]</code>CFURLRef QUrl::toCFURL() const</a></li>
<li><a href="#since-5-0-qstring-qstring-html-qurl-todisplaystring-qurl-formattingoptions-urlformattingoption-enum-options-formattingoptions-prettydecoded-const"><code>[since 5.0]</code></a><a href="qstring.html">QString</a> QUrl::toDisplayString(<a href="#UrlFormattingOption-enum">QUrl::FormattingOptions</a> <em>options</em> = FormattingOptions(PrettyDecoded)) const</li>
<li><a href="#qbytearray-qbytearray-html-qurl-toencoded-qurl-formattingoptions-urlformattingoption-enum-options-fullyencoded-const">QByteArray</a></li>
<li><a href="#qstring-qstring-html-qurl-tolocalfile-const-8">QString</a></li>
<li><a href="#since-5-2-nsurl-qurl-tonsurl-const"><code>[since 5.2]</code>NSURL *QUrl::toNSURL() const</a></li>
<li><a href="#static-qbytearray-qbytearray-html-qurl-topercentencoding-const-qstring-qstring-html-input-const-qbytearray-qbytearray-html-exclude-qbytearray-const-qbytearray-qbytearray-html-include-qbytearray"><code>[static]</code></a><a href="qbytearray.html">QByteArray</a> QUrl::toPercentEncoding(const <a href="qstring.html">QString</a> &amp;<em>input</em>, const <a href="qbytearray.html">QByteArray</a> &amp;<em>exclude</em> = QByteArray(), const <a href="qbytearray.html">QByteArray</a> &amp;<em>include</em> = QByteArray())</li>
<li><a href="#qstring-qstring-html-qurl-tostring-qurl-formattingoptions-urlformattingoption-enum-options-formattingoptions-prettydecoded-const-9">QString</a></li>
<li><a href="#static-since-5-1-qstringlist-qstringlist-html-qurl-tostringlist-const-qlist-qlist-html-qurl-qurl-urls-qurl-formattingoptions-urlformattingoption-enum-options-formattingoptions-prettydecoded"><code>[static, since 5.1]</code></a><a href="qstringlist.html">QStringList</a> QUrl::toStringList(const <a href="qlist.html">QList</a>&lt;<a href="#QUrl">QUrl</a>&gt; &amp;<em>urls</em>, <a href="#UrlFormattingOption-enum">QUrl::FormattingOptions</a> <em>options</em> = FormattingOptions(PrettyDecoded))</li>
<li><a href="#qstring-qstring-html-qurl-url-qurl-formattingoptions-urlformattingoption-enum-options-formattingoptions-prettydecoded-const-10">QString</a></li>
<li><a href="#qstring-qstring-html-qurl-userinfo-qurl-componentformattingoptions-componentformattingoption-enum-options-prettydecoded-const-11">QString</a></li>
<li><a href="#qstring-qstring-html-qurl-username-qurl-componentformattingoptions-componentformattingoption-enum-options-fullydecoded-const-12">QString</a></li>
<li><a href="#bool-qurl-operator-const-qurl-qurl-url-const">bool QUrl::operator!=(const </a><a href="#QUrl">QUrl</a> &amp;<em>url</em>) const</li>
<li><a href="#bool-qurl-operator-const-qurl-qurl-url-const">bool QUrl::operator==(const </a><a href="#QUrl">QUrl</a> &amp;<em>url</em>) const</li>
</ul>
</li>
<li><a href="#xiang-guan-fei-cheng-yuan-1">相关非成员</a><ul>
<li><a href="#qdatastream-qdatastream-html-operator-qdatastream-qdatastream-html-out-const-qurl-qurl-url">QDataStream</a></li>
<li><a href="#qdatastream-qdatastream-html-operator-qdatastream-qdatastream-html-in-qurl-qurl-url-1">QDataStream</a></li>
</ul>
</li>
<li><a href="#hong-wen-dang">宏文档</a><ul>
<li><a href="#qt-no-url-cast-from-string">QT_NO_URL_CAST_FROM_STRING</a></li>
</ul>
</li>
</ul>
</li>
</ul>
<!-- tocstop -->

</div>
# QUrl Class

<p>QUrl 类为处理 URL 提供了一个方便的接口。 <a href="#%E8%AF%A6%E7%BB%86%E6%8F%8F%E8%BF%B0">More…</a></p>
<table>
<thead>
<tr>
<th>Header:</th>
<th>#include <qurl></qurl></th>
</tr>
</thead>
<tbody><tr>
<td>CMake:</td>
<td>find_package(Qt6 COMPONENTS Core REQUIRED) target_link_libraries(mytarget PRIVATE Qt6::Core)</td>
</tr>
<tr>
<td>qmake:</td>
<td>QT += core</td>
</tr>
</tbody></table>
<ul>
<li><a href="qurl-members.html">List of all members, including inherited members</a></li>
</ul>
<p><strong>注意：</strong> 此类中的所有函数都是 <a href="17-qdoc-commands-thread.html#reentrant">reentrant</a>。</p>
<h2><span id="gong-gong-lei-xing">公共类型</span><a href="#gong-gong-lei-xing" class="header-anchor">#</a></h2><table>
<thead>
<tr>
<th>enum</th>
<th><strong><a href="#ComponentFormattingOption-enum">ComponentFormattingOption</a></strong> { PrettyDecoded, EncodeSpaces, EncodeUnicode, EncodeDelimiters, EncodeReserved, …, FullyDecoded }</th>
</tr>
</thead>
<tbody><tr>
<td>flags</td>
<td><strong><a href="#ComponentFormattingOption-enum">ComponentFormattingOptions</a></strong></td>
</tr>
<tr>
<td>flags</td>
<td><strong><a href="#UrlFormattingOption-enum">FormattingOptions</a></strong></td>
</tr>
<tr>
<td>enum</td>
<td><strong><a href="#ParsingMode-enum">ParsingMode</a></strong> { TolerantMode, StrictMode, DecodedMode }</td>
</tr>
<tr>
<td>enum</td>
<td><strong><a href="#UrlFormattingOption-enum">UrlFormattingOption</a></strong> { None, RemoveScheme, RemovePassword, RemoveUserInfo, RemovePort, …, NormalizePathSegments }</td>
</tr>
<tr>
<td>enum</td>
<td><strong><a href="#UserInputResolutionOption-enum">UserInputResolutionOption</a></strong> { DefaultResolution, AssumeLocalFile }</td>
</tr>
<tr>
<td>flags</td>
<td><strong><a href="#UserInputResolutionOption-enum">UserInputResolutionOptions</a></strong></td>
</tr>
</tbody></table>
<h2><span id="gong-gong-han-shu">公共函数</span><a href="#gong-gong-han-shu" class="header-anchor">#</a></h2><table>
<thead>
<tr>
<th></th>
<th><strong><a href="#QUrl-3">QUrl</a></strong>(QUrl &amp;&amp;<em>other</em>)</th>
</tr>
</thead>
<tbody><tr>
<td></td>
<td><strong><a href="#QUrl-2">QUrl</a></strong>(const QString &amp;<em>url</em>, QUrl::ParsingMode <em>parsingMode</em> = TolerantMode)</td>
</tr>
<tr>
<td></td>
<td><strong><a href="#QUrl-1">QUrl</a></strong>(const QUrl &amp;<em>other</em>)</td>
</tr>
<tr>
<td></td>
<td><strong><a href="#QUrl">QUrl</a></strong>()</td>
</tr>
<tr>
<td>QUrl &amp;</td>
<td><strong><a href="#operator-eq-2">operator=</a></strong>(QUrl &amp;&amp;<em>other</em>)</td>
</tr>
<tr>
<td>QUrl &amp;</td>
<td><strong><a href="#operator-eq-1">operator=</a></strong>(const QString &amp;<em>url</em>)</td>
</tr>
<tr>
<td>QUrl &amp;</td>
<td><strong><a href="#operator-eq">operator=</a></strong>(const QUrl &amp;<em>url</em>)</td>
</tr>
<tr>
<td></td>
<td><strong><a href="#dtor.QUrl">~QUrl</a></strong>()</td>
</tr>
<tr>
<td>QUrl</td>
<td><strong><a href="#adjusted">adjusted</a></strong>(QUrl::FormattingOptions <em>options</em>) const</td>
</tr>
<tr>
<td>QString</td>
<td><strong><a href="#authority">authority</a></strong>(QUrl::ComponentFormattingOptions <em>options</em> = PrettyDecoded) const</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="#clear">clear</a></strong>()</td>
</tr>
<tr>
<td>QString</td>
<td><strong><a href="#errorString">errorString</a></strong>() const</td>
</tr>
<tr>
<td>QString</td>
<td><strong><a href="#fileName">fileName</a></strong>(QUrl::ComponentFormattingOptions <em>options</em> = FullyDecoded) const</td>
</tr>
<tr>
<td>QString</td>
<td><strong><a href="#fragment">fragment</a></strong>(QUrl::ComponentFormattingOptions <em>options</em> = PrettyDecoded) const</td>
</tr>
<tr>
<td>bool</td>
<td><strong><a href="#hasFragment">hasFragment</a></strong>() const</td>
</tr>
<tr>
<td>bool</td>
<td><strong><a href="#hasQuery">hasQuery</a></strong>() const</td>
</tr>
<tr>
<td>QString</td>
<td><strong><a href="#host">host</a></strong>(QUrl::ComponentFormattingOptions <em>options</em> = FullyDecoded) const</td>
</tr>
<tr>
<td>bool</td>
<td><strong><a href="#isEmpty">isEmpty</a></strong>() const</td>
</tr>
<tr>
<td>bool</td>
<td><strong><a href="#isLocalFile">isLocalFile</a></strong>() const</td>
</tr>
<tr>
<td>bool</td>
<td><strong><a href="#isParentOf">isParentOf</a></strong>(const QUrl &amp;<em>childUrl</em>) const</td>
</tr>
<tr>
<td>bool</td>
<td><strong><a href="#isRelative">isRelative</a></strong>() const</td>
</tr>
<tr>
<td>bool</td>
<td><strong><a href="#isValid">isValid</a></strong>() const</td>
</tr>
<tr>
<td>bool</td>
<td><strong><a href="#matches">matches</a></strong>(const QUrl &amp;<em>url</em>, QUrl::FormattingOptions <em>options</em>) const</td>
</tr>
<tr>
<td>QString</td>
<td><strong><a href="#password">password</a></strong>(QUrl::ComponentFormattingOptions <em>options</em> = FullyDecoded) const</td>
</tr>
<tr>
<td>QString</td>
<td><strong><a href="#path">path</a></strong>(QUrl::ComponentFormattingOptions <em>options</em> = FullyDecoded) const</td>
</tr>
<tr>
<td>int</td>
<td><strong><a href="#port">port</a></strong>(int <em>defaultPort</em> = -1) const</td>
</tr>
<tr>
<td>QString</td>
<td><strong><a href="#query">query</a></strong>(QUrl::ComponentFormattingOptions <em>options</em> = PrettyDecoded) const</td>
</tr>
<tr>
<td>QUrl</td>
<td><strong><a href="#resolved">resolved</a></strong>(const QUrl &amp;<em>relative</em>) const</td>
</tr>
<tr>
<td>QString</td>
<td><strong><a href="#scheme">scheme</a></strong>() const</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="#setAuthority">setAuthority</a></strong>(const QString &amp;<em>authority</em>, QUrl::ParsingMode <em>mode</em> = TolerantMode)</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="#setFragment">setFragment</a></strong>(const QString &amp;<em>fragment</em>, QUrl::ParsingMode <em>mode</em> = TolerantMode)</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="#setHost">setHost</a></strong>(const QString &amp;<em>host</em>, QUrl::ParsingMode <em>mode</em> = DecodedMode)</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="#setPassword">setPassword</a></strong>(const QString &amp;<em>password</em>, QUrl::ParsingMode <em>mode</em> = DecodedMode)</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="#setPath">setPath</a></strong>(const QString &amp;<em>path</em>, QUrl::ParsingMode <em>mode</em> = DecodedMode)</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="#setPort">setPort</a></strong>(int <em>port</em>)</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="#setQuery">setQuery</a></strong>(const QString &amp;<em>query</em>, QUrl::ParsingMode <em>mode</em> = TolerantMode)</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="#setQuery-1">setQuery</a></strong>(const QUrlQuery &amp;<em>query</em>)</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="#setScheme">setScheme</a></strong>(const QString &amp;<em>scheme</em>)</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="#setUrl">setUrl</a></strong>(const QString &amp;<em>url</em>, QUrl::ParsingMode <em>parsingMode</em> = TolerantMode)</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="#setUserInfo">setUserInfo</a></strong>(const QString &amp;<em>userInfo</em>, QUrl::ParsingMode <em>mode</em> = TolerantMode)</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="#setUserName">setUserName</a></strong>(const QString &amp;<em>userName</em>, QUrl::ParsingMode <em>mode</em> = DecodedMode)</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="#swap">swap</a></strong>(QUrl &amp;<em>other</em>)</td>
</tr>
<tr>
<td>CFURLRef</td>
<td><strong><a href="#toCFURL">toCFURL</a></strong>() const</td>
</tr>
<tr>
<td>QString</td>
<td><strong><a href="#toDisplayString">toDisplayString</a></strong>(QUrl::FormattingOptions <em>options</em> = FormattingOptions(PrettyDecoded)) const</td>
</tr>
<tr>
<td>QByteArray</td>
<td><strong><a href="#toEncoded">toEncoded</a></strong>(QUrl::FormattingOptions <em>options</em> = FullyEncoded) const</td>
</tr>
<tr>
<td>QString</td>
<td><strong><a href="#toLocalFile">toLocalFile</a></strong>() const</td>
</tr>
<tr>
<td>NSURL *</td>
<td><strong><a href="#toNSURL">toNSURL</a></strong>() const</td>
</tr>
<tr>
<td>QString</td>
<td><strong><a href="#toString">toString</a></strong>(QUrl::FormattingOptions <em>options</em> = FormattingOptions(PrettyDecoded)) const</td>
</tr>
<tr>
<td>QString</td>
<td><strong><a href="#url">url</a></strong>(QUrl::FormattingOptions <em>options</em> = FormattingOptions(PrettyDecoded)) const</td>
</tr>
<tr>
<td>QString</td>
<td><strong><a href="#userInfo">userInfo</a></strong>(QUrl::ComponentFormattingOptions <em>options</em> = PrettyDecoded) const</td>
</tr>
<tr>
<td>QString</td>
<td><strong><a href="#userName">userName</a></strong>(QUrl::ComponentFormattingOptions <em>options</em> = FullyDecoded) const</td>
</tr>
<tr>
<td>bool</td>
<td><strong><a href="#operator-not-eq">operator!=</a></strong>(const QUrl &amp;<em>url</em>) const</td>
</tr>
<tr>
<td>bool</td>
<td><strong><a href="#operator-eq-eq">operator==</a></strong>(const QUrl &amp;<em>url</em>) const</td>
</tr>
</tbody></table>
<h2><span id="jing-tai-gong-gong-cheng-yuan">静态公共成员</span><a href="#jing-tai-gong-gong-cheng-yuan" class="header-anchor">#</a></h2><table>
<thead>
<tr>
<th>QString</th>
<th><strong><a href="#fromAce">fromAce</a></strong>(const QByteArray &amp;<em>domain</em>)</th>
</tr>
</thead>
<tbody><tr>
<td>QUrl</td>
<td><strong><a href="#fromCFURL">fromCFURL</a></strong>(CFURLRef <em>url</em>)</td>
</tr>
<tr>
<td>QUrl</td>
<td><strong><a href="#fromEncoded">fromEncoded</a></strong>(const QByteArray &amp;<em>input</em>, QUrl::ParsingMode <em>parsingMode</em> = TolerantMode)</td>
</tr>
<tr>
<td>QUrl</td>
<td><strong><a href="#fromLocalFile">fromLocalFile</a></strong>(const QString &amp;<em>localFile</em>)</td>
</tr>
<tr>
<td>QUrl</td>
<td><strong><a href="#fromNSURL">fromNSURL</a></strong>(const NSURL *<em>url</em>)</td>
</tr>
<tr>
<td>QString</td>
<td><strong><a href="#fromPercentEncoding">fromPercentEncoding</a></strong>(const QByteArray &amp;<em>input</em>)</td>
</tr>
<tr>
<td>QList<qurl></qurl></td>
<td><strong><a href="#fromStringList">fromStringList</a></strong>(const QStringList &amp;<em>urls</em>, QUrl::ParsingMode <em>mode</em> = TolerantMode)</td>
</tr>
<tr>
<td>QUrl</td>
<td><strong><a href="#fromUserInput">fromUserInput</a></strong>(const QString &amp;<em>userInput</em>, const QString &amp;<em>workingDirectory</em> = QString(), QUrl::UserInputResolutionOptions <em>options</em> = DefaultResolution)</td>
</tr>
<tr>
<td>QStringList</td>
<td><strong><a href="#idnWhitelist">idnWhitelist</a></strong>()</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="#setIdnWhitelist">setIdnWhitelist</a></strong>(const QStringList &amp;<em>list</em>)</td>
</tr>
<tr>
<td>QByteArray</td>
<td><strong><a href="#toAce">toAce</a></strong>(const QString &amp;<em>domain</em>)</td>
</tr>
<tr>
<td>QByteArray</td>
<td><strong><a href="#toPercentEncoding">toPercentEncoding</a></strong>(const QString &amp;<em>input</em>, const QByteArray &amp;<em>exclude</em> = QByteArray(), const QByteArray &amp;<em>include</em> = QByteArray())</td>
</tr>
<tr>
<td>QStringList</td>
<td><strong><a href="#toStringList">toStringList</a></strong>(const QList<qurl> &amp;<em>urls</em>, QUrl::FormattingOptions <em>options</em> = FormattingOptions(PrettyDecoded))</qurl></td>
</tr>
</tbody></table>
<h2><span id="xiang-guan-fei-cheng-yuan">相关非成员</span><a href="#xiang-guan-fei-cheng-yuan" class="header-anchor">#</a></h2><table>
<thead>
<tr>
<th>QDataStream &amp;</th>
<th><strong><a href="#operator-lt-lt">operator&lt;&lt;</a></strong>(QDataStream &amp;<em>out</em>, const QUrl &amp;<em>url</em>)</th>
</tr>
</thead>
<tbody><tr>
<td>QDataStream &amp;</td>
<td><strong><a href="#operator-gt-gt">operator&gt;&gt;</a></strong>(QDataStream &amp;<em>in</em>, QUrl &amp;<em>url</em>)</td>
</tr>
</tbody></table>
<h2><span id="hong">宏</span><a href="#hong" class="header-anchor">#</a></h2><table>
<thead>
<tr>
<th></th>
<th><strong><a href="#QT_NO_URL_CAST_FROM_STRING">QT_NO_URL_CAST_FROM_STRING</a></strong></th>
</tr>
</thead>
<tbody><tr>
<td></td>
<td></td>
</tr>
</tbody></table>
<h2><span id="xiang-xi-miao-shu">详细描述</span><a href="#xiang-xi-miao-shu" class="header-anchor">#</a></h2><p>它可以解析和构造编码和未编码形式的 URL。QUrl 还支持国际化域名 (IDN)。</p>
<p>使用 QUrl 最常见的方法是通过构造函数通过传递<a href="qstring.html">QString</a>来初始化它。否则，也可以使用<a href="#setUrl">setUrl ()。</a></p>
<p>URL 可以用两种形式表示：编码的或未编码的。未编码的表示适合向用户展示，但编码的表示通常是您将发送到 Web 服务器的内容。例如，未编码的 URL “<a target="_blank" rel="noopener" href="http://bühler.example.com/List">http://bühler.example.com/List</a> of applicable.xml”将作为“<a target="_blank" rel="noopener" href="http://bühler.example.com/List%20of%%E2%80%9D%E5%8F%91%E9%80%81%E5%88%B0%E6%9C%8D%E5%8A%A1%E5%99%A820applicants.xml%E2%80%9D%E3%80%82">http://xn--bhler-kva.example.com/List%20of%”发送到服务器20applicants.xml”。</a></p>
<p>也可以通过调用<a href="#setScheme">setScheme</a> ()、<a href="#setUserName">setUserName</a> ()、<a href="#setPassword">setPassword</a> ()、<a href="#setHost">setHost</a> ()、<a href="#setPort">setPort</a> ()、<a href="#setPath">setPath</a> ()、<a href="#setQuery">setQuery</a> ()和setFragment()来逐个构建<a href="#setFragment">一个URL</a>。还提供了一些方便的函数：<a href="#setAuthority">setAuthority</a> () 设置用户名、密码、主机和端口。<a href="#setUserInfo">setUserInfo</a> () 一次性设置用户名和密码。</p>
<p>调用<a href="#isValid">isValid</a> () 来检查 URL 是否有效。这可以在构建 URL 期间的任何时候完成。如果<a href="#isValid">isValid</a> () 返回<code>false</code>，则应在继续之前<a href="#clear">清除() URL，或者通过使用</a><a href="#setUrl">setUrl</a> () 解析新 URL 重新开始。</p>
<p><a href="qurlquery.html">通过使用QUrlQuery</a>类及其方法<a href="qurlquery.html#setQueryItems">QUrlQuery::setQueryItems</a> ()、<a href="qurlquery.html#addQueryItem">QUrlQuery::addQueryItem</a> () 和<a href="qurlquery.html#removeQueryItem">QUrlQuery::removeQueryItem</a> ()构造查询特别方便。使用<a href="qurlquery.html#setQueryDelimiters">QUrlQuery::setQueryDelimiters</a> () 自定义用于生成查询字符串的分隔符。</p>
<p>为了方便生成编码的 URL 字符串或查询字符串，有两个静态函数叫做<a href="#fromPercentEncoding">fromPercentEncoding</a> () 和<a href="#toPercentEncoding">toPercentEncoding</a> ()，它们处理<a href="qstring.html">QString</a>对象的百分比编码和解码。</p>
<p><a href="#fromLocalFile">fromLocalFile</a> () 通过解析本地文件路径构造一个 QUrl。<a href="#toLocalFile">toLocalFile</a> () 将 URL 转换为本地文件路径。</p>
<p><a href="#toString">使用toString</a> ()获取 URL 的人类可读表示。此表示适用于以未编码的形式向用户显示 URL。然而，由<a href="#toEncoded">toEncoded</a> () 返回的编码形式供内部使用，传递给 Web 服务器、邮件客户端等。这两种形式在技术上都是正确的，并且明确地表示相同的 URL —— 事实上，将任何一种形式传递给 QUrl 的构造函数或<a href="#setUrl">setUrl</a> () 都会产生相同的 QUrl 对象。</p>
<p>QUrl 符合<a target="_blank" rel="noopener" href="https://datatracker.ietf.org/doc/html/rfc3986">RFC 3986 （统一资源标识符：通用语法）的 URI 规范，并包括来自</a><a target="_blank" rel="noopener" href="https://datatracker.ietf.org/doc/html/rfc1738">RFC 1738</a>（统一资源定位符）的方案扩展。QUrl 中的大小写折叠规则符合<a target="_blank" rel="noopener" href="https://datatracker.ietf.org/doc/html/rfc3491">RFC 3491</a>（Nameprep：国际化域名 (IDN) 的 Stringprep 配置文件）。它还与来自 freedesktop.org 的<a target="_blank" rel="noopener" href="http://freedesktop.org/wiki/Specifications/file-uri-spec/">文件 URI 规范</a>兼容，前提是语言环境使用 UTF-8（IDN 要求）对文件名进行编码。</p>
<h4><span id="xiang-dui-url-yu-xiang-dui-lu-jing">相对 URL 与相对路径</span><a href="#xiang-dui-url-yu-xiang-dui-lu-jing" class="header-anchor">#</a></h4><p>调用<a href="#isRelative">isRelative</a> () 将返回 URL 是否是相对的。相对 URL 没有<a href="#scheme">方案</a>。例如：</p>
<div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-built_in">qDebug</span>() &lt;&lt; <span class="hljs-built_in">QUrl</span>(<span class="hljs-string">"main.qml"</span>).<span class="hljs-built_in">isRelative</span>();          <span class="hljs-comment">// true: no scheme</span>
<span class="hljs-built_in">qDebug</span>() &lt;&lt; <span class="hljs-built_in">QUrl</span>(<span class="hljs-string">"qml/main.qml"</span>).<span class="hljs-built_in">isRelative</span>();      <span class="hljs-comment">// true: no scheme</span>
<span class="hljs-built_in">qDebug</span>() &lt;&lt; <span class="hljs-built_in">QUrl</span>(<span class="hljs-string">"file:main.qml"</span>).<span class="hljs-built_in">isRelative</span>();     <span class="hljs-comment">// false: has "file" scheme</span>
<span class="hljs-built_in">qDebug</span>() &lt;&lt; <span class="hljs-built_in">QUrl</span>(<span class="hljs-string">"file:qml/main.qml"</span>).<span class="hljs-built_in">isRelative</span>(); <span class="hljs-comment">// false: has "file" scheme</span></code></pre></div>

<p> 请注意，包含相对路径的 URL 可以是绝对的，反之亦然： </p>
<div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-comment">// Absolute URL, relative path</span>
<span class="hljs-function">QUrl <span class="hljs-title">url</span><span class="hljs-params">(<span class="hljs-string">"file:file.txt"</span>)</span></span>;
<span class="hljs-built_in">qDebug</span>() &lt;&lt; url.<span class="hljs-built_in">isRelative</span>();                 <span class="hljs-comment">// false: has "file" scheme</span>
<span class="hljs-built_in">qDebug</span>() &lt;&lt; QDir::<span class="hljs-built_in">isAbsolutePath</span>(url.<span class="hljs-built_in">path</span>()); <span class="hljs-comment">// false: relative path</span>

<span class="hljs-comment">// Relative URL, absolute path</span>
url = <span class="hljs-built_in">QUrl</span>(<span class="hljs-string">"/home/user/file.txt"</span>);
<span class="hljs-built_in">qDebug</span>() &lt;&lt; url.<span class="hljs-built_in">isRelative</span>();                 <span class="hljs-comment">// true: has no scheme</span>
<span class="hljs-built_in">qDebug</span>() &lt;&lt; QDir::<span class="hljs-built_in">isAbsolutePath</span>(url.<span class="hljs-built_in">path</span>()); <span class="hljs-comment">// true: absolute path</span></code></pre></div>

<p>可以通过将相对 URL 作为参数传递给<a href="#resolved">resolved</a> () 来解析相对URL，resolve() 返回绝对URL。<a href="#isParentOf">isParentOf</a> () 用于确定一个 URL 是否是另一个 URL 的父级。</p>
<h4><span id="cuo-wu-jian-cha">错误检查</span><a href="#cuo-wu-jian-cha" class="header-anchor">#</a></h4><p>QUrl 能够在解析 URL 时或在使用单独的 setter 方法（如<a href="#setScheme">setScheme</a> ()、<a href="#setHost">setHost</a> () 或<a href="#setPath">setPath</a> ()）设置 URL 的组件时检测 URL 中的许多错误。如果解析或设置函数成功，则任何先前记录的错误条件都将被丢弃。</p>
<p>默认情况下，QUrl setter 方法在<a href="#ParsingMode-enum">QUrl::TolerantMode</a>中运行，这意味着它们接受一些常见的错误和数据的错误表示。另一种解析方法是<a href="#ParsingMode-enum">QUrl::StrictMode</a>，它应用进一步检查。有关解析模式差异的描述，请参见<a href="#ParsingMode-enum">QUrl::ParsingMode</a>。</p>
<p>QUrl 仅检查是否符合 URL 规范。它不会尝试验证高级协议 URL 的格式是否为其他地方的处理程序所期望的格式。例如，以下 URI 都被 QUrl 认为是有效的，即使它们在使用时没有意义：</p>
<ul>
<li>“http:/filename.html”</li>
<li>“mailto://example.com”</li>
</ul>
<p>当解析器遇到错误时，它通过使<a href="#isValid">isValid</a> () 返回 false 和<a href="#toString">toString</a> () / <a href="#toEncoded">toEncoded</a> () 返回一个空字符串来发出事件信号。如果需要向用户展示URL解析失败的原因，可以通过调用<a href="#errorString">errorString</a> ()从QUrl中获取错误情况。请注意，此消息技术性很强，可能对最终用户没有意义。</p>
<p>QUrl 只能记录一种错误情况。如果发现多个错误，则未定义报告哪个错误。</p>
<h4><span id="zi-fu-zhuan-huan">字符转换</span><a href="#zi-fu-zhuan-huan" class="header-anchor">#</a></h4><p>在处理 URL 和字符串时，请遵循以下规则以避免错误的字符转换：</p>
<ul>
<li>在创建<a href="qstring.html">QString</a>以包含来自<a href="qbytearray.html">QByteArray</a>或 char* 的 URL 时，始终使用<a href="qstring.html#fromUtf8">QString::fromUtf8</a> ()。</li>
</ul>
<h2><span id="cheng-yuan-lei-xing-wen-dang">成员类型文档</span><a href="#cheng-yuan-lei-xing-wen-dang" class="header-anchor">#</a></h2><h3><span id="since-5-0-enum-qurl-componentformattingoption-flags-qurl-componentformattingoptions"><code>[since 5.0]</code>enum QUrl::ComponentFormattingOption flags QUrl::ComponentFormattingOptions</span><a href="#since-5-0-enum-qurl-componentformattingoption-flags-qurl-componentformattingoptions" class="header-anchor">#</a></h3><p>组件格式化选项定义了 URL 的组件在写成文本时如何格式化。在<a href="#toString">toString</a> () 和<a href="#toEncoded">toEncoded</a> () 中使用时，它们可以与来自<a href="#UrlFormattingOption-enum">QUrl::FormattingOptions</a>的选项结合使用。</p>
<table>
<thead>
<tr>
<th>持续的</th>
<th>价值</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td><code>QUrl::PrettyDecoded</code></td>
<td><code>0x000000</code></td>
<td>该组件以“漂亮的形式”返回，其中大多数百分比编码的字符都已解码。PrettyDecoded 的确切行为因组件而异，也可能因 Qt 版本而异。这是默认设置。</td>
</tr>
<tr>
<td><code>QUrl::EncodeSpaces</code></td>
<td><code>0x100000</code></td>
<td>将空格字符保留为其编码形式（“%20”）。</td>
</tr>
<tr>
<td><code>QUrl::EncodeUnicode</code></td>
<td><code>0x200000</code></td>
<td>保留以 UTF-8 百分比编码形式编码的非 US-ASCII 字符（例如，U+00E9 代码点的“%C3%A9”，带有尖音的拉丁小写字母 E）。</td>
</tr>
<tr>
<td><code>QUrl::EncodeDelimiters</code></td>
<td>`0x400000</td>
<td>0x800000`</td>
</tr>
<tr>
<td><code>QUrl::EncodeReserved</code></td>
<td><code>0x1000000</code></td>
<td>将规范中不允许在 URL 中使用的 US-ASCII 字符保留为编码形式。这是<a href="#toString">toString</a> () 和<a href="#toEncoded">toEncoded</a> () 的默认值。</td>
</tr>
<tr>
<td><code>QUrl::DecodeReserved</code></td>
<td><code>0x2000000</code></td>
<td>对 URL 规范不允许出现在 URL 中的 US-ASCII 字符进行解码。这是单个组件的 getter 的默认设置。</td>
</tr>
<tr>
<td><code>QUrl::FullyEncoded</code></td>
<td>`EncodeSpaces</td>
<td>EncodeUnicode</td>
</tr>
<tr>
<td><code>QUrl::FullyDecoded</code></td>
<td>`FullyEncoded</td>
<td>DecodeReserved</td>
</tr>
</tbody></table>
<p>EncodeReserved 和 DecodeReserved 的值不应在一次调用中一起使用。如果发生这种情况，行为是未定义的。它们作为单独的值提供，因为关于保留字符的“漂亮模式”的行为在某些组件上是不同的，特别是在完整的 URL 上。</p>
<h5><span id="quan-jie-ma">全解码</span><a href="#quan-jie-ma" class="header-anchor">#</a></h5><p>FullDecoded 模式类似于 Qt 4.x 中返回<a href="qstring.html">QString</a>的函数的行为，因为每个字符都代表它自己并且从不具有任何特殊含义。即使对于百分比字符 (‘%’) 也是如此，它应该被解释为表示文字百分比，而不是百分比编码序列的开头。在所有其他解码模式中，相同的实际字符由序列“%25”表示。</p>
<p>每当将使用 QUrl::FullyDecoded 获得的数据重新应用到<a href>QUrl</a>中时，必须注意将<a href="#ParsingMode-enum">QUrl::DecodedMode</a>参数用于设置器（如<a href="#setPath">setPath</a> () 和<a href="#setUserName">setUserName</a> ()）。不这样做可能会导致将百分比字符 (‘%’) 重新解释为百分比编码序列的开头。</p>
<p>当 URL 的一部分用于非 URL 上下文时，此模式非常有用。例如，要在 FTP 客户端应用程序中提取用户名、密码或文件路径，应使用 FullyDecoded 模式。</p>
<p><a href="qstring.html">应谨慎使用此模式，因为在返回的QString</a>中有两个条件无法可靠地表示。他们是：</p>
<ul>
<li><strong>非 UTF-8 序列：</strong> URL 可能包含不形成有效 UTF-8 序列的百分比编码字符序列。由于 URL 需要使用 UTF-8 进行解码，因此任何解码器失败都会导致<a href="qstring.html">QString</a>包含一个或多个替换字符，其中存在序列。</li>
<li><strong>编码分隔符：</strong>还允许 URL 区分以文字形式找到的分隔符和以百分比编码形式找到的分隔符。这在查询中最常见，但在 URL 的大部分部分都是允许的。</li>
</ul>
<p>下面的例子说明了这个问题：</p>
<div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-function">QUrl <span class="hljs-title">original</span><span class="hljs-params">(<span class="hljs-string">"http://example.com/?q=a%2B%3Db%26c"</span>)</span></span>;
<span class="hljs-function">QUrl <span class="hljs-title">copy</span><span class="hljs-params">(original)</span></span>;
copy.<span class="hljs-built_in">setQuery</span>(copy.<span class="hljs-built_in">query</span>(QUrl::FullyDecoded), QUrl::DecodedMode);

<span class="hljs-built_in">qDebug</span>() &lt;&lt; original.<span class="hljs-built_in">toString</span>();   <span class="hljs-comment">// prints: http://example.com/?q=a%2B%3Db%26c</span>
<span class="hljs-built_in">qDebug</span>() &lt;&lt; copy.<span class="hljs-built_in">toString</span>();       <span class="hljs-comment">// prints: http://example.com/?q=a+=b&amp;c</span></code></pre></div>

<p>如果通过 HTTP GET 使用这两个 URL，则 Web 服务器的解释可能会有所不同。在第一种情况下，它将解释为一个参数，键为“q”，值为“a+=b&amp;c”。在第二种情况下，它可能会解释为两个参数，一个带有键“q”和值“a =b”，第二个带有键“c”并且没有值。</p>
<p>这个枚举是在 Qt 5.0 中引入或修改的。</p>
<p>ComponentFormattingOptions 类型是<a href="qflags.html">QFlags</a> <componentformattingoption> 的 typedef。它存储 ComponentFormattingOption 值的 OR 组合。</componentformattingoption></p>
<p><strong>See also</strong> <a href="#UrlFormattingOption-enum">QUrl::FormattingOptions</a>.</p>
<h3><span id="enum-qurl-parsingmode">enum QUrl::ParsingMode</span><a href="#enum-qurl-parsingmode" class="header-anchor">#</a></h3><p>解析模式控制<a href>QUrl</a>解析字符串的方式。</p>
<table>
<thead>
<tr>
<th>持续的</th>
<th>价值</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td><code>QUrl::TolerantMode</code></td>
<td><code>0</code></td>
<td><a href>QUrl</a>将尝试纠正 URL 中的一些常见错误。此模式对于解析来自未知严格符合标准的来源的 URL 很有用。</td>
</tr>
<tr>
<td><code>QUrl::StrictMode</code></td>
<td><code>1</code></td>
<td>只接受有效的 URL。此模式对于常规 URL 验证很有用。</td>
</tr>
<tr>
<td><code>QUrl::DecodedMode</code></td>
<td><code>2</code></td>
<td><a href>QUrl</a>将以完全解码的形式解释 URL 组件，其中百分比字符代表自己，而不是百分比编码序列的开头。此模式仅对 URL 的 setter 设置组件有效；在<a href>QUrl</a>构造函数、<a href="#fromEncoded">fromEncoded</a> () 或<a href="#setUrl">setUrl</a> () 中是不允许的。有关此模式的更多信息，请参阅<a href="#ComponentFormattingOption-enum">QUrl::FullyDecoded</a>的文档。</td>
</tr>
</tbody></table>
<p>在 TolerantMode 中，解析器具有以下行为：</p>
<ul>
<li>空格和“%20”：将接受未编码的空格字符，并将被视为等同于“%20”。</li>
<li>单个“%”字符：任何出现的百分比字符“%”后面没有正好两个十六进制字符（例如，“13% coverage.html”）将被“%25”替换。请注意，一个单独的“%”字符将触发所有百分比字符的校正模式。</li>
<li>保留和未保留字符：编码的 URL 应该只包含几个字符作为文字；所有其他字符都应进行百分比编码。在 TolerantMode 中，如果在 URL 中找到这些字符将被接受：空格 / 双引号 / “&lt;” / “&gt;” / “” / “^” / “`” / “{“ / “|” <a href="#ComponentFormattingOption-enum">/ “}” 通过将QUrl::DecodeReserved</a>传递给<a href="#toString">toString</a> () 或<a href="#toEncoded">toEncoded</a> ()可以再次解码相同的字符。在单个组件的 getter 中，这些字符通常以解码的形式返回。</li>
</ul>
<p>在 StrictMode 下，如果发现解析错误，<a href="#isValid">isValid</a> () 将返回<code>false</code>，<a href="#errorString">errorString</a> () 将返回描述错误的消息。如果检测到多个错误，则未定义报告哪个错误。</p>
<p>请注意，TolerantMode 通常不足以解析用户输入，它通常包含比解析器可以处理的更多错误和期望。在处理直接来自用户的数据时——与来自数据传输源（例如其他程序）的数据相反——建议使用<a href="#fromUserInput">fromUserInput</a> ()。</p>
<p><strong>另请参见</strong><a href="#fromUserInput">fromUserInput</a> ()、<a href="#setUrl">setUrl</a> ()、<a href="#toString">toString</a> ()、<a href="#toEncoded">toEncoded</a> () 和<a href="#UrlFormattingOption-enum">QUrl::FormattingOptions</a>。</p>
<h3><span id="enum-qurl-urlformattingoption-flags-qurl-formattingoptions">enum QUrl::UrlFormattingOption flags QUrl::FormattingOptions</span><a href="#enum-qurl-urlformattingoption-flags-qurl-formattingoptions" class="header-anchor">#</a></h3><p>格式化选项定义了 URL 在写成文本时的格式。</p>
<table>
<thead>
<tr>
<th>持续的</th>
<th>价值</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td><code>QUrl::None</code></td>
<td><code>0x0</code></td>
<td>URL 的格式不变。</td>
</tr>
<tr>
<td><code>QUrl::RemoveScheme</code></td>
<td><code>0x1</code></td>
<td>该方案已从 URL 中删除。</td>
</tr>
<tr>
<td><code>QUrl::RemovePassword</code></td>
<td><code>0x2</code></td>
<td>URL 中的所有密码都将被删除。</td>
</tr>
<tr>
<td><code>QUrl::RemoveUserInfo</code></td>
<td>`RemovePassword</td>
<td>0x4`</td>
</tr>
<tr>
<td><code>QUrl::RemovePort</code></td>
<td><code>0x8</code></td>
<td>任何指定的端口都会从 URL 中删除。</td>
</tr>
<tr>
<td><code>QUrl::RemoveAuthority</code></td>
<td>`RemoveUserInfo</td>
<td>RemovePort</td>
</tr>
<tr>
<td><code>QUrl::RemovePath</code></td>
<td><code>0x20</code></td>
<td>URL 的路径被删除，只留下方案、主机地址和端口（如果存在）。</td>
</tr>
<tr>
<td><code>QUrl::RemoveQuery</code></td>
<td><code>0x40</code></td>
<td>URL 的查询部分（在“？”字符之后）被删除。</td>
</tr>
<tr>
<td><code>QUrl::RemoveFragment</code></td>
<td><code>0x80</code></td>
<td></td>
</tr>
<tr>
<td><code>QUrl::RemoveFilename</code></td>
<td><code>0x800</code></td>
<td>文件名（即路径中最后一个“/”之后的所有内容）被删除。除非设置了 StripTrailingSlash，否则将保留尾随 ‘/‘。仅在未设置 RemovePath 时有效。</td>
</tr>
<tr>
<td><code>QUrl::PreferLocalFile</code></td>
<td><code>0x200</code></td>
<td>如果根据<a href="#isLocalFile">isLocalFile</a> ()该URL是本地文件且不包含查询或片段，则返回本地文件路径。</td>
</tr>
<tr>
<td><code>QUrl::StripTrailingSlash</code></td>
<td><code>0x400</code></td>
<td>尾部斜杠从路径中删除（如果存在）。</td>
</tr>
<tr>
<td><code>QUrl::NormalizePathSegments</code></td>
<td><code>0x1000</code></td>
<td>修改路径以删除多余的目录分隔符，并解析“.”和“..”（尽可能）。对于非本地路径，保留相邻的斜线。</td>
</tr>
</tbody></table>
<p>请注意，QUrl 符合的 Nameprep 中的大小写折叠规则要求<a href>主机</a><a target="_blank" rel="noopener" href="https://datatracker.ietf.org/doc/html/rfc3491">名</a>始终转换为小写，而不管使用的 Qt::FormattingOptions 是什么。</p>
<p><a href="#ComponentFormattingOption-enum">QUrl::ComponentFormattingOptions</a>中的选项也是可能的。</p>
<p>FormattingOptions 类型是<a href="qflags.html">QFlags</a> <urlformattingoption> 的 typedef。它存储 UrlFormattingOption 值的 OR 组合。</urlformattingoption></p>
<p><strong>另请参阅</strong><a href="#ComponentFormattingOption-enum">QUrl::ComponentFormattingOptions</a>。</p>
<h3><span id="since-5-4-enum-qurl-userinputresolutionoption-flags-qurl-userinputresolutionoptions"><code>[since 5.4]</code>enum QUrl::UserInputResolutionOption flags QUrl::UserInputResolutionOptions</span><a href="#since-5-4-enum-qurl-userinputresolutionoption-flags-qurl-userinputresolutionoptions" class="header-anchor">#</a></h3><p>用户输入解析选项定义<a href="#fromUserInput">fromUserInput</a> () 应该如何解释可能是相对路径或 HTTP URL 的短格式的字符串。例如<code>file.pl</code>，可以是本地文件或 URL <code>http://file.pl</code>。</p>
<table>
<thead>
<tr>
<th>持续的</th>
<th>价值</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td><code>QUrl::DefaultResolution</code></td>
<td><code>0</code></td>
<td>默认的解析机制是检查本地文件是否存在，在给<a href="#fromUserInput">fromUserInput</a>的工作目录中，并且在这种情况下只返回本地路径。否则假定一个 URL。</td>
</tr>
<tr>
<td><code>QUrl::AssumeLocalFile</code></td>
<td><code>1</code></td>
<td>此选项使<a href="#fromUserInput">fromUserInput</a> () 始终返回本地路径，除非输入包含方案，例如<code>http://file.pl</code>. 这对于诸如文本编辑器之类的应用程序很有用，它们能够在文件不存在时创建文件。</td>
</tr>
</tbody></table>
<p>这个枚举是在 Qt 5.4 中引入或修改的。</p>
<p>UserInputResolutionOptions 类型是<a href="qflags.html">QFlags</a> <userinputresolutionoption> 的 typedef。它存储 UserInputResolutionOption 值的 OR 组合。</userinputresolutionoption></p>
<p><strong>另见</strong><a href="#fromUserInput">fromUserInput</a> ()。</p>
<h2><span id="cheng-yuan-han-shu-wen-dang">成员函数文档</span><a href="#cheng-yuan-han-shu-wen-dang" class="header-anchor">#</a></h2><h3><span id="since-5-2-qurl-qurl-qurl-amp-amp-other"><code>[since 5.2]</code>QUrl::QUrl( &amp;&amp;<em>other</em>)</span><a href="#since-5-2-qurl-qurl-qurl-amp-amp-other" class="header-anchor">#</a></h3><p>移动构造一个 QUrl 实例，使其指向与<em>other</em>指向的对象相同的对象。</p>
<p>这个函数是在 Qt 5.2 中引入的。</p>
<h3><span id="qurl-qurl-const-qstring-amp-url-qurl-parsingmode-parsingmode-tolerantmode">QUrl::QUrl(const  &amp;<em>url</em>,  <em>parsingMode</em> = TolerantMode)</span><a href="#qurl-qurl-const-qstring-amp-url-qurl-parsingmode-parsingmode-tolerantmode" class="header-anchor">#</a></h3><p>通过解析<em>url</em>构造一个 URL 。QUrl 将自动对 URL 中不允许的所有字符进行百分比编码，并对表示未保留字符（字母、数字、连字符、下划线、点和波浪号）的百分比编码序列进行解码。所有其他字符都保留其原始形式。</p>
<p>使用解析器模式<em>parsingMode</em>解析<em>url</em>。在<a href="#ParsingMode-enum">TolerantMode</a>（默认值）中，QUrl 将纠正某些错误，特别是没有后跟两个十六进制数字的百分比字符 (‘%’) 的存在，并且它可以接受任何位置的任何字符。在<a href="#ParsingMode-enum">StrictMode</a>中，不允许出现编码错误，QUrl 还将检查某些禁止字符是否以未编码的形式出现。<a href="#ParsingMode-enum">如果在StrictMode</a>中检测到错误，<a href="#isValid">isValid</a> () 将返回 false。在此上下文中不允许使用解析模式<a href="#ParsingMode-enum">DecodedMode 。</a></p>
<p>例子：</p>
<div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-function">QUrl <span class="hljs-title">url</span><span class="hljs-params">(<span class="hljs-string">"http://www.example.com/List of holidays.xml"</span>)</span></span>;
<span class="hljs-comment">// url.toEncoded() == "http://www.example.com/List%20of%20holidays.xml"</span></code></pre></div>

<p> 要从编码字符串构造 URL，还可以使用<a target="_blank" rel="noopener" href="https://doc.qt.io/qt-6/qurl.html#fromEncoded">fromEncoded</a> ()： </p>
<div class="code-wrapper"><pre><code class="hljs c++">QUrl url = QUrl::<span class="hljs-built_in">fromEncoded</span>(<span class="hljs-string">"http://qt-project.org/List%20of%20holidays.xml"</span>);</code></pre></div>

<p>这两个函数是等价的，并且在 Qt 5 中，这两个函数都接受编码数据。通常，QUrl 构造函数或<a target="_blank" rel="noopener" href="https://doc.qt.io/qt-6/qurl.html#setUrl">setUrl</a> () 与<a target="_blank" rel="noopener" href="https://doc.qt.io/qt-6/qurl.html#fromEncoded">fromEncoded</a> () 的选择将取决于源数据：构造函数和<a target="_blank" rel="noopener" href="https://doc.qt.io/qt-6/qurl.html#setUrl">setUrl</a> () 采用<a target="_blank" rel="noopener" href="https://doc.qt.io/qt-6/qstring.html">QString</a>，而<a target="_blank" rel="noopener" href="https://doc.qt.io/qt-6/qurl.html#fromEncoded">fromEncoded</a>采用<a target="_blank" rel="noopener" href="https://doc.qt.io/qt-6/qbytearray.html">QByteArray</a>。</p>
<p><strong>另请参见</strong><a target="_blank" rel="noopener" href="https://doc.qt.io/qt-6/qurl.html#setUrl">setUrl</a> ()、<a target="_blank" rel="noopener" href="https://doc.qt.io/qt-6/qurl.html#fromEncoded">fromEncoded</a> () 和<a target="_blank" rel="noopener" href="https://doc.qt.io/qt-6/qurl.html#ParsingMode-enum">TolerantMode</a>。</p>
<h3><span id="qurl-qurl-const-qurl-amp-other">QUrl::QUrl(const  &amp;<em>other</em>)</span><a href="#qurl-qurl-const-qurl-amp-other" class="header-anchor">#</a></h3><p> 构造<em>other</em>的副本。 </p>
<h3><span id="qurl-qurl">QUrl::QUrl()</span><a href="#qurl-qurl" class="header-anchor">#</a></h3><p> 构造一个空的 QUrl 对象。 </p>
<h3><span id="since-5-2-qurl-amp-qurl-operator-qurl-amp-amp-other"><code>[since 5.2]</code> &amp;QUrl::operator=( &amp;&amp;<em>other</em>)</span><a href="#since-5-2-qurl-amp-qurl-operator-qurl-amp-amp-other" class="header-anchor">#</a></h3><p>移动构造将<em>other</em>分配给此<a target="_blank" rel="noopener" href="https://doc.qt.io/qt-6/qurl.html">QUrl</a>实例。</p>
<p>这个函数是在 Qt 5.2 中引入的。</p>
<h3><span id="qurl-amp-qurl-operator-const-qstring-amp-url"> &amp;QUrl::operator=(const  &amp;<em>url</em>)</span><a href="#qurl-amp-qurl-operator-const-qstring-amp-url" class="header-anchor">#</a></h3><p> 将指定的<em>url</em>分配给此对象。 </p>
<h3><span id="qurl-amp-qurl-operator-const-qurl-amp-url"> &amp;QUrl::operator=(const  &amp;<em>url</em>)</span><a href="#qurl-amp-qurl-operator-const-qurl-amp-url" class="header-anchor">#</a></h3><p> 将指定的<em>url</em>分配给此对象。 </p>
<h3><span id="qurl-qurl">QUrl::~QUrl()</span><a href="#qurl-qurl" class="header-anchor">#</a></h3><p> 析构函数；在对象被删除之前立即调用。 </p>
<h3><span id="since-5-2-qurl-qurl-adjusted-qurl-formattingoptions-options-const"><code>[since 5.2]</code> QUrl::adjusted( <em>options</em>) const</span><a href="#since-5-2-qurl-qurl-adjusted-qurl-formattingoptions-options-const" class="header-anchor">#</a></h3><p>返回 URL 的调整版本。可以通过传递带有<em>options</em>的标志来自定义输出。</p>
<p><a target="_blank" rel="noopener" href="https://doc.qt.io/qt-6/qurl.html#ComponentFormattingOption-enum">QUrl::ComponentFormattingOption</a>的编码选项对这种方法没有多大意义，<a target="_blank" rel="noopener" href="https://doc.qt.io/qt-6/qurl.html#UrlFormattingOption-enum">QUrl::PreferLocalFile</a>也没有。</p>
<p>这始终等价于<a target="_blank" rel="noopener" href="https://doc.qt.io/qt-6/qurl.html">QUrl</a> ( <a target="_blank" rel="noopener" href="https://doc.qt.io/qt-6/qurl.html#toString">url.toString</a> (options))。</p>
<p>这个函数是在 Qt 5.2 中引入的。</p>
<p><strong>另请参见</strong><a target="_blank" rel="noopener" href="https://doc.qt.io/qt-6/qurl.html#UrlFormattingOption-enum">FormattingOptions</a>、<a target="_blank" rel="noopener" href="https://doc.qt.io/qt-6/qurl.html#toEncoded">toEncoded</a> () 和<a target="_blank" rel="noopener" href="https://doc.qt.io/qt-6/qurl.html#toString">toString</a> ()。</p>
<h3><span id="qstring-qurl-authority-qurl-componentformattingoptions-options-prettydecoded-const"> QUrl::authority( <em>options</em> = PrettyDecoded) const</span><a href="#qstring-qurl-authority-qurl-componentformattingoptions-options-prettydecoded-const" class="header-anchor">#</a></h3><p>如果已定义，则返回 URL 的权限；否则返回一个空字符串。</p>
<p>此函数返回一个明确的值，其中可能包含仍以百分比编码的字符，以及一些在<a target="_blank" rel="noopener" href="https://doc.qt.io/qt-6/qstring.html">QString</a>中无法以解码形式表示的控制序列。</p>
<p><em>options</em>参数控制如何格式化用户信息组件。<a target="_blank" rel="noopener" href="https://doc.qt.io/qt-6/qurl.html#ComponentFormattingOption-enum">此函数中不允许QUrl::FullyDecoded</a>的值。如果需要获取完全解码的数据，分别调用<a target="_blank" rel="noopener" href="https://doc.qt.io/qt-6/qurl.html#userName">userName</a> ()、<a target="_blank" rel="noopener" href="https://doc.qt.io/qt-6/qurl.html#password">password</a> ()、<a target="_blank" rel="noopener" href="https://doc.qt.io/qt-6/qurl.html#host">host</a> ()和<a target="_blank" rel="noopener" href="https://doc.qt.io/qt-6/qurl.html#port">port</a> ()。</p>
<p><strong>另请参见</strong><a target="_blank" rel="noopener" href="https://doc.qt.io/qt-6/qurl.html#setAuthority">setAuthority</a> ()、<a target="_blank" rel="noopener" href="https://doc.qt.io/qt-6/qurl.html#userInfo">userInfo</a> ()、<a target="_blank" rel="noopener" href="https://doc.qt.io/qt-6/qurl.html#userName">userName</a> ()、<a target="_blank" rel="noopener" href="https://doc.qt.io/qt-6/qurl.html#password">password</a> ()、<a target="_blank" rel="noopener" href="https://doc.qt.io/qt-6/qurl.html#host">host</a> () 和<a target="_blank" rel="noopener" href="https://doc.qt.io/qt-6/qurl.html#port">port</a> ()。</p>
<h3><span id="void-qurl-clear">void QUrl::clear()</span><a href="#void-qurl-clear" class="header-anchor">#</a></h3><p>重置<a target="_blank" rel="noopener" href="https://doc.qt.io/qt-6/qurl.html">QUrl</a>的内容。调用此函数后，<a target="_blank" rel="noopener" href="https://doc.qt.io/qt-6/qurl.html">QUrl</a>等于使用默认空构造函数构造的 QUrl。</p>
<p><strong>另请参见</strong><a target="_blank" rel="noopener" href="https://doc.qt.io/qt-6/qurl.html#isEmpty">isEmpty</a> ()。</p>
<h3><span id="qstring-qurl-errorstring-const"> QUrl::errorString() const</span><a href="#qstring-qurl-errorstring-const" class="header-anchor">#</a></h3><p><a target="_blank" rel="noopener" href="https://doc.qt.io/qt-6/qurl.html">如果修改此QUrl</a>对象的最后一个操作遇到解析错误，则返回错误消息。如果未检测到错误，则此函数返回一个空字符串，并且<a target="_blank" rel="noopener" href="https://doc.qt.io/qt-6/qurl.html#isValid">isValid</a> () 返回<code>true</code>。</p>
<p>此函数返回的错误消息本质上是技术性的，最终用户可能无法理解。它对试图理解为什么<a target="_blank" rel="noopener" href="https://doc.qt.io/qt-6/qurl.html">QUrl</a>不接受某些输入的开发人员非常有用。</p>
<p><strong>另请参见</strong><a target="_blank" rel="noopener" href="https://doc.qt.io/qt-6/qurl.html#ParsingMode-enum">QUrl::ParsingMode</a>。</p>
<h3><span id="since-5-2-qstring-qurl-filename-qurl-componentformattingoptions-options-fullydecoded-const"><code>[since 5.2]</code> QUrl::fileName( <em>options</em> = FullyDecoded) const</span><a href="#since-5-2-qstring-qurl-filename-qurl-componentformattingoptions-options-fullydecoded-const" class="header-anchor">#</a></h3><p>返回文件的名称，不包括目录路径。</p>
<p>请注意，如果此<a target="_blank" rel="noopener" href="https://doc.qt.io/qt-6/qurl.html">QUrl</a>对象的路径以斜杠结尾，则文件名被视为空。</p>
<p>如果路径不包含任何斜杠，则将其完全作为文件名返回。</p>
<p>例子：</p>
<div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-function">QUrl <span class="hljs-title">url</span><span class="hljs-params">(<span class="hljs-string">"http://qt-project.org/support/file.html"</span>)</span></span>;
<span class="hljs-comment">// url.adjusted(RemoveFilename) == "http://qt-project.org/support/"</span>
<span class="hljs-comment">// url.fileName() == "file.html"</span></code></pre></div>

<p><em>options</em>参数控制如何格式化文件名组件。所有值都会产生明确的结果。使用<a target="_blank" rel="noopener" href="https://doc.qt.io/qt-6/qurl.html#ComponentFormattingOption-enum">QUrl::FullyDecoded</a>，所有百分比编码的序列都被解码；否则，返回的值可能包含某些控制序列的百分比编码序列，这些控制序列在<a target="_blank" rel="noopener" href="https://doc.qt.io/qt-6/qstring.html">QString</a>中无法以解码形式表示。</p>
<p>这个函数是在 Qt 5.2 中引入的。</p>
<p><strong>See also</strong> <a href="#path">path</a>().</p>
<h3><span id="qstring-qurl-fragment-qurl-componentformattingoptions-options-prettydecoded-const"> QUrl::fragment( <em>options</em> = PrettyDecoded) const</span><a href="#qstring-qurl-fragment-qurl-componentformattingoptions-options-prettydecoded-const" class="header-anchor">#</a></h3><p>返回 URL 的片段。要确定解析后的 URL 是否包含片段，请使用<a target="_blank" rel="noopener" href="https://doc.qt.io/qt-6/qurl.html#hasFragment">hasFragment</a> ()。</p>
<p><em>options</em>参数控制如何格式化片段组件。所有值都会产生明确的结果。使用<a target="_blank" rel="noopener" href="https://doc.qt.io/qt-6/qurl.html#ComponentFormattingOption-enum">QUrl::FullyDecoded</a>，所有百分比编码的序列都被解码；否则，返回的值可能包含某些控制序列的百分比编码序列，这些控制序列在<a target="_blank" rel="noopener" href="https://doc.qt.io/qt-6/qstring.html">QString</a>中无法以解码形式表示。</p>
<p>请注意，如果存在那些不可表示的序列，则<a target="_blank" rel="noopener" href="https://doc.qt.io/qt-6/qurl.html#ComponentFormattingOption-enum">QUrl::FullyDecoded可能会导致数据丢失。</a>当结果将在非 URL 上下文中使用时，建议使用该值。</p>
<p><strong>另请参见</strong><a target="_blank" rel="noopener" href="https://doc.qt.io/qt-6/qurl.html#hasFragment">setFragment</a> ( ) 和<a target="_blank" rel="noopener" href="https://doc.qt.io/qt-6/qurl.html#setFragment">hasFragment</a> ()。</p>
<h3><span id="static-qstring-qurl-fromace-const-qbytearray-amp-domain"><code>[static]</code> QUrl::fromAce(const  &amp;<em>domain</em>)</span><a href="#static-qstring-qurl-fromace-const-qbytearray-amp-domain" class="header-anchor">#</a></h3><p>返回以 ASCII 兼容编码 (ACE) 编码的给定域名<em>domain的 Unicode 形式。</em>此函数的结果被认为等同于<em>domain</em>。</p>
<p>如果<em>domain</em>中的值无法编码，则将其转换为<a target="_blank" rel="noopener" href="https://doc.qt.io/qt-6/qstring.html">QString</a>并返回。</p>
<p>ASCII 兼容编码 (ACE) 由 RFC 3490、RFC 3491 和 RFC 3492 定义。它是应用程序中的国际化域名 (IDNA) 规范的一部分，允许<code>"example.com"</code>使用国际字符编写域名（如 ）。</p>
<h3><span id="static-since-5-2-qurl-qurl-fromcfurl-cfurlref-url"><code>[static, since 5.2]</code> QUrl::fromCFURL(CFURLRef <em>url</em>)</span><a href="#static-since-5-2-qurl-qurl-fromcfurl-cfurlref-url" class="header-anchor">#</a></h3><p>构造一个包含 CFURL <em>url</em>副本的<a target="_blank" rel="noopener" href="https://doc.qt.io/qt-6/qurl.html">QUrl</a>。</p>
<p>这个函数是在 Qt 5.2 中引入的。</p>
<h3><span id="static-qurl-qurl-fromencoded-const-qbytearray-amp-input-qurl-parsingmode-parsingmode-tolerantmode"><code>[static]</code> QUrl::fromEncoded(const  &amp;<em>input</em>,  <em>parsingMode</em> = TolerantMode)</span><a href="#static-qurl-qurl-fromencoded-const-qbytearray-amp-input-qurl-parsingmode-parsingmode-tolerantmode" class="header-anchor">#</a></h3><p>解析<em>input</em>并返回相应的<a target="_blank" rel="noopener" href="https://doc.qt.io/qt-6/qurl.html">QUrl</a>。假设<em>input</em>为编码形式，仅包含 ASCII 字符。</p>
<p>使用<em>parsingMode</em>解析 URL 。有关此参数的更多信息，请参见<a target="_blank" rel="noopener" href="https://doc.qt.io/qt-6/qurl.html#setUrl">setUrl</a> ()。在此上下文中不允许使用<a target="_blank" rel="noopener" href="https://doc.qt.io/qt-6/qurl.html#ParsingMode-enum">QUrl::DecodedMode 。</a></p>
<p><strong>另见</strong><a target="_blank" rel="noopener" href="https://doc.qt.io/qt-6/qurl.html#toEncoded">toEncoded</a> () 和<a target="_blank" rel="noopener" href="https://doc.qt.io/qt-6/qurl.html#setUrl">setUrl</a> ()。</p>
<h3><span id="static-qurl-qurl-fromlocalfile-const-qstring-amp-localfile"><code>[static]</code> QUrl::fromLocalFile(const  &amp;<em>localFile</em>)</span><a href="#static-qurl-qurl-fromlocalfile-const-qstring-amp-localfile" class="header-anchor">#</a></h3><p>返回<em>localFile的</em><a target="_blank" rel="noopener" href="https://doc.qt.io/qt-6/qurl.html">QUrl</a>表示，解释为本地文件。此函数接受由斜杠分隔的路径以及此平台的本机分隔符。</p>
<p>此函数还接受带有双斜杠（或反斜杠）的路径以指示远程文件，如“//servername/path/to/file.txt”。请注意，只有某些平台才能真正使用<a target="_blank" rel="noopener" href="https://doc.qt.io/qt-6/qfile.html#open">QFile::open</a> () 打开此文件。</p>
<p>一个空的<em>localFile</em>会导致一个空的 URL（从 Qt 5.4 开始）。</p>
<div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-built_in">qDebug</span>() &lt;&lt; QUrl::<span class="hljs-built_in">fromLocalFile</span>(<span class="hljs-string">"file.txt"</span>);            <span class="hljs-comment">// QUrl("file:file.txt")</span>
<span class="hljs-built_in">qDebug</span>() &lt;&lt; QUrl::<span class="hljs-built_in">fromLocalFile</span>(<span class="hljs-string">"/home/user/file.txt"</span>); <span class="hljs-comment">// QUrl("file:///home/user/file.txt")</span>
<span class="hljs-built_in">qDebug</span>() &lt;&lt; QUrl::<span class="hljs-built_in">fromLocalFile</span>(<span class="hljs-string">"file:file.txt"</span>);       <span class="hljs-comment">// doesn't make sense; expects path, not url with scheme</span></code></pre></div>

<p> 在上面代码片段的第一行中，文件 URL 是从本地相对路径构造的。具有相对路径的文件 URL 仅在存在用于解析它的基本 URL 时才有意义。例如： </p>
<div class="code-wrapper"><pre><code class="hljs c++">QUrl url = QUrl::<span class="hljs-built_in">fromLocalFile</span>(<span class="hljs-string">"file.txt"</span>);
QUrl baseUrl = <span class="hljs-built_in">QUrl</span>(<span class="hljs-string">"file:/home/user/"</span>);
<span class="hljs-comment">// wrong: prints QUrl("file:file.txt"), as url already has a scheme</span>
<span class="hljs-built_in">qDebug</span>() &lt;&lt; baseUrl.<span class="hljs-built_in">resolved</span>(url);</code></pre></div>

<p> 要解析这样的 URL，需要事先删除该方案： </p>
<div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-comment">// correct: prints QUrl("file:///home/user/file.txt")</span>
url.<span class="hljs-built_in">setScheme</span>(<span class="hljs-built_in">QString</span>());
<span class="hljs-built_in">qDebug</span>() &lt;&lt; baseUrl.<span class="hljs-built_in">resolved</span>(url);</code></pre></div>

<p> 因此，相对文件路径最好使用相对 URL（即无方案）： </p>
<div class="code-wrapper"><pre><code class="hljs c++">QUrl url = <span class="hljs-built_in">QUrl</span>(<span class="hljs-string">"file.txt"</span>);
QUrl baseUrl = <span class="hljs-built_in">QUrl</span>(<span class="hljs-string">"file:/home/user/"</span>);
<span class="hljs-comment">// prints QUrl("file:///home/user/file.txt")</span>
<span class="hljs-built_in">qDebug</span>() &lt;&lt; baseUrl.<span class="hljs-built_in">resolved</span>(url);</code></pre></div>

<p><strong>See also</strong> <a href="#toLocalFile">toLocalFile</a>(), <a href="#isLocalFile">isLocalFile</a>(), and <a href="qdir.html#toNativeSeparators">QDir::toNativeSeparators</a>().</p>
<h3><span id="static-since-5-2-qurl-qurl-fromnsurl-const-nsurl-url"><code>[static, since 5.2]</code> QUrl::fromNSURL(const NSURL *<em>url</em>)</span><a href="#static-since-5-2-qurl-qurl-fromnsurl-const-nsurl-url" class="header-anchor">#</a></h3><p>构造一个包含 NSURL <em>url</em>副本的<a target="_blank" rel="noopener" href="https://doc.qt.io/qt-6/qurl.html">QUrl</a>。</p>
<p>这个函数是在 Qt 5.2 中引入的。</p>
<h3><span id="static-qstring-qurl-frompercentencoding-const-qbytearray-amp-input"><code>[static]</code> QUrl::fromPercentEncoding(const  &amp;<em>input</em>)</span><a href="#static-qstring-qurl-frompercentencoding-const-qbytearray-amp-input" class="header-anchor">#</a></h3><p>返回<em>input</em>的解码副本。<em>input</em>首先从百分比编码解码，然后从 UTF-8 转换为 unicode。</p>
<p><strong>注意：</strong>给定无效输入（例如包含序列“%G5”的字符串，它不是有效的十六进制数），输出也将无效。例如：序列“%G5”可以解码为“W”。</p>
<h3><span id="static-since-5-1-qlist-lt-qurl-gt-qurl-fromstringlist-const-qstringlist-amp-urls-qurl-parsingmode-mode-tolerantmode"><code>[static, since 5.1]</code>&lt;&gt; QUrl::fromStringList(const  &amp;<em>urls</em>,  <em>mode</em> = TolerantMode)</span><a href="#static-since-5-1-qlist-lt-qurl-gt-qurl-fromstringlist-const-qstringlist-amp-urls-qurl-parsingmode-mode-tolerantmode" class="header-anchor">#</a></h3><p>使用<a target="_blank" rel="noopener" href="https://doc.qt.io/qt-6/qurl.html">QUrl</a> (str, <em>mode</em> )将表示<em>url</em>的字符串列表转换为url 列表。请注意，这意味着所有字符串都必须是 url，而不是例如本地路径。</p>
<p>这个函数是在 Qt 5.1 中引入的。</p>
<h3><span id="static-since-5-4-qurl-qurl-fromuserinput-const-qstring-amp-userinput-const-qstring-amp-workingdirectory-qstring-qurl-userinputresolutionoptions-options-defaultresolution"><code>[static, since 5.4]</code> QUrl::fromUserInput(const  &amp;<em>userInput</em>, const  &amp;<em>workingDirectory</em> = QString(),  <em>options</em> = DefaultResolution)</span><a href="#static-since-5-4-qurl-qurl-fromuserinput-const-qstring-amp-userinput-const-qstring-amp-workingdirectory-qstring-qurl-userinputresolutionoptions-options-defaultresolution" class="header-anchor">#</a></h3><p>如果可以推断出，则从用户提供的<em>userInput</em>字符串返回一个有效的 URL 。在不可能的情况下，返回一个无效的<a target="_blank" rel="noopener" href="https://doc.qt.io/qt-6/qurl.html#QUrl">QUrl</a> ()。</p>
<p>这允许用户以纯字符串的形式输入 URL 或本地文件路径。这个字符串可以手动输入到地址栏中，从剪贴板中获取，或者通过命令行参数传入。</p>
<p>当字符串还不是有效的 URL 时，会进行最佳猜测，并做出各种假设。</p>
<p>如果字符串对应于系统上的有效文件路径，则使用<a target="_blank" rel="noopener" href="https://doc.qt.io/qt-6/qurl.html#fromLocalFile">QUrl::fromLocalFile</a> () 构造一个 file:// URL。</p>
<p>如果不是这种情况，则会尝试将字符串转换为 http:// 或 ftp:// URL。后者在字符串以“ftp”开头的情况下。然后将结果通过<a target="_blank" rel="noopener" href="https://doc.qt.io/qt-6/qurl.html">QUrl</a>的容错解析器，如果成功或成功，则返回有效的<a target="_blank" rel="noopener" href="https://doc.qt.io/qt-6/qurl.html">QUrl</a>，否则返回<a target="_blank" rel="noopener" href="https://doc.qt.io/qt-6/qurl.html#QUrl">QUrl</a> ()。</p>
<h4><span id="li-zi">例子：</span><a href="#li-zi" class="header-anchor">#</a></h4><ul>
<li>qt-project.org 变成 <a target="_blank" rel="noopener" href="http://qt-project.org/">http://qt-project.org</a></li>
<li>ftp.qt-project.org 变为 <a href="ftp://ftp.qt-project.org/">ftp://ftp.qt-project.org</a></li>
<li>主机名变成 <a target="_blank" rel="noopener" href="http://hostname/">http://hostname</a></li>
<li>/home/user/test.html 变成 file:///home/user/test.html</li>
</ul>
<p>为了能够处理相对路径，此方法采用可选的<em>workingDirectory</em>路径。这在处理命令行参数时特别有用。如果<em>workingDirectory</em>为空，则不会处理相对路径。</p>
<p>默认情况下，只有当文件实际存在于给定工作目录中时，才会将看起来像相对路径的输入字符串视为相对路径。如果应用程序可以处理尚不存在的文件，它应该在<em>options中传递标志</em><a target="_blank" rel="noopener" href="https://doc.qt.io/qt-6/qurl.html#UserInputResolutionOption-enum">AssumeLocalFile</a>。</p>
<p>这个函数是在 Qt 5.4 中引入的。</p>
<h3><span id="bool-qurl-hasfragment-const">bool QUrl::hasFragment() const</span><a href="#bool-qurl-hasfragment-const" class="header-anchor">#</a></h3><p> 返回<code>true</code>此 URL 是否包含片段（即，如果在其上看到 #）。 </p>
<p><strong>See also</strong> <a href="#fragment">fragment</a>() and <a href="#setFragment">setFragment</a>().</p>
<h3><span id="bool-qurl-hasquery-const">bool QUrl::hasQuery() const</span><a href="#bool-qurl-hasquery-const" class="header-anchor">#</a></h3><p>返回<code>true</code>此 URL 是否包含查询（即，是否在其上看到 ?）。</p>
<p><strong>另请参见</strong><a target="_blank" rel="noopener" href="https://doc.qt.io/qt-6/qurl.html#setQuery">setQuery</a> ()、<a target="_blank" rel="noopener" href="https://doc.qt.io/qt-6/qurl.html#query">query</a> () 和<a target="_blank" rel="noopener" href="https://doc.qt.io/qt-6/qurl.html#hasFragment">hasFragment</a> ()。</p>
<h3><span id="qstring-qurl-host-qurl-componentformattingoptions-options-fullydecoded-const"> QUrl::host( <em>options</em> = FullyDecoded) const</span><a href="#qstring-qurl-host-qurl-componentformattingoptions-options-fullydecoded-const" class="header-anchor">#</a></h3><p>如果已定义，则返回 URL 的主机；否则返回一个空字符串。</p>
<p><em>options</em>参数控制主机名的格式。QUrl <a target="_blank" rel="noopener" href="https://doc.qt.io/qt-6/qurl.html#ComponentFormattingOption-enum">::EncodeUnicode</a>选项将导致此函数以 ASCII 兼容编码 (ACE) 形式返回主机名，该格式适用于非 8 位干净或需要旧主机名的通道（例如 DNS 请求或在 HTTP 请求标头中）。如果该标志不存在，则此函数根据允许的顶级域列表（请参阅<a target="_blank" rel="noopener" href="https://doc.qt.io/qt-6/qurl.html#idnWhitelist">idnWhitelist</a> ()）以 Unicode 形式返回国际域名 (IDN)。</p>
<p>所有其他标志都被忽略。主机名不能包含控制字符或百分比字符，因此返回的值可以认为是完全解码的。</p>
<p><strong>另请参见</strong><a target="_blank" rel="noopener" href="https://doc.qt.io/qt-6/qurl.html#setHost">setHost</a> ()、<a target="_blank" rel="noopener" href="https://doc.qt.io/qt-6/qurl.html#idnWhitelist">idnWhitelist</a> ()、<a target="_blank" rel="noopener" href="https://doc.qt.io/qt-6/qurl.html#setIdnWhitelist">setIdnWhitelist</a> () 和<a target="_blank" rel="noopener" href="https://doc.qt.io/qt-6/qurl.html#authority">authority</a> ()。</p>
<h3><span id="static-qstringlist-qurl-idnwhitelist"><code>[static]</code> QUrl::idnWhitelist()</span><a href="#static-qstringlist-qurl-idnwhitelist" class="header-anchor">#</a></h3><p>返回允许在其组成中包含非 ASCII 字符的顶级域的当前白名单。</p>
<p>有关此列表的基本原理，请参见<a target="_blank" rel="noopener" href="https://doc.qt.io/qt-6/qurl.html#setIdnWhitelist">setIdnWhitelist</a> ()。</p>
<p><strong>另请参见</strong><a target="_blank" rel="noopener" href="https://doc.qt.io/qt-6/qurl.html#setIdnWhitelist">setIdnWhitelist</a> ()。</p>
<h3><span id="bool-qurl-isempty-const">bool QUrl::isEmpty() const</span><a href="#bool-qurl-isempty-const" class="header-anchor">#</a></h3><p> <code>true</code>如果 URL 没有数据则返回；否则返回<code>false</code>。 </p>
<p><strong>See also</strong> <a href="#clear">clear</a>().</p>
<h3><span id="bool-qurl-islocalfile-const">bool QUrl::isLocalFile() const</span><a href="#bool-qurl-islocalfile-const" class="header-anchor">#</a></h3><p>如果此 URL 指向本地文件路径，则返回<code>true</code>。如果方案是“文件”，则 URL 是本地文件路径。</p>
<p>请注意，此函数将带有主机名的 URL 视为本地文件路径，即使最终的文件路径无法使用<a target="_blank" rel="noopener" href="https://doc.qt.io/qt-6/qfile.html#open">QFile::open</a> () 打开。</p>
<p><strong>另请参见</strong><a target="_blank" rel="noopener" href="https://doc.qt.io/qt-6/qurl.html#fromLocalFile">fromLocalFile</a> () 和<a target="_blank" rel="noopener" href="https://doc.qt.io/qt-6/qurl.html#toLocalFile">toLocalFile</a> ()。</p>
<h3><span id="bool-qurl-isparentof-const-qurl-amp-childurl-const">bool QUrl::isParentOf(const  &amp;<em>childUrl</em>) const</span><a href="#bool-qurl-isparentof-const-qurl-amp-childurl-const" class="header-anchor">#</a></h3><p>如果此 URL 是<em>childUrl</em>的父级，则返回 <code>true</code>。如果两个 URL 共享相同的方案和权限，则<em>childUrl</em>是此 URL 的子级，并且此 URL 的路径是<em>childUrl</em>路径的父级。 </p>
<h3><span id="bool-qurl-isrelative-const">bool QUrl::isRelative() const</span><a href="#bool-qurl-isrelative-const" class="header-anchor">#</a></h3><p>如果 URL 是相对的，则返回<code>true</code>；否则返回<code>false</code>。如果其方案未定义，则 URL 是相对引用；因此这个函数相当于调用<a target="_blank" rel="noopener" href="https://doc.qt.io/qt-6/qurl.html#scheme">scheme</a> ()。<a target="_blank" rel="noopener" href="https://doc.qt.io/qt-6/qurl.html#isEmpty">是空</a>的（）。</p>
<p>相对引用在 RFC 3986 第 4.2 节中定义。</p>
<p><strong>See also</strong> <a href="#relative-urls-vs-relative-paths">Relative URLs vs Relative Paths</a>.</p>
<h3><span id="bool-qurl-isvalid-const">bool QUrl::isValid() const</span><a href="#bool-qurl-isvalid-const" class="header-anchor">#</a></h3><p>如果 URL 非空且有效，则返回<code>true</code>；否则返回<code>false</code>。</p>
<p>URL 通过一致性测试运行。URL 的每个部分都必须符合 URI 标准的标准编码规则，才能将 URL 报告为有效。</p>
<div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">checkUrl</span><span class="hljs-params">(<span class="hljs-type">const</span> QUrl &amp;url)</span> </span>{
    <span class="hljs-keyword">if</span> (!url.<span class="hljs-built_in">isValid</span>()) {
        <span class="hljs-built_in">qDebug</span>(<span class="hljs-string">"Invalid URL: %s"</span>, <span class="hljs-built_in">qUtf8Printable</span>(url.<span class="hljs-built_in">toString</span>()));
        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
    }

    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
}</code></pre></div>

<h3><span id="since-5-2-bool-qurl-matches-const-qurl-amp-url-qurl-formattingoptions-options-const"><code>[since 5.2]</code>bool QUrl::matches(const  &amp;<em>url</em>,  <em>options</em>) const</span><a href="#since-5-2-bool-qurl-matches-const-qurl-amp-url-qurl-formattingoptions-options-const" class="header-anchor">#</a></h3><p>返回<code>true</code>如果此 URL 和给定<em>url</em>在应用<em>options</em>后相等；否则返回<code>false</code>。</p>
<p>这相当于在两个 URL 上调用adjusted(options) 并比较结果URL，但速度更快。</p>
<p>这个函数是在 Qt 5.2 中引入的。</p>
<h3><span id="qstring-qurl-password-qurl-componentformattingoptions-options-fullydecoded-const"> QUrl::password( <em>options</em> = FullyDecoded) const</span><a href="#qstring-qurl-password-qurl-componentformattingoptions-options-fullydecoded-const" class="header-anchor">#</a></h3><p>如果已定义，则返回 URL 的密码；否则返回一个空字符串。</p>
<p><em>options</em>参数控制如何格式化用户名组件。所有值都会产生明确的结果。使用<a target="_blank" rel="noopener" href="https://doc.qt.io/qt-6/qurl.html#ComponentFormattingOption-enum">QUrl::FullyDecoded</a>，所有百分比编码的序列都被解码；否则，返回的值可能包含某些控制序列的百分比编码序列，这些控制序列在<a target="_blank" rel="noopener" href="https://doc.qt.io/qt-6/qstring.html">QString</a>中无法以解码形式表示。</p>
<p>请注意，如果存在那些不可表示的序列，则<a target="_blank" rel="noopener" href="https://doc.qt.io/qt-6/qurl.html#ComponentFormattingOption-enum">QUrl::FullyDecoded可能会导致数据丢失。</a>当结果将在非 URL 上下文中使用时，建议使用该值，例如在<a target="_blank" rel="noopener" href="https://doc.qt.io/qt-6/qauthenticator.html">QAuthenticator</a>中设置或协商登录。</p>
<p><strong>另见</strong><a target="_blank" rel="noopener" href="https://doc.qt.io/qt-6/qurl.html#setPassword">setPassword</a> ()。</p>
<h3><span id="qstring-qurl-path-qurl-componentformattingoptions-options-fullydecoded-const"> QUrl::path( <em>options</em> = FullyDecoded) const</span><a href="#qstring-qurl-path-qurl-componentformattingoptions-options-fullydecoded-const" class="header-anchor">#</a></h3><p> 返回 URL 的路径。 </p>
<div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-built_in">qDebug</span>() &lt;&lt; <span class="hljs-built_in">QUrl</span>(<span class="hljs-string">"file:file.txt"</span>).<span class="hljs-built_in">path</span>();                   <span class="hljs-comment">// "file.txt"</span>
<span class="hljs-built_in">qDebug</span>() &lt;&lt; <span class="hljs-built_in">QUrl</span>(<span class="hljs-string">"/home/user/file.txt"</span>).<span class="hljs-built_in">path</span>();             <span class="hljs-comment">// "/home/user/file.txt"</span>
<span class="hljs-built_in">qDebug</span>() &lt;&lt; <span class="hljs-built_in">QUrl</span>(<span class="hljs-string">"http://www.example.com/test/123"</span>).<span class="hljs-built_in">path</span>(); <span class="hljs-comment">// "/test/123"</span></code></pre></div>

<p><em>options</em>参数控制如何格式化路径组件。所有值都会产生明确的结果。使用<a target="_blank" rel="noopener" href="https://doc.qt.io/qt-6/qurl.html#ComponentFormattingOption-enum">QUrl::FullyDecoded</a>，所有百分比编码的序列都被解码；否则，返回的值可能包含某些控制序列的百分比编码序列，这些控制序列在<a target="_blank" rel="noopener" href="https://doc.qt.io/qt-6/qstring.html">QString</a>中无法以解码形式表示。</p>
<p>请注意，如果存在那些不可表示的序列，则<a target="_blank" rel="noopener" href="https://doc.qt.io/qt-6/qurl.html#ComponentFormattingOption-enum">QUrl::FullyDecoded可能会导致数据丢失。</a>当结果将用于非 URL 上下文（例如发送到 FTP 服务器）时，建议使用该值。</p>
<p>数据丢失的一个例子是当您有非 Unicode 百分比编码的序列并使用<a target="_blank" rel="noopener" href="https://doc.qt.io/qt-6/qurl.html#ComponentFormattingOption-enum">FullyDecoded</a>（默认值）时：</p>
<div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-built_in">qDebug</span>() &lt;&lt; <span class="hljs-built_in">QUrl</span>(<span class="hljs-string">"/foo%FFbar"</span>).<span class="hljs-built_in">path</span>();</code></pre></div>

<p><code>%FF</code>在此示例中，由于无法转换，将会有一定程度的数据丢失。</p>
<p>当路径包含子分隔符（例如<code>+</code>）时，也可能发生数据丢失：</p>
<div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-built_in">qDebug</span>() &lt;&lt; <span class="hljs-built_in">QUrl</span>(<span class="hljs-string">"/foo+bar%2B"</span>).<span class="hljs-built_in">path</span>(); <span class="hljs-comment">// "/foo+bar+"</span></code></pre></div>

<p> 其他解码示例： </p>
<div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">const</span> QUrl <span class="hljs-title">url</span><span class="hljs-params">(<span class="hljs-string">"/tmp/Mambo %235%3F.mp3"</span>)</span></span>;
<span class="hljs-built_in">qDebug</span>() &lt;&lt; url.<span class="hljs-built_in">path</span>(QUrl::FullyDecoded);  <span class="hljs-comment">// "/tmp/Mambo #5?.mp3"</span>
<span class="hljs-built_in">qDebug</span>() &lt;&lt; url.<span class="hljs-built_in">path</span>(QUrl::PrettyDecoded); <span class="hljs-comment">// "/tmp/Mambo #5?.mp3"</span>
<span class="hljs-built_in">qDebug</span>() &lt;&lt; url.<span class="hljs-built_in">path</span>(QUrl::FullyEncoded);  <span class="hljs-comment">// "/tmp/Mambo%20%235%3F.mp3"</span></code></pre></div>

<p><strong>See also</strong> <a href="#setPath">setPath</a>().</p>
<h3><span id="int-qurl-port-int-defaultport-1-const">int QUrl::port(int <em>defaultPort</em> = -1) const</span><a href="#int-qurl-port-int-defaultport-1-const" class="header-anchor">#</a></h3><p>返回 URL 的端口，如果端口未指定，则返回<em>defaultPort 。</em></p>
<p>例子：</p>
<div class="code-wrapper"><pre><code class="hljs c++">QTcpSocket sock;
sock.<span class="hljs-built_in">connectToHost</span>(url.<span class="hljs-built_in">host</span>(), url.<span class="hljs-built_in">port</span>(<span class="hljs-number">80</span>));</code></pre></div>

<p><strong>See also</strong> <a href="#setPort">setPort</a>().</p>
<h3><span id="qstring-qurl-query-qurl-componentformattingoptions-options-prettydecoded-const"> QUrl::query( <em>options</em> = PrettyDecoded) const</span><a href="#qstring-qurl-query-qurl-componentformattingoptions-options-prettydecoded-const" class="header-anchor">#</a></h3><p>如果有查询字符串，则返回 URL 的查询字符串，否则返回空结果。要确定解析的 URL 是否包含查询字符串，请使用<a target="_blank" rel="noopener" href="https://doc.qt.io/qt-6/qurl.html#hasQuery">hasQuery</a> ()。</p>
<p><em>options</em>参数控制如何格式化查询组件。所有值都会产生明确的结果。使用<a target="_blank" rel="noopener" href="https://doc.qt.io/qt-6/qurl.html#ComponentFormattingOption-enum">QUrl::FullyDecoded</a>，所有百分比编码的序列都被解码；否则，返回的值可能包含某些控制序列的百分比编码序列，这些控制序列在<a target="_blank" rel="noopener" href="https://doc.qt.io/qt-6/qstring.html">QString</a>中无法以解码形式表示。</p>
<p>请注意，不鼓励在查询中使用<a target="_blank" rel="noopener" href="https://doc.qt.io/qt-6/qurl.html#ComponentFormattingOption-enum">QUrl::FullyDecoded</a>，因为查询通常包含应该保持百分比编码的数据，包括使用 “%2B” 序列来表示加号 (‘+’)。</p>
<p><strong>另请参见</strong><a target="_blank" rel="noopener" href="https://doc.qt.io/qt-6/qurl.html#setQuery">setQuery</a> () 和<a target="_blank" rel="noopener" href="https://doc.qt.io/qt-6/qurl.html#hasQuery">hasQuery</a> ()。</p>
<h3><span id="qurl-qurl-resolved-const-qurl-amp-relative-const"> QUrl::resolved(const  &amp;<em>relative</em>) const</span><a href="#qurl-qurl-resolved-const-qurl-amp-relative-const" class="header-anchor">#</a></h3><p>返回此 URL 与<em>relative</em>合并的结果。此 URL 用作将<em>相对</em>URL 转换为绝对 URL 的基础。</p>
<p>如果<em>relative</em>不是相对 URL，则此函数将直接返回<em>relative</em>。否则，合并两个 URL 的路径，返回的新 URL 具有基本 URL 的方案和权限，但具有合并的路径，如下例所示：</p>
<div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-function">QUrl <span class="hljs-title">baseUrl</span><span class="hljs-params">(<span class="hljs-string">"http://qt.digia.com/Support/"</span>)</span></span>;
<span class="hljs-function">QUrl <span class="hljs-title">relativeUrl</span><span class="hljs-params">(<span class="hljs-string">"../Product/Library/"</span>)</span></span>;
<span class="hljs-built_in">qDebug</span>(baseUrl.<span class="hljs-built_in">resolved</span>(relativeUrl).<span class="hljs-built_in">toString</span>());
<span class="hljs-comment">// prints "http://qt.digia.com/Product/Library/"</span></code></pre></div>

<p>使用“..”调用 resolved() 会返回一个<a target="_blank" rel="noopener" href="https://doc.qt.io/qt-6/qurl.html">QUrl</a>，其目录比原始目录高一级。同样，使用“../..”调用 resolved() 会从路径中删除两个级别。如果<em>relative</em>为“/”，则路径变为“/”。</p>
<p><strong>另请参见</strong><a target="_blank" rel="noopener" href="https://doc.qt.io/qt-6/qurl.html#isRelative">isRelative</a> ()。</p>
<h3><span id="qstring-qurl-scheme-const"> QUrl::scheme() const</span><a href="#qstring-qurl-scheme-const" class="header-anchor">#</a></h3><p>返回 URL 的方案。如果返回一个空字符串，这意味着方案未定义并且 URL 是相对的。</p>
<p>该方案只能包含 US-ASCII 字母或数字，这意味着它不能包含任何需要编码的字符。此外，方案总是以小写形式返回。</p>
<p><strong>另请参见</strong><a target="_blank" rel="noopener" href="https://doc.qt.io/qt-6/qurl.html#setScheme">setScheme</a> () 和<a target="_blank" rel="noopener" href="https://doc.qt.io/qt-6/qurl.html#isRelative">isRelative</a> ()。</p>
<h3><span id="void-qurl-setauthority-const-qstring-amp-authority-qurl-parsingmode-mode-tolerantmode">void QUrl::setAuthority(const  &amp;<em>authority</em>,  <em>mode</em> = TolerantMode)</span><a href="#void-qurl-setauthority-const-qstring-amp-authority-qurl-parsingmode-mode-tolerantmode" class="header-anchor">#</a></h3><p>将 URL 的权限设置为<em>authority</em>。</p>
<p>URL 的权限是用户信息、主机名和端口的组合。所有这些元素都是可选的；因此，空的权限是有效的。</p>
<p>用户信息和主机用“@”分隔，主机和端口用“:”分隔。如果用户信息为空，“@”必须省略；尽管如果端口为空，则允许使用杂散的“：”。</p>
<p>以下示例显示了一个有效的权限字符串：</p>
<p><img src="https://doc.qt.io/qt-6/images/qurl-authority.png" srcset="/img/loading.gif" lazyload alt="img"></p>
<p><em>权限</em>数据根据模式进行解释：<em>在</em>StrictMode 中<a target="_blank" rel="noopener" href="https://doc.qt.io/qt-6/qurl.html#ParsingMode-enum">，</a>任何 ‘%’ 字符必须紧跟两个十六进制字符，并且某些字符（包括空格）不允许以未解码的形式出现。在<a target="_blank" rel="noopener" href="https://doc.qt.io/qt-6/qurl.html#ParsingMode-enum">TolerantMode</a>（默认）中，所有字符都以未解码的形式接受，并且容错解析器将纠正杂散的 ‘%’ 后面没有两个十六进制字符。</p>
<p>此函数不允许<em>模式</em>为<a target="_blank" rel="noopener" href="https://doc.qt.io/qt-6/qurl.html#ParsingMode-enum">QUrl::DecodedMode</a>。要设置完全解码的数据，请分别调用<a target="_blank" rel="noopener" href="https://doc.qt.io/qt-6/qurl.html#setUserName">setUserName</a> ()、<a target="_blank" rel="noopener" href="https://doc.qt.io/qt-6/qurl.html#setPassword">setPassword</a> ()、<a target="_blank" rel="noopener" href="https://doc.qt.io/qt-6/qurl.html#setHost">setHost</a> () 和<a target="_blank" rel="noopener" href="https://doc.qt.io/qt-6/qurl.html#setPort">setPort</a> ()。</p>
<p><strong>另请参见</strong><a target="_blank" rel="noopener" href="https://doc.qt.io/qt-6/qurl.html#authority">authority</a> ()、<a target="_blank" rel="noopener" href="https://doc.qt.io/qt-6/qurl.html#setUserInfo">setUserInfo</a> ()、<a target="_blank" rel="noopener" href="https://doc.qt.io/qt-6/qurl.html#setHost">setHost</a> () 和<a target="_blank" rel="noopener" href="https://doc.qt.io/qt-6/qurl.html#setPort">setPort</a> ()。</p>
<h3><span id="void-qurl-setfragment-const-qstring-amp-fragment-qurl-parsingmode-mode-tolerantmode">void QUrl::setFragment(const  &amp;<em>fragment</em>,  <em>mode</em> = TolerantMode)</span><a href="#void-qurl-setfragment-const-qstring-amp-fragment-qurl-parsingmode-mode-tolerantmode" class="header-anchor">#</a></h3><p>将 URL 的片段设置为<em>fragment</em>。片段是 URL 的最后一部分，由“#”表示，后跟一串字符。它通常在 HTTP 中用于引用页面上的某个链接或点：</p>
<p><img src="https://doc.qt.io/qt-6/images/qurl-fragment.png" srcset="/img/loading.gif" lazyload alt="img"></p>
<p>片段有时也称为 URL“参考”。</p>
<p>传递 QString() 的参数（空<a target="_blank" rel="noopener" href="https://doc.qt.io/qt-6/qstring.html">QString</a>）将取消设置片段。传递<a target="_blank" rel="noopener" href="https://doc.qt.io/qt-6/qstring.html">QString</a> (“”) 的参数（一个空但不为空的<a target="_blank" rel="noopener" href="https://doc.qt.io/qt-6/qstring.html">QString</a>）会将片段设置为空字符串（就好像原始 URL 有一个单独的“#”）。</p>
<p><em>片段</em>数据根据 mode 进行解释：<em>在</em>StrictMode 中<a target="_blank" rel="noopener" href="https://doc.qt.io/qt-6/qurl.html#ParsingMode-enum">，</a>任何 ‘%’ 字符必须紧跟两个十六进制字符，并且某些字符（包括空格）不允许以未解码的形式出现。在<a target="_blank" rel="noopener" href="https://doc.qt.io/qt-6/qurl.html#ParsingMode-enum">TolerantMode</a>中，所有字符都以未解码的形式接受，并且容错解析器将纠正杂散的 ‘%’ 后面没有两个十六进制字符。在<a target="_blank" rel="noopener" href="https://doc.qt.io/qt-6/qurl.html#ParsingMode-enum">DecodedMode</a>中，’%’ 代表它们自己，编码字符是不可能的。</p>
<p>当从不是 URL 的数据源或通过使用 QUrl::FullyDecoded 格式化选项调用 fragment () 获得的片段设置片段时，应<a target="_blank" rel="noopener" href="https://doc.qt.io/qt-6/qurl.html#ParsingMode-enum">使用</a><a target="_blank" rel="noopener" href="https://doc.qt.io/qt-6/qurl.html#ComponentFormattingOption-enum">QUrl</a> :: <a target="_blank" rel="noopener" href="https://doc.qt.io/qt-6/qurl.html#fragment">DecodedMode</a>。</p>
<p><strong>另请参见</strong><a target="_blank" rel="noopener" href="https://doc.qt.io/qt-6/qurl.html#fragment">片段</a>() 和<a target="_blank" rel="noopener" href="https://doc.qt.io/qt-6/qurl.html#hasFragment">hasFragment</a> ()。</p>
<h3><span id="void-qurl-sethost-const-qstring-amp-host-qurl-parsingmode-mode-decodedmode">void QUrl::setHost(const  &amp;<em>host</em>,  <em>mode</em> = DecodedMode)</span><a href="#void-qurl-sethost-const-qstring-amp-host-qurl-parsingmode-mode-decodedmode" class="header-anchor">#</a></h3><p>将 URL 的主机设置为<em>host</em>。主人是权威的一部分。</p>
<p><em>主机</em>数据根据 mode 进行解释：<em>在</em>StrictMode 中<a target="_blank" rel="noopener" href="https://doc.qt.io/qt-6/qurl.html#ParsingMode-enum">，</a>任何 ‘%’ 字符必须紧跟两个十六进制字符，并且某些字符（包括空格）不允许以未解码的形式出现。在<a target="_blank" rel="noopener" href="https://doc.qt.io/qt-6/qurl.html#ParsingMode-enum">TolerantMode</a>中，所有字符都以未解码的形式接受，并且容错解析器将纠正杂散的 ‘%’ 后面没有两个十六进制字符。在<a target="_blank" rel="noopener" href="https://doc.qt.io/qt-6/qurl.html#ParsingMode-enum">DecodedMode</a>中，’%’ 代表它们自己，编码字符是不可能的。</p>
<p>请注意，在所有情况下，解析结果都必须是根据国际化资源标识符规范 (RFC 3987) 修改的 STD 3 规则的有效主机名。不允许使用无效的主机名，这将导致<a target="_blank" rel="noopener" href="https://doc.qt.io/qt-6/qurl.html#isValid">isValid</a> () 变为 false。</p>
<p><strong>另请参见</strong><a target="_blank" rel="noopener" href="https://doc.qt.io/qt-6/qurl.html#host">host</a> () 和<a target="_blank" rel="noopener" href="https://doc.qt.io/qt-6/qurl.html#setAuthority">setAuthority</a> ()。</p>
<h3><span id="static-void-qurl-setidnwhitelist-const-qstringlist-amp-list"><code>[static]</code>void QUrl::setIdnWhitelist(const  &amp;<em>list</em>)</span><a href="#static-void-qurl-setidnwhitelist-const-qstringlist-amp-list" class="header-anchor">#</a></h3><p>将允许在域中包含非 ASCII 字符的顶级域 (TLD) 的白名单设置为<em>list</em>的值。</p>
<p>请注意，如果您调用此函数，则需要<em>在</em>启动任何可能访问<a target="_blank" rel="noopener" href="https://doc.qt.io/qt-6/qurl.html#idnWhitelist">idnWhitelist</a> () 的线程之前执行此操作。</p>
<p>Qt 附带一个默认列表，其中包含已发布对国际化域名 (IDN) 的支持的 Internet 顶级域和规则，以保证在外观相似的字符之间不会发生欺骗（例如拉丁小写字母<code>'a'</code>和西里尔字母） ，在大多数字体中在视觉上是相同的）。</p>
<p>随着注册商发布新规则，此列表会定期维护。</p>
<p>此功能是为那些需要操作列表以添加或删除 TLD 的人提供的。不建议出于测试以外的目的更改其值，因为这可能会使用户面临安全风险。</p>
<p><strong>另见</strong><a target="_blank" rel="noopener" href="https://doc.qt.io/qt-6/qurl.html#idnWhitelist">idnWhitelist</a> ()。</p>
<h3><span id="void-qurl-setpassword-const-qstring-amp-password-qurl-parsingmode-mode-decodedmode">void QUrl::setPassword(const  &amp;<em>password</em>,  <em>mode</em> = DecodedMode)</span><a href="#void-qurl-setpassword-const-qstring-amp-password-qurl-parsingmode-mode-decodedmode" class="header-anchor">#</a></h3><p>将 URL 的密码设置为<em>password</em>。<em>密码</em>是 URL 权限中用户信息元素的一部分，如<a target="_blank" rel="noopener" href="https://doc.qt.io/qt-6/qurl.html#setUserInfo">setUserInfo</a> () 中所述。</p>
<p><em>密码</em>数据根据 mode 进行解释：<em>在</em>StrictMode 中<a target="_blank" rel="noopener" href="https://doc.qt.io/qt-6/qurl.html#ParsingMode-enum">，</a>任何 ‘%’ 字符必须紧跟两个十六进制字符，并且某些字符（包括空格）不允许以未解码的形式出现。在<a target="_blank" rel="noopener" href="https://doc.qt.io/qt-6/qurl.html#ParsingMode-enum">TolerantMode</a>中，所有字符都以未解码的形式接受，并且容错解析器将纠正杂散的 ‘%’ 后面没有两个十六进制字符。在<a target="_blank" rel="noopener" href="https://doc.qt.io/qt-6/qurl.html#ParsingMode-enum">DecodedMode</a>中，’%’ 代表它们自己，编码字符是不可能的。</p>
<p>当从不是 URL 的数据源设置密码时，应使用<a target="_blank" rel="noopener" href="https://doc.qt.io/qt-6/qurl.html#ParsingMode-enum">QUrl::DecodedMode ，例如向用户显示的密码对话框或通过使用</a><a target="_blank" rel="noopener" href="https://doc.qt.io/qt-6/qurl.html#ComponentFormattingOption-enum">QUrl::FullyDecoded</a>格式选项调用<a target="_blank" rel="noopener" href="https://doc.qt.io/qt-6/qurl.html#password">密码</a>()获得的密码。</p>
<p><strong>另请参见</strong><a target="_blank" rel="noopener" href="https://doc.qt.io/qt-6/qurl.html#password">密码</a>() 和<a target="_blank" rel="noopener" href="https://doc.qt.io/qt-6/qurl.html#setUserInfo">setUserInfo</a> ()。</p>
<h3><span id="void-qurl-setpath-const-qstring-amp-path-qurl-parsingmode-mode-decodedmode">void QUrl::setPath(const  &amp;<em>path</em>,  <em>mode</em> = DecodedMode)</span><a href="#void-qurl-setpath-const-qstring-amp-path-qurl-parsingmode-mode-decodedmode" class="header-anchor">#</a></h3><p>将 URL 的路径设置为<em>path</em>。路径是 URL 中位于权限之后但在查询字符串之前的部分。</p>
<p><img src="https://doc.qt.io/qt-6/images/qurl-ftppath.png" srcset="/img/loading.gif" lazyload alt="img"></p>
<p>对于非分层方案，路径将是方案声明之后的所有内容，如下例所示：</p>
<p><img src="https://doc.qt.io/qt-6/images/qurl-mailtopath.png" srcset="/img/loading.gif" lazyload alt="img"></p>
<p><em>路径</em>数据根据 mode 进行解释：<em>在</em>StrictMode 中<a target="_blank" rel="noopener" href="https://doc.qt.io/qt-6/qurl.html#ParsingMode-enum">，</a>任何 ‘%’ 字符必须紧跟两个十六进制字符，并且某些字符（包括空格）不允许以未解码的形式出现。在<a target="_blank" rel="noopener" href="https://doc.qt.io/qt-6/qurl.html#ParsingMode-enum">TolerantMode</a>中，所有字符都以未解码的形式接受，并且容错解析器将纠正杂散的 ‘%’ 后面没有两个十六进制字符。在<a target="_blank" rel="noopener" href="https://doc.qt.io/qt-6/qurl.html#ParsingMode-enum">DecodedMode</a>中，’%’ 代表它们自己，编码字符是不可能的。</p>
<p>当从不是 URL 的数据源设置路径时，应使用<a target="_blank" rel="noopener" href="https://doc.qt.io/qt-6/qurl.html#ParsingMode-enum">QUrl::DecodedMode ，例如向用户显示的对话框或通过使用</a><a target="_blank" rel="noopener" href="https://doc.qt.io/qt-6/qurl.html#ComponentFormattingOption-enum">QUrl::FullyDecoded</a>格式化选项调用<a target="_blank" rel="noopener" href="https://doc.qt.io/qt-6/qurl.html#path">path</a> ()获得的路径。</p>
<p><strong>See also</strong> <a href="#path">path</a>().</p>
<h3><span id="void-qurl-setport-int-port">void QUrl::setPort(int <em>port</em>)</span><a href="#void-qurl-setport-int-port" class="header-anchor">#</a></h3><p>将 URL 的端口设置为<em>port</em>。端口是 URL 权限的一部分，如<a target="_blank" rel="noopener" href="https://doc.qt.io/qt-6/qurl.html#setAuthority">setAuthority</a> () 中所述。</p>
<p><em>port</em>必须介于 0 和 65535（含）之间。将端口设置为 -1 表示未指定端口。</p>
<p><strong>See also</strong> <a href="#port">port</a>().</p>
<h3><span id="void-qurl-setquery-const-qstring-amp-query-qurl-parsingmode-mode-tolerantmode">void QUrl::setQuery(const  &amp;<em>query</em>,  <em>mode</em> = TolerantMode)</span><a href="#void-qurl-setquery-const-qstring-amp-query-qurl-parsingmode-mode-tolerantmode" class="header-anchor">#</a></h3><p>将 URL 的查询字符串设置为<em>query</em>。</p>
<p>如果您需要传递不适合键值模式的查询字符串，或者使用与<a target="_blank" rel="noopener" href="https://doc.qt.io/qt-6/qurl.html">QUrl</a>建议的不同的特殊字符编码方案，则此函数很有用。</p>
<p>将 QString() 的值传递给<em>查询</em>（空<a target="_blank" rel="noopener" href="https://doc.qt.io/qt-6/qstring.html">QString</a>）会完全取消设置查询。但是，传递<a target="_blank" rel="noopener" href="https://doc.qt.io/qt-6/qstring.html">QString</a> (“”) 的值会将查询设置为空值，就好像原始 URL 有一个单独的 “?”。</p>
<p><em>查询</em>数据根据 mode 进行解释：<em>在</em>StrictMode 中<a target="_blank" rel="noopener" href="https://doc.qt.io/qt-6/qurl.html#ParsingMode-enum">，</a>任何 ‘%’ 字符必须紧跟两个十六进制字符，并且某些字符（包括空格）不允许以未解码的形式出现。在<a target="_blank" rel="noopener" href="https://doc.qt.io/qt-6/qurl.html#ParsingMode-enum">TolerantMode</a>中，所有字符都以未解码的形式接受，并且容错解析器将纠正杂散的 ‘%’ 后面没有两个十六进制字符。在<a target="_blank" rel="noopener" href="https://doc.qt.io/qt-6/qurl.html#ParsingMode-enum">DecodedMode</a>中，’%’ 代表它们自己，编码字符是不可能的。</p>
<p>查询字符串通常包含百分比编码的序列，因此不鼓励使用<a target="_blank" rel="noopener" href="https://doc.qt.io/qt-6/qurl.html#ParsingMode-enum">DecodedMode</a>。要注意的一个特殊序列是加号 (‘+’) 的序列。<a target="_blank" rel="noopener" href="https://doc.qt.io/qt-6/qurl.html">QUrl</a>不会将空格转换为加号字符，即使 Web 浏览器发布的 HTML 表单可以。为了在查询中表示实际的加号，通常使用序列“%2B”。此函数将在<a target="_blank" rel="noopener" href="https://doc.qt.io/qt-6/qurl.html#ParsingMode-enum">TolerantMode</a>或<a target="_blank" rel="noopener" href="https://doc.qt.io/qt-6/qurl.html#ParsingMode-enum">StrictMode</a>中保持“%2B”序列不变。</p>
<p><strong>另请参见</strong><a target="_blank" rel="noopener" href="https://doc.qt.io/qt-6/qurl.html#query">query</a> () 和<a target="_blank" rel="noopener" href="https://doc.qt.io/qt-6/qurl.html#hasQuery">hasQuery</a> ()。</p>
<h3><span id="since-5-0-void-qurl-setquery-const-qurlquery-amp-query"><code>[since 5.0]</code>void QUrl::setQuery(const  &amp;<em>query</em>)</span><a href="#since-5-0-void-qurl-setquery-const-qurlquery-amp-query" class="header-anchor">#</a></h3><p>这是一个重载功能。</p>
<p>将 URL 的查询字符串设置为<em>query</em>。</p>
<p><a target="_blank" rel="noopener" href="https://doc.qt.io/qt-6/qurlquery.html">此函数从QUrlQuery</a>对象重构查询字符串并设置在此<a target="_blank" rel="noopener" href="https://doc.qt.io/qt-6/qurl.html">QUrl</a>对象上。此函数没有解析参数，因为<a target="_blank" rel="noopener" href="https://doc.qt.io/qt-6/qurlquery.html">QUrlQuery</a>包含已解析的数据。</p>
<p>此功能是在 Qt 5.0 中引入的。</p>
<p><strong>另请参见</strong><a target="_blank" rel="noopener" href="https://doc.qt.io/qt-6/qurl.html#query">query</a> () 和<a target="_blank" rel="noopener" href="https://doc.qt.io/qt-6/qurl.html#hasQuery">hasQuery</a> ()。</p>
<h3><span id="void-qurl-setscheme-const-qstring-amp-scheme">void QUrl::setScheme(const  &amp;<em>scheme</em>)</span><a href="#void-qurl-setscheme-const-qstring-amp-scheme" class="header-anchor">#</a></h3><p>将 URL 的方案设置为<em>scheme</em>。由于方案只能包含 ASCII 字符，因此不会对输入进行转换或解码。它还必须以 ASCII 字母开头。</p>
<p>该方案描述了 URL 的类型（或协议）。它由 URL 开头的一个或多个 ASCII 字符表示。</p>
<p>方案严格<a target="_blank" rel="noopener" href="https://datatracker.ietf.org/doc/html/rfc3986">符合 RFC 3986</a>：<code>scheme = ALPHA *( ALPHA / DIGIT / "+" / "-" / "." )</code></p>
<p>以下示例显示了方案为“ftp”的 URL：</p>
<p><img src="https://doc.qt.io/qt-6/images/qurl-authority2.png" srcset="/img/loading.gif" lazyload alt="img"></p>
<p>要设置方案，使用以下调用：</p>
<div class="code-wrapper"><pre><code class="hljs c++">QUrl url;
url.<span class="hljs-built_in">setScheme</span>(<span class="hljs-string">"ftp"</span>);</code></pre></div>

<p>该方案也可以为空，在这种情况下 URL 被解释为相对的。</p>
<p><strong>另见</strong><a target="_blank" rel="noopener" href="https://doc.qt.io/qt-6/qurl.html#scheme">scheme</a> () 和<a target="_blank" rel="noopener" href="https://doc.qt.io/qt-6/qurl.html#isRelative">isRelative</a> ()。</p>
<h3><span id="void-qurl-seturl-const-qstring-amp-url-qurl-parsingmode-parsingmode-tolerantmode">void QUrl::setUrl(const  &amp;<em>url</em>,  <em>parsingMode</em> = TolerantMode)</span><a href="#void-qurl-seturl-const-qstring-amp-url-qurl-parsingmode-parsingmode-tolerantmode" class="header-anchor">#</a></h3><p>解析<em>url</em>并将此对象设置为该值。<a target="_blank" rel="noopener" href="https://doc.qt.io/qt-6/qurl.html">QUrl</a>将自动对 URL 中不允许的所有字符进行百分比编码，并对表示未保留字符（字母、数字、连字符、下划线、点和波浪号）的百分比编码序列进行解码。所有其他字符都保留其原始形式。</p>
<p>使用解析器模式<em>parsingMode</em>解析<em>url</em>。在<a target="_blank" rel="noopener" href="https://doc.qt.io/qt-6/qurl.html#ParsingMode-enum">TolerantMode</a>（默认值）中，<a target="_blank" rel="noopener" href="https://doc.qt.io/qt-6/qurl.html">QUrl</a>将纠正某些错误，特别是没有后跟两个十六进制数字的百分比字符 (‘%’) 的存在，并且它将接受任何位置的任何字符。在<a target="_blank" rel="noopener" href="https://doc.qt.io/qt-6/qurl.html#ParsingMode-enum">StrictMode</a>中，不允许出现编码错误，<a target="_blank" rel="noopener" href="https://doc.qt.io/qt-6/qurl.html">QUrl</a>还将检查某些禁止字符是否以未编码的形式出现。<a target="_blank" rel="noopener" href="https://doc.qt.io/qt-6/qurl.html#ParsingMode-enum">如果在StrictMode</a>中检测到错误，<a target="_blank" rel="noopener" href="https://doc.qt.io/qt-6/qurl.html#isValid">isValid</a> () 将返回 false。在此上下文中不允许使用解析模式<a target="_blank" rel="noopener" href="https://doc.qt.io/qt-6/qurl.html#ParsingMode-enum">DecodedMode ，它将产生运行时警告。</a></p>
<p><strong>另见</strong><a target="_blank" rel="noopener" href="https://doc.qt.io/qt-6/qurl.html#url">url</a> () 和<a target="_blank" rel="noopener" href="https://doc.qt.io/qt-6/qurl.html#toString">toString</a> ()。</p>
<h3><span id="void-qurl-setuserinfo-const-qstring-amp-userinfo-qurl-parsingmode-mode-tolerantmode">void QUrl::setUserInfo(const  &amp;<em>userInfo</em>,  <em>mode</em> = TolerantMode)</span><a href="#void-qurl-setuserinfo-const-qstring-amp-userinfo-qurl-parsingmode-mode-tolerantmode" class="header-anchor">#</a></h3><p>将 URL 的用户信息设置为<em>userInfo</em>。用户信息是 URL 权限的可选部分，如<a target="_blank" rel="noopener" href="https://doc.qt.io/qt-6/qurl.html#setAuthority">setAuthority</a> () 中所述。</p>
<p>用户信息由用户名和可选的密码组成，以“:”分隔。如果密码为空，则必须省略冒号。以下示例显示了一个有效的用户信息字符串：</p>
<p><img src="https://doc.qt.io/qt-6/images/qurl-authority3.png" srcset="/img/loading.gif" lazyload alt="img"></p>
<p><em>userInfo</em>数据根据 mode 进行解释：<em>在</em>StrictMode 中<a target="_blank" rel="noopener" href="https://doc.qt.io/qt-6/qurl.html#ParsingMode-enum">，</a>任何 ‘%’ 字符必须紧跟两个十六进制字符，并且某些字符（包括空格）不允许以未解码的形式出现。在<a target="_blank" rel="noopener" href="https://doc.qt.io/qt-6/qurl.html#ParsingMode-enum">TolerantMode</a>（默认）中，所有字符都以未解码的形式接受，并且容错解析器将纠正杂散的 ‘%’ 后面没有两个十六进制字符。</p>
<p>此函数不允许<em>模式</em>为<a target="_blank" rel="noopener" href="https://doc.qt.io/qt-6/qurl.html#ParsingMode-enum">QUrl::DecodedMode</a>。要设置完全解码的数据，请分别调用<a target="_blank" rel="noopener" href="https://doc.qt.io/qt-6/qurl.html#setUserName">setUserName</a> () 和<a target="_blank" rel="noopener" href="https://doc.qt.io/qt-6/qurl.html#setPassword">setPassword</a> ()。</p>
<p><strong>另请参见</strong><a target="_blank" rel="noopener" href="https://doc.qt.io/qt-6/qurl.html#userInfo">userInfo</a> ()、<a target="_blank" rel="noopener" href="https://doc.qt.io/qt-6/qurl.html#setUserName">setUserName</a> ()、<a target="_blank" rel="noopener" href="https://doc.qt.io/qt-6/qurl.html#setPassword">setPassword</a> () 和<a target="_blank" rel="noopener" href="https://doc.qt.io/qt-6/qurl.html#setAuthority">setAuthority</a> ()。</p>
<h3><span id="void-qurl-setusername-const-qstring-amp-username-qurl-parsingmode-mode-decodedmode">void QUrl::setUserName(const  &amp;<em>userName</em>,  <em>mode</em> = DecodedMode)</span><a href="#void-qurl-setusername-const-qstring-amp-username-qurl-parsingmode-mode-decodedmode" class="header-anchor">#</a></h3><p>将 URL 的用户名设置为<em>userName</em>。<em>userName</em>是 URL 权限中用户信息元素的一部分，如<a target="_blank" rel="noopener" href="https://doc.qt.io/qt-6/qurl.html#setUserInfo">setUserInfo</a> () 中所述。</p>
<p><em>userName</em>数据根据 mode 进行解释：<em>在</em>StrictMode 中<a target="_blank" rel="noopener" href="https://doc.qt.io/qt-6/qurl.html#ParsingMode-enum">，</a>任何 ‘%’ 字符必须紧跟两个十六进制字符，并且某些字符（包括空格）不允许以未解码的形式出现。在<a target="_blank" rel="noopener" href="https://doc.qt.io/qt-6/qurl.html#ParsingMode-enum">TolerantMode</a>（默认）中，所有字符都以未解码的形式接受，并且容错解析器将纠正杂散的 ‘%’ 后面没有两个十六进制字符。在<a target="_blank" rel="noopener" href="https://doc.qt.io/qt-6/qurl.html#ParsingMode-enum">DecodedMode</a>中，’%’ 代表它们自己，编码字符是不可能的。</p>
<p>当从不是 URL 的数据源设置用户名时，应使用<a target="_blank" rel="noopener" href="https://doc.qt.io/qt-6/qurl.html#ParsingMode-enum">QUrl::DecodedMode ，例如向用户显示的密码对话框或通过使用</a><a target="_blank" rel="noopener" href="https://doc.qt.io/qt-6/qurl.html#ComponentFormattingOption-enum">QUrl::FullyDecoded</a>格式化选项调用<a target="_blank" rel="noopener" href="https://doc.qt.io/qt-6/qurl.html#userName">userName</a> ()获得的用户名.</p>
<p><strong>另请参见</strong><a target="_blank" rel="noopener" href="https://doc.qt.io/qt-6/qurl.html#userName">userName</a> () 和<a target="_blank" rel="noopener" href="https://doc.qt.io/qt-6/qurl.html#setUserInfo">setUserInfo</a> ()。</p>
<h3><span id="void-qurl-swap-qurl-amp-other">void QUrl::swap( &amp;<em>other</em>)</span><a href="#void-qurl-swap-qurl-amp-other" class="header-anchor">#</a></h3><p> 用此 URL交换 URL <em>other 。</em>此操作非常快且永不失败。 </p>
<h3><span id="static-qbytearray-qurl-toace-const-qstring-amp-domain"><code>[static]</code> QUrl::toAce(const  &amp;<em>domain</em>)</span><a href="#static-qbytearray-qurl-toace-const-qstring-amp-domain" class="header-anchor">#</a></h3><p>返回给定域名<em>domain</em>的 ASCII 兼容编码。此函数的结果被认为等同于<em>domain</em>。</p>
<p>ASCII 兼容编码 (ACE) 由 RFC 3490、RFC 3491 和 RFC 3492 定义。它是应用程序中国际化域名 (IDNA) 规范的一部分，允许<code>"example.com"</code>使用国际字符编写域名（如 ）。</p>
<p>如果<em>domain</em>不是有效的主机名，此函数将返回一个空的<a target="_blank" rel="noopener" href="https://doc.qt.io/qt-6/qbytearray.html">QByteArray 。</a>请特别注意，IPv6 文字不是有效的域名。</p>
<h3><span id="since-5-2-cfurlref-qurl-tocfurl-const"><code>[since 5.2]</code>CFURLRef QUrl::toCFURL() const</span><a href="#since-5-2-cfurlref-qurl-tocfurl-const" class="header-anchor">#</a></h3><p><a target="_blank" rel="noopener" href="https://doc.qt.io/qt-6/qurl.html">从QUrl</a>创建一个 CFURL 。</p>
<p>调用者拥有 CFURL 并负责释放它。</p>
<p>这个函数是在 Qt 5.2 中引入的。</p>
<h3><span id="since-5-0-qstring-qurl-todisplaystring-qurl-formattingoptions-options-formattingoptions-prettydecoded-const"><code>[since 5.0]</code> QUrl::toDisplayString( <em>options</em> = FormattingOptions(PrettyDecoded)) const</span><a href="#since-5-0-qstring-qurl-todisplaystring-qurl-formattingoptions-options-formattingoptions-prettydecoded-const" class="header-anchor">#</a></h3><p>返回 URL 的人类可显示的字符串表示形式。可以通过传递带有<em>options</em>的标志来自定义输出。<a target="_blank" rel="noopener" href="https://doc.qt.io/qt-6/qurl.html#UrlFormattingOption-enum">始终启用RemovePassword</a>选项，因为永远不应向用户显示密码。</p>
<p>使用默认选项，生成的<a target="_blank" rel="noopener" href="https://doc.qt.io/qt-6/qstring.html">QString</a>可以稍后传递回<a target="_blank" rel="noopener" href="https://doc.qt.io/qt-6/qurl.html">QUrl</a>，但最初存在的任何密码都将丢失。</p>
<p>此功能是在 Qt 5.0 中引入的。</p>
<p><strong>另请参见</strong><a target="_blank" rel="noopener" href="https://doc.qt.io/qt-6/qurl.html#UrlFormattingOption-enum">FormattingOptions</a>、<a target="_blank" rel="noopener" href="https://doc.qt.io/qt-6/qurl.html#toEncoded">toEncoded</a> () 和<a target="_blank" rel="noopener" href="https://doc.qt.io/qt-6/qurl.html#toString">toString</a> ()。</p>
<h3><span id="qbytearray-qurl-toencoded-qurl-formattingoptions-options-fullyencoded-const"> QUrl::toEncoded( <em>options</em> = FullyEncoded) const</span><a href="#qbytearray-qurl-toencoded-qurl-formattingoptions-options-fullyencoded-const" class="header-anchor">#</a></h3><p>如果有效，则返回 URL 的编码表示；否则返回一个空的<a target="_blank" rel="noopener" href="https://doc.qt.io/qt-6/qbytearray.html">QByteArray</a>。可以通过传递带有<em>options</em>的标志来自定义输出。</p>
<p>用户信息、路径和片段都转换为 UTF-8，然后对所有非 ASCII 字符进行百分比编码。主机名使用 Punycode 进行编码。</p>
<h3><span id="qstring-qurl-tolocalfile-const"> QUrl::toLocalFile() const</span><a href="#qstring-qurl-tolocalfile-const" class="header-anchor">#</a></h3><p>返回格式化为本地文件路径的此 URL 的路径。返回的路径将使用正斜杠，即使它最初是从带有反斜杠的路径创建的。</p>
<p>如果此 URL 包含非空主机名，它将以在 SMB 网络上找到的形式（例如，“//servername/path/to/file.txt”）在返回值中进行编码。</p>
<div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-built_in">qDebug</span>() &lt;&lt; <span class="hljs-built_in">QUrl</span>(<span class="hljs-string">"file:file.txt"</span>).<span class="hljs-built_in">toLocalFile</span>();            <span class="hljs-comment">// "file.txt"</span>
<span class="hljs-built_in">qDebug</span>() &lt;&lt; <span class="hljs-built_in">QUrl</span>(<span class="hljs-string">"file:/home/user/file.txt"</span>).<span class="hljs-built_in">toLocalFile</span>(); <span class="hljs-comment">// "/home/user/file.txt"</span>
<span class="hljs-built_in">qDebug</span>() &lt;&lt; <span class="hljs-built_in">QUrl</span>(<span class="hljs-string">"file.txt"</span>).<span class="hljs-built_in">toLocalFile</span>();                 <span class="hljs-comment">// ""; wasn't a local file as it had no scheme</span></code></pre></div>

<p>注意：如果此 URL 的路径组件包含非 UTF-8 二进制序列（例如 %80），则此函数的行为未定义。</p>
<p><strong>另请参见</strong><a target="_blank" rel="noopener" href="https://doc.qt.io/qt-6/qurl.html#fromLocalFile">fromLocalFile</a> () 和<a target="_blank" rel="noopener" href="https://doc.qt.io/qt-6/qurl.html#isLocalFile">isLocalFile</a> ()。</p>
<h3><span id="since-5-2-nsurl-qurl-tonsurl-const"><code>[since 5.2]</code>NSURL *QUrl::toNSURL() const</span><a href="#since-5-2-nsurl-qurl-tonsurl-const" class="header-anchor">#</a></h3><p><a target="_blank" rel="noopener" href="https://doc.qt.io/qt-6/qurl.html">从QUrl</a>创建一个 NSURL 。</p>
<p>NSURL 是自动释放的。</p>
<p>这个函数是在 Qt 5.2 中引入的。</p>
<h3><span id="static-qbytearray-qurl-topercentencoding-const-qstring-amp-input-const-qbytearray-amp-exclude-qbytearray-const-qbytearray-amp-include-qbytearray"><code>[static]</code> QUrl::toPercentEncoding(const  &amp;<em>input</em>, const  &amp;<em>exclude</em> = QByteArray(), const  &amp;<em>include</em> = QByteArray())</span><a href="#static-qbytearray-qurl-topercentencoding-const-qstring-amp-input-const-qbytearray-amp-exclude-qbytearray-const-qbytearray-amp-include-qbytearray" class="header-anchor">#</a></h3><p>返回<em>input</em>的编码副本。<em>输入</em>首先转换为 UTF-8，并且所有不在未保留组中的 ASCII 字符都进行百分比编码。为了防止字符被百分比编码，将它们传递给<em>exclude</em>。要强制字符进行百分比编码，请将它们传递给<em>include</em>。</p>
<p>未保留定义为：<code>ALPHA / DIGIT / "-" / "." / "_" / "~"</code></p>
<div class="code-wrapper"><pre><code class="hljs c++">QByteArray ba = QUrl::<span class="hljs-built_in">toPercentEncoding</span>(<span class="hljs-string">"{a fishy string?}"</span>, <span class="hljs-string">"{}"</span>, <span class="hljs-string">"s"</span>);
<span class="hljs-built_in">qDebug</span>(ba.<span class="hljs-built_in">constData</span>());
<span class="hljs-comment">// prints "{a fi%73hy %73tring%3F}"</span></code></pre></div>

<h3><span id="qstring-qurl-tostring-qurl-formattingoptions-options-formattingoptions-prettydecoded-const"> QUrl::toString( <em>options</em> = FormattingOptions(PrettyDecoded)) const</span><a href="#qstring-qurl-tostring-qurl-formattingoptions-options-formattingoptions-prettydecoded-const" class="header-anchor">#</a></h3><p>返回 URL 的字符串表示形式。可以通过传递带有<em>options</em>的标志来自定义输出。此函数中不允许使用选项<a target="_blank" rel="noopener" href="https://doc.qt.io/qt-6/qurl.html#ComponentFormattingOption-enum">QUrl::FullyDecoded ，因为它会生成模棱两可的数据。</a></p>
<p>默认格式选项是<a target="_blank" rel="noopener" href="https://doc.qt.io/qt-6/qurl.html#UrlFormattingOption-enum">PrettyDecoded</a>。</p>
<p><strong>另请参阅</strong><a target="_blank" rel="noopener" href="https://doc.qt.io/qt-6/qurl.html#UrlFormattingOption-enum">FormattingOptions</a>、<a target="_blank" rel="noopener" href="https://doc.qt.io/qt-6/qurl.html#url">url</a> () 和<a target="_blank" rel="noopener" href="https://doc.qt.io/qt-6/qurl.html#setUrl">setUrl</a> ()。</p>
<h3><span id="static-since-5-1-qstringlist-qurl-tostringlist-const-qlist-lt-qurl-gt-amp-urls-qurl-formattingoptions-options-formattingoptions-prettydecoded"><code>[static, since 5.1]</code> QUrl::toStringList(const &lt;&gt; &amp;<em>urls</em>,  <em>options</em> = FormattingOptions(PrettyDecoded))</span><a href="#static-since-5-1-qstringlist-qurl-tostringlist-const-qlist-lt-qurl-gt-amp-urls-qurl-formattingoptions-options-formattingoptions-prettydecoded" class="header-anchor">#</a></h3><p><a target="_blank" rel="noopener" href="https://doc.qt.io/qt-6/qurl.html#toString">使用toString</a> ( <em>options</em> )将<em>url</em>列表转换为<a target="_blank" rel="noopener" href="https://doc.qt.io/qt-6/qstring.html">QString</a>对象列表。</p>
<p>这个函数是在 Qt 5.1 中引入的。</p>
<h3><span id="qstring-qurl-url-qurl-formattingoptions-options-formattingoptions-prettydecoded-const"> QUrl::url( <em>options</em> = FormattingOptions(PrettyDecoded)) const</span><a href="#qstring-qurl-url-qurl-formattingoptions-options-formattingoptions-prettydecoded-const" class="header-anchor">#</a></h3><p>返回 URL 的字符串表示形式。可以通过传递带有<em>options</em>的标志来自定义输出。此函数中不允许使用选项<a target="_blank" rel="noopener" href="https://doc.qt.io/qt-6/qurl.html#ComponentFormattingOption-enum">QUrl::FullyDecoded ，因为它会生成模棱两可的数据。</a></p>
<p>生成的<a target="_blank" rel="noopener" href="https://doc.qt.io/qt-6/qstring.html">QString</a>可以稍后传递回<a target="_blank" rel="noopener" href="https://doc.qt.io/qt-6/qurl.html">QUrl</a>。</p>
<p><a target="_blank" rel="noopener" href="https://doc.qt.io/qt-6/qurl.html#toString">toString</a>（选项）的同义词。</p>
<p><strong>另请参见</strong><a target="_blank" rel="noopener" href="https://doc.qt.io/qt-6/qurl.html#setUrl">setUrl</a> ()、<a target="_blank" rel="noopener" href="https://doc.qt.io/qt-6/qurl.html#UrlFormattingOption-enum">FormattingOptions</a>、<a target="_blank" rel="noopener" href="https://doc.qt.io/qt-6/qurl.html#toEncoded">toEncoded</a> () 和<a target="_blank" rel="noopener" href="https://doc.qt.io/qt-6/qurl.html#toString">toString</a> ()。</p>
<h3><span id="qstring-qurl-userinfo-qurl-componentformattingoptions-options-prettydecoded-const"> QUrl::userInfo( <em>options</em> = PrettyDecoded) const</span><a href="#qstring-qurl-userinfo-qurl-componentformattingoptions-options-prettydecoded-const" class="header-anchor">#</a></h3><p>返回 URL 的用户信息，如果用户信息未定义，则返回空字符串。</p>
<p>此函数返回一个明确的值，其中可能包含仍以百分比编码的字符，以及一些在<a target="_blank" rel="noopener" href="https://doc.qt.io/qt-6/qstring.html">QString</a>中无法以解码形式表示的控制序列。</p>
<p><em>options</em>参数控制如何格式化用户信息组件。<a target="_blank" rel="noopener" href="https://doc.qt.io/qt-6/qurl.html#ComponentFormattingOption-enum">此函数中不允许QUrl::FullyDecoded</a>的值。如果需要获取完全解码的数据，分别调用<a target="_blank" rel="noopener" href="https://doc.qt.io/qt-6/qurl.html#userName">userName</a> ()和<a target="_blank" rel="noopener" href="https://doc.qt.io/qt-6/qurl.html#password">password</a> ()。</p>
<p><strong>另请参见</strong><a target="_blank" rel="noopener" href="https://doc.qt.io/qt-6/qurl.html#setUserInfo">setUserInfo</a> ()、<a target="_blank" rel="noopener" href="https://doc.qt.io/qt-6/qurl.html#userName">userName</a> ()、<a target="_blank" rel="noopener" href="https://doc.qt.io/qt-6/qurl.html#password">password</a> () 和<a target="_blank" rel="noopener" href="https://doc.qt.io/qt-6/qurl.html#authority">authority</a> ()。</p>
<h3><span id="qstring-qurl-username-qurl-componentformattingoptions-options-fullydecoded-const"> QUrl::userName( <em>options</em> = FullyDecoded) const</span><a href="#qstring-qurl-username-qurl-componentformattingoptions-options-fullydecoded-const" class="header-anchor">#</a></h3><p>如果已定义，则返回 URL 的用户名；否则返回一个空字符串。</p>
<p><em>options</em>参数控制如何格式化用户名组件。所有值都会产生明确的结果。使用<a target="_blank" rel="noopener" href="https://doc.qt.io/qt-6/qurl.html#ComponentFormattingOption-enum">QUrl::FullyDecoded</a>，所有百分比编码的序列都被解码；否则，返回的值可能包含某些控制序列的百分比编码序列，这些控制序列在<a target="_blank" rel="noopener" href="https://doc.qt.io/qt-6/qstring.html">QString</a>中无法以解码形式表示。</p>
<p>请注意，如果存在那些不可表示的序列，则<a target="_blank" rel="noopener" href="https://doc.qt.io/qt-6/qurl.html#ComponentFormattingOption-enum">QUrl::FullyDecoded可能会导致数据丢失。</a>当结果将在非 URL 上下文中使用时，建议使用该值，例如在<a target="_blank" rel="noopener" href="https://doc.qt.io/qt-6/qauthenticator.html">QAuthenticator</a>中设置或协商登录。</p>
<p><strong>另请参见</strong><a target="_blank" rel="noopener" href="https://doc.qt.io/qt-6/qurl.html#setUserName">setUserName</a> () 和<a target="_blank" rel="noopener" href="https://doc.qt.io/qt-6/qurl.html#userInfo">userInfo</a> ()。</p>
<h3><span id="bool-qurl-operator-const-qurl-amp-url-const">bool QUrl::operator!=(const  &amp;<em>url</em>) const</span><a href="#bool-qurl-operator-const-qurl-amp-url-const" class="header-anchor">#</a></h3><p>如果此 URL 和给定的<em>url</em>不相等，则返回 <code>true</code>；否则返回<code>false</code>。 </p>
<p><strong>See also</strong> <a href="#matches">matches</a>().</p>
<h3><span id="bool-qurl-operator-const-qurl-amp-url-const">bool QUrl::operator==(const  &amp;<em>url</em>) const</span><a href="#bool-qurl-operator-const-qurl-amp-url-const" class="header-anchor">#</a></h3><p>如果此 URL 和给定的<em>url</em>相等，则返回 <code>true</code>；否则返回<code>false</code>。 </p>
<p><strong>See also</strong> <a href="#matches">matches</a>().</p>
<h2><span id="xiang-guan-fei-cheng-yuan">相关非成员</span><a href="#xiang-guan-fei-cheng-yuan" class="header-anchor">#</a></h2><h3><span id="qdatastream-amp-operator-lt-lt-qdatastream-amp-out-const-qurl-amp-url"> &amp;operator&lt;&lt;( &amp;<em>out</em>, const  &amp;<em>url</em>)</span><a href="#qdatastream-amp-operator-lt-lt-qdatastream-amp-out-const-qurl-amp-url" class="header-anchor">#</a></h3><p>将 url <em>url</em>写入流<em>输出</em>并返回对流的引用。</p>
<p><strong>另请参阅</strong><a target="_blank" rel="noopener" href="https://doc.qt.io/qt-6/datastreamformat.html">QDataStream 运算符的格式</a>。</p>
<h3><span id="qdatastream-amp-operator-gt-gt-qdatastream-amp-in-qurl-amp-url"> &amp;operator&gt;&gt;( &amp;<em>in</em>,  &amp;<em>url</em>)</span><a href="#qdatastream-amp-operator-gt-gt-qdatastream-amp-in-qurl-amp-url" class="header-anchor">#</a></h3><p>从流<em>in</em>读取一个url到<em>url</em>中，并返回对流的引用。</p>
<p><strong>另请参阅</strong><a target="_blank" rel="noopener" href="https://doc.qt.io/qt-6/datastreamformat.html">QDataStream 运算符的格式</a>。</p>
<h2><span id="hong-wen-dang">宏文档</span><a href="#hong-wen-dang" class="header-anchor">#</a></h2><h3><span id="qt-no-url-cast-from-string">QT_NO_URL_CAST_FROM_STRING</span><a href="#qt-no-url-cast-from-string" class="header-anchor">#</a></h3><p>禁用从<a target="_blank" rel="noopener" href="https://doc.qt.io/qt-6/qstring.html">QString</a>（或 char *）到<a target="_blank" rel="noopener" href="https://doc.qt.io/qt-6/qurl.html">QUrl</a>的自动转换。</p>
<p>当您有很多使用<a target="_blank" rel="noopener" href="https://doc.qt.io/qt-6/qstring.html">QString</a>作为文件名的代码并且您希望将其转换为使用<a target="_blank" rel="noopener" href="https://doc.qt.io/qt-6/qurl.html">QUrl</a>以实现网络透明性时，使用此定义编译代码很有用。在任何使用<a target="_blank" rel="noopener" href="https://doc.qt.io/qt-6/qurl.html">QUrl</a>的代码中，它可以帮助避免丢失<a target="_blank" rel="noopener" href="https://doc.qt.io/qt-6/qurl.html#resolved">QUrl::resolved</a> () 调用，以及<a target="_blank" rel="noopener" href="https://doc.qt.io/qt-6/qstring.html">QString</a>到<a target="_blank" rel="noopener" href="https://doc.qt.io/qt-6/qurl.html">QUrl</a>转换的其他误用。</p>
<p>例如，如果您有类似的代码</p>
<div class="code-wrapper"><pre><code class="hljs c++">url = filename; <span class="hljs-comment">// probably not what you want</span></code></pre></div>

<p> 您可以将其重写为 </p>
<div class="code-wrapper"><pre><code class="hljs c++">url = QUrl::<span class="hljs-built_in">fromLocalFile</span>(filename);
url = baseurl.<span class="hljs-built_in">resolved</span>(<span class="hljs-built_in">QUrl</span>(filename));</code></pre></div>

<p> <strong>另请参见</strong><a target="_blank" rel="noopener" href="https://doc.qt.io/qt-6/qstring.html#QT_NO_CAST_FROM_ASCII">QT_NO_CAST_FROM_ASCII</a>。</p>

            </div>
            <hr>
            <div>
              <div class="post-metas mb-3">
                
                
                  <div class="post-meta">
                    <i class="iconfont icon-tags"></i>
                    
                      <a class="hover-with-bg" href="/tags/U/">U</a>
                    
                  </div>
                
              </div>
              
                <p class="note note-warning">
                  
                    本博客所有文章除特别声明外，均采用 <a target="_blank" href="https://creativecommons.org/licenses/by-sa/4.0/deed.zh" rel="nofollow noopener noopener">CC BY-SA 4.0 协议</a> ，转载请注明出处！
                  
                </p>
              
              
                <div class="post-prevnext">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/2022/03/02/QtDocumentCN/Src/V/QVariantAnimation/QVariantAnimation/">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">QVariantAnimation类</span>
                        <span class="visible-mobile">上一篇</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2022/03/02/QtDocumentCN/Src/V/QVariantConstPointer/QVariantConstPointer/">
                        <span class="hidden-mobile">QVariantConstPointer类</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
              <!-- Comments -->
              <article class="comments" id="comments" lazyload>
                
                  
                
                
  <div id="lv-container" data-id="city" data-uid="MTAyMC81NTMzMi8zMTc5OQ==">
    <script type="text/javascript">
      Fluid.utils.loadComments('#lv-container', function() {
        Fluid.utils.createScript('https://cdn-city.livere.com/js/embed.dist.js');
      });
    </script>
    <noscript>Please enable JavaScript to view the comments</noscript>
  </div>


              </article>
            
          </article>
        </div>
      </div>
    </div>
    
      <div class="d-none d-lg-block col-lg-2 toc-container" id="toc-ctn">
        <div id="toc">
  <p class="toc-header"><i class="iconfont icon-list"></i>&nbsp;目录</p>
  <div class="toc-body" id="toc-body"></div>
</div>

      </div>
    
  </div>
</div>

<!-- Custom -->


    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v"
                 for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>
    

    
  </main>

  <footer class="text-center mt-5 py-3">
  <div class="footer-content">
     <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> 
  </div>
  

  

  
</footer>


  <!-- SCRIPTS -->
  
  <script  src="https://cdn.jsdelivr.net/npm/nprogress@0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/nprogress@0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js" ></script>
<script  src="https://cdn.jsdelivr.net/npm/bootstrap@4/dist/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>

<!-- Plugins -->


  <script  src="/js/local-search.js" ></script>



  
    <script  src="/js/img-lazyload.js" ></script>
  



  



  
    <script  src="https://cdn.jsdelivr.net/npm/tocbot@4/dist/tocbot.min.js" ></script>
  
  
    <script  src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3/dist/jquery.fancybox.min.js" ></script>
  
  
    <script  src="https://cdn.jsdelivr.net/npm/anchor-js@4/anchor.min.js" ></script>
  
  
    <script defer src="https://cdn.jsdelivr.net/npm/clipboard@2/dist/clipboard.min.js" ></script>
  






  <script  src="https://cdn.jsdelivr.net/npm/typed.js@2/lib/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var title = document.getElementById('subtitle').title;
      
        typing(title);
      
    })(window, document);
  </script>















<!-- 主题的启动项 保持在最底部 -->
<script  src="/js/boot.js" ></script>


</body>
</html>
