

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=auto>



<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/logo.jpg">
  <link rel="icon" href="/img/logo.jpg">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
    <meta http-equiv="Content-Security-Policy" content="upgrade-insecure-requests">
  
  <meta name="theme-color" content="#6aa84f">
  <meta name="author" content="John Doe">
  <meta name="keywords" content="">
  
    <meta name="description" content="QImage 类 公共类型 公共函数 静态公共成员 相关非成员 详细描述 读写图像文件 图像信息 像素操纵 图像格式 图像变换   成员类型文档 enum QImage:: 格式 enum QImage:: InvertMode   成员函数文档 QImage  QImage  QImage  QImage  [since 6.0] QImage QImage:: convertedTo">
<meta property="og:type" content="article">
<meta property="og:title" content="QImage类">
<meta property="og:url" content="https://txt1994.github.io/2022/03/02/QtDocumentCN/Src/I/QImage/QImage/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:description" content="QImage 类 公共类型 公共函数 静态公共成员 相关非成员 详细描述 读写图像文件 图像信息 像素操纵 图像格式 图像变换   成员类型文档 enum QImage:: 格式 enum QImage:: InvertMode   成员函数文档 QImage  QImage  QImage  QImage  [since 6.0] QImage QImage:: convertedTo">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://doc.qt.io/qt-6/images/qimage-32bit_scaled.png">
<meta property="og:image" content="https://doc.qt.io/qt-6/images/qimage-8bit_scaled.png">
<meta property="og:image" content="https://doc.qt.io/qt-6/images/qimage-scaling.png">
<meta property="article:published_time" content="2022-03-02T06:31:47.000Z">
<meta property="article:modified_time" content="2022-03-18T16:41:52.361Z">
<meta property="article:author" content="John Doe">
<meta property="article:tag" content="I">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="https://doc.qt.io/qt-6/images/qimage-32bit_scaled.png">
  
  
  <title>QImage类 - Hexo</title>

  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4/dist/css/bootstrap.min.css" />


  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/github-markdown-css@4/github-markdown.min.css" />
  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/hint.css@2/hint.min.css" />

  
    
    
      
      <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@10/styles/github-gist.min.css" />
    
  

  
    <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3/dist/jquery.fancybox.min.css" />
  


<!-- 主题依赖的图标库，不要自行修改 -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_ba1fz6golrf.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_lbnruvf0jn.css">


<link  rel="stylesheet" href="/css/main.css" />

<!-- 自定义样式保持在最底部 -->

  
<link rel="stylesheet" href="/css/style.css">



  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    var CONFIG = {"hostname":"txt1994.github.io","root":"/","version":"1.8.14","typing":{"enable":true,"typeSpeed":70,"cursorChar":"_","loop":false},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"right","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"copy_btn":true,"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":false,"baidu":null,"google":null,"gtag":null,"tencent":{"sid":null,"cid":null},"woyaola":null,"cnzz":null,"leancloud":{"app_id":null,"app_key":null,"server_url":null,"path":"window.location.pathname","ignore_local":false}},"search_path":"/local-search.xml"};
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
<meta name="generator" content="Hexo 6.1.0">
<style>.github-emoji { position: relative; display: inline-block; width: 1.2em; min-height: 1.2em; overflow: hidden; vertical-align: top; color: transparent; }  .github-emoji > span { position: relative; z-index: 10; }  .github-emoji img, .github-emoji .fancybox { margin: 0 !important; padding: 0 !important; border: none !important; outline: none !important; text-decoration: none !important; user-select: none !important; cursor: auto !important; }  .github-emoji img { height: 1.2em !important; width: 1.2em !important; position: absolute !important; left: 50% !important; top: 50% !important; transform: translate(-50%, -50%) !important; user-select: none !important; cursor: auto !important; } .github-emoji-fallback { color: inherit; } .github-emoji-fallback img { opacity: 0 !important; }</style>
</head>


<body>
  <header style="height: 70vh;">
    <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/">
      <strong>txt1994s</strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/">
                <i class="iconfont icon-home-fill"></i>
                首页
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/">
                <i class="iconfont icon-archive-fill"></i>
                归档
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/">
                <i class="iconfont icon-tags-fill"></i>
                标签
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/">
                <i class="iconfont icon-user-fill"></i>
                关于
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/links/">
                <i class="iconfont icon-link-fill"></i>
                友联
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              &nbsp;<i class="iconfont icon-search"></i>&nbsp;
            </a>
          </li>
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">&nbsp;<i
                class="iconfont icon-dark" id="color-toggle-icon"></i>&nbsp;</a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

    <div class="banner" id="banner" parallax=true
         style="background: url('/img/default.png') no-repeat center center;
           background-size: cover;">
      <div class="full-bg-img">
        <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
          <div class="page-header text-center fade-in-up">
            <span class="h2" id="subtitle" title="QImage类">
              
            </span>

            
              <div class="mt-3">
  
  
    <span class="post-meta">
      <i class="iconfont icon-date-fill" aria-hidden="true"></i>
      <time datetime="2022-03-02 14:31" pubdate>
        2022年3月2日 下午
      </time>
    </span>
  
</div>

<div class="mt-1">
  
    <span class="post-meta mr-2">
      <i class="iconfont icon-chart"></i>
      42k 字
    </span>
  

  
    <span class="post-meta mr-2">
      <i class="iconfont icon-clock-fill"></i>
      
      
      352 分钟
    </span>
  

  
  
</div>

            
          </div>

          
        </div>
      </div>
    </div>
  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="d-none d-lg-block col-lg-2"></div>
    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div class="py-5" id="board">
          <article class="post-content mx-auto">
            <!-- SEO header -->
            <h1 style="display: none">QImage类</h1>
            
              <p class="note note-info">
                
                  本文最后更新于：2022年3月19日 凌晨
                
              </p>
            
            <div class="markdown-body">
              <div class="toc">

<!-- toc -->

<ul>
<li><a href="#qimage-lei">QImage 类</a><ul>
<li><a href="#gong-gong-lei-xing">公共类型</a></li>
<li><a href="#gong-gong-han-shu">公共函数</a></li>
<li><a href="#jing-tai-gong-gong-cheng-yuan">静态公共成员</a></li>
<li><a href="#xiang-guan-fei-cheng-yuan">相关非成员</a></li>
<li><a href="#xiang-xi-miao-shu">详细描述</a><ul>
<li><a href="#du-xie-tu-xiang-wen-jian">读写图像文件</a></li>
<li><a href="#tu-xiang-xin-xi">图像信息</a></li>
<li><a href="#xiang-su-cao-zong">像素操纵</a></li>
<li><a href="#tu-xiang-ge-shi">图像格式</a></li>
<li><a href="#tu-xiang-bian-huan">图像变换</a></li>
</ul>
</li>
<li><a href="#cheng-yuan-lei-xing-wen-dang">成员类型文档</a><ul>
<li><a href="#enum-qimage-ge-shi">enum QImage:: 格式</a></li>
<li><a href="#enum-qimage-invertmode">enum QImage:: InvertMode</a></li>
</ul>
</li>
<li><a href="#cheng-yuan-han-shu-wen-dang">成员函数文档</a><ul>
<li><a href="#qimage-qimage-qimage-rgbswapped">QImage </a></li>
<li><a href="#qimage-qimage-qimage-rgbswapped-const-1">QImage </a></li>
<li><a href="#qimage-qimage-qimage-mirrored-bool-horizontal-false-bool-vertical-true-2">QImage </a></li>
<li><a href="#qimage-qimage-qimage-mirrored-bool-horizontal-false-bool-vertical-true-const-3">QImage </a></li>
<li><a href="#since-6-0-qimage-qimage-qimage-convertedto-qimage-format-format-enum-format-qt-imageconversionflags-imageconversionflag-enum-flags-qt-autocolor"><code>[since 6.0] </code></a><a href="#QImage">QImage </a>QImage:: convertedTo ( <a href="#Format-enum">QImage::Format </a><em>format</em> , <a href="#ImageConversionFlag-enum">Qt::ImageConversionFlags </a><em>flags</em> = Qt::AutoColor) &amp;&amp;</li>
<li><a href="#since-6-0-qimage-qimage-qimage-convertedto-qimage-format-format-enum-format-qt-imageconversionflags-imageconversionflag-enum-flags-qt-autocolor-const"><code>[since 6.0] </code></a><a href="#QImage">QImage </a>QImage:: convertedTo ( <a href="#Format-enum">QImage::Format </a><em>format</em> , <a href="#ImageConversionFlag-enum">Qt::ImageConversionFlags </a><em>flags</em> = Qt::AutoColor) const &amp;</li>
<li><a href="#qimage-qimage-qimage-converttoformat-qimage-format-format-enum-format-qt-imageconversionflags-imageconversionflag-enum-flags-qt-autocolor-4">QImage </a></li>
<li><a href="#qimage-qimage-qimage-converttoformat-qimage-format-format-enum-format-qt-imageconversionflags-imageconversionflag-enum-flags-qt-autocolor-const-5">QImage </a></li>
<li><a href="#since-5-2-qimage-qimage-qimage-qimage-other"><code>[since 5.2] </code>QImage:: QImage ( </a><a href="#QImage">QImage </a>&amp;&amp; <em>other</em> )</li>
<li><a href="#qimage-qimage-const-qimage-qimage-image">QImage:: QImage (const </a><a href="#QImage">QImage </a>&amp; <em>image</em> )</li>
<li><a href="#qimage-qimage-const-qstring-qstring-html-filename-const-char-format-nullptr">QImage:: QImage (const </a><a href="qstring.html">QString </a>&amp; <em>fileName</em> , const char * <em>format</em> = nullptr)</li>
<li><a href="#qimage-qimage-const-char-const-xpm">QImage:: QImage (const char *const [] <em>xpm</em> )</a></li>
<li><a href="#qimage-qimage-const-uchar-qtglobal-html-uchar-typedef-data-int-width-int-height-qsizetype-bytesperline-qimage-format-format-enum-format-qimagecleanupfunction-qimagecleanupfunction-typedef-cleanupfunction-nullptr-void-cleanupinfo-nullptr">QImage:: QImage (const </a><a href="qtglobal.html#uchar-typedef">uchar </a>* <em>data</em> , int <em>width</em> , int <em>height</em> , qsizetype <em>bytesPerLine</em> , <a href="#Format-enum">QImage::Format </a><em>format</em> , <a href="#QImageCleanupFunction-typedef">QImageCleanupFunction </a><em>cleanupFunction</em> = nullptr, void * <em>cleanupInfo</em> = nullptr)</li>
<li><a href="#qimage-qimage-uchar-qtglobal-html-uchar-typedef-data-int-width-int-height-qsizetype-bytesperline-qimage-format-format-enum-format-qimagecleanupfunction-qimagecleanupfunction-typedef-cleanupfunction-nullptr-void-cleanupinfo-nullptr">QImage:: QImage ( </a><a href="qtglobal.html#uchar-typedef">uchar </a>* <em>data</em> , int <em>width</em> , int <em>height</em> , qsizetype <em>bytesPerLine</em> , <a href="#Format-enum">QImage::Format </a><em>format</em> , <a href="#QImageCleanupFunction-typedef">QImageCleanupFunction </a><em>cleanupFunction</em> = nullptr, void * <em>cleanupInfo</em> = nullptr)</li>
<li><a href="#qimage-qimage-const-uchar-qtglobal-html-uchar-typedef-data-int-width-int-height-qimage-format-format-enum-format-qimagecleanupfunction-qimagecleanupfunction-typedef-cleanupfunction-nullptr-void-cleanupinfo-nullptr">QImage:: QImage (const </a><a href="qtglobal.html#uchar-typedef">uchar </a>* <em>data</em> , int <em>width</em> , int <em>height</em> , <a href="#Format-enum">QImage::Format </a><em>format</em> , <a href="#QImageCleanupFunction-typedef">QImageCleanupFunction </a><em>cleanupFunction</em> = nullptr, void * <em>cleanupInfo</em> = nullptr)</li>
<li><a href="#qimage-qimage-uchar-qtglobal-html-uchar-typedef-data-int-width-int-height-qimage-format-format-enum-format-qimagecleanupfunction-qimagecleanupfunction-typedef-cleanupfunction-nullptr-void-cleanupinfo-nullptr">QImage:: QImage ( </a><a href="qtglobal.html#uchar-typedef">uchar </a>* <em>data</em> , int <em>width</em> , int <em>height</em> , <a href="#Format-enum">QImage::Format </a><em>format</em> , <a href="#QImageCleanupFunction-typedef">QImageCleanupFunction </a><em>cleanupFunction</em> = nullptr, void * <em>cleanupInfo</em> = nullptr)</li>
<li><a href="#qimage-qimage-int-width-int-height-qimage-format-format-enum-format">QImage:: QImage ( int <em>width</em> , int <em>height</em> , </a><a href="#Format-enum">QImage::Format </a><em>format</em> )</li>
<li><a href="#qimage-qimage-const-qsize-qsize-html-size-qimage-format-format-enum-format">QImage:: QImage (const </a><a href="qsize.html">QSize </a>&amp; <em>size</em> , <a href="#Format-enum">QImage::Format </a><em>format</em> )</li>
<li><a href="#qimage-qimage">QImage:: QImage ()</a></li>
<li><a href="#since-5-2-qimage-qimage-qimage-operator-qimage-qimage-other"><code>[since 5.2] </code></a><a href="#QImage">QImage </a>&amp;QImage:: operator= ( <a href="#QImage">QImage </a>&amp;&amp; <em>other</em> )</li>
<li><a href="#qimage-qimage-qimage-operator-const-qimage-qimage-image-6">QImage </a></li>
<li><a href="#virtual-qimage-qimage"><code>[virtual] </code>QImage:: ~QImage ()</a></li>
<li><a href="#bool-qimage-allgray-const">bool QImage:: allGray () const</a></li>
<li><a href="#since-5-14-void-qimage-applycolortransform-const-qcolortransform-qcolortransform-html-transform"><code>[since 5.14] </code>void QImage:: applyColorTransform (const </a><a href="qcolortransform.html">QColorTransform </a>&amp; <em>transform</em> )</li>
<li><a href="#int-qimage-bitplanecount-const">int QImage:: bitPlaneCount () const</a></li>
<li><a href="#uchar-qtglobal-html-uchar-typedef-qimage-bits">uchar </a></li>
<li><a href="#const-uchar-qtglobal-html-uchar-typedef-qimage-bits-const">const </a><a href="qtglobal.html#uchar-typedef">uchar </a>*QImage:: bits () const</li>
<li><a href="#qsizetype-qimage-bytesperline-const">qsizetype QImage:: bytesPerLine () const</a></li>
<li><a href="#qint64-qtglobal-html-qint64-typedef-qimage-cachekey-const">qint64 </a></li>
<li><a href="#qrgb-qrgb-typedef-qimage-color-int-i-const">QRgb </a></li>
<li><a href="#int-qimage-colorcount-const">int QImage:: colorCount () const</a></li>
<li><a href="#since-5-14-qcolorspace-qcolorspace-html-qimage-colorspace-const"><code>[since 5.14] </code></a><a href="qcolorspace.html">QColorSpace </a>QImage:: colorSpace () const</li>
<li><a href="#qlist-qlist-html-qrgb-qrgb-typedef-qimage-colortable-const">QList </a></li>
<li><a href="#const-uchar-qtglobal-html-uchar-typedef-qimage-constbits-const">const </a><a href="qtglobal.html#uchar-typedef">uchar </a>*QImage:: constBits () const</li>
<li><a href="#const-uchar-qtglobal-html-uchar-typedef-qimage-constscanline-int-i-const">const </a><a href="qtglobal.html#uchar-typedef">uchar </a>*QImage:: constScanLine ( int <em>i</em> ) const</li>
<li><a href="#since-5-13-void-qimage-convertto-qimage-format-format-enum-format-qt-imageconversionflags-imageconversionflag-enum-flags-qt-autocolor"><code>[since 5.13] </code>void QImage:: convertTo ( </a><a href="#Format-enum">QImage::Format </a><em>format</em> , <a href="#ImageConversionFlag-enum">Qt::ImageConversionFlags </a><em>flags</em> = Qt::AutoColor)</li>
<li><a href="#since-5-14-void-qimage-converttocolorspace-const-qcolorspace-qcolorspace-html-colorspace"><code>[since 5.14] </code>void QImage:: convertToColorSpace (const </a><a href="qcolorspace.html">QColorSpace </a>&amp; <em>colorSpace</em> )</li>
<li><a href="#qimage-qimage-qimage-converttoformat-qimage-format-format-enum-format-const-qlist-qlist-html-qrgb-qrgb-typedef-colortable-qt-imageconversionflags-imageconversionflag-enum-flags-qt-autocolor-const-7">QImage </a></li>
<li><a href="#since-5-14-qimage-qimage-qimage-convertedtocolorspace-const-qcolorspace-qcolorspace-html-colorspace-const"><code>[since 5.14] </code></a><a href="#QImage">QImage </a>QImage:: convertedToColorSpace (const <a href="qcolorspace.html">QColorSpace </a>&amp; <em>colorSpace</em> ) const</li>
<li><a href="#qimage-qimage-qimage-copy-const-qrect-qrect-html-rectangle-qrect-const-8">QImage </a></li>
<li><a href="#qimage-qimage-qimage-copy-int-x-int-y-int-width-int-height-const-9">QImage </a></li>
<li><a href="#qimage-qimage-qimage-createalphamask-qt-imageconversionflags-imageconversionflag-enum-flags-qt-autocolor-const-10">QImage </a></li>
<li><a href="#qimage-qimage-qimage-createheuristicmask-bool-cliptight-true-const-11">QImage </a></li>
<li><a href="#qimage-qimage-qimage-createmaskfromcolor-qrgb-qrgb-typedef-color-qt-maskmode-maskmode-enum-mode-qt-maskincolor-const-12">QImage </a></li>
<li><a href="#int-qimage-depth-const">int QImage:: depth () const</a></li>
<li><a href="#qsizef-qsizef-html-qimage-deviceindependentsize-const">QSizeF </a></li>
<li><a href="#qreal-qtglobal-html-qreal-typedef-qimage-devicepixelratio-const">qreal </a></li>
<li><a href="#int-qimage-dotspermeterx-const">int QImage:: dotsPerMeterX () const</a></li>
<li><a href="#int-qimage-dotspermetery-const">int QImage:: dotsPerMeterY () const</a></li>
<li><a href="#void-qimage-fill-uint-qtglobal-html-uint-typedef-pixelvalue">void QImage:: fill ( </a><a href="qtglobal.html#uint-typedef">uint </a><em>pixelValue</em> )</li>
<li><a href="#void-qimage-fill-const-qcolor-color">void QImage:: fill (const </a><a href>QColor </a>&amp; <em>color</em> )</li>
<li><a href="#void-qimage-fill-qt-globalcolor-globalcolor-enum-color">void QImage:: fill ( </a><a href="#GlobalColor-enum">Qt::GlobalColor </a><em>color</em> )</li>
<li><a href="#qimage-format-format-enum-qimage-format-const">QImage::Format </a></li>
<li><a href="#static-since-6-2-qimage-qimage-qimage-fromdata-qbytearrayview-qbytearrayview-html-data-const-char-format-nullptr"><code>[static, since 6.2] </code></a><a href="#QImage">QImage </a>QImage:: fromData ( <a href="qbytearrayview.html">QByteArrayView </a><em>data</em> , const char * <em>format</em> = nullptr)</li>
<li><a href="#static-qimage-qimage-qimage-fromdata-const-uchar-qtglobal-html-uchar-typedef-data-int-size-const-char-format-nullptr"><code>[static] </code></a><a href="#QImage">QImage </a>QImage:: fromData (const <a href="qtglobal.html#uchar-typedef">uchar </a>* <em>data</em> , int <em>size</em> , const char * <em>format</em> = nullptr)</li>
<li><a href="#static-qimage-qimage-qimage-fromdata-const-qbytearray-qbytearray-html-data-const-char-format-nullptr"><code>[static] </code></a><a href="#QImage">QImage </a>QImage:: fromData (const <a href="qbytearray.html">QByteArray </a>&amp; <em>data</em> , const char * <em>format</em> = nullptr)</li>
<li><a href="#static-since-6-0-qimage-qimage-qimage-fromhbitmap-hbitmap-hbitmap"><code>[static, since 6.0] </code></a><a href="#QImage">QImage </a>QImage:: fromHBITMAP ( HBITMAP <em>hbitmap</em> )</li>
<li><a href="#static-since-6-0-qimage-qimage-qimage-fromhicon-hicon-icon"><code>[static, since 6.0] </code></a><a href="#QImage">QImage </a>QImage:: fromHICON ( HICON <em>icon</em> )</li>
<li><a href="#bool-qimage-hasalphachannel-const">bool QImage:: hasAlphaChannel () const</a></li>
<li><a href="#int-qimage-height-const">int QImage:: height () const</a></li>
<li><a href="#void-qimage-invertpixels-qimage-invertmode-invertmode-enum-mode-invertrgb">void QImage:: invertPixels ( </a><a href="#InvertMode-enum">QImage::InvertMode </a><em>mode</em> = InvertRgb)</li>
<li><a href="#bool-qimage-isgrayscale-const">bool QImage:: isGrayscale () const</a></li>
<li><a href="#bool-qimage-isnull-const">bool QImage:: isNull () const</a></li>
<li><a href="#bool-qimage-load-const-qstring-qstring-html-filename-const-char-format-nullptr">bool QImage:: load (const </a><a href="qstring.html">QString </a>&amp; <em>fileName</em> , const char * <em>format</em> = nullptr)</li>
<li><a href="#bool-qimage-load-qiodevice-qiodevice-html-device-const-char-format">bool QImage:: load ( </a><a href="qiodevice.html">QIODevice </a>* <em>device</em> , const char * <em>format</em> )</li>
<li><a href="#since-6-2-bool-qimage-loadfromdata-qbytearrayview-qbytearrayview-html-data-const-char-format-nullptr"><code>[since 6.2] </code>bool QImage:: loadFromData ( </a><a href="qbytearrayview.html">QByteArrayView </a><em>data</em> , const char * <em>format</em> = nullptr)</li>
<li><a href="#bool-qimage-loadfromdata-const-uchar-qtglobal-html-uchar-typedef-data-int-len-const-char-format-nullptr">bool QImage:: loadFromData (const </a><a href="qtglobal.html#uchar-typedef">uchar </a>* <em>data</em> , int <em>len</em> , const char * <em>format</em> = nullptr)</li>
<li><a href="#bool-qimage-loadfromdata-const-qbytearray-qbytearray-html-data-const-char-format-nullptr">bool QImage:: loadFromData (const </a><a href="qbytearray.html">QByteArray </a>&amp; <em>data</em> , const char * <em>format</em> = nullptr)</li>
<li><a href="#since-6-0-void-qimage-mirror-bool-horizontal-false-bool-vertical-true"><code>[since 6.0] </code>void QImage:: mirror ( bool <em>horizontal</em> = false, bool <em>vertical</em> = true)</a></li>
<li><a href="#qpoint-qpoint-html-qimage-offset-const">QPoint </a></li>
<li><a href="#qrgb-qrgb-typedef-qimage-pixel-const-qpoint-qpoint-html-position-const-1">QRgb </a></li>
<li><a href="#qrgb-qrgb-typedef-qimage-pixel-int-x-int-y-const-2">QRgb </a></li>
<li><a href="#since-5-6-qcolor-qimage-pixelcolor-const-qpoint-qpoint-html-position-const"><code>[since 5.6] </code></a><a href>QColor </a>QImage:: pixelColor (const <a href="qpoint.html">QPoint </a>&amp; <em>position</em> ) const</li>
<li><a href="#since-5-6-qcolor-qimage-pixelcolor-int-x-int-y-const"><code>[since 5.6] </code></a><a href>QColor </a>QImage:: pixelColor ( int <em>x</em> , int <em>y</em> ) const</li>
<li><a href="#qpixelformat-qpixelformat-html-qimage-pixelformat-const">QPixelFormat </a></li>
<li><a href="#int-qimage-pixelindex-const-qpoint-qpoint-html-position-const">int QImage:: pixelIndex (const </a><a href="qpoint.html">QPoint </a>&amp; <em>position</em> ) const</li>
<li><a href="#int-qimage-pixelindex-int-x-int-y-const">int QImage:: pixelIndex ( int <em>x</em> , int <em>y</em> ) const</a></li>
<li><a href="#qrect-qrect-html-qimage-rect-const">QRect </a></li>
<li><a href="#since-5-9-bool-qimage-reinterpretasformat-qimage-format-format-enum-format"><code>[since 5.9] </code>bool QImage:: reinterpretAsFormat ( </a><a href="#Format-enum">QImage::Format </a><em>format</em> )</li>
<li><a href="#since-6-0-void-qimage-rgbswap"><code>[since 6.0] </code>void QImage:: rgbSwap ()</a></li>
<li><a href="#bool-qimage-save-const-qstring-qstring-html-filename-const-char-format-nullptr-int-quality-1-const">bool QImage:: save (const </a><a href="qstring.html">QString </a>&amp; <em>fileName</em> , const char * <em>format</em> = nullptr, int <em>quality</em> = -1) const</li>
<li><a href="#bool-qimage-save-qiodevice-qiodevice-html-device-const-char-format-nullptr-int-quality-1-const">bool QImage:: save ( </a><a href="qiodevice.html">QIODevice </a>* <em>device</em> , const char * <em>format</em> = nullptr, int <em>quality</em> = -1) const</li>
<li><a href="#qimage-qimage-qimage-scaled-const-qsize-qsize-html-size-qt-aspectratiomode-aspectratiomode-enum-aspectratiomode-qt-ignoreaspectratio-qt-transformationmode-transformationmode-enum-transformmode-qt-fasttransformation-const-13">QImage </a></li>
<li><a href="#qimage-qimage-qimage-scaled-int-width-int-height-qt-aspectratiomode-aspectratiomode-enum-aspectratiomode-qt-ignoreaspectratio-qt-transformationmode-transformationmode-enum-transformmode-qt-fasttransformation-const-14">QImage </a></li>
<li><a href="#qimage-qimage-qimage-scaledtoheight-int-height-qt-transformationmode-transformationmode-enum-mode-qt-fasttransformation-const-15">QImage </a></li>
<li><a href="#qimage-qimage-qimage-scaledtowidth-int-width-qt-transformationmode-transformationmode-enum-mode-qt-fasttransformation-const-16">QImage </a></li>
<li><a href="#uchar-qtglobal-html-uchar-typedef-qimage-scanline-int-i-1">uchar </a></li>
<li><a href="#const-uchar-qtglobal-html-uchar-typedef-qimage-scanline-int-i-const">const </a><a href="qtglobal.html#uchar-typedef">uchar </a>*QImage:: scanLine ( int <em>i</em> ) const</li>
<li><a href="#void-qimage-setalphachannel-const-qimage-qimage-alphachannel">void QImage:: setAlphaChannel (const </a><a href="#QImage">QImage </a>&amp; <em>alphaChannel</em> )</li>
<li><a href="#void-qimage-setcolor-int-index-qrgb-qrgb-typedef-colorvalue">void QImage:: setColor ( int <em>index</em> , </a><a href="#QRgb-typedef">QRgb </a><em>colorValue</em> )</li>
<li><a href="#void-qimage-setcolorcount-int-colorcount">void QImage:: setColorCount ( int <em>colorCount</em> )</a></li>
<li><a href="#since-5-14-void-qimage-setcolorspace-const-qcolorspace-qcolorspace-html-colorspace"><code>[since 5.14] </code>void QImage:: setColorSpace (const </a><a href="qcolorspace.html">QColorSpace </a>&amp; <em>colorSpace</em> )</li>
<li><a href="#void-qimage-setcolortable-const-qlist-qlist-html-qrgb-qrgb-typedef-colors">void QImage:: setColorTable (const </a><a href="qlist.html">QList </a>&lt; <a href="#QRgb-typedef">QRgb </a>&gt; &amp; <em>colors</em> )</li>
<li><a href="#void-qimage-setdevicepixelratio-qreal-qtglobal-html-qreal-typedef-scalefactor">void QImage:: setDevicePixelRatio ( </a><a href="qtglobal.html#qreal-typedef">qreal </a><em>scaleFactor</em> )</li>
<li><a href="#void-qimage-setdotspermeterx-int-x">void QImage:: setDotsPerMeterX ( int <em>x</em> )</a></li>
<li><a href="#void-qimage-setdotspermetery-int-y">void QImage:: setDotsPerMeterY ( int <em>y</em> )</a></li>
<li><a href="#void-qimage-setoffset-const-qpoint-qpoint-html-offset">void QImage:: setOffset (const </a><a href="qpoint.html">QPoint </a>&amp; <em>offset</em> )</li>
<li><a href="#void-qimage-setpixel-const-qpoint-qpoint-html-position-uint-qtglobal-html-uint-typedef-index-or-rgb">void QImage:: setPixel (const </a><a href="qpoint.html">QPoint </a>&amp; <em>position</em> , <a href="qtglobal.html#uint-typedef">uint </a><em>index_or_rgb</em> )</li>
<li><a href="#void-qimage-setpixel-int-x-int-y-uint-qtglobal-html-uint-typedef-index-or-rgb">void QImage:: setPixel ( int <em>x</em> , int <em>y</em> , </a><a href="qtglobal.html#uint-typedef">uint </a><em>index_or_rgb</em> )</li>
<li><a href="#since-5-6-void-qimage-setpixelcolor-const-qpoint-qpoint-html-position-const-qcolor-color"><code>[since 5.6] </code>void QImage:: setPixelColor (const </a><a href="qpoint.html">QPoint </a>&amp; <em>position</em> , const <a href>QColor </a>&amp; <em>color</em> )</li>
<li><a href="#since-5-6-void-qimage-setpixelcolor-int-x-int-y-const-qcolor-color"><code>[since 5.6] </code>void QImage:: setPixelColor ( int <em>x</em> , int <em>y</em> , const </a><a href>QColor </a>&amp; <em>color</em> )</li>
<li><a href="#void-qimage-settext-const-qstring-qstring-html-key-const-qstring-qstring-html-text">void QImage:: setText (const </a><a href="qstring.html">QString </a>&amp; <em>key</em> , const <a href="qstring.html">QString </a>&amp; <em>text</em> )</li>
<li><a href="#qsize-qsize-html-qimage-size-const">QSize </a></li>
<li><a href="#since-5-10-qsizetype-qimage-sizeinbytes-const"><code>[since 5.10] </code>qsizetype QImage:: sizeInBytes () const</a></li>
<li><a href="#void-qimage-swap-qimage-qimage-other">void QImage:: swap ( </a><a href="#QImage">QImage </a>&amp; <em>other</em> )</li>
<li><a href="#qstring-qstring-html-qimage-text-const-qstring-qstring-html-key-qstring-const">QString </a></li>
<li><a href="#qstringlist-qstringlist-html-qimage-textkeys-const">QStringList </a></li>
<li><a href="#cgimageref-qimage-tocgimage-const">CGImageRef QImage:: toCGImage () const</a></li>
<li><a href="#since-6-0-hbitmap-qimage-tohbitmap-const"><code>[since 6.0] </code>HBITMAP QImage:: toHBITMAP () const</a></li>
<li><a href="#since-6-0-hicon-qimage-tohicon-const-qimage-qimage-mask-const"><code>[since 6.0] </code>HICON QImage:: toHICON (const </a><a href="#QImage">QImage </a>&amp; <em>mask</em> = {}) const</li>
<li><a href="#static-qimage-format-format-enum-qimage-toimageformat-qpixelformat-qpixelformat-html-format"><code>[static] </code></a><a href="#Format-enum">QImage::Format </a>QImage:: toImageFormat ( <a href="qpixelformat.html">QPixelFormat </a><em>format</em> )</li>
<li><a href="#static-qpixelformat-qpixelformat-html-qimage-topixelformat-qimage-format-format-enum-format"><code>[static] </code></a><a href="qpixelformat.html">QPixelFormat </a>QImage:: toPixelFormat ( <a href="#Format-enum">QImage::Format </a><em>format</em> )</li>
<li><a href="#qimage-qimage-qimage-transformed-const-qtransform-qtransform-html-matrix-qt-transformationmode-transformationmode-enum-mode-qt-fasttransformation-const-17">QImage </a></li>
<li><a href="#static-qtransform-qtransform-html-qimage-truematrix-const-qtransform-qtransform-html-matrix-int-width-int-height"><code>[static] </code></a><a href="qtransform.html">QTransform </a>QImage:: trueMatrix (const <a href="qtransform.html">QTransform </a>&amp; <em>matrix</em> , int <em>width</em> , int <em>height</em> )</li>
<li><a href="#bool-qimage-valid-const-qpoint-qpoint-html-pos-const">bool QImage:: valid (const </a><a href="qpoint.html">QPoint </a>&amp; <em>pos</em> ) const</li>
<li><a href="#bool-qimage-valid-int-x-int-y-const">bool QImage:: valid ( int <em>x</em> , int <em>y</em> ) const</a></li>
<li><a href="#int-qimage-width-const">int QImage:: width () const</a></li>
<li><a href="#qvariant-qvariant-html-qimage-operator-qvariant-const">QVariant </a></li>
<li><a href="#bool-qimage-operator-const-qimage-qimage-image-const">bool QImage:: operator!= (const </a><a href="#QImage">QImage </a>&amp; <em>image</em> ) const</li>
<li><a href="#bool-qimage-operator-const-qimage-qimage-image-const">bool QImage:: operator== (const </a><a href="#QImage">QImage </a>&amp; <em>image</em> ) const</li>
</ul>
</li>
<li><a href="#xiang-guan-fei-cheng-yuan-1">相关非成员</a><ul>
<li><a href="#since-5-0-qimagecleanupfunction"><code>[since 5.0] </code>QImageCleanupFunction</a></li>
<li><a href="#qdatastream-operator-qdatastream-stream-const-qimage-qimage-image">QDataStream </a></li>
<li><a href="#qdatastream-operator-qdatastream-stream-qimage-qimage-image-1">QDataStream </a></li>
</ul>
</li>
</ul>
</li>
</ul>
<!-- tocstop -->

</div>
# QImage 类

<p>QImage 类提供独立于硬件的图像表示 (允许直接访问像素数据，且可以用作描绘设备)。 <a href="#%E8%AF%A6%E7%BB%86%E6%8F%8F%E8%BF%B0">更多…</a></p>
<table>
<thead>
<tr>
<th>Header:</th>
<th>#include <qimage></qimage></th>
</tr>
</thead>
<tbody><tr>
<td>CMake:</td>
<td>find_package(Qt6 COMPONENTS Gui REQUIRED) target_link_libraries(mytarget PRIVATE Qt6::Gui)</td>
</tr>
<tr>
<td>qmake:</td>
<td>QT += gui</td>
</tr>
<tr>
<td>继承：</td>
<td><a href="qpaintdevice.html">QPaintDevice</a></td>
</tr>
</tbody></table>
<ul>
<li><a href="qimage-members.html">所有成员列表，包括继承成员</a></li>
</ul>
<p><strong>注意：</strong> 此类的所有函数 <a href="threads-reentrancy.html">可重入 </a>.</p>
<h2><span id="gong-gong-lei-xing">公共类型</span><a href="#gong-gong-lei-xing" class="header-anchor">#</a></h2><table>
<thead>
<tr>
<th>enum</th>
<th><strong><a href="#Format-enum">格式 </a></strong>{ Format_Invalid, Format_Mono, Format_MonoLSB, Format_Indexed8, Format_RGB32, …, Format_RGBA32FPx4_Premultiplied }</th>
</tr>
</thead>
<tbody><tr>
<td>enum</td>
<td><strong><a href="#InvertMode-enum">InvertMode </a></strong>{ InvertRgb, InvertRgba }</td>
</tr>
</tbody></table>
<h2><span id="gong-gong-han-shu">公共函数</span><a href="#gong-gong-han-shu" class="header-anchor">#</a></h2><table>
<thead>
<tr>
<th></th>
<th><strong><a href="#QImage-10">QImage </a></strong>(QImage &amp;&amp; <em>other</em> )</th>
</tr>
</thead>
<tbody><tr>
<td></td>
<td><strong><a href="#QImage-9">QImage </a></strong>(const QImage &amp; <em>image</em> )</td>
</tr>
<tr>
<td></td>
<td><strong><a href="#QImage-8">QImage </a></strong>(const QString &amp; <em>fileName</em> , const char * <em>format</em> = nullptr)</td>
</tr>
<tr>
<td></td>
<td><strong><a href="#QImage-7">QImage </a></strong>(const char *const [] <em>xpm</em> )</td>
</tr>
<tr>
<td></td>
<td><strong><a href="#QImage-6">QImage </a></strong>(const uchar * <em>data</em> , int <em>width</em> , int <em>height</em> , qsizetype <em>bytesPerLine</em> , QImage::Format <em>format</em> , QImageCleanupFunction <em>cleanupFunction</em> = nullptr, void * <em>cleanupInfo</em> = nullptr)</td>
</tr>
<tr>
<td></td>
<td><strong><a href="#QImage-5">QImage </a></strong>(uchar * <em>data</em> , int <em>width</em> , int <em>height</em> , qsizetype <em>bytesPerLine</em> , QImage::Format <em>format</em> , QImageCleanupFunction <em>cleanupFunction</em> = nullptr, void * <em>cleanupInfo</em> = nullptr)</td>
</tr>
<tr>
<td></td>
<td><strong><a href="#QImage-4">QImage </a></strong>(const uchar * <em>data</em> , int <em>width</em> , int <em>height</em> , QImage::Format <em>format</em> , QImageCleanupFunction <em>cleanupFunction</em> = nullptr, void * <em>cleanupInfo</em> = nullptr)</td>
</tr>
<tr>
<td></td>
<td><strong><a href="#QImage-3">QImage </a></strong>(uchar * <em>data</em> , int <em>width</em> , int <em>height</em> , QImage::Format <em>format</em> , QImageCleanupFunction <em>cleanupFunction</em> = nullptr, void * <em>cleanupInfo</em> = nullptr)</td>
</tr>
<tr>
<td></td>
<td><strong><a href="#QImage-2">QImage </a></strong>(int <em>width</em> , int <em>height</em> , QImage::Format <em>format</em> )</td>
</tr>
<tr>
<td></td>
<td><strong><a href="#QImage-1">QImage </a></strong>(const QSize &amp; <em>size</em> , QImage::Format <em>format</em> )</td>
</tr>
<tr>
<td></td>
<td><strong><a href="#QImage">QImage </a></strong>()</td>
</tr>
<tr>
<td>QImage &amp;</td>
<td><strong><a href="#operator-eq-1">operator= </a></strong>(QImage &amp;&amp; <em>other</em> )</td>
</tr>
<tr>
<td>QImage &amp;</td>
<td><strong><a href="#operator-eq">operator= </a></strong>(const QImage &amp; <em>image</em> )</td>
</tr>
<tr>
<td>virtual</td>
<td><strong><a href="#dtor.QImage">~QImage </a></strong>()</td>
</tr>
<tr>
<td>bool</td>
<td><strong><a href="#allGray">allGray </a></strong>() const</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="#applyColorTransform">applyColorTransform </a></strong>(const QColorTransform &amp; <em>transform</em> )</td>
</tr>
<tr>
<td>int</td>
<td><strong><a href="#bitPlaneCount">bitPlaneCount </a></strong>() const</td>
</tr>
<tr>
<td>uchar *</td>
<td><strong><a href="#bits">bits </a></strong>()</td>
</tr>
<tr>
<td>const uchar *</td>
<td><strong><a href="#bits-1">bits </a></strong>() const</td>
</tr>
<tr>
<td>qsizetype</td>
<td><strong><a href="#bytesPerLine">bytesPerLine </a></strong>() const</td>
</tr>
<tr>
<td>qint64</td>
<td><strong><a href="#cacheKey">cacheKey </a></strong>() const</td>
</tr>
<tr>
<td>QRgb</td>
<td><strong><a href="#color">color </a></strong>(int <em>i</em> ) const</td>
</tr>
<tr>
<td>int</td>
<td><strong><a href="#colorCount">colorCount </a></strong>() const</td>
</tr>
<tr>
<td>QColorSpace</td>
<td><strong><a href="#colorSpace">colorSpace </a></strong>() const</td>
</tr>
<tr>
<td>QList<qrgb></qrgb></td>
<td><strong><a href="#colorTable">colorTable </a></strong>() const</td>
</tr>
<tr>
<td>const uchar *</td>
<td><strong><a href="#constBits">constBits </a></strong>() const</td>
</tr>
<tr>
<td>const uchar *</td>
<td><strong><a href="#constScanLine">constScanLine </a></strong>(int <em>i</em> ) const</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="#convertTo">convertTo </a></strong>(QImage::Format <em>format</em> , Qt::ImageConversionFlags <em>flags</em> = Qt::AutoColor)</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="#convertToColorSpace">convertToColorSpace </a></strong>(const QColorSpace &amp; <em>colorSpace</em> )</td>
</tr>
<tr>
<td>QImage</td>
<td><strong><a href="#convertToFormat">convertToFormat </a></strong>(QImage::Format <em>format</em> , Qt::ImageConversionFlags <em>flags</em> = Qt::AutoColor) const &amp;</td>
</tr>
<tr>
<td>QImage</td>
<td><strong><a href="#convertToFormat-1">convertToFormat </a></strong>(QImage::Format <em>format</em> , Qt::ImageConversionFlags <em>flags</em> = Qt::AutoColor) &amp;&amp;</td>
</tr>
<tr>
<td>QImage</td>
<td><strong><a href="#convertToFormat-2">convertToFormat </a></strong>(QImage::Format <em>format</em> , const QList<qrgb> &amp; <em>colorTable</em> , Qt::ImageConversionFlags <em>flags</em> = Qt::AutoColor) const</qrgb></td>
</tr>
<tr>
<td>QImage</td>
<td><strong><a href="#convertedTo">convertedTo </a></strong>(QImage::Format <em>format</em> , Qt::ImageConversionFlags <em>flags</em> = Qt::AutoColor) const &amp;</td>
</tr>
<tr>
<td>QImage</td>
<td><strong><a href="#convertedTo-1">convertedTo </a></strong>(QImage::Format <em>format</em> , Qt::ImageConversionFlags <em>flags</em> = Qt::AutoColor) &amp;&amp;</td>
</tr>
<tr>
<td>QImage</td>
<td><strong><a href="#convertedToColorSpace">convertedToColorSpace </a></strong>(const QColorSpace &amp; <em>colorSpace</em> ) const</td>
</tr>
<tr>
<td>QImage</td>
<td><strong><a href="#copy">copy </a></strong>(const QRect &amp; <em>rectangle</em> = QRect()) const</td>
</tr>
<tr>
<td>QImage</td>
<td><strong><a href="#copy-1">copy </a></strong>(int <em>x</em> , int <em>y</em> , int <em>width</em> , int <em>height</em> ) const</td>
</tr>
<tr>
<td>QImage</td>
<td><strong><a href="#createAlphaMask">createAlphaMask </a></strong>(Qt::ImageConversionFlags <em>flags</em> = Qt::AutoColor) const</td>
</tr>
<tr>
<td>QImage</td>
<td><strong><a href="#createHeuristicMask">createHeuristicMask </a></strong>(bool <em>clipTight</em> = true) const</td>
</tr>
<tr>
<td>QImage</td>
<td><strong><a href="#createMaskFromColor">createMaskFromColor </a></strong>(QRgb <em>color</em> , Qt::MaskMode <em>mode</em> = Qt::MaskInColor) const</td>
</tr>
<tr>
<td>int</td>
<td><strong><a href="#depth">depth </a></strong>() const</td>
</tr>
<tr>
<td>QSizeF</td>
<td><strong><a href="#deviceIndependentSize">deviceIndependentSize </a></strong>() const</td>
</tr>
<tr>
<td>qreal</td>
<td><strong><a href="#devicePixelRatio">devicePixelRatio </a></strong>() const</td>
</tr>
<tr>
<td>int</td>
<td><strong><a href="#dotsPerMeterX">dotsPerMeterX </a></strong>() const</td>
</tr>
<tr>
<td>int</td>
<td><strong><a href="#dotsPerMeterY">dotsPerMeterY </a></strong>() const</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="#fill">fill </a></strong>(uint <em>pixelValue</em> )</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="#fill-1">fill </a></strong>(const QColor &amp; <em>color</em> )</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="#fill-2">fill </a></strong>(Qt::GlobalColor <em>color</em> )</td>
</tr>
<tr>
<td>QImage::Format</td>
<td><strong><a href="#format">format </a></strong>() const</td>
</tr>
<tr>
<td>bool</td>
<td><strong><a href="#hasAlphaChannel">hasAlphaChannel </a></strong>() const</td>
</tr>
<tr>
<td>int</td>
<td><strong><a href="#height">height </a></strong>() const</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="#invertPixels">invertPixels </a></strong>(QImage::InvertMode <em>mode</em> = InvertRgb)</td>
</tr>
<tr>
<td>bool</td>
<td><strong><a href="#isGrayscale">isGrayscale </a></strong>() const</td>
</tr>
<tr>
<td>bool</td>
<td><strong><a href="#isNull">isNull </a></strong>() const</td>
</tr>
<tr>
<td>bool</td>
<td><strong><a href="#load">load </a></strong>(const QString &amp; <em>fileName</em> , const char * <em>format</em> = nullptr)</td>
</tr>
<tr>
<td>bool</td>
<td><strong><a href="#load-1">load </a></strong>(QIODevice * <em>device</em> , const char * <em>format</em> )</td>
</tr>
<tr>
<td>bool</td>
<td><strong><a href="#loadFromData">loadFromData </a></strong>(QByteArrayView <em>data</em> , const char * <em>format</em> = nullptr)</td>
</tr>
<tr>
<td>bool</td>
<td><strong><a href="#loadFromData-1">loadFromData </a></strong>(const uchar * <em>data</em> , int <em>len</em> , const char * <em>format</em> = nullptr)</td>
</tr>
<tr>
<td>bool</td>
<td><strong><a href="#loadFromData-2">loadFromData </a></strong>(const QByteArray &amp; <em>data</em> , const char * <em>format</em> = nullptr)</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="#mirror">mirror </a></strong>(bool <em>horizontal</em> = false, bool <em>vertical</em> = true)</td>
</tr>
<tr>
<td>QImage</td>
<td><strong><a href="#mirrored">mirrored </a></strong>(bool <em>horizontal</em> = false, bool <em>vertical</em> = true) const &amp;</td>
</tr>
<tr>
<td>QImage</td>
<td><strong><a href="#mirrored-1">mirrored </a></strong>(bool <em>horizontal</em> = false, bool <em>vertical</em> = true) &amp;&amp;</td>
</tr>
<tr>
<td>QPoint</td>
<td><strong><a href="#offset">offset </a></strong>() const</td>
</tr>
<tr>
<td>QRgb</td>
<td><strong><a href="#pixel">pixel </a></strong>(const QPoint &amp; <em>position</em> ) const</td>
</tr>
<tr>
<td>QRgb</td>
<td><strong><a href="#pixel-1">pixel </a></strong>(int <em>x</em> , int <em>y</em> ) const</td>
</tr>
<tr>
<td>QColor</td>
<td><strong><a href="#pixelColor">pixelColor </a></strong>(const QPoint &amp; <em>position</em> ) const</td>
</tr>
<tr>
<td>QColor</td>
<td><strong><a href="#pixelColor-1">pixelColor </a></strong>(int <em>x</em> , int <em>y</em> ) const</td>
</tr>
<tr>
<td>QPixelFormat</td>
<td><strong><a href="#pixelFormat">pixelFormat </a></strong>() const</td>
</tr>
<tr>
<td>int</td>
<td><strong><a href="#pixelIndex">pixelIndex </a></strong>(const QPoint &amp; <em>position</em> ) const</td>
</tr>
<tr>
<td>int</td>
<td><strong><a href="#pixelIndex-1">pixelIndex </a></strong>(int <em>x</em> , int <em>y</em> ) const</td>
</tr>
<tr>
<td>QRect</td>
<td><strong><a href="#rect">rect </a></strong>() const</td>
</tr>
<tr>
<td>bool</td>
<td><strong><a href="#reinterpretAsFormat">reinterpretAsFormat </a></strong>(QImage::Format <em>format</em> )</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="#rgbSwap">rgbSwap </a></strong>()</td>
</tr>
<tr>
<td>QImage</td>
<td><strong><a href="#rgbSwapped">rgbSwapped </a></strong>() const &amp;</td>
</tr>
<tr>
<td>QImage</td>
<td><strong><a href="#rgbSwapped-1">rgbSwapped </a></strong>() &amp;&amp;</td>
</tr>
<tr>
<td>bool</td>
<td><strong><a href="#save">save </a></strong>(const QString &amp; <em>fileName</em> , const char * <em>format</em> = nullptr, int <em>quality</em> = -1) const</td>
</tr>
<tr>
<td>bool</td>
<td><strong><a href="#save-1">save </a></strong>(QIODevice * <em>device</em> , const char * <em>format</em> = nullptr, int <em>quality</em> = -1) const</td>
</tr>
<tr>
<td>QImage</td>
<td><strong><a href="#scaled">scaled </a></strong>(const QSize &amp; <em>size</em> , Qt::AspectRatioMode <em>aspectRatioMode</em> = Qt::IgnoreAspectRatio, Qt::TransformationMode <em>transformMode</em> = Qt::FastTransformation) const</td>
</tr>
<tr>
<td>QImage</td>
<td><strong><a href="#scaled-1">scaled </a></strong>(int <em>width</em> , int <em>height</em> , Qt::AspectRatioMode <em>aspectRatioMode</em> = Qt::IgnoreAspectRatio, Qt::TransformationMode <em>transformMode</em> = Qt::FastTransformation) const</td>
</tr>
<tr>
<td>QImage</td>
<td><strong><a href="#scaledToHeight">scaledToHeight </a></strong>(int <em>height</em> , Qt::TransformationMode <em>mode</em> = Qt::FastTransformation) const</td>
</tr>
<tr>
<td>QImage</td>
<td><strong><a href="#scaledToWidth">scaledToWidth </a></strong>(int <em>width</em> , Qt::TransformationMode <em>mode</em> = Qt::FastTransformation) const</td>
</tr>
<tr>
<td>uchar *</td>
<td><strong><a href="#scanLine">scanLine </a></strong>(int <em>i</em> )</td>
</tr>
<tr>
<td>const uchar *</td>
<td><strong><a href="#scanLine-1">scanLine </a></strong>(int <em>i</em> ) const</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="#setAlphaChannel">setAlphaChannel </a></strong>(const QImage &amp; <em>alphaChannel</em> )</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="#setColor">setColor </a></strong>(int <em>index</em> , QRgb <em>colorValue</em> )</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="#setColorCount">setColorCount </a></strong>(int <em>colorCount</em> )</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="#setColorSpace">setColorSpace </a></strong>(const QColorSpace &amp; <em>colorSpace</em> )</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="#setColorTable">setColorTable </a></strong>(const QList<qrgb> &amp; <em>colors</em> )</qrgb></td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="#setDevicePixelRatio">setDevicePixelRatio </a></strong>(qreal <em>scaleFactor</em> )</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="#setDotsPerMeterX">setDotsPerMeterX </a></strong>(int <em>x</em> )</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="#setDotsPerMeterY">setDotsPerMeterY </a></strong>(int <em>y</em> )</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="#setOffset">setOffset </a></strong>(const QPoint &amp; <em>offset</em> )</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="#setPixel">setPixel </a></strong>(const QPoint &amp; <em>position</em> , uint <em>index_or_rgb</em> )</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="#setPixel-1">setPixel </a></strong>(int <em>x</em> , int <em>y</em> , uint <em>index_or_rgb</em> )</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="#setPixelColor">setPixelColor </a></strong>(const QPoint &amp; <em>position</em> , const QColor &amp; <em>color</em> )</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="#setPixelColor-1">setPixelColor </a></strong>(int <em>x</em> , int <em>y</em> , const QColor &amp; <em>color</em> )</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="#setText">setText </a></strong>(const QString &amp; <em>key</em> , const QString &amp; <em>text</em> )</td>
</tr>
<tr>
<td>QSize</td>
<td><strong><a href="#size">size </a></strong>() const</td>
</tr>
<tr>
<td>qsizetype</td>
<td><strong><a href="#sizeInBytes">sizeInBytes </a></strong>() const</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="#swap">swap </a></strong>(QImage &amp; <em>other</em> )</td>
</tr>
<tr>
<td>QString</td>
<td><strong><a href="#text">text </a></strong>(const QString &amp; <em>key</em> = QString()) const</td>
</tr>
<tr>
<td>QStringList</td>
<td><strong><a href="#textKeys">textKeys </a></strong>() const</td>
</tr>
<tr>
<td>CGImageRef</td>
<td><strong><a href="#toCGImage">toCGImage </a></strong>() const</td>
</tr>
<tr>
<td>HBITMAP</td>
<td><strong><a href="#toHBITMAP">toHBITMAP </a></strong>() const</td>
</tr>
<tr>
<td>HICON</td>
<td><strong><a href="#toHICON">toHICON </a></strong>(const QImage &amp; <em>mask</em> = {}) const</td>
</tr>
<tr>
<td>QImage</td>
<td><strong><a href="#transformed">transformed </a></strong>(const QTransform &amp; <em>matrix</em> , Qt::TransformationMode <em>mode</em> = Qt::FastTransformation) const</td>
</tr>
<tr>
<td>bool</td>
<td><strong><a href="#valid">valid </a></strong>(const QPoint &amp; <em>pos</em> ) const</td>
</tr>
<tr>
<td>bool</td>
<td><strong><a href="#valid-1">valid </a></strong>(int <em>x</em> , int <em>y</em> ) const</td>
</tr>
<tr>
<td>int</td>
<td><strong><a href="#width">width </a></strong>() const</td>
</tr>
<tr>
<td>QVariant</td>
<td><strong><a href="#operator-QVariant">operator QVariant </a></strong>() const</td>
</tr>
<tr>
<td>bool</td>
<td><strong><a href="#operator-not-eq">operator!= </a></strong>(const QImage &amp; <em>image</em> ) const</td>
</tr>
<tr>
<td>bool</td>
<td><strong><a href="#operator-eq-eq">operator== </a></strong>(const QImage &amp; <em>image</em> ) const</td>
</tr>
</tbody></table>
<h2><span id="jing-tai-gong-gong-cheng-yuan">静态公共成员</span><a href="#jing-tai-gong-gong-cheng-yuan" class="header-anchor">#</a></h2><table>
<thead>
<tr>
<th>QImage</th>
<th><strong><a href="#fromData">fromData </a></strong>(QByteArrayView <em>data</em> , const char * <em>format</em> = nullptr)</th>
</tr>
</thead>
<tbody><tr>
<td>QImage</td>
<td><strong><a href="#fromData-1">fromData </a></strong>(const uchar * <em>data</em> , int <em>size</em> , const char * <em>format</em> = nullptr)</td>
</tr>
<tr>
<td>QImage</td>
<td><strong><a href="#fromData-2">fromData </a></strong>(const QByteArray &amp; <em>data</em> , const char * <em>format</em> = nullptr)</td>
</tr>
<tr>
<td>QImage</td>
<td><strong><a href="#fromHBITMAP">fromHBITMAP </a></strong>(HBITMAP <em>hbitmap</em> )</td>
</tr>
<tr>
<td>QImage</td>
<td><strong><a href="#fromHICON">fromHICON </a></strong>(HICON <em>icon</em> )</td>
</tr>
<tr>
<td>QImage::Format</td>
<td><strong><a href="#toImageFormat">toImageFormat </a></strong>(QPixelFormat <em>format</em> )</td>
</tr>
<tr>
<td>QPixelFormat</td>
<td><strong><a href="#toPixelFormat">toPixelFormat </a></strong>(QImage::Format <em>format</em> )</td>
</tr>
<tr>
<td>QTransform</td>
<td><strong><a href="#trueMatrix">trueMatrix </a></strong>(const QTransform &amp; <em>matrix</em> , int <em>width</em> , int <em>height</em> )</td>
</tr>
</tbody></table>
<h2><span id="xiang-guan-fei-cheng-yuan">相关非成员</span><a href="#xiang-guan-fei-cheng-yuan" class="header-anchor">#</a></h2><table>
<thead>
<tr>
<th></th>
<th><strong><a href="#QImageCleanupFunction-typedef">QImageCleanupFunction</a></strong></th>
</tr>
</thead>
<tbody><tr>
<td>QDataStream &amp;</td>
<td><strong><a href="#operator-lt-lt">operator&lt;&lt; </a></strong>(QDataStream &amp; <em>stream</em> , const QImage &amp; <em>image</em> )</td>
</tr>
<tr>
<td>QDataStream &amp;</td>
<td><strong><a href="#operator-gt-gt">operator&gt;&gt; </a></strong>(QDataStream &amp; <em>stream</em> , QImage &amp; <em>image</em> )</td>
</tr>
</tbody></table>
<h2><span id="xiang-xi-miao-shu">详细描述</span><a href="#xiang-xi-miao-shu" class="header-anchor">#</a></h2><p>Qt 为处理图像数据提供了 4 个类：QImage、 <a href="qpixmap.html">QPixmap </a>, <a href="qbitmap.html">QBitmap </a>and <a href="qpicture.html">QPicture </a>。QImage 是为 I/O 和直接像素访问 操纵而设计 优化的，而 <a href="qpixmap.html">QPixmap </a>为在屏幕上展示图像而设计 优化的。 <a href="qbitmap.html">QBitmap </a>只是方便类，继承 <a href="qpixmap.html">QPixmap </a>，确保 1 深度。最后， <a href="qpicture.html">QPicture </a>类是描绘设备，它记录并重演 <a href="qpainter.html">QPainter </a>命令。</p>
<p>由于 QImage 是 <a href="qpaintdevice.html">QPaintDevice </a>子类， <a href="qpainter.html">QPainter </a>可用于在图像上直接绘制。当使用 <a href="qpainter.html">QPainter </a>在 QImage，描绘可以在当前 GUI 线程外的其它线程中履行。</p>
<p>QImage 类支持几种图像格式，描述通过 <a href="#Format-enum">格式 </a>枚举。这些包括单色、8 位、32 位且 Alpha 融合图像 (可用于所有 Qt 4.x 版本)。</p>
<p>QImage 提供一批函数，可用于获取有关图像的各种信息。还有几个函数使图像能够变换。</p>
<p>QImage 对象可以按值传递，由于 QImage 类使用 <a href="implicit-sharing.html">隐式数据共享 </a>。QImage 对象还可以被流化和比较。</p>
<p><strong>注意：</strong> 若愿意以静态 Qt 构建加载 QImage 对象，参考 <a href="plugins-howto.html">插件怎么样 </a>.</p>
<p><strong>警告：</strong> 在 QImage 上描绘采用格式 <a href="#Format-enum">QImage::Format_Indexed8 </a>不被支持。</p>
<h3><span id="du-xie-tu-xiang-wen-jian">读写图像文件</span><a href="#du-xie-tu-xiang-wen-jian" class="header-anchor">#</a></h3><p>QImage 提供加载图像文件的几种方式：可以在构造 QImage 对象时加载文件，或通过使用 <a href="#load">load </a>() 或 <a href="#loadFromData">loadFromData </a>() 函数稍后。QImage 还提供静态 <a href="#fromData">fromData </a>() 函数，从给定数据构造 QImage。当加载图像时，文件名可以引用实际磁盘文件，也可以引用某一应用程序嵌入资源。见 <a href="resources.html">Qt 资源系统 </a>概述，了解如何在应用程序可执行文件中嵌入图像及其它资源文件的细节。</p>
<p>只需调用 <a href="#save">save </a>() 函数以保存 QImage 对象。</p>
<p>可获得支持的文件格式的完整列表，透过 <a href="qimagereader.html#supportedImageFormats">QImageReader::supportedImageFormats </a>() 和 <a href="#supportedImageFormats">QImageWriter::supportedImageFormats </a>() 函数。可以将新文件格式添加作为插件。默认情况下，Qt 支持以下格式：</p>
<table>
<thead>
<tr>
<th align="left">格式</th>
<th align="left">描述</th>
<th align="left">Qt 支持</th>
</tr>
</thead>
<tbody><tr>
<td align="left">BMP</td>
<td align="left">Windows 位图</td>
<td align="left">读/写</td>
</tr>
<tr>
<td align="left">GIF</td>
<td align="left">GIF (图形互换格式) 可选</td>
<td align="left">读取</td>
</tr>
<tr>
<td align="left">JPG</td>
<td align="left">JPEG (联合摄影专家组)</td>
<td align="left">读/写</td>
</tr>
<tr>
<td align="left">JPEG</td>
<td align="left">JPEG (联合摄影专家组)</td>
<td align="left">读/写</td>
</tr>
<tr>
<td align="left">PNG</td>
<td align="left">PNG (便携式网络图形)</td>
<td align="left">读/写</td>
</tr>
<tr>
<td align="left">PBM</td>
<td align="left">PBM (便携式位图)</td>
<td align="left">读取</td>
</tr>
<tr>
<td align="left">PGM</td>
<td align="left">PGM (便携式灰度图)</td>
<td align="left">读取</td>
</tr>
<tr>
<td align="left">PPM</td>
<td align="left">Portable Pixmap (便携式像素图)</td>
<td align="left">读/写</td>
</tr>
<tr>
<td align="left">XBM</td>
<td align="left">X11 Bitmap (X11 位图)</td>
<td align="left">读/写</td>
</tr>
<tr>
<td align="left">XPM</td>
<td align="left">X11 Pixmap (X11 像素图)</td>
<td align="left">读/写</td>
</tr>
</tbody></table>
<h3><span id="tu-xiang-xin-xi">图像信息</span><a href="#tu-xiang-xin-xi" class="header-anchor">#</a></h3><p>QImage 提供可用于获取有关图像各种信息的函数集合：</p>
<table>
<thead>
<tr>
<th align="left"></th>
<th align="left">可用函数</th>
</tr>
</thead>
<tbody><tr>
<td align="left">几何体</td>
<td align="left"><a href="#size">size</a>(), <a href="#width">width</a>(), <a href="#height">height</a>(), <a href="#dotsPerMeterX">dotsPerMeterX </a>()，和 <a href="#dotsPerMeterY">dotsPerMeterY </a>() 函数提供图像大小和宽高比的有关信息。<a href="#rect">rect </a>() 函数返回图像的封闭矩形。 <a href="#valid">valid </a>() 函数告诉给定坐标对是否在此矩形内。 <a href="#offset">offset</a>() 函数返回图像相对于其他图像定位时要偏移的像素数。这也可以用<a href="#setOffset">setOffset</a>()函数来操作。</td>
</tr>
<tr>
<td align="left">颜色</td>
<td align="left">像素的颜色可以通过将其坐标传递给<a href="#pixel">pixel</a>()函数来检索。 <a href="#pixel">pixel</a>()函数将颜色作为一个<a href="#QRgb-typedef">QRgb</a>值返回，与图像的格式无关。 如果是单色和8位图像，<a href="#colorCount">colorCount </a>()和<a href="#colorTable">colorTable </a>()函数提供关于用于存储图像数据的颜色组件的信息。<a href="#colorTable">colorTable </a>()函数返回图像的整个颜色表。要获得单个条目，使用<a href="#pixelIndex">pixelIndex</a>()函数来检索给定的一对坐标的像素索引，然后使用<a href="#color">color</a>()函数来检索颜色。注意，如果你手动创建一个8位图像，你必须在图像上设置一个有效的色表。<a href="#hasAlphaChannel">hasAlphaChannel</a>()函数告诉你，图像的格式是否尊重alpha通道。<a href="#allGray">allGray </a>() 和 <a href="#isGrayscale">isGrayscale </a>() 函数告诉你图像的颜色是否都是灰色的。</td>
</tr>
<tr>
<td align="left">文本</td>
<td align="left"><a href="#text">text </a>()函数返回与给定文本键相关的图像文本。可以使用<a href="#textKeys">textKeys</a>()函数检索图像的文本键。使用<a href="#setText">setText</a>()函数来改变一个图像的文本。</td>
</tr>
<tr>
<td align="left">低级信息</td>
<td align="left"><a href="#depth">depth</a>()函数返回图像的深度。支持的深度是1（单色）、8、16、24和32比特。<a href="#bitPlaneCount">bitPlaneCount </a>()函数告诉你这些位中有多少被使用。更多信息见<a href="#image-formats">图像格式</a>章节。<a href="#format">format</a>()，<a href="#bytesPerLine">bytePerLine</a>()，和<a href="#sizeInBytes">sizeInBytes</a>()函数提供关于存储在图像中的数据的低层次信息。 <a href="#cacheKey">cacheKey</a>() 函数返回此QImage对象内容的唯一标识数。</td>
</tr>
</tbody></table>
<h3><span id="xiang-su-cao-zong">像素操纵</span><a href="#xiang-su-cao-zong" class="header-anchor">#</a></h3><p>用来处理图像像素的函数取决于图像格式。原因是单色和8位图像是基于索引的，并使用颜色查找表，而32位图像直接存储ARGB值。关于图像格式的更多信息，请参阅 <a href="#%E5%9B%BE%E5%83%8F%E6%A0%BC%E5%BC%8F">图像格式</a>章节。</p>
<p>如果是32位图像，<a href="#setPixel">setPixel</a>()函数可以用来改变给定坐标上的像素的颜色，使其成为任何其他指定为ARGB四色的颜色。要制作一个合适的<a href="#QRgb-typedef">QRgb</a>值，请使用<a href="#qRgb">qRgb</a>()(在给定的RGB值中添加一个默认的alpha成分，即创建一个不透明的颜色)或<a href="#qRgba">qRgba</a>()函数。</p>
<p>例如：</p>
<table>
<thead>
<tr>
<th align="center">32-bit</th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td align="center"><img src="https://doc.qt.io/qt-6/images/qimage-32bit_scaled.png" srcset="/img/loading.gif" lazyload alt="img"></td>
<td><code>QImage image(3, 3, QImage::Format_RGB32); QRgb value; value = qRgb(189, 149, 39); // 0xffbd9527 image.setPixel(1, 1, value); value = qRgb(122, 163, 39); // 0xff7aa327 image.setPixel(0, 1, value); image.setPixel(1, 0, value); value = qRgb(237, 187, 51); // 0xffedba31 image.setPixel(2, 1, value);</code></td>
</tr>
</tbody></table>
<p>对于8位和单色图像来说，像素值只是图像颜色表的一个索引。因此，<a href="#setPixel">setPixel</a>()函数只能用来改变给定坐标上的像素的颜色，使其成为图像色表中预定义的颜色，也就是说，它只能改变像素的索引价值。要改变或添加一种颜色到图像的色表中，请使用<a href="#setColor">setColor</a>()函数。</p>
<p>色表中的一个条目是一个ARGB四元组，被编码为<a href="#QRgb-typedef">QRgb</a>值。 使用 <a href="#qRgb">qRgb </a>() 和 <a href="#qRgba">qRgba </a>() 函数来制作一个合适的 <a href="#QRgb-typedef">QRgb </a> 值，用于 <a href="#setColor">setColor </a>() 函数。例如：</p>
<table>
<thead>
<tr>
<th align="left">8 位</th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td align="left"><img src="https://doc.qt.io/qt-6/images/qimage-8bit_scaled.png" srcset="/img/loading.gif" lazyload alt="img"></td>
<td><code>QImage image(3, 3, QImage::Format_Indexed8); QRgb value; value = qRgb(122, 163, 39); // 0xff7aa327 image.setColor(0, value); value = qRgb(237, 187, 51); // 0xffedba31 image.setColor(1, value); value = qRgb(189, 149, 39); // 0xffbd9527 image.setColor(2, value); image.setPixel(0, 1, 0); image.setPixel(1, 0, 0); image.setPixel(1, 1, 2); image.setPixel(2, 1, 1);                                     </code></td>
</tr>
</tbody></table>
<p>对于每个颜色通道超过8位的图像。方法<a href="#setPixelColor">setPixelColor</a>()和<a href="#pixelColor">pixelColor</a>()可以用来设置和获取<a href>QColor</a>值。</p>
<p>QImage还提供了<a href="#scanLine">scanLine</a>()函数，它返回一个指向给定索引的扫描线上的像素数据的指针，以及<a href="#bits">bits</a>()函数，它返回一个指向第一个像素数据的指针（这相当于<code>scanLine(0) </code>）。</p>
<h3><span id="tu-xiang-ge-shi">图像格式</span><a href="#tu-xiang-ge-shi" class="header-anchor">#</a></h3><p>存储在QImage中的每个像素都由一个整数表示。整数的大小根据格式的不同而不同。QImage支持由<a href="#Format-enum">格式</a>枚举描述的几种图像格式。</p>
<p>单色图像使用1位索引存储在一个最多两种颜色的色表中。有两种不同类型的单色图像：big endian（MSB优先）或little endian（LSB优先）位顺序。</p>
<p>8位图像使用8位索引存储到色表中，也就是说，它们每个像素有一个字节。色表是一个<a href="qlist.html">QList</a>&lt; <a href="#QRgb-typedef">QRgb</a>&gt;，而<a href="#QRgb-typedef">QRgb</a>的类型定义相当于一个无符号int，包含一个格式为0xAARRGGBB的ARGB四元组。</p>
<p>32位图像没有色表；相反，每个像素包含一个<a href="#QRgb-typedef">QRgb </a>值。有三种不同类型的32位图像分别存储RGB（即0xffRRGGBB）、ARGB和预乘的ARGB值。在预乘格式中，红色、绿色和蓝色通道都是乘以除以255的α成分。</p>
<p>一个图像的格式可以用<a href="#format">format</a>()函数来检索。使用<a href="#convertToFormat">convertToFormat</a>()函数将图像转换成其他格式。<a href="#allGray">allGray </a>()和<a href="#isGrayscale">isGrayscale </a>()函数告诉人们，彩色图像是否可以安全地转换为灰度图像。</p>
<h3><span id="tu-xiang-bian-huan">图像变换</span><a href="#tu-xiang-bian-huan" class="header-anchor">#</a></h3><p>QImage支持一些函数来创建一个新的图像，它是原始图像的转换版本。createAlphaMask](#createAlphaMask)()函数从这个图像的alpha缓冲区建立并返回一个1-bpp的掩码，<a href="#createHeuristicMask">createHeuristicMask</a>()函数为这个图像建立并返回一个1-bpp的启发式掩码。后一个函数的工作原理是从其中一个角上选择一种颜色，然后从所有的边缘开始削去该颜色的像素。</p>
<p><a href="#mirrored">mirrored</a>() 函数返回期望方向的图像镜像，<a href="#scaled">scaled</a>() 返回图像的一个副本，该副本被缩放为一个期望尺寸的矩形，<a href="#rgbSwapped">rgbSwapped</a>() 函数从一个RGB图像构建一个BGR图像。</p>
<p><a href="#scaledToWidth">scaledToWidth</a>()和<a href="#scaledToHeight">scaledToHeight</a>()函数返回图像的按比例复制。</p>
<p><a href="#transformed">transformed</a>()函数返回一个用给定的变换矩阵和变换模式进行变换的图像副本。在内部，变换矩阵被调整以补偿不需要的平移，即<a href="#transformed">transformed</a>()返回包含原图像的所有变换点的最小图像。静态的<a href="#trueMatrix">trueMatrix</a>()函数返回用于转换图像的实际矩阵。</p>
<p>还有一些函数用于就地改变图像的属性:</p>
<table>
<thead>
<tr>
<th align="left">Function</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><a href="#setDotsPerMeterX">setDotsPerMeterX </a>()</td>
<td align="left">通过设置水平方向上适合物理仪表的像素数量来定义长宽比。</td>
</tr>
<tr>
<td align="left"><a href="#setDotsPerMeterY">setDotsPerMeterY </a>()</td>
<td align="left">通过设置垂直方向上适合物理仪表的像素数量来定义长宽比。</td>
</tr>
<tr>
<td align="left"><a href="#fill">fill </a>()</td>
<td align="left">用给定的像素值填充整个图像。</td>
</tr>
<tr>
<td align="left"><a href="#invertPixels">invertPixels </a>()</td>
<td align="left">使用给定的<a href="#InvertMode-enum">InvertMode</a>值反转图像中的所有像素值。</td>
</tr>
<tr>
<td align="left"><a href="#setColorTable">setColorTable </a>()</td>
<td align="left">设置用于转换颜色索引的色表。只有单色和8位格式。</td>
</tr>
<tr>
<td align="left"><a href="#setColorCount">setColorCount </a>()</td>
<td align="left">调整颜色表的大小。只有单色和8位格式。</td>
</tr>
</tbody></table>
<p><strong>另请参阅</strong> <a href="qimagereader.html">QImageReader </a>, <a href>QImageWriter </a>, <a href="qpixmap.html">QPixmap </a>, <a href="qsvgrenderer.html">QSvgRenderer </a>, <a href="qtwidgets-painting-imagecomposition-example.html">图像合成范例 </a>, <a href="qtwidgets-widgets-imageviewer-example.html">图像查看器范例 </a>, <a href="qtwidgets-widgets-scribble-example.html">涂鸦范例 </a>，和 <a href="qtwidgets-itemviews-pixelator-example.html">像素器范例 </a>.</p>
<h2><span id="cheng-yuan-lei-xing-wen-dang">成员类型文档</span><a href="#cheng-yuan-lei-xing-wen-dang" class="header-anchor">#</a></h2><h3><span id="enum-qimage-ge-shi">enum QImage:: 格式</span><a href="#enum-qimage-ge-shi" class="header-anchor">#</a></h3><p>以下图像格式可用于 Qt。见表格后注意事项。</p>
<table>
<thead>
<tr>
<th align="left">常量</th>
<th align="left">值</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>QImage::Format_Invalid</code></td>
<td align="left"><code>0</code></td>
<td align="left">图像无效。</td>
</tr>
<tr>
<td align="left"><code>QImage::Format_Mono</code></td>
<td align="left"><code>1</code></td>
<td align="left">图像是用每个像素1位来存储的。字节是以最有意义的位（MSB）为先打包的。</td>
</tr>
<tr>
<td align="left"><code>QImage::Format_MonoLSB</code></td>
<td align="left"><code>2</code></td>
<td align="left">图像是用每个像素1位来存储的。字节以较小的有效位（LSB）为先进行打包。</td>
</tr>
<tr>
<td align="left"><code>QImage::Format_Indexed8</code></td>
<td align="left"><code>3</code></td>
<td align="left">图像使用 8 位索引存储成颜色映射。</td>
</tr>
<tr>
<td align="left"><code>QImage::Format_RGB32</code></td>
<td align="left"><code>4</code></td>
<td align="left">图像使用 32 位 RGB 格式 (0xffRRGGBB) 存储。</td>
</tr>
<tr>
<td align="left"><code>QImage::Format_ARGB32</code></td>
<td align="left"><code>5</code></td>
<td align="left">图像使用 32 位 ARGB 格式 (0xAARRGGBB) 存储。</td>
</tr>
<tr>
<td align="left"><code>QImage::Format_ARGB32_Premultiplied</code></td>
<td align="left"><code>6</code></td>
<td align="left">图像使用预乘的32位ARGB格式（0xAARRGGBB）进行存储，即红、绿、蓝通道乘以α成分除以255。(如果RR、GG或BB的值高于阿尔法通道，那么结果就无法定义)。某些操作（如使用阿尔法混合的图像合成）使用预乘的ARGB32比使用普通的ARGB32要快。</td>
</tr>
<tr>
<td align="left"><code>QImage::Format_RGB16</code></td>
<td align="left"><code>7</code></td>
<td align="left">图像使用 16 位 RGB 格式 (5-6-5) 存储。</td>
</tr>
<tr>
<td align="left"><code>QImage::Format_ARGB8565_Premultiplied</code></td>
<td align="left"><code>8</code></td>
<td align="left">该图像使用预乘的24位ARGB格式（8-5-6-5）进行存储。</td>
</tr>
<tr>
<td align="left"><code>QImage::Format_RGB666</code></td>
<td align="left"><code>9</code></td>
<td align="left">图像采用24位RGB格式（6-6-6）存储。未使用的最重要的位总是零。</td>
</tr>
<tr>
<td align="left"><code>QImage::Format_ARGB6666_Premultiplied</code></td>
<td align="left"><code>10</code></td>
<td align="left">该图像使用预乘的24位ARGB格式（6-6-6）进行存储。</td>
</tr>
<tr>
<td align="left"><code>QImage::Format_RGB555</code></td>
<td align="left"><code>11</code></td>
<td align="left">图像采用16位RGB格式（5-5-5）存储。未使用的最重要的位总是零。</td>
</tr>
<tr>
<td align="left"><code>QImage::Format_ARGB8555_Premultiplied</code></td>
<td align="left"><code>12</code></td>
<td align="left">该图像使用预乘的24位ARGB格式（8-5-5-5）进行存储。</td>
</tr>
<tr>
<td align="left"><code>QImage::Format_RGB888</code></td>
<td align="left"><code>13</code></td>
<td align="left">图像使用 24 位 RGB 格式 (8-8-8) 存储。</td>
</tr>
<tr>
<td align="left"><code>QImage::Format_RGB444</code></td>
<td align="left"><code>14</code></td>
<td align="left">图像采用16位RGB格式（4-4-4）存储。未使用的比特总是为零。</td>
</tr>
<tr>
<td align="left"><code>QImage::Format_ARGB4444_Premultiplied</code></td>
<td align="left"><code>15</code></td>
<td align="left">该图像使用预乘的16位ARGB格式（4-4-4）进行存储。</td>
</tr>
<tr>
<td align="left"><code>QImage::Format_RGBX8888</code></td>
<td align="left"><code>16</code></td>
<td align="left">图像使用32位字节排序的RGB(x)格式（8-8-8）存储。这与Format_RGBA8888相同，只是alpha必须始终为255。(在Qt 5.2中添加)</td>
</tr>
<tr>
<td align="left"><code>QImage::Format_RGBA8888</code></td>
<td align="left"><code>17</code></td>
<td align="left">图像使用32位字节排序的RGBA格式（8-8-8）来存储。与ARGB32不同的是，这是一种字节排序的格式，这意味着32位编码在大恩典和小恩典架构之间有所不同，分别为(0xRRGGBBAA)和(0xAABBGGRR)。如果以字节0xRR,0xGG,0xBB,0xAA的形式读取，颜色的顺序在任何架构上都是一样的。(在Qt 5.2中添加)</td>
</tr>
<tr>
<td align="left"><code>QImage::Format_RGBA8888_Premultiplied</code></td>
<td align="left"><code>18</code></td>
<td align="left">图像使用预乘的32位字节排序的RGBA格式（8-8-8）来存储。(在Qt 5.2中添加)</td>
</tr>
<tr>
<td align="left"><code>QImage::Format_BGR30</code></td>
<td align="left"><code>19</code></td>
<td align="left">图像使用32位BGR格式（x-10-10-10）存储。(在Qt 5.4中添加)</td>
</tr>
<tr>
<td align="left"><code>QImage::Format_A2BGR30_Premultiplied</code></td>
<td align="left"><code>20</code></td>
<td align="left">图像使用32位预乘法ABGR格式（2-10-10-10）进行存储。(在Qt 5.4中添加)</td>
</tr>
<tr>
<td align="left"><code>QImage::Format_RGB30</code></td>
<td align="left"><code>21</code></td>
<td align="left">图像使用 32 位 RGB 格式 (x-10-10-10) 存储。(在 Qt 5.4 添加)</td>
</tr>
<tr>
<td align="left"><code>QImage::Format_A2RGB30_Premultiplied</code></td>
<td align="left"><code>22</code></td>
<td align="left">图像使用32位预乘的ARGB格式（2-10-10-10）进行存储。(在Qt 5.4中添加)</td>
</tr>
<tr>
<td align="left"><code>QImage::Format_Alpha8</code></td>
<td align="left"><code>23</code></td>
<td align="left">图像使用 8 位仅 alpha 格式存储。(在 Qt 5.5 添加)</td>
</tr>
<tr>
<td align="left"><code>QImage::Format_Grayscale8</code></td>
<td align="left"><code>24</code></td>
<td align="left">图像使用 8 位灰度格式存储。(在 Qt 5.5 添加)</td>
</tr>
<tr>
<td align="left"><code>QImage::Format_Grayscale16</code></td>
<td align="left"><code>28</code></td>
<td align="left">图像使用 16 位灰度格式存储。(在 Qt 5.13 添加)</td>
</tr>
<tr>
<td align="left"><code>QImage::Format_RGBX64</code></td>
<td align="left"><code>25</code></td>
<td align="left">图像使用64位半字排序的RGB(x)格式（16-16-16）来存储。这与Format_RGBA64相同，只是alpha必须始终是65535。(在Qt 5.12中添加)</td>
</tr>
<tr>
<td align="left"><code>QImage::Format_RGBA64</code></td>
<td align="left"><code>26</code></td>
<td align="left">图像使用 64 位半字有序 RGBA 格式 (16-16-16-16) 存储。(在 Qt 5.12 添加)</td>
</tr>
<tr>
<td align="left"><code>QImage::Format_RGBA64_Premultiplied</code></td>
<td align="left"><code>27</code></td>
<td align="left">图像使用预乘的64位半字排序的RGBA格式（16-16-16）进行存储。(在Qt 5.12中添加)</td>
</tr>
<tr>
<td align="left"><code>QImage::Format_BGR888</code></td>
<td align="left"><code>29</code></td>
<td align="left">图像使用 24 位 BGR 格式存储。(在 Qt 5.14 添加)</td>
</tr>
<tr>
<td align="left"><code>QImage::Format_RGBX16FPx4</code></td>
<td align="left"><code>30</code></td>
<td align="left">图像使用4个16位半字的浮点RGBx格式（16FP-16FP-16FP）来存储。这与Format_RGBA16FPx4相同，只是alpha必须始终为1.0。(在Qt 6.2中添加)</td>
</tr>
<tr>
<td align="left"><code>QImage::Format_RGBA16FPx4</code></td>
<td align="left"><code>31</code></td>
<td align="left">图像使用4个16位半字浮点的RGBA格式（16FP-16FP-16FP）来存储。(在Qt 6.2中添加)</td>
</tr>
<tr>
<td align="left"><code>QImage::Format_RGBA16FPx4_Premultiplied</code></td>
<td align="left"><code>32</code></td>
<td align="left">图像使用预乘的4个16位半字浮点RGBA格式（16FP-16FP-16FP）进行存储。(在Qt 6.2中添加)</td>
</tr>
<tr>
<td align="left"><code>QImage::Format_RGBX32FPx4</code></td>
<td align="left"><code>33</code></td>
<td align="left">图像使用4个32位浮点RGBx格式（32FP-32FP-32FP）进行存储。这与Format_RGBA32FPx4相同，只是alpha必须始终为1.0。(在Qt 6.2中添加)</td>
</tr>
<tr>
<td align="left"><code>QImage::Format_RGBA32FPx4</code></td>
<td align="left"><code>34</code></td>
<td align="left">图像使用4个32位浮点RGBA格式（32FP-32FP-32FP-32FP）存储。(在Qt 6.2中添加)</td>
</tr>
<tr>
<td align="left"><code>QImage::Format_RGBA32FPx4_Premultiplied</code></td>
<td align="left"><code>35</code></td>
<td align="left">图像使用预乘的4个32位浮点RGBA格式（32FP-32FP-32FP）来存储。(在Qt 6.2中添加)</td>
</tr>
</tbody></table>
<p><strong>注意：</strong> 绘制进 <a href="qimage.html">QImage </a>采用 QImage::Format_Indexed8 不支持。</p>
<p><strong>注意：</strong> 避免大多数直接渲染到大多数这些格式使用 <a href="qpainter.html">QPainter </a>。最好优化渲染针对 <code>Format_RGB32 </code>and <code>Format_ARGB32_Premultiplied </code>格式，和其次是渲染到 <code>Format_RGB16 </code>, <code>Format_RGBX8888 </code>, <code>Format_RGBA8888_Premultiplied </code>, <code>Format_RGBX64 </code>and <code>Format_RGBA64_Premultiplied </code>formats</p>
<p><strong>另请参阅</strong> <a href="#format">format </a>() 和 <a href="#convertToFormat">convertToFormat </a>().</p>
<h3><span id="enum-qimage-invertmode">enum QImage:: InvertMode</span><a href="#enum-qimage-invertmode" class="header-anchor">#</a></h3><p>这个枚举类型用于描述在<a href="#invertPixels">invertPixels</a>()函数中，像素值应该如何被反转。</p>
<table>
<thead>
<tr>
<th align="left">常量</th>
<th align="left">值</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>QImage::InvertRgb</code></td>
<td align="left"><code>0</code></td>
<td align="left">只反转RGB值，保持alpha通道不变。</td>
</tr>
<tr>
<td align="left"><code>QImage::InvertRgba</code></td>
<td align="left"><code>1</code></td>
<td align="left">反转所有通道，包括 Alpha 通道。</td>
</tr>
</tbody></table>
<p><strong>另请参阅</strong> <a href="#invertPixels">invertPixels </a>().</p>
<h2><span id="cheng-yuan-han-shu-wen-dang">成员函数文档</span><a href="#cheng-yuan-han-shu-wen-dang" class="header-anchor">#</a></h2><h3><span id="qimage-qimage-rgbswapped-amp-amp">QImage:: rgbSwapped () &amp;&amp;</span><a href="#qimage-qimage-rgbswapped-amp-amp" class="header-anchor">#</a></h3><h3><span id="qimage-qimage-rgbswapped-const-amp">QImage:: rgbSwapped () const &amp;</span><a href="#qimage-qimage-rgbswapped-const-amp" class="header-anchor">#</a></h3><p>返回 <a href="qimage.html">QImage</a>，其中所有像素的红色和蓝色分量的值都被调换，有效地将RGB图像转换为BGR图像。</p>
<p>原始 <a href="qimage.html">QImage </a>无变化。</p>
<p><strong>另请参阅</strong> <a href="#rgbSwap">rgbSwap </a>() 和 <a href="#image-transformations">图像变换 </a>.</p>
<h3><span id="qimage-qimage-mirrored-bool-horizontal-false-bool-vertical-true-amp-amp">QImage:: mirrored ( bool <em>horizontal</em> = false, bool <em>vertical</em> = true) &amp;&amp;</span><a href="#qimage-qimage-mirrored-bool-horizontal-false-bool-vertical-true-amp-amp" class="header-anchor">#</a></h3><h3><span id="qimage-qimage-mirrored-bool-horizontal-false-bool-vertical-true-const-amp">QImage:: mirrored ( bool <em>horizontal</em> = false, bool <em>vertical</em> = true) const &amp;</span><a href="#qimage-qimage-mirrored-bool-horizontal-false-bool-vertical-true-const-amp" class="header-anchor">#</a></h3><p>返回图像的镜像，根据<em>horizontal</em>和<em>vertical</em>是否被设置为true或false，在水平和/或垂直方向上进行镜像。</p>
<p>注意：原始图像无变化。</p>
<p><strong>另请参阅</strong> <a href="#mirror">mirror </a>() 和 <a href="#image-transformations">图像变换 </a>.</p>
<h3><span id="since-6-0-qimage-qimage-convertedto-qimage-format-format-qt-imageconversionflags-flags-qt-autocolor-amp-amp"><code>[since 6.0] </code>QImage:: convertedTo ( <em>format</em> , <em>flags</em> = Qt::AutoColor) &amp;&amp;</span><a href="#since-6-0-qimage-qimage-convertedto-qimage-format-format-qt-imageconversionflags-flags-qt-autocolor-amp-amp" class="header-anchor">#</a></h3><h3><span id="since-6-0-qimage-qimage-convertedto-qimage-format-format-qt-imageconversionflags-flags-qt-autocolor-const-amp"><code>[since 6.0] </code>QImage:: convertedTo ( <em>format</em> , <em>flags</em> = Qt::AutoColor) const &amp;</span><a href="#since-6-0-qimage-qimage-convertedto-qimage-format-format-qt-imageconversionflags-flags-qt-autocolor-const-amp" class="header-anchor">#</a></h3><p>返回图像副本按给定 <em>format</em> .</p>
<p>指定图像转换 <em>flags</em> 控制转换过程中如何处理图像数据。</p>
<p>该函数在 Qt 6.0 引入。</p>
<p><strong>另请参阅</strong> <a href="#convertTo">convertTo </a>() 和 <a href="#image-formats">图像格式 </a>.</p>
<h3><span id="qimage-qimage-converttoformat-qimage-format-format-qt-imageconversionflags-flags-qt-autocolor-amp-amp">QImage:: convertToFormat ( <em>format</em> , <em>flags</em> = Qt::AutoColor) &amp;&amp;</span><a href="#qimage-qimage-converttoformat-qimage-format-format-qt-imageconversionflags-flags-qt-autocolor-amp-amp" class="header-anchor">#</a></h3><h3><span id="qimage-qimage-converttoformat-qimage-format-format-qt-imageconversionflags-flags-qt-autocolor-const-amp">QImage:: convertToFormat ( <em>format</em> , <em>flags</em> = Qt::AutoColor) const &amp;</span><a href="#qimage-qimage-converttoformat-qimage-format-format-qt-imageconversionflags-flags-qt-autocolor-const-amp" class="header-anchor">#</a></h3><p>返回图像副本按给定 <em>format</em> .</p>
<p>指定图像转换 <em>flags</em> 控制转换过程中如何处理图像数据。</p>
<p><strong>另请参阅</strong> <a href="#convertTo">convertTo </a>() 和 <a href="#image-formats">图像格式 </a>.</p>
<h3><span id="since-5-2-qimage-qimage-qimage-amp-amp-other"><code>[since 5.2] </code>QImage:: QImage ( &amp;&amp; <em>other</em> )</span><a href="#since-5-2-qimage-qimage-qimage-amp-amp-other" class="header-anchor">#</a></h3><p>移动–构造一个QImage实例，使其指向<em>other</em> 所指向的同一对象。</p>
<p>该函数在 Qt 5.2 引入。</p>
<h3><span id="qimage-qimage-const-qimage-amp-image">QImage:: QImage (const &amp; <em>image</em> )</span><a href="#qimage-qimage-const-qimage-amp-image" class="header-anchor">#</a></h3><p>构造浅拷贝为给定 <em>image</em> .</p>
<p>有关浅拷贝的更多信息，见 <a href="implicit-sharing.html">隐式数据共享 </a>文档编制。</p>
<p><strong>另请参阅</strong> <a href="#copy">copy </a>().</p>
<h3><span id="qimage-qimage-const-qstring-amp-filename-const-char-format-nullptr">QImage:: QImage (const &amp; <em>fileName</em> , const char * <em>format</em> = nullptr)</span><a href="#qimage-qimage-const-qstring-amp-filename-const-char-format-nullptr" class="header-anchor">#</a></h3><p>构造图像并试着从文件加载图像，采用给定 <em>fileName</em> .</p>
<p>加载器试图读取图像使用指定的<em>format</em>。若<em>format</em>未被指定（这是默认的），它将根据文件的后缀和标题被自动检测出来。详情请见 { <a href="qimagereader.html#setAutoDetectImageFormat">QImageReader::setAutoDetectImageFormat </a>()}{ <a href="qimagereader.html">QImageReader </a>}。</p>
<p>若图像加载失败，此对象为 null 图像。</p>
<p>文件名可以是指磁盘上的一个实际文件，也可以是指应用程序的一个嵌入式资源。参见<a href="resources.html">资源系统</a>概述。，了解如何在应用程序可执行文件中嵌入图像及其它资源文件的细节。</p>
<p><strong>另请参阅</strong> <a href="#isNull">isNull </a>() 和 <a href="#reading-and-writing-image-files">读写图像文件 </a>.</p>
<h3><span id="qimage-qimage-const-char-const-xpm">QImage:: QImage (const char *const [] <em>xpm</em> )</span><a href="#qimage-qimage-const-char-const-xpm" class="header-anchor">#</a></h3><p>构造图像从给定 <em>xpm</em> 图像。</p>
<p>确保图像是有效 XPM 图像。错误被默默忽略。</p>
<p>注意，通过使用不寻常声明稍微挤压 XPM 变量是可能的：</p>
<div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-type">static</span> <span class="hljs-type">const</span> <span class="hljs-type">char</span> * <span class="hljs-type">const</span> start_xpm[] = {
    <span class="hljs-string">"16 15 8 1"</span>,
    <span class="hljs-string">"a c #cec6bd"</span>,
    <span class="hljs-comment">// etc.</span>
};</code></pre></div>

<p>额外的 “const “使整个定义成为只读的，这样的效率略高（例如，当代码在共享库中时），并且能够与应用程序一起存储在ROM中。</p>
<h3><span id="qimage-qimage-const-uchar-data-int-width-int-height-qsizetype-bytesperline-qimage-format-format-qimagecleanupfunction-cleanupfunction-nullptr-void-cleanupinfo-nullptr">QImage:: QImage (const * <em>data</em> , int <em>width</em> , int <em>height</em> , qsizetype <em>bytesPerLine</em> , <em>format</em> , <em>cleanupFunction</em> = nullptr, void * <em>cleanupInfo</em> = nullptr)</span><a href="#qimage-qimage-const-uchar-data-int-width-int-height-qsizetype-bytesperline-qimage-format-format-qimagecleanupfunction-cleanupfunction-nullptr-void-cleanupinfo-nullptr" class="header-anchor">#</a></h3><p>构造图像采用给定的 <em>width</em> , <em>height</em> 和 <em>format</em> ，即使用一个现有的内存缓冲区，<em>data</em> 。 <em>width</em> 和 <em>height</em> 必须以像素为单位指定。<em>bytesPerLine</em>指定了每行的字节数（stride）。</p>
<p>缓冲区必须在QImage的整个生命周期内保持有效，所有没有被修改或以其他方式从原始缓冲区脱离的副本都是如此。图像在销毁时不会删除该缓冲区。你可以提供一个函数指针<em>cleanupFunction</em>，同时提供一个额外的指针<em>cleanupInfo</em>，当最后一个副本被销毁时，将被调用。</p>
<p>若<em>format</em>是一个索引的颜色格式，图像的颜色表最初是空的，在使用图像之前必须用<a href="#setColorCount">setColorCount</a>()或<a href="#setColorTable">setColorTable</a>()充分扩展。</p>
<p>与类似的QImage构造函数不同的是，该构造函数需要一个非静态的数据缓冲区，这个版本永远不会改变缓冲区的内容。例如，调用<a href="#bits">QImage::bits</a>()将返回一个图像的深度拷贝，而不是传递给构造函数的缓冲区。这使得从原始数据构造QImage的效率得到了提高，而原始数据没有被改变的可能。</p>
<h3><span id="qimage-qimage-uchar-data-int-width-int-height-qsizetype-bytesperline-qimage-format-format-qimagecleanupfunction-cleanupfunction-nullptr-void-cleanupinfo-nullptr">QImage:: QImage ( * <em>data</em> , int <em>width</em> , int <em>height</em> , qsizetype <em>bytesPerLine</em> , <em>format</em> , <em>cleanupFunction</em> = nullptr, void * <em>cleanupInfo</em> = nullptr)</span><a href="#qimage-qimage-uchar-data-int-width-int-height-qsizetype-bytesperline-qimage-format-format-qimagecleanupfunction-cleanupfunction-nullptr-void-cleanupinfo-nullptr" class="header-anchor">#</a></h3><p>构造图像采用给定的 <em>width</em> , <em>height</em> 和 <em>format</em> ，即使用一个现有的内存缓冲区，<em>data</em> 。 <em>width</em> 和 <em>height</em> 必须以像素为单位指定。<em>bytesPerLine</em>指定了每行的字节数（stride）。</p>
<p>缓冲区必须在QImage的整个生命周期内保持有效，所有没有被修改或以其他方式从原始缓冲区脱离的副本都是如此。图像在销毁时不会删除该缓冲区。你可以提供一个函数指针<em>cleanupFunction</em>，同时提供一个额外的指针<em>cleanupInfo</em>，当最后一个副本被销毁时，将被调用。</p>
<p>若<em>format</em>是一个索引的颜色格式，图像的颜色表最初是空的，在使用图像之前必须用<a href="#setColorCount">setColorCount</a>()或<a href="#setColorTable">setColorTable</a>()充分扩展。</p>
<h3><span id="qimage-qimage-const-uchar-data-int-width-int-height-qimage-format-format-qimagecleanupfunction-cleanupfunction-nullptr-void-cleanupinfo-nullptr">QImage:: QImage (const * <em>data</em> , int <em>width</em> , int <em>height</em> , <em>format</em> , <em>cleanupFunction</em> = nullptr, void * <em>cleanupInfo</em> = nullptr)</span><a href="#qimage-qimage-const-uchar-data-int-width-int-height-qimage-format-format-qimagecleanupfunction-cleanupfunction-nullptr-void-cleanupinfo-nullptr" class="header-anchor">#</a></h3><p>构造图像采用给定的 <em>width</em> , <em>height</em> 和 <em>format</em> ，使用现有的只读内存缓冲区， <em>data</em> 。 <em>width</em> 和 <em>height</em> 必须以像素为单位， <em>data</em> 必须是32位对齐的，图像中的每个扫描线数据也必须是32位对齐。</p>
<p>缓冲区必须在QImage的整个生命周期内保持有效，所有没有被修改或以其他方式从原始缓冲区脱离的副本都是如此。图像在销毁时不会删除该缓冲区。你可以提供一个函数指针<em>cleanupFunction</em>，同时提供一个额外的指针<em>cleanupInfo</em>，当最后一个副本被销毁时，这个指针将被调用。</p>
<p>若<em>format</em>是一个索引的颜色格式，图像的颜色表最初是空的，在使用图像之前必须用<a href="#setColorCount">setColorCount</a>()或<a href="#setColorTable">setColorTable</a>()充分扩展。</p>
<p>与类似的QImage构造函数不同的是，该构造函数需要一个非静态的数据缓冲区，这个版本永远不会改变缓冲区的内容。例如，调用<a href="#bits">QImage::bits</a>()将返回一个图像的深度拷贝，而不是传递给构造函数的缓冲区。这使得从原始数据构造QImage的效率得到了提高，而原始数据没有被改变的可能。</p>
<h3><span id="qimage-qimage-uchar-data-int-width-int-height-qimage-format-format-qimagecleanupfunction-cleanupfunction-nullptr-void-cleanupinfo-nullptr">QImage:: QImage ( * <em>data</em> , int <em>width</em> , int <em>height</em> , <em>format</em> , <em>cleanupFunction</em> = nullptr, void * <em>cleanupInfo</em> = nullptr)</span><a href="#qimage-qimage-uchar-data-int-width-int-height-qimage-format-format-qimagecleanupfunction-cleanupfunction-nullptr-void-cleanupinfo-nullptr" class="header-anchor">#</a></h3><p>构造图像采用给定的 <em>width</em> , <em>height</em> 和 <em>format</em> ，使用现有的内存缓冲区， <em>data</em> 。 <em>width</em> 和 <em>height</em> 必须以像素为单位， <em>data</em> 必须是32位对齐的，图像中的每个扫描线数据也必须是32位对齐的。</p>
<p>缓冲区必须在QImage的整个生命周期内保持有效，所有没有被修改或以其他方式从原始缓冲区脱离的副本都是如此。图像在销毁时不会删除该缓冲区。你可以提供一个函数指针<em>cleanupFunction</em>，同时提供一个额外的指针<em>cleanupInfo</em>，当最后一个副本被销毁时，这个指针将被调用。</p>
<p>如果<em>format</em>是一个索引的颜色格式，图像的颜色表最初是空的，在使用图像之前必须用<a href="#setColorCount">setColorCount</a>()或<a href="#setColorTable">setColorTable</a>()充分地扩展。</p>
<h3><span id="qimage-qimage-int-width-int-height-qimage-format-format">QImage:: QImage ( int <em>width</em> , int <em>height</em> , <em>format</em> )</span><a href="#qimage-qimage-int-width-int-height-qimage-format-format" class="header-anchor">#</a></h3><p>构造图像采用给定 <em>width</em> , <em>height</em> and <em>format</em> .</p>
<p>如果内存不能被分配，将返回一个<a href="#isNull">null</a>图像。</p>
<p><strong>警告：</strong> 这将创建带有未初始化数据的QImage。调用<a href="#fill">fill</a>()在用<a href="qpainter.html">QPainter</a>绘制图像之前，用适当的像素值来填充该图像。</p>
<h3><span id="qimage-qimage-const-qsize-amp-size-qimage-format-format">QImage:: QImage (const &amp; <em>size</em> , <em>format</em> )</span><a href="#qimage-qimage-const-qsize-amp-size-qimage-format-format" class="header-anchor">#</a></h3><p>构造图像采用给定 <em>size</em> and <em>format</em> .</p>
<p>A <a href="#isNull">null </a>图像被返回，若无法分配内存。</p>
<p><strong>警告：</strong> 这将创建带有未初始化数据的 QImage。调用<a href="#fill">fill</a>()在用<a href="qpainter.html">QPainter</a>绘制图像之前，用一个适当的像素值来填充。</p>
<h3><span id="qimage-qimage">QImage:: QImage ()</span><a href="#qimage-qimage" class="header-anchor">#</a></h3><p>构造空图像。</p>
<p><strong>另请参阅</strong> <a href="#isNull">isNull </a>().</p>
<h3><span id="since-5-2-qimage-amp-qimage-operator-qimage-amp-amp-other"><code>[since 5.2] </code>&amp;QImage:: operator= ( &amp;&amp; <em>other</em> )</span><a href="#since-5-2-qimage-amp-qimage-operator-qimage-amp-amp-other" class="header-anchor">#</a></h3><p>移动赋值 <em>other</em> 到此 <a href="qimage.html">QImage </a>实例。</p>
<p>该函数在 Qt 5.2 引入。</p>
<h3><span id="qimage-amp-qimage-operator-const-qimage-amp-image">&amp;QImage:: operator= (const &amp; <em>image</em> )</span><a href="#qimage-amp-qimage-operator-const-qimage-amp-image" class="header-anchor">#</a></h3><p>将给定的<em>image</em> 的浅层拷贝分配给此图像，并返回此图像的引用。</p>
<p>有关浅拷贝的更多信息，见 <a href="implicit-sharing.html">隐式数据共享 </a>文档编制。</p>
<p><strong>另请参阅</strong> <a href="#copy">copy </a>() 和 <a href="#QImage">QImage </a>().</p>
<h3><span id="virtual-qimage-qimage"><code>[virtual] </code>QImage:: ~QImage ()</span><a href="#virtual-qimage-qimage" class="header-anchor">#</a></h3><p>销毁图像并清理。</p>
<h3><span id="bool-qimage-allgray-const">bool QImage:: allGray () const</span><a href="#bool-qimage-allgray-const" class="header-anchor">#</a></h3><p>返回 <code>true </code>如果图像中的所有颜色都是灰度（即它们的红、绿、蓝成分相等）；否则为false。</p>
<p>请注意，这个函数对于没有色表的图像是很慢的。</p>
<p><strong>另请参阅</strong> <a href="#isGrayscale">isGrayscale </a>().</p>
<h3><span id="since-5-14-void-qimage-applycolortransform-const-qcolortransform-amp-transform"><code>[since 5.14] </code>void QImage:: applyColorTransform (const &amp; <em>transform</em> )</span><a href="#since-5-14-void-qimage-applycolortransform-const-qcolortransform-amp-transform" class="header-anchor">#</a></h3><p>应用颜色变换<em>transform</em> 到图像中的所有像素。</p>
<p>该函数在 Qt 5.14 引入。</p>
<h3><span id="int-qimage-bitplanecount-const">int QImage:: bitPlaneCount () const</span><a href="#int-qimage-bitplanecount-const" class="header-anchor">#</a></h3><p>返回图像位平面数。</p>
<p>位平面的数量是指每个像素的颜色和透明度信息的位数。当图像格式包含未使用的比特时，这与深度不同（即小于）。</p>
<p><strong>另请参阅</strong> <a href="#depth">depth </a>(), <a href="#format">format </a>()，和 <a href="#image-formats">图像格式 </a>.</p>
<h3><span id="uchar-qimage-bits">*QImage:: bits ()</span><a href="#uchar-qimage-bits" class="header-anchor">#</a></h3><p>返回第一像素数据指针。这相当于 <a href="#scanLine">scanLine </a>(0).</p>
<p>注意， <a href="qimage.html">QImage </a>使用 <a href="implicit-sharing.html">隐式数据共享 </a>. 这个函数对共享的像素数据进行深度拷贝，从而确保这个<a href="qimage.html">QImage</a>是唯一使用当前返回值的。</p>
<p><strong>另请参阅</strong> <a href="#scanLine">scanLine </a>(), <a href="#sizeInBytes">sizeInBytes </a>()，和 <a href="#constBits">constBits </a>().</p>
<h3><span id="const-uchar-qimage-bits-const">const *QImage:: bits () const</span><a href="#const-uchar-qimage-bits-const" class="header-anchor">#</a></h3><p>这是重载函数。</p>
<p>注意， <a href="qimage.html">QImage </a>使用 <a href="implicit-sharing.html">隐式数据共享 </a>, 但这个函数 <strong>不</strong> 对共享的像素数据进行深度拷贝，因为返回的数据是常数。</p>
<h3><span id="qsizetype-qimage-bytesperline-const">qsizetype QImage:: bytesPerLine () const</span><a href="#qsizetype-qimage-bytesperline-const" class="header-anchor">#</a></h3><p>返回每图像扫描线的字节数。</p>
<p>这相当于 <a href="#sizeInBytes">sizeInBytes </a>() / <a href="#height">height </a>() if <a href="#height">height </a>() 非零。</p>
<p><strong>另请参阅</strong> <a href="#scanLine">scanLine </a>().</p>
<h3><span id="qint64-qimage-cachekey-const">QImage:: cacheKey () const</span><a href="#qint64-qimage-cachekey-const" class="header-anchor">#</a></h3><p>返回一个数字，用于识别这个<a href="qimage.html">QImage</a>对象的内容。不同的<a href="qimage.html">QImage</a>对象只有在引用相同的内容时才会有相同的键。</p>
<p>键将改变当变更图像时。</p>
<h3><span id="qrgb-qimage-color-int-i-const">QImage:: color ( int <em>i</em> ) const</span><a href="#qrgb-qimage-color-int-i-const" class="header-anchor">#</a></h3><p>返回颜色表中索引<em>i</em>的颜色。第一个颜色在索引0处。</p>
<p>图像色表中的颜色被指定为ARGB四元组（<a href="#QRgb-typedef">QRgb</a>）。使用qAlpha()、qRed()、qGreen()和qBlue()函数来获取颜色值成分。</p>
<p><strong>另请参阅</strong> <a href="#setColor">setColor </a>(), <a href="#pixelIndex">pixelIndex </a>()，和 <a href="#pixel-manipulation">像素操纵 </a>.</p>
<h3><span id="int-qimage-colorcount-const">int QImage:: colorCount () const</span><a href="#int-qimage-colorcount-const" class="header-anchor">#</a></h3><p>返回图像的颜色表大小。</p>
<p>请注意，colorCount()对32-pp的图像返回0，因为这些图像不使用颜色表，而是将像素值编码为ARGB四边形。</p>
<p><strong>另请参阅</strong> <a href="#setColorCount">setColorCount </a>() 和 <a href="#image-information">图像信息 </a>.</p>
<h3><span id="since-5-14-qcolorspace-qimage-colorspace-const"><code>[since 5.14] </code>QImage:: colorSpace () const</span><a href="#since-5-14-qcolorspace-qimage-colorspace-const" class="header-anchor">#</a></h3><p>返回图像的色彩空间，若有定义色彩空间。</p>
<p>该函数在 Qt 5.14 引入。</p>
<p><strong>另请参阅</strong> <a href="#setColorSpace">setColorSpace </a>().</p>
<h3><span id="qlist-lt-qrgb-gt-qimage-colortable-const">&lt; &gt; QImage:: colorTable () const</span><a href="#qlist-lt-qrgb-gt-qimage-colortable-const" class="header-anchor">#</a></h3><p>返回一个包含在图像颜色表中的颜色列表，如果图像没有颜色表，则返回一个空列表。</p>
<p><strong>另请参阅</strong> <a href="#setColorTable">setColorTable </a>(), <a href="#colorCount">colorCount </a>()，和 <a href="#color">color </a>().</p>
<h3><span id="const-uchar-qimage-constbits-const">const *QImage:: constBits () const</span><a href="#const-uchar-qimage-constbits-const" class="header-anchor">#</a></h3><p>返回第一像素数据指针。</p>
<p>注意， <a href="qimage.html">QImage </a>使用 <a href="implicit-sharing.html">隐式数据共享 </a>, 但这个函数并<em>不</em>对共享的像素数据进行深度拷贝，因为返回的数据是常数。</p>
<p><strong>另请参阅</strong> <a href="#bits">bits </a>() 和 <a href="#constScanLine">constScanLine </a>().</p>
<h3><span id="const-uchar-qimage-constscanline-int-i-const">const *QImage:: constScanLine ( int <em>i</em> ) const</span><a href="#const-uchar-qimage-constscanline-int-i-const" class="header-anchor">#</a></h3><p>返回索引为<em>i</em>的扫描线的像素数据的指针。第一个扫描线的索引是0。</p>
<p>扫描线数据至少是32位对齐的。对于64位格式，它遵循64位整数的本地对齐方式（大多数平台为64位，但在i386上主要为32位）。</p>
<p>注意， <a href="qimage.html">QImage </a>使用 <a href="implicit-sharing.html">隐式数据共享 </a>, 但这个函数并<em>不</em>对共享的像素数据进行深度拷贝，因为返回的数据是常数.</p>
<p><strong>另请参阅</strong> <a href="#scanLine">scanLine </a>() 和 <a href="#constBits">constBits </a>().</p>
<h3><span id="since-5-13-void-qimage-convertto-qimage-format-format-qt-imageconversionflags-flags-qt-autocolor"><code>[since 5.13] </code>void QImage:: convertTo ( <em>format</em> , <em>flags</em> = Qt::AutoColor)</span><a href="#since-5-13-void-qimage-convertto-qimage-format-format-qt-imageconversionflags-flags-qt-autocolor" class="header-anchor">#</a></h3><p>将图像转换为给定的<em>format</em> ，必要时分离。</p>
<p>指定图像转换 <em>flags</em> 控制转换过程中如何处理图像数据。</p>
<p>该函数在 Qt 5.13 引入。</p>
<p><strong>另请参阅</strong> <a href="#convertedTo">convertedTo </a>().</p>
<h3><span id="since-5-14-void-qimage-converttocolorspace-const-qcolorspace-amp-colorspace"><code>[since 5.14] </code>void QImage:: convertToColorSpace (const &amp; <em>colorSpace</em> )</span><a href="#since-5-14-void-qimage-converttocolorspace-const-qcolorspace-amp-colorspace" class="header-anchor">#</a></h3><p>将图像转换成 <em>colorSpace</em> .</p>
<p>若图像没有有效色彩空间，方法什么都不做。</p>
<p>该函数在 Qt 5.14 引入。</p>
<p><strong>另请参阅</strong> <a href="#convertedToColorSpace">convertedToColorSpace </a>() 和 <a href="#setColorSpace">setColorSpace </a>().</p>
<h3><span id="qimage-qimage-converttoformat-qimage-format-format-const-qlist-lt-qrgb-gt-amp-colortable-qt-imageconversionflags-flags-qt-autocolor-const">QImage:: convertToFormat ( <em>format</em> , const &lt; &gt; &amp; <em>colorTable</em> , <em>flags</em> = Qt::AutoColor) const</span><a href="#qimage-qimage-converttoformat-qimage-format-format-const-qlist-lt-qrgb-gt-amp-colortable-qt-imageconversionflags-flags-qt-autocolor-const" class="header-anchor">#</a></h3><p>这是重载函数。</p>
<p>返回一个转换为给定<em>格式</em>的图像的副本，使用指定的<em>colorTable</em>。</p>
<p>从RGB格式转换到索引格式是一个缓慢的操作，将使用一个直接的最近的颜色方法，没有抖动。</p>
<h3><span id="since-5-14-qimage-qimage-convertedtocolorspace-const-qcolorspace-amp-colorspace-const"><code>[since 5.14] </code>QImage:: convertedToColorSpace (const &amp; <em>colorSpace</em> ) const</span><a href="#since-5-14-qimage-qimage-convertedtocolorspace-const-qcolorspace-amp-colorspace-const" class="header-anchor">#</a></h3><p>返回图像转换到 <em>colorSpace</em> .</p>
<p>若图像没有有效色彩空间，null <a href="qimage.html">QImage </a>被返回。</p>
<p>该函数在 Qt 5.14 引入。</p>
<p><strong>另请参阅</strong> <a href="#convertToColorSpace">convertToColorSpace </a>().</p>
<h3><span id="qimage-qimage-copy-const-qrect-amp-rectangle-qrect-const">QImage:: copy (const &amp; <em>rectangle</em> = QRect()) const</span><a href="#qimage-qimage-copy-const-qrect-amp-rectangle-qrect-const" class="header-anchor">#</a></h3><p>将图像的子区域作为新图像返回。</p>
<p>返回的图像是从这个图像中的位置（<em>rectangle</em> .x(), <em>rectangle</em> .y()）复制的，并且总是具有给定的<em>rectangle</em>的大小。</p>
<p>对于32位RGB图像，这意味着黑色；对于32位ARGB图像，这意味着透明的黑色；对于8位图像，这意味着色表中索引为0的颜色，可以是任何颜色；对于1位图像，这意味着<a href="#GlobalColor-enum">Qt::color0</a>。</p>
<p>如果给定 <em>rectangle</em> 是一个空的矩形，整个图像就被复制了。</p>
<p><strong>另请参阅</strong> <a href="#QImage">QImage </a>().</p>
<h3><span id="qimage-qimage-copy-int-x-int-y-int-width-int-height-const">QImage:: copy ( int <em>x</em> , int <em>y</em> , int <em>width</em> , int <em>height</em> ) const</span><a href="#qimage-qimage-copy-int-x-int-y-int-width-int-height-const" class="header-anchor">#</a></h3><p>这是重载函数。</p>
<p>返回的图像是从这个图像中的( <em>x</em> , <em>y</em> )位置复制的，并且总是具有给定的<em>width</em> 和<em>height</em> 。在超出此图像的区域，像素被设置为0。</p>
<h3><span id="qimage-qimage-createalphamask-qt-imageconversionflags-flags-qt-autocolor-const">QImage:: createAlphaMask ( <em>flags</em> = Qt::AutoColor) const</span><a href="#qimage-qimage-createalphamask-qt-imageconversionflags-flags-qt-autocolor-const" class="header-anchor">#</a></h3><p>从这个图像中的alpha缓冲区建立并返回一个1-bpp的遮罩。如果图像的格式是<a href="#Format-enum">QImage::Format_RGB32</a>，则返回一个空图像。</p>
<p><em>flags</em> 自变量是按位或的[Qt::ImageConversionFlags]（#ImageConversionFlag-enum），并控制转换过程。传递0的flags可以设置所有的默认选项。</p>
<p>返回的图像具有小-序（即图像的格式是<a href="#Format-enum">QImage::Format_MonoLSB</a>），你可以使用<a href="#convertToFormat">convertToFormat</a>()函数将其转换为大-序（ <a href="#Format-enum">QImage::Format_Mono</a>）。</p>
<p><strong>另请参阅</strong> <a href="#createHeuristicMask">createHeuristicMask </a>() 和 <a href="#image-transformations">图像变换 </a>.</p>
<h3><span id="qimage-qimage-createheuristicmask-bool-cliptight-true-const">QImage:: createHeuristicMask ( bool <em>clipTight</em> = true) const</span><a href="#qimage-qimage-createheuristicmask-bool-cliptight-true-const" class="header-anchor">#</a></h3><p>为该图像创建并返回一个1-bpp的启发式掩码。</p>
<p>该函数的工作原理是从其中一个角选择一种颜色，然后从所有边缘开始削去该颜色的像素。四个角投票决定哪种颜色要被遮蔽掉。如果出现平局（这通常意味着这个函数不适用于该图像），结果是任意的。</p>
<p>返回的图像具有小-endian位顺序（即图像的格式是<a href="#Format-enum">QImage::Format_MonoLSB</a>），你可以使用<a href="#convertToFormat">convertToFormat</a>()函数将其转换为大-endian（<a href="#Format-enum">QImage::Format_Mono</a>）。</p>
<p>如果<em>clipTight</em>为真（默认），遮罩就会大到足以覆盖这些像素；否则，遮罩就会比数据像素大。</p>
<p>请注意，这个函数不考虑alpha缓冲区。</p>
<p><strong>另请参阅</strong> <a href="#createAlphaMask">createAlphaMask </a>() 和 <a href="#image-transformations">图像变换 </a>.</p>
<h3><span id="qimage-qimage-createmaskfromcolor-qrgb-color-qt-maskmode-mode-qt-maskincolor-const">QImage:: createMaskFromColor ( <em>color</em> , <em>mode</em> = Qt::MaskInColor) const</span><a href="#qimage-qimage-createmaskfromcolor-qrgb-color-qt-maskmode-mode-qt-maskincolor-const" class="header-anchor">#</a></h3><p>根据给定的<em>color</em>值，为该图像创建并返回一个蒙版。如果<em>mode</em>是MaskInColor（默认值），所有与<em>color</em>相匹配的像素将成为蒙版中不透明的像素。如果<em>mode</em>是MaskOutColor，所有匹配给定颜色的像素将是透明的。</p>
<p><strong>另请参阅</strong> <a href="#createAlphaMask">createAlphaMask </a>() 和 <a href="#createHeuristicMask">createHeuristicMask </a>().</p>
<h3><span id="int-qimage-depth-const">int QImage:: depth () const</span><a href="#int-qimage-depth-const" class="header-anchor">#</a></h3><p>返回图像的深度。</p>
<p>图像深度是指用于存储单个像素的比特数，也叫每像素比特数（bpp）。</p>
<p>支持深度：1、8、16、24、32 及 64。</p>
<p><strong>另请参阅</strong> <a href="#bitPlaneCount">bitPlaneCount </a>(), <a href="#convertToFormat">convertToFormat </a>(), <a href="#image-formats">图像格式 </a>，和 <a href="#image-information">图像信息 </a>.</p>
<h3><span id="qsizef-qimage-deviceindependentsize-const">QImage:: deviceIndependentSize () const</span><a href="#qsizef-qimage-deviceindependentsize-const" class="header-anchor">#</a></h3><p>按设备无关像素返回像素图的大小。</p>
<p>在用户界面尺寸计算中使用像素图尺寸时，应使用这个值。</p>
<p>返回值相当于 pixmap. <a href="#size">size </a>() / pixmap. <a href="#devicePixelRatio">devicePixelRatio </a>(),</p>
<h3><span id="qreal-qimage-devicepixelratio-const">QImage:: devicePixelRatio () const</span><a href="#qreal-qimage-devicepixelratio-const" class="header-anchor">#</a></h3><p>返回图像的设备像素比。这是<em>device pixels</em>和<em>device independent pixels</em>之间的比率。</p>
<p>返回图像的设备像素比。这是<em>设备像素</em>和<em>设备独立像素</em>之间的比率。</p>
<p>在根据图像尺寸计算布局几何时，使用这个函数。<a href="qsize.html">QSize</a>layoutSize = image. <a href="#size">size</a>() / image.devicePixelRatio()</p>
<p>默认值为 1.0。</p>
<p><strong>另请参阅</strong> <a href="#setDevicePixelRatio">setDevicePixelRatio </a>() 和 <a href="qimagereader.html">QImageReader </a>.</p>
<h3><span id="int-qimage-dotspermeterx-const">int QImage:: dotsPerMeterX () const</span><a href="#int-qimage-dotspermeterx-const" class="header-anchor">#</a></h3><p>返回在水平方向上适合一个物理米的像素数。与<a href="#dotsPerMeterY">dotsPerMeterY</a>()一起，这个数字定义了图像的预期比例和长宽比。</p>
<p><strong>另请参阅</strong> <a href="#setDotsPerMeterX">setDotsPerMeterX </a>() 和 <a href="#image-information">图像信息 </a>.</p>
<h3><span id="int-qimage-dotspermetery-const">int QImage:: dotsPerMeterY () const</span><a href="#int-qimage-dotspermetery-const" class="header-anchor">#</a></h3><p>返回垂直方向上适合一个物理米的像素数。与<a href="#dotsPerMeterX">dotsPerMeterX</a>()一起，这个数字定义了图像的预期比例和长宽比。</p>
<p><strong>另请参阅</strong> <a href="#setDotsPerMeterY">setDotsPerMeterY </a>() 和 <a href="#image-information">图像信息 </a>.</p>
<h3><span id="void-qimage-fill-uint-pixelvalue">void QImage:: fill ( <em>pixelValue</em> )</span><a href="#void-qimage-fill-uint-pixelvalue" class="header-anchor">#</a></h3><p>填充整个图像采用给定 <em>pixelValue</em> .</p>
<p>如果这个图像的深度是1，就只使用最低位。如果你说fill(0)、fill(2)等，图像就会被填充成0。如果你说fill(1)、fill(3)等，图像就会被填上1。如果深度是8，则使用最低的8比特，如果深度是16，则使用最低的16比特。</p>
<p>如果图像深度高于32位，结果就无法定义。</p>
<p><strong>注意：</strong>没有相应的值获取器，尽管对于索引格式，<a href="#pixelIndex">QImage::pixelIndex </a>()将返回相同的值，而对于RGB32、ARGB32和ARGB32PM格式，<a href="#pixel">QImage::pixel </a>()则返回相同的值。</p>
<p><strong>另请参阅</strong> <a href="#depth">depth </a>() 和 <a href="#image-transformations">图像变换 </a>.</p>
<h3><span id="void-qimage-fill-const-qcolor-amp-color">void QImage:: fill (const &amp; <em>color</em> )</span><a href="#void-qimage-fill-const-qcolor-amp-color" class="header-anchor">#</a></h3><p>这是重载函数。</p>
<p>填充整个图像采用给定 <em>color</em> .</p>
<p>若图像深度为 1，图像将被填充采用 1 若 <em>color</em> 等于 <a href="#GlobalColor-enum">Qt::color1 </a>；否则将被填充采用 0。</p>
<p>如果图像的深度是8，如果存在的话，图像将被填充颜色表中的<em>颜色</em>对应的索引；否则将被填充为0。</p>
<h3><span id="void-qimage-fill-qt-globalcolor-color">void QImage:: fill ( <em>color</em> )</span><a href="#void-qimage-fill-qt-globalcolor-color" class="header-anchor">#</a></h3><p>这是重载函数。</p>
<p>填充图像采用给定 <em>color</em> ，描述为标准全局颜色。</p>
<h3><span id="qimage-format-qimage-format-const">QImage:: format () const</span><a href="#qimage-format-qimage-format-const" class="header-anchor">#</a></h3><p>返回图像格式。</p>
<p><strong>另请参阅</strong> <a href="#image-formats">图像格式 </a>.</p>
<h3><span id="static-since-6-2-qimage-qimage-fromdata-qbytearrayview-data-const-char-format-nullptr"><code>[static, since 6.2] </code>QImage:: fromData ( <em>data</em> , const char * <em>format</em> = nullptr)</span><a href="#static-since-6-2-qimage-qimage-fromdata-qbytearrayview-data-const-char-format-nullptr" class="header-anchor">#</a></h3><p>构造图像从给定 <a href="qbytearrayview.html">QByteArrayView </a><em>data</em> . 装载器试图使用指定的<em>format</em>来读取图像。若没有指定<em>format</em>（这是默认的），装载器会探测数据中的头来猜测文件格式。</p>
<p>若 <em>format</em> 有指定，它必须是某一值返回通过 <a href="qimagereader.html#supportedImageFormats">QImageReader::supportedImageFormats </a>().</p>
<p>若图像加载失败，返回图像将为 null 图像。</p>
<p>该函数在 Qt 6.2 引入。</p>
<p><strong>另请参阅</strong> <a href="#load">load </a>(), <a href="#save">save </a>()，和 <a href="#reading-and-writing-image-files">读写图像文件 </a>.</p>
<h3><span id="static-qimage-qimage-fromdata-const-uchar-data-int-size-const-char-format-nullptr"><code>[static] </code>QImage:: fromData (const * <em>data</em> , int <em>size</em> , const char * <em>format</em> = nullptr)</span><a href="#static-qimage-qimage-fromdata-const-uchar-data-int-size-const-char-format-nullptr" class="header-anchor">#</a></h3><p>这是重载函数。</p>
<p>构造 <a href="qimage.html">QImage</a>，从给定的二进制数据的第一个<em>size</em> 字节开始。</p>
<h3><span id="static-qimage-qimage-fromdata-const-qbytearray-amp-data-const-char-format-nullptr"><code>[static] </code>QImage:: fromData (const &amp; <em>data</em> , const char * <em>format</em> = nullptr)</span><a href="#static-qimage-qimage-fromdata-const-qbytearray-amp-data-const-char-format-nullptr" class="header-anchor">#</a></h3><p>这是重载函数。</p>
<p>构造 <a href="qimage.html">QImage </a>from the given <a href="qbytearray.html">QByteArray </a><em>data</em> .</p>
<h3><span id="static-since-6-0-qimage-qimage-fromhbitmap-hbitmap-hbitmap"><code>[static, since 6.0] </code>QImage:: fromHBITMAP ( HBITMAP <em>hbitmap</em> )</span><a href="#static-since-6-0-qimage-qimage-fromhbitmap-hbitmap-hbitmap" class="header-anchor">#</a></h3><p>返回 <a href="qimage.html">QImage</a>，等同于给定的<em>hbitmap</em>。</p>
<p>HBITMAP并不存储关于alpha通道的信息。</p>
<p>在标准情况下，alpha通道被忽略，一个完全不透明的图像被创建（通常格式为<a href="#Format-enum">QImage::Format_RGB32</a>）。</p>
<p>但也有使用alpha通道的情况，例如应用图标或系统托盘图标。在这种情况下，应该对返回的图像调用<code>reinterpretAsFormat(QImage::Format_ARGB32)</code>，以确保格式正确。</p>
<p>该函数在 Qt 6.0 引入。</p>
<p><strong>另请参阅</strong> <a href="#toHBITMAP">toHBITMAP </a>() 和 <a href="#reinterpretAsFormat">reinterpretAsFormat </a>().</p>
<h3><span id="static-since-6-0-qimage-qimage-fromhicon-hicon-icon"><code>[static, since 6.0] </code>QImage:: fromHICON ( HICON <em>icon</em> )</span><a href="#static-since-6-0-qimage-qimage-fromhicon-hicon-icon" class="header-anchor">#</a></h3><p>返回 <a href="qimage.html">QImage</a>，相当于给定的<em>icon</em>。</p>
<p>该函数在 Qt 6.0 引入。</p>
<p><strong>另请参阅</strong> <a href="#toHICON">toHICON </a>().</p>
<h3><span id="bool-qimage-hasalphachannel-const">bool QImage:: hasAlphaChannel () const</span><a href="#bool-qimage-hasalphachannel-const" class="header-anchor">#</a></h3><p>返回 <code>true </code>若图像拥有的格式遵守 Alpha 通道，否则返回 <code>false </code>.</p>
<p><strong>另请参阅</strong> <a href="#image-information">图像信息 </a>.</p>
<h3><span id="int-qimage-height-const">int QImage:: height () const</span><a href="#int-qimage-height-const" class="header-anchor">#</a></h3><p>返回图像的高度。</p>
<p><strong>另请参阅</strong> <a href="#image-information">图像信息 </a>.</p>
<h3><span id="void-qimage-invertpixels-qimage-invertmode-mode-invertrgb">void QImage:: invertPixels ( <em>mode</em> = InvertRgb)</span><a href="#void-qimage-invertpixels-qimage-invertmode-mode-invertrgb" class="header-anchor">#</a></h3><p>反转图像所有像素值。</p>
<p>给定的反转<em>模式</em>只有在图像深度为32时才有意义。默认的<em>模式</em>是<a href="#InvertMode-enum">InvertRgb </a>，它使alpha通道保持不变。如果<em>模式</em>是<a href="#InvertMode-enum">InvertRgba</a>，alpha位也会被反转。</p>
<p>颠倒一个8位图像意味着用一个颜色索引255减去<em>i</em>的像素来替换所有使用颜色索引的像素。1位图像的情况也是如此。请注意，色表是<em>不</em>改变的。</p>
<p>如果图像有一个预乘的阿尔法通道，图像首先被转换为一个未预乘的图像格式，以进行反转，然后再转换回来。</p>
<p><strong>另请参阅</strong> <a href="#image-transformations">图像变换 </a>.</p>
<h3><span id="bool-qimage-isgrayscale-const">bool QImage:: isGrayscale () const</span><a href="#bool-qimage-isgrayscale-const" class="header-anchor">#</a></h3><p>对于 32 位图像，此函数相当于 <a href="#allGray">allGray </a>().</p>
<p>对于颜色索引图像，此函数返回 <code>true </code>若 color(i) 为 <a href="#QRgb-typedef">QRgb </a>(i, i, i) 对于颜色表所有索引而言；否则返回 <code>false </code>.</p>
<p><strong>另请参阅</strong> <a href="#allGray">allGray </a>() 和 <a href="#image-formats">图像格式 </a>.</p>
<h3><span id="bool-qimage-isnull-const">bool QImage:: isNull () const</span><a href="#bool-qimage-isnull-const" class="header-anchor">#</a></h3><p>返回 <code>true </code>若它是 null 图像，否则返回 <code>false </code>.</p>
<p>null 图像的所有参数都设置为零，并且没有分配的数据。</p>
<h3><span id="bool-qimage-load-const-qstring-amp-filename-const-char-format-nullptr">bool QImage:: load (const &amp; <em>fileName</em> , const char * <em>format</em> = nullptr)</span><a href="#bool-qimage-load-const-qstring-amp-filename-const-char-format-nullptr" class="header-anchor">#</a></h3><p>从文件加载图像采用给定 <em>fileName</em> 。返回 <code>true </code>若成功加载图像；否则使图像无效并返回 <code>false </code>.</p>
<p>加载器试图读取图像使用指定 <em>format</em> , 例如，PNG或JPG。如果没有指定<em>format</em>（这是默认的），它将根据文件的后缀和标题自动检测出来。详情请见 <a href="qimagereader.html#setAutoDetectImageFormat">QImageReader::setAutoDetectImageFormat </a>().</p>
<p>文件名可以是指磁盘上的一个实际文件，也可以是指应用程序的一个嵌入式资源。See the <a href="resources.html">资源系统 </a>概述，了解如何在应用程序可执行文件中嵌入图像及其它资源文件的细节。</p>
<p><strong>另请参阅</strong> <a href="#reading-and-writing-image-files">读写图像文件 </a>.</p>
<h3><span id="bool-qimage-load-qiodevice-device-const-char-format">bool QImage:: load ( * <em>device</em> , const char * <em>format</em> )</span><a href="#bool-qimage-load-qiodevice-device-const-char-format" class="header-anchor">#</a></h3><p>这是重载函数。</p>
<p>此函数从给定的<em>device</em> 中读取 <a href="qimage.html">QImage </a>。例如，这可以用来将图像直接加载到<a href="qbytearray.html">QByteArray</a>中。</p>
<h3><span id="since-6-2-bool-qimage-loadfromdata-qbytearrayview-data-const-char-format-nullptr"><code>[since 6.2] </code>bool QImage:: loadFromData ( <em>data</em> , const char * <em>format</em> = nullptr)</span><a href="#since-6-2-bool-qimage-loadfromdata-qbytearrayview-data-const-char-format-nullptr" class="header-anchor">#</a></h3><p>加载图像从给定 <a href="qbytearrayview.html">QByteArrayView </a><em>data</em> 。返回 <code>true </code>若成功加载图像；否则使图像无效并返回 <code>false </code>.</p>
<p>加载器试图读取图像使用指定 <em>format</em> , 例如，PNG或JPG。如果没有指定<em>format</em>（这是默认的），加载器会探测文件的头，以猜测文件的格式。</p>
<p>该函数在 Qt 6.2 引入。</p>
<p><strong>另请参阅</strong> <a href="#reading-and-writing-image-files">读写图像文件 </a>.</p>
<h3><span id="bool-qimage-loadfromdata-const-uchar-data-int-len-const-char-format-nullptr">bool QImage:: loadFromData (const * <em>data</em> , int <em>len</em> , const char * <em>format</em> = nullptr)</span><a href="#bool-qimage-loadfromdata-const-uchar-data-int-len-const-char-format-nullptr" class="header-anchor">#</a></h3><p>这是重载函数。</p>
<p>从给定的二进制<em>data</em>的前<em>len</em>字节中加载一个图像。</p>
<h3><span id="bool-qimage-loadfromdata-const-qbytearray-amp-data-const-char-format-nullptr">bool QImage:: loadFromData (const &amp; <em>data</em> , const char * <em>format</em> = nullptr)</span><a href="#bool-qimage-loadfromdata-const-qbytearray-amp-data-const-char-format-nullptr" class="header-anchor">#</a></h3><p>这是重载函数。</p>
<p>加载图像从给定 <a href="qbytearray.html">QByteArray </a><em>data</em> .</p>
<h3><span id="since-6-0-void-qimage-mirror-bool-horizontal-false-bool-vertical-true"><code>[since 6.0] </code>void QImage:: mirror ( bool <em>horizontal</em> = false, bool <em>vertical</em> = true)</span><a href="#since-6-0-void-qimage-mirror-bool-horizontal-false-bool-vertical-true" class="header-anchor">#</a></h3><p>根据<em>horizontal</em>和<em>vertical</em>是否设置为true或false，在水平和/或垂直方向上对图像进行镜像。</p>
<p>该函数在 Qt 6.0 引入。</p>
<p><strong>另请参阅</strong> <a href="#mirrored">mirrored </a>() 和 <a href="#image-transformations">图像变换 </a>.</p>
<h3><span id="qpoint-qimage-offset-const">QImage:: offset () const</span><a href="#qpoint-qimage-offset-const" class="header-anchor">#</a></h3><p>返回图像相对于其他图像定位时打算偏移的像素数。</p>
<p><strong>另请参阅</strong> <a href="#setOffset">setOffset </a>() 和 <a href="#image-information">图像信息 </a>.</p>
<h3><span id="qrgb-qimage-pixel-const-qpoint-amp-position-const">QImage:: pixel (const &amp; <em>position</em> ) const</span><a href="#qrgb-qimage-pixel-const-qpoint-amp-position-const" class="header-anchor">#</a></h3><p>返回像素的颜色在给定 <em>position</em> .</p>
<p>若 <em>position</em> 无效，结果未定义。</p>
<p><strong>警告：</strong>这个函数在用于大量的像素操作时很昂贵。当需要读取许多像素时，请使用 <a href="#constBits">constBits </a>() 或 <a href="#constScanLine">constScanLine </a>()。</p>
<p><strong>另请参阅</strong> <a href="#setPixel">setPixel </a>(), <a href="#valid">valid </a>(), <a href="#constBits">constBits </a>(), <a href="#constScanLine">constScanLine </a>()，和 <a href="#pixel-manipulation">像素操纵 </a>.</p>
<h3><span id="qrgb-qimage-pixel-int-x-int-y-const">QImage:: pixel ( int <em>x</em> , int <em>y</em> ) const</span><a href="#qrgb-qimage-pixel-int-x-int-y-const" class="header-anchor">#</a></h3><p>这是重载函数。</p>
<p>返回像素的颜色在坐标 ( <em>x</em> , <em>y</em> ).</p>
<h3><span id="since-5-6-qcolor-qimage-pixelcolor-const-qpoint-amp-position-const"><code>[since 5.6] </code>QImage:: pixelColor (const &amp; <em>position</em> ) const</span><a href="#since-5-6-qcolor-qimage-pixelcolor-const-qpoint-amp-position-const" class="header-anchor">#</a></h3><p>返回像素的颜色在给定 <em>position</em> 作为 <a href>QColor </a>.</p>
<p>如果<em>position</em>无效，一个无效的<a href>QColor</a>被返回。</p>
<p><strong>警告：</strong>这个函数在用于大量的像素操作时很昂贵。当需要读取许多像素时，请使用 <a href="#constBits">constBits </a>() 或 <a href="#constScanLine">constScanLine </a>()。</p>
<p>该函数在 Qt 5.6 引入。</p>
<p><strong>另请参阅</strong> <a href="#setPixelColor">setPixelColor </a>(), <a href="#setPixel">setPixel </a>(), <a href="#valid">valid </a>(), <a href="#constBits">constBits </a>(), <a href="#constScanLine">constScanLine </a>()，和 <a href="#pixel-manipulation">像素操纵 </a>.</p>
<h3><span id="since-5-6-qcolor-qimage-pixelcolor-int-x-int-y-const"><code>[since 5.6] </code>QImage:: pixelColor ( int <em>x</em> , int <em>y</em> ) const</span><a href="#since-5-6-qcolor-qimage-pixelcolor-int-x-int-y-const" class="header-anchor">#</a></h3><p>这是重载函数。</p>
<p>返回像素的颜色在坐标 ( <em>x</em> , <em>y</em> ) 作为 <a href>QColor </a>.</p>
<p>该函数在 Qt 5.6 引入。</p>
<h3><span id="qpixelformat-qimage-pixelformat-const">QImage:: pixelFormat () const</span><a href="#qpixelformat-qimage-pixelformat-const" class="header-anchor">#</a></h3><p>返回 <a href="#Format-enum">QImage::Format </a>作为 <a href="qpixelformat.html">QPixelFormat</a></p>
<h3><span id="int-qimage-pixelindex-const-qpoint-amp-position-const">int QImage:: pixelIndex (const &amp; <em>position</em> ) const</span><a href="#int-qimage-pixelindex-const-qpoint-amp-position-const" class="header-anchor">#</a></h3><p>返回像素索引在给定 <em>position</em> .</p>
<p>若 <em>position</em> 无效，或图像不是调色板图像 ( <a href="#depth">depth </a>() &gt; 8)，结果未定义。</p>
<p><strong>另请参阅</strong> <a href="#valid">valid </a>(), <a href="#depth">depth </a>()，和 <a href="#pixel-manipulation">像素操纵 </a>.</p>
<h3><span id="int-qimage-pixelindex-int-x-int-y-const">int QImage:: pixelIndex ( int <em>x</em> , int <em>y</em> ) const</span><a href="#int-qimage-pixelindex-int-x-int-y-const" class="header-anchor">#</a></h3><p>这是重载函数。</p>
<p>返回像素索引在 ( <em>x</em> , <em>y</em> ).</p>
<h3><span id="qrect-qimage-rect-const">QImage:: rect () const</span><a href="#qrect-qimage-rect-const" class="header-anchor">#</a></h3><p>返回封闭矩形 (0, 0, <a href="#width">width </a>(), <a href="#height">height </a>()) 为图像。</p>
<p><strong>另请参阅</strong> <a href="#image-information">图像信息 </a>.</p>
<h3><span id="since-5-9-bool-qimage-reinterpretasformat-qimage-format-format"><code>[since 5.9] </code>bool QImage:: reinterpretAsFormat ( <em>format</em> )</span><a href="#since-5-9-bool-qimage-reinterpretasformat-qimage-format-format" class="header-anchor">#</a></h3><p>将图像格式改为 <em>format</em> 不改变数据。仅工作于相同深度的格式之间。</p>
<p>返回 <code>true </code>若成功。</p>
<p>如果已知数据是不透明的，这个函数可以用来将带有阿尔法通道的图像改变为相应的不透明格式，或者在用新数据覆盖之前改变给定图像缓冲区的格式。</p>
<p><strong>警告：</strong>该函数不检查图像数据在新格式中是否有效，如果深度兼容，仍将返回 “true”。对一个无效数据的图像的操作是未定义的。</p>
<p><strong>警告：</strong> 若图像未分离，这将导致数据被拷贝。</p>
<p>该函数在 Qt 5.9 引入。</p>
<p><strong>另请参阅</strong> <a href="#hasAlphaChannel">hasAlphaChannel </a>() 和 <a href="#convertToFormat">convertToFormat </a>().</p>
<h3><span id="since-6-0-void-qimage-rgbswap"><code>[since 6.0] </code>void QImage:: rgbSwap ()</span><a href="#since-6-0-void-qimage-rgbswap" class="header-anchor">#</a></h3><p>交换所有像素的红色和蓝色成分的值，有效地将RGB图像转换为BGR图像。</p>
<p>该函数在 Qt 6.0 引入。</p>
<p><strong>另请参阅</strong> <a href="#rgbSwapped">rgbSwapped </a>() 和 <a href="#image-transformations">图像变换 </a>.</p>
<h3><span id="bool-qimage-save-const-qstring-amp-filename-const-char-format-nullptr-int-quality-1-const">bool QImage:: save (const &amp; <em>fileName</em> , const char * <em>format</em> = nullptr, int <em>quality</em> = -1) const</span><a href="#bool-qimage-save-const-qstring-amp-filename-const-char-format-nullptr-int-quality-1-const" class="header-anchor">#</a></h3><p>保存图像到文件采用给定 <em>fileName</em> ，使用给定图像文件 <em>format</em> and <em>quality</em> 因子。若 <em>format</em> is <code>nullptr </code>, <a href="qimage.html">QImage </a>将试图猜测格式通过查看 <em>fileName</em> 的后缀。</p>
<p><em>quality</em> 因子必须在 0 到 100 范围内或为 -1。指定 0 以获得小压缩文件，100 为大的未压缩文件，和 -1 (默认) 使用默认设置。</p>
<p>返回 <code>true </code>若图像成功保存；否则返回 <code>false </code>.</p>
<p><strong>另请参阅</strong> <a href="#reading-and-writing-image-files">读写图像文件 </a>.</p>
<h3><span id="bool-qimage-save-qiodevice-device-const-char-format-nullptr-int-quality-1-const">bool QImage:: save ( * <em>device</em> , const char * <em>format</em> = nullptr, int <em>quality</em> = -1) const</span><a href="#bool-qimage-save-qiodevice-device-const-char-format-nullptr-int-quality-1-const" class="header-anchor">#</a></h3><p>这是重载函数。</p>
<p>此函数写入 <a href="qimage.html">QImage </a>到给定 <em>device</em> .</p>
<p>例如，这可以用于将图像直接保存到 <a href="qbytearray.html">QByteArray </a>:</p>
<div class="code-wrapper"><pre><code class="hljs c++">QImage image;
QByteArray ba;
<span class="hljs-function">QBuffer <span class="hljs-title">buffer</span><span class="hljs-params">(&amp;ba)</span></span>;
buffer.<span class="hljs-built_in">open</span>(QIODevice::WriteOnly);
image.<span class="hljs-built_in">save</span>(&amp;buffer, <span class="hljs-string">"PNG"</span>); <span class="hljs-comment">// writes image into ba in PNG format 		</span></code></pre></div>

<h3><span id="qimage-qimage-scaled-const-qsize-amp-size-qt-aspectratiomode-aspectratiomode-qt-ignoreaspectratio-qt-transformationmode-transformmode-qt-fasttransformation-const">QImage:: scaled (const &amp; <em>size</em> , <em>aspectRatioMode</em> = Qt::IgnoreAspectRatio, <em>transformMode</em> = Qt::FastTransformation) const</span><a href="#qimage-qimage-scaled-const-qsize-amp-size-qt-aspectratiomode-aspectratiomode-qt-ignoreaspectratio-qt-transformationmode-transformmode-qt-fasttransformation-const" class="header-anchor">#</a></h3><p>根据给定的<em>aspectRatioMode</em>和<em>transformMode</em>，返回一个按比例放大到由给定的<em>size</em>定义的矩形的图像副本。</p>
<p><img src="https://doc.qt.io/qt-6/images/qimage-scaling.png" srcset="/img/loading.gif" lazyload alt="img"></p>
<ul>
<li>若 <em>aspectRatioMode</em> is <a href="#AspectRatioMode-enum">Qt::IgnoreAspectRatio </a>, 图像被缩放为<em>size</em> 。</li>
<li>若 <em>aspectRatioMode</em> is <a href="#AspectRatioMode-enum">Qt::KeepAspectRatio </a>, 图像被缩放为一个尽可能大的矩形，在<em>size</em>内。, 维持宽高比。</li>
<li>若 <em>aspectRatioMode</em> is <a href="#AspectRatioMode-enum">Qt::KeepAspectRatioByExpanding </a>, 图像被缩放为一个尽可能小的矩形，在<em>size</em>之外，维持宽高比。</li>
</ul>
<p>若给定 <em>size</em> 为空，此函数返回 null 图像。</p>
<p><strong>另请参阅</strong> <a href="#isNull">isNull </a>() 和 <a href="#image-transformations">图像变换 </a>.</p>
<h3><span id="qimage-qimage-scaled-int-width-int-height-qt-aspectratiomode-aspectratiomode-qt-ignoreaspectratio-qt-transformationmode-transformmode-qt-fasttransformation-const">QImage:: scaled ( int <em>width</em> , int <em>height</em> , <em>aspectRatioMode</em> = Qt::IgnoreAspectRatio, <em>transformMode</em> = Qt::FastTransformation) const</span><a href="#qimage-qimage-scaled-int-width-int-height-qt-aspectratiomode-aspectratiomode-qt-ignoreaspectratio-qt-transformationmode-transformmode-qt-fasttransformation-const" class="header-anchor">#</a></h3><p>这是重载函数。</p>
<p>根据给定的<em>aspectRatioMode</em>和<em>transformMode</em>，将图像的副本按比例放大到给定的<em>width</em> 和<em>height</em> 的矩形。</p>
<p>若 <em>width</em> 或 <em>height</em> 为 0 或负数，此函数返回 null 图像。</p>
<h3><span id="qimage-qimage-scaledtoheight-int-height-qt-transformationmode-mode-qt-fasttransformation-const">QImage:: scaledToHeight ( int <em>height</em> , <em>mode</em> = Qt::FastTransformation) const</span><a href="#qimage-qimage-scaledtoheight-int-height-qt-transformationmode-mode-qt-fasttransformation-const" class="header-anchor">#</a></h3><p>返回图像的一个缩放副本。返回的图像使用指定的转换<em>mode</em> 被缩放到给定的<em>高度</em>。</p>
<p>这个函数会自动计算图像的宽度，以便保留图像的比例。</p>
<p>若给定 <em>height</em> 为 0 或负数，返回 null 图像。</p>
<p><strong>另请参阅</strong> <a href="#image-transformations">图像变换 </a>.</p>
<h3><span id="qimage-qimage-scaledtowidth-int-width-qt-transformationmode-mode-qt-fasttransformation-const">QImage:: scaledToWidth ( int <em>width</em> , <em>mode</em> = Qt::FastTransformation) const</span><a href="#qimage-qimage-scaledtowidth-int-width-qt-transformationmode-mode-qt-fasttransformation-const" class="header-anchor">#</a></h3><p>返回图像的一个缩放副本。返回的图像使用指定的转换<em>mode</em> ，被缩放到给定的<em>宽度</em>。</p>
<p>这个函数会自动计算图像的高度，这样它的长宽比就被保留了。</p>
<p>若给定 <em>width</em> 为 0 或负数，返回 null 图像。</p>
<p><strong>另请参阅</strong> <a href="#image-transformations">图像变换 </a>.</p>
<h3><span id="uchar-qimage-scanline-int-i">*QImage:: scanLine ( int <em>i</em> )</span><a href="#uchar-qimage-scanline-int-i" class="header-anchor">#</a></h3><p>返回索引为<em>i</em>的扫描线的像素数据的指针。第一个扫描线的索引是0。</p>
<p>扫描线数据至少是32位对齐的。对于64位格式，它遵循64位整数的本地对齐方式（大多数平台为64位，但在i386上明显为32位）。</p>
<p>例如，要去除图像中每个像素的绿色部分:</p>
<div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> y = <span class="hljs-number">0</span>; y &lt; image.<span class="hljs-built_in">height</span>(); ++y) {
    QRgb *line = <span class="hljs-built_in">reinterpret_cast</span>&lt;QRgb*&gt;(image.<span class="hljs-built_in">scanLine</span>(y));
    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> x = <span class="hljs-number">0</span>; x &lt; image.<span class="hljs-built_in">width</span>(); ++x) {
        QRgb &amp;rgb = line[x];
        rgb = <span class="hljs-built_in">qRgba</span>(<span class="hljs-built_in">qRed</span>(rgb), <span class="hljs-built_in">qGreen</span>(<span class="hljs-number">0</span>), <span class="hljs-built_in">qBlue</span>(rgb), <span class="hljs-built_in">qAlpha</span>(rgb));
    }
}</code></pre></div>

<p><strong>警告：</strong> 如果你要访问32-pp的图像数据，把返回的指针投给<code>QRgb* </code>(<a href="#QRgb-typedef">QRgb</a>有32位大小)，用它来读/写像素值。你不能直接使用<code>uchar* </code>指针，因为像素格式取决于底层平台的字节顺序。使用qRed(), qGreen(), qBlue(), 和qAlpha()来访问像素。</p>
<p><strong>另请参阅</strong> <a href="#bytesPerLine">bytesPerLine </a>(), <a href="#bits">bits </a>(), <a href="#pixel-manipulation">像素操纵 </a>，和 <a href="#constScanLine">constScanLine </a>().</p>
<h3><span id="const-uchar-qimage-scanline-int-i-const">const *QImage:: scanLine ( int <em>i</em> ) const</span><a href="#const-uchar-qimage-scanline-int-i-const" class="header-anchor">#</a></h3><p>这是重载函数。</p>
<h3><span id="void-qimage-setalphachannel-const-qimage-amp-alphachannel">void QImage:: setAlphaChannel (const &amp; <em>alphaChannel</em> )</span><a href="#void-qimage-setalphachannel-const-qimage-amp-alphachannel" class="header-anchor">#</a></h3><p>将此图像的 Alpha 通道设为给定 <em>alphaChannel</em> .</p>
<p>若<em>alphaChannel</em>是一个8位的alpha图像，则直接使用alpha值。否则，<em>alphaChannel</em>被转换为8位灰度，并使用像素值的强度。</p>
<p>如果图像已经有一个alpha通道，现有的alpha通道将与新的通道相乘。如果图像没有alpha通道，它将被转换为一个有alpha通道的格式。</p>
<p>操作类似于描绘<em>alphaChannel</em>作为此图像的alpha图像，使用<code>QPainter::CompositionMode_DestinationIn</code>。</p>
<p><strong>另请参阅</strong> <a href="#hasAlphaChannel">hasAlphaChannel </a>(), <a href="#image-transformations">图像变换 </a>，和 <a href="#image-formats">图像格式 </a>.</p>
<h3><span id="void-qimage-setcolor-int-index-qrgb-colorvalue">void QImage:: setColor ( int <em>index</em> , <em>colorValue</em> )</span><a href="#void-qimage-setcolor-int-index-qrgb-colorvalue" class="header-anchor">#</a></h3><p>设置颜色在给定 <em>index</em> 在颜色表中，到给定 <em>colorValue</em> 。颜色值是 ARGB 四元组。</p>
<p>若 <em>index</em> 超出颜色表当前大小，展开它采用 <a href="#setColorCount">setColorCount </a>().</p>
<p><strong>另请参阅</strong> <a href="#color">color </a>(), <a href="#colorCount">colorCount </a>(), <a href="#setColorTable">setColorTable </a>()，和 <a href="#pixel-manipulation">像素操纵 </a>.</p>
<h3><span id="void-qimage-setcolorcount-int-colorcount">void QImage:: setColorCount ( int <em>colorCount</em> )</span><a href="#void-qimage-setcolorcount-int-colorcount" class="header-anchor">#</a></h3><p>重置颜色表大小以包含 <em>colorCount</em> 条目。</p>
<p>若颜色表被展开，所有额外颜色将被设为透明 (即 <a href="#qRgba">qRgba </a>(0, 0, 0, 0)).</p>
<p>当使用图像时，颜色表必须足够大，以便有图像中存在的所有像素/索引值的条目，否则，结果就无法确定。</p>
<p><strong>另请参阅</strong> <a href="#colorCount">colorCount </a>(), <a href="#colorTable">colorTable </a>(), <a href="#setColor">setColor </a>()，和 <a href="#image-transformations">图像变换 </a>.</p>
<h3><span id="since-5-14-void-qimage-setcolorspace-const-qcolorspace-amp-colorspace"><code>[since 5.14] </code>void QImage:: setColorSpace (const &amp; <em>colorSpace</em> )</span><a href="#since-5-14-void-qimage-setcolorspace-const-qcolorspace-amp-colorspace" class="header-anchor">#</a></h3><p>将图像色彩空间设为 <em>colorSpace</em> 不对图像数据履行任何转换。</p>
<p>该函数在 Qt 5.14 引入。</p>
<p><strong>另请参阅</strong> <a href="#colorSpace">colorSpace </a>().</p>
<h3><span id="void-qimage-setcolortable-const-qlist-lt-qrgb-gt-amp-colors">void QImage:: setColorTable (const &lt; &gt; &amp; <em>colors</em> )</span><a href="#void-qimage-setcolortable-const-qlist-lt-qrgb-gt-amp-colors" class="header-anchor">#</a></h3><p>将用于翻译颜色索引的颜色表设为 <a href="#QRgb-typedef">QRgb </a>值，到指定 <em>colors</em> .</p>
<p>当使用图像时，颜色表必须足够大，以便有图像中存在的所有像素/索引值的条目，否则，结果就无法确定。</p>
<p><strong>另请参阅</strong> <a href="#colorTable">colorTable </a>(), <a href="#setColor">setColor </a>()，和 <a href="#image-transformations">图像变换 </a>.</p>
<h3><span id="void-qimage-setdevicepixelratio-qreal-scalefactor">void QImage:: setDevicePixelRatio ( <em>scaleFactor</em> )</span><a href="#void-qimage-setdevicepixelratio-qreal-scalefactor" class="header-anchor">#</a></h3><p>设置图像的设备像素比。这是图像像素和与设备无关的像素之间的比率。</p>
<p>默认scaleFactor是1.0。把它设置成其他的东西有两个效果。</p>
<p>在图像上打开的QPainters将被缩放。例如，在一个200x200的图像上绘画，如果比例为2.0，将导致有效的（与设备无关的）绘画范围为100x100。</p>
<p>Qt中基于图像尺寸计算布局几何的代码路径会考虑到这个比例。QSize layoutSize = image.size() / image.devicePixelRatio() 这样做的净效果是，图像被显示为高DPI图像，而不是大图像（参见绘制高分辨率版本的Pixmaps和图像）。</p>
<p><strong>另请参阅</strong> <a href="#devicePixelRatio">devicePixelRatio </a>() 和 <a href="#deviceIndependentSize">deviceIndependentSize </a>().</p>
<h3><span id="void-qimage-setdotspermeterx-int-x">void QImage:: setDotsPerMeterX ( int <em>x</em> )</span><a href="#void-qimage-setdotspermeterx-int-x" class="header-anchor">#</a></h3><p>设置水平方向上适合于一个物理米的像素数，为<em>x</em>。</p>
<p>与<a href="#dotsPerMeterY">dotsPerMeterY</a>()一起，这个数字定义了图像的预期比例和纵横比，并决定了<a href="qpainter.html">QPainter</a>在图像上绘制图形的比例。它不会改变图像在其他绘画设备上渲染时的比例或长宽比。</p>
<p><strong>另请参阅</strong> <a href="#dotsPerMeterX">dotsPerMeterX </a>() 和 <a href="#image-information">图像信息 </a>.</p>
<h3><span id="void-qimage-setdotspermetery-int-y">void QImage:: setDotsPerMeterY ( int <em>y</em> )</span><a href="#void-qimage-setdotspermetery-int-y" class="header-anchor">#</a></h3><p>将垂直方向上适合于一个物理米的像素数量设置为<em>y</em>。</p>
<p>与<a href="#dotsPerMeterX">dotsPerMeterX</a>()一起，这个数字定义了图像的预期比例和长宽比，并决定了<a href="qpainter.html">QPainter</a>在图像上绘制图形的比例。它不会改变图像在其他绘画设备上渲染时的比例或长宽比。</p>
<p><strong>另请参阅</strong> <a href="#dotsPerMeterY">dotsPerMeterY </a>() 和 <a href="#image-information">图像信息 </a>.</p>
<h3><span id="void-qimage-setoffset-const-qpoint-amp-offset">void QImage:: setOffset (const &amp; <em>offset</em> )</span><a href="#void-qimage-setoffset-const-qpoint-amp-offset" class="header-anchor">#</a></h3><p>设置图像相对于其他图像定位时要偏移的像素数，为<em>offset</em>。</p>
<p><strong>另请参阅</strong> <a href="#offset">offset </a>() 和 <a href="#image-information">图像信息 </a>.</p>
<h3><span id="void-qimage-setpixel-const-qpoint-amp-position-uint-index-or-rgb">void QImage:: setPixel (const &amp; <em>position</em> , <em>index_or_rgb</em> )</span><a href="#void-qimage-setpixel-const-qpoint-amp-position-uint-index-or-rgb" class="header-anchor">#</a></h3><p>设置像素索引或颜色在给定 <em>position</em> to <em>index_or_rgb</em> .</p>
<p>如果图像的格式是单色或调色板，给定的<em>index_or_rgb</em>值必须是图像颜色表中的一个索引，否则参数必须是一个<a href="#QRgb-typedef">QRgb</a>值。</p>
<p>如果<em>position</em>不是图像中的有效坐标对，或者如果<em>index_or_rgb</em>&gt;= <a href="#colorCount">colorCount </a>()，在单色和调色板图像的情况下，其结果是未定义。</p>
<p><strong>警告：</strong>由于调用内部的<code>detach()</code>函数，这个函数很昂贵；如果对性能有顾虑，我们建议使用<a href="#scanLine">scanLine</a>() 或 <a href="#bits">bits</a>()直接访问像素数据。</p>
<p><strong>另请参阅</strong> <a href="#pixel">pixel </a>() 和 <a href="#pixel-manipulation">像素操纵 </a>.</p>
<h3><span id="void-qimage-setpixel-int-x-int-y-uint-index-or-rgb">void QImage:: setPixel ( int <em>x</em> , int <em>y</em> , <em>index_or_rgb</em> )</span><a href="#void-qimage-setpixel-int-x-int-y-uint-index-or-rgb" class="header-anchor">#</a></h3><p>这是重载函数。</p>
<p>设置像素索引或颜色在 ( <em>x</em> , <em>y</em> ) 到 <em>index_or_rgb</em> .</p>
<h3><span id="since-5-6-void-qimage-setpixelcolor-const-qpoint-amp-position-const-qcolor-amp-color"><code>[since 5.6] </code>void QImage:: setPixelColor (const &amp; <em>position</em> , const &amp; <em>color</em> )</span><a href="#since-5-6-void-qimage-setpixelcolor-const-qpoint-amp-position-const-qcolor-amp-color" class="header-anchor">#</a></h3><p>设置颜色在给定 <em>position</em> to <em>color</em> .</p>
<p>如果<em>position</em>不是图像中的有效坐标对，或者图像的格式是单色或调色板，则结果是未定义的。</p>
<p><strong>警告：</strong>由于调用内部的<code>detach()</code>函数，这个函数很昂贵；如果对性能有顾虑，我们建议使用<a href="#scanLine">scanLine</a>() 或 <a href="#bits">bits</a>()直接访问像素数据。</p>
<p>该函数在 Qt 5.6 引入。</p>
<p><strong>另请参阅</strong> <a href="#pixelColor">pixelColor </a>(), <a href="#pixel">pixel </a>(), <a href="#bits">bits </a>(), <a href="#scanLine">scanLine </a>()，和 <a href="#pixel-manipulation">像素操纵 </a>.</p>
<h3><span id="since-5-6-void-qimage-setpixelcolor-int-x-int-y-const-qcolor-amp-color"><code>[since 5.6] </code>void QImage:: setPixelColor ( int <em>x</em> , int <em>y</em> , const &amp; <em>color</em> )</span><a href="#since-5-6-void-qimage-setpixelcolor-int-x-int-y-const-qcolor-amp-color" class="header-anchor">#</a></h3><p>这是重载函数。</p>
<p>设置像素颜色在 ( <em>x</em> , <em>y</em> ) 到 <em>color</em> .</p>
<p>该函数在 Qt 5.6 引入。</p>
<h3><span id="void-qimage-settext-const-qstring-amp-key-const-qstring-amp-text">void QImage:: setText (const &amp; <em>key</em> , const &amp; <em>text</em> )</span><a href="#void-qimage-settext-const-qstring-amp-key-const-qstring-amp-text" class="header-anchor">#</a></h3><p>将图像文本设为给定 <em>text</em> 并将其关联到给定 <em>key</em> .</p>
<p>若仅仅想要存储单文本块 (即：comment 或仅仅描述)，可以传递空键，或使用像 Description 的一般键。</p>
<p>图像文本被嵌入图像数据当调用 <a href="#save">save </a>() 或 <a href="#write">QImageWriter::write </a>().</p>
<p>并非所有图像格式都支持嵌入文本。可以找出哪些特定图像或格式支持嵌入文本通过使用 <a href="#supportsOption">QImageWriter::supportsOption </a>()。给出范例：</p>
<div class="code-wrapper"><pre><code class="hljs c++">QImageWriter writer;
writer.<span class="hljs-built_in">setFormat</span>(<span class="hljs-string">"png"</span>);
<span class="hljs-keyword">if</span> (writer.<span class="hljs-built_in">supportsOption</span>(QImageIOHandler::Description))
    <span class="hljs-built_in">qDebug</span>() &lt;&lt; <span class="hljs-string">"Png supports embedded text"</span>;</code></pre></div>

<p>可以使用 <a href="#supportedImageFormats">QImageWriter::supportedImageFormats </a>() 以找出哪些图像格式是可用的。</p>
<p><strong>另请参阅</strong> <a href="#text">text </a>() 和 <a href="#textKeys">textKeys </a>().</p>
<h3><span id="qsize-qimage-size-const">QImage:: size () const</span><a href="#qsize-qimage-size-const" class="header-anchor">#</a></h3><p>返回图片大小，即其 <a href="#width">width </a>() 和 <a href="#height">height </a>().</p>
<p><strong>另请参阅</strong> <a href="#image-information">图像信息 </a>and <a href="#deviceIndependentSize">deviceIndependentSize </a>().</p>
<h3><span id="since-5-10-qsizetype-qimage-sizeinbytes-const"><code>[since 5.10] </code>qsizetype QImage:: sizeInBytes () const</span><a href="#since-5-10-qsizetype-qimage-sizeinbytes-const" class="header-anchor">#</a></h3><p>返回图像数据大小 (以字节为单位)。</p>
<p>该函数在 Qt 5.10 引入。</p>
<p><strong>另请参阅</strong> <a href="#bytesPerLine">bytesPerLine </a>(), <a href="#bits">bits </a>()，和 <a href="#image-information">图像信息 </a>.</p>
<h3><span id="void-qimage-swap-qimage-amp-other">void QImage:: swap ( &amp; <em>other</em> )</span><a href="#void-qimage-swap-qimage-amp-other" class="header-anchor">#</a></h3><p>交换图像 <em>other</em> 与此图像。此操作非常快且从不失败。</p>
<h3><span id="qstring-qimage-text-const-qstring-amp-key-qstring-const">QImage:: text (const &amp; <em>key</em> = QString()) const</span><a href="#qstring-qimage-text-const-qstring-amp-key-qstring-const" class="header-anchor">#</a></h3><p>返回的图像文本关联给定 <em>key</em> 。若指定 <em>key</em> 是空字符串，返回整个图像文本，每个键文本对由换行符分隔。</p>
<p><strong>另请参阅</strong> <a href="#setText">setText </a>() 和 <a href="#textKeys">textKeys </a>().</p>
<h3><span id="qstringlist-qimage-textkeys-const">QImage:: textKeys () const</span><a href="#qstringlist-qimage-textkeys-const" class="header-anchor">#</a></h3><p>返回此图像的文本键。</p>
<p>你可以用这些键与<a href="#text">text</a>()一起使用，列出某个键的图像文本。</p>
<p><strong>另请参阅</strong> <a href="#text">text </a>().</p>
<h3><span id="cgimageref-qimage-tocgimage-const">CGImageRef QImage:: toCGImage () const</span><a href="#cgimageref-qimage-tocgimage-const" class="header-anchor">#</a></h3><p>创建 <code>CGImage </code>等效于此 <a href="qimage.html">QImage </a>.</p>
<p>返回 <code>CGImageRef </code>句柄。</p>
<p>返回的CGImageRef参与了<a href="qimage.html">QImage</a>的隐式共享，并持有对<a href="qimage.html">QImage</a>数据的引用。CGImage是不可改变的，永远不会脱离<a href="qimage.html">QImage</a>。对<a href="qimage.html">QImage</a>的写入将像往常一样分离。</p>
<p>此函数很快，且不会拷贝或转换图像数据。</p>
<p>支持以下图像格式，且会映射到相应本机图像类型：</p>
<table>
<thead>
<tr>
<th align="left">Qt</th>
<th align="left">CoreGraphics</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><a href="#Format-enum">Format_ARGB32</a></td>
<td align="left">kCGImageAlphaFirst | kCGBitmapByteOrder32Host</td>
</tr>
<tr>
<td align="left"><a href="#Format-enum">Format_RGB32</a></td>
<td align="left">kCGImageAlphaNoneSkipFirst | kCGBitmapByteOrder32Host</td>
</tr>
<tr>
<td align="left"><a href="#Format-enum">Format_RGBA8888_Premultiplied</a></td>
<td align="left">kCGImageAlphaPremultipliedLast | kCGBitmapByteOrder32Big</td>
</tr>
<tr>
<td align="left"><a href="#Format-enum">Format_RGBA8888</a></td>
<td align="left">kCGImageAlphaLast | kCGBitmapByteOrder32Big</td>
</tr>
<tr>
<td align="left"><a href="#Format-enum">Format_RGBX8888</a></td>
<td align="left">kCGImageAlphaNoneSkipLast | kCGBitmapByteOrder32Big</td>
</tr>
<tr>
<td align="left"><a href="#Format-enum">Format_ARGB32_Premultiplied</a></td>
<td align="left">kCGImageAlphaPremultipliedFirst | kCGBitmapByteOrder32Host</td>
</tr>
</tbody></table>
<p>其他格式不被支持；在这些情况下，这个函数返回一个空的CGImageRef。这个函数的用户可以先将<a href="qimage.html">QImage</a>转换成支持的格式，例如<a href="#Format-enum">Format_ARGB32_Premultiplied</a>。</p>
<p>CGImageRef 颜色空间被设为 sRGB 颜色空间。</p>
<h3><span id="since-6-0-hbitmap-qimage-tohbitmap-const"><code>[since 6.0] </code>HBITMAP QImage:: toHBITMAP () const</span><a href="#since-6-0-hbitmap-qimage-tohbitmap-const" class="header-anchor">#</a></h3><p>创建 <code>HBITMAP </code>相当于 <a href="qimage.html">QImage </a>.</p>
<p>返回 <code>HBITMAP </code>句柄。</p>
<p>调用者负责释放 <code>HBITMAP </code>数据在使用后。</p>
<p>对于使用标准的GDI调用，例如<code>BitBlt()</code>，图像应该具有<a href="#Format-enum">QImage::Format_RGB32 </a>的格式。</p>
<p>当在<code>AlphaBlend()</code>GDI函数中使用生成的HBITMAP时，图像的格式应该是<a href="#Format-enum">QImage::Format_ARGB32_Premultiplied</a>（使用<a href="#convertToFormat">convertToFormat</a>()）。</p>
<p>当使用产生的HBITMAP作为应用程序图标或系统托盘图标时，图像应该具有<a href="#Format-enum">QImage::Format_ARGB32 </a>的格式。</p>
<p>该函数在 Qt 6.0 引入。</p>
<p><strong>另请参阅</strong> <a href="#fromHBITMAP">fromHBITMAP </a>() 和 <a href="#convertToFormat">convertToFormat </a>().</p>
<h3><span id="since-6-0-hicon-qimage-tohicon-const-qimage-amp-mask-const"><code>[since 6.0] </code>HICON QImage:: toHICON (const &amp; <em>mask</em> = {}) const</span><a href="#since-6-0-hicon-qimage-tohicon-const-qimage-amp-mask-const" class="header-anchor">#</a></h3><p>创建 <code>HICON </code>相当于 <a href="qpixmap.html">QPixmap </a>, 应用掩码 <em>mask</em>  .</p>
<p>如果<em>mask</em>不是空的，它需要是<a href="#Format-enum">QImage::Format_Mono</a>的格式。返回 “HICON “的句柄。</p>
<p>调用者负责释放 <code>HICON </code>数据在使用后。</p>
<p>该函数在 Qt 6.0 引入。</p>
<p><strong>另请参阅</strong> <a href="#fromHICON">fromHICON </a>().</p>
<h3><span id="static-qimage-format-qimage-toimageformat-qpixelformat-format"><code>[static] </code>QImage:: toImageFormat ( <em>format</em> )</span><a href="#static-qimage-format-qimage-toimageformat-qpixelformat-format" class="header-anchor">#</a></h3><p>转换 <em>format</em> 成 <a href="#Format-enum">QImage::Format</a></p>
<h3><span id="static-qpixelformat-qimage-topixelformat-qimage-format-format"><code>[static] </code>QImage:: toPixelFormat ( <em>format</em> )</span><a href="#static-qpixelformat-qimage-topixelformat-qimage-format-format" class="header-anchor">#</a></h3><p>转换 <em>format</em> 成 <a href="qpixelformat.html">QPixelFormat</a></p>
<h3><span id="qimage-qimage-transformed-const-qtransform-amp-matrix-qt-transformationmode-mode-qt-fasttransformation-const">QImage:: transformed (const &amp; <em>matrix</em> , <em>mode</em> = Qt::FastTransformation) const</span><a href="#qimage-qimage-transformed-const-qtransform-amp-matrix-qt-transformationmode-mode-qt-fasttransformation-const" class="header-anchor">#</a></h3><p>返回一个使用给定的变换<em>matrix</em> 和变换<em>mode</em> 进行变换的图像的副本。</p>
<p>返回的图像通常具有与原图像相同的{图像格式}{format}。然而，复杂的变换可能会导致图像中并非所有像素都被原图像的变换像素所覆盖。在这种情况下，那些背景像素将被分配一个透明的颜色值，而转换后的图像将被赋予一个带有阿尔法通道的格式，即使原图像没有这个通道。</p>
<p>变换<em>矩阵</em>是内部调整的，以补偿不需要的平移；也就是说，产生的图像是包含原图像所有变换点的最小的图像。使用<a href="#trueMatrix">trueMatrix</a>()函数来检索用于转换图像的实际矩阵。</p>
<p>与其他重载不同，这个函数可以用来对图像进行透视变换。</p>
<p><strong>另请参阅</strong> <a href="#trueMatrix">trueMatrix </a>() 和 <a href="#image-transformations">图像变换 </a>.</p>
<h3><span id="static-qtransform-qimage-truematrix-const-qtransform-amp-matrix-int-width-int-height"><code>[static] </code>QImage:: trueMatrix (const &amp; <em>matrix</em> , int <em>width</em> , int <em>height</em> )</span><a href="#static-qtransform-qimage-truematrix-const-qtransform-amp-matrix-int-width-int-height" class="header-anchor">#</a></h3><p>返回用于变换图像的实际矩阵采用给定 <em>width</em> , <em>height</em> and <em>matrix</em> .</p>
<p>当使用<a href="#transformed">transformed</a>()函数转换图像时，转换矩阵会被内部调整以补偿不需要的平移，即<a href="#transformed">transformed</a>()返回包含原图像的所有转换点的最小图像。这个函数返回修改后的矩阵，它将原图像中的点正确地映射到新图像中。</p>
<p>与其他重载不同，这个函数创建的变换矩阵可以用来对图像进行透视变换。</p>
<p><strong>另请参阅</strong> <a href="#transformed">transformed </a>() 和 <a href="#image-transformations">图像变换 </a>.</p>
<h3><span id="bool-qimage-valid-const-qpoint-amp-pos-const">bool QImage:: valid (const &amp; <em>pos</em> ) const</span><a href="#bool-qimage-valid-const-qpoint-amp-pos-const" class="header-anchor">#</a></h3><p>返回 <code>true </code>if <em>pos</em> 是图像中的有效坐标对；否则返回 <code>false </code>.</p>
<p><strong>另请参阅</strong> <a href="#rect">rect </a>() 和 <a href="qrect.html#contains">QRect::contains </a>().</p>
<h3><span id="bool-qimage-valid-int-x-int-y-const">bool QImage:: valid ( int <em>x</em> , int <em>y</em> ) const</span><a href="#bool-qimage-valid-int-x-int-y-const" class="header-anchor">#</a></h3><p>这是重载函数。</p>
<p>返回 <code>true </code>if <a href="qpoint.html">QPoint </a>( <em>x</em> , <em>y</em> ) 是图像中的有效坐标对；否则返回 <code>false </code>.</p>
<h3><span id="int-qimage-width-const">int QImage:: width () const</span><a href="#int-qimage-width-const" class="header-anchor">#</a></h3><p>返回图像宽度。</p>
<p><strong>另请参阅</strong> <a href="#image-information">图像信息 </a>.</p>
<h3><span id="qvariant-qimage-operator-qvariant-const">QImage:: operator QVariant () const</span><a href="#qvariant-qimage-operator-qvariant-const" class="header-anchor">#</a></h3><p>将图像返回作为 <a href="qvariant.html">QVariant </a>.</p>
<h3><span id="bool-qimage-operator-const-qimage-amp-image-const">bool QImage:: operator!= (const &amp; <em>image</em> ) const</span><a href="#bool-qimage-operator-const-qimage-amp-image-const" class="header-anchor">#</a></h3><p>返回 <code>true </code>若此图像和给定 <em>image</em> 拥有不同内容；否则返回 <code>false </code>.</p>
<p>比较可能很慢，除非有一些明显差异 (譬如：不同宽度)，在这种情况下函数会快速返回。</p>
<p><strong>另请参阅</strong> <a href="#operator-eq">operator= </a>().</p>
<h3><span id="bool-qimage-operator-const-qimage-amp-image-const">bool QImage:: operator== (const &amp; <em>image</em> ) const</span><a href="#bool-qimage-operator-const-qimage-amp-image-const" class="header-anchor">#</a></h3><p>返回 <code>true </code>若此图像和给定 <em>image</em> 拥有相同内容；否则返回 <code>false </code>.</p>
<p>比较可能很慢，除非有一些明显差异 (如：不同大小或格式)，在这种情况下函数会快速返回。</p>
<p><strong>另请参阅</strong> <a href="#operator-eq">operator= </a>().</p>
<h2><span id="xiang-guan-fei-cheng-yuan">相关非成员</span><a href="#xiang-guan-fei-cheng-yuan" class="header-anchor">#</a></h2><h3><span id="since-5-0-qimagecleanupfunction"><code>[since 5.0] </code>QImageCleanupFunction</span><a href="#since-5-0-qimagecleanupfunction" class="header-anchor">#</a></h3><p>具有以下签名的函数，可用于实现基本图像内存管理：</p>
<div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">myImageCleanupHandler</span><span class="hljs-params">(<span class="hljs-type">void</span> *info)</span></span>;</code></pre></div>

<p>该 typedef 在 Qt 5.0 引入。</p>
<h3><span id="qdatastream-amp-operator-lt-lt-qdatastream-amp-stream-const-qimage-amp-image">&amp; operator&lt;&lt; ( &amp; <em>stream</em> , const &amp; <em>image</em> )</span><a href="#qdatastream-amp-operator-lt-lt-qdatastream-amp-stream-const-qimage-amp-image" class="header-anchor">#</a></h3><p>写入给定 <em>image</em> 到给定 <em>stream</em> 作为 PNG 图像，或作为 BMP 图像若流的版本为 1。注意：将流写入文件不会产生有效图像文件。</p>
<p><strong>另请参阅</strong> <a href="#save">QImage::save </a>() 和 <a href>序列化 Qt 数据类型 </a>.</p>
<h3><span id="qdatastream-amp-operator-gt-gt-qdatastream-amp-stream-qimage-amp-image">&amp; operator&gt;&gt; ( &amp; <em>stream</em> , &amp; <em>image</em> )</span><a href="#qdatastream-amp-operator-gt-gt-qdatastream-amp-stream-qimage-amp-image" class="header-anchor">#</a></h3><p>读取图像从给定 <em>stream</em> 并将它存储在给定 <em>image</em> .</p>
<p><strong>另请参阅</strong> <a href="#load">QImage::load </a>() 和 <a href>序列化 Qt 数据类型 </a>.</p>

            </div>
            <hr>
            <div>
              <div class="post-metas mb-3">
                
                
                  <div class="post-meta">
                    <i class="iconfont icon-tags"></i>
                    
                      <a class="hover-with-bg" href="/tags/I/">I</a>
                    
                  </div>
                
              </div>
              
                <p class="note note-warning">
                  
                    本博客所有文章除特别声明外，均采用 <a target="_blank" href="https://creativecommons.org/licenses/by-sa/4.0/deed.zh" rel="nofollow noopener noopener">CC BY-SA 4.0 协议</a> ，转载请注明出处！
                  
                </p>
              
              
                <div class="post-prevnext">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/2022/03/02/QtDocumentCN/Src/I/QImageIOHandler/QImageIOHandler/">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">QImageIOHandler类</span>
                        <span class="visible-mobile">上一篇</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2022/03/02/QtDocumentCN/Src/I/QImageCapture/QImageCapture/">
                        <span class="hidden-mobile">QImageCapture类</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
              <!-- Comments -->
              <article class="comments" id="comments" lazyload>
                
                  
                
                
  <div id="lv-container" data-id="city" data-uid="MTAyMC81NTMzMi8zMTc5OQ==">
    <script type="text/javascript">
      Fluid.utils.loadComments('#lv-container', function() {
        Fluid.utils.createScript('https://cdn-city.livere.com/js/embed.dist.js');
      });
    </script>
    <noscript>Please enable JavaScript to view the comments</noscript>
  </div>


              </article>
            
          </article>
        </div>
      </div>
    </div>
    
      <div class="d-none d-lg-block col-lg-2 toc-container" id="toc-ctn">
        <div id="toc">
  <p class="toc-header"><i class="iconfont icon-list"></i>&nbsp;目录</p>
  <div class="toc-body" id="toc-body"></div>
</div>

      </div>
    
  </div>
</div>

<!-- Custom -->


    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v"
                 for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>
    

    
  </main>

  <footer class="text-center mt-5 py-3">
  <div class="footer-content">
     <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> 
  </div>
  

  

  
</footer>


  <!-- SCRIPTS -->
  
  <script  src="https://cdn.jsdelivr.net/npm/nprogress@0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/nprogress@0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js" ></script>
<script  src="https://cdn.jsdelivr.net/npm/bootstrap@4/dist/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>

<!-- Plugins -->


  <script  src="/js/local-search.js" ></script>



  
    <script  src="/js/img-lazyload.js" ></script>
  



  



  
    <script  src="https://cdn.jsdelivr.net/npm/tocbot@4/dist/tocbot.min.js" ></script>
  
  
    <script  src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3/dist/jquery.fancybox.min.js" ></script>
  
  
    <script  src="https://cdn.jsdelivr.net/npm/anchor-js@4/anchor.min.js" ></script>
  
  
    <script defer src="https://cdn.jsdelivr.net/npm/clipboard@2/dist/clipboard.min.js" ></script>
  






  <script  src="https://cdn.jsdelivr.net/npm/typed.js@2/lib/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var title = document.getElementById('subtitle').title;
      
        typing(title);
      
    })(window, document);
  </script>















<!-- 主题的启动项 保持在最底部 -->
<script  src="/js/boot.js" ></script>


</body>
</html>
