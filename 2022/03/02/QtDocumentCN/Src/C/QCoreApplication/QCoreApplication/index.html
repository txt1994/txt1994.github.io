

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=auto>



<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/logo.jpg">
  <link rel="icon" href="/img/logo.jpg">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
    <meta http-equiv="Content-Security-Policy" content="upgrade-insecure-requests">
  
  <meta name="theme-color" content="#6aa84f">
  <meta name="author" content="John Doe">
  <meta name="keywords" content="">
  
    <meta name="description" content="QCoreApplication 类 属性 公共成员函数 详细说明 事件循环及事件处理 程序和库路径 国际化和翻译 访问命令行参数 区域设置 属性文档 applicationName : QString applicationVersion: QString organizationDomain: QString organizationName: QString quitLockEna">
<meta property="og:type" content="article">
<meta property="og:title" content="QCoreApplication类">
<meta property="og:url" content="https://txt1994.github.io/2022/03/02/QtDocumentCN/Src/C/QCoreApplication/QCoreApplication/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:description" content="QCoreApplication 类 属性 公共成员函数 详细说明 事件循环及事件处理 程序和库路径 国际化和翻译 访问命令行参数 区域设置 属性文档 applicationName : QString applicationVersion: QString organizationDomain: QString organizationName: QString quitLockEna">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2022-03-02T05:27:47.000Z">
<meta property="article:modified_time" content="2022-03-18T16:37:13.234Z">
<meta property="article:author" content="John Doe">
<meta property="article:tag" content="C">
<meta name="twitter:card" content="summary_large_image">
  
  
  <title>QCoreApplication类 - Hexo</title>

  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4/dist/css/bootstrap.min.css" />


  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/github-markdown-css@4/github-markdown.min.css" />
  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/hint.css@2/hint.min.css" />

  
    
    
      
      <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@10/styles/github-gist.min.css" />
    
  

  
    <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3/dist/jquery.fancybox.min.css" />
  


<!-- 主题依赖的图标库，不要自行修改 -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_ba1fz6golrf.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_lbnruvf0jn.css">


<link  rel="stylesheet" href="/css/main.css" />

<!-- 自定义样式保持在最底部 -->

  
<link rel="stylesheet" href="/css/style.css">



  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    var CONFIG = {"hostname":"txt1994.github.io","root":"/","version":"1.8.14","typing":{"enable":true,"typeSpeed":70,"cursorChar":"_","loop":false},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"right","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"copy_btn":true,"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":false,"baidu":null,"google":null,"gtag":null,"tencent":{"sid":null,"cid":null},"woyaola":null,"cnzz":null,"leancloud":{"app_id":null,"app_key":null,"server_url":null,"path":"window.location.pathname","ignore_local":false}},"search_path":"/local-search.xml"};
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
<meta name="generator" content="Hexo 6.1.0">
<style>.github-emoji { position: relative; display: inline-block; width: 1.2em; min-height: 1.2em; overflow: hidden; vertical-align: top; color: transparent; }  .github-emoji > span { position: relative; z-index: 10; }  .github-emoji img, .github-emoji .fancybox { margin: 0 !important; padding: 0 !important; border: none !important; outline: none !important; text-decoration: none !important; user-select: none !important; cursor: auto !important; }  .github-emoji img { height: 1.2em !important; width: 1.2em !important; position: absolute !important; left: 50% !important; top: 50% !important; transform: translate(-50%, -50%) !important; user-select: none !important; cursor: auto !important; } .github-emoji-fallback { color: inherit; } .github-emoji-fallback img { opacity: 0 !important; }</style>
</head>


<body>
  <header style="height: 70vh;">
    <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/">
      <strong>txt1994s</strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/">
                <i class="iconfont icon-home-fill"></i>
                首页
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/">
                <i class="iconfont icon-archive-fill"></i>
                归档
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/">
                <i class="iconfont icon-tags-fill"></i>
                标签
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/">
                <i class="iconfont icon-user-fill"></i>
                关于
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/links/">
                <i class="iconfont icon-link-fill"></i>
                友联
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              &nbsp;<i class="iconfont icon-search"></i>&nbsp;
            </a>
          </li>
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">&nbsp;<i
                class="iconfont icon-dark" id="color-toggle-icon"></i>&nbsp;</a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

    <div class="banner" id="banner" parallax=true
         style="background: url('/img/default.png') no-repeat center center;
           background-size: cover;">
      <div class="full-bg-img">
        <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
          <div class="page-header text-center fade-in-up">
            <span class="h2" id="subtitle" title="QCoreApplication类">
              
            </span>

            
              <div class="mt-3">
  
  
    <span class="post-meta">
      <i class="iconfont icon-date-fill" aria-hidden="true"></i>
      <time datetime="2022-03-02 13:27" pubdate>
        2022年3月2日 下午
      </time>
    </span>
  
</div>

<div class="mt-1">
  
    <span class="post-meta mr-2">
      <i class="iconfont icon-chart"></i>
      20k 字
    </span>
  

  
    <span class="post-meta mr-2">
      <i class="iconfont icon-clock-fill"></i>
      
      
      164 分钟
    </span>
  

  
  
</div>

            
          </div>

          
        </div>
      </div>
    </div>
  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="d-none d-lg-block col-lg-2"></div>
    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div class="py-5" id="board">
          <article class="post-content mx-auto">
            <!-- SEO header -->
            <h1 style="display: none">QCoreApplication类</h1>
            
              <p class="note note-info">
                
                  本文最后更新于：2022年3月19日 凌晨
                
              </p>
            
            <div class="markdown-body">
              <div class="toc">

<!-- toc -->

<ul>
<li><a href="#qcoreapplication-lei">QCoreApplication 类</a><ul>
<li><a href="#shu-xing">属性</a></li>
<li><a href="#gong-gong-cheng-yuan-han-shu">公共成员函数</a></li>
<li><a href="#xiang-xi-shuo-ming">详细说明</a></li>
<li><a href="#shi-jian-xun-huan-ji-shi-jian-chu-li">事件循环及事件处理</a></li>
<li><a href="#cheng-xu-he-ku-lu-jing">程序和库路径</a></li>
<li><a href="#guo-ji-hua-he-fan-yi">国际化和翻译</a></li>
<li><a href="#fang-wen-ming-ling-xing-can-shu">访问命令行参数</a></li>
<li><a href="#qu-yu-she-zhi">区域设置</a></li>
<li><a href="#shu-xing-wen-dang">属性文档</a><ul>
<li><a href="#applicationname-qstring-s-qstring-qstring-md">applicationName : </a><a href="../../S/QString/QString.md">QString</a></li>
<li><a href="#applicationversion-qstring-s-qstring-qstring-md">applicationVersion: </a><a href="../../S/QString/QString.md">QString</a></li>
<li><a href="#organizationdomain-qstring-s-qstring-qstring-md">organizationDomain: </a><a href="../../S/QString/QString.md">QString</a></li>
<li><a href="#organizationname-qstring-s-qstring-qstring-md">organizationName: </a><a href="../../S/QString/QString.md">QString</a></li>
<li><a href="#quitlockenabled-bool">quitLockEnabled: bool</a></li>
</ul>
</li>
<li><a href="#cheng-yuan-han-shu-wen-dang">成员函数文档</a><ul>
<li><a href="#qcoreapplication-qcoreapplication-int-argc-char-argv">QCoreApplication::QCoreApplication(int &amp;<em>argc</em>, char **<em>argv</em>)</a></li>
<li><a href="#void-qcoreapplication-abouttoquit-signal">void QCoreApplication::aboutToQuit() [signal]</a></li>
<li><a href="#void-qcoreapplication-quit-static-slot">void QCoreApplication::quit() [static slot]</a></li>
<li><a href="#qcoreapplication-qcoreapplication-virtual">QCoreApplication::~QCoreApplication() [virtual]</a></li>
<li><a href="#void-qcoreapplication-addlibrarypath-const-qstring-s-qstring-qstring-md-path-static">void QCoreApplication::addLibraryPath(const </a><a href="../../S/QString/QString.md">QString</a> &amp;<em>path</em>) [static]</li>
<li><a href="#qstring-s-qstring-qstring-md-qcoreapplication-applicationdirpath-static">QString</a></li>
<li><a href="#qstring-s-qstring-qstring-md-qcoreapplication-applicationfilepath-static-1">QString</a></li>
<li><a href="#qint64-g-qtglobal-qtglobal-md-qcoreapplication-applicationpid-static">qint64</a></li>
<li><a href="#qstringlist-s-qstringlist-qstringlist-md-qcoreapplication-arguments-static">QStringList</a></li>
<li><a href="#bool-qcoreapplication-closingdown-static">bool QCoreApplication::closingDown() [static]</a></li>
<li><a href="#bool-qcoreapplication-event-qevent-e-qevent-qevent-md-e-override-virtual-protected">bool QCoreApplication::event(</a><a href="../../E/QEvent/QEvent.md">QEvent</a> *<em>e</em>) [override virtual protected]</li>
<li><a href="#qabstracteventdispatcher-a-qabstracteventdispatcher-qabstracteventdispatcher-md-qcoreapplication-eventdispatcher-static">QAbstractEventDispatcher</a></li>
<li><a href="#int-qcoreapplication-exec-static">int QCoreApplication::exec() [static]</a></li>
<li><a href="#void-qcoreapplication-exit-int-returncode-0-static">void QCoreApplication::exit(int <em>returnCode</em> = 0) [static]</a></li>
<li><a href="#void-qcoreapplication-installnativeeventfilter-qabstractnativeeventfilter-a-qabstractnativeeventfilter-qabstractnativeeventfilter-md-filterobj">void QCoreApplication::installNativeEventFilter(</a><a href="../../A/QAbstractNativeEventFilter/QAbstractNativeEventFilter.md">QAbstractNativeEventFilter</a> *<em>filterObj</em>)</li>
<li><a href="#bool-qcoreapplication-installtranslator-qtranslator-t-qtranslator-qtranslator-md-translationfile-static">bool QCoreApplication::installTranslator(</a><a href="../../T/QTranslator/QTranslator.md">QTranslator</a> *<em>translationFile</em>) [static]</li>
<li><a href="#qcoreapplication-qcoreapplication-md-qcoreapplication-instance-static">QCoreApplication</a></li>
<li><a href="#bool-qcoreapplication-issetuidallowed-static">bool QCoreApplication::isSetuidAllowed() [static]</a></li>
<li><a href="#qstringlist-s-qstringlist-qstringlist-md-qcoreapplication-librarypaths-static-1">QStringList</a></li>
<li><a href="#bool-qcoreapplication-notify-qobject-o-qobject-qobject-md-receiver-qevent-e-qevent-qevent-md-event-virtual">bool QCoreApplication::notify(</a><a href="../../O/QObject/QObject.md">QObject</a> <em><em>receiver</em>, <a href="../../E/QEvent/QEvent.md">QEvent</a></em> <em>event</em>) [virtual]</li>
<li><a href="#void-qcoreapplication-postevent-qobject-o-qobject-qobject-md-receiver-qevent-e-qevent-qevent-md-event-int-priority-qt-normaleventpriority-static">void QCoreApplication::postEvent(</a><a href="../../O/QObject/QObject.md">QObject</a>* <em>receiver</em>, <a href="../../E/QEvent/QEvent.md">QEvent</a>* <em>event</em>, int <em>priority</em> = Qt::NormalEventPriority) [static]</li>
<li><a href="#void-qcoreapplication-processevents-qeventloop-processeventsflags-https-doc-qt-io-qt-5-qeventloop-html-processeventsflag-enum-flags-qeventloop-allevents-static">void QCoreApplication::processEvents(</a><a target="_blank" rel="noopener" href="https://doc.qt.io/qt-5/qeventloop.html#ProcessEventsFlag-enum">QEventLoop::ProcessEventsFlags</a> <em>flags</em> = QEventLoop::AllEvents) [static]</li>
<li><a href="#void-qcoreapplication-processevents-qeventloop-processeventsflags-https-doc-qt-io-qt-5-qeventloop-html-processeventsflag-enum-flags-qeventloop-allevents-int-ms-static">void QCoreApplication::processEvents(</a><a target="_blank" rel="noopener" href="https://doc.qt.io/qt-5/qeventloop.html#ProcessEventsFlag-enum">QEventLoop::ProcessEventsFlags</a> <em>flags</em> = QEventLoop::AllEvents, int <em>ms</em>) [static]</li>
<li><a href="#void-qcoreapplication-removelibrarypath-const-qstring-s-qstring-qstring-md-path-static">void QCoreApplication::removeLibraryPath(const </a><a href="../../S/QString/QString.md">QString</a> &amp;<em>path</em>) [static]</li>
<li><a href="#void-qcoreapplication-removenativeeventfilter-qabstractnativeeventfilter-a-qabstractnativeeventfilter-qabstractnativeeventfilter-md-filterobject">void QCoreApplication::removeNativeEventFilter(</a><a href="../../A/QAbstractNativeEventFilter/QAbstractNativeEventFilter.md">QAbstractNativeEventFilter</a> *<em>filterObject</em>)</li>
<li><a href="#void-qcoreapplication-removepostedevents-qobject-o-qobject-qobject-md-receiver-int-eventtype-0-static">void QCoreApplication::removePostedEvents(</a><a href="../../O/QObject/QObject.md">QObject</a> *<em>receiver</em>, int <em>eventType</em> = 0) [static]</li>
<li><a href="#bool-qcoreapplication-removetranslator-qtranslator-translationfile-static">bool QCoreApplication::removeTranslator(</a><a href>QTranslator</a> *translationFile) [static]</li>
<li><a href="#bool-qcoreapplication-sendevent-qobject-o-qobject-qobject-md-receiver-qevent-event-static">bool QCoreApplication::sendEvent(</a><a href="../../O/QObject/QObject.md">QObject</a> *receiver, <a href>QEvent</a> *event) [static]</li>
<li><a href="#void-qcoreapplication-sendpostedevents-qobject-o-qobject-qobject-md-receiver-nullptr-int-event-type-0-static">void QCoreApplication::sendPostedEvents(</a><a href="../../O/QObject/QObject.md">QObject</a> *receiver = nullptr, int event_type = 0) [static]</li>
<li><a href="#void-qcoreapplication-setattribute-qt-applicationattribute-attribute-bool-on-true-static">void QCoreApplication::setAttribute(</a><a href>Qt::ApplicationAttribute</a> attribute, bool on = true) [static]</li>
<li><a href="#void-qcoreapplication-seteventdispatcher-qabstracteventdispatcher-eventdispatcher-static">void QCoreApplication::setEventDispatcher(</a><a href>QAbstractEventDispatcher</a> *eventDispatcher) [static]</li>
<li><a href="#void-qcoreapplication-setlibrarypaths-const-qstringlist-paths-static">void QCoreApplication::setLibraryPaths(const </a><a href>QStringList</a> &amp;paths) [static]</li>
<li><a href="#void-qcoreapplication-setsetuidallowed-bool-allow-static">void QCoreApplication::setSetuidAllowed(bool allow) [static]</a></li>
<li><a href="#bool-qcoreapplication-startingup">bool QCoreApplication::startingUp()</a></li>
<li><a href="#bool-qcoreapplication-testattribute-qt-applicationattribute-attribute-static">bool QCoreApplication::testAttribute(</a><a href>Qt::ApplicationAttribute</a> attribute) [static]</li>
<li><a href="#qstring-qcoreapplication-translate-const-char-context-const-char-sourcetext-const-char-disambiguation-nullptr-int-n-1-static-2">QString</a></li>
</ul>
</li>
<li><a href="#xiang-guan-fei-cheng-yuan-han-shu">相关非成员函数</a><ul>
<li><a href="#void-qaddpostroutine-qtcleanupfunction-ptr">void qAddPostRoutine(QtCleanUpFunction ptr)</a></li>
<li><a href="#void-qremovepostroutine-qtcleanupfunction-ptr">void qRemovePostRoutine(QtCleanUpFunction ptr)</a></li>
</ul>
</li>
<li><a href="#hong-wen-dang">宏文档</a><ul>
<li><a href="#q-coreapp-startup-function-qtstartupfunction-ptr">Q_COREAPP_STARTUP_FUNCTION(QtStartUpFunction ptr)</a></li>
<li><a href="#q-declare-tr-functions-context">Q_DECLARE_TR_FUNCTIONS(context)</a></li>
</ul>
</li>
</ul>
</li>
</ul>
<!-- tocstop -->

</div>

<h1><span id="qcoreapplication-lei">QCoreApplication 类</span><a href="#qcoreapplication-lei" class="header-anchor">#</a></h1><p>QCoreApplication类为没有UI的Qt程序提供了一个事件循环。</p>
<table>
<thead>
<tr>
<th align="right">属性</th>
<th align="left">方法</th>
</tr>
</thead>
<tbody><tr>
<td align="right">头文件</td>
<td align="left"><code>#include&lt;QCoreApplication&gt;</code></td>
</tr>
<tr>
<td align="right">qmake</td>
<td align="left"><code>QT+=core</code></td>
</tr>
<tr>
<td align="right">自从</td>
<td align="left">Qt 4.6</td>
</tr>
<tr>
<td align="right">继承</td>
<td align="left"><a href="../../O/QObject/QObject.md">QObject</a></td>
</tr>
<tr>
<td align="right">派生</td>
<td align="left"><a href="../../G/QGuiApplication/QGuiApplication.md">QGuiApplication</a></td>
</tr>
</tbody></table>
<h2><span id="shu-xing">属性</span><a href="#shu-xing" class="header-anchor">#</a></h2><table>
<thead>
<tr>
<th align="left">属性</th>
<th>类型</th>
<th>属性</th>
<th>类型</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><a href="#currentloop--const-int">applicationName</a></td>
<td>QString</td>
<td><a href="#duration--const-int">organizationName</a></td>
<td>QString</td>
</tr>
<tr>
<td align="left"><a href="#currenttime--int">applicationVersion</a></td>
<td>QString</td>
<td><a href="#loopcount--int">quitLockEnabled</a></td>
<td>QString</td>
</tr>
<tr>
<td align="left"><a href="#direction--direction">organizationDomain</a></td>
<td>QString</td>
<td></td>
<td></td>
</tr>
</tbody></table>
<h2><span id="gong-gong-cheng-yuan-han-shu">公共成员函数</span><a href="#gong-gong-cheng-yuan-han-shu" class="header-anchor">#</a></h2><h2><span id="xiang-xi-shuo-ming">详细说明</span><a href="#xiang-xi-shuo-ming" class="header-anchor">#</a></h2><p>此类为那些没有GUI的应用程序提供消息循环。对于使用Qt但无GUI的程序，它们必须有且仅有一个QCoreApplication对象。对于GUI应用程序，请参见<a href="../../G/QGuiApplication/QGuiApplication.md">QGuiApplication</a>。对于使用了Qt Widgets的模块，请参见<a href="../../A/QApplication/QApplication.md">QApplication</a>。</p>
<p>QCoreApplication包含主事件循环，这些来自于操作系统（如定时器、网络事件等）及其它来源的事件将由它来处理和派发。它同时也处理应用程序的初始化和析构，以及全系统和全程序的设置。</p>
<h2><span id="shi-jian-xun-huan-ji-shi-jian-chu-li">事件循环及事件处理</span><a href="#shi-jian-xun-huan-ji-shi-jian-chu-li" class="header-anchor">#</a></h2><p>消息循环从调用exec()开始。长时间运行的一些操作也可以通过调用processEvents()让程序保持响应。</p>
<p>一般地，我们建议您尽可能早地在您的main()函数中创建QCoreApplication、<a href="../../G/QGuiApplication/QGuiApplication.md">QGuiApplication</a>或<a href="../../A/QApplication/QApplication.md">QApplication</a>。当消息循环退出时，例如当quit()被调用时，exec()才会返回。</p>
<p>我们也提供了一些便捷的静态函数。QCoreApplication对象能够通过instance()来获取。您可以通过sendEvent()来发送事件，以及通过postEvent()来投送事件。待处理的事件能通过removePostedEvents()来移除，亦可通过sendPostedEvents()来派发。</p>
<p>此类提供了一个槽函数quit()及一个信号aboutToQuit()。</p>
<h2><span id="cheng-xu-he-ku-lu-jing">程序和库路径</span><a href="#cheng-xu-he-ku-lu-jing" class="header-anchor">#</a></h2><p>一个应用程序有一个applicationDirPath()和一个applicationFilePath()。库路径(参见<a href="../../L/QLibrary/QLibrary.md">QLibrary</a>)能通过libraryPaths()被获取，且能通过setLibraryPaths()、addLibraryPath()和removeLibraryPath()来对它进行操作。</p>
<h2><span id="guo-ji-hua-he-fan-yi">国际化和翻译</span><a href="#guo-ji-hua-he-fan-yi" class="header-anchor">#</a></h2><p>翻译文件能分别通过<a href>installTranslator</a>()和<a href>removeTranslator</a>()被加载和移除。您可以通过<a href>translate</a>()来翻译应用中的字符串。<a href>QObject::tr</a>()和QObject::trUtf8()这两个函数根据translate()来进行了实现。</p>
<h2><span id="fang-wen-ming-ling-xing-can-shu">访问命令行参数</span><a href="#fang-wen-ming-ling-xing-can-shu" class="header-anchor">#</a></h2><p>您应该通过arguments()来获取传递给QCoreApplication构造函数的命令行参数。</p>
<p>注意：QCoreApplication将移除 <strong>-qmljsdebugger=”…”</strong> 选项。它会解析 <strong>qmljsdebugger</strong> 参数，然后删除此选项及其参数。</p>
<p>对于一些更加高级的命令行参数的处理，请创建一个<a href="../QCommandLineParser/QCommandLineParser.md">QCommandLineParser</a>。</p>
<h2><span id="qu-yu-she-zhi">区域设置</span><a href="#qu-yu-she-zhi" class="header-anchor">#</a></h2><p>运行在Unix/Linux的Qt程序，将会默认使用系统的区域设置。这可能会导致在使用POSIX函数时发生冲突，例如，数据类型转换时由转换浮点数转换为字符串，由于不同区域符号的差异可能会导致一些冲突。为了解决这个问题，在初始化<a href="../../G/QGuiApplication/QGuiApplication.md">QGuiApplication</a>、<a href="../../A/QApplication/QApplication.md">QApplication</a>或QCoreApplication之后，需要马上调用POSIX函数**setlocale(LC_NUMERIC, “C”)**，以重新将数字的格式设置为”C”-locale。</p>
<p>另请参阅<a href="../../G/QGuiApplication/QGuiApplication.md">QGuiApplication</a>, <a href="../../A/QAbstractEventDispatcher/QAbstractEventDispatcher.md">QAbstractEventDispatcher</a>, <a href="../../E/QEventLoop/QEventLoop.md">QEventLoop</a>, [Semaphores Example](../../S/Semaphorse Example/Semaphores Example.md), 以及[Wait Conditions Example](../../W/Wait Conditions Example/Wait Conditions Example.md)。</p>
<h2><span id="shu-xing-wen-dang">属性文档</span><a href="#shu-xing-wen-dang" class="header-anchor">#</a></h2><h3><span id="applicationname-qstring">applicationName : </span><a href="#applicationname-qstring" class="header-anchor">#</a></h3><p>此属性保存应用程序的名字。</p>
<p>当使用空的构造函数初始化<a href="../../S/QSettings/QSettings.md">QSettings</a>类的实例时，此属性被使用。这样一来，每次创建<a href="../../S/QSettings/QSettings.md">QSettings</a>对象时，都不必重复此信息。</p>
<p>如果未设置，则应用程序名称默认为可执行文件名称（自5.0开始）。</p>
<p><strong>访问函数：</strong></p>
<table>
<thead>
<tr>
<th>QString</th>
<th><strong>applicationName</strong>()</th>
</tr>
</thead>
<tbody><tr>
<td>void</td>
<td><strong>setApplicationName</strong>(const QString &amp;<em>application</em>)</td>
</tr>
</tbody></table>
<p><strong>通知信号：</strong></p>
<table>
<thead>
<tr>
<th>void</th>
<th><strong>applicationNameChanged</strong>()</th>
</tr>
</thead>
<tbody><tr>
<td></td>
<td></td>
</tr>
</tbody></table>
<p>另请参阅 <a target="_blank" rel="noopener" href="https://doc.qt.io/qt-5/qcoreapplication.html#organizationName-prop">organizationName</a>, <a target="_blank" rel="noopener" href="https://doc.qt.io/qt-5/qcoreapplication.html#organizationDomain-prop">organizationDomain</a>, <a target="_blank" rel="noopener" href="https://doc.qt.io/qt-5/qcoreapplication.html#applicationVersion-prop">applicationVersion</a>, 以及 <a target="_blank" rel="noopener" href="https://doc.qt.io/qt-5/qcoreapplication.html#applicationFilePath">applicationFilePath</a>()。</p>
<h3><span id="applicationversion-qstring">applicationVersion: </span><a href="#applicationversion-qstring" class="header-anchor">#</a></h3><p>此属性保存应用程序的版本。</p>
<p>如果没有设置此属性，那么此属性将会被默认设置为平台相关的值，该值由主应用程序的可执行文件或程序包确定（自Qt 5.9起）：</p>
<table>
<thead>
<tr>
<th align="center">平台</th>
<th align="center">源</th>
</tr>
</thead>
<tbody><tr>
<td align="center">Windows (经典桌面)</td>
<td align="center">VERSIONINFO 资源中的 PRODUCTVERSION 参数</td>
</tr>
<tr>
<td align="center">Windows通用应用平台(UWP)</td>
<td align="center">应用程序包中清单文件的版本属性</td>
</tr>
<tr>
<td align="center">macOS, iOS, tvOS, watchOS</td>
<td align="center">信息属性列表中的CFBundleVersion属性</td>
</tr>
<tr>
<td align="center">Android</td>
<td align="center">AndroidManifest.xml清单中的android:versionName属性</td>
</tr>
</tbody></table>
<p>在其他平台上，此属性默认值为空字符串。</p>
<p>此属性自Qt 4.4引入。</p>
<p><strong>访问函数：</strong></p>
<table>
<thead>
<tr>
<th>QString</th>
<th><strong>applicationVersion</strong>()</th>
</tr>
</thead>
<tbody><tr>
<td>void</td>
<td><strong>setApplicationVersion</strong>(const QString &amp;<em>version</em>)</td>
</tr>
</tbody></table>
<p><strong>通知信号：</strong></p>
<table>
<thead>
<tr>
<th>void</th>
<th><strong>applicationVersionChanged</strong>()</th>
</tr>
</thead>
<tbody><tr>
<td></td>
<td></td>
</tr>
</tbody></table>
<p>另请参阅<a href>applicationName</a>,  <a href>organizationName</a>, 以及<a href>organizationDomain</a>。</p>
<h3><span id="organizationdomain-qstring">organizationDomain: </span><a href="#organizationdomain-qstring" class="header-anchor">#</a></h3><p>此属性保存编写此应用程序的组织的Internet域。</p>
<p>当使用空的构造函数初始化<a href="../../S/QSettings/QSettings.md">QSettings</a>类的实例时，此属性被使用。这样一来，每次创建<a href="../../S/QSettings/QSettings.md">QSettings</a>对象时，都不必重复此信息。</p>
<p>在Mac上，如果organizationDomain()不是一个空值，那么<a href="../../S/QSettings/QSettings.md">QSettings</a>将会使用它；否则它将会使用<a href>organizatioName</a>()。在其他平台上，<a href="../../S/QSettings/QSettings.md">QSettings</a>将<a href>organizationName</a>()作为组织名来使用。</p>
<p><strong>访问函数：</strong></p>
<table>
<thead>
<tr>
<th>QString</th>
<th><strong>organizationDomain</strong>()</th>
</tr>
</thead>
<tbody><tr>
<td>void</td>
<td><strong>setOrganizationDomain</strong>(const QString &amp;<em>orgDomain</em>)</td>
</tr>
</tbody></table>
<p><strong>通知信号：</strong></p>
<table>
<thead>
<tr>
<th>void</th>
<th><strong>organizationDomainChanged</strong>()</th>
</tr>
</thead>
<tbody><tr>
<td></td>
<td></td>
</tr>
</tbody></table>
<p>另请参阅 <a href>organizationName</a>, <a href>applicationName</a>, 以及<a href>applicationVersion</a>。</p>
<h3><span id="organizationname-qstring">organizationName: </span><a href="#organizationname-qstring" class="header-anchor">#</a></h3><p>此属性保存编写此应用程序的组织名。</p>
<p>当使用空的构造函数初始化<a href="../../S/QSettings/QSettings.md">QSettings</a>类的实例时，此属性被使用。这样一来，每次创建<a href="../../S/QSettings/QSettings.md">QSettings</a>对象时，都不必重复此信息。</p>
<p>在Mac上，如果organizationDomain()不是一个空值，那么<a href="../../S/QSettings/QSettings.md">QSettings</a>将会使用它；否则它将会使用<a href>organizatioName</a>()。在其他平台上，<a href="../../S/QSettings/QSettings.md">QSettings</a>将<a href>organizationName</a>()作为组织名来使用。</p>
<p><strong>访问函数：</strong></p>
<table>
<thead>
<tr>
<th>QString</th>
<th><strong>organizationName</strong>()</th>
</tr>
</thead>
<tbody><tr>
<td>void</td>
<td><strong>setOrganizationName</strong>(const QString &amp;<em>orgName</em>)</td>
</tr>
</tbody></table>
<p><strong>通知信号：</strong></p>
<table>
<thead>
<tr>
<th>void</th>
<th><strong>organizationNameChanged</strong>()</th>
</tr>
</thead>
<tbody><tr>
<td></td>
<td></td>
</tr>
</tbody></table>
<p>另请参阅 <a href>applicationDomain</a>和<a href>applicationName</a>。</p>
<h3><span id="quitlockenabled-bool">quitLockEnabled: bool</span><a href="#quitlockenabled-bool" class="header-anchor">#</a></h3><p>此属性保存使用<a href="../../E/QEventLoopLocker/QEventLoopLocker.md">QEventLoopLocker</a>是否能退出的特性。</p>
<p>默认值是<strong>true</strong>。</p>
<p><strong>访问函数：</strong></p>
<table>
<thead>
<tr>
<th>bool</th>
<th><strong>isQuitLockEnabled</strong>()</th>
</tr>
</thead>
<tbody><tr>
<td>void</td>
<td><strong>setQuitLockEnabled</strong>(bool <em>enabled</em>)</td>
</tr>
</tbody></table>
<p>另请参阅 <a href="../../E/QEventLoopLocker/QEventLoopLocker.md">QEventLoopLocker</a>。</p>
<h2><span id="cheng-yuan-han-shu-wen-dang">成员函数文档</span><a href="#cheng-yuan-han-shu-wen-dang" class="header-anchor">#</a></h2><hr>
<h3><span id="qcoreapplication-qcoreapplication-int-amp-argc-char-argv">QCoreApplication::QCoreApplication(int &amp;<em>argc</em>, char **<em>argv</em>)</span><a href="#qcoreapplication-qcoreapplication-int-amp-argc-char-argv" class="header-anchor">#</a></h3><p>构造一个Qt内核程序。所谓内核程序，就是没有图形用户界面的程序。这样的程序使用控制台，或者是作为服务进程运行着。</p>
<p><em>argc</em>和<em>argv</em>参数将会被应用程序处理，将其转换为一种更加便捷的形式，并可以通过<a href>arguments</a>()来获取。</p>
<p><strong>警告</strong>：<em>argc</em>和<em>argv</em>这两个值所指向的内存，必须在整个QCoreApplication生命周期内有效。另外，<em>agrc</em>必须要大于0，且<em>argv</em>必须至少包含一个合法的字符串。</p>
<hr>
<h3><span id="void-qcoreapplication-abouttoquit-signal">void QCoreApplication::aboutToQuit() [signal]</span><a href="#void-qcoreapplication-abouttoquit-signal" class="header-anchor">#</a></h3><p>当程序即将退出主消息循环时，如当消息循环嵌套层数降为0时，此事件被发射。它可能发生在应用程序中调用<a href>quit</a>()之后，亦发生在关闭整个桌面会话时。</p>
<p><strong>注意</strong>：这是一个私有信号。它能够被连接，但是用户无法发射它。</p>
<p><strong>另请参阅</strong> <a target="_blank" rel="noopener" href="https://doc.qt.io/qt-5/qcoreapplication.html#quit">quit</a>()。</p>
<hr>
<h3><span id="void-qcoreapplication-quit-static-slot">void QCoreApplication::quit() [static slot]</span><a href="#void-qcoreapplication-quit-static-slot" class="header-anchor">#</a></h3><p>告知程序以返回值0来退出。等效于调用 <a href>QCoreApplication::exit</a>(0)。</p>
<p>一般我们将quit()槽连接到<a href>QGuiApplication::lastWindowClosed</a>()信号，您同样可以将此槽连接到<a href="../../A/QAction/QAction.md">QAction</a>、<a href="../../M/QMenu/QMenu.md">QMenu</a>或<a href="../../M/QMenuBar/QMenuBar.md">QMenuBar</a>的<a href>QAbstractButton::clicked</a>()信号上。</p>
<p>将信号以<a href>QueuedConnection</a>参数连接此槽是一个不错的实践。如果连接了此槽的一个信号（未在队列中的）在控制流程进入主消息循环前（如在int main中调用<a href>exec</a>()之前）被发射，那么这个槽不会有任何效果，应用程序也不会退出。使用队列连接方式能保证控制路程进入主消息循环后，此槽才会被触发。</p>
<p>例如：</p>
<div class="code-wrapper"><pre><code class="hljs C++">QPushButton *quitButton = <span class="hljs-keyword">new</span> <span class="hljs-built_in">QPushButton</span>(<span class="hljs-string">"Quit"</span>);
<span class="hljs-built_in">connect</span>(quitButton, &amp;QPushButton::clicked, &amp;app, &amp;QCoreApplication::quit, Qt::QueuedConnection);</code></pre></div>

<p><strong>另请参阅</strong> <a target="_blank" rel="noopener" href="https://doc.qt.io/qt-5/qcoreapplication.html#exit">exit</a>(), <a target="_blank" rel="noopener" href="https://doc.qt.io/qt-5/qcoreapplication.html#aboutToQuit">aboutToQuit</a>(), and <a target="_blank" rel="noopener" href="https://doc.qt.io/qt-5/qguiapplication.html#lastWindowClosed">QGuiApplication::lastWindowClosed</a>()。</p>
<hr>
<h3><span id="qcoreapplication-qcoreapplication-virtual">QCoreApplication::~QCoreApplication() [virtual]</span><a href="#qcoreapplication-qcoreapplication-virtual" class="header-anchor">#</a></h3><p>销毁<a href="./QCoreApplication.md">QCoreApplication</a>对象。</p>
<hr>
<h3><span id="void-qcoreapplication-addlibrarypath-const-qstring-amp-path-static">void QCoreApplication::addLibraryPath(const  &amp;<em>path</em>) [static]</span><a href="#void-qcoreapplication-addlibrarypath-const-qstring-amp-path-static" class="header-anchor">#</a></h3><p>将<em>path</em>添加到库路径开头，保证它先会被库搜索到。如果<em>path</em>为空或者已经存在于路径列表，那么路径列表保持不变。</p>
<p>默认的路径列表只包含一个条目，即插件安装路径。默认的插件安装文件夹是<code>INSTALL/plugins</code>，其中<code>INSTALL</code>是Qt安装文件夹。</p>
<p>当<a href="./QCoreApplication.md">QCoreApplication</a>被销毁后，这些库路径将会被重设为默认值。</p>
<p><strong>另请参阅</strong> <a target="_blank" rel="noopener" href="https://doc.qt.io/qt-5/qcoreapplication.html#removeLibraryPath">removeLibraryPath</a>(), <a target="_blank" rel="noopener" href="https://doc.qt.io/qt-5/qcoreapplication.html#libraryPaths">libraryPaths</a>(), and <a target="_blank" rel="noopener" href="https://doc.qt.io/qt-5/qcoreapplication.html#setLibraryPaths">setLibraryPaths</a>().</p>
<hr>
<h3><span id="qstring-qcoreapplication-applicationdirpath-static"> QCoreApplication::applicationDirPath() [static]</span><a href="#qstring-qcoreapplication-applicationdirpath-static" class="header-anchor">#</a></h3><p>返回包含此可执行文件的文件夹路径。</p>
<p>例如，您已经在<code>C:\Qt</code>安装了Qt，然后运行<code>regexp</code>示例，那么这个函数会返回”C:/Qt:/examples/tools/regexp”。</p>
<p>在macOS和iOS上，它会指向实际包含可执行文件的目录，该目录可能在一个应用程序包内（如果是以应用程序包形式存在）。</p>
<p><strong>警告</strong>：在Linux上，这个函数会尝试从<code>/proc</code>获取文件路径。如果失败了，那么它假设<code>argv[0]</code>包含了可执行文件的绝对路径。此函数同样也假设了应用程序不会改变当前路径。</p>
<p><strong>另请参阅</strong> <a target="_blank" rel="noopener" href="https://doc.qt.io/qt-5/qcoreapplication.html#applicationFilePath">applicationFilePath</a>()。</p>
<hr>
<h3><span id="qstring-qcoreapplication-applicationfilepath-static"> QCoreApplication::applicationFilePath() [static]</span><a href="#qstring-qcoreapplication-applicationfilepath-static" class="header-anchor">#</a></h3><p>返回包含此可执行文件的文件路径。</p>
<p>例如，您已经在<code>/usr/local/qt</code>目录安装了Qt，然后运行<code>regexp</code>示例，那么这个函数会返回”/usr/local/qt/examples/tools/regexp/regexp”。</p>
<p><strong>警告</strong>：在Linux上，这个函数会尝试从<code>/proc</code>获取文件路径。如果失败了，那么它假设<code>argv[0]</code>包含了可执行文件的绝对路径。此函数同样也假设了应用程序不会改变当前路径。</p>
<p><strong>另请参阅</strong> <a target="_blank" rel="noopener" href="https://doc.qt.io/qt-5/qcoreapplication.html#applicationDirPath">applicationDirPath</a>()。</p>
<h3><span id="qint64-qcoreapplication-applicationpid-static"> QCoreApplication::applicationPid() [static]</span><a href="#qint64-qcoreapplication-applicationpid-static" class="header-anchor">#</a></h3><hr>
<p>返回当前应用程序的进程ID。</p>
<p>此函数自Qt 4.4引入。</p>
<hr>
<h3><span id="qstringlist-qcoreapplication-arguments-static"> QCoreApplication::arguments() [static]</span><a href="#qstringlist-qcoreapplication-arguments-static" class="header-anchor">#</a></h3><p>返回命令行参数列表。</p>
<p>一般情况下，arguments().at(0)表示可执行文件名，arguments().at(1)是第一个参数，arguments().last()是最后一个参数。请见下面关于Windows的注释。</p>
<p>调用这个函数需要花费很多时间——您应该在解析命令行时，将结果缓存起来。</p>
<p><strong>警告：</strong> 在Unix下，这个参数列表由main()函数中的argc和argv参数生成。argv中的字符串数据将会通过<a href>QString::fromLocal8Bit</a>()来解析，因此，在Latin1的区域环境下，是不可能来传递日语的命令行的，其他情况以此类推。大部分现代Unix系统没有此限制，因为它们是基于Unicode的。</p>
<p>在Windows下，这个参数列表，只有在构造函数中传入了修改的argc和argv时，才会从这个argc和argv中解析。这种情况下，就会出现编码问题。</p>
<p>如果不是上述情况，那么arguments()将会从<a href>GetCommandLine()</a>中构造。此时arguments().at(0)在Windows下未必是可执行文件名，而是取决于程序是如何被启动的。</p>
<p>此函数自Qt 4.1引入。</p>
<p><strong>另请参阅</strong> <a href>applicationFilePath</a>()和<a href="../../C/QCommandLineParser/QCommandLineParser.md">QCommandLineParser</a>。</p>
<hr>
<h3><span id="bool-qcoreapplication-closingdown-static">bool QCoreApplication::closingDown() [static]</span><a href="#bool-qcoreapplication-closingdown-static" class="header-anchor">#</a></h3><p>如果application对象正在被销毁中，则返回true，否则返回false。</p>
<p><strong>另请参阅</strong> <a href>startingUp</a>()。</p>
<hr>
<h3><span id="bool-qcoreapplication-event-qevent-e-override-virtual-protected">bool QCoreApplication::event( *<em>e</em>) [override virtual protected]</span><a href="#bool-qcoreapplication-event-qevent-e-override-virtual-protected" class="header-anchor">#</a></h3><p>重写了：<a href>QObject::event</a>(QEvent* e)。</p>
<hr>
<h3><span id="qabstracteventdispatcher-qcoreapplication-eventdispatcher-static"> *QCoreApplication::eventDispatcher() [static]</span><a href="#qabstracteventdispatcher-qcoreapplication-eventdispatcher-static" class="header-anchor">#</a></h3><p>返回指向主线程事件派发器的指针。如果线程中没有事件派发器，则返回<code>nullptr</code>。</p>
<p><strong>另请参阅</strong> <a href>setEventDispatcher</a>()。</p>
<hr>
<h3><span id="int-qcoreapplication-exec-static">int QCoreApplication::exec() [static]</span><a href="#int-qcoreapplication-exec-static" class="header-anchor">#</a></h3><p>进入主消息循环，直到<a href>exit</a>()被调用。其返回值是为<a href>exit</a>()传入的那个参数（如果是调用<a href>quit</a>()，等效于调用<a href>exit</a>(0))。</p>
<p>通过此函数来开始事件循环是很有必要的。主线程事件循环将从窗口系统接收事件，并派发给应用程序下的窗体。</p>
<p>为了能让您的程序在空闲时来处理事件（在没有待处理的事件时，通过调用一个特殊的函数），可以使用一个超时为0的<a href="../../T/QTimer/QTimer.md">QTimer</a>。可以使用<a href>processEvents</a>()来跟进一步处理空闲事件。</p>
<p>我们建议您连接<a href>aboutToQuit</a>()信号来做一些清理工作，而不是将它们放在main函数中。因为在某些平台下，exec()可能不会返回。例如，在Windows下，当用户注销时，系统将在Qt关闭所有顶层窗口后才终止进程。因此，不能保证程序有时间退出其消息循环来执行main函数中exec()之后的代码。</p>
<p><strong>另请参阅</strong> <a href>quit</a>()，<a href>exit</a>(), <a href>processEvent</a>()和<a href>QApplication::exec</a>()。</p>
<hr>
<h3><span id="void-qcoreapplication-exit-int-returncode-0-static">void QCoreApplication::exit(int <em>returnCode</em> = 0) [static]</span><a href="#void-qcoreapplication-exit-int-returncode-0-static" class="header-anchor">#</a></h3><p>告诉程序需要退出了，并带上一个返回值。</p>
<p>在此函数被调用后，程序将离开主消息循环，并且从<a href>exec</a>()中返回。其返回值就是<em>returnCode</em>。如果消息循环没有运行，那么此方法什么都不做。</p>
<p>一般我们约定0表示成功，非0表示产生了一个错误。</p>
<p>将信号以<a href>QueuedConnection</a>参数连接此槽是一个不错的实践。如果连接了此槽的一个信号（未在队列中的）在控制流程进入主消息循环前（如在int main中调用<a href>exec</a>()之前）被发射，那么这个槽不会有任何效果，应用程序也不会退出。使用队列连接方式能保证控制路程进入主消息循环后，此槽才会被触发。</p>
<p><strong>另请参阅</strong> <a href>quit</a>()和<a href>exec</a>()。</p>
<hr>
<h3><span id="void-qcoreapplication-installnativeeventfilter-qabstractnativeeventfilter-filterobj">void QCoreApplication::installNativeEventFilter( *<em>filterObj</em>)</span><a href="#void-qcoreapplication-installnativeeventfilter-qabstractnativeeventfilter-filterobj" class="header-anchor">#</a></h3><p>在主线程为应用程序所能接收到的原生事件安装一个事件过滤器。</p>
<p>事件过滤器<em>filterObj</em>通过<a href>nativeEventFilter</a>()来接收事件。它可以接收到主线程所有的原生事件。</p>
<p>如果某个原生事件需要被过滤或被屏蔽，那么<a target="_blank" rel="noopener" href="https://doc.qt.io/qt-5/qabstractnativeeventfilter.html#nativeEventFilter">QAbstractNativeEventFilter::nativeEventFilter</a>需要返回true。如果它需要使用Qt默认处理流程，则返回false：那么接下来这个原生事件则会被翻译为一个<a href="../../E/QEvent/QEvent.md">QEvent</a>，并且由Qt的标准事件过滤器来处理。</p>
<p>如果有多个事件过滤器被安装了，那么最后安装的过滤器将会被最先调用。</p>
<p><strong>注意：</strong> 此处设置的过滤器功能接收原生事件，即MSG或XCB事件结构。</p>
<p><strong>注意：</strong> 如果设置了<a href>Qt::AA_PluginApplication</a>属性，那么原生事件过滤器将会被屏蔽。</p>
<p>为了最大可能保持可移植性，您应该总是尽可能使用<a href="../../E/QEvent/QEvent.md">QEvent</a>和<a href>QObject::installEventFilter</a>()。</p>
<p><strong>另请参阅</strong> <a href>QObject::installEventFilter</a>()。</p>
<hr>
<h3><span id="bool-qcoreapplication-installtranslator-qtranslator-translationfile-static">bool QCoreApplication::installTranslator( *<em>translationFile</em>) [static]</span><a href="#bool-qcoreapplication-installtranslator-qtranslator-translationfile-static" class="header-anchor">#</a></h3><p>将<em>translationFile</em>添加到翻译文件列表，它将会被用于翻译。</p>
<p>您可以安装多个翻译文件。这些翻译文件将会按照安装顺序的逆序被搜索到，因此最近添加的翻译文件会首先被搜索到，第一个安装的搜索文件会最后被搜索。一旦翻译文件中匹配了一个字符串，那么搜索就会终止。</p>
<p>安装、移除一个<a href="../../T/QTranslator/QTranslator.md">QTranslator</a>，或者更改一个已经安装的<a href="../../T/QTranslator/QTranslator.md">QTranslator</a>将会为<a href="./QCoreApplication.md">QCoreApplication</a>实例产生一个<a href="%5BQEvent%5D(../../E/QEvent/QEvent.md)">LanguageChange</a>事件。一个<a href="../../A/QApplication/QApplication.md">QApplication</a>会将这个事件派发到所有的顶层窗体，使用<a href>tr</a>()来传递用户可见的字符串到对应的属性设置器，通过这种方式来重新实现changeEvent则可以重新翻译用户的界面。通过Qt设计师(Qt Designer)生成的窗体类提供了一个retranslateUi()可以实现上述效果。</p>
<p>函数若执行成功则返回true，失败则返回false。</p>
<p><strong>另请参阅</strong> <a href>removeTranslator</a>()，<a href>translate</a>()，<a href>QTranslator::load</a>()和<a href>动态翻译</a>。</p>
<hr>
<h3><span id="qcoreapplication-qcoreapplication-instance-static">* QCoreApplication::instance() [static]</span><a href="#qcoreapplication-qcoreapplication-instance-static" class="header-anchor">#</a></h3><p>返回程序的<a href="./QCoreApplication.md">QCoreApplication</a> (或<a href="../../G/QGuiApplication/QGuiApplication.md">QGuiApplication</a>/<a href="../../A/QApplication/QApplication.md">QApplication</a>)实例的指针。</p>
<hr>
<h3><span id="bool-qcoreapplication-issetuidallowed-static">bool QCoreApplication::isSetuidAllowed() [static]</span><a href="#bool-qcoreapplication-issetuidallowed-static" class="header-anchor">#</a></h3><p>如果在UNIX平台中，允许应用程序使用setuid，则返回true。</p>
<p>此函数自Qt 5.3引入。</p>
<p><strong>另请参阅</strong> <a href>QCoreApplication::setSetuidAllowed</a>()。</p>
<hr>
<h3><span id="qstringlist-qcoreapplication-librarypaths-static"> QCoreApplication::libraryPaths() [static]</span><a href="#qstringlist-qcoreapplication-librarypaths-static" class="header-anchor">#</a></h3><p>返回一个路径列表，其中的路径表示动态加载链接库时的搜索路径。</p>
<p>此函数的返回值也许会在<a href="./QCoreApplication.md">QCoreApplication</a>创建之后改变，因此不建议在<a href="./QCoreApplication.md">QCoreApplication</a>创建之前调用。应用程序所在的路径（<strong>非</strong>工作路径），如果是已知的，那么它会被放入列表中。为了能知道这个路径，<a href="./QCoreApplication.md">QCoreApplication</a>必须要在创建时使用argv[0]来表示此路径。</p>
<p>Qt提供默认的库搜索路径，但是它们同样也可以通过<a href>qt.conf</a>文件配置。在此文件中所指定的路径会覆盖默认路径。注意如果qt.conf文件存在于应用程序所在的文件夹目录下，那么直到<a href="./QCoreApplication.md">QCoreApplication</a>被创建时它才可以被发现。如果它没有被发现，那么调用此函数仍然返回默认搜索路径。</p>
<p>如果插件存在，那么这个列表会包含插件安装目录（默认的插件安装目录是 <code>INSTALL/plugins</code>，其中<code>INSTALL</code>是Qt所安装的目录。用分号分隔的<code>QT_PLUGIN_PATH</code>环境变量中的条目一定会被添加到列表。插件安装目录（以及它存在）在应用程序目录已知时可能会被更改。</p>
<p>如果您想遍历列表，可以使用<a href>foreach</a>伪关键字：</p>
<div class="code-wrapper"><pre><code class="hljs C++">foreach (<span class="hljs-type">const</span> QString &amp;path, app.<span class="hljs-built_in">libraryPaths</span>())
    <span class="hljs-built_in">do_something</span>(path);</code></pre></div>

<p><strong>另请参阅</strong>  <a target="_blank" rel="noopener" href="https://doc.qt.io/qt-5/qcoreapplication.html#setLibraryPaths">setLibraryPaths</a>(), <a target="_blank" rel="noopener" href="https://doc.qt.io/qt-5/qcoreapplication.html#addLibraryPath">addLibraryPath</a>(), <a target="_blank" rel="noopener" href="https://doc.qt.io/qt-5/qcoreapplication.html#removeLibraryPath">removeLibraryPath</a>(), <a href="../../L/QLibrary/QLibrary.md">QLibrary</a> , 以及 <a target="_blank" rel="noopener" href="https://doc.qt.io/qt-5/plugins-howto.html">如何创建Qt插件</a>。</p>
<hr>
<h3><span id="bool-qcoreapplication-notify-qobject-receiver-qevent-event-virtual">bool QCoreApplication::notify( <em><em>receiver</em>, <a href="../../E/QEvent/QEvent.md">QEvent</a></em> <em>event</em>) [virtual]</span><a href="#bool-qcoreapplication-notify-qobject-receiver-qevent-event-virtual" class="header-anchor">#</a></h3><p>将事件发送给接收者：<em>receiver</em>-&gt;event(<em>event</em>)。其返回值为接受者的事件处理器的返回值。注意这个函数将会在任意线程中调用，并将事件转发给任意对象。</p>
<p>对于一些特定的事件（如鼠标、键盘事件），如果事件处理器不处理此事件（也就是它返回<em>false</em>），那么事件会被逐级派发到对象的父亲，一直派发到顶层对象。</p>
<p>处理事件有5种不同的方式：重写虚函数只是其中一种。所有的五种途径如下所示：</p>
<ol>
<li>重写<a href>paintEvent</a>()，<a href>mousePressEvent</a>()等。这个是最通用、最简单但最不强大的一种方法。</li>
<li>重写此函数。这非常强大，提供了完全控制，但是一次只能激活一个子类。</li>
<li>将一个事件过滤器安装到<a href="./QCoreApplication.md">QCoreApplication</a>。这样的一个事件过滤器可以处理所有窗体的所有事件，就像是重写了notify()函数这样强大。此外，您还可以提供多个应用级别全局的事件过滤器。全局事件过滤器甚至可以接收到那些<a href>不可用窗体</a>的鼠标事件。注意程序的事件过滤器仅能响应主线程中的对象。</li>
<li>重写<a href>QObject::event</a>()（就像<a href="../../W/QWidget/QWidget.md">QWidget</a>那样）。如果您是这样做的，您可以接收到Tab按键，及您可以在任何特定窗体的事件过滤器被调用之前接收到事件。</li>
<li>在对象上安装事件过滤器。这样的事件过滤器将可以收到所有事件，包括Tab和Shift+Tab事件——只要它们不更改窗体的焦点。</li>
</ol>
<p><strong>未来规划</strong>：在Qt 6中，这个函数不会响应主线程之外的对象。需要该功能的应用程序应同时为其事件检查需求找到其他解决方案。该更改可能会扩展到主线程，因此不建议使用此功能。</p>
<p><strong>注意</strong>：如果您重写此函数，在您的应用程序开始析构之前，您必须保证所有正在处理事件的线程停止处理事件。这包括了您可能在用的其他库所创建的线程，但是不适用于Qt自己的线程。</p>
<p><strong>另请参阅</strong>：<a href>QObject::event</a>()和<a href>installNativeEventFilter</a>()。</p>
<hr>
<h3><span id="void-qcoreapplication-postevent-qobject-receiver-qevent-event-int-priority-qt-normaleventpriority-static">void QCoreApplication::postEvent(* <em>receiver</em>, * <em>event</em>, int <em>priority</em> = Qt::NormalEventPriority) [static]</span><a href="#void-qcoreapplication-postevent-qobject-receiver-qevent-event-int-priority-qt-normaleventpriority-static" class="header-anchor">#</a></h3><p>添加一个<em>event</em>事件，其中<em>receiver</em>表示事件的接收方。事件被添加到消息队列，并立即返回。</p>
<p>被添加的事件必须被分配在堆上，这样消息队列才能接管此事件，并在它被投送之后删除它。当它被投递之后，再来访问此事件是<em>不安全</em>的。</p>
<p>当程序流程返回到了主事件循环时，所有的队列中的事件会通过<a href>notify</a>()来发送。</p>
<p>队列中的事件按照<em>priority</em>降序排列，这意味着<em>高优先级</em>的事件将排列于<em>低优先级</em>之前。优先级<em>priority</em>可以是任何整数，只要它们在<code>INT_MAX</code>和<code>INT_MIN</code>之闭区间内。相同优先级的事件会按照投送顺序被处理。</p>
<p><strong>注意</strong>：此函数是<a href>线程安全</a>的。</p>
<p>此函数自Qt 4.3引入。</p>
<p><strong>另请参阅</strong>：<a href>sendEvent</a>()，<a href>notify</a>()，<a href>sendPostedEvents</a>()，和<a href>Qt::EventPriority</a>。</p>
<hr>
<h3><span id="void-qcoreapplication-processevents-qeventloop-processeventsflags-flags-qeventloop-allevents-static">void QCoreApplication::processEvents( <em>flags</em> = QEventLoop::AllEvents) [static]</span><a href="#void-qcoreapplication-processevents-qeventloop-processeventsflags-flags-qeventloop-allevents-static" class="header-anchor">#</a></h3><p>根据<em>flags</em>处理调用线程的所有待处理事件，直到没有事件需要处理。</p>
<p>您可以在您程序进行一项长时间操作的时候偶尔调用此函数（例如拷贝一个文件时）。</p>
<p>如果您在一个本地循环中持续调用这个函数，而不是在消息循环中，那么<a href>DeferredDelete</a>事件不会被处理。这会影响到一些窗体的行为，例如<a href="../../T/QToolTip/QToolTip.md">QToolTip</a>，它依赖<a href>DeferredDelete</a>事件。以使其正常运行。一种替代方法是从该本地循环中调用<a target="_blank" rel="noopener" href="https://doc.qt.io/qt-5/qcoreapplication.html#sendPostedEvents">sendPostedEvents</a>()。</p>
<p>此函数只处理调用线程的事件，当所有可处理事件处理完毕之后返回。可用事件是在函数调用之前排队的事件。这意味着在函数运行时投送的事件将会排队到下一轮事件处理为止。</p>
<p><strong>注意</strong>：此函数是<a href>线程安全</a>的。</p>
<p><strong>另请参阅</strong>：<a href>exec</a>()，<a href="../../T/QTimer/QTimer.md">QTimer</a>，<a href>QEventLoop::processEvents</a>()，<a href>flush</a>()和<a href>sendPostedEvents</a>()。</p>
<hr>
<h3><span id="void-qcoreapplication-processevents-qeventloop-processeventsflags-flags-qeventloop-allevents-int-ms-static">void QCoreApplication::processEvents( <em>flags</em> = QEventLoop::AllEvents, int <em>ms</em>) [static]</span><a href="#void-qcoreapplication-processevents-qeventloop-processeventsflags-flags-qeventloop-allevents-int-ms-static" class="header-anchor">#</a></h3><p>此函数重写了processEvents()。</p>
<p>此函数将用<em>ms</em>毫秒为调用线程处理待处理的事件，或者直到没有更多事件需要处理。</p>
<p>您可以在您程序进行一项长时间操作的时候偶尔调用此函数（例如拷贝一个文件时）。</p>
<p>此函数只处理调用线程的事件。</p>
<p><strong>注意</strong>：不像<a href>processEvents</a>()的重写，这个函数同样也处理当函数正在运行中时被投送的事件。)，QTimer，QEventLoop::processEvents()。</p>
<p><strong>另请参阅</strong>：<a href>exec</a>()，<a href="../../T/QTimer/QTimer.md">QTimer</a>，<a href>QEventLoop::processEvents</a>()。</p>
<hr>
<h3><span id="void-qcoreapplication-removelibrarypath-const-qstring-amp-path-static">void QCoreApplication::removeLibraryPath(const  &amp;<em>path</em>) [static]</span><a href="#void-qcoreapplication-removelibrarypath-const-qstring-amp-path-static" class="header-anchor">#</a></h3><p>从库的搜索路径列表中移除<em>path</em>。如果<em>path</em>是空的，或者不存在于列表，则列表不会改变。</p>
<p>当<a href="./QCoreApplication.md">QCoreApplication</a>被析构时，此列表会被还原。</p>
<p><strong>另请参阅</strong>：<a href>exec</a>()，<a href="../../T/QTimer/QTimer.md">QTimer</a>和<a href>QEventLoop::processEvents</a>()。</p>
<hr>
<h3><span id="void-qcoreapplication-removenativeeventfilter-qabstractnativeeventfilter-filterobject">void QCoreApplication::removeNativeEventFilter( *<em>filterObject</em>)</span><a href="#void-qcoreapplication-removenativeeventfilter-qabstractnativeeventfilter-filterobject" class="header-anchor">#</a></h3><p>从此实例中移除<em>filterObject</em>事件过滤器。如果这个事件过滤器没有被安装，则什么也不做。</p>
<p>当此实例被销毁时，所有的事件过滤器都会自动被移除。</p>
<p>任何时候——甚至正在事件过滤被激活时（通过nativeEventFilter()函数)——移除一个事件过滤器都是安全的。</p>
<p>此函数自Qt 5.0引入。</p>
<p><strong>另请参阅</strong>：<a href>installNativeEventFilter</a>()。</p>
<hr>
<h3><span id="void-qcoreapplication-removepostedevents-qobject-receiver-int-eventtype-0-static">void QCoreApplication::removePostedEvents( *<em>receiver</em>, int <em>eventType</em> = 0) [static]</span><a href="#void-qcoreapplication-removepostedevents-qobject-receiver-int-eventtype-0-static" class="header-anchor">#</a></h3><p>移除所指定的 <em>eventType</em> 类型且由<a href>postEvent</a>()所添加的事件。</p>
<p>这些事件不会被派发，而是直接从队列中移除。您从来都不需要调用此方法。如果您确实调用了它，那么请注意杀掉事件可能会影响 <em>receiver</em> 的不变性(invariant)。</p>
<p>如果接收者为<code>nullptr</code>，那么所有对象将会移除 <em>eventType</em> 所指定的所有事件。如果 <em>eventType</em> 为0，那么<em>receiver</em>的所有事件将会被移除。自始自终，您都不应将 0 传递给 <em>eventType</em> 。</p>
<p><strong>注意</strong>：此函数是<a href>线程安全</a>的。</p>
<p>此函数自Qt 4.3引入。</p>
<hr>
<h3><span id="bool-qcoreapplication-removetranslator-qtranslator-translationfile-static">bool QCoreApplication::removeTranslator( *translationFile) [static]</span><a href="#bool-qcoreapplication-removetranslator-qtranslator-translationfile-static" class="header-anchor">#</a></h3><p>从此应用程序使用的翻译文件列表中删除翻译文件 <em>translationFile</em> 。 （不会在文件系统中删除此翻译文件。）</p>
<p>该函数成功时返回 true ，失败时返回 false 。</p>
<p><strong>另请参阅</strong>：<a href>installTranslator()</a>，<a href>translate()</a>，与 <a href>QObject::tr()</a>。</p>
<hr>
<h3><span id="bool-qcoreapplication-sendevent-qobject-receiver-qevent-event-static">bool QCoreApplication::sendEvent( *receiver,  *event) [static]</span><a href="#bool-qcoreapplication-sendevent-qobject-receiver-qevent-event-static" class="header-anchor">#</a></h3><p>通过函数 <a href>notify()</a> 将事件 <em>event</em> 直接发送至接收对象 <em>receiver</em> 。返回从事件处理对象得到的返回值。</p>
<p>事件 <em>不会</em> 在发送之后删除掉。通常的方法是在栈上创建事件，例如：</p>
<div class="code-wrapper"><pre><code class="hljs C++"><span class="hljs-function">QMouseEvent <span class="hljs-title">event</span><span class="hljs-params">(QEvent::MouseButtonPress, pos, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>)</span></span>;
QApplication::<span class="hljs-built_in">sendEvent</span>(mainWindow, &amp;event);</code></pre></div>

<p><strong>另请参阅</strong>：<a href>postEvent()</a> 与 <a href>notify()</a>。</p>
<hr>
<h3><span id="void-qcoreapplication-sendpostedevents-qobject-receiver-nullptr-int-event-type-0-static">void QCoreApplication::sendPostedEvents( *receiver = nullptr, int event_type = 0) [static]</span><a href="#void-qcoreapplication-sendpostedevents-qobject-receiver-nullptr-int-event-type-0-static" class="header-anchor">#</a></h3><p>立刻分派所有先前通过 <a href>QCoreApplication::postEvent()</a> 进入队列的事件。这些事件是针对接收对象的，且事件类型为 <em>event_type</em> 。</p>
<p>该函数不会对来自窗口系统的事件进行分派，如有需求请参考 <a href>processEvents()</a>。</p>
<p>如果接收对象指针为 <strong>nullptr</strong> ，<em>event_type</em> 的所有事件将分派到所有对象。如果 <em>event_type</em> 为 0 ，所有事件将发送到接收对象 <em>receiver</em> 。</p>
<p><strong>注意：</strong> 该方法必须由其 <a href="../../O/QObject/QObject.md">QObject</a> 参数 <a href>receiver</a> 所在的线程调用。</p>
<p><strong>另请参阅</strong>：<a href>flush()</a> 与 <a href>postEvent()</a>。</p>
<hr>
<h3><span id="void-qcoreapplication-setattribute-qt-applicationattribute-attribute-bool-on-true-static">void QCoreApplication::setAttribute( attribute, bool on = true) [static]</span><a href="#void-qcoreapplication-setattribute-qt-applicationattribute-attribute-bool-on-true-static" class="header-anchor">#</a></h3><p>如果 <em>on</em> 为 true ，则设置属性 <em>attribute</em>；否则清除该属性。</p>
<p><strong>注意：</strong>在创建 <a href>QCoreApplication</a> 实例之前，一些应用程序的属性必须要设置。 有关更多信息，请参考 <a href>Qt::ApplicationAttribute</a> 文档。</p>
<p><strong>另请参阅</strong>：<a href>testAttribute()</a>。</p>
<hr>
<h3><span id="void-qcoreapplication-seteventdispatcher-qabstracteventdispatcher-eventdispatcher-static">void QCoreApplication::setEventDispatcher( *eventDispatcher) [static]</span><a href="#void-qcoreapplication-seteventdispatcher-qabstracteventdispatcher-eventdispatcher-static" class="header-anchor">#</a></h3><p>将主线程的事件分派器设置为 <em>eventDispatcher</em> 。只有在还没有安装事件分派器的情况下，也就是在实例化 <a href>QCoreApplication</a> 之前，才可以进行设置。此方法获取对象的所有权。</p>
<p><strong>另请参阅</strong>：<a href>eventDispatcher()</a>。</p>
<hr>
<h3><span id="void-qcoreapplication-setlibrarypaths-const-qstringlist-amp-paths-static">void QCoreApplication::setLibraryPaths(const  &amp;paths) [static]</span><a href="#void-qcoreapplication-setlibrarypaths-const-qstringlist-amp-paths-static" class="header-anchor">#</a></h3><p>将加载库时要搜索的目录列表设置为 <em>paths</em>。现有的所有路径将被删除，路径列表将从参数 <em>paths</em> 中获取。</p>
<p>当实例 <a href>QCoreApplication</a> 被析构时，库路径将设置为默认值。</p>
<p><strong>另请参阅</strong>：<a href>libraryPaths()</a>、<a href>addLibraryPath()</a>、<a href>removeLibraryPath()</a> 与 <a href>QLibrary</a>。</p>
<hr>
<h3><span id="void-qcoreapplication-setsetuidallowed-bool-allow-static">void QCoreApplication::setSetuidAllowed(bool allow) [static]</span><a href="#void-qcoreapplication-setsetuidallowed-bool-allow-static" class="header-anchor">#</a></h3><p>若 <em>allow</em> 为 true，允许程序在 UNIX 平台上运行 setuid 。</p>
<p>若 <em>allow</em> 为 false （默认值），且 Qt 检测到程序使用与实际用户id不同的有效用户id运行，那么在创建 QCoreApplication 实例时程序将中止。</p>
<p>Qt 受攻击面较大，因此它并不是一个恰当 setuid 程序解决方案。 不过，出于历史原因，可能某些程序仍需要这种方式运行。 当检测到此标志时，可防止 Qt 中止应用程序。须在创建 QCoreApplication 实例之前将其进行设置。</p>
<p><strong>注意：</strong>强烈建议不要打开此选项，它会带来安全风险。</p>
<p>此函数自Qt 5.3引入。</p>
<p><strong>另请参阅</strong>：<a href>isSetuidAllowed()</a>。</p>
<hr>
<h3><span id="bool-qcoreapplication-startingup">bool QCoreApplication::startingUp()</span><a href="#bool-qcoreapplication-startingup" class="header-anchor">#</a></h3><p>如果应用程序对象尚未创建，则返回 <strong>true</strong> ；否则返回 <strong>false</strong> 。</p>
<p><strong>另请参阅</strong>：<a href>closingDown()</a>。</p>
<hr>
<h3><span id="bool-qcoreapplication-testattribute-qt-applicationattribute-attribute-static">bool QCoreApplication::testAttribute( attribute) [static]</span><a href="#bool-qcoreapplication-testattribute-qt-applicationattribute-attribute-static" class="header-anchor">#</a></h3><p>如果设置了属性 <em>attribute</em> ，返回 true ；否则返回 false 。</p>
<p><strong>另请参阅</strong>：<a href>setAttribute()</a>。</p>
<hr>
<h3><span id="qstring-qcoreapplication-translate-const-char-context-const-char-sourcetext-const-char-disambiguation-nullptr-int-n-1-static"> QCoreApplication::translate(const char *context, const char *sourceText, const char *disambiguation = nullptr, int n = -1) [static]</span><a href="#qstring-qcoreapplication-translate-const-char-context-const-char-sourcetext-const-char-disambiguation-nullptr-int-n-1-static" class="header-anchor">#</a></h3><p>搜索最近到首次安装的翻译文件，查询翻译文件中 sourceText 对应的翻译内容，返回其结果。</p>
<p><a href>QObject::tr()</a> 作用相同且使用更便捷。</p>
<p><em>context</em> 通常为类名（如 “MyDialog”），<em>sourceText</em> 则是英文文本或简短的识别文本。</p>
<p><em>disambiguation</em> 为一段识别字符串，用于同一上下文中不同角色使用相同的 <em>sourceText</em> 。它的默认值为 <strong>nullptr</strong>。</p>
<p>有关上下文、消除歧义和注释的更多信息，请参阅 <a href>QTranslator</a> 和 <a href>QObject::tr()</a> 文档。</p>
<p><em>n</em> 与 <em>%n</em> 一并使用以便支持复数形式。详见 <a href>QObject::tr()</a> 。</p>
<p>如果没有任何翻译文件包含 <em>context</em> 中 <em>sourceText</em> 的翻译内容，该函数则返回 <a href>QString</a> 包裹的 <em>sourceText</em> 。</p>
<p>此函数非虚函数。您可以子类化 <a href>QTranslator</a> 来使用其他翻译技术。</p>
<p><strong>注意：</strong>此函数线程安全。</p>
<p><strong>另请参阅</strong>：<a href>QObject::tr()</a>，<a href>installTranslator()</a>，<a href>removeTranslator()</a>，与 translate()。</p>
<h2><span id="xiang-guan-fei-cheng-yuan-han-shu">相关非成员函数</span><a href="#xiang-guan-fei-cheng-yuan-han-shu" class="header-anchor">#</a></h2><hr>
<h3><span id="void-qaddpostroutine-qtcleanupfunction-ptr">void qAddPostRoutine(QtCleanUpFunction ptr)</span><a href="#void-qaddpostroutine-qtcleanupfunction-ptr" class="header-anchor">#</a></h3><p>添加一个全局例程，它将在  <a href>QCoreApplication</a> 析构函数中调用。这个函数通常用来作为在程序范围功能内，添加程序清除例程的函数。</p>
<p>清除例程的调用顺序与添加例程的顺序相反。</p>
<p>参数 <em>ptr</em> 指定的函数应既没有参数，也没有返回值，例如：</p>
<div class="code-wrapper"><pre><code class="hljs C++"><span class="hljs-type">static</span> <span class="hljs-type">int</span> *global_ptr = <span class="hljs-literal">nullptr</span>;

<span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title">cleanup_ptr</span><span class="hljs-params">()</span></span>
<span class="hljs-function"></span>{
    <span class="hljs-keyword">delete</span> [] global_ptr;
    global_ptr = <span class="hljs-literal">nullptr</span>;
}

<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">init_ptr</span><span class="hljs-params">()</span></span>
<span class="hljs-function"></span>{
    global_ptr = <span class="hljs-keyword">new</span> <span class="hljs-type">int</span>[<span class="hljs-number">100</span>];      <span class="hljs-comment">// allocate data</span>
    <span class="hljs-built_in">qAddPostRoutine</span>(cleanup_ptr);   <span class="hljs-comment">// delete later</span>
}</code></pre></div>

<p>注意，对于应用程序或模块范围的清理，qAddPostRoutine() 通常不太合适。例如，若程序被分割成动态加载的模块，那么相关的模块可能在 <a href>QCoreApplication</a> 的析构函数调用之前就卸载了。在这种情况下，如果仍想使用 qAddPostRoutine() ，可以使用 qRemovePostRoutine() 来防止 <a href>QCoreApplication</a> 的析构函数调用一个例程。举个例子，在模块卸载前调用 qRemovePostRoutine() 。</p>
<p>对于模块或库，使用引用计数初始化管理器，或者 Qt 对象树删除机制可能会更好。下面是一个私有类使用对象树机制正确调用清除函数的一个例子：</p>
<div class="code-wrapper"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyPrivateInitStuff</span> : <span class="hljs-keyword">public</span> QObject
{
<span class="hljs-keyword">public</span>:
    <span class="hljs-function"><span class="hljs-type">static</span> MyPrivateInitStuff *<span class="hljs-title">initStuff</span><span class="hljs-params">(QObject *parent)</span></span>
<span class="hljs-function">    </span>{
        <span class="hljs-keyword">if</span> (!p)
            p = <span class="hljs-keyword">new</span> <span class="hljs-built_in">MyPrivateInitStuff</span>(parent);
        <span class="hljs-keyword">return</span> p;
    }

    ~<span class="hljs-built_in">MyPrivateInitStuff</span>()
    {
        <span class="hljs-comment">// cleanup goes here</span>
    }

<span class="hljs-keyword">private</span>:
    <span class="hljs-built_in">MyPrivateInitStuff</span>(QObject *parent)
        : <span class="hljs-built_in">QObject</span>(parent)
    {
        <span class="hljs-comment">// initialization goes here</span>
    }

    MyPrivateInitStuff *p;
};</code></pre></div>
<p>通过选择正确的父对象，正常情况下可以在正确的时机清理模块的数据。</p>
<p><strong>注意：</strong> 函数自 Qt 5.10 已线程安全</p>
<p><strong>注意：</strong> 该函数线程安全</p>
<p><strong>另请参阅</strong>：<a href>qRemovePostRoutine()</a>。</p>
<hr>
<h3><span id="void-qremovepostroutine-qtcleanupfunction-ptr">void qRemovePostRoutine(QtCleanUpFunction ptr)</span><a href="#void-qremovepostroutine-qtcleanupfunction-ptr" class="header-anchor">#</a></h3><p><strong>注意：</strong> 函数自 Qt 5.10 已线程安全</p>
<p><strong>注意：</strong> 该函数线程安全</p>
<p>此函数自 Qt 5.3 引入。</p>
<p><strong>另请参阅</strong>：<a href>qAddPostRoutine()</a>。</p>
<h2><span id="hong-wen-dang">宏文档</span><a href="#hong-wen-dang" class="header-anchor">#</a></h2><hr>
<h3><span id="q-coreapp-startup-function-qtstartupfunction-ptr">Q_COREAPP_STARTUP_FUNCTION(QtStartUpFunction ptr)</span><a href="#q-coreapp-startup-function-qtstartupfunction-ptr" class="header-anchor">#</a></h3><p>添加一个全局函数，它将在 <a href>QCoreApplication</a> 的构造函数中调用。这个宏通常用于为程序范围内的功能初始化库，无需应用程序调用库进行初始化。</p>
<p>参数 <em>ptr</em> 指定的函数应既没有参数，也没有返回值，例如：</p>
<div class="code-wrapper"><pre><code class="hljs C++"><span class="hljs-comment">// Called once QCoreApplication exists</span>
<span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title">preRoutineMyDebugTool</span><span class="hljs-params">()</span></span>
<span class="hljs-function"></span>{
    MyDebugTool* tool = <span class="hljs-keyword">new</span> <span class="hljs-built_in">MyDebugTool</span>(QCoreApplication::<span class="hljs-built_in">instance</span>());
    QCoreApplication::<span class="hljs-built_in">instance</span>()-&gt;<span class="hljs-built_in">installEventFilter</span>(tool);
}

<span class="hljs-built_in">Q_COREAPP_STARTUP_FUNCTION</span>(preRoutineMyDebugTool)</code></pre></div>
<p>注意，启动函数将在 <a href>QCoreApplication</a> 构造后，在任何 GUI 初始化前调用。如果函数中需要GUI代码，请使用计时器(或队列动态调用)，在后面的事件循环中执行初始化。</p>
<p>如果删除了 <a href>QCoreApplication</a> 并创建了另一个 <a href>QCoreApplication</a> ，将再次调用启动函数。</p>
<p><strong>注意：</strong>此宏不适用于静态链接到应用程序中的库代码中使用，因为链接器可能会删除该函数，使其根本不会被调用。</p>
<p><strong>注意：</strong>此函数是<a href>可重入的</a>。</p>
<p>此函数自 Qt 5.1 引入。</p>
<hr>
<h3><span id="q-declare-tr-functions-context">Q_DECLARE_TR_FUNCTIONS(context)</span><a href="#q-declare-tr-functions-context" class="header-anchor">#</a></h3><p><strong>Q_DECLARE_TR_FUNCTIONS()</strong> 宏使用以下签名声明并实现了两个转换函数 <strong>tr()</strong> 和 **trUtf8()**：</p>
<div class="code-wrapper"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-keyword">inline</span> QString <span class="hljs-title">tr</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *sourceText,</span></span>
<span class="hljs-params"><span class="hljs-function">                         <span class="hljs-type">const</span> <span class="hljs-type">char</span> *comment = <span class="hljs-literal">nullptr</span>)</span></span>;
<span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-keyword">inline</span> QString <span class="hljs-title">trUtf8</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *sourceText,</span></span>
<span class="hljs-params"><span class="hljs-function">                             <span class="hljs-type">const</span> <span class="hljs-type">char</span> *comment = <span class="hljs-literal">nullptr</span>)</span></span>;</code></pre></div>

<p>如果您想在不继承 <a href>QObject</a> 的类使用 <a href>QObject::tr()</a> 或者 QObject::Utf8() ，这个宏就非常适用。</p>
<p><strong>Q_DECLARE_TR_FUNCTIONS()</strong> 宏必须写在类的第一行（在第一个 public: 或 protected: 之前），例如：</p>
<div class="code-wrapper"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyMfcView</span> : <span class="hljs-keyword">public</span> CView
{
    <span class="hljs-built_in">Q_DECLARE_TR_FUNCTIONS</span>(MyMfcView)

<span class="hljs-keyword">public</span>:
    <span class="hljs-built_in">MyMfcView</span>();
    ...
};</code></pre></div>
<p>通常 <em>context</em> 参数为类名，不过也可以是任何文本。</p>
<p><strong>另请参阅</strong>：<a href>Q_OBJECT</a>，<a href>QObject::tr()</a>，与 <a href>QObject::trUtf8()</a>。</p>

            </div>
            <hr>
            <div>
              <div class="post-metas mb-3">
                
                
                  <div class="post-meta">
                    <i class="iconfont icon-tags"></i>
                    
                      <a class="hover-with-bg" href="/tags/C/">C</a>
                    
                  </div>
                
              </div>
              
                <p class="note note-warning">
                  
                    本博客所有文章除特别声明外，均采用 <a target="_blank" href="https://creativecommons.org/licenses/by-sa/4.0/deed.zh" rel="nofollow noopener noopener">CC BY-SA 4.0 协议</a> ，转载请注明出处！
                  
                </p>
              
              
                <div class="post-prevnext">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/2022/03/02/QtDocumentCN/Src/C/QColorTransform/QColorTransform/">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">QColorTransform类</span>
                        <span class="visible-mobile">上一篇</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2022/03/02/QtDocumentCN/Src/C/QCheckBox/QCheckBox/">
                        <span class="hidden-mobile">QCheckBox类</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
              <!-- Comments -->
              <article class="comments" id="comments" lazyload>
                
                  
                
                
  <div id="lv-container" data-id="city" data-uid="MTAyMC81NTMzMi8zMTc5OQ==">
    <script type="text/javascript">
      Fluid.utils.loadComments('#lv-container', function() {
        Fluid.utils.createScript('https://cdn-city.livere.com/js/embed.dist.js');
      });
    </script>
    <noscript>Please enable JavaScript to view the comments</noscript>
  </div>


              </article>
            
          </article>
        </div>
      </div>
    </div>
    
      <div class="d-none d-lg-block col-lg-2 toc-container" id="toc-ctn">
        <div id="toc">
  <p class="toc-header"><i class="iconfont icon-list"></i>&nbsp;目录</p>
  <div class="toc-body" id="toc-body"></div>
</div>

      </div>
    
  </div>
</div>

<!-- Custom -->


    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v"
                 for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>
    

    
  </main>

  <footer class="text-center mt-5 py-3">
  <div class="footer-content">
     <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> 
  </div>
  

  

  
</footer>


  <!-- SCRIPTS -->
  
  <script  src="https://cdn.jsdelivr.net/npm/nprogress@0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/nprogress@0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js" ></script>
<script  src="https://cdn.jsdelivr.net/npm/bootstrap@4/dist/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>

<!-- Plugins -->


  <script  src="/js/local-search.js" ></script>



  
    <script  src="/js/img-lazyload.js" ></script>
  



  



  
    <script  src="https://cdn.jsdelivr.net/npm/tocbot@4/dist/tocbot.min.js" ></script>
  
  
    <script  src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3/dist/jquery.fancybox.min.js" ></script>
  
  
    <script  src="https://cdn.jsdelivr.net/npm/anchor-js@4/anchor.min.js" ></script>
  
  
    <script defer src="https://cdn.jsdelivr.net/npm/clipboard@2/dist/clipboard.min.js" ></script>
  






  <script  src="https://cdn.jsdelivr.net/npm/typed.js@2/lib/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var title = document.getElementById('subtitle').title;
      
        typing(title);
      
    })(window, document);
  </script>















<!-- 主题的启动项 保持在最底部 -->
<script  src="/js/boot.js" ></script>


</body>
</html>
