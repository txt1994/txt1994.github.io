

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=auto>



<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/logo.jpg">
  <link rel="icon" href="/img/logo.jpg">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
    <meta http-equiv="Content-Security-Policy" content="upgrade-insecure-requests">
  
  <meta name="theme-color" content="#6aa84f">
  <meta name="author" content="John Doe">
  <meta name="keywords" content="">
  
    <meta name="description" content="QRegExp Class 公共类型 公共函数 静态公共成员 相关非成员 详细描述 简介 字符和字符集的缩写 字符集 限定词 断言 通配符匹配 Perl 用户注意事项 代码示例 移植到 QRegularExpression   成员类型文档 enum QRegExp::CaretMode enum QRegExp::PatternSyntax   成员函数文档 QRegExp::QReg">
<meta property="og:type" content="article">
<meta property="og:title" content="QRegExp类">
<meta property="og:url" content="https://txt1994.github.io/2022/03/02/QtDocumentCN/Src/R/QRegExp/QRegExp/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:description" content="QRegExp Class 公共类型 公共函数 静态公共成员 相关非成员 详细描述 简介 字符和字符集的缩写 字符集 限定词 断言 通配符匹配 Perl 用户注意事项 代码示例 移植到 QRegularExpression   成员类型文档 enum QRegExp::CaretMode enum QRegExp::PatternSyntax   成员函数文档 QRegExp::QReg">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2022-03-02T06:47:47.000Z">
<meta property="article:modified_time" content="2022-03-18T16:51:34.306Z">
<meta property="article:author" content="John Doe">
<meta property="article:tag" content="R">
<meta name="twitter:card" content="summary_large_image">
  
  
  <title>QRegExp类 - Hexo</title>

  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4/dist/css/bootstrap.min.css" />


  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/github-markdown-css@4/github-markdown.min.css" />
  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/hint.css@2/hint.min.css" />

  
    
    
      
      <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@10/styles/github-gist.min.css" />
    
  

  
    <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3/dist/jquery.fancybox.min.css" />
  


<!-- 主题依赖的图标库，不要自行修改 -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_ba1fz6golrf.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_lbnruvf0jn.css">


<link  rel="stylesheet" href="/css/main.css" />

<!-- 自定义样式保持在最底部 -->

  
<link rel="stylesheet" href="/css/style.css">



  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    var CONFIG = {"hostname":"txt1994.github.io","root":"/","version":"1.8.14","typing":{"enable":true,"typeSpeed":70,"cursorChar":"_","loop":false},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"right","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"copy_btn":true,"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":false,"baidu":null,"google":null,"gtag":null,"tencent":{"sid":null,"cid":null},"woyaola":null,"cnzz":null,"leancloud":{"app_id":null,"app_key":null,"server_url":null,"path":"window.location.pathname","ignore_local":false}},"search_path":"/local-search.xml"};
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
<meta name="generator" content="Hexo 6.1.0">
<style>.github-emoji { position: relative; display: inline-block; width: 1.2em; min-height: 1.2em; overflow: hidden; vertical-align: top; color: transparent; }  .github-emoji > span { position: relative; z-index: 10; }  .github-emoji img, .github-emoji .fancybox { margin: 0 !important; padding: 0 !important; border: none !important; outline: none !important; text-decoration: none !important; user-select: none !important; cursor: auto !important; }  .github-emoji img { height: 1.2em !important; width: 1.2em !important; position: absolute !important; left: 50% !important; top: 50% !important; transform: translate(-50%, -50%) !important; user-select: none !important; cursor: auto !important; } .github-emoji-fallback { color: inherit; } .github-emoji-fallback img { opacity: 0 !important; }</style>
</head>


<body>
  <header style="height: 70vh;">
    <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/">
      <strong>txt1994s</strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/">
                <i class="iconfont icon-home-fill"></i>
                首页
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/">
                <i class="iconfont icon-archive-fill"></i>
                归档
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/">
                <i class="iconfont icon-tags-fill"></i>
                标签
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/">
                <i class="iconfont icon-user-fill"></i>
                关于
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/links/">
                <i class="iconfont icon-link-fill"></i>
                友联
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              &nbsp;<i class="iconfont icon-search"></i>&nbsp;
            </a>
          </li>
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">&nbsp;<i
                class="iconfont icon-dark" id="color-toggle-icon"></i>&nbsp;</a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

    <div class="banner" id="banner" parallax=true
         style="background: url('/img/default.png') no-repeat center center;
           background-size: cover;">
      <div class="full-bg-img">
        <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
          <div class="page-header text-center fade-in-up">
            <span class="h2" id="subtitle" title="QRegExp类">
              
            </span>

            
              <div class="mt-3">
  
  
    <span class="post-meta">
      <i class="iconfont icon-date-fill" aria-hidden="true"></i>
      <time datetime="2022-03-02 14:47" pubdate>
        2022年3月2日 下午
      </time>
    </span>
  
</div>

<div class="mt-1">
  
    <span class="post-meta mr-2">
      <i class="iconfont icon-chart"></i>
      27k 字
    </span>
  

  
    <span class="post-meta mr-2">
      <i class="iconfont icon-clock-fill"></i>
      
      
      228 分钟
    </span>
  

  
  
</div>

            
          </div>

          
        </div>
      </div>
    </div>
  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="d-none d-lg-block col-lg-2"></div>
    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div class="py-5" id="board">
          <article class="post-content mx-auto">
            <!-- SEO header -->
            <h1 style="display: none">QRegExp类</h1>
            
              <p class="note note-info">
                
                  本文最后更新于：2022年3月19日 凌晨
                
              </p>
            
            <div class="markdown-body">
              <div class="toc">

<!-- toc -->

<ul>
<li><a href="#qregexp-class">QRegExp Class</a><ul>
<li><a href="#gong-gong-lei-xing">公共类型</a></li>
<li><a href="#gong-gong-han-shu">公共函数</a></li>
<li><a href="#jing-tai-gong-gong-cheng-yuan">静态公共成员</a></li>
<li><a href="#xiang-guan-fei-cheng-yuan">相关非成员</a></li>
<li><a href="#xiang-xi-miao-shu">详细描述</a><ul>
<li><a href="#jian-jie">简介</a></li>
<li><a href="#zi-fu-he-zi-fu-ji-de-suo-xie">字符和字符集的缩写</a></li>
<li><a href="#zi-fu-ji">字符集</a></li>
<li><a href="#xian-ding-ci">限定词</a></li>
<li><a href="#duan-yan">断言</a></li>
<li><a href="#tong-pei-fu-pi-pei">通配符匹配</a></li>
<li><a href="#perl-yong-hu-zhu-yi-shi-xiang">Perl 用户注意事项</a></li>
<li><a href="#dai-ma-shi-li">代码示例</a></li>
<li><a href="#yi-zhi-dao-qregularexpression">移植到 QRegularExpression</a></li>
</ul>
</li>
<li><a href="#cheng-yuan-lei-xing-wen-dang">成员类型文档</a><ul>
<li><a href="#enum-qregexp-caretmode">enum QRegExp::CaretMode</a></li>
<li><a href="#enum-qregexp-patternsyntax">enum QRegExp::PatternSyntax</a></li>
</ul>
</li>
<li><a href="#cheng-yuan-han-shu-wen-dang">成员函数文档</a><ul>
<li><a href="#qregexp-qregexp-const-qregexp-qregexp-rx">QRegExp::QRegExp(const </a><a href="#QRegExp">QRegExp</a> &amp;<em>rx</em>)</li>
<li><a href="#qregexp-qregexp-const-qstring-qstring-html-pattern-qt-casesensitivity-qt-html-casesensitivity-enum-cs-qt-casesensitive-qregexp-patternsyntax-patternsyntax-enum-syntax-regexp">QRegExp::QRegExp(const </a><a href="qstring.html">QString</a> &amp;<em>pattern</em>, <a href="qt.html#CaseSensitivity-enum">Qt::CaseSensitivity</a> <em>cs</em> = Qt::CaseSensitive, <a href="#PatternSyntax-enum">QRegExp::PatternSyntax</a> <em>syntax</em> = RegExp)</li>
<li><a href="#qregexp-qregexp">QRegExp::QRegExp()</a></li>
<li><a href="#since-5-2-qregexp-qregexp-qregexp-operator-qregexp-qregexp-other"><code>[since 5.2]</code></a><a href="#QRegExp">QRegExp</a> &amp;QRegExp::operator=(<a href="#QRegExp">QRegExp</a> &amp;&amp;<em>other</em>)</li>
<li><a href="#qregexp-qregexp-qregexp-operator-const-qregexp-qregexp-rx">QRegExp</a></li>
<li><a href="#qregexp-qregexp">QRegExp::~QRegExp()</a></li>
<li><a href="#qstring-qstring-html-qregexp-cap-int-nth-0-const">QString</a></li>
<li><a href="#int-qregexp-capturecount-const">int QRegExp::captureCount() const</a></li>
<li><a href="#qstringlist-qstringlist-html-qregexp-capturedtexts-const">QStringList</a></li>
<li><a href="#qt-casesensitivity-qt-html-casesensitivity-enum-qregexp-casesensitivity-const">Qt::CaseSensitivity</a></li>
<li><a href="#int-qregexp-countin-const-qstring-qstring-html-str-const">int QRegExp::countIn(const </a><a href="qstring.html">QString</a> &amp;<em>str</em>) const</li>
<li><a href="#qstring-qstring-html-qregexp-errorstring-const-1">QString</a></li>
<li><a href="#static-qstring-qstring-html-qregexp-escape-const-qstring-qstring-html-str"><code>[static]</code></a><a href="qstring.html">QString</a> QRegExp::escape(const <a href="qstring.html">QString</a> &amp;<em>str</em>)</li>
<li><a href="#bool-qregexp-exactmatch-const-qstring-qstring-html-str-const">bool QRegExp::exactMatch(const </a><a href="qstring.html">QString</a> &amp;<em>str</em>) const</li>
<li><a href="#qstringlist-qstringlist-html-qregexp-filterlist-const-qstringlist-qstringlist-html-stringlist-const-1">QStringList</a></li>
<li><a href="#int-qregexp-indexin-const-qstring-qstring-html-str-int-offset-0-qregexp-caretmode-caretmode-enum-caretmode-caretatzero-const">int QRegExp::indexIn(const </a><a href="qstring.html">QString</a> &amp;<em>str</em>, int <em>offset</em> = 0, <a href="#CaretMode-enum">QRegExp::CaretMode</a> <em>caretMode</em> = CaretAtZero) const</li>
<li><a href="#int-qregexp-indexin-const-qstringlist-qstringlist-html-list-int-from-const">int QRegExp::indexIn(const </a><a href="qstringlist.html">QStringList</a> &amp;<em>list</em>, int <em>from</em>) const</li>
<li><a href="#bool-qregexp-isempty-const">bool QRegExp::isEmpty() const</a></li>
<li><a href="#bool-qregexp-isminimal-const">bool QRegExp::isMinimal() const</a></li>
<li><a href="#bool-qregexp-isvalid-const">bool QRegExp::isValid() const</a></li>
<li><a href="#int-qregexp-lastindexin-const-qstring-qstring-html-str-int-offset-1-qregexp-caretmode-caretmode-enum-caretmode-caretatzero-const">int QRegExp::lastIndexIn(const </a><a href="qstring.html">QString</a> &amp;<em>str</em>, int <em>offset</em> = -1, <a href="#CaretMode-enum">QRegExp::CaretMode</a> <em>caretMode</em> = CaretAtZero) const</li>
<li><a href="#int-qregexp-lastindexin-const-qstringlist-qstringlist-html-list-int-from-const">int QRegExp::lastIndexIn(const </a><a href="qstringlist.html">QStringList</a> &amp;<em>list</em>, int <em>from</em>) const</li>
<li><a href="#int-qregexp-matchedlength-const">int QRegExp::matchedLength() const</a></li>
<li><a href="#qstring-qstring-html-qregexp-pattern-const-2">QString</a></li>
<li><a href="#qregexp-patternsyntax-patternsyntax-enum-qregexp-patternsyntax-const">QRegExp::PatternSyntax</a></li>
<li><a href="#int-qregexp-pos-int-nth-0-const">int QRegExp::pos(int <em>nth</em> = 0) const</a></li>
<li><a href="#qstring-qstring-html-qregexp-removein-const-qstring-qstring-html-str-const-3">QString</a></li>
<li><a href="#qstring-qstring-html-qregexp-replacein-const-qstring-qstring-html-str-const-qstring-qstring-html-after-const-4">QString</a></li>
<li><a href="#qstringlist-qstringlist-html-qregexp-replacein-const-qstringlist-qstringlist-html-stringlist-const-qstring-qstring-html-after-const-2">QStringList</a></li>
<li><a href="#void-qregexp-setcasesensitivity-qt-casesensitivity-qt-html-casesensitivity-enum-cs">void QRegExp::setCaseSensitivity(</a><a href="qt.html#CaseSensitivity-enum">Qt::CaseSensitivity</a> <em>cs</em>)</li>
<li><a href="#void-qregexp-setminimal-bool-minimal">void QRegExp::setMinimal(bool <em>minimal</em>)</a></li>
<li><a href="#void-qregexp-setpattern-const-qstring-qstring-html-pattern">void QRegExp::setPattern(const </a><a href="qstring.html">QString</a> &amp;<em>pattern</em>)</li>
<li><a href="#void-qregexp-setpatternsyntax-qregexp-patternsyntax-patternsyntax-enum-syntax">void QRegExp::setPatternSyntax(</a><a href="#PatternSyntax-enum">QRegExp::PatternSyntax</a> <em>syntax</em>)</li>
<li><a href="#qstringlist-qstringlist-html-qregexp-splitstring-const-qstring-qstring-html-str-qt-splitbehavior-qt-html-splitbehaviorflags-enum-behavior-qt-keepemptyparts-const-3">QStringList</a></li>
<li><a href="#void-qregexp-swap-qregexp-qregexp-other">void QRegExp::swap(</a><a href="#QRegExp">QRegExp</a> &amp;<em>other</em>)</li>
<li><a href="#qvariant-qvariant-html-qregexp-operator-qvariant-const">QVariant</a></li>
<li><a href="#bool-qregexp-operator-const-qregexp-qregexp-rx-const">bool QRegExp::operator!=(const </a><a href="#QRegExp">QRegExp</a> &amp;<em>rx</em>) const</li>
<li><a href="#bool-qregexp-operator-const-qregexp-qregexp-rx-const">bool QRegExp::operator==(const </a><a href="#QRegExp">QRegExp</a> &amp;<em>rx</em>) const</li>
</ul>
</li>
<li><a href="#xiang-guan-fei-cheng-yuan-1">相关非成员</a><ul>
<li><a href="#since-5-6-size-t-qhash-const-qregexp-qregexp-key-size-t-seed-0"><code>[since 5.6]</code>size_t qHash(const </a><a href="#QRegExp">QRegExp</a> &amp;<em>key</em>, size_t <em>seed</em> = 0)</li>
<li><a href="#qdatastream-qdatastream-html-operator-qdatastream-qdatastream-html-out-const-qregexp-qregexp-regexp">QDataStream</a></li>
<li><a href="#qdatastream-qdatastream-html-operator-qdatastream-qdatastream-html-in-qregexp-qregexp-regexp-1">QDataStream</a></li>
</ul>
</li>
</ul>
</li>
</ul>
<!-- tocstop -->

</div>
# QRegExp Class

<p>QRegExp类使用正则表达式提供模式匹配. <a href="#%E8%AF%A6%E7%BB%86%E6%8F%8F%E8%BF%B0">More…</a></p>
<table>
<thead>
<tr>
<th>Header:</th>
<th>#include <qregexp></qregexp></th>
</tr>
</thead>
<tbody><tr>
<td>CMake:</td>
<td>find_package(Qt6 COMPONENTS Core5Compat REQUIRED) target_link_libraries(mytarget PRIVATE Qt6::Core5Compat)</td>
</tr>
<tr>
<td>qmake:</td>
<td>QT += core5compat</td>
</tr>
</tbody></table>
<ul>
<li><a href="qregexp-members.html">List of all members, including inherited members</a></li>
</ul>
<p><strong>Note:</strong> All functions in this class are <a href="threads-reentrancy.html">reentrant</a>.</p>
<h2><span id="gong-gong-lei-xing">公共类型</span><a href="#gong-gong-lei-xing" class="header-anchor">#</a></h2><table>
<thead>
<tr>
<th>enum</th>
<th><strong><a href="#CaretMode-enum">CaretMode</a></strong> { CaretAtZero, CaretAtOffset, CaretWontMatch }</th>
</tr>
</thead>
<tbody><tr>
<td>enum</td>
<td><strong><a href="#PatternSyntax-enum">PatternSyntax</a></strong> { RegExp, RegExp2, Wildcard, WildcardUnix, FixedString, W3CXmlSchema11 }</td>
</tr>
</tbody></table>
<h2><span id="gong-gong-han-shu">公共函数</span><a href="#gong-gong-han-shu" class="header-anchor">#</a></h2><table>
<thead>
<tr>
<th></th>
<th><strong><a href="#QRegExp-2">QRegExp</a></strong>(const QRegExp &amp;<em>rx</em>)</th>
</tr>
</thead>
<tbody><tr>
<td></td>
<td><strong><a href="#QRegExp-1">QRegExp</a></strong>(const QString &amp;<em>pattern</em>, Qt::CaseSensitivity <em>cs</em> = Qt::CaseSensitive, QRegExp::PatternSyntax <em>syntax</em> = RegExp)</td>
</tr>
<tr>
<td></td>
<td><strong><a href="#QRegExp">QRegExp</a></strong>()</td>
</tr>
<tr>
<td>QRegExp &amp;</td>
<td><strong><a href="#operator-eq-1">operator=</a></strong>(QRegExp &amp;&amp;<em>other</em>)</td>
</tr>
<tr>
<td>QRegExp &amp;</td>
<td><strong><a href="#operator-eq">operator=</a></strong>(const QRegExp &amp;<em>rx</em>)</td>
</tr>
<tr>
<td></td>
<td><strong><a href="#dtor.QRegExp">~QRegExp</a></strong>()</td>
</tr>
<tr>
<td>QString</td>
<td><strong><a href="#cap">cap</a></strong>(int <em>nth</em> = 0) const</td>
</tr>
<tr>
<td>int</td>
<td><strong><a href="#captureCount">captureCount</a></strong>() const</td>
</tr>
<tr>
<td>QStringList</td>
<td><strong><a href="#capturedTexts">capturedTexts</a></strong>() const</td>
</tr>
<tr>
<td>Qt::CaseSensitivity</td>
<td><strong><a href="#caseSensitivity">caseSensitivity</a></strong>() const</td>
</tr>
<tr>
<td>int</td>
<td><strong><a href="#countIn">countIn</a></strong>(const QString &amp;<em>str</em>) const</td>
</tr>
<tr>
<td>QString</td>
<td><strong><a href="#errorString">errorString</a></strong>() const</td>
</tr>
<tr>
<td>bool</td>
<td><strong><a href="#exactMatch">exactMatch</a></strong>(const QString &amp;<em>str</em>) const</td>
</tr>
<tr>
<td>QStringList</td>
<td><strong><a href="#filterList">filterList</a></strong>(const QStringList &amp;<em>stringList</em>) const</td>
</tr>
<tr>
<td>int</td>
<td><strong><a href="#indexIn">indexIn</a></strong>(const QString &amp;<em>str</em>, int <em>offset</em> = 0, QRegExp::CaretMode <em>caretMode</em> = CaretAtZero) const</td>
</tr>
<tr>
<td>int</td>
<td><strong><a href="#indexIn-1">indexIn</a></strong>(const QStringList &amp;<em>list</em>, int <em>from</em>) const</td>
</tr>
<tr>
<td>bool</td>
<td><strong><a href="#isEmpty">isEmpty</a></strong>() const</td>
</tr>
<tr>
<td>bool</td>
<td><strong><a href="#isMinimal">isMinimal</a></strong>() const</td>
</tr>
<tr>
<td>bool</td>
<td><strong><a href="#isValid">isValid</a></strong>() const</td>
</tr>
<tr>
<td>int</td>
<td><strong><a href="#lastIndexIn">lastIndexIn</a></strong>(const QString &amp;<em>str</em>, int <em>offset</em> = -1, QRegExp::CaretMode <em>caretMode</em> = CaretAtZero) const</td>
</tr>
<tr>
<td>int</td>
<td><strong><a href="#lastIndexIn-1">lastIndexIn</a></strong>(const QStringList &amp;<em>list</em>, int <em>from</em>) const</td>
</tr>
<tr>
<td>int</td>
<td><strong><a href="#matchedLength">matchedLength</a></strong>() const</td>
</tr>
<tr>
<td>QString</td>
<td><strong><a href="#pattern">pattern</a></strong>() const</td>
</tr>
<tr>
<td>QRegExp::PatternSyntax</td>
<td><strong><a href="#patternSyntax">patternSyntax</a></strong>() const</td>
</tr>
<tr>
<td>int</td>
<td><strong><a href="#pos">pos</a></strong>(int <em>nth</em> = 0) const</td>
</tr>
<tr>
<td>QString</td>
<td><strong><a href="#removeIn">removeIn</a></strong>(const QString &amp;<em>str</em>) const</td>
</tr>
<tr>
<td>QString</td>
<td><strong><a href="#replaceIn">replaceIn</a></strong>(const QString &amp;<em>str</em>, const QString &amp;<em>after</em>) const</td>
</tr>
<tr>
<td>QStringList</td>
<td><strong><a href="#replaceIn-1">replaceIn</a></strong>(const QStringList &amp;<em>stringList</em>, const QString &amp;<em>after</em>) const</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="#setCaseSensitivity">setCaseSensitivity</a></strong>(Qt::CaseSensitivity <em>cs</em>)</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="#setMinimal">setMinimal</a></strong>(bool <em>minimal</em>)</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="#setPattern">setPattern</a></strong>(const QString &amp;<em>pattern</em>)</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="#setPatternSyntax">setPatternSyntax</a></strong>(QRegExp::PatternSyntax <em>syntax</em>)</td>
</tr>
<tr>
<td>QStringList</td>
<td><strong><a href="#splitString">splitString</a></strong>(const QString &amp;<em>str</em>, Qt::SplitBehavior <em>behavior</em> = Qt::KeepEmptyParts) const</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="#swap">swap</a></strong>(QRegExp &amp;<em>other</em>)</td>
</tr>
<tr>
<td>QVariant</td>
<td><strong><a href="#operator-QVariant">operator QVariant</a></strong>() const</td>
</tr>
<tr>
<td>bool</td>
<td><strong><a href="#operator-not-eq">operator!=</a></strong>(const QRegExp &amp;<em>rx</em>) const</td>
</tr>
<tr>
<td>bool</td>
<td><strong><a href="#operator-eq-eq">operator==</a></strong>(const QRegExp &amp;<em>rx</em>) const</td>
</tr>
</tbody></table>
<h2><span id="jing-tai-gong-gong-cheng-yuan">静态公共成员</span><a href="#jing-tai-gong-gong-cheng-yuan" class="header-anchor">#</a></h2><table>
<thead>
<tr>
<th>QString</th>
<th><strong><a href="#escape">escape</a></strong>(const QString &amp;<em>str</em>)</th>
</tr>
</thead>
<tbody><tr>
<td></td>
<td></td>
</tr>
</tbody></table>
<h2><span id="xiang-guan-fei-cheng-yuan">相关非成员</span><a href="#xiang-guan-fei-cheng-yuan" class="header-anchor">#</a></h2><table>
<thead>
<tr>
<th>size_t</th>
<th><strong><a href="#qHash">qHash</a></strong>(const QRegExp &amp;<em>key</em>, size_t <em>seed</em> = 0)</th>
</tr>
</thead>
<tbody><tr>
<td>QDataStream &amp;</td>
<td><strong><a href="#operator-lt-lt">operator&lt;&lt;</a></strong>(QDataStream &amp;<em>out</em>, const QRegExp &amp;<em>regExp</em>)</td>
</tr>
<tr>
<td>QDataStream &amp;</td>
<td><strong><a href="#operator-gt-gt">operator&gt;&gt;</a></strong>(QDataStream &amp;<em>in</em>, QRegExp &amp;<em>regExp</em>)</td>
</tr>
</tbody></table>
<h2><span id="xiang-xi-miao-shu">详细描述</span><a href="#xiang-xi-miao-shu" class="header-anchor">#</a></h2><p>这个类在Qt 6中被废弃了。请使用 <a href="qregularexpression.html">QRegularExpression</a> 来代替所有的新代码。关于将旧代码从 QRegExp 移植到 <a href="qregularexpression.html">QRegularExpression</a> 的指南，请参阅 {Porting to <a href="qregularexpression.html">QRegularExpression</a>}。</p>
<p>正则表达式，或称 “regexp”，是一种用于匹配文本中子串的模式。这在许多情况下都很有用，例如:</p>
<table>
<thead>
<tr>
<th>验证</th>
<th>一个regexp可以测试一个子串是否符合某些标准，例如，是一个整数或不包含空格。</th>
</tr>
</thead>
<tbody><tr>
<td>搜索</td>
<td>regexp提供了比简单子串匹配更强大的模式匹配，例如，匹配<em>mail</em>、<em>letter</em>或<em>correspondence</em>中的一个词，但不匹配<em>email</em>、<em>mailman</em>、<em>mailer</em>、<em>letterbox</em>等词。</td>
</tr>
<tr>
<td>搜索和替换</td>
<td>一个重合表达式可以用不同的子串替换所有出现的子串，例如，用*&amp;<em>替换所有出现的</em>&amp;<em>，除非</em>&amp;<em>后面已经有一个</em>amp;*。</td>
</tr>
<tr>
<td>字符串拆分</td>
<td>一个regexp可以用来识别一个字符串应该被分割的地方，例如分割以tab为界的字符串。</td>
</tr>
</tbody></table>
<p>介绍了对regexps的简单介绍，对Qt的regexp语言的描述，一些例子，以及函数本身的文档。QRegExp是以Perl的regexp语言为模型。它完全支持Unicode。QRegExp也可以在更简单的*通配符模式下使用，这与命令壳中的功能相似。QRegExp使用的语法规则可以通过<a href="#setPatternSyntax">setPatternSyntax</a>()改变。特别是，模式语法可以被设置为<a href="#PatternSyntax-enum">QRegExp::FixedString</a>，这意味着要匹配的模式被解释为纯字符串，即特殊字符（例如反斜杠）不被转义。</p>
<p>关于regexps的一篇好文章是<em>Mastering Regular Expressions</em>（第三版），作者Jeffrey E. F. Friedl，ISBN 0-596-52812-4。</p>
<p><strong>注：</strong>在Qt 5中，新的<a href="qregularexpression.html">QRegularExpression</a>类提供了一个与Perl兼容的正则表达式实现，建议用它来代替QRegExp。</p>
<h3><span id="jian-jie">简介</span><a href="#jian-jie" class="header-anchor">#</a></h3><p>Regexps是由表达式、量词和断言构成的。最简单的表达式是一个字符，例如：<strong>x</strong>或<strong>5</strong>。一个表达式也可以是一组用方括号括起来的字符。**[ABCD]<strong>将匹配一个</strong>A<strong>或一个</strong>B<strong>或一个</strong>C<strong>或一个</strong>D<strong>。我们可以把这个同样的表达式写成</strong>[A-D]<strong>，而匹配英文字母中任何大写字母的表达式则写成</strong>[A-Z]**。</p>
<p>量词指定了必须被匹配的表达式的出现次数。<strong>x{1,1}<strong>表示匹配一个且只有一个</strong>x</strong>。<strong>x{1,5}<strong>表示匹配一个至少包含一个</strong>x</strong>但不超过五个的<strong>x</strong>字符序列。</p>
<p>请注意，通常正则表达式不能用于检查平衡的括号或标签。例如, 如果<code>标签没有嵌套，可以写一个重定式来匹配html开头的</code>和它的结尾<code>，但是如果</code>标签是嵌套的，同样的重定式将匹配一个开头的<code>标签和错误的结尾</code>。对于片段<code>bold bolder</code>，第一个<code>将与第一个</code>匹配， 这是不正确的.但是，可以编写一个正确匹配嵌套括号或标签的正则表达式，但前提是嵌套级别的数量是固定且已知的。 如果嵌套层数不固定且不知道，就不可能编写一个不会失败的正则表达式。</p>
<p>假设我们想用一个表达式来匹配0到99范围内的整数，至少需要一个数字，所以我们从表达式**[0-9]{1,1}<strong>开始，它正好可以匹配一个数字。这个表达式可以匹配0到9范围内的整数。为了匹配最大99的整数，将最大出现次数增加到2，因此该表达式成为</strong>[0-9]{1,2}<strong>。这个重合表达式满足了最初的要求，即匹配0到99的整数，但它也会匹配出现在字符串中间的整数。如果我们希望匹配的整数是整个字符串，我们必须使用锚定断言，</strong>^<strong>（粗体字）和</strong>$<strong>（美元）。当</strong>^<strong>是regexp中的第一个字符时，它意味着regexp必须从字符串的开头开始匹配。当</strong>$<strong>是表达式的最后一个字符时，它意味着表达式必须匹配到字符串的末尾。重组表达式变成</strong>^[0-9]{1,2}$<strong>。注意，断言，例如</strong>^<strong>和</strong>$**，并不匹配字符，而是匹配字符串中的位置。</p>
<p>如果你在其他地方看到过对表达式的描述，它们可能看起来与这里显示的表达式不同。这是因为一些字符集和一些量词非常常见，以至于它们被赋予了特殊的符号来表示它们。**[0-9]<strong>可以用符号</strong>\d<strong>代替。准确匹配一次出现的量词，</strong>{1,1}<strong>，可以用表达式本身代替，即</strong>x{1,1}<strong>与</strong>x<strong>相同。所以我们的0到99匹配器可以写成</strong>^\d{1,2}$<strong>。它也可以写成</strong>^\d\d{0,1}$<strong>，即<em>从字符串开始，匹配一个数字，后面紧接着0或1个数字</em>。在实践中，它将被写成</strong>^\d\d?$<strong>。</strong>?<strong>是量词</strong>{0,1}<strong>的简写，即0或1的出现次数。</strong>?**使表达式具有可选性。regexp **^\d\d?$*<em>的意思是</em>从字符串的开始，匹配一个数字，紧接着是0或1个数字，紧接着是 字符串的结束*。</p>
<p>编写一个匹配单词’mail’<em>或</em>“letter”<em>或</em>“correspondence”但不匹配包含这些单词的单词的正则表达式，例如“email”、“mailman”、“mailer”和“letterbox”，以匹配“mail”的正则表达式开头。完全表达，正则表达式是<strong>m{1,1}a{1,1}i{1,1}l{1,1}<strong>，但是因为一个字符表达式是由</strong>{1,1自动量化的}<strong>，我们可以将正则表达式简化为</strong>mail</strong>，即“m”后接“a”后接“i”后接“l”。现在我们可以使用竖线**|<strong>，意思是</strong>或<strong>来包含另外两个词，所以我们匹配三个词中的任何一个的正则表达式变成了</strong>mail|letter|correspondence<strong>。匹配“mail”</strong>或<strong>“letter”</strong>或<strong>“correspondence”。虽然此正则表达式将匹配我们要匹配的三个单词之一，但它也会匹配我们不想匹配的单词，例如“email”。为了防止正则表达式匹配不需要的单词，我们必须告诉它在单词边界开始和结束匹配。首先，我们将正则表达式括在括号中，</strong>(mail|letter|correspondence)<strong>。括号将表达式组合在一起，它们标识了我们希望 <a href="#capturing-text">capture</a> 的正则表达式的一部分。将表达式括在括号中允许我们将其用作更复杂的正则表达式中的组件。它还允许我们检查三个单词中的哪个单词实际上是匹配的。为了强制匹配在单词边界开始和结束，我们将正则表达式包含在 <strong>\b</strong> <em>word boundary</em> 断言中：</strong>\b(mail|letter|correspondence)\b*<em>。现在正则表达式的意思是：</em>匹配一个单词边界，然后是括号中的正则表达式，然后是一个单词边界*。 <strong>\b</strong> 断言匹配正则表达式中的 <em>position</em>，而不是 <em>character</em>。单词边界是任何非单词字符，例如空格、换行符或字符串的开头或结尾。</p>
<p>如果我们想用HTML实体**&amp;<strong>来替换安培尔符号，那么要匹配的重合指数就是</strong>&amp;<strong>。但是这个重合表达式也会匹配已经被转换为HTML实体的安培尔符号。我们只想替换那些后面没有</strong>amp;<strong>的安培数。为此，我们需要负向查找断言，</strong>(?!<strong>__</strong>)<strong>。然后，这个重构式可以写成</strong>&amp;(?!amp;)<strong>，也就是说，匹配一个</strong>没有** **amp;**的安培号。 </p>
<p>如果我们想计算字符串中所有出现的 ‘Eric’ 和 ‘Eirik’，两个有效的解决方案是 <strong>\b(Eric|Eirik)\b</strong> 和 <strong>\bEi?ri[ck]\b</strong> 。 单词边界断言 ‘\b’ 是必需的，以避免匹配包含任一名称的单词，例如 ‘Ericsson’。 请注意，第二个正则表达式匹配的拼写比我们想要的要多：’Eric’、’Erik’、’Eiric’ 和 ‘Eirik’。</p>
<p>上面讨论的一些示例在 <a href="#code-examples">代码示例</a> 部分中实现。</p>
<h3><span id="zi-fu-he-zi-fu-ji-de-suo-xie">字符和字符集的缩写</span><a href="#zi-fu-he-zi-fu-ji-de-suo-xie" class="header-anchor">#</a></h3><table>
<thead>
<tr>
<th align="center">Element</th>
<th align="center">Meaning</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><strong>c</strong></td>
<td align="center">一个字符代表它自己，除非它具有特殊的正则表达式含义。 例如 <strong>c</strong> 匹配字符 <em>c</em>。</td>
</tr>
<tr>
<td align="center"><strong>\c</strong></td>
<td align="center">反斜杠后面的字符与字符本身匹配，但下面指定的除外。 例如，要匹配字符串开头的文字插入符号，请编写 <strong>^</strong>。</td>
</tr>
<tr>
<td align="center"><strong>\a</strong></td>
<td align="center">匹配ASCII铃声（BEL，0x07）。</td>
</tr>
<tr>
<td align="center"><strong>\f</strong></td>
<td align="center">匹配ASCII表格进位（FF，0x0C）。</td>
</tr>
<tr>
<td align="center"><strong>\n</strong></td>
<td align="center">匹配ASCII换行（LF，0x0A，Unix换行）。</td>
</tr>
<tr>
<td align="center"><strong>\r</strong></td>
<td align="center">匹配ASCII回车键（CR，0x0D）。</td>
</tr>
<tr>
<td align="center"><strong>\t</strong></td>
<td align="center">匹配ASCII水平制表符（HT，0x09）。</td>
</tr>
<tr>
<td align="center"><strong>\v</strong></td>
<td align="center">匹配ASCII垂直制表符（VT，0x0B）。</td>
</tr>
<tr>
<td align="center"><strong>\x*hhhh*</strong></td>
<td align="center">匹配对应于十六进制数字<em>hhhh</em>（0x0000和0xFFFF之间）的Unicode字符。</td>
</tr>
<tr>
<td align="center"><strong>\0*ooo*</strong> (i.e., \zero <em>ooo</em>)</td>
<td align="center">匹配八进制数字<em>ooo</em>的ASCII/Latin1字符（在0和0377之间）。</td>
</tr>
<tr>
<td align="center"><strong>. (dot)</strong></td>
<td align="center">匹配任何字符（包括换行）。</td>
</tr>
<tr>
<td align="center"><strong>\d</strong></td>
<td align="center">匹配一个数字（<a href="qchar.html#isDigit">QChar::isDigit</a>()）。</td>
</tr>
<tr>
<td align="center"><strong>\D</strong></td>
<td align="center">匹配一个非数字。</td>
</tr>
<tr>
<td align="center"><strong>\s</strong></td>
<td align="center">匹配一个空白字符（<a href="qchar.html#isSpace">QChar::isSpace</a>()）。</td>
</tr>
<tr>
<td align="center"><strong>\S</strong></td>
<td align="center">匹配一个非空格字符。</td>
</tr>
<tr>
<td align="center"><strong>\w</strong></td>
<td align="center">匹配一个单词字符（<a href="qchar.html#isLetterOrNumber">QChar::isLetterOrNumber</a>(), <a href="qchar.html#isMark">QChar::isMark</a>(), 或 ‘<a href="qromancalendar.html">_</a>‘）。</td>
</tr>
<tr>
<td align="center"><strong>\W</strong></td>
<td align="center">匹配一个非单词字符。</td>
</tr>
<tr>
<td align="center"><strong>*n*</strong></td>
<td align="center">第<em>n</em>个反向参考，例如： （1）、（2）等。</td>
</tr>
</tbody></table>
<p><strong>注意：</strong>C++编译器会在字符串中转换反斜线。要在一个重构公式中包括一个<code>\</code>，请输入两次，即<code>\\</code>。要匹配反斜线字符本身，请输入四次，即：<code>\\\\</code>。</p>
<h3><span id="zi-fu-ji">字符集</span><a href="#zi-fu-ji" class="header-anchor">#</a></h3><p>方括号表示匹配方括号中包含的任何字符。 上述字符集缩写可以出现在方括号中的字符集中。 除字符集缩写和以下两种例外情况外，方括号中的字符没有特殊含义。</p>
<table>
<thead>
<tr>
<th><strong>^</strong></th>
<th>如果插入符号作为第一个字符出现（即紧跟在左方括号之后），则插入符号否定字符集。 <strong>[abc]</strong> 匹配 ‘a’ 或 ‘b’ 或 ‘c’，但 <strong>[^abc]</strong> 匹配任何 <em>but</em> ‘a’ 或 ‘b’ 或 ‘c’。</th>
</tr>
</thead>
<tbody><tr>
<td><strong>-</strong></td>
<td>破折号表示字符范围。 <strong>[W-Z]</strong> 匹配“W”或“X”或“Y”或“Z”。</td>
</tr>
</tbody></table>
<p>使用预定义的字符集缩写比使用跨平台和跨语言的字符范围更便于移植。 例如，**[0-9]** 匹配西方字母中的数字，但 <strong>\d</strong> 匹配 <em>any</em> 字母中的数字。</p>
<p>注意：在其他正则表达式文档中，字符集通常称为“字符类”。</p>
<h3><span id="xian-ding-ci">限定词</span><a href="#xian-ding-ci" class="header-anchor">#</a></h3><p>默认情况下，一个表达式由 <strong>{1,1}</strong> 自动量化，即它应该只出现一次。 在下面的列表中，*<strong>E*</strong> 代表表达式。 表达式是一个字符，或一组字符的缩写，或方括号中的一组字符，或括号中的表达式。</p>
<table>
<thead>
<tr>
<th>*<strong>E*?</strong></th>
<th>匹配 0 次或 1 次 <em>E</em>。 这个量词的意思是<em>前面的表达式是可选的</em>，因为它会匹配表达式是否被找到。 <strong><em>E*?</em>* 与 *<strong>E*{0,1}</strong> 相同。 例如，</strong>dents?** 匹配 ‘dent’ 或 ‘dents’。</th>
</tr>
</thead>
<tbody><tr>
<td>*<strong>E*+</strong></td>
<td>匹配一个或多个 <em>E</em>。 <strong><em>E*+</em>* 与 *<strong>E*{1,}</strong> 相同。 例如，</strong>0+** 匹配“0”、“00”、“000”等。</td>
</tr>
<tr>
<td><em><strong>E*</strong></em></td>
<td>匹配零次或多次出现的 <em>E</em>。 它与 *<strong>E*{0,}</strong> 相同。 在应该使用 <strong>+</strong> 的地方经常错误地使用 ***** 量词。 例如，如果在表达式中使用 <strong>\s*$</strong> 来匹配以空格结尾的字符串，它将匹配每个字符串，因为 <strong>\s*$</strong> 表示 <em>匹配零个或多个空格后跟 字符串结尾</em>。 匹配至少有一个尾随空白字符的字符串的正确正则表达式是 **\s+$**。</td>
</tr>
<tr>
<td>*<strong>E*{n}</strong></td>
<td>准确匹配<em>E</em>的<em>n</em>次出现。<em>**E*{n}<strong>等同于重复<em>E</em> <em>n</em>次。例如，</strong>x{5}<strong>与</strong>xxxxx</em><em>相同。它也与</em>**E*{n,n}<strong>相同，例如，</strong>x{5,5}**。</td>
</tr>
<tr>
<td>*<strong>E*{n,}</strong></td>
<td>至少匹配<em>E</em>的<em>n</em>次出现。</td>
</tr>
<tr>
<td>*<strong>E*{,m}</strong></td>
<td>最多匹配<em>E</em>的<em>m</em>次出现。**<em>E*{,m}<strong>与</strong></em>E*{0,m}**相同。</td>
</tr>
<tr>
<td>*<strong>E*{n,m}</strong></td>
<td>匹配至少<em>n</em>和最多<em>m</em>出现的<em>E</em>。</td>
</tr>
</tbody></table>
<p>要将一个量词应用于不仅仅是前面的字符，请使用括号将表达式中的字符分组。例如，**tag+<strong>匹配一个’t’，后面是一个’a’，后面是至少一个’g’，而</strong>（tag）+**匹配至少一个’tag’的出现。</p>
<p>注意：量词通常是 “贪婪的”。它们总是尽可能多地匹配文本。例如，**0+**匹配它发现的第一个零和第一个零之后的所有连续的零。应用于 “20005”，它匹配 “20005”。量词可以变得不贪婪，见<a href="#setMinimal">setMinimal</a>()。</p>
<p>括号允许我们将元素组合在一起，以便我们能够量化和捕捉它们。例如，如果我们有匹配一个字符串的表达式<strong>mail|letter|correspondence</strong>，我们知道其中<em>个词是匹配的，但不知道是哪一个。使用小括号可以让我们 “捕获 “在其范围内匹配的任何内容，因此，如果我们使用</em>*(mail|letter|correspondence)**并将这个重构表达式与字符串 “我给你发了一些电子邮件 “相匹配，我们可以使用<a href="#cap">cap</a>()或<a href="#capturedTexts">capturedTexts</a>()函数来提取匹配字符，在这种情况下是 ‘mail’。</p>
<p>我们可以在regexp本身中使用捕获的文本。为了引用捕获的文本，我们使用<em>backreferences</em>，其索引从1开始，与<a href="#cap">cap</a>()的情况相同。例如，我们可以使用<strong>b(\w+)\W+\1\b</strong>来搜索一个字符串中的重复单词，这意味着匹配一个单词边界，后面是一个或多个单词字符，后面是一个或多个非单词字符，后面是与第一个括号表达式相同的文本，后面是一个单词边界。</p>
<p>如果我们想纯粹使用小括号进行分组而不是捕捉，我们可以使用非捕捉语法，例如**(?:green|blue)**。非捕获性括号以<code>(?:</code>开始，以<code>)</code>结束。在这个例子中，我们匹配了 “green “或 “blue”，但我们没有捕获匹配，所以我们只知道我们是否匹配，但不知道我们实际上找到了哪种颜色。使用非捕获式小括号比使用捕获式小括号更有效，因为regexp引擎需要做的记账工作更少。</p>
<p>捕捉性和非捕捉性括号都可以嵌套。</p>
<p>由于历史原因，适用于捕获括号的量词（例如*****************）比其他量词更 “贪婪”。例如， <strong>a*(a*)</strong> 将匹配cap(1)==”aaa “的 “aaa”。这种行为与其他regexp引擎的做法不同（特别是Perl）。为了获得更直观的捕获行为，请在QRegExp构造函数中指定<a href="#PatternSyntax-enum">QRegExp::RegExp2</a>，或者调用<a href="#setPatternSyntax">setPatternSyntax</a>(<a href="#PatternSyntax-enum">QRegExp::RegExp2</a>)。</p>
<p>当不能事先确定匹配的数量时，一个常见的习惯做法是在一个循环中使用<a href="#cap">cap</a>()。比如说：</p>
<div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-function">QRegExp <span class="hljs-title">rx</span><span class="hljs-params">(<span class="hljs-string">"(\\d+)"</span>)</span></span>;
QString str = <span class="hljs-string">"Offsets: 12 14 99 231 7"</span>;
QStringList list;
<span class="hljs-type">int</span> pos = <span class="hljs-number">0</span>;

<span class="hljs-keyword">while</span> ((pos = rx.<span class="hljs-built_in">indexIn</span>(str, pos)) != <span class="hljs-number">-1</span>) {
    list &lt;&lt; rx.<span class="hljs-built_in">cap</span>(<span class="hljs-number">1</span>);
    pos += rx.<span class="hljs-built_in">matchedLength</span>();
}
<span class="hljs-comment">// list: ["12", "14", "99", "231", "7"]</span></code></pre></div>



<h3><span id="duan-yan">断言</span><a href="#duan-yan" class="header-anchor">#</a></h3><p>断言在它们出现在regexp中的地方对文本做一些声明，但它们不匹配任何字符。在下面的列表中，***E***代表任何表达式。</p>
<table>
<thead>
<tr>
<th><strong>^</strong></th>
<th>插入符号表示字符串的开头。 如果你想匹配一个文字 <code>^</code>，你必须通过写 <code>\\^</code> 来转义它。 例如，<strong>^#include</strong> 将仅匹配 <em>begin</em> 以字符 ‘#include’ 开头的字符串。 （当插入符号是字符集中的第一个字符时，它具有特殊含义，请参阅 <a href="#sets-of-characters">字符集</a>。）</th>
</tr>
</thead>
<tbody><tr>
<td><strong>$</strong></td>
<td>美元表示字符串的结尾。 例如 <strong>\d\s*$</strong> 将匹配以数字结尾的字符串（可选地后跟空格）。 如果你想匹配一个文字 <code>$</code>，你必须通过写 <code>\\$</code> 来转义它。</td>
</tr>
<tr>
<td><strong>\b</strong></td>
<td>一个词的边界。 例如，正则表达式 <strong>\bOK\b</strong> 表示在单词边界（例如字符串或空格的开头）之后立即匹配字母“O”，然后在另一个单词边界之前匹配字母“K”（例如字符串结尾或空格） ）。 但请注意，该断言实际上不匹配任何空格，因此如果我们写 <strong>(\bOK\b)</strong> 并且我们有一个匹配项，即使字符串是<code>It's OK now</code>，它也只会包含 ‘OK’。</td>
</tr>
<tr>
<td><strong>\B</strong></td>
<td>非单词边界。 只要 <strong>\b</strong> 为假，此断言就为真。 例如，如果我们在<code>Left on</code>中搜索 <strong>\Bon\B</strong>，则匹配将失败（空格和字符串结尾不是非单词边界），但它会在<code>tonne</code>中匹配。</td>
</tr>
<tr>
<td><strong>(?=*E*)</strong></td>
<td>积极展望。 如果表达式在正则表达式中的这一点匹配，则此断言为真。 例如，<strong>const(?=\s+char)</strong> 匹配 ‘const’ 后跟 ‘char’，如 <code>static const char *</code>。 （与匹配 ‘static const char *’ 的 <strong>const\s+char</strong> 进行比较。）</td>
</tr>
<tr>
<td><strong>(?!*E*)</strong></td>
<td>负向查找。如果表达式在regexp的这一点上不匹配，这个断言就是真的。例如，**const(?!\s+char)*<em>与’const’匹配，</em>除了*当它后面是’char’时。</td>
</tr>
</tbody></table>
<h3><span id="tong-pei-fu-pi-pei">通配符匹配</span><a href="#tong-pei-fu-pi-pei" class="header-anchor">#</a></h3><p>大多数命令 shell，例如 <em>bash</em> 或 <em>cmd.exe</em> 支持“文件通配符”，即使用通配符识别一组文件的能力。 <a href="#setPatternSyntax">setPatternSyntax</a>() 函数用于在正则表达式和通配符模式之间切换。 通配符匹配比完整的正则表达式简单得多，并且只有四个功能:</p>
<table>
<thead>
<tr>
<th><strong>c</strong></th>
<th>除了下面提到的那些之外，任何字符都代表它自己。 因此 <strong>c</strong> 匹配字符 <em>c</em>。</th>
</tr>
</thead>
<tbody><tr>
<td><strong>?</strong></td>
<td>匹配任何单个字符。 它与完整的正则表达式中的 <strong>.</strong> 相同。</td>
</tr>
<tr>
<td>*****</td>
<td>匹配零个或多个任意字符。 它与完整的正则表达式中的 <strong>.*</strong> 相同。</td>
</tr>
<tr>
<td><strong>[…]</strong></td>
<td>字符集可以用方括号表示，类似于完整的正则表达式。 在字符类内部，与外部一样，反斜杠没有特殊含义。</td>
</tr>
</tbody></table>
<p>在通配符模式下，不能对通配符进行转义。 在模式 <a href="#PatternSyntax-enum">WildcardUnix</a> 中，字符 ‘' 转义通配符。</p>
<p>例如，如果我们处于通配符模式并且有包含文件名的字符串，我们可以使用 ***.html** 来识别 HTML 文件。 这将匹配零个或多个字符，后跟一个点，后跟<code>h</code>、<code>t</code>、<code>m</code>和<code>l</code>。</p>
<p>要根据通配符表达式测试字符串，请使用 <a href="#exactMatch">exactMatch</a>()。 例如：</p>
<div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-function">QRegExp <span class="hljs-title">rx</span><span class="hljs-params">(<span class="hljs-string">"*.txt"</span>)</span></span>;
rx.<span class="hljs-built_in">setPatternSyntax</span>(QRegExp::Wildcard);
rx.<span class="hljs-built_in">exactMatch</span>(<span class="hljs-string">"README.txt"</span>);        <span class="hljs-comment">// returns true</span>
rx.<span class="hljs-built_in">exactMatch</span>(<span class="hljs-string">"welcome.txt.bak"</span>);   <span class="hljs-comment">// returns false</span></code></pre></div>



<h3><span id="perl-yong-hu-zhu-yi-shi-xiang">Perl 用户注意事项</span><a href="#perl-yong-hu-zhu-yi-shi-xiang" class="header-anchor">#</a></h3><p>Perl 支持的大多数字符类缩写都由 QRegExp 支持，请参阅 <a href="#characters-and-abbreviations-for-sets-of-characters">characters and abbreviations for sets of characters</a>。</p>
<p>在 QRegExp 中，除了在字符类中，<code>^</code> 总是表示字符串的开始，因此插入符号必须始终被转义，除非用于该目的。 在 Perl 中，插入符号的含义会根据它出现的位置自动变化，因此很少需要转义。 这同样适用于 <code>$</code>，它在 QRegExp 中总是表示字符串的结尾。</p>
<p>QRegExp 的量词与 Perl 的贪心量词相同（但请参见 <a href="#greedy-quantifiers">note above</a>）。 非贪心匹配不能应用于单个量词，但可以应用于模式中的所有量词。 例如，要匹配 Perl 正则表达式 <strong>ro+?m</strong> 需要:</p>
<div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-function">QRegExp <span class="hljs-title">rx</span><span class="hljs-params">(<span class="hljs-string">"ro+m"</span>)</span></span>;
rx.<span class="hljs-built_in">setMinimal</span>(<span class="hljs-literal">true</span>);</code></pre></div>

<p>Perl 的 <code>/i</code> 选项等价于 <a href="#setCaseSensitivity">setCaseSensitivity</a>(<a href="qt.html#CaseSensitivity-enum">Qt::CaseInsensitive</a>)。</p>
<p>Perl 的 <code>/g</code> 选项可以使用 <a href="#cap-in-a-loop">loop</a> 来模拟。</p>
<p>在 QRegExp 中 <strong>.</strong> 匹配任何字符，因此所有 QRegExp 正则表达式都等效于 Perl 的 <code>/s</code> 选项。 QRegExp 没有与 Perl 的 <code>/m</code> 选项等效的选项，但可以通过多种方式来模拟，例如将输入拆分为行或使用搜索换行符的正则表达式进行循环。</p>
<p>因为 QRegExp 是面向字符串的，所以没有 \A、\Z 或 \z 断言。不支持 \G 断言，但可以在循环中模拟。</p>
<p>Perl 的 $&amp; 是 cap(0) 或 <a href="#capturedTexts">capturedTexts</a>()[0]。 $`、$’ 或 $+ 没有 QRegExp 等价物。 Perl 的捕获变量，$1, $2, … 对应 cap(1) 或 <a href="#capturedTexts">capturedTexts</a>()[1], cap(2) 或 <a href="#capturedTexts">capturedTexts</a>()[2] 等.</p>
<p>要替换模式，请使用 <a href="qstring.html#replace">QString::replace</a>()。</p>
<p>Perl 的扩展 <code>/x</code> 语法不受支持，指令也不支持，例如(?i) 或正则表达式注释，例如（？＃评论）。另一方面，可以使用 C++ 的文字字符串规则来实现相同的目的：</p>
<div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-function">QRegExp <span class="hljs-title">mark</span><span class="hljs-params">(<span class="hljs-string">"\\b"</span>      <span class="hljs-comment">// word boundary</span></span></span>
<span class="hljs-params"><span class="hljs-function">             <span class="hljs-string">"[Mm]ark"</span> <span class="hljs-comment">// the word we want to match</span></span></span>
<span class="hljs-params"><span class="hljs-function">            )</span></span>;</code></pre></div>

<p>使用与 Perl 相同的语法支持零宽度正和零宽度负前瞻断言 (?=pattern) 和 (?!pattern)。 不支持 Perl 的后向断言、“独立”子表达式和条件表达式。</p>
<p>也支持非捕获括号，具有相同的 (?:pattern) 语法。</p>
<p>请参阅 <a href="qstring.html#split">QString::split</a>() 和 <a href="qstringlist.html#join">QStringList::join</a>() 以了解 Perl 的 split 和 join 函数的等价物。</p>
<p>注意：因为 C++ 转换 's 它们必须在代码中写<em>两次</em>，例如 <strong>\b</strong> 必须写成 <strong>\\b</strong>。</p>
<h3><span id="dai-ma-shi-li">代码示例</span><a href="#dai-ma-shi-li" class="header-anchor">#</a></h3><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-function">QRegExp <span class="hljs-title">rx</span><span class="hljs-params">(<span class="hljs-string">"^\\d\\d?$"</span>)</span></span>;    <span class="hljs-comment">// match integers 0 to 99</span>
rx.<span class="hljs-built_in">indexIn</span>(<span class="hljs-string">"123"</span>);          <span class="hljs-comment">// returns -1 (no match)</span>
rx.<span class="hljs-built_in">indexIn</span>(<span class="hljs-string">"-6"</span>);           <span class="hljs-comment">// returns -1 (no match)</span>
rx.<span class="hljs-built_in">indexIn</span>(<span class="hljs-string">"6"</span>);            <span class="hljs-comment">// returns 0 (matched at position 0)</span></code></pre></div>

<p>第三个字符串匹配<code>6</code>。 这是 0 到 99 范围内整数的简单验证正则表达式。</p>
<div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-function">QRegExp <span class="hljs-title">rx</span><span class="hljs-params">(<span class="hljs-string">"^\\S+$"</span>)</span></span>;       <span class="hljs-comment">// match strings without whitespace</span>
rx.<span class="hljs-built_in">indexIn</span>(<span class="hljs-string">"Hello world"</span>);  <span class="hljs-comment">// returns -1 (no match)</span>
rx.<span class="hljs-built_in">indexIn</span>(<span class="hljs-string">"This_is-OK"</span>);   <span class="hljs-comment">// returns 0 (matched at position 0)</span></code></pre></div>

<p>第二个字符串匹配“ This_is-OK ”。我们使用了字符集缩写“\S”（非空格）和锚来匹配不包含空格的字符串。</p>
<p>在以下示例中，我们匹配包含“mail”或“letter”或“correspondence”的字符串，但仅匹配整个单词，即不匹配“email”</p>
<div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-function">QRegExp <span class="hljs-title">rx</span><span class="hljs-params">(<span class="hljs-string">"\\b(mail|letter|correspondence)\\b"</span>)</span></span>;
rx.<span class="hljs-built_in">indexIn</span>(<span class="hljs-string">"I sent you an email"</span>);     <span class="hljs-comment">// returns -1 (no match)</span>
rx.<span class="hljs-built_in">indexIn</span>(<span class="hljs-string">"Please write the letter"</span>); <span class="hljs-comment">// returns 17</span></code></pre></div>

<p> 第二个字符串匹配“Please write the letter”。单词“letter”也被捕获（因为括号）。我们可以看到我们捕获的文本是这样的： </p>
<div class="code-wrapper"><pre><code class="hljs c++">QString captured = rx.<span class="hljs-built_in">cap</span>(<span class="hljs-number">1</span>); <span class="hljs-comment">// captured == "letter"</span></code></pre></div>

<p> 这将从第一组捕获括号中捕获文本（从左到右计算捕获左括号）。括号从 1 开始计数，因为 cap(0) 是整个匹配的正则表达式（在大多数正则表达式引擎中相当于 ‘&amp;’）。 </p>
<div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-function">QRegExp <span class="hljs-title">rx</span><span class="hljs-params">(<span class="hljs-string">"&amp;(?!amp;)"</span>)</span></span>;      <span class="hljs-comment">// match ampersands but not &amp;amp;</span>
QString line1 = <span class="hljs-string">"This &amp; that"</span>;
line1.<span class="hljs-built_in">replace</span>(rx, <span class="hljs-string">"&amp;amp;"</span>);
<span class="hljs-comment">// line1 == "This &amp;amp; that"</span>
QString line2 = <span class="hljs-string">"His &amp;amp; hers &amp; theirs"</span>;
line2.<span class="hljs-built_in">replace</span>(rx, <span class="hljs-string">"&amp;amp;"</span>);
<span class="hljs-comment">// line2 == "His &amp;amp; hers &amp;amp; theirs"</span></code></pre></div>

<p> 在这里，我们将 QRegExp 传递给<a target="_blank" rel="noopener" href="https://doc.qt.io/qt-6/qstring.html">QString</a>的 replace() 函数，以用新文本替换匹配的文本。 </p>
<div class="code-wrapper"><pre><code class="hljs c++">QString str = <span class="hljs-string">"One Eric another Eirik, and an Ericsson. "</span>
    <span class="hljs-string">"How many Eiriks, Eric?"</span>;
<span class="hljs-function">QRegExp <span class="hljs-title">rx</span><span class="hljs-params">(<span class="hljs-string">"\\b(Eric|Eirik)\\b"</span>)</span></span>; <span class="hljs-comment">// match Eric or Eirik</span>
<span class="hljs-type">int</span> pos = <span class="hljs-number">0</span>;    <span class="hljs-comment">// where we are in the string</span>
<span class="hljs-type">int</span> count = <span class="hljs-number">0</span>;  <span class="hljs-comment">// how many Eric and Eirik's we've counted</span>
<span class="hljs-keyword">while</span> (pos &gt;= <span class="hljs-number">0</span>) {
    pos = rx.<span class="hljs-built_in">indexIn</span>(str, pos);
    <span class="hljs-keyword">if</span> (pos &gt;= <span class="hljs-number">0</span>) {
        ++pos;      <span class="hljs-comment">// move along in str</span>
        ++count;    <span class="hljs-comment">// count our Eric or Eirik</span>
    }
}</code></pre></div>

<p>我们使用<a target="_blank" rel="noopener" href="https://doc.qt.io/qt-6/qregexp.html#indexIn">indexIn</a> () 函数重复匹配字符串中的正则表达式。<code>pos++</code>请注意，我们可以编写<code>pos += rx.matchedLength()</code>跳过已经匹配的字符串，而不是一次向前移动一个字符。计数将等于 3，匹配 ‘一个Eric另一个Eirik和一个 Ericsson。多少埃里克，埃里克？它与“Ericsson”或“Eiriks”不匹配，因为它们不受非单词边界的限制。</p>
<p>正则表达式的一种常见用途是将多行分隔数据拆分为其组成字段。</p>
<div class="code-wrapper"><pre><code class="hljs c++">str = <span class="hljs-string">"The Qt Company Ltd\tqt.io\tFinland"</span>;
QString company, web, country;
rx.<span class="hljs-built_in">setPattern</span>(<span class="hljs-string">"^([^\t]+)\t([^\t]+)\t([^\t]+)$"</span>);
<span class="hljs-keyword">if</span> (rx.<span class="hljs-built_in">indexIn</span>(str) != <span class="hljs-number">-1</span>) {
    company = rx.<span class="hljs-built_in">cap</span>(<span class="hljs-number">1</span>);
    web = rx.<span class="hljs-built_in">cap</span>(<span class="hljs-number">2</span>);
    country = rx.<span class="hljs-built_in">cap</span>(<span class="hljs-number">3</span>);
}</code></pre></div>

<p> 在本例中，我们的输入行格式为公司名称、网址和国家/地区。不幸的是，正则表达式相当长并且不是很通用——如果我们添加更多字段，代码将会中断。一个更简单更好的解决方案是查找分隔符，在这种情况下为 ‘\t’，并获取周围的文本。<a target="_blank" rel="noopener" href="https://doc.qt.io/qt-6/qstring.html#split">QString::split</a> () 函数可以将分隔符字符串或正则表达式作为参数并相应地拆分字符串。 </p>
<div class="code-wrapper"><pre><code class="hljs c++">QStringList field = str.<span class="hljs-built_in">split</span>(<span class="hljs-string">"\t"</span>);</code></pre></div>

<p>这里 field[0] 是公司，field[1] 是网址等等。</p>
<p>为了模仿shell的匹配，我们可以使用通配符模式。</p>
<div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-function">QRegExp <span class="hljs-title">rx</span><span class="hljs-params">(<span class="hljs-string">"*.html"</span>)</span></span>;
rx.<span class="hljs-built_in">setPatternSyntax</span>(QRegExp::Wildcard);
rx.<span class="hljs-built_in">exactMatch</span>(<span class="hljs-string">"index.html"</span>);                <span class="hljs-comment">// returns true</span>
rx.<span class="hljs-built_in">exactMatch</span>(<span class="hljs-string">"default.htm"</span>);               <span class="hljs-comment">// returns false</span>
rx.<span class="hljs-built_in">exactMatch</span>(<span class="hljs-string">"readme.txt"</span>);                <span class="hljs-comment">// returns false</span></code></pre></div>

<p>通配符匹配很方便，因为它很简单，但是任何通配符正则表达式都可以使用完整的正则表达式来定义，例如**.*.html$<strong>。请注意，我们不能同时使用通配符匹配<code>.html</code>和<code>.htm</code>文件，除非我们使用</strong>*.htm*<strong>，它也将匹配 ‘test.html.bak’。完整的正则表达式为我们提供了所需的精度</strong>.*.html?$**。</p>
<p><a target="_blank" rel="noopener" href="https://doc.qt.io/qt-6/qregexp.html#setCaseSensitivity">QRegExp 可以使用setCaseSensitivity</a> ()进行不区分大小写的匹配，也可以使用非贪婪匹配，参见<a target="_blank" rel="noopener" href="https://doc.qt.io/qt-6/qregexp.html#setMinimal">setMinimal</a> ()。默认情况下，QRegExp 使用完整的正则表达式，但这可以通过<a target="_blank" rel="noopener" href="https://doc.qt.io/qt-6/qregexp.html#setPatternSyntax">setPatternSyntax</a> () 进行更改。可以使用<a target="_blank" rel="noopener" href="https://doc.qt.io/qt-6/qregexp.html#indexIn">indexIn</a> () 向前搜索或使用<a target="_blank" rel="noopener" href="https://doc.qt.io/qt-6/qregexp.html#lastIndexIn">lastIndexIn</a> () 向后搜索。可以使用<a target="_blank" rel="noopener" href="https://doc.qt.io/qt-6/qregexp.html#capturedTexts">captureTexts</a> () 访问捕获的文本，它返回所有捕获字符串的字符串列表，或者使用<a target="_blank" rel="noopener" href="https://doc.qt.io/qt-6/qregexp.html#cap">cap</a> () 返回给定索引的捕获字符串。<a target="_blank" rel="noopener" href="https://doc.qt.io/qt-6/qregexp.html#pos">pos</a> () 函数采用匹配索引并返回匹配的字符串中的位置（如果没有匹配，则返回 -1）。</p>
<h3><span id="yi-zhi-dao-qregularexpression">移植到 QRegularExpression</span><a href="#yi-zhi-dao-qregularexpression" class="header-anchor">#</a></h3><p>Qt 5 中引入的<a target="_blank" rel="noopener" href="https://doc.qt.io/qt-6/qregularexpression.html">QRegularExpression</a>类在提供的 API、支持的模式语法和执行速度方面是对 QRegExp 的重大改进。最大的不同是<a target="_blank" rel="noopener" href="https://doc.qt.io/qt-6/qregularexpression.html">QRegularExpression</a>只是保存了一个正则表达式，并且在请求匹配时<em>不会修改它。</em>相反，返回一个<a target="_blank" rel="noopener" href="https://doc.qt.io/qt-6/qregularexpressionmatch.html">QRegularExpressionMatch</a>对象，以检查匹配结果并提取捕获的子字符串。这同样适用于全局匹配和<a target="_blank" rel="noopener" href="https://doc.qt.io/qt-6/qregularexpressionmatchiterator.html">QRegularExpressionMatchIterator</a>。</p>
<p>其他差异概述如下。</p>
<h4><span id="bu-tong-de-mo-shi-yu-fa">不同的模式语法</span><a href="#bu-tong-de-mo-shi-yu-fa" class="header-anchor">#</a></h4><p>将正则表达式从 QRegExp 移植到<a target="_blank" rel="noopener" href="https://doc.qt.io/qt-6/qregularexpression.html">QRegularExpression</a>可能需要更改模式本身。</p>
<p>在某些情况下，QRegExp 过于宽松，接受的模式在使用<a target="_blank" rel="noopener" href="https://doc.qt.io/qt-6/qregularexpression.html">QRegularExpression</a>时根本无效。这些在某种程度上很容易检测到，因为使用这些模式构建的<a target="_blank" rel="noopener" href="https://doc.qt.io/qt-6/qregularexpression.html">QRegularExpression</a>对象无效（参见<a target="_blank" rel="noopener" href="https://doc.qt.io/qt-6/qregularexpression.html#isValid">QRegularExpression::isValid</a> ()）。</p>
<p>在其他情况下，从 QRegExp 移植到 QRegularExpression 的模式<a target="_blank" rel="noopener" href="https://doc.qt.io/qt-6/qregularexpression.html">可能</a>会默默地改变语义。因此，有必要审查所使用的模式。最值得注意的无声不兼容案例是：</p>
<ul>
<li><code>\xHHHH</code>为了使用超过 2 位的十六进制转义，需要大括号。<code>\x2022</code>需要移植到类似的模式<code>\x{2022}</code>，否则它将匹配空格 ( <code>0x20</code>) 后跟字符串<code>"22"</code>。<code>\x</code>通常，无论指定多少位数，强烈建议始终使用带有转义的花括号。</li>
<li><code>{,n}</code>需要移植一个 0 到 n 的量化，<code>{0,n}</code>以保留语义。否则，诸如这样的模式<code>\d{,3}</code>实际上会匹配一个数字后跟确切的字符串<code>"{,3}"</code>。</li>
<li>QRegExp 默认进行 Unicode 感知匹配，而<a target="_blank" rel="noopener" href="https://doc.qt.io/qt-6/qregularexpression.html">QRegularExpression</a>需要单独的选项；请参阅下面的更多细节。</li>
<li>QRegExp 中的 c{.} 默认匹配所有字符，包括换行符。<a target="_blank" rel="noopener" href="https://doc.qt.io/qt-6/qregularexpression.html">QRegularExpression</a>默认排除换行符。要包含换行符，请设置<a target="_blank" rel="noopener" href="https://doc.qt.io/qt-6/qregularexpression.html#PatternOption-enum">QRegularExpression::DotMatchesEverythingOption</a>模式选项。</li>
</ul>
<h4><span id="cong-qregexp-exactmatch-yi-zhi">从 QRegExp::exactMatch() 移植</span><a href="#cong-qregexp-exactmatch-yi-zhi" class="header-anchor">#</a></h4><p> <a target="_blank" rel="noopener" href="https://doc.qt.io/qt-6/qregexp.html#exactMatch">Qt 4 中的QRegExp::exactMatch</a> () 有两个目的：将正则表达式与主题字符串精确匹配，并实现部分匹配。 </p>
<h5><span id="cong-qregexp-de-jing-que-pi-pei-yi-zhi">从 QRegExp 的精确匹配移植</span><a href="#cong-qregexp-de-jing-que-pi-pei-yi-zhi" class="header-anchor">#</a></h5><p> 精确匹配表示正则表达式是否匹配整个主题字符串。例如，类在主题字符串上产生<code>"abc123"</code>： </p>
<table>
<thead>
<tr>
<th align="center"></th>
<th align="center"><a href="#exactMatch">QRegExp::exactMatch</a>()</th>
<th align="center"><a href="qregularexpressionmatch.html#hasMatch">QRegularExpressionMatch::hasMatch</a>()</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><code>"\\d+"</code></td>
<td align="center"><strong>false</strong></td>
<td align="center"><strong>true</strong></td>
</tr>
<tr>
<td align="center"><code>"[a-z]+\\d+"</code></td>
<td align="center"><strong>true</strong></td>
<td align="center"><strong>true</strong></td>
</tr>
</tbody></table>
<p> 精确匹配未反映在<a target="_blank" rel="noopener" href="https://doc.qt.io/qt-6/qregularexpression.html">QRegularExpression</a>中。如果要确保主题字符串与正则表达式完全匹配，可以使用<a target="_blank" rel="noopener" href="https://doc.qt.io/qt-6/qregularexpression.html#anchoredPattern">QRegularExpression::anchoredPattern</a> () 函数包装模式： </p>
<div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-function">QString <span class="hljs-title">p</span><span class="hljs-params">(<span class="hljs-string">"a .*|pattern"</span>)</span></span>;

<span class="hljs-comment">// re matches exactly the pattern string p</span>
<span class="hljs-function">QRegularExpression <span class="hljs-title">re</span><span class="hljs-params">(QRegularExpression::anchoredPattern(p))</span></span>;</code></pre></div>

<h5><span id="cong-qregexp-de-bu-fen-pi-pei-yi-zhi">从 QRegExp 的部分匹配移植</span><a href="#cong-qregexp-de-bu-fen-pi-pei-yi-zhi" class="header-anchor">#</a></h5><p>在使用<a target="_blank" rel="noopener" href="https://doc.qt.io/qt-6/qregexp.html#exactMatch">QRegExp::exactMatch () 时，如果没有找到精确匹配，仍然可以通过调用</a><a target="_blank" rel="noopener" href="https://doc.qt.io/qt-6/qregexp.html#matchedLength">QRegExp::matchedLength</a> ()来找出有多少主题字符串被正则表达式匹配。如果返回的长度等于主题字符串的长度，则可以断定找到了部分匹配。</p>
<p><a target="_blank" rel="noopener" href="https://doc.qt.io/qt-6/qregularexpression.html">QRegularExpression</a>通过适当的 MatchType 显式支持部分匹配。</p>
<h4><span id="quan-ju-pi-pei">全局匹配</span><a href="#quan-ju-pi-pei" class="header-anchor">#</a></h4><p>由于 QRegExp API 的限制，不可能正确地实现全局匹配（也就是说，就像 Perl 一样）。特别是，可以匹配 0 个字符（如<code>"a*"</code>）的模式是有问题的。</p>
<p><a target="_blank" rel="noopener" href="https://doc.qt.io/qt-6/qregularexpression.html#globalMatch">QRegularExpression::globalMatch</a> () 正确实现 Perl 全局匹配，返回的迭代器可用于检查每个结果。</p>
<h4><span id="unicode-shu-xing-zhi-chi">Unicode 属性支持</span><a href="#unicode-shu-xing-zhi-chi" class="header-anchor">#</a></h4><p>使用 QRegExp 时，诸如 , 等字符类<code>\w</code>匹配<code>\d</code>具有相应 Unicode 属性的字符：例如，<code>\d</code>匹配具有 Unicode Nd（十进制数字）属性的任何字符。</p>
<p><a target="_blank" rel="noopener" href="https://doc.qt.io/qt-6/qregularexpression.html">使用QRegularExpression</a>时，这些字符类默认仅匹配 ASCII 字符：例如，与ASCII 范围内<code>\d</code>的字符完全匹配。<code>0-9</code>可以通过使用 UseUnicodePropertiesOption 模式选项来更改此行为。</p>
<h4><span id="tong-pei-fu-pi-pei">通配符匹配</span><a href="#tong-pei-fu-pi-pei" class="header-anchor">#</a></h4><p> 在<a target="_blank" rel="noopener" href="https://doc.qt.io/qt-6/qregularexpression.html">QRegularExpression</a>中没有直接的方法来进行通配符匹配。但是，提供了 wildcardToRegularExpression 方法以将 glob 模式转换为可用于该目的的 Perl 兼容的正则表达式。 </p>
<h4><span id="qi-ta-mo-shi-yu-fa">其他模式语法</span><a href="#qi-ta-mo-shi-yu-fa" class="header-anchor">#</a></h4><p> <a target="_blank" rel="noopener" href="https://doc.qt.io/qt-6/qregularexpression.html">QRegularExpression</a>仅支持与 Perl 兼容的正则表达式。 </p>
<h4><span id="zui-xiao-pi-pei">最小匹配</span><a href="#zui-xiao-pi-pei" class="header-anchor">#</a></h4><p> <a target="_blank" rel="noopener" href="https://doc.qt.io/qt-6/qregexp.html#setMinimal">QRegExp::setMinimal</a> () 通过简单地反转量词的贪婪来实现最小匹配（QRegExp 不支持惰性量词，如<code>*?</code>,<code>+?</code>等）。<a target="_blank" rel="noopener" href="https://doc.qt.io/qt-6/qregularexpression.html">相反， QRegularExpression</a>确实支持贪婪、懒惰和所有格量词。InvertedGreedinessOption 模式选项可用于模拟<a target="_blank" rel="noopener" href="https://doc.qt.io/qt-6/qregexp.html#setMinimal">QRegExp::setMinimal</a> () 的效果：如果启用，它会反转量词的贪婪（贪婪的变得懒惰，反之亦然）。 </p>
<h4><span id="cha-ru-fu-hao-mo-shi">插入符号模式</span><a href="#cha-ru-fu-hao-mo-shi" class="header-anchor">#</a></h4><p> AnchorAtOffsetMatchOption 匹配选项可用于模拟<a target="_blank" rel="noopener" href="https://doc.qt.io/qt-6/qregexp.html#CaretMode-enum">QRegExp::CaretAtOffset</a>行为。<a target="_blank" rel="noopener" href="https://doc.qt.io/qt-6/qregexp.html#CaretMode-enum">其他QRegExp::CaretMode</a>模式没有等价物。 </p>
<p><strong>See also</strong> <a href="qstring.html">QString</a>, <a href="qstringlist.html">QStringList</a>, and <a href="qsortfilterproxymodel.html">QSortFilterProxyModel</a>.</p>
<h2><span id="cheng-yuan-lei-xing-wen-dang">成员类型文档</span><a href="#cheng-yuan-lei-xing-wen-dang" class="header-anchor">#</a></h2><h3><span id="enum-qregexp-caretmode">enum QRegExp::CaretMode</span><a href="#enum-qregexp-caretmode" class="header-anchor">#</a></h3><p> CaretMode 枚举定义了正则表达式中插入符号 ( <strong>^ ) 的不同含义。</strong>可能的值是： </p>
<table>
<thead>
<tr>
<th>Constant</th>
<th>Value</th>
<th>Description</th>
</tr>
</thead>
<tbody><tr>
<td><code>QRegExp::CaretAtZero</code></td>
<td><code>0</code></td>
<td>插入符号对应于搜索字符串中的索引 0。</td>
</tr>
<tr>
<td><code>QRegExp::CaretAtOffset</code></td>
<td><code>1</code></td>
<td>插入符号对应于搜索的起始偏移量。</td>
</tr>
<tr>
<td><code>QRegExp::CaretWontMatch</code></td>
<td><code>2</code></td>
<td>插入符号从不匹配。</td>
</tr>
</tbody></table>
<h3><span id="enum-qregexp-patternsyntax">enum QRegExp::PatternSyntax</span><a href="#enum-qregexp-patternsyntax" class="header-anchor">#</a></h3><p> 用于解释模式含义的语法。 </p>
<table>
<thead>
<tr>
<th>Constant</th>
<th>Value</th>
<th>Description</th>
</tr>
</thead>
<tbody><tr>
<td><code>QRegExp::RegExp</code></td>
<td><code>0</code></td>
<td>丰富的类似 Perl 的模式匹配语法。这是默认设置。</td>
</tr>
<tr>
<td><code>QRegExp::RegExp2</code></td>
<td><code>3</code></td>
<td>像 RegExp，但带有<a target="_blank" rel="noopener" href="https://doc.qt.io/qt-6/qregexp.html#greedy-quantifiers">贪婪的量词</a>。（在 Qt 4.2 中引入。）</td>
</tr>
<tr>
<td><code>QRegExp::Wildcard</code></td>
<td><code>1</code></td>
<td>这提供了一种简单的模式匹配语法，类似于 shell（命令解释器）用于“文件通配”的语法。请参阅<a target="_blank" rel="noopener" href="https://doc.qt.io/qt-6/qregexp.html#qregexp-wildcard-matching">QRegExp 通配符匹配</a>。</td>
</tr>
<tr>
<td><code>QRegExp::WildcardUnix</code></td>
<td><code>4</code></td>
<td>这类似于通配符，但具有 Unix shell 的行为。通配符可以用字符“\”转义。</td>
</tr>
<tr>
<td><code>QRegExp::FixedString</code></td>
<td><code>2</code></td>
<td>该模式是一个固定的字符串。这等效于在字符串上使用 RegExp 模式，其中所有元字符都使用<a target="_blank" rel="noopener" href="https://doc.qt.io/qt-6/qregexp.html#escape">escape</a> () 进行转义。</td>
</tr>
<tr>
<td><code>QRegExp::W3CXmlSchema11</code></td>
<td><code>5</code></td>
<td>该模式是 W3C XML Schema 1.1 规范定义的正则表达式。</td>
</tr>
</tbody></table>
<p><strong>See also</strong> <a href="#setPatternSyntax">setPatternSyntax</a>().</p>
<h2><span id="cheng-yuan-han-shu-wen-dang">成员函数文档</span><a href="#cheng-yuan-han-shu-wen-dang" class="header-anchor">#</a></h2><h3><span id="qregexp-qregexp-const-qregexp-amp-rx">QRegExp::QRegExp(const  &amp;<em>rx</em>)</span><a href="#qregexp-qregexp-const-qregexp-amp-rx" class="header-anchor">#</a></h3><p> 将正则表达式构造为<em>rx</em>的副本。 </p>
<p><strong>See also</strong> <a href="#operator-eq">operator=</a>().</p>
<h3><span id="qregexp-qregexp-const-qstring-amp-pattern-qt-casesensitivity-cs-qt-casesensitive-qregexp-patternsyntax-syntax-regexp">QRegExp::QRegExp(const  &amp;<em>pattern</em>,  <em>cs</em> = Qt::CaseSensitive,  <em>syntax</em> = RegExp)</span><a href="#qregexp-qregexp-const-qstring-amp-pattern-qt-casesensitivity-cs-qt-casesensitive-qregexp-patternsyntax-syntax-regexp" class="header-anchor">#</a></h3><p> 为给定的模式字符串构造一个正则表达式对象。如果<em>syntax</em> 是<a target="_blank" rel="noopener" href="https://doc.qt.io/qt-6/qregexp.html#PatternSyntax-enum">通配符</a>，则必须使用通配符表示模式；默认为正则<a target="_blank" rel="noopener" href="https://doc.qt.io/qt-6/qregexp.html#PatternSyntax-enum">表达式</a>。该模式区分大小写，除非<em>cs</em>是<a target="_blank" rel="noopener" href="https://doc.qt.io/qt-6/qt.html#CaseSensitivity-enum">Qt::CaseInsensitive</a>。匹配是贪心的（最大的），但可以通过调用<a target="_blank" rel="noopener" href="https://doc.qt.io/qt-6/qregexp.html#setMinimal">setMinimal</a> () 来改变。 </p>
<p><strong>See also</strong> <a href="#setPattern">setPattern</a>(), <a href="#setCaseSensitivity">setCaseSensitivity</a>(), and <a href="#setPatternSyntax">setPatternSyntax</a>().</p>
<h3><span id="qregexp-qregexp">QRegExp::QRegExp()</span><a href="#qregexp-qregexp" class="header-anchor">#</a></h3><p> 构造一个空的正则表达式。 </p>
<p><strong>See also</strong> <a href="#isValid">isValid</a>() and <a href="#errorString">errorString</a>().</p>
<h3><span id="since-5-2-qregexp-amp-qregexp-operator-qregexp-amp-amp-other"><code>[since 5.2]</code> &amp;QRegExp::operator=( &amp;&amp;<em>other</em>)</span><a href="#since-5-2-qregexp-amp-qregexp-operator-qregexp-amp-amp-other" class="header-anchor">#</a></h3><p><em>将other</em>移动分配给此<a target="_blank" rel="noopener" href="https://doc.qt.io/qt-6/qregexp.html">QRegExp</a>实例。</p>
<p>这个函数是在 Qt 5.2 中引入的。</p>
<h3><span id="qregexp-amp-qregexp-operator-const-qregexp-amp-rx"> &amp;QRegExp::operator=(const  &amp;<em>rx</em>)</span><a href="#qregexp-amp-qregexp-operator-const-qregexp-amp-rx" class="header-anchor">#</a></h3><p> 复制正则表达式<em>rx</em>并返回对副本的引用。还会复制区分大小写、通配符和最小匹配选项。 </p>
<h3><span id="qregexp-qregexp">QRegExp::~QRegExp()</span><a href="#qregexp-qregexp" class="header-anchor">#</a></h3><p> 销毁正则表达式并清理其内部数据。 </p>
<h3><span id="qstring-qregexp-cap-int-nth-0-const"> QRegExp::cap(int <em>nth</em> = 0) const</span><a href="#qstring-qregexp-cap-int-nth-0-const" class="header-anchor">#</a></h3><p> 返回第 <em>nth</em>个子表达式捕获的文本。整个匹配的索引为 0，带括号的子表达式的索引从 1 开始（不包括非捕获括号）。 </p>
<div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-function">QRegExp <span class="hljs-title">rxlen</span><span class="hljs-params">(<span class="hljs-string">"(\\d+)(?:\\s*)(cm|inch)"</span>)</span></span>;
<span class="hljs-type">int</span> pos = rxlen.<span class="hljs-built_in">indexIn</span>(<span class="hljs-string">"Length: 189cm"</span>);
<span class="hljs-keyword">if</span> (pos &gt; <span class="hljs-number">-1</span>) {
    QString value = rxlen.<span class="hljs-built_in">cap</span>(<span class="hljs-number">1</span>); <span class="hljs-comment">// "189"</span>
    QString unit = rxlen.<span class="hljs-built_in">cap</span>(<span class="hljs-number">2</span>);  <span class="hljs-comment">// "cm"</span>
    <span class="hljs-comment">// ...</span>
}</code></pre></div>

<p> cap() 匹配的元素顺序如下。第一个元素 cap(0) 是整个匹配字符串。每个后续元素对应于下一个捕获左括号。因此 cap(1) 是第一个捕获括号的文本，cap(2) 是第二个捕获括号的文本，依此类推。 </p>
<p><strong>See also</strong> <a href="#capturedTexts">capturedTexts</a>() and <a href="#pos">pos</a>().</p>
<h3><span id="int-qregexp-capturecount-const">int QRegExp::captureCount() const</span><a href="#int-qregexp-capturecount-const" class="header-anchor">#</a></h3><p> 返回正则表达式中包含的捕获数。 </p>
<h3><span id="qstringlist-qregexp-capturedtexts-const"> QRegExp::capturedTexts() const</span><a href="#qstringlist-qregexp-capturedtexts-const" class="header-anchor">#</a></h3><p>返回捕获的文本字符串的列表。</p>
<p>列表中的第一个字符串是整个匹配的字符串。每个后续列表元素都包含一个与正则表达式的（捕获）子表达式匹配的字符串。</p>
<p>例如：</p>
<div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-function">QRegExp <span class="hljs-title">rx</span><span class="hljs-params">(<span class="hljs-string">"(\\d+)(\\s*)(cm|inch(es)?)"</span>)</span></span>;
<span class="hljs-type">int</span> pos = rx.<span class="hljs-built_in">indexIn</span>(<span class="hljs-string">"Length: 36 inches"</span>);
QStringList list = rx.<span class="hljs-built_in">capturedTexts</span>();
<span class="hljs-comment">// list is now ("36 inches", "36", " ", "inches", "es")</span></code></pre></div>

<p> 上面的示例还捕获了可能存在但我们不感兴趣的元素。这个问题可以通过使用非捕获括号来解决：:</p>
<div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-function">QRegExp <span class="hljs-title">rx</span><span class="hljs-params">(<span class="hljs-string">"(\\d+)(?:\\s*)(cm|inch(?:es)?)"</span>)</span></span>;
<span class="hljs-type">int</span> pos = rx.<span class="hljs-built_in">indexIn</span>(<span class="hljs-string">"Length: 36 inches"</span>);
QStringList list = rx.<span class="hljs-built_in">capturedTexts</span>();
<span class="hljs-comment">// list is now ("36 inches", "36", "inches")</span></code></pre></div>

<p> 请注意，如果要遍历列表，则应遍历副本，例如 :</p>
<div class="code-wrapper"><pre><code class="hljs c++">QStringList list = rx.<span class="hljs-built_in">capturedTexts</span>();
QStringList::iterator it = list.<span class="hljs-built_in">begin</span>();
<span class="hljs-keyword">while</span> (it != list.<span class="hljs-built_in">end</span>()) {
    <span class="hljs-built_in">myProcessing</span>(*it);
    ++it;
}</code></pre></div>

<p>一些正则表达式可以匹配不确定的次数。例如，如果输入字符串是“Offsets: 12 14 99 231 7”并且正则表达式 ,<code>rx</code>是**(\d+)+**，我们希望得到所有匹配数字的列表。但是，在调用后<code>rx.indexIn(str)</code>，cappedTexts() 将返回列表（“12”，“12”），即整个匹配是“12”，第一个匹配的子表达式是“12”。正确的做法是在<a target="_blank" rel="noopener" href="https://doc.qt.io/qt-6/qregexp.html#cap-in-a-loop">loop</a>中使用<a target="_blank" rel="noopener" href="https://doc.qt.io/qt-6/qregexp.html#cap">cap</a> () 。</p>
<p>字符串列表中元素的顺序如下。第一个元素是整个匹配字符串。每个后续元素对应于下一个捕获左括号。因此 captureTexts()[1] 是第一个捕获括号的文本，cappedTexts()[2] 是第二个捕获的文本，依此类推（对应于 $1、$2 等，在其他一些正则表达式语言中）。</p>
<p><strong>See also</strong> <a href="#cap">cap</a>() and <a href="#pos">pos</a>().</p>
<h3><span id="qt-casesensitivity-qregexp-casesensitivity-const"> QRegExp::caseSensitivity() const</span><a href="#qt-casesensitivity-qregexp-casesensitivity-const" class="header-anchor">#</a></h3><p> 如果正则表达式区分大小写，则返回<a target="_blank" rel="noopener" href="https://doc.qt.io/qt-6/qt.html#CaseSensitivity-enum">Qt::CaseSensitive ；</a>否则返回<a target="_blank" rel="noopener" href="https://doc.qt.io/qt-6/qt.html#CaseSensitivity-enum">Qt::CaseInsensitive</a>。 </p>
<p><strong>See also</strong> <a href="#setCaseSensitivity">setCaseSensitivity</a>(), <a href="#patternSyntax">patternSyntax</a>(), <a href="#pattern">pattern</a>(), and <a href="#isMinimal">isMinimal</a>().</p>
<h3><span id="int-qregexp-countin-const-qstring-amp-str-const">int QRegExp::countIn(const  &amp;<em>str</em>) const</span><a href="#int-qregexp-countin-const-qstring-amp-str-const" class="header-anchor">#</a></h3><p> 返回此正则表达式在<em>str</em>中匹配的次数。 </p>
<p><strong>See also</strong> <a href="#indexIn">indexIn</a>(), <a href="#lastIndexIn">lastIndexIn</a>(), and <a href="#replaceIn">replaceIn</a>().</p>
<h3><span id="qstring-qregexp-errorstring-const"> QRegExp::errorString() const</span><a href="#qstring-qregexp-errorstring-const" class="header-anchor">#</a></h3><p> 返回一个文本字符串，解释为什么正则表达式模式在这种情况下是无效的；否则返回<code>no error occurred</code>。 </p>
<p><strong>See also</strong> <a href="#isValid">isValid</a>().</p>
<h3><span id="static-qstring-qregexp-escape-const-qstring-amp-str"><code>[static]</code> QRegExp::escape(const  &amp;<em>str</em>)</span><a href="#static-qstring-qregexp-escape-const-qstring-amp-str" class="header-anchor">#</a></h3><p> 返回字符串<em>str</em>，每个正则表达式特殊字符都用反斜杠转义。特殊字符为 $、(,)、*、+、.、?、[、,]、^、{、| 和 }。 </p>
<p>例子:</p>
<div class="code-wrapper"><pre><code class="hljs c++">s1 = QRegExp::<span class="hljs-built_in">escape</span>(<span class="hljs-string">"bingo"</span>);   <span class="hljs-comment">// s1 == "bingo"</span>
s2 = QRegExp::<span class="hljs-built_in">escape</span>(<span class="hljs-string">"f(x)"</span>);    <span class="hljs-comment">// s2 == "f\\(x\\)"</span></code></pre></div>

<p> 此函数对于动态构造正则表达式模式很有用： </p>
<div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-function">QRegExp <span class="hljs-title">rx</span><span class="hljs-params">(<span class="hljs-string">"("</span> + QRegExp::escape(name) +</span></span>
<span class="hljs-params"><span class="hljs-function">           <span class="hljs-string">"|"</span> + QRegExp::escape(alias) + <span class="hljs-string">")"</span>)</span></span>;</code></pre></div>

<p><strong>See also</strong> <a href="#setPatternSyntax">setPatternSyntax</a>().</p>
<h3><span id="bool-qregexp-exactmatch-const-qstring-amp-str-const">bool QRegExp::exactMatch(const  &amp;<em>str</em>) const</span><a href="#bool-qregexp-exactmatch-const-qstring-amp-str-const" class="header-anchor">#</a></h3><p>返回<code>true</code>如果<em>str</em>与此正则表达式完全匹配；否则返回<code>false</code>。您可以通过调用<a target="_blank" rel="noopener" href="https://doc.qt.io/qt-6/qregexp.html#matchedLength">matchedLength</a> () 来确定匹配字符串的多少。</p>
<p>对于给定的正则表达式字符串 R，exactMatch(“R”) 等效于<a target="_blank" rel="noopener" href="https://doc.qt.io/qt-6/qregexp.html#indexIn">indexIn</a> (“^R$”)，因为 exactMatch() 有效地将正则表达式包含在字符串的开头和字符串锚点的结尾，除了它设置<a target="_blank" rel="noopener" href="https://doc.qt.io/qt-6/qregexp.html#matchedLength">matchLength</a> ( ) 不同。</p>
<p>例如，如果正则表达式是<strong>blue</strong>，则 exactMatch()<code>true</code>仅返回 input <code>blue</code>。对于输入和<code>bluebell</code>，exactMatch() 返回，<a target="_blank" rel="noopener" href="https://doc.qt.io/qt-6/qregexp.html#matchedLength">matchedLength</a> () 将分别返回 4、3 和 0。<code>blutak``lightblue``false</code></p>
<p>虽然是 const，但该函数设置<a target="_blank" rel="noopener" href="https://doc.qt.io/qt-6/qregexp.html#matchedLength">了matchedLength</a> ()、<a target="_blank" rel="noopener" href="https://doc.qt.io/qt-6/qregexp.html#capturedTexts">capturedTexts</a> () 和<a target="_blank" rel="noopener" href="https://doc.qt.io/qt-6/qregexp.html#pos">pos</a> ()。</p>
<p><strong>See also</strong> <a href="#indexIn">indexIn</a>() and <a href="#lastIndexIn">lastIndexIn</a>().</p>
<h3><span id="qstringlist-qregexp-filterlist-const-qstringlist-amp-stringlist-const"> QRegExp::filterList(const  &amp;<em>stringList</em>) const</span><a href="#qstringlist-qregexp-filterlist-const-qstringlist-amp-stringlist-const" class="header-anchor">#</a></h3><p> <em>在stringList</em>中返回与此正则表达式匹配的所有字符串的列表。 </p>
<h3><span id="int-qregexp-indexin-const-qstring-amp-str-int-offset-0-qregexp-caretmode-caretmode-caretatzero-const">int QRegExp::indexIn(const  &amp;<em>str</em>, int <em>offset</em> = 0,  <em>caretMode</em> = CaretAtZero) const</span><a href="#int-qregexp-indexin-const-qstring-amp-str-int-offset-0-qregexp-caretmode-caretmode-caretatzero-const" class="header-anchor">#</a></h3><p>尝试从位置<em>offset</em>（默认为 0）在<em>str</em>中找到匹配项。如果<em>offset</em>为 -1，则从最后一个字符开始搜索；如果 -2，则在倒数第二个字符处；等等。</p>
<p>返回第一个匹配的位置，如果没有匹配则返回 -1。</p>
<p>caretMode参数可用于指示<strong>^</strong>是否应在索引 0 处或在<em>offset</em>处匹配。</p>
<p>你可能更喜欢使用<a target="_blank" rel="noopener" href="https://doc.qt.io/qt-6/qstring.html#indexOf">QString::indexOf</a> ()、<a target="_blank" rel="noopener" href="https://doc.qt.io/qt-6/qstring.html#contains">QString::contains</a> ()，甚至是<a target="_blank" rel="noopener" href="https://doc.qt.io/qt-6/qstringlist.html#filter">QStringList::filter</a> ()。要替换匹配项，请使用<a target="_blank" rel="noopener" href="https://doc.qt.io/qt-6/qstring.html#replace">QString::replace</a> ()。</p>
<p>例子：</p>
<div class="code-wrapper"><pre><code class="hljs c++">QString str = <span class="hljs-string">"offsets: 1.23 .50 71.00 6.00"</span>;
<span class="hljs-function">QRegExp <span class="hljs-title">rx</span><span class="hljs-params">(<span class="hljs-string">"\\d*\\.\\d+"</span>)</span></span>;    <span class="hljs-comment">// primitive floating point matching</span>
<span class="hljs-type">int</span> count = <span class="hljs-number">0</span>;
<span class="hljs-type">int</span> pos = <span class="hljs-number">0</span>;
<span class="hljs-keyword">while</span> ((pos = rx.<span class="hljs-built_in">indexIn</span>(str, pos)) != <span class="hljs-number">-1</span>) {
    ++count;
    pos += rx.<span class="hljs-built_in">matchedLength</span>();
}
<span class="hljs-comment">// pos will be 9, 14, 18 and finally 24; count will end up as 4</span></code></pre></div>

<p>虽然是 const，但这个函数设置<a target="_blank" rel="noopener" href="https://doc.qt.io/qt-6/qregexp.html#matchedLength">了matchedLength</a> ()、<a target="_blank" rel="noopener" href="https://doc.qt.io/qt-6/qregexp.html#capturedTexts">capturedTexts</a> () 和<a target="_blank" rel="noopener" href="https://doc.qt.io/qt-6/qregexp.html#pos">pos</a> ()。</p>
<p>如果<a target="_blank" rel="noopener" href="https://doc.qt.io/qt-6/qregexp.html">QRegExp</a>是通配符表达式（请参阅<a target="_blank" rel="noopener" href="https://doc.qt.io/qt-6/qregexp.html#setPatternSyntax">setPatternSyntax</a> ()）并且想要针对整个通配符表达式测试字符串，请使用<a target="_blank" rel="noopener" href="https://doc.qt.io/qt-6/qregexp.html#exactMatch">exactMatch</a> () 而不是此函数。</p>
<p><strong>See also</strong> <a href="#lastIndexIn">lastIndexIn</a>() and <a href="#exactMatch">exactMatch</a>().</p>
<h3><span id="int-qregexp-indexin-const-qstringlist-amp-list-int-from-const">int QRegExp::indexIn(const  &amp;<em>list</em>, int <em>from</em>) const</span><a href="#int-qregexp-indexin-const-qstringlist-amp-list-int-from-const" class="header-anchor">#</a></h3><p> 返回<em>list</em>中此正则表达式的第一个完全匹配的索引位置，从索引位置向<strong>from</strong>搜索。如果没有匹配的项目，则返回 -1。 </p>
<p><strong>See also</strong> <a href="#lastIndexIn">lastIndexIn</a>() and <a href="#exactMatch">exactMatch</a>().</p>
<h3><span id="bool-qregexp-isempty-const">bool QRegExp::isEmpty() const</span><a href="#bool-qregexp-isempty-const" class="header-anchor">#</a></h3><p><code>true</code>如果模式字符串为空，则返回；否则返回假。</p>
<p>如果您在空字符串上使用空模式调用<a target="_blank" rel="noopener" href="https://doc.qt.io/qt-6/qregexp.html#exactMatch">exactMatch</a> ()，它将返回true；否则它会返回<code>false</code>，因为它对整个字符串进行操作。如果您在<em>任何</em>字符串上使用空模式调用<a target="_blank" rel="noopener" href="https://doc.qt.io/qt-6/qregexp.html#indexIn">indexIn</a> ()，它将返回起始偏移量（默认为 0），因为空模式与字符串开头的“空”匹配。<a target="_blank" rel="noopener" href="https://doc.qt.io/qt-6/qregexp.html#matchedLength">在这种情况下， matchedLength</a> ()返回的匹配长度将为 0。</p>
<p>See <a href="qstring.html#isEmpty">QString::isEmpty</a>().</p>
<h3><span id="bool-qregexp-isminimal-const">bool QRegExp::isMinimal() const</span><a href="#bool-qregexp-isminimal-const" class="header-anchor">#</a></h3><p> <code>true</code>如果启用了最小（非贪婪）匹配，则返回；否则返回<code>false</code>。 </p>
<p><strong>See also</strong> <a href="#caseSensitivity">caseSensitivity</a>() and <a href="#setMinimal">setMinimal</a>().</p>
<h3><span id="bool-qregexp-isvalid-const">bool QRegExp::isValid() const</span><a href="#bool-qregexp-isvalid-const" class="header-anchor">#</a></h3><p>返回<code>true</code>正则表达式是否有效；否则返回假。无效的正则表达式永远不会匹配。</p>
<p>模式**[az**是无效模式的一个示例，因为它缺少右方括号。</p>
<p>请注意，正则表达式的有效性也可能取决于通配符标志的设置，例如***.html**是有效的通配符正则表达式，但完整的正则表达式无效。</p>
<p><strong>See also</strong> <a href="#errorString">errorString</a>().</p>
<h3><span id="int-qregexp-lastindexin-const-qstring-amp-str-int-offset-1-qregexp-caretmode-caretmode-caretatzero-const">int QRegExp::lastIndexIn(const  &amp;<em>str</em>, int <em>offset</em> = -1,  <em>caretMode</em> = CaretAtZero) const</span><a href="#int-qregexp-lastindexin-const-qstring-amp-str-int-offset-1-qregexp-caretmode-caretmode-caretatzero-const" class="header-anchor">#</a></h3><p>尝试从位置<em>offset</em>在<em>str</em>中向后查找匹配项。如果<em>offset</em>为 -1（默认），则搜索从最后一个字符开始；如果 -2，则在倒数第二个字符处；等等。</p>
<p>返回第一个匹配的位置，如果没有匹配则返回 -1。</p>
<p>caretMode参数可用于指示<strong>^</strong>是否应在索引 0 处或在<em>offset</em>处匹配。</p>
<p>虽然是 const，但这个函数设置<a target="_blank" rel="noopener" href="https://doc.qt.io/qt-6/qregexp.html#matchedLength">了matchedLength</a> ()、<a target="_blank" rel="noopener" href="https://doc.qt.io/qt-6/qregexp.html#capturedTexts">capturedTexts</a> () 和<a target="_blank" rel="noopener" href="https://doc.qt.io/qt-6/qregexp.html#pos">pos</a> ()。</p>
<p><strong>警告：</strong>向后搜索比向前搜索慢得多。</p>
<p><strong>See also</strong> <a href="#indexIn">indexIn</a>() and <a href="#exactMatch">exactMatch</a>().</p>
<h3><span id="int-qregexp-lastindexin-const-qstringlist-amp-list-int-from-const">int QRegExp::lastIndexIn(const  &amp;<em>list</em>, int <em>from</em>) const</span><a href="#int-qregexp-lastindexin-const-qstringlist-amp-list-int-from-const" class="header-anchor">#</a></h3><p> 返回此正则表达式在<em>list</em>中的最后一个完全匹配的索引位置，从索引位置向后搜索。如果<em>from</em>为 -1（默认值），则搜索从最后一项开始。如果没有匹配的项目，则返回 -1。 </p>
<p><strong>See also</strong> <a href="#exactMatch">QRegExp::exactMatch</a>().</p>
<h3><span id="int-qregexp-matchedlength-const">int QRegExp::matchedLength() const</span><a href="#int-qregexp-matchedlength-const" class="header-anchor">#</a></h3><p> 返回最后一个匹配字符串的长度，如果没有匹配则返回 -1。 </p>
<p><strong>See also</strong> <a href="#exactMatch">exactMatch</a>(), <a href="#indexIn">indexIn</a>(), and <a href="#lastIndexIn">lastIndexIn</a>().</p>
<h3><span id="qstring-qregexp-pattern-const"> QRegExp::pattern() const</span><a href="#qstring-qregexp-pattern-const" class="header-anchor">#</a></h3><p> 返回正则表达式的模式字符串。该模式具有正则表达式语法或通配符语法，具体取决于<a target="_blank" rel="noopener" href="https://doc.qt.io/qt-6/qregexp.html#patternSyntax">patternSyntax</a> ()。 </p>
<p><strong>See also</strong> <a href="#setPattern">setPattern</a>(), <a href="#patternSyntax">patternSyntax</a>(), and <a href="#caseSensitivity">caseSensitivity</a>().</p>
<h3><span id="qregexp-patternsyntax-qregexp-patternsyntax-const"> QRegExp::patternSyntax() const</span><a href="#qregexp-patternsyntax-qregexp-patternsyntax-const" class="header-anchor">#</a></h3><p> 返回正则表达式使用的语法。默认值为<a target="_blank" rel="noopener" href="https://doc.qt.io/qt-6/qregexp.html#PatternSyntax-enum">QRegExp::RegExp</a>。 </p>
<p><strong>See also</strong> <a href="#setPatternSyntax">setPatternSyntax</a>(), <a href="#pattern">pattern</a>(), and <a href="#caseSensitivity">caseSensitivity</a>().</p>
<h3><span id="int-qregexp-pos-int-nth-0-const">int QRegExp::pos(int <em>nth</em> = 0) const</span><a href="#int-qregexp-pos-int-nth-0-const" class="header-anchor">#</a></h3><p>返回搜索字符串中第 nth 个捕获的文本的位置。如果<em>nth</em>为 0（默认值），则 pos() 返回整个匹配的位置。</p>
<p>例子：</p>
<div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-function">QRegExp <span class="hljs-title">rx</span><span class="hljs-params">(<span class="hljs-string">"/([a-z]+)/([a-z]+)"</span>)</span></span>;
rx.<span class="hljs-built_in">indexIn</span>(<span class="hljs-string">"Output /dev/null"</span>);   <span class="hljs-comment">// returns 7 (position of /dev/null)</span>
rx.<span class="hljs-built_in">pos</span>(<span class="hljs-number">0</span>);                        <span class="hljs-comment">// returns 7 (position of /dev/null)</span>
rx.<span class="hljs-built_in">pos</span>(<span class="hljs-number">1</span>);                        <span class="hljs-comment">// returns 8 (position of dev)</span>
rx.<span class="hljs-built_in">pos</span>(<span class="hljs-number">2</span>);                        <span class="hljs-comment">// returns 12 (position of null)</span></code></pre></div>

<p> 对于零长度匹配，pos() 总是返回 -1。（例如，如果 cap(4) 将返回一个空字符串，则 pos(4) 返回 -1。）这是实现的一个特性。 </p>
<p><strong>See also</strong> <a href="#cap">cap</a>() and <a href="#capturedTexts">capturedTexts</a>().</p>
<h3><span id="qstring-qregexp-removein-const-qstring-amp-str-const"> QRegExp::removeIn(const  &amp;<em>str</em>) const</span><a href="#qstring-qregexp-removein-const-qstring-amp-str-const" class="header-anchor">#</a></h3><p>删除此正则表达式<em>str</em>的每次出现，并返回结果</p>
<p>与<a target="_blank" rel="noopener" href="https://doc.qt.io/qt-6/qregexp.html#replaceIn">replaceIn</a> (str, QString()) 相同。</p>
<p><strong>See also</strong> <a href="#indexIn">indexIn</a>(), <a href="#lastIndexIn">lastIndexIn</a>(), and <a href="#replaceIn">replaceIn</a>().</p>
<h3><span id="qstring-qregexp-replacein-const-qstring-amp-str-const-qstring-amp-after-const"> QRegExp::replaceIn(const  &amp;<em>str</em>, const  &amp;<em>after</em>) const</span><a href="#qstring-qregexp-replacein-const-qstring-amp-str-const-qstring-amp-after-const" class="header-anchor">#</a></h3><p>将<em>str</em>中此正则表达式的每次出现替换为<em>after</em>并返回结果。</p>
<p><a target="_blank" rel="noopener" href="https://doc.qt.io/qt-6/qregexp.html#capturing-parentheses">对于包含捕获括号</a>的正则表达式，出现的<strong>\1</strong>，<strong>\2</strong>，…，在<em>after</em>被替换为<code>rx</code>.cap(1), cap(2), …</p>
<p><strong>See also</strong> <a href="#indexIn">indexIn</a>(), <a href="#lastIndexIn">lastIndexIn</a>(), and <a href="#cap">QRegExp::cap</a>().</p>
<h3><span id="qstringlist-qregexp-replacein-const-qstringlist-amp-stringlist-const-qstring-amp-after-const"> QRegExp::replaceIn(const  &amp;<em>stringList</em>, const  &amp;<em>after</em>) const</span><a href="#qstringlist-qregexp-replacein-const-qstringlist-amp-stringlist-const-qstring-amp-after-const" class="header-anchor">#</a></h3><p> 用<em>after</em>替换每个<em>stringList</em>中此正则表达式的每次出现。返回对字符串列表的引用。 </p>
<h3><span id="void-qregexp-setcasesensitivity-qt-casesensitivity-cs">void QRegExp::setCaseSensitivity( <em>cs</em>)</span><a href="#void-qregexp-setcasesensitivity-qt-casesensitivity-cs" class="header-anchor">#</a></h3><p>将区分大小写的匹配设置为<em>cs</em>。</p>
<p>如果<em>cs</em>是<a target="_blank" rel="noopener" href="https://doc.qt.io/qt-6/qt.html#CaseSensitivity-enum">Qt::CaseSensitive</a>，**.txt$**匹配<code>readme.txt</code>但不匹配<code>README.TXT</code>。</p>
<p><strong>See also</strong> <a href="#caseSensitivity">caseSensitivity</a>(), <a href="#setPatternSyntax">setPatternSyntax</a>(), <a href="#setPattern">setPattern</a>(), and <a href="#setMinimal">setMinimal</a>().</p>
<h3><span id="void-qregexp-setminimal-bool-minimal">void QRegExp::setMinimal(bool <em>minimal</em>)</span><a href="#void-qregexp-setminimal-bool-minimal" class="header-anchor">#</a></h3><p>Enables or disables minimal matching. If <em>minimal</em> is false, matching is greedy (maximal) which is the default.</p>
<p>For example, suppose we have the input string “We must be <b>bold</b>, very <b>bold</b>!” and the pattern&nbsp;<b>.*</b>. With the default greedy (maximal) matching, the match is “We must be&nbsp;<b>bold</b>, very <b>bold</b>!”. But with minimal (non-greedy) matching, the first match is: “We must be&nbsp;<b>bold</b>, very <b>bold</b>!” and the second match is “We must be <b>bold</b>, very&nbsp;<b>bold</b>!”. In practice we might use the pattern&nbsp;<b>[^&lt;]*</b>&nbsp;instead, although this will still fail for nested tags.</p>
<p><strong>See also</strong> <a href="#isMinimal">isMinimal</a>() and <a href="#setCaseSensitivity">setCaseSensitivity</a>().</p>
<h3><span id="void-qregexp-setpattern-const-qstring-amp-pattern">void QRegExp::setPattern(const  &amp;<em>pattern</em>)</span><a href="#void-qregexp-setpattern-const-qstring-amp-pattern" class="header-anchor">#</a></h3><p> 将模式字符串设置为<em>pattern</em>。区分大小写、通配符和最小匹配选项不会更改。 </p>
<p><strong>See also</strong> <a href="#pattern">pattern</a>(), <a href="#setPatternSyntax">setPatternSyntax</a>(), and <a href="#setCaseSensitivity">setCaseSensitivity</a>().</p>
<h3><span id="void-qregexp-setpatternsyntax-qregexp-patternsyntax-syntax">void QRegExp::setPatternSyntax( <em>syntax</em>)</span><a href="#void-qregexp-setpatternsyntax-qregexp-patternsyntax-syntax" class="header-anchor">#</a></h3><p>设置正则表达式的语法模式。默认值为<a target="_blank" rel="noopener" href="https://doc.qt.io/qt-6/qregexp.html#PatternSyntax-enum">QRegExp::RegExp</a>。</p>
<p>将<em>语法</em>设置为<a target="_blank" rel="noopener" href="https://doc.qt.io/qt-6/qregexp.html#PatternSyntax-enum">QRegExp::Wildcard</a>可以实现简单的类似于 shell 的<a target="_blank" rel="noopener" href="https://doc.qt.io/qt-6/qregexp.html#qregexp-wildcard-matching">QRegExp 通配符匹配</a>。例如，<strong>r*.txt</strong>匹配<code>readme.txt</code>通配符模式下的字符串，但不匹配<code>readme</code>.</p>
<p>将<em>语法</em>设置为<a target="_blank" rel="noopener" href="https://doc.qt.io/qt-6/qregexp.html#PatternSyntax-enum">QRegExp::FixedString</a>意味着模式被解释为纯字符串。特殊字符（例如，反斜杠）不需要转义。</p>
<p><strong>See also</strong> <a href="#patternSyntax">patternSyntax</a>(), <a href="#setPattern">setPattern</a>(), <a href="#setCaseSensitivity">setCaseSensitivity</a>(), and <a href="#escape">escape</a>().</p>
<h3><span id="qstringlist-qregexp-splitstring-const-qstring-amp-str-qt-splitbehavior-behavior-qt-keepemptyparts-const"> QRegExp::splitString(const  &amp;<em>str</em>,  <em>behavior</em> = Qt::KeepEmptyParts) const</span><a href="#qstringlist-qregexp-splitstring-const-qstring-amp-str-qt-splitbehavior-behavior-qt-keepemptyparts-const" class="header-anchor">#</a></h3><p>在此正则表达式匹配的任何地方将<em>str</em>拆分为子字符串，并返回这些字符串的列表。如果此正则表达式在字符串中的任何位置都不匹配，则 split() 返回包含<em>str</em>的单元素列表。</p>
<p>如果<em>behavior</em> 设置为<a target="_blank" rel="noopener" href="https://doc.qt.io/qt-6/qt.html#SplitBehaviorFlags-enum">Qt::KeepEmptyParts</a>，则结果列表中将包含空字段。</p>
<p><strong>See also</strong> <a href="qstringlist.html#join">QStringList::join</a>() and <a href="qstring.html#split">QString::split</a>().</p>
<h3><span id="void-qregexp-swap-qregexp-amp-other">void QRegExp::swap( &amp;<em>other</em>)</span><a href="#void-qregexp-swap-qregexp-amp-other" class="header-anchor">#</a></h3><p> 用这个正则表达式交换正则表达式<em>other 。</em>此操作非常快且永不失败。 </p>
<h3><span id="qvariant-qregexp-operator-qvariant-const"> QRegExp::operator QVariant() const</span><a href="#qvariant-qregexp-operator-qvariant-const" class="header-anchor">#</a></h3><p> 将正则表达式作为<a target="_blank" rel="noopener" href="https://doc.qt.io/qt-6/qvariant.html">QVariant返回</a> </p>
<h3><span id="bool-qregexp-operator-const-qregexp-amp-rx-const">bool QRegExp::operator!=(const  &amp;<em>rx</em>) const</span><a href="#bool-qregexp-operator-const-qregexp-amp-rx-const" class="header-anchor">#</a></h3><p> 返回<code>true</code>如果此正则表达式不等于<em>rx</em>；否则返回<code>false</code>。 </p>
<p><strong>See also</strong> <a href="#operator-eq-eq">operator==</a>().</p>
<h3><span id="bool-qregexp-operator-const-qregexp-amp-rx-const">bool QRegExp::operator==(const  &amp;<em>rx</em>) const</span><a href="#bool-qregexp-operator-const-qregexp-amp-rx-const" class="header-anchor">#</a></h3><p>返回<code>true</code>此正则表达式是否等于<em>rx</em>；否则返回<code>false</code>。</p>
<p>如果两个<a target="_blank" rel="noopener" href="https://doc.qt.io/qt-6/qregexp.html">QRegExp</a>对象具有相同的模式字符串和相同的区分大小写、通配符和最小匹配的设置，则它们是相等的。</p>
<h2><span id="xiang-guan-fei-cheng-yuan">相关非成员</span><a href="#xiang-guan-fei-cheng-yuan" class="header-anchor">#</a></h2><h3><span id="since-5-6-size-t-qhash-const-qregexp-amp-key-size-t-seed-0"><code>[since 5.6]</code>size_t qHash(const  &amp;<em>key</em>, size_t <em>seed</em> = 0)</span><a href="#since-5-6-size-t-qhash-const-qregexp-amp-key-size-t-seed-0" class="header-anchor">#</a></h3><p><em>返回key</em>的哈希值，使用<em>seed</em> 为计算提供种子。</p>
<p>这个函数是在 Qt 5.6 中引入的。</p>
<h3><span id="qdatastream-amp-operator-lt-lt-qdatastream-amp-out-const-qregexp-amp-regexp"> &amp;operator&lt;&lt;( &amp;<em>out</em>, const  &amp;<em>regExp</em>)</span><a href="#qdatastream-amp-operator-lt-lt-qdatastream-amp-out-const-qregexp-amp-regexp" class="header-anchor">#</a></h3><p> 将正则表达式<em>regExp</em>写入stream <em>out</em>。 </p>
<p><strong>See also</strong> <a href="datastreamformat.html">Serializing Qt Data Types</a>.</p>
<h3><span id="qdatastream-amp-operator-gt-gt-qdatastream-amp-in-qregexp-amp-regexp"> &amp;operator&gt;&gt;( &amp;<em>in</em>,  &amp;<em>regExp</em>)</span><a href="#qdatastream-amp-operator-gt-gt-qdatastream-amp-in-qregexp-amp-regexp" class="header-anchor">#</a></h3><p> 将流中的正则表达式读入<em>regExp</em>。 </p>
<p><strong>See also</strong> <a href="datastreamformat.html">Serializing Qt Data Types</a>.</p>

            </div>
            <hr>
            <div>
              <div class="post-metas mb-3">
                
                
                  <div class="post-meta">
                    <i class="iconfont icon-tags"></i>
                    
                      <a class="hover-with-bg" href="/tags/R/">R</a>
                    
                  </div>
                
              </div>
              
                <p class="note note-warning">
                  
                    本博客所有文章除特别声明外，均采用 <a target="_blank" href="https://creativecommons.org/licenses/by-sa/4.0/deed.zh" rel="nofollow noopener noopener">CC BY-SA 4.0 协议</a> ，转载请注明出处！
                  
                </p>
              
              
                <div class="post-prevnext">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/2022/03/02/QtDocumentCN/Src/R/QRegularExpressionMatch/QRegularExpressionMatch/">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">QRegularExpressionMatch类</span>
                        <span class="visible-mobile">上一篇</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2022/03/02/QtDocumentCN/Src/R/QRegularExpression/QRegularExpression/">
                        <span class="hidden-mobile">QRegularExpression类</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
              <!-- Comments -->
              <article class="comments" id="comments" lazyload>
                
                  
                
                
  <div id="lv-container" data-id="city" data-uid="MTAyMC81NTMzMi8zMTc5OQ==">
    <script type="text/javascript">
      Fluid.utils.loadComments('#lv-container', function() {
        Fluid.utils.createScript('https://cdn-city.livere.com/js/embed.dist.js');
      });
    </script>
    <noscript>Please enable JavaScript to view the comments</noscript>
  </div>


              </article>
            
          </article>
        </div>
      </div>
    </div>
    
      <div class="d-none d-lg-block col-lg-2 toc-container" id="toc-ctn">
        <div id="toc">
  <p class="toc-header"><i class="iconfont icon-list"></i>&nbsp;目录</p>
  <div class="toc-body" id="toc-body"></div>
</div>

      </div>
    
  </div>
</div>

<!-- Custom -->


    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v"
                 for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>
    

    
  </main>

  <footer class="text-center mt-5 py-3">
  <div class="footer-content">
     <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> 
  </div>
  

  

  
</footer>


  <!-- SCRIPTS -->
  
  <script  src="https://cdn.jsdelivr.net/npm/nprogress@0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/nprogress@0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js" ></script>
<script  src="https://cdn.jsdelivr.net/npm/bootstrap@4/dist/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>

<!-- Plugins -->


  <script  src="/js/local-search.js" ></script>



  
    <script  src="/js/img-lazyload.js" ></script>
  



  



  
    <script  src="https://cdn.jsdelivr.net/npm/tocbot@4/dist/tocbot.min.js" ></script>
  
  
    <script  src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3/dist/jquery.fancybox.min.js" ></script>
  
  
    <script  src="https://cdn.jsdelivr.net/npm/anchor-js@4/anchor.min.js" ></script>
  
  
    <script defer src="https://cdn.jsdelivr.net/npm/clipboard@2/dist/clipboard.min.js" ></script>
  






  <script  src="https://cdn.jsdelivr.net/npm/typed.js@2/lib/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var title = document.getElementById('subtitle').title;
      
        typing(title);
      
    })(window, document);
  </script>















<!-- 主题的启动项 保持在最底部 -->
<script  src="/js/boot.js" ></script>


</body>
</html>
