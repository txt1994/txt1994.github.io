

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=auto>



<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/logo.jpg">
  <link rel="icon" href="/img/logo.jpg">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
    <meta http-equiv="Content-Security-Policy" content="upgrade-insecure-requests">
  
  <meta name="theme-color" content="#6aa84f">
  <meta name="author" content="John Doe">
  <meta name="keywords" content="">
  
    <meta name="description" content="QNetworkProxyQuery Class 公共类型 公共函数 详细描述 成员类型文档 enum QNetworkProxyQuery::QueryType   成员函数文档 QNetworkProxyQuery::QNetworkProxyQuery(const QNetworkProxyQuery &amp;other) QNetworkProxyQuery::QNetwork">
<meta property="og:type" content="article">
<meta property="og:title" content="QNetworkProxyQuery类">
<meta property="og:url" content="https://txt1994.github.io/2022/03/02/QtDocumentCN/Src/N/QNetworkProxyQuery/QNetworkProxyQuery/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:description" content="QNetworkProxyQuery Class 公共类型 公共函数 详细描述 成员类型文档 enum QNetworkProxyQuery::QueryType   成员函数文档 QNetworkProxyQuery::QNetworkProxyQuery(const QNetworkProxyQuery &amp;other) QNetworkProxyQuery::QNetwork">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2022-03-02T06:47:47.000Z">
<meta property="article:modified_time" content="2022-03-18T16:49:37.961Z">
<meta property="article:author" content="John Doe">
<meta property="article:tag" content="N">
<meta name="twitter:card" content="summary_large_image">
  
  
  <title>QNetworkProxyQuery类 - Hexo</title>

  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4/dist/css/bootstrap.min.css" />


  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/github-markdown-css@4/github-markdown.min.css" />
  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/hint.css@2/hint.min.css" />

  
    
    
      
      <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@10/styles/github-gist.min.css" />
    
  

  
    <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3/dist/jquery.fancybox.min.css" />
  


<!-- 主题依赖的图标库，不要自行修改 -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_ba1fz6golrf.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_lbnruvf0jn.css">


<link  rel="stylesheet" href="/css/main.css" />

<!-- 自定义样式保持在最底部 -->

  
<link rel="stylesheet" href="/css/style.css">



  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    var CONFIG = {"hostname":"txt1994.github.io","root":"/","version":"1.8.14","typing":{"enable":true,"typeSpeed":70,"cursorChar":"_","loop":false},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"right","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"copy_btn":true,"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":false,"baidu":null,"google":null,"gtag":null,"tencent":{"sid":null,"cid":null},"woyaola":null,"cnzz":null,"leancloud":{"app_id":null,"app_key":null,"server_url":null,"path":"window.location.pathname","ignore_local":false}},"search_path":"/local-search.xml"};
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
<meta name="generator" content="Hexo 6.1.0">
<style>.github-emoji { position: relative; display: inline-block; width: 1.2em; min-height: 1.2em; overflow: hidden; vertical-align: top; color: transparent; }  .github-emoji > span { position: relative; z-index: 10; }  .github-emoji img, .github-emoji .fancybox { margin: 0 !important; padding: 0 !important; border: none !important; outline: none !important; text-decoration: none !important; user-select: none !important; cursor: auto !important; }  .github-emoji img { height: 1.2em !important; width: 1.2em !important; position: absolute !important; left: 50% !important; top: 50% !important; transform: translate(-50%, -50%) !important; user-select: none !important; cursor: auto !important; } .github-emoji-fallback { color: inherit; } .github-emoji-fallback img { opacity: 0 !important; }</style>
</head>


<body>
  <header style="height: 70vh;">
    <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/">
      <strong>txt1994s</strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/">
                <i class="iconfont icon-home-fill"></i>
                首页
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/">
                <i class="iconfont icon-archive-fill"></i>
                归档
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/">
                <i class="iconfont icon-tags-fill"></i>
                标签
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/">
                <i class="iconfont icon-user-fill"></i>
                关于
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/links/">
                <i class="iconfont icon-link-fill"></i>
                友联
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              &nbsp;<i class="iconfont icon-search"></i>&nbsp;
            </a>
          </li>
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">&nbsp;<i
                class="iconfont icon-dark" id="color-toggle-icon"></i>&nbsp;</a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

    <div class="banner" id="banner" parallax=true
         style="background: url('/img/default.png') no-repeat center center;
           background-size: cover;">
      <div class="full-bg-img">
        <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
          <div class="page-header text-center fade-in-up">
            <span class="h2" id="subtitle" title="QNetworkProxyQuery类">
              
            </span>

            
              <div class="mt-3">
  
  
    <span class="post-meta">
      <i class="iconfont icon-date-fill" aria-hidden="true"></i>
      <time datetime="2022-03-02 14:47" pubdate>
        2022年3月2日 下午
      </time>
    </span>
  
</div>

<div class="mt-1">
  
    <span class="post-meta mr-2">
      <i class="iconfont icon-chart"></i>
      8.7k 字
    </span>
  

  
    <span class="post-meta mr-2">
      <i class="iconfont icon-clock-fill"></i>
      
      
      73 分钟
    </span>
  

  
  
</div>

            
          </div>

          
        </div>
      </div>
    </div>
  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="d-none d-lg-block col-lg-2"></div>
    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div class="py-5" id="board">
          <article class="post-content mx-auto">
            <!-- SEO header -->
            <h1 style="display: none">QNetworkProxyQuery类</h1>
            
              <p class="note note-info">
                
                  本文最后更新于：2022年3月19日 凌晨
                
              </p>
            
            <div class="markdown-body">
              <div class="toc">

<!-- toc -->

<ul>
<li><a href="#qnetworkproxyquery-class">QNetworkProxyQuery Class</a><ul>
<li><a href="#gong-gong-lei-xing">公共类型</a></li>
<li><a href="#gong-gong-han-shu">公共函数</a></li>
<li><a href="#xiang-xi-miao-shu">详细描述</a></li>
<li><a href="#cheng-yuan-lei-xing-wen-dang">成员类型文档</a><ul>
<li><a href="#enum-qnetworkproxyquery-querytype">enum QNetworkProxyQuery::QueryType</a></li>
</ul>
</li>
<li><a href="#cheng-yuan-han-shu-wen-dang">成员函数文档</a><ul>
<li><a href="#qnetworkproxyquery-qnetworkproxyquery-const-qnetworkproxyquery-qnetworkproxyquery-other">QNetworkProxyQuery::QNetworkProxyQuery(const </a><a href="#QNetworkProxyQuery">QNetworkProxyQuery</a> &amp;<em>other</em>)</li>
<li><a href="#qnetworkproxyquery-qnetworkproxyquery-quint16-https-doc-qt-io-qt-6-qtglobal-html-quint16-typedef-bindport-const-qstring-https-doc-qt-io-qt-6-qstring-html-protocoltag-qstring-qnetworkproxyquery-querytype-querytype-enum-querytype-tcpserver">QNetworkProxyQuery::QNetworkProxyQuery(</a><a target="_blank" rel="noopener" href="https://doc.qt.io/qt-6/qtglobal.html#quint16-typedef">quint16</a> <em>bindPort</em>, const <a target="_blank" rel="noopener" href="https://doc.qt.io/qt-6/qstring.html">QString</a> &amp;<em>protocolTag</em> = QString(), <a href="#QueryType-enum">QNetworkProxyQuery::QueryType</a> <em>queryType</em> = TcpServer)</li>
<li><a href="#qnetworkproxyquery-qnetworkproxyquery-const-qstring-https-doc-qt-io-qt-6-qstring-html-hostname-int-port-const-qstring-https-doc-qt-io-qt-6-qstring-html-protocoltag-qstring-qnetworkproxyquery-querytype-querytype-enum-querytype-tcpsocket">QNetworkProxyQuery::QNetworkProxyQuery(const </a><a target="_blank" rel="noopener" href="https://doc.qt.io/qt-6/qstring.html">QString</a> &amp;<em>hostname</em>, int <em>port</em>, const <a target="_blank" rel="noopener" href="https://doc.qt.io/qt-6/qstring.html">QString</a> &amp;<em>protocolTag</em> = QString(), <a href="#QueryType-enum">QNetworkProxyQuery::QueryType</a> <em>queryType</em> = TcpSocket)</li>
<li><a href="#qnetworkproxyquery-qnetworkproxyquery-const-qurl-https-doc-qt-io-qt-6-qurl-html-requesturl-qnetworkproxyquery-querytype-querytype-enum-querytype-urlrequest">QNetworkProxyQuery::QNetworkProxyQuery(const </a><a target="_blank" rel="noopener" href="https://doc.qt.io/qt-6/qurl.html">QUrl</a> &amp;<em>requestUrl</em>, <a href="#QueryType-enum">QNetworkProxyQuery::QueryType</a> <em>queryType</em> = UrlRequest)</li>
<li><a href="#qnetworkproxyquery-qnetworkproxyquery">QNetworkProxyQuery::QNetworkProxyQuery()</a></li>
<li><a href="#qnetworkproxyquery-qnetworkproxyquery-qnetworkproxyquery-operator-const-qnetworkproxyquery-qnetworkproxyquery-other">QNetworkProxyQuery</a></li>
<li><a href="#qnetworkproxyquery-qnetworkproxyquery">QNetworkProxyQuery::~QNetworkProxyQuery()</a></li>
<li><a href="#int-qnetworkproxyquery-localport-const">int QNetworkProxyQuery::localPort() const</a></li>
<li><a href="#qstring-https-doc-qt-io-qt-6-qstring-html-qnetworkproxyquery-peerhostname-const">QString</a></li>
<li><a href="#int-qnetworkproxyquery-peerport-const">int QNetworkProxyQuery::peerPort() const</a></li>
<li><a href="#qstring-https-doc-qt-io-qt-6-qstring-html-qnetworkproxyquery-protocoltag-const-1">QString</a></li>
<li><a href="#qnetworkproxyquery-querytype-querytype-enum-qnetworkproxyquery-querytype-const">QNetworkProxyQuery::QueryType</a></li>
<li><a href="#void-qnetworkproxyquery-setlocalport-int-port">void QNetworkProxyQuery::setLocalPort(int <em>port</em>)</a></li>
<li><a href="#void-qnetworkproxyquery-setpeerhostname-const-qstring-https-doc-qt-io-qt-6-qstring-html-hostname">void QNetworkProxyQuery::setPeerHostName(const </a><a target="_blank" rel="noopener" href="https://doc.qt.io/qt-6/qstring.html">QString</a> &amp;<em>hostname</em>)</li>
<li><a href="#void-qnetworkproxyquery-setpeerport-int-port">void QNetworkProxyQuery::setPeerPort(int <em>port</em>)</a></li>
<li><a href="#void-qnetworkproxyquery-setprotocoltag-const-qstring-https-doc-qt-io-qt-6-qstring-html-protocoltag">void QNetworkProxyQuery::setProtocolTag(const </a><a target="_blank" rel="noopener" href="https://doc.qt.io/qt-6/qstring.html">QString</a> &amp;<em>protocolTag</em>)</li>
<li><a href="#void-qnetworkproxyquery-setquerytype-qnetworkproxyquery-querytype-querytype-enum-type">void QNetworkProxyQuery::setQueryType(</a><a href="#QueryType-enum">QNetworkProxyQuery::QueryType</a> <em>type</em>)</li>
<li><a href="#void-qnetworkproxyquery-seturl-const-qurl-https-doc-qt-io-qt-6-qurl-html-url">void QNetworkProxyQuery::setUrl(const </a><a target="_blank" rel="noopener" href="https://doc.qt.io/qt-6/qurl.html">QUrl</a> &amp;<em>url</em>)</li>
<li><a href="#since-5-0-void-qnetworkproxyquery-swap-qnetworkproxyquery-qnetworkproxyquery-other"><code>[since 5.0]</code>void QNetworkProxyQuery::swap(</a><a href="#QNetworkProxyQuery">QNetworkProxyQuery</a> &amp;<em>other</em>)</li>
<li><a href="#qurl-https-doc-qt-io-qt-6-qurl-html-qnetworkproxyquery-url-const">QUrl</a></li>
<li><a href="#bool-qnetworkproxyquery-operator-const-qnetworkproxyquery-qnetworkproxyquery-other-const">bool QNetworkProxyQuery::operator!=(const </a><a href="#QNetworkProxyQuery">QNetworkProxyQuery</a> &amp;<em>other</em>) const</li>
<li><a href="#bool-qnetworkproxyquery-operator-const-qnetworkproxyquery-qnetworkproxyquery-other-const">bool QNetworkProxyQuery::operator==(const </a><a href="#QNetworkProxyQuery">QNetworkProxyQuery</a> &amp;<em>other</em>) const</li>
</ul>
</li>
</ul>
</li>
</ul>
<!-- tocstop -->

</div>
# QNetworkProxyQuery Class

<p>QNetworkProxyQuery类是用来查询一个套接字的代理设置。 <a href="#%E8%AF%A6%E7%BB%86%E6%8F%8F%E8%BF%B0">More…</a></p>
<table>
<thead>
<tr>
<th>Header:</th>
<th>#include <qnetworkproxyquery></qnetworkproxyquery></th>
</tr>
</thead>
<tbody><tr>
<td>CMake:</td>
<td>find_package(Qt6 COMPONENTS Network REQUIRED) target_link_libraries(mytarget PRIVATE Qt6::Network)</td>
</tr>
<tr>
<td>qmake:</td>
<td>QT += network</td>
</tr>
</tbody></table>
<ul>
<li><a target="_blank" rel="noopener" href="https://doc.qt.io/qt-6/qnetworkproxyquery-members.html">List of all members, including inherited members</a></li>
</ul>
<h2><span id="gong-gong-lei-xing">公共类型</span><a href="#gong-gong-lei-xing" class="header-anchor">#</a></h2><table>
<thead>
<tr>
<th>enum</th>
<th><strong><a href="#QueryType-enum">QueryType</a></strong> { TcpSocket, UdpSocket, SctpSocket, TcpServer, UrlRequest, SctpServer }</th>
</tr>
</thead>
<tbody><tr>
<td></td>
<td></td>
</tr>
</tbody></table>
<h2><span id="gong-gong-han-shu">公共函数</span><a href="#gong-gong-han-shu" class="header-anchor">#</a></h2><table>
<thead>
<tr>
<th></th>
<th><strong><a href="#QNetworkProxyQuery-4">QNetworkProxyQuery</a></strong>(const QNetworkProxyQuery &amp;<em>other</em>)</th>
</tr>
</thead>
<tbody><tr>
<td></td>
<td><strong><a href="#QNetworkProxyQuery-3">QNetworkProxyQuery</a></strong>(quint16 <em>bindPort</em>, const QString &amp;<em>protocolTag</em> = QString(), QNetworkProxyQuery::QueryType <em>queryType</em> = TcpServer)</td>
</tr>
<tr>
<td></td>
<td><strong><a href="#QNetworkProxyQuery-2">QNetworkProxyQuery</a></strong>(const QString &amp;<em>hostname</em>, int <em>port</em>, const QString &amp;<em>protocolTag</em> = QString(), QNetworkProxyQuery::QueryType <em>queryType</em> = TcpSocket)</td>
</tr>
<tr>
<td></td>
<td><strong><a href="#QNetworkProxyQuery-1">QNetworkProxyQuery</a></strong>(const QUrl &amp;<em>requestUrl</em>, QNetworkProxyQuery::QueryType <em>queryType</em> = UrlRequest)</td>
</tr>
<tr>
<td></td>
<td><strong><a href="#QNetworkProxyQuery">QNetworkProxyQuery</a></strong>()</td>
</tr>
<tr>
<td>QNetworkProxyQuery &amp;</td>
<td><strong><a href="#operator-eq-1">operator=</a></strong>(const QNetworkProxyQuery &amp;<em>other</em>)</td>
</tr>
<tr>
<td></td>
<td><strong><a href="#dtor.QNetworkProxyQuery">~QNetworkProxyQuery</a></strong>()</td>
</tr>
<tr>
<td>int</td>
<td><strong><a href="#localPort">localPort</a></strong>() const</td>
</tr>
<tr>
<td>QString</td>
<td><strong><a href="#peerHostName">peerHostName</a></strong>() const</td>
</tr>
<tr>
<td>int</td>
<td><strong><a href="#peerPort">peerPort</a></strong>() const</td>
</tr>
<tr>
<td>QString</td>
<td><strong><a href="#protocolTag">protocolTag</a></strong>() const</td>
</tr>
<tr>
<td>QNetworkProxyQuery::QueryType</td>
<td><strong><a href="#queryType">queryType</a></strong>() const</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="#setLocalPort">setLocalPort</a></strong>(int <em>port</em>)</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="#setPeerHostName">setPeerHostName</a></strong>(const QString &amp;<em>hostname</em>)</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="#setPeerPort">setPeerPort</a></strong>(int <em>port</em>)</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="#setProtocolTag">setProtocolTag</a></strong>(const QString &amp;<em>protocolTag</em>)</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="#setQueryType">setQueryType</a></strong>(QNetworkProxyQuery::QueryType <em>type</em>)</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="#setUrl">setUrl</a></strong>(const QUrl &amp;<em>url</em>)</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="#swap">swap</a></strong>(QNetworkProxyQuery &amp;<em>other</em>)</td>
</tr>
<tr>
<td>QUrl</td>
<td><strong><a href="#url">url</a></strong>() const</td>
</tr>
<tr>
<td>bool</td>
<td><strong><a href="#operator-not-eq">operator!=</a></strong>(const QNetworkProxyQuery &amp;<em>other</em>) const</td>
</tr>
<tr>
<td>bool</td>
<td><strong><a href="#operator-eq-eq">operator==</a></strong>(const QNetworkProxyQuery &amp;<em>other</em>) const</td>
</tr>
</tbody></table>
<h2><span id="xiang-xi-miao-shu">详细描述</span><a href="#xiang-xi-miao-shu" class="header-anchor">#</a></h2><p>QNetworkProxyQuery保存了正在创建的套接字或请求的细节。它被<a target="_blank" rel="noopener" href="https://doc.qt.io/qt-6/qnetworkproxy.html">QNetworkProxy</a>和<a target="_blank" rel="noopener" href="https://doc.qt.io/qt-6/qnetworkproxyfactory.html">QNetworkProxyFactory</a>使用，允许应用程序根据查询的细节，对使用哪些代理服务器进行更细化的控制。这允许应用程序应用不同的设置，例如，根据协议或目标主机名。</p>
<p>QNetworkProxyQuery支持以下选择代理的标准。</p>
<ul>
<li>查询的类型</li>
<li>要使用的本地端口号</li>
<li>目的地主机名</li>
<li>目的地端口号</li>
<li>协议名称，如 “http “或 “ftp”</li>
<li>被请求的URL</li>
</ul>
<p>在出站连接套接字的情况下，目标主机名是连接中的主机。它是传递给<a target="_blank" rel="noopener" href="https://doc.qt.io/qt-6/qabstractsocket.html#connectToHost">QTcpSocket::connectToHost</a>()的<code>hostName</code>参数，或者是用<a target="_blank" rel="noopener" href="https://doc.qt.io/qt-6/qnetworkrequest.html">QNetworkRequest</a>请求的URL的host组件。</p>
<p>在出站套接字的情况下，目标端口号是要求连接的端口，而本地端口号是套接字在尝试外部连接之前希望在本地使用的端口。在大多数情况下，本地端口号只被监听套接字（<a target="_blank" rel="noopener" href="https://doc.qt.io/qt-6/qtcpsocket.html">QTcpSocket</a>）或数据报套接字（<a target="_blank" rel="noopener" href="https://doc.qt.io/qt-6/qudpsocket.html">QUdpSocket</a>）所使用。</p>
<p>协议名称是一个任意的字符串，表示正在尝试的连接类型。例如，它可以匹配URL的方案，如 “http”、”https “和 “ftp”。在大多数情况下，代理的选择不会因协议的不同而改变，但提供这些信息是为了防止可以做出更好的选择，比如为基于HTTP的连接选择一个缓存的HTTP代理，但为所有其他的连接选择一个更强大的SOCKSv5代理。</p>
<p>有些标准在所有类型的查询中可能没有意义。下表根据查询的类型列出了最常用的标准。</p>
<table>
<thead>
<tr>
<th align="center">Query type</th>
<th align="center">Description</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><a href="#QueryType-enum">TcpSocket</a></td>
<td align="center">请求连接到远程服务器的普通套接字，如<a target="_blank" rel="noopener" href="https://doc.qt.io/qt-6/qtcpsocket.html">QTcpSocket</a>。对方主机名和对方端口与传递给<a target="_blank" rel="noopener" href="https://doc.qt.io/qt-6/qabstractsocket.html#connectToHost">QTcpSocket::connectToHost</a>()的值一致。本地端口通常为-1，表示该套接字在使用哪个端口方面没有偏好。URL组件不被使用。</td>
</tr>
<tr>
<td align="center"><a href="#QueryType-enum">UdpSocket</a></td>
<td align="center">基于数据报的套接字，既可以发送也可以接收。本地端口、远程主机或远程端口字段都可以使用或不使用，这取决于套接字的特性。URL组件不被使用。</td>
</tr>
<tr>
<td align="center"><a href="#QueryType-enum">SctpSocket</a></td>
<td align="center">面向消息的套接字，请求与远程服务器的连接。对方主机名和对方端口与传递给<a target="_blank" rel="noopener" href="https://doc.qt.io/qt-6/qabstractsocket.html#connectToHost">QSctpSocket::connectToHost</a>()的值一致。本地端口通常为-1，表示该套接字在使用哪个端口方面没有偏好。URL组件不被使用。</td>
</tr>
<tr>
<td align="center"><a href="#QueryType-enum">TcpServer</a></td>
<td align="center">被动的服务器套接字，在一个端口上监听并等待来自网络的连接。通常情况下，只使用本地端口，但在特定情况下可以使用远程地址，例如，表明期望从哪个远程主机进行连接。URL组件不被使用。</td>
</tr>
<tr>
<td align="center"><a href="#QueryType-enum">UrlRequest</a></td>
<td align="center">一个更高级的请求，例如那些来自<a target="_blank" rel="noopener" href="https://doc.qt.io/qt-6/qnetworkaccessmanager.html">QNetworkAccessManager</a>的请求。这些请求将不可避免地使用一个流出的TCP套接字，但提供这种查询类型是为了表明在URL组件中存在更详细的信息。为了便于实现，URL的主机和端口被设置为目标地址。</td>
</tr>
<tr>
<td align="center"><a href="#QueryType-enum">SctpServer</a></td>
<td align="center">被动的服务器套接字，在SCTP端口上监听，等待来自网络的连接。通常情况下，只使用本地端口，但在特定情况下可以使用远程地址，例如，表明期望从哪个远程主机进行连接。URL组件不被使用。</td>
</tr>
</tbody></table>
<p>应该注意的是，任何标准都可能缺失或未知（主机名或协议名为空<a target="_blank" rel="noopener" href="https://doc.qt.io/qt-6/qstring.html">QString</a>，端口号为-1）。如果发生这种情况，执行查询的函数应该做出最好的猜测，或者应用一些实现定义的默认值。</p>
<p><strong>See also</strong> <a target="_blank" rel="noopener" href="https://doc.qt.io/qt-6/qnetworkproxy.html">QNetworkProxy</a>, <a target="_blank" rel="noopener" href="https://doc.qt.io/qt-6/qnetworkproxyfactory.html">QNetworkProxyFactory</a>, <a target="_blank" rel="noopener" href="https://doc.qt.io/qt-6/qnetworkaccessmanager.html">QNetworkAccessManager</a>, and <a target="_blank" rel="noopener" href="https://doc.qt.io/qt-6/qabstractsocket.html#setProxy">QAbstractSocket::setProxy</a>().</p>
<h2><span id="cheng-yuan-lei-xing-wen-dang">成员类型文档</span><a href="#cheng-yuan-lei-xing-wen-dang" class="header-anchor">#</a></h2><h3><span id="enum-qnetworkproxyquery-querytype">enum QNetworkProxyQuery::QueryType</span><a href="#enum-qnetworkproxyquery-querytype" class="header-anchor">#</a></h3><p>描述了一个<a href>QNetworkProxyQuery</a>查询的类型。</p>
<table>
<thead>
<tr>
<th>Constant</th>
<th>Value</th>
<th>Description</th>
</tr>
</thead>
<tbody><tr>
<td><code>QNetworkProxyQuery::TcpSocket</code></td>
<td><code>0</code></td>
<td>一个正常的、外发的TCP套接字</td>
</tr>
<tr>
<td><code>QNetworkProxyQuery::UdpSocket</code></td>
<td><code>1</code></td>
<td>一个基于数据报的UDP套接字，它可以向多个目的地发送</td>
</tr>
<tr>
<td><code>QNetworkProxyQuery::SctpSocket</code></td>
<td><code>2</code></td>
<td>一个面向消息的、向外发送的SCTP套接字</td>
</tr>
<tr>
<td><code>QNetworkProxyQuery::TcpServer</code></td>
<td><code>100</code></td>
<td>一个TCP服务器，用于监听来自网络的入站连接</td>
</tr>
<tr>
<td><code>QNetworkProxyQuery::UrlRequest</code></td>
<td><code>101</code></td>
<td>一个更复杂的请求，包括加载一个URL</td>
</tr>
<tr>
<td><code>QNetworkProxyQuery::SctpServer</code></td>
<td><code>102</code></td>
<td>一个SCTP服务器，监听来自网络的入站连接。</td>
</tr>
</tbody></table>
<p><strong>See also</strong> <a href="#queryType">queryType</a>() and <a href="#setQueryType">setQueryType</a>().</p>
<h2><span id="cheng-yuan-han-shu-wen-dang">成员函数文档</span><a href="#cheng-yuan-han-shu-wen-dang" class="header-anchor">#</a></h2><h3><span id="qnetworkproxyquery-qnetworkproxyquery-const-qnetworkproxyquery-amp-other">QNetworkProxyQuery::QNetworkProxyQuery(const  &amp;<em>other</em>)</span><a href="#qnetworkproxyquery-qnetworkproxyquery-const-qnetworkproxyquery-amp-other" class="header-anchor">#</a></h3><p>构建一个QNetworkProxyQuery对象，它是<em>other</em>的副本。</p>
<h3><span id="qnetworkproxyquery-qnetworkproxyquery-quint16-bindport-const-qstring-amp-protocoltag-qstring-qnetworkproxyquery-querytype-querytype-tcpserver">QNetworkProxyQuery::QNetworkProxyQuery( <em>bindPort</em>, const  &amp;<em>protocolTag</em> = QString(),  <em>queryType</em> = TcpServer)</span><a href="#qnetworkproxyquery-qnetworkproxyquery-quint16-bindport-const-qstring-amp-protocoltag-qstring-qnetworkproxyquery-querytype-querytype-tcpserver" class="header-anchor">#</a></h3><p>构建一个类型为<em>queryType</em>的QNetworkProxyQuery，并将协议标签设为<em>protocolTag</em>。这个构造函数适用于<a href="#QueryType-enum">QNetworkProxyQuery::TcpSocket</a>查询，因为它将本地端口号设置为<em>bindPort</em>。</p>
<p>请注意，<em>bindPort</em>的类型是quint16，以表示被请求的确切端口号。在这种情况下，-1（未知）的值是不允许的。</p>
<p><strong>See also</strong> <a href="#localPort">localPort</a>().</p>
<h3><span id="qnetworkproxyquery-qnetworkproxyquery-const-qstring-amp-hostname-int-port-const-qstring-amp-protocoltag-qstring-qnetworkproxyquery-querytype-querytype-tcpsocket">QNetworkProxyQuery::QNetworkProxyQuery(const  &amp;<em>hostname</em>, int <em>port</em>, const  &amp;<em>protocolTag</em> = QString(),  <em>queryType</em> = TcpSocket)</span><a href="#qnetworkproxyquery-qnetworkproxyquery-const-qstring-amp-hostname-int-port-const-qstring-amp-protocoltag-qstring-qnetworkproxyquery-querytype-querytype-tcpsocket" class="header-anchor">#</a></h3><p>构建一个类型为<em>queryType</em>的QNetworkProxyQuery，并将协议标签设为<em>protocolTag</em>。这个构造函数适用于<a href="#QueryType-enum">QNetworkProxyQuery::TcpSocket</a>查询，因为它将对等体的主机名设为<em>hostname</em>，对等体的端口号设为<em>port</em>。</p>
<h3><span id="qnetworkproxyquery-qnetworkproxyquery-const-qurl-amp-requesturl-qnetworkproxyquery-querytype-querytype-urlrequest">QNetworkProxyQuery::QNetworkProxyQuery(const  &amp;<em>requestUrl</em>,  <em>queryType</em> = UrlRequest)</span><a href="#qnetworkproxyquery-qnetworkproxyquery-const-qurl-amp-requesturl-qnetworkproxyquery-querytype-querytype-urlrequest" class="header-anchor">#</a></h3><p>用URL <em>requestUrl</em>构建一个QNetworkProxyQuery，并将查询类型设置为<em>queryType</em>。</p>
<p><strong>See also</strong> <a href="#protocolTag">protocolTag</a>(), <a href="#peerHostName">peerHostName</a>(), and <a href="#peerPort">peerPort</a>().</p>
<h3><span id="qnetworkproxyquery-qnetworkproxyquery">QNetworkProxyQuery::QNetworkProxyQuery()</span><a href="#qnetworkproxyquery-qnetworkproxyquery" class="header-anchor">#</a></h3><p>构建一个默认的QNetworkProxyQuery对象。默认情况下，查询类型将是[QNetworkProxyQuery::TcpSocket]（#QueryType-enum）。</p>
<h3><span id="qnetworkproxyquery-amp-qnetworkproxyquery-operator-const-qnetworkproxyquery-amp-other"> &amp;QNetworkProxyQuery::operator=(const  &amp;<em>other</em>)</span><a href="#qnetworkproxyquery-amp-qnetworkproxyquery-operator-const-qnetworkproxyquery-amp-other" class="header-anchor">#</a></h3><p>复制<em>other</em>的内容。</p>
<h3><span id="qnetworkproxyquery-qnetworkproxyquery">QNetworkProxyQuery::~QNetworkProxyQuery()</span><a href="#qnetworkproxyquery-qnetworkproxyquery" class="header-anchor">#</a></h3><p>销毁这个<a href>QNetworkProxyQuery</a>对象。</p>
<h3><span id="int-qnetworkproxyquery-localport-const">int QNetworkProxyQuery::localPort() const</span><a href="#int-qnetworkproxyquery-localport-const" class="header-anchor">#</a></h3><p>返回接受来自远程服务器的数据包的套接字的端口号，如果端口不知道，则返回-1。</p>
<p><strong>See also</strong> <a href="#peerPort">peerPort</a>(), <a href="#peerHostName">peerHostName</a>(), and <a href="#setLocalPort">setLocalPort</a>().</p>
<h3><span id="qstring-qnetworkproxyquery-peerhostname-const"> QNetworkProxyQuery::peerHostName() const</span><a href="#qstring-qnetworkproxyquery-peerhostname-const" class="header-anchor">#</a></h3><p>返回正在请求的外发连接的主机名或IP地址，如果不知道远程主机名，则返回一个空字符串。</p>
<p>如果查询类型是<a href="#QueryType-enum">QNetworkProxyQuery::UrlRequest</a>，该函数返回被请求的URL的主机部分。</p>
<p><strong>See also</strong> <a href="#peerPort">peerPort</a>(), <a href="#localPort">localPort</a>(), and <a href="#setPeerHostName">setPeerHostName</a>().</p>
<h3><span id="int-qnetworkproxyquery-peerport-const">int QNetworkProxyQuery::peerPort() const</span><a href="#int-qnetworkproxyquery-peerport-const" class="header-anchor">#</a></h3><p>返回出站请求的端口号，如果端口号不知道，则返回-1。</p>
<p>如果查询类型是<a href="#QueryType-enum">QNetworkProxyQuery::UrlRequest</a>，该函数返回被请求的URL的端口号。一般来说，框架会从它们的默认值中填入端口号。</p>
<p><strong>See also</strong> <a href="#peerHostName">peerHostName</a>(), <a href="#localPort">localPort</a>(), and <a href="#setPeerPort">setPeerPort</a>().</p>
<h3><span id="qstring-qnetworkproxyquery-protocoltag-const"> QNetworkProxyQuery::protocolTag() const</span><a href="#qstring-qnetworkproxyquery-protocoltag-const" class="header-anchor">#</a></h3><p>返回这个<a href>QNetworkProxyQuery</a>对象的协议标签，或者在协议标签未知的情况下返回一个空的<a target="_blank" rel="noopener" href="https://doc.qt.io/qt-6/qstring.html">QString</a>。</p>
<p>如果是<a href="#QueryType-enum">QNetworkProxyQuery::UrlRequest</a>类型的查询，这个函数返回URL的方案组件的值。</p>
<p><strong>See also</strong> <a href="#setProtocolTag">setProtocolTag</a>() and <a href="#url">url</a>().</p>
<h3><span id="qnetworkproxyquery-querytype-qnetworkproxyquery-querytype-const"> QNetworkProxyQuery::queryType() const</span><a href="#qnetworkproxyquery-querytype-qnetworkproxyquery-querytype-const" class="header-anchor">#</a></h3><p>返回查询类型。</p>
<p><strong>See also</strong> <a href="#setQueryType">setQueryType</a>().</p>
<h3><span id="void-qnetworkproxyquery-setlocalport-int-port">void QNetworkProxyQuery::setLocalPort(int <em>port</em>)</span><a href="#void-qnetworkproxyquery-setlocalport-int-port" class="header-anchor">#</a></h3><p>将套接字希望在本地使用的接受来自远程服务器的传入数据包的端口号设置为<em>port</em>。本地端口最常被用于<a href="#QueryType-enum">QNetworkProxyQuery::TcpServer</a>和<a href="#QueryType-enum">QNetworkProxyQuery::UdpSocket</a>查询类型。</p>
<p>有效值是0到65535（0表示任何端口号都可以接受）或-1，这意味着本地端口号未知或不适用。</p>
<p>在某些情况下，对于特殊的协议，它的本地端口号也可以用<a href="#QueryType-enum">QNetworkProxyQuery::TcpSocket</a>类型的查询来使用。当这种情况发生时，套接字表明它希望在连接到远程主机时使用端口号<em>port</em>。</p>
<p><strong>See also</strong> <a href="#localPort">localPort</a>(), <a href="#setPeerPort">setPeerPort</a>(), and <a href="#setPeerHostName">setPeerHostName</a>().</p>
<h3><span id="void-qnetworkproxyquery-setpeerhostname-const-qstring-amp-hostname">void QNetworkProxyQuery::setPeerHostName(const  &amp;<em>hostname</em>)</span><a href="#void-qnetworkproxyquery-setpeerhostname-const-qstring-amp-hostname" class="header-anchor">#</a></h3><p>将被请求的外发连接的主机名设置为<em>hostname</em>。一个空的主机名可以用来表示远程主机是未知的。</p>
<p>在<a href="#QueryType-enum">QNetworkProxyQuery::UdpSocket</a>或<a href="#QueryType-enum">QNetworkProxyQuery::TcpServer</a>查询类型的情况下，对等主机名也可用于指示传入连接的预期源地址。</p>
<p><strong>See also</strong> <a href="#peerHostName">peerHostName</a>(), <a href="#setPeerPort">setPeerPort</a>(), and <a href="#setLocalPort">setLocalPort</a>().</p>
<h3><span id="void-qnetworkproxyquery-setpeerport-int-port">void QNetworkProxyQuery::setPeerPort(int <em>port</em>)</span><a href="#void-qnetworkproxyquery-setpeerport-int-port" class="header-anchor">#</a></h3><p>将出站连接的请求端口号设置为<em>port</em>。有效值是1到65535，或者-1表示远程端口号未知。</p>
<p>在<a href="#QueryType-enum">QNetworkProxyQuery::UdpSocket</a>或<a href="#QueryType-enum">QNetworkProxyQuery::TcpServer</a>查询类型的情况下，对等端口号也可用于指示传入连接的预期端口号。</p>
<p><strong>See also</strong> <a href="#peerPort">peerPort</a>(), <a href="#setPeerHostName">setPeerHostName</a>(), and <a href="#setLocalPort">setLocalPort</a>().</p>
<h3><span id="void-qnetworkproxyquery-setprotocoltag-const-qstring-amp-protocoltag">void QNetworkProxyQuery::setProtocolTag(const  &amp;<em>protocolTag</em>)</span><a href="#void-qnetworkproxyquery-setprotocoltag-const-qstring-amp-protocoltag" class="header-anchor">#</a></h3><p>为这个<a href>QNetworkProxyQuery</a>对象设置协议标签为<em>protocolTag</em>。</p>
<p>协议标签是一个任意的字符串，表示在套接字上谈论的是哪个协议，例如 “http”、”xmpp”、”telnet”，等等。协议标签被后端用来返回更具体的协议请求：例如，一个HTTP连接可以使用一个缓存的HTTP代理服务器，而所有其他连接则使用一个更强大的SOCKSv5代理服务器。</p>
<p><strong>See also</strong> <a href="#protocolTag">protocolTag</a>().</p>
<h3><span id="void-qnetworkproxyquery-setquerytype-qnetworkproxyquery-querytype-type">void QNetworkProxyQuery::setQueryType( <em>type</em>)</span><a href="#void-qnetworkproxyquery-setquerytype-qnetworkproxyquery-querytype-type" class="header-anchor">#</a></h3><p>设置此对象的查询类型为<em>type</em>。</p>
<p><strong>See also</strong> <a href="#queryType">queryType</a>().</p>
<h3><span id="void-qnetworkproxyquery-seturl-const-qurl-amp-url">void QNetworkProxyQuery::setUrl(const  &amp;<em>url</em>)</span><a href="#void-qnetworkproxyquery-seturl-const-qurl-amp-url" class="header-anchor">#</a></h3><p>将这个<a href>QNetworkProxyQuery</a>对象的URL组件设置为<em>url</em>。设置URL也将设置协议标签、远程主机名和端口号。这样做是为了方便执行确定要使用的代理服务器的代码。</p>
<p><strong>See also</strong> <a href="#url">url</a>(), <a href="#peerHostName">peerHostName</a>(), and <a href="#peerPort">peerPort</a>().</p>
<h3><span id="since-5-0-void-qnetworkproxyquery-swap-qnetworkproxyquery-amp-other"><code>[since 5.0]</code>void QNetworkProxyQuery::swap( &amp;<em>other</em>)</span><a href="#since-5-0-void-qnetworkproxyquery-swap-qnetworkproxyquery-amp-other" class="header-anchor">#</a></h3><p>将这个网络代理查询实例与<em>other</em>交换。这个功能非常快，而且从不失败。</p>
<p>这个函数在Qt 5.8中引入。</p>
<h3><span id="qurl-qnetworkproxyquery-url-const"> QNetworkProxyQuery::url() const</span><a href="#qurl-qnetworkproxyquery-url-const" class="header-anchor">#</a></h3><p>在查询类型为<a href="#QueryType-enum">QNetworkProxyQuery::UrlRequest</a>的情况下，返回该<a href>QNetworkProxyQuery</a>对象的URL组件。</p>
<p><strong>See also</strong> <a href="#setUrl">setUrl</a>().</p>
<h3><span id="bool-qnetworkproxyquery-operator-const-qnetworkproxyquery-amp-other-const">bool QNetworkProxyQuery::operator!=(const  &amp;<em>other</em>) const</span><a href="#bool-qnetworkproxyquery-operator-const-qnetworkproxyquery-amp-other-const" class="header-anchor">#</a></h3><p>如果这个<a href>QNetworkProxyQuery</a>对象不包含与<em>other</em>相同的数据，则返回<code>true</code>。</p>
<h3><span id="bool-qnetworkproxyquery-operator-const-qnetworkproxyquery-amp-other-const">bool QNetworkProxyQuery::operator==(const  &amp;<em>other</em>) const</span><a href="#bool-qnetworkproxyquery-operator-const-qnetworkproxyquery-amp-other-const" class="header-anchor">#</a></h3><p>如果这个<a href>QNetworkProxyQuery</a>对象包含与<em>other</em>相同的数据，则返回<code>true</code>。</p>

            </div>
            <hr>
            <div>
              <div class="post-metas mb-3">
                
                
                  <div class="post-meta">
                    <i class="iconfont icon-tags"></i>
                    
                      <a class="hover-with-bg" href="/tags/N/">N</a>
                    
                  </div>
                
              </div>
              
                <p class="note note-warning">
                  
                    本博客所有文章除特别声明外，均采用 <a target="_blank" href="https://creativecommons.org/licenses/by-sa/4.0/deed.zh" rel="nofollow noopener noopener">CC BY-SA 4.0 协议</a> ，转载请注明出处！
                  
                </p>
              
              
                <div class="post-prevnext">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/2022/03/02/QtDocumentCN/Src/N/QNetworkProxyFactory/QNetworkProxyFactory/">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">QNetworkProxyFactory类</span>
                        <span class="visible-mobile">上一篇</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2022/03/02/QtDocumentCN/Src/N/QNetworkReply/QNetworkReply/">
                        <span class="hidden-mobile">QNetworkReply类</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
              <!-- Comments -->
              <article class="comments" id="comments" lazyload>
                
                  
                
                
  <div id="lv-container" data-id="city" data-uid="MTAyMC81NTMzMi8zMTc5OQ==">
    <script type="text/javascript">
      Fluid.utils.loadComments('#lv-container', function() {
        Fluid.utils.createScript('https://cdn-city.livere.com/js/embed.dist.js');
      });
    </script>
    <noscript>Please enable JavaScript to view the comments</noscript>
  </div>


              </article>
            
          </article>
        </div>
      </div>
    </div>
    
      <div class="d-none d-lg-block col-lg-2 toc-container" id="toc-ctn">
        <div id="toc">
  <p class="toc-header"><i class="iconfont icon-list"></i>&nbsp;目录</p>
  <div class="toc-body" id="toc-body"></div>
</div>

      </div>
    
  </div>
</div>

<!-- Custom -->


    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v"
                 for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>
    

    
  </main>

  <footer class="text-center mt-5 py-3">
  <div class="footer-content">
     <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> 
  </div>
  

  

  
</footer>


  <!-- SCRIPTS -->
  
  <script  src="https://cdn.jsdelivr.net/npm/nprogress@0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/nprogress@0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js" ></script>
<script  src="https://cdn.jsdelivr.net/npm/bootstrap@4/dist/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>

<!-- Plugins -->


  <script  src="/js/local-search.js" ></script>



  
    <script  src="/js/img-lazyload.js" ></script>
  



  



  
    <script  src="https://cdn.jsdelivr.net/npm/tocbot@4/dist/tocbot.min.js" ></script>
  
  
    <script  src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3/dist/jquery.fancybox.min.js" ></script>
  
  
    <script  src="https://cdn.jsdelivr.net/npm/anchor-js@4/anchor.min.js" ></script>
  
  
    <script defer src="https://cdn.jsdelivr.net/npm/clipboard@2/dist/clipboard.min.js" ></script>
  






  <script  src="https://cdn.jsdelivr.net/npm/typed.js@2/lib/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var title = document.getElementById('subtitle').title;
      
        typing(title);
      
    })(window, document);
  </script>















<!-- 主题的启动项 保持在最底部 -->
<script  src="/js/boot.js" ></script>


</body>
</html>
