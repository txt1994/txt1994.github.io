

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=auto>



<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/logo.jpg">
  <link rel="icon" href="/img/logo.jpg">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
    <meta http-equiv="Content-Security-Policy" content="upgrade-insecure-requests">
  
  <meta name="theme-color" content="#6aa84f">
  <meta name="author" content="John Doe">
  <meta name="keywords" content="">
  
    <meta name="description" content="QNetworkRequest Class 公共类型 公共函数 详细描述 成员类型文档 enum QNetworkRequest::Attribute enum QNetworkRequest::CacheLoadControl enum QNetworkRequest::KnownHeaders enum QNetworkRequest::LoadControl enum QNetwo">
<meta property="og:type" content="article">
<meta property="og:title" content="QNetworkRequest类">
<meta property="og:url" content="https://txt1994.github.io/2022/03/02/QtDocumentCN/Src/N/QNetworkRequest/QNetworkRequest/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:description" content="QNetworkRequest Class 公共类型 公共函数 详细描述 成员类型文档 enum QNetworkRequest::Attribute enum QNetworkRequest::CacheLoadControl enum QNetworkRequest::KnownHeaders enum QNetworkRequest::LoadControl enum QNetwo">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2022-03-02T06:47:47.000Z">
<meta property="article:modified_time" content="2022-03-18T16:49:45.442Z">
<meta property="article:author" content="John Doe">
<meta property="article:tag" content="N">
<meta name="twitter:card" content="summary_large_image">
  
  
  <title>QNetworkRequest类 - Hexo</title>

  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4/dist/css/bootstrap.min.css" />


  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/github-markdown-css@4/github-markdown.min.css" />
  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/hint.css@2/hint.min.css" />

  
    
    
      
      <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@10/styles/github-gist.min.css" />
    
  

  
    <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3/dist/jquery.fancybox.min.css" />
  


<!-- 主题依赖的图标库，不要自行修改 -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_ba1fz6golrf.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_lbnruvf0jn.css">


<link  rel="stylesheet" href="/css/main.css" />

<!-- 自定义样式保持在最底部 -->

  
<link rel="stylesheet" href="/css/style.css">



  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    var CONFIG = {"hostname":"txt1994.github.io","root":"/","version":"1.8.14","typing":{"enable":true,"typeSpeed":70,"cursorChar":"_","loop":false},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"right","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"copy_btn":true,"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":false,"baidu":null,"google":null,"gtag":null,"tencent":{"sid":null,"cid":null},"woyaola":null,"cnzz":null,"leancloud":{"app_id":null,"app_key":null,"server_url":null,"path":"window.location.pathname","ignore_local":false}},"search_path":"/local-search.xml"};
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
<meta name="generator" content="Hexo 6.1.0">
<style>.github-emoji { position: relative; display: inline-block; width: 1.2em; min-height: 1.2em; overflow: hidden; vertical-align: top; color: transparent; }  .github-emoji > span { position: relative; z-index: 10; }  .github-emoji img, .github-emoji .fancybox { margin: 0 !important; padding: 0 !important; border: none !important; outline: none !important; text-decoration: none !important; user-select: none !important; cursor: auto !important; }  .github-emoji img { height: 1.2em !important; width: 1.2em !important; position: absolute !important; left: 50% !important; top: 50% !important; transform: translate(-50%, -50%) !important; user-select: none !important; cursor: auto !important; } .github-emoji-fallback { color: inherit; } .github-emoji-fallback img { opacity: 0 !important; }</style>
</head>


<body>
  <header style="height: 70vh;">
    <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/">
      <strong>txt1994s</strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/">
                <i class="iconfont icon-home-fill"></i>
                首页
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/">
                <i class="iconfont icon-archive-fill"></i>
                归档
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/">
                <i class="iconfont icon-tags-fill"></i>
                标签
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/">
                <i class="iconfont icon-user-fill"></i>
                关于
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/links/">
                <i class="iconfont icon-link-fill"></i>
                友联
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              &nbsp;<i class="iconfont icon-search"></i>&nbsp;
            </a>
          </li>
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">&nbsp;<i
                class="iconfont icon-dark" id="color-toggle-icon"></i>&nbsp;</a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

    <div class="banner" id="banner" parallax=true
         style="background: url('/img/default.png') no-repeat center center;
           background-size: cover;">
      <div class="full-bg-img">
        <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
          <div class="page-header text-center fade-in-up">
            <span class="h2" id="subtitle" title="QNetworkRequest类">
              
            </span>

            
              <div class="mt-3">
  
  
    <span class="post-meta">
      <i class="iconfont icon-date-fill" aria-hidden="true"></i>
      <time datetime="2022-03-02 14:47" pubdate>
        2022年3月2日 下午
      </time>
    </span>
  
</div>

<div class="mt-1">
  
    <span class="post-meta mr-2">
      <i class="iconfont icon-chart"></i>
      18k 字
    </span>
  

  
    <span class="post-meta mr-2">
      <i class="iconfont icon-clock-fill"></i>
      
      
      152 分钟
    </span>
  

  
  
</div>

            
          </div>

          
        </div>
      </div>
    </div>
  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="d-none d-lg-block col-lg-2"></div>
    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div class="py-5" id="board">
          <article class="post-content mx-auto">
            <!-- SEO header -->
            <h1 style="display: none">QNetworkRequest类</h1>
            
              <p class="note note-info">
                
                  本文最后更新于：2022年3月19日 凌晨
                
              </p>
            
            <div class="markdown-body">
              <div class="toc">

<!-- toc -->

<ul>
<li><a href="#qnetworkrequest-class">QNetworkRequest Class</a><ul>
<li><a href="#gong-gong-lei-xing">公共类型</a></li>
<li><a href="#gong-gong-han-shu">公共函数</a></li>
<li><a href="#xiang-xi-miao-shu">详细描述</a></li>
<li><a href="#cheng-yuan-lei-xing-wen-dang">成员类型文档</a><ul>
<li><a href="#enum-qnetworkrequest-attribute">enum QNetworkRequest::Attribute</a></li>
<li><a href="#enum-qnetworkrequest-cacheloadcontrol">enum QNetworkRequest::CacheLoadControl</a></li>
<li><a href="#enum-qnetworkrequest-knownheaders">enum QNetworkRequest::KnownHeaders</a></li>
<li><a href="#enum-qnetworkrequest-loadcontrol">enum QNetworkRequest::LoadControl</a></li>
<li><a href="#enum-qnetworkrequest-priority">enum QNetworkRequest::Priority</a></li>
<li><a href="#since-5-9-enum-qnetworkrequest-redirectpolicy"><code>[since 5.9]</code>enum QNetworkRequest::RedirectPolicy</a></li>
<li><a href="#since-5-15-enum-qnetworkrequest-transfertimeoutconstant"><code>[since 5.15]</code>enum QNetworkRequest::TransferTimeoutConstant</a></li>
</ul>
</li>
<li><a href="#cheng-yuan-han-shu-wen-dang">成员函数文档</a><ul>
<li><a href="#qnetworkrequest-qnetworkrequest-const-qnetworkrequest-qnetworkrequest-other">QNetworkRequest::QNetworkRequest(const </a><a href="#QNetworkRequest">QNetworkRequest</a> &amp;<em>other</em>)</li>
<li><a href="#qnetworkrequest-qnetworkrequest-const-qurl-qurl-html-url">QNetworkRequest::QNetworkRequest(const </a><a href="qurl.html">QUrl</a> &amp;<em>url</em>)</li>
<li><a href="#qnetworkrequest-qnetworkrequest">QNetworkRequest::QNetworkRequest()</a></li>
<li><a href="#qnetworkrequest-qnetworkrequest-qnetworkrequest-operator-const-qnetworkrequest-qnetworkrequest-other">QNetworkRequest</a></li>
<li><a href="#qnetworkrequest-qnetworkrequest">QNetworkRequest::~QNetworkRequest()</a></li>
<li><a href="#qvariant-qvariant-html-qnetworkrequest-attribute-qnetworkrequest-attribute-attribute-enum-code-const-qvariant-qvariant-html-defaultvalue-qvariant-const">QVariant</a></li>
<li><a href="#since-6-2-qint64-qtglobal-html-qint64-typedef-qnetworkrequest-decompressedsafetycheckthreshold-const"><code>[since 6.2]</code></a><a href="qtglobal.html#qint64-typedef">qint64</a> QNetworkRequest::decompressedSafetyCheckThreshold() const</li>
<li><a href="#bool-qnetworkrequest-hasrawheader-const-qbytearray-qbytearray-html-headername-const">bool QNetworkRequest::hasRawHeader(const </a><a href="qbytearray.html">QByteArray</a> &amp;<em>headerName</em>) const</li>
<li><a href="#qvariant-qvariant-html-qnetworkrequest-header-qnetworkrequest-knownheaders-knownheaders-enum-header-const-1">QVariant</a></li>
<li><a href="#since-5-14-qhttp2configuration-qhttp2configuration-html-qnetworkrequest-http2configuration-const"><code>[since 5.14]</code></a><a href="qhttp2configuration.html">QHttp2Configuration</a> QNetworkRequest::http2Configuration() const</li>
<li><a href="#since-5-6-int-qnetworkrequest-maximumredirectsallowed-const"><code>[since 5.6]</code>int QNetworkRequest::maximumRedirectsAllowed() const</a></li>
<li><a href="#qobject-qobject-html-qnetworkrequest-originatingobject-const">QObject</a></li>
<li><a href="#since-5-13-qstring-qstring-html-qnetworkrequest-peerverifyname-const"><code>[since 5.13]</code></a><a href="qstring.html">QString</a> QNetworkRequest::peerVerifyName() const</li>
<li><a href="#qnetworkrequest-priority-priority-enum-qnetworkrequest-priority-const">QNetworkRequest::Priority</a></li>
<li><a href="#qbytearray-qbytearray-html-qnetworkrequest-rawheader-const-qbytearray-qbytearray-html-headername-const">QByteArray</a></li>
<li><a href="#qlist-qlist-html-qbytearray-qbytearray-html-qnetworkrequest-rawheaderlist-const">QList</a></li>
<li><a href="#void-qnetworkrequest-setattribute-qnetworkrequest-attribute-attribute-enum-code-const-qvariant-qvariant-html-value">void QNetworkRequest::setAttribute(</a><a href="#Attribute-enum">QNetworkRequest::Attribute</a> <em>code</em>, const <a href="qvariant.html">QVariant</a> &amp;<em>value</em>)</li>
<li><a href="#since-6-2-void-qnetworkrequest-setdecompressedsafetycheckthreshold-qint64-qtglobal-html-qint64-typedef-threshold"><code>[since 6.2]</code>void QNetworkRequest::setDecompressedSafetyCheckThreshold(</a><a href="qtglobal.html#qint64-typedef">qint64</a> <em>threshold</em>)</li>
<li><a href="#void-qnetworkrequest-setheader-qnetworkrequest-knownheaders-knownheaders-enum-header-const-qvariant-qvariant-html-value">void QNetworkRequest::setHeader(</a><a href="#KnownHeaders-enum">QNetworkRequest::KnownHeaders</a> <em>header</em>, const <a href="qvariant.html">QVariant</a> &amp;<em>value</em>)</li>
<li><a href="#since-5-14-void-qnetworkrequest-sethttp2configuration-const-qhttp2configuration-qhttp2configuration-html-configuration"><code>[since 5.14]</code>void QNetworkRequest::setHttp2Configuration(const </a><a href="qhttp2configuration.html">QHttp2Configuration</a> &amp;<em>configuration</em>)</li>
<li><a href="#since-5-6-void-qnetworkrequest-setmaximumredirectsallowed-int-maxredirectsallowed"><code>[since 5.6]</code>void QNetworkRequest::setMaximumRedirectsAllowed(int <em>maxRedirectsAllowed</em>)</a></li>
<li><a href="#void-qnetworkrequest-setoriginatingobject-qobject-qobject-html-object">void QNetworkRequest::setOriginatingObject(</a><a href="qobject.html">QObject</a> *<em>object</em>)</li>
<li><a href="#since-5-13-void-qnetworkrequest-setpeerverifyname-const-qstring-qstring-html-peername"><code>[since 5.13]</code>void QNetworkRequest::setPeerVerifyName(const </a><a href="qstring.html">QString</a> &amp;<em>peerName</em>)</li>
<li><a href="#void-qnetworkrequest-setpriority-qnetworkrequest-priority-priority-enum-priority">void QNetworkRequest::setPriority(</a><a href="#Priority-enum">QNetworkRequest::Priority</a> <em>priority</em>)</li>
<li><a href="#void-qnetworkrequest-setrawheader-const-qbytearray-qbytearray-html-headername-const-qbytearray-qbytearray-html-headervalue">void QNetworkRequest::setRawHeader(const </a><a href="qbytearray.html">QByteArray</a> &amp;<em>headerName</em>, const <a href="qbytearray.html">QByteArray</a> &amp;<em>headerValue</em>)</li>
<li><a href="#void-qnetworkrequest-setsslconfiguration-const-qsslconfiguration-qsslconfiguration-html-config">void QNetworkRequest::setSslConfiguration(const </a><a href="qsslconfiguration.html">QSslConfiguration</a> &amp;<em>config</em>)</li>
<li><a href="#since-5-15-void-qnetworkrequest-settransfertimeout-int-timeout-defaulttransfertimeoutconstant"><code>[since 5.15]</code>void QNetworkRequest::setTransferTimeout(int <em>timeout</em> = DefaultTransferTimeoutConstant)</a></li>
<li><a href="#void-qnetworkrequest-seturl-const-qurl-qurl-html-url">void QNetworkRequest::setUrl(const </a><a href="qurl.html">QUrl</a> &amp;<em>url</em>)</li>
<li><a href="#qsslconfiguration-qsslconfiguration-html-qnetworkrequest-sslconfiguration-const">QSslConfiguration</a></li>
<li><a href="#since-5-0-void-qnetworkrequest-swap-qnetworkrequest-qnetworkrequest-other"><code>[since 5.0]</code>void QNetworkRequest::swap(</a><a href="#QNetworkRequest">QNetworkRequest</a> &amp;<em>other</em>)</li>
<li><a href="#since-5-15-int-qnetworkrequest-transfertimeout-const"><code>[since 5.15]</code>int QNetworkRequest::transferTimeout() const</a></li>
<li><a href="#qurl-qurl-html-qnetworkrequest-url-const">QUrl</a></li>
<li><a href="#bool-qnetworkrequest-operator-const-qnetworkrequest-qnetworkrequest-other-const">bool QNetworkRequest::operator!=(const </a><a href="#QNetworkRequest">QNetworkRequest</a> &amp;<em>other</em>) const</li>
<li><a href="#bool-qnetworkrequest-operator-const-qnetworkrequest-qnetworkrequest-other-const">bool QNetworkRequest::operator==(const </a><a href="#QNetworkRequest">QNetworkRequest</a> &amp;<em>other</em>) const</li>
</ul>
</li>
</ul>
</li>
</ul>
<!-- tocstop -->

</div>
目录：

<ul>
<li><p><a href="#%E5%85%AC%E5%85%B1%E7%B1%BB%E5%9E%8B">公共类型</a></p>
</li>
<li><p><a href="#%E5%85%AC%E5%85%B1%E5%87%BD%E6%95%B0">公共函数</a></p>
</li>
<li><p><a href="#%E8%AF%A6%E7%BB%86%E6%8F%8F%E8%BF%B0">详细描述</a></p>
</li>
<li><p><a href="#%E6%88%90%E5%91%98%E7%B1%BB%E5%9E%8B%E6%96%87%E6%A1%A3">成员类型文档</a></p>
</li>
<li><p><a href="#%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0%E6%96%87%E6%A1%A3">成员函数文档</a></p>
</li>
</ul>
<h1><span id="qnetworkrequest-class">QNetworkRequest Class</span><a href="#qnetworkrequest-class" class="header-anchor">#</a></h1><p>QNetworkRequest类持有要用<a href="qnetworkaccessmanager.html">QNetworkAccessManager</a>发送的请求。<a href="#%E8%AF%A6%E7%BB%86%E6%8F%8F%E8%BF%B0">More…</a></p>
<table>
<thead>
<tr>
<th>Header:</th>
<th>#include <qnetworkrequest></qnetworkrequest></th>
</tr>
</thead>
<tbody><tr>
<td>CMake:</td>
<td>find_package(Qt6 COMPONENTS Network REQUIRED) target_link_libraries(mytarget PRIVATE Qt6::Network)</td>
</tr>
<tr>
<td>qmake:</td>
<td>QT += network</td>
</tr>
</tbody></table>
<ul>
<li><a href="qnetworkrequest-members.html">List of all members, including inherited members</a></li>
</ul>
<h2><span id="gong-gong-lei-xing">公共类型</span><a href="#gong-gong-lei-xing" class="header-anchor">#</a></h2><table>
<thead>
<tr>
<th>enum</th>
<th><strong><a href="#Attribute-enum">Attribute</a></strong> { HttpStatusCodeAttribute, HttpReasonPhraseAttribute, RedirectionTargetAttribute, ConnectionEncryptedAttribute, CacheLoadControlAttribute, …, UserMax }</th>
</tr>
</thead>
<tbody><tr>
<td>enum</td>
<td><strong><a href="#CacheLoadControl-enum">CacheLoadControl</a></strong> { AlwaysNetwork, PreferNetwork, PreferCache, AlwaysCache }</td>
</tr>
<tr>
<td>enum</td>
<td><strong><a href="#KnownHeaders-enum">KnownHeaders</a></strong> { ContentDispositionHeader, ContentTypeHeader, ContentLengthHeader, LocationHeader, LastModifiedHeader, …, ServerHeader }</td>
</tr>
<tr>
<td>enum</td>
<td><strong><a href="#LoadControl-enum">LoadControl</a></strong> { Automatic, Manual }</td>
</tr>
<tr>
<td>enum</td>
<td><strong><a href="#Priority-enum">Priority</a></strong> { HighPriority, NormalPriority, LowPriority }</td>
</tr>
<tr>
<td>enum</td>
<td><strong><a href="#RedirectPolicy-enum">RedirectPolicy</a></strong> { ManualRedirectPolicy, NoLessSafeRedirectPolicy, SameOriginRedirectPolicy, UserVerifiedRedirectPolicy }</td>
</tr>
<tr>
<td>enum</td>
<td><strong><a href="#TransferTimeoutConstant-enum">TransferTimeoutConstant</a></strong> { DefaultTransferTimeoutConstant }</td>
</tr>
</tbody></table>
<h2><span id="gong-gong-han-shu">公共函数</span><a href="#gong-gong-han-shu" class="header-anchor">#</a></h2><table>
<thead>
<tr>
<th></th>
<th><strong><a href="#QNetworkRequest-2">QNetworkRequest</a></strong>(const QNetworkRequest &amp;<em>other</em>)</th>
</tr>
</thead>
<tbody><tr>
<td></td>
<td><strong><a href="#QNetworkRequest-1">QNetworkRequest</a></strong>(const QUrl &amp;<em>url</em>)</td>
</tr>
<tr>
<td></td>
<td><strong><a href="#QNetworkRequest">QNetworkRequest</a></strong>()</td>
</tr>
<tr>
<td>QNetworkRequest &amp;</td>
<td><strong><a href="#operator-eq-1">operator=</a></strong>(const QNetworkRequest &amp;<em>other</em>)</td>
</tr>
<tr>
<td></td>
<td><strong><a href="#dtor.QNetworkRequest">~QNetworkRequest</a></strong>()</td>
</tr>
<tr>
<td>QVariant</td>
<td><strong><a href="#attribute">attribute</a></strong>(QNetworkRequest::Attribute <em>code</em>, const QVariant &amp;<em>defaultValue</em> = QVariant()) const</td>
</tr>
<tr>
<td>qint64</td>
<td><strong><a href="#decompressedSafetyCheckThreshold">decompressedSafetyCheckThreshold</a></strong>() const</td>
</tr>
<tr>
<td>bool</td>
<td><strong><a href="#hasRawHeader">hasRawHeader</a></strong>(const QByteArray &amp;<em>headerName</em>) const</td>
</tr>
<tr>
<td>QVariant</td>
<td><strong><a href="#header">header</a></strong>(QNetworkRequest::KnownHeaders <em>header</em>) const</td>
</tr>
<tr>
<td>QHttp2Configuration</td>
<td><strong><a href="#http2Configuration">http2Configuration</a></strong>() const</td>
</tr>
<tr>
<td>int</td>
<td><strong><a href="#maximumRedirectsAllowed">maximumRedirectsAllowed</a></strong>() const</td>
</tr>
<tr>
<td>QObject *</td>
<td><strong><a href="#originatingObject">originatingObject</a></strong>() const</td>
</tr>
<tr>
<td>QString</td>
<td><strong><a href="#peerVerifyName">peerVerifyName</a></strong>() const</td>
</tr>
<tr>
<td>QNetworkRequest::Priority</td>
<td><strong><a href="#priority">priority</a></strong>() const</td>
</tr>
<tr>
<td>QByteArray</td>
<td><strong><a href="#rawHeader">rawHeader</a></strong>(const QByteArray &amp;<em>headerName</em>) const</td>
</tr>
<tr>
<td>QList<qbytearray></qbytearray></td>
<td><strong><a href="#rawHeaderList">rawHeaderList</a></strong>() const</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="#setAttribute">setAttribute</a></strong>(QNetworkRequest::Attribute <em>code</em>, const QVariant &amp;<em>value</em>)</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="#setDecompressedSafetyCheckThreshold">setDecompressedSafetyCheckThreshold</a></strong>(qint64 <em>threshold</em>)</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="#setHeader">setHeader</a></strong>(QNetworkRequest::KnownHeaders <em>header</em>, const QVariant &amp;<em>value</em>)</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="#setHttp2Configuration">setHttp2Configuration</a></strong>(const QHttp2Configuration &amp;<em>configuration</em>)</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="#setMaximumRedirectsAllowed">setMaximumRedirectsAllowed</a></strong>(int <em>maxRedirectsAllowed</em>)</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="#setOriginatingObject">setOriginatingObject</a></strong>(QObject *<em>object</em>)</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="#setPeerVerifyName">setPeerVerifyName</a></strong>(const QString &amp;<em>peerName</em>)</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="#setPriority">setPriority</a></strong>(QNetworkRequest::Priority <em>priority</em>)</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="#setRawHeader">setRawHeader</a></strong>(const QByteArray &amp;<em>headerName</em>, const QByteArray &amp;<em>headerValue</em>)</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="#setSslConfiguration">setSslConfiguration</a></strong>(const QSslConfiguration &amp;<em>config</em>)</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="#setTransferTimeout">setTransferTimeout</a></strong>(int <em>timeout</em> = DefaultTransferTimeoutConstant)</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="#setUrl">setUrl</a></strong>(const QUrl &amp;<em>url</em>)</td>
</tr>
<tr>
<td>QSslConfiguration</td>
<td><strong><a href="#sslConfiguration">sslConfiguration</a></strong>() const</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="#swap">swap</a></strong>(QNetworkRequest &amp;<em>other</em>)</td>
</tr>
<tr>
<td>int</td>
<td><strong><a href="#transferTimeout">transferTimeout</a></strong>() const</td>
</tr>
<tr>
<td>QUrl</td>
<td><strong><a href="#url">url</a></strong>() const</td>
</tr>
<tr>
<td>bool</td>
<td><strong><a href="#operator-not-eq">operator!=</a></strong>(const QNetworkRequest &amp;<em>other</em>) const</td>
</tr>
<tr>
<td>bool</td>
<td><strong><a href="#operator-eq-eq">operator==</a></strong>(const QNetworkRequest &amp;<em>other</em>) const</td>
</tr>
</tbody></table>
<h2><span id="xiang-xi-miao-shu">详细描述</span><a href="#xiang-xi-miao-shu" class="header-anchor">#</a></h2><p>QNetworkRequest是网络访问API的一部分，是持有通过网络发送请求所需信息的类。它包含一个URL和一些辅助信息，可以用来修改请求。</p>
<p><strong>See also</strong> <a href="qnetworkreply.html">QNetworkReply</a> and <a href="qnetworkaccessmanager.html">QNetworkAccessManager</a>.</p>
<h2><span id="cheng-yuan-lei-xing-wen-dang">成员类型文档</span><a href="#cheng-yuan-lei-xing-wen-dang" class="header-anchor">#</a></h2><h3><span id="enum-qnetworkrequest-attribute">enum QNetworkRequest::Attribute</span><a href="#enum-qnetworkrequest-attribute" class="header-anchor">#</a></h3><p>用于<a href>QNetworkRequest</a>和<a href="qnetworkreply.html">QNetworkReply</a>的属性代码。</p>
<p>属性是额外的元数据，用于控制请求的行为，并从回复中传递进一步的信息给应用程序。属性也是可扩展的，允许自定义实现传递自定义值。</p>
<p>下表解释了默认的属性代码是什么，与之相关的<a href="qvariant.html">QVariant</a>类型，如果所述属性缺失的默认值，以及它是否在请求或回复中使用。</p>
<table>
<thead>
<tr>
<th>Constant</th>
<th>Value</th>
<th>Description</th>
</tr>
</thead>
<tbody><tr>
<td><code>QNetworkRequest::HttpStatusCodeAttribute</code></td>
<td><code>0</code></td>
<td>仅限回复，类型:<a href="qmetatype.html#Type-enum">QMetaType::Int</a>)(无默认值) 表示从HTTP服务器收到的HTTP状态代码（如200、304、404、401等）。如果连接不是基于HTTP的，这个属性将不会出现。</td>
</tr>
<tr>
<td><code>QNetworkRequest::HttpReasonPhraseAttribute</code></td>
<td><code>1</code></td>
<td>仅限回，类型：<a href="qmetatype.html#Type-enum">QMetaType::QByteArray</a> (无默认值) 表示从HTTP服务器收到的HTTP原因短语（如 “OK”、”发现”、”未发现”、”拒绝访问 “等），这是状态代码（见上文）的人类可读表示。如果连接不是基于HTTP的，这个属性将不会出现。</td>
</tr>
<tr>
<td><code>QNetworkRequest::RedirectionTargetAttribute</code></td>
<td><code>2</code></td>
<td>仅限回复，类型:<a href="qmetatype.html#Type-enum">QMetaType::QUrl</a> (无默认值) 如果存在，表明服务器正在将请求重定向到一个不同的URL。网络访问API默认遵循重定向，但如果<a href="#RedirectPolicy-enum">QNetworkRequest::ManualRedirectPolicy</a>被启用，并且重定向没有在redirected()中处理，那么这个属性将出现。返回的URL可能是相对的。使用<a href="qurl.html#resolved">QUrl::resolved</a>()来创建一个绝对的URL出来。</td>
</tr>
<tr>
<td><code>QNetworkRequest::ConnectionEncryptedAttribute</code></td>
<td><code>3</code></td>
<td>仅限回复，类型:<a href="qmetatype.html#Type-enum">QMetaType::Bool</a> (默认: false) 表示数据是否通过加密（安全）连接获得。</td>
</tr>
<tr>
<td><code>QNetworkRequest::CacheLoadControlAttribute</code></td>
<td><code>4</code></td>
<td>只请求，类型:<a href="qmetatype.html#Type-enum">QMetaType::Int</a> (默认。<a href="#CacheLoadControl-enum">QNetworkRequest::PreferNetwork</a>) 控制应该如何访问缓存。可能的值是<a href="#CacheLoadControl-enum">QNetworkRequest::CacheLoadControl</a>中的那些。请注意，默认的 <a href="qnetworkaccessmanager.html">QNetworkAccessManager</a> 实现不支持缓存。然而，这个属性可以被某些后端用来修改他们的请求（例如，用于缓存代理）。</td>
</tr>
<tr>
<td><code>QNetworkRequest::CacheSaveControlAttribute</code></td>
<td><code>5</code></td>
<td>只请求，类型:<a href="qmetatype.html#Type-enum">QMetaType::Bool</a> (默认: true) 控制是否应将获得的数据保存到缓存中供将来使用。如果值为false，获得的数据将不会被自动缓存。如果为true，数据可以被缓存，只要它是可缓存的（什么是可缓存的取决于使用的协议）。</td>
</tr>
<tr>
<td><code>QNetworkRequest::SourceIsFromCacheAttribute</code></td>
<td><code>6</code></td>
<td>仅限回复，类型:<a href="qmetatype.html#Type-enum">QMetaType::Bool</a> (默认: false) 表示数据是否从缓存中获取。</td>
</tr>
<tr>
<td><code>QNetworkRequest::DoNotBufferUploadDataAttribute</code></td>
<td><code>7</code></td>
<td>仅请求，类型:<a href="qmetatype.html#Type-enum">QMetaType::Bool</a> (默认：false) 指示<a href="qnetworkaccessmanager.html">QNetworkAccessManager</a>代码是否允许对上传数据进行缓冲，例如在做HTTP POST时。当使用这个标志与顺序上传数据时，<a href="#KnownHeaders-enum">ContentLengthHeader</a>头必须被设置。<code>QNetworkRequest::HttpPipeliningAllowedAttribute</code>。</td>
</tr>
<tr>
<td></td>
<td><code>8</code></td>
<td>仅请求，类型：<a href="qmetatype.html#Type-enum">QMetaType::Bool</a> (默认: false) 表示<a href="qnetworkaccessmanager.html">QNetworkAccessManager</a>代码是否允许在此请求中使用HTTP管道。</td>
</tr>
<tr>
<td><code>QNetworkRequest::HttpPipeliningWasUsedAttribute</code></td>
<td><code>9</code></td>
<td>仅限回复，类型：<a href="qmetatype.html#Type-enum">QMetaType::Bool</a> 表示接收此回复时是否使用了HTTP管道。</td>
</tr>
<tr>
<td><code>QNetworkRequest::CustomVerbAttribute</code></td>
<td><code>10</code></td>
<td>仅限请求，类型:<a href="qmetatype.html#Type-enum">QMetaType::QByteArray</a> 保存要发送的自定义HTTP动词的值（注定要使用GET、POST、PUT和DELETE以外的其他动词）。这个动词在调用<a href="qnetworkaccessmanager.html#sendCustomRequest">QNetworkAccessManager::sendCustomRequest</a>()时被设置。</td>
</tr>
<tr>
<td><code>QNetworkRequest::CookieLoadControlAttribute</code></td>
<td><code>11</code></td>
<td>仅限请求，类型:<a href="qmetatype.html#Type-enum">QMetaType::Int</a> (默认。<a href="#LoadControl-enum">QNetworkRequest::Automatic</a>) 表示是否在请求中发送 “Cookie “头文件。当创建一个跨源的XMLHttpRequest时，这个属性被Qt WebKit设置为false，其中withCredentials没有被创建该请求的Javascript明确设置为true。更多信息见<a target="_blank" rel="noopener" href="http://www.w3.org/TR/XMLHttpRequest2/#credentials-flag">here</a>。(这个值在4.7中被引入。)</td>
</tr>
<tr>
<td><code>QNetworkRequest::CookieSaveControlAttribute</code></td>
<td><code>13</code></td>
<td>仅限请求，类型：<a href="qmetatype.html#Type-enum">QMetaType::Int</a> (默认。<a href="#LoadControl-enum">QNetworkRequest::Automatic</a>) 表示是否要保存从服务器收到的回复请求的 “Cookie “头信息。当创建一个跨源的XMLHttpRequest时，这个属性被Qt WebKit设置为false，其中withCredentials没有被创建该请求的Javascript明确设置为true。更多信息见<a target="_blank" rel="noopener" href="http://www.w3.org/TR/XMLHttpRequest2/#credentials-flag">here</a>。(这个值在4.7中被引入。)</td>
</tr>
<tr>
<td><code>QNetworkRequest::AuthenticationReuseAttribute</code></td>
<td><code>12</code></td>
<td>仅限请求，类型：<a href="qmetatype.html#Type-enum">QMetaType::Int</a> (默认。<a href="#LoadControl-enum">QNetworkRequest::Automatic</a>) 表示是否在请求中使用缓存的授权凭证，如果有的话。如果这个属性被设置为<a href="#LoadControl-enum">QNetworkRequest::Manual</a>，并且认证机制是 “Basic “或 “Digest”，Qt将不会发送一个 “Authorization “的HTTP头，其中可能有任何关于请求的URL的缓存凭证。当创建一个跨源XMLHttpRequest时，这个属性被Qt WebKit设置为<a href="#LoadControl-enum">QNetworkRequest::Manual</a>，其中withCredentials没有被创建该请求的Javascript明确设置为true。更多信息见<a target="_blank" rel="noopener" href="http://www.w3.org/TR/XMLHttpRequest2/#credentials-flag">here</a>。(这个值在4.7中被引入。)</td>
</tr>
<tr>
<td><code>QNetworkRequest::BackgroundRequestAttribute</code></td>
<td><code>17</code></td>
<td>类型:<a href="qmetatype.html#Type-enum">QMetaType::Bool</a> (默认：false) 表示这是一个后台传输，而不是一个用户发起的传输。根据平台的不同，后台传输可能受制于不同的政策。</td>
</tr>
<tr>
<td><code>QNetworkRequest::Http2AllowedAttribute</code></td>
<td><code>19</code></td>
<td>仅请求，类型:<a href="qmetatype.html#Type-enum">QMetaType::Bool</a> (默认：true) 表示<a href="qnetworkaccessmanager.html">QNetworkAccessManager</a>代码是否允许在此请求中使用HTTP/2。这适用于SSL请求或 “明文 “HTTP/2。</td>
</tr>
<tr>
<td><code>QNetworkRequest::Http2WasUsedAttribute</code></td>
<td><code>20</code></td>
<td>仅限回复，类型：<a href="qmetatype.html#Type-enum">QMetaType::Bool</a> (默认: false) 表示是否使用HTTP/2来接收这个回复。(这个值在5.9中引入)。</td>
</tr>
<tr>
<td><code>QNetworkRequest::EmitAllUploadProgressSignalsAttribute</code></td>
<td><code>18</code></td>
<td>只请求，类型：<a href="qmetatype.html#Type-enum">QMetaType::Bool</a> (默认: false) 表示是否应该发射所有的上传信号。默认情况下，uploadProgress信号只以100毫秒的间隔发射。(这个值在5.5中引入）。</td>
</tr>
<tr>
<td><code>QNetworkRequest::OriginalContentLengthAttribute</code></td>
<td><code>21</code></td>
<td>仅限回复，类型:<a href="qmetatype.html#Type-enum">QMetaType::Int</a> 在数据被压缩和请求被标记为自动解压时，保留原始的content-length属性，并从头文件中删除。(这个值在5.9中引入）。</td>
</tr>
<tr>
<td><code>QNetworkRequest::RedirectPolicyAttribute</code></td>
<td><code>22</code></td>
<td>只请求，类型:<a href="qmetatype.html#Type-enum">QMetaType::Int</a>，应该是<a href="#RedirectPolicy-enum">QNetworkRequest::RedirectPolicy</a>中的一个值（默认值。<a href="#RedirectPolicy-enum">NoLessSafeRedirectPolicy</a>）。(这个值在5.9中引入）。</td>
</tr>
<tr>
<td><code>QNetworkRequest::Http2DirectAttribute</code></td>
<td><code>23</code></td>
<td>只请求，类型:<a href="qmetatype.html#Type-enum">QMetaType::Bool</a> (默认：false) 如果设置，这个属性将强制<a href="qnetworkaccessmanager.html">QNetworkAccessManager</a>使用HTTP/2协议，而无需进行最初的HTTP/2协议协商。使用这个属性意味着事先知道一个特定的服务器支持HTTP/2。该属性适用于SSL或 “明文 “HTTP/2。如果一个服务器不支持HTTP/2，当HTTP/2直接被指定时，<a href="qnetworkaccessmanager.html">QNetworkAccessManager</a>就会放弃，而不会试图退回到HTTP/1.1。如果同时设置了Http2AAllowedAttribute和Http2DirectAttribute，则Http2DirectAttribute优先。(这个值是在5.11中引入的）。</td>
</tr>
<tr>
<td><code>QNetworkRequest::AutoDeleteReplyOnFinishAttribute</code></td>
<td><code>25</code></td>
<td>只请求，类型:<a href="qmetatype.html#Type-enum">QMetaType::Bool</a> (默认: false) 如果设置，这个属性将使<a href="qnetworkaccessmanager.html">QNetworkAccessManager</a>在发出 “完成 “后删除<a href="qnetworkreply.html">QNetworkReply</a> 。(这个值是在5.14中引入的）。</td>
</tr>
<tr>
<td><code>QNetworkRequest::User</code></td>
<td><code>1000</code></td>
<td>特殊类型。额外的信息可以在QVariants中传递，其类型范围从User到UserMax。网络访问的默认实现将忽略这个范围内的任何请求属性，它不会在回复中产生这个范围内的任何属性。这个范围被保留给<a href="qnetworkaccessmanager.html">QNetworkAccessManager</a>的扩展。</td>
</tr>
<tr>
<td><code>QNetworkRequest::UserMax</code></td>
<td><code>32767</code></td>
<td>特殊类型。见用户。</td>
</tr>
</tbody></table>
<h3><span id="enum-qnetworkrequest-cacheloadcontrol">enum QNetworkRequest::CacheLoadControl</span><a href="#enum-qnetworkrequest-cacheloadcontrol" class="header-anchor">#</a></h3><p>控制<a href="qnetworkaccessmanager.html">QNetworkAccessManager</a>的缓存机制。</p>
<table>
<thead>
<tr>
<th>Constant</th>
<th>Value</th>
<th>Description</th>
</tr>
</thead>
<tbody><tr>
<td><code>QNetworkRequest::AlwaysNetwork</code></td>
<td><code>0</code></td>
<td>总是从网络上加载，不检查缓存是否有有效条目（类似于浏览器的 “重新加载 “功能）；此外，强制中间缓存重新验证。</td>
</tr>
<tr>
<td><code>QNetworkRequest::PreferNetwork</code></td>
<td><code>1</code></td>
<td>默认值；如果缓存条目比网络条目老，则从网络加载。这将永远不会从缓存中返回陈旧的数据，但会重新验证已经变得陈旧的资源。</td>
</tr>
<tr>
<td><code>QNetworkRequest::PreferCache</code></td>
<td><code>2</code></td>
<td>如果有的话从缓存中加载，否则从网络中加载。请注意，这可能会从缓存中返回可能过时的（但不是过期的）项目。</td>
</tr>
<tr>
<td><code>QNetworkRequest::AlwaysCache</code></td>
<td><code>3</code></td>
<td>只从缓存中加载，如果该项目没有被缓存，则表示错误（即离线模式）</td>
</tr>
</tbody></table>
<h3><span id="enum-qnetworkrequest-knownheaders">enum QNetworkRequest::KnownHeaders</span><a href="#enum-qnetworkrequest-knownheaders" class="header-anchor">#</a></h3><p><a href>QNetworkRequest</a>解析的已知头类型的列表。每个已知的头也以原始形式表示，并附有完整的HTTP名称。</p>
<table>
<thead>
<tr>
<th>Constant</th>
<th>Value</th>
<th>Description</th>
</tr>
</thead>
<tbody><tr>
<td><code>QNetworkRequest::ContentDispositionHeader</code></td>
<td><code>6</code></td>
<td>对应于HTTP Content-Disposition头，包含一个包含处置类型（例如，附件）和一个参数（例如，文件名）的字符串。</td>
</tr>
<tr>
<td><code>QNetworkRequest::ContentTypeHeader</code></td>
<td><code>0</code></td>
<td>对应于HTTP Content-Type头，包含一个包含媒体（MIME）类型和任何辅助数据（例如，字符集）的字符串。</td>
</tr>
<tr>
<td><code>QNetworkRequest::ContentLengthHeader</code></td>
<td><code>1</code></td>
<td>对应于HTTP Content-Length头，包含传输数据的字节长度。</td>
</tr>
<tr>
<td><code>QNetworkRequest::LocationHeader</code></td>
<td><code>2</code></td>
<td>对应于HTTP位置标头，包含一个代表数据实际位置的URL，包括重定向情况下的目标URL。</td>
</tr>
<tr>
<td><code>QNetworkRequest::LastModifiedHeader</code></td>
<td><code>3</code></td>
<td>对应于HTTP Last-Modified头，包含一个<a href="qdatetime.html">QDateTime</a>代表内容的最后修改日期。</td>
</tr>
<tr>
<td><code>QNetworkRequest::IfModifiedSinceHeader</code></td>
<td><code>9</code></td>
<td>对应于HTTP的If-Modified-Since头，并包含一个[QDateTime]（qdatetime.html）。它通常被添加到一个<a href>QNetworkRequest</a>中。如果资源自此以后没有改变，服务器应发送一个304（未修改）响应。</td>
</tr>
<tr>
<td><code>QNetworkRequest::ETagHeader</code></td>
<td><code>10</code></td>
<td>对应于HTTP ETag头，包含一个<a href="qstring.html">QString</a>，代表内容的最后修改状态。</td>
</tr>
<tr>
<td><code>QNetworkRequest::IfMatchHeader</code></td>
<td><code>11</code></td>
<td>对应于HTTP If-Match头，包含一个<a href="qstringlist.html">QStringList</a>。它通常被添加到一个<a href>QNetworkRequest</a>中。如果资源不匹配，服务器应发送一个412（前提条件失败）响应。</td>
</tr>
<tr>
<td><code>QNetworkRequest::IfNoneMatchHeader</code></td>
<td><code>12</code></td>
<td>对应于HTTP If-None-Match头，包含一个<a href="qstringlist.html">QStringList</a>。它通常被添加到一个<a href>QNetworkRequest</a>中。如果资源确实匹配，服务器应发送一个304（未修改）响应。</td>
</tr>
<tr>
<td><code>QNetworkRequest::CookieHeader</code></td>
<td><code>4</code></td>
<td>对应于HTTP Cookie头，包含一个<a href="qlist.html">QList</a>&lt;<a href="qnetworkcookie.html">QNetworkCookie</a>&gt;，代表要发回给服务器的cookie。</td>
</tr>
<tr>
<td><code>QNetworkRequest::SetCookieHeader</code></td>
<td><code>5</code></td>
<td>对应于HTTP Set-Cookie头，包含一个<a href="qlist.html">QList</a>&lt;<a href="qnetworkcookie.html">QNetworkCookie</a>&gt;，代表由服务器发送的要存储在本地的cookies。</td>
</tr>
<tr>
<td><code>QNetworkRequest::UserAgentHeader</code></td>
<td><code>7</code></td>
<td>由HTTP客户端发送的User-Agent标头。</td>
</tr>
<tr>
<td><code>QNetworkRequest::ServerHeader</code></td>
<td><code>8</code></td>
<td>由HTTP客户收到的服务器标头。</td>
</tr>
</tbody></table>
<p><strong>See also</strong> <a href="#header">header</a>(), <a href="#setHeader">setHeader</a>(), <a href="#rawHeader">rawHeader</a>(), and <a href="#setRawHeader">setRawHeader</a>().</p>
<h3><span id="enum-qnetworkrequest-loadcontrol">enum QNetworkRequest::LoadControl</span><a href="#enum-qnetworkrequest-loadcontrol" class="header-anchor">#</a></h3><p>表示请求的加载机制的某个方面是否被手动重写，例如被Qt WebKit重写。</p>
<table>
<thead>
<tr>
<th>Constant</th>
<th>Value</th>
<th>Description</th>
</tr>
</thead>
<tbody><tr>
<td><code>QNetworkRequest::Automatic</code></td>
<td><code>0</code></td>
<td>默认值：表示默认行为。</td>
</tr>
<tr>
<td><code>QNetworkRequest::Manual</code></td>
<td><code>1</code></td>
<td>表示行为已被手动重写。</td>
</tr>
</tbody></table>
<h3><span id="enum-qnetworkrequest-priority">enum QNetworkRequest::Priority</span><a href="#enum-qnetworkrequest-priority" class="header-anchor">#</a></h3><p>这个枚举列出了可能的网络请求优先级。</p>
<table>
<thead>
<tr>
<th>Constant</th>
<th>Value</th>
<th>Description</th>
</tr>
</thead>
<tbody><tr>
<td><code>QNetworkRequest::HighPriority</code></td>
<td><code>1</code></td>
<td>高度优先</td>
</tr>
<tr>
<td><code>QNetworkRequest::NormalPriority</code></td>
<td><code>3</code></td>
<td>正常优先级</td>
</tr>
<tr>
<td><code>QNetworkRequest::LowPriority</code></td>
<td><code>5</code></td>
<td>低优先级</td>
</tr>
</tbody></table>
<h3><span id="since-5-9-enum-qnetworkrequest-redirectpolicy"><code>[since 5.9]</code>enum QNetworkRequest::RedirectPolicy</span><a href="#since-5-9-enum-qnetworkrequest-redirectpolicy" class="header-anchor">#</a></h3><p>表示网络访问API是否应该自动跟踪HTTP重定向响应。</p>
<table>
<thead>
<tr>
<th>Constant</th>
<th>Value</th>
<th>Description</th>
</tr>
</thead>
<tbody><tr>
<td><code>QNetworkRequest::ManualRedirectPolicy</code></td>
<td><code>0</code></td>
<td>不遵循任何重定向。</td>
</tr>
<tr>
<td><code>QNetworkRequest::NoLessSafeRedirectPolicy</code></td>
<td><code>1</code></td>
<td>默认值。只允许 “http”-&gt;”http”、”http”-&gt;”https “或 “https”-&gt;”https “重定向。</td>
</tr>
<tr>
<td><code>QNetworkRequest::SameOriginRedirectPolicy</code></td>
<td><code>2</code></td>
<td>要求有相同的协议、主机和端口。注意，<a target="_blank" rel="noopener" href="http://example.com/">http://example.com</a> 和 <a target="_blank" rel="noopener" href="http://example.com/">http://example.com:80</a> 将在此策略下失败（隐式/显式端口被认为是不匹配的）。</td>
</tr>
<tr>
<td><code>QNetworkRequest::UserVerifiedRedirectPolicy</code></td>
<td><code>3</code></td>
<td>客户端通过处理redirected()信号来决定是否跟随每个重定向，在<a href="qnetworkreply.html">QNetworkReply</a>对象上发出redirectAllowed()以允许重定向，或者中止/完成它以拒绝重定向。例如，这可以用来询问用户是否接受重定向，或者根据一些应用程序的特定配置来决定。</td>
</tr>
</tbody></table>
<p>这个枚举是在Qt 5.9中引入或修改的。</p>
<h3><span id="since-5-15-enum-qnetworkrequest-transfertimeoutconstant"><code>[since 5.15]</code>enum QNetworkRequest::TransferTimeoutConstant</span><a href="#since-5-15-enum-qnetworkrequest-transfertimeoutconstant" class="header-anchor">#</a></h3><p>一个常数，可用于启用具有预设值的传输超时。</p>
<table>
<thead>
<tr>
<th>Constant</th>
<th>Value</th>
<th>Description</th>
</tr>
</thead>
<tbody><tr>
<td><code>QNetworkRequest::DefaultTransferTimeoutConstant</code></td>
<td><code>30000</code></td>
<td>以毫秒为单位的传输超时。在调用setTimeout()时没有参数的情况下使用。</td>
</tr>
</tbody></table>
<p>这个枚举是在Qt 5.15中引入或修改的。</p>
<h2><span id="cheng-yuan-han-shu-wen-dang">成员函数文档</span><a href="#cheng-yuan-han-shu-wen-dang" class="header-anchor">#</a></h2><h3><span id="qnetworkrequest-qnetworkrequest-const-qnetworkrequest-amp-other">QNetworkRequest::QNetworkRequest(const  &amp;<em>other</em>)</span><a href="#qnetworkrequest-qnetworkrequest-const-qnetworkrequest-amp-other" class="header-anchor">#</a></h3><p>创建一个<em>other</em>的副本。</p>
<h3><span id="qnetworkrequest-qnetworkrequest-const-qurl-amp-url">QNetworkRequest::QNetworkRequest(const  &amp;<em>url</em>)</span><a href="#qnetworkrequest-qnetworkrequest-const-qurl-amp-url" class="header-anchor">#</a></h3><p>构建一个QNetworkRequest对象，其<em>url</em>为要请求的URL。</p>
<p><strong>See also</strong> <a href="#url">url</a>() and <a href="#setUrl">setUrl</a>().</p>
<h3><span id="qnetworkrequest-qnetworkrequest">QNetworkRequest::QNetworkRequest()</span><a href="#qnetworkrequest-qnetworkrequest" class="header-anchor">#</a></h3><p>构建一个没有URL请求的QNetworkRequest对象。使用<a href="#setUrl">setUrl</a>()来设置一个。</p>
<p><strong>See also</strong> <a href="#url">url</a>() and <a href="#setUrl">setUrl</a>().</p>
<h3><span id="qnetworkrequest-amp-qnetworkrequest-operator-const-qnetworkrequest-amp-other"> &amp;QNetworkRequest::operator=(const  &amp;<em>other</em>)</span><a href="#qnetworkrequest-amp-qnetworkrequest-operator-const-qnetworkrequest-amp-other" class="header-anchor">#</a></h3><p>创建一个<em>other</em>的副本</p>
<h3><span id="qnetworkrequest-qnetworkrequest">QNetworkRequest::~QNetworkRequest()</span><a href="#qnetworkrequest-qnetworkrequest" class="header-anchor">#</a></h3><p>处置<a href>QNetworkRequest</a>对象。</p>
<h3><span id="qvariant-qnetworkrequest-attribute-qnetworkrequest-attribute-code-const-qvariant-amp-defaultvalue-qvariant-const"> QNetworkRequest::attribute( <em>code</em>, const  &amp;<em>defaultValue</em> = QVariant()) const</span><a href="#qvariant-qnetworkrequest-attribute-qnetworkrequest-attribute-code-const-qvariant-amp-defaultvalue-qvariant-const" class="header-anchor">#</a></h3><p>返回与代码<em>code</em>相关的属性。如果该属性没有被设置，它将返回<em>defaultValue</em>。</p>
<p><strong>注意：</strong>此函数不应用<a href="#Attribute-enum">QNetworkRequest::Attribute</a>中列出的默认值。</p>
<p><strong>See also</strong> <a href="#setAttribute">setAttribute</a>() and <a href="#Attribute-enum">QNetworkRequest::Attribute</a>.</p>
<h3><span id="since-6-2-qint64-qnetworkrequest-decompressedsafetycheckthreshold-const"><code>[since 6.2]</code> QNetworkRequest::decompressedSafetyCheckThreshold() const</span><a href="#since-6-2-qint64-qnetworkrequest-decompressedsafetycheckthreshold-const" class="header-anchor">#</a></h3><p>返回存档炸弹检查的阈值。</p>
<p>如果回复的解压大小小于此值，Qt将简单地解压，而不进一步检查。</p>
<p>这个函数是在Qt 6.2中引入的。</p>
<p><strong>See also</strong> <a href="#setDecompressedSafetyCheckThreshold">setDecompressedSafetyCheckThreshold</a>().</p>
<h3><span id="bool-qnetworkrequest-hasrawheader-const-qbytearray-amp-headername-const">bool QNetworkRequest::hasRawHeader(const  &amp;<em>headerName</em>) const</span><a href="#bool-qnetworkrequest-hasrawheader-const-qbytearray-amp-headername-const" class="header-anchor">#</a></h3><p>如果这个网络请求中存在原始头文件<em>headerName</em>，则返回<code>true</code>。</p>
<p><strong>See also</strong> <a href="#rawHeader">rawHeader</a>() and <a href="#setRawHeader">setRawHeader</a>().</p>
<h3><span id="qvariant-qnetworkrequest-header-qnetworkrequest-knownheaders-header-const"> QNetworkRequest::header( <em>header</em>) const</span><a href="#qvariant-qnetworkrequest-header-qnetworkrequest-knownheaders-header-const" class="header-anchor">#</a></h3><p>如果这个请求中存在已知的网络头信息<em>header</em>，则返回它的值。如果不存在，则返回QVariant()（即，一个无效的变量）。</p>
<p><strong>See also</strong> <a href="#KnownHeaders-enum">KnownHeaders</a>, <a href="#rawHeader">rawHeader</a>(), and <a href="#setHeader">setHeader</a>().</p>
<h3><span id="since-5-14-qhttp2configuration-qnetworkrequest-http2configuration-const"><code>[since 5.14]</code> QNetworkRequest::http2Configuration() const</span><a href="#since-5-14-qhttp2configuration-qnetworkrequest-http2configuration-const" class="header-anchor">#</a></h3><p>返回<a href="qnetworkaccessmanager.html">QNetworkAccessManager</a>当前用于此请求和其底层HTTP/2连接的参数。这要么是一个应用程序先前设置的配置，要么是一个默认配置。</p>
<p><a href="qnetworkaccessmanager.html">QNetworkAccessManager</a>正在使用的默认值是。</p>
<ul>
<li>连接级流量控制的窗口大小是2147483647个字节</li>
<li>流级流量控制的窗口大小是21474836个八位字节</li>
<li>最大的帧大小是16384</li>
</ul>
<p>默认情况下，服务器推送被禁用，Huffman压缩和字符串索引被启用。</p>
<p>这个函数是在Qt 5.14中引入的。</p>
<p><strong>See also</strong> <a href="#setHttp2Configuration">setHttp2Configuration</a>.</p>
<h3><span id="since-5-6-int-qnetworkrequest-maximumredirectsallowed-const"><code>[since 5.6]</code>int QNetworkRequest::maximumRedirectsAllowed() const</span><a href="#since-5-6-int-qnetworkrequest-maximumredirectsallowed-const" class="header-anchor">#</a></h3><p>返回这个请求允许遵循的最大重定向数量。</p>
<p>这个函数是在Qt 5.6中引入的。</p>
<p><strong>See also</strong> <a href="#setMaximumRedirectsAllowed">setMaximumRedirectsAllowed</a>().</p>
<h3><span id="qobject-qnetworkrequest-originatingobject-const"> *QNetworkRequest::originatingObject() const</span><a href="#qobject-qnetworkrequest-originatingobject-const" class="header-anchor">#</a></h3><p>返回发起此网络请求的对象的引用；如果没有设置或对象已被销毁，则返回<code>nullptr</code>。</p>
<p><strong>See also</strong> <a href="#setOriginatingObject">setOriginatingObject</a>().</p>
<h3><span id="since-5-13-qstring-qnetworkrequest-peerverifyname-const"><code>[since 5.13]</code> QNetworkRequest::peerVerifyName() const</span><a href="#since-5-13-qstring-qnetworkrequest-peerverifyname-const" class="header-anchor">#</a></h3><p>返回为证书验证设置的主机名，如<a href="#setPeerVerifyName">setPeerVerifyName</a>所设置。默认情况下，这将返回一个空字符串。</p>
<p>这个函数是在Qt 5.13中引入的。</p>
<p><strong>See also</strong> <a href="#setPeerVerifyName">setPeerVerifyName</a>.</p>
<h3><span id="qnetworkrequest-priority-qnetworkrequest-priority-const"> QNetworkRequest::priority() const</span><a href="#qnetworkrequest-priority-qnetworkrequest-priority-const" class="header-anchor">#</a></h3><p>返回这个请求的优先级。</p>
<p><strong>See also</strong> <a href="#setPriority">setPriority</a>().</p>
<h3><span id="qbytearray-qnetworkrequest-rawheader-const-qbytearray-amp-headername-const"> QNetworkRequest::rawHeader(const  &amp;<em>headerName</em>) const</span><a href="#qbytearray-qnetworkrequest-rawheader-const-qbytearray-amp-headername-const" class="header-anchor">#</a></h3><p>返回头文件<em>headerName</em>的原始形式。如果没有这样的头信息，将返回一个空的<a href="qbytearray.html">QByteArray</a>，这可能与一个存在但没有内容的头信息无法区分（使用<a href="#hasRawHeader">hasRawHeader</a>()来找出头信息是否存在）。</p>
<p>原始头信息可以用<a href="#setRawHeader">setRawHeader</a>()或<a href="#setHeader">setHeader</a>()来设置。</p>
<p><strong>See also</strong> <a href="#header">header</a>() and <a href="#setRawHeader">setRawHeader</a>().</p>
<h3><span id="qlist-lt-qbytearray-gt-qnetworkrequest-rawheaderlist-const">&lt;&gt; QNetworkRequest::rawHeaderList() const</span><a href="#qlist-lt-qbytearray-gt-qnetworkrequest-rawheaderlist-const" class="header-anchor">#</a></h3><p>返回该网络请求中设置的所有原始头信息的列表。该列表是按照头信息被设置的顺序排列的。</p>
<p><strong>See also</strong> <a href="#hasRawHeader">hasRawHeader</a>() and <a href="#rawHeader">rawHeader</a>().</p>
<h3><span id="void-qnetworkrequest-setattribute-qnetworkrequest-attribute-code-const-qvariant-amp-value">void QNetworkRequest::setAttribute( <em>code</em>, const  &amp;<em>value</em>)</span><a href="#void-qnetworkrequest-setattribute-qnetworkrequest-attribute-code-const-qvariant-amp-value" class="header-anchor">#</a></h3><p>将与代码<em>code</em>相关的属性设置为值<em>value</em>。如果该属性已经被设置，那么之前的值将被丢弃。在特殊情况下，如果<em>value</em>是一个无效的<a href="qvariant.html">QVariant</a>，该属性将被取消设置。</p>
<p><strong>See also</strong> <a href="#attribute">attribute</a>() and <a href="#Attribute-enum">QNetworkRequest::Attribute</a>.</p>
<h3><span id="since-6-2-void-qnetworkrequest-setdecompressedsafetycheckthreshold-qint64-threshold"><code>[since 6.2]</code>void QNetworkRequest::setDecompressedSafetyCheckThreshold( <em>threshold</em>)</span><a href="#since-6-2-void-qnetworkrequest-setdecompressedsafetycheckthreshold-qint64-threshold" class="header-anchor">#</a></h3><p>设置存档炸弹检查的<em>threshold</em>。</p>
<p>一些支持的压缩算法可以在一个微小的压缩文件中，编码出一个巨大的解压缩文件。这只有在解压后的内容极其单调的情况下才有可能，而真实的文件很少会被真诚地传输：行使这种疯狂的高压缩比的文件通常是缓冲区溢出攻击的有效载荷，或拒绝服务（通过使用过多的内存）攻击。因此，解压成巨大尺寸的文件，特别是从微小的压缩形式，最好作为可疑的恶意软件拒绝。</p>
<p>如果一个回复的解压大小大于这个阈值（默认为10 MiB，即10 * 1024 * 1024），Qt将检查压缩率：如果这个压缩率大得不合理（GZip和Deflate为40:1，Brotli和ZStandard为100:1），这个回复将被视为一个错误。将阈值设置为 “1 “可以禁止这种检查。</p>
<p>这个函数是在Qt 6.2中引入的。</p>
<p><strong>See also</strong> <a href="#decompressedSafetyCheckThreshold">decompressedSafetyCheckThreshold</a>().</p>
<h3><span id="void-qnetworkrequest-setheader-qnetworkrequest-knownheaders-header-const-qvariant-amp-value">void QNetworkRequest::setHeader( <em>header</em>, const  &amp;<em>value</em>)</span><a href="#void-qnetworkrequest-setheader-qnetworkrequest-knownheaders-header-const-qvariant-amp-value" class="header-anchor">#</a></h3><p>将已知的头信息<em>header</em>的值设置为<em>value</em>，覆盖之前设置的任何头信息。这个操作也设置了相应的原始HTTP头。</p>
<p><strong>See also</strong> <a href="#KnownHeaders-enum">KnownHeaders</a>, <a href="#setRawHeader">setRawHeader</a>(), and <a href="#header">header</a>().</p>
<h3><span id="since-5-14-void-qnetworkrequest-sethttp2configuration-const-qhttp2configuration-amp-configuration"><code>[since 5.14]</code>void QNetworkRequest::setHttp2Configuration(const  &amp;<em>configuration</em>)</span><a href="#since-5-14-void-qnetworkrequest-sethttp2configuration-const-qhttp2configuration-amp-configuration" class="header-anchor">#</a></h3><p>从<em>configuration</em>设置请求的HTTP/2参数。</p>
<p><strong>注意：</strong>配置必须在发出请求之前设置。</p>
<p><strong>注意:</strong> HTTP/2在一个单一的HTTP/2连接中复用了几个流。这意味着<a href="qnetworkaccessmanager.html">QNetworkAccessManager</a>将使用从一系列发送到同一主机的请求中找到的第一个配置。</p>
<p>这个函数是在Qt 5.14中引入的。</p>
<p><strong>See also</strong> <a href="#http2Configuration">http2Configuration</a>, <a href="qnetworkaccessmanager.html">QNetworkAccessManager</a>, and <a href="qhttp2configuration.html">QHttp2Configuration</a>.</p>
<h3><span id="since-5-6-void-qnetworkrequest-setmaximumredirectsallowed-int-maxredirectsallowed"><code>[since 5.6]</code>void QNetworkRequest::setMaximumRedirectsAllowed(int <em>maxRedirectsAllowed</em>)</span><a href="#since-5-6-void-qnetworkrequest-setmaximumredirectsallowed-int-maxredirectsallowed" class="header-anchor">#</a></h3><p>将此请求允许遵循的最大重定向数量设置为<em>maxRedirectsAllowed</em>。</p>
<p>这个函数是在Qt 5.6中引入的。</p>
<p><strong>See also</strong> <a href="#maximumRedirectsAllowed">maximumRedirectsAllowed</a>().</p>
<h3><span id="void-qnetworkrequest-setoriginatingobject-qobject-object">void QNetworkRequest::setOriginatingObject( *<em>object</em>)</span><a href="#void-qnetworkrequest-setoriginatingobject-qobject-object" class="header-anchor">#</a></h3><p>允许设置一个对发起请求的object*的引用。</p>
<p>例如，Qt WebKit将起源对象设置为发起请求的QWebFrame。</p>
<p><strong>See also</strong> <a href="#originatingObject">originatingObject</a>().</p>
<h3><span id="since-5-13-void-qnetworkrequest-setpeerverifyname-const-qstring-amp-peername"><code>[since 5.13]</code>void QNetworkRequest::setPeerVerifyName(const  &amp;<em>peerName</em>)</span><a href="#since-5-13-void-qnetworkrequest-setpeerverifyname-const-qstring-amp-peername" class="header-anchor">#</a></h3><p>设置<em>peerName</em>作为证书验证的主机名，而不是用于TCP连接的主机名。</p>
<p>这个函数是在Qt 5.13中引入的。</p>
<p><strong>See also</strong> <a href="#peerVerifyName">peerVerifyName</a>.</p>
<h3><span id="void-qnetworkrequest-setpriority-qnetworkrequest-priority-priority">void QNetworkRequest::setPriority( <em>priority</em>)</span><a href="#void-qnetworkrequest-setpriority-qnetworkrequest-priority-priority" class="header-anchor">#</a></h3><p>将此请求的优先级设置为<em>priority</em>。</p>
<p><strong>注意：</strong>优先级*只是对网络访问管理器的一个提示。它可以使用它，也可以不使用。目前，它被用于HTTP，以决定哪个请求应该被首先发送到服务器上。</p>
<p><strong>See also</strong> <a href="#priority">priority</a>().</p>
<h3><span id="void-qnetworkrequest-setrawheader-const-qbytearray-amp-headername-const-qbytearray-amp-headervalue">void QNetworkRequest::setRawHeader(const  &amp;<em>headerName</em>, const  &amp;<em>headerValue</em>)</span><a href="#void-qnetworkrequest-setrawheader-const-qbytearray-amp-headername-const-qbytearray-amp-headervalue" class="header-anchor">#</a></h3><p>设置头信息<em>headerName</em>为<em>headerValue</em>值。如果<em>headerName</em>对应于一个已知的头（见<a href="#KnownHeaders-enum">QNetworkRequest::KnownHeaders</a>），原始格式将被解析，相应的 “熟 “头也将被设置。</p>
<p>比如说:</p>
<div class="code-wrapper"><pre><code class="hljs c++">request.<span class="hljs-built_in">setRawHeader</span>(<span class="hljs-built_in">QByteArray</span>(<span class="hljs-string">"Last-Modified"</span>), <span class="hljs-built_in">QByteArray</span>(<span class="hljs-string">"Sun, 06 Nov 1994 08:49:37 GMT"</span>));</code></pre></div>

<p>也将设置已知头信息<a href="#KnownHeaders-enum">LastModifiedHeader</a>为解析日期的<a href="qdatetime.html">QDateTime</a>对象。</p>
<p><strong>注意：</strong>两次设置相同的头信息会覆盖之前的设置。为了完成多个同名HTTP头的行为，你应该把两个值连接起来，用逗号（”,”）分开，然后设置一个单一的原始头。</p>
<p><strong>See also</strong> <a href="#KnownHeaders-enum">KnownHeaders</a>, <a href="#setHeader">setHeader</a>(), <a href="#hasRawHeader">hasRawHeader</a>(), and <a href="#rawHeader">rawHeader</a>().</p>
<h3><span id="void-qnetworkrequest-setsslconfiguration-const-qsslconfiguration-amp-config">void QNetworkRequest::setSslConfiguration(const  &amp;<em>config</em>)</span><a href="#void-qnetworkrequest-setsslconfiguration-const-qsslconfiguration-amp-config" class="header-anchor">#</a></h3><p>设置该网络请求的SSL配置为<em>config</em>。适用的设置是私钥、本地证书、SSL协议（SSLv2、SSLv3、TLSv1.0，如适用）、CA证书和SSL后端允许使用的密码。</p>
<p><strong>See also</strong> <a href="#sslConfiguration">sslConfiguration</a>() and <a href="qsslconfiguration.html#defaultConfiguration">QSslConfiguration::defaultConfiguration</a>().</p>
<h3><span id="since-5-15-void-qnetworkrequest-settransfertimeout-int-timeout-defaulttransfertimeoutconstant"><code>[since 5.15]</code>void QNetworkRequest::setTransferTimeout(int <em>timeout</em> = DefaultTransferTimeoutConstant)</span><a href="#since-5-15-void-qnetworkrequest-settransfertimeout-int-timeout-defaulttransfertimeoutconstant" class="header-anchor">#</a></h3><p>设置<em>timeout</em>作为传输超时，单位是毫秒。</p>
<p>如果在超时前没有传输任何字节，传输将被终止。零意味着不设置定时器。如果没有提供参数，超时是[QNetworkRequest::DefaultTransferTimeoutConstant]（#TransferTimeoutConstant-enum）。如果这个函数没有被调用，超时就会被禁用，其值为零。</p>
<p>这个函数是在Qt 5.15中引入的。</p>
<p><strong>See also</strong> <a href="#transferTimeout">transferTimeout</a>.</p>
<h3><span id="void-qnetworkrequest-seturl-const-qurl-amp-url">void QNetworkRequest::setUrl(const  &amp;<em>url</em>)</span><a href="#void-qnetworkrequest-seturl-const-qurl-amp-url" class="header-anchor">#</a></h3><p>设置此网络请求引用的URL为<em>url</em>。</p>
<p><strong>See also</strong> <a href="#url">url</a>().</p>
<h3><span id="qsslconfiguration-qnetworkrequest-sslconfiguration-const"> QNetworkRequest::sslConfiguration() const</span><a href="#qsslconfiguration-qnetworkrequest-sslconfiguration-const" class="header-anchor">#</a></h3><p>返回这个网络请求的SSL配置。默认情况下，这与<a href="qsslconfiguration.html#defaultConfiguration">QSslConfiguration::defaultConfiguration</a>()相同。</p>
<p><strong>See also</strong> <a href="#setSslConfiguration">setSslConfiguration</a>() and <a href="qsslconfiguration.html#defaultConfiguration">QSslConfiguration::defaultConfiguration</a>().</p>
<h3><span id="since-5-0-void-qnetworkrequest-swap-qnetworkrequest-amp-other"><code>[since 5.0]</code>void QNetworkRequest::swap( &amp;<em>other</em>)</span><a href="#since-5-0-void-qnetworkrequest-swap-qnetworkrequest-amp-other" class="header-anchor">#</a></h3><p>将这个网络请求与<em>other</em>交换。这个函数非常快，而且从不失败。</p>
<p>这个函数是在Qt 5.0中引入的。</p>
<h3><span id="since-5-15-int-qnetworkrequest-transfertimeout-const"><code>[since 5.15]</code>int QNetworkRequest::transferTimeout() const</span><a href="#since-5-15-int-qnetworkrequest-transfertimeout-const" class="header-anchor">#</a></h3><p>返回用于传输的超时，单位是毫秒。</p>
<p>如果<a href="#setTransferTimeout">setTransferTimeout</a>没有被调用，这个超时是零，这意味着超时没有被使用。</p>
<p>这个函数是在Qt 5.15中引入的。</p>
<p><strong>See also</strong> <a href="#setTransferTimeout">setTransferTimeout</a>.</p>
<h3><span id="qurl-qnetworkrequest-url-const"> QNetworkRequest::url() const</span><a href="#qurl-qnetworkrequest-url-const" class="header-anchor">#</a></h3><p>返回这个网络请求所指的URL。</p>
<p><strong>See also</strong> <a href="#setUrl">setUrl</a>().</p>
<h3><span id="bool-qnetworkrequest-operator-const-qnetworkrequest-amp-other-const">bool QNetworkRequest::operator!=(const  &amp;<em>other</em>) const</span><a href="#bool-qnetworkrequest-operator-const-qnetworkrequest-amp-other-const" class="header-anchor">#</a></h3><p>如果这个对象与<em>other</em>不相同，则返回<code>false</code>。</p>
<p><strong>See also</strong> <a href="#operator-eq-eq">operator==</a>().</p>
<h3><span id="bool-qnetworkrequest-operator-const-qnetworkrequest-amp-other-const">bool QNetworkRequest::operator==(const  &amp;<em>other</em>) const</span><a href="#bool-qnetworkrequest-operator-const-qnetworkrequest-amp-other-const" class="header-anchor">#</a></h3><p>如果此对象与<em>other</em>相同，则返回<code>true</code>（即，如果它们有相同的URL、相同的头文件和相同的元数据设置）。</p>
<p><strong>See also</strong> <a href="#operator-not-eq">operator!=</a>().</p>

            </div>
            <hr>
            <div>
              <div class="post-metas mb-3">
                
                
                  <div class="post-meta">
                    <i class="iconfont icon-tags"></i>
                    
                      <a class="hover-with-bg" href="/tags/N/">N</a>
                    
                  </div>
                
              </div>
              
                <p class="note note-warning">
                  
                    本博客所有文章除特别声明外，均采用 <a target="_blank" href="https://creativecommons.org/licenses/by-sa/4.0/deed.zh" rel="nofollow noopener noopener">CC BY-SA 4.0 协议</a> ，转载请注明出处！
                  
                </p>
              
              
                <div class="post-prevnext">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/2022/03/02/QtDocumentCN/Src/N/QNetworkReply/QNetworkReply/">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">QNetworkReply类</span>
                        <span class="visible-mobile">上一篇</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2022/03/02/QtDocumentCN/Src/L/QLibrary/QLibrary/">
                        <span class="hidden-mobile">QLibrary类</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
              <!-- Comments -->
              <article class="comments" id="comments" lazyload>
                
                  
                
                
  <div id="lv-container" data-id="city" data-uid="MTAyMC81NTMzMi8zMTc5OQ==">
    <script type="text/javascript">
      Fluid.utils.loadComments('#lv-container', function() {
        Fluid.utils.createScript('https://cdn-city.livere.com/js/embed.dist.js');
      });
    </script>
    <noscript>Please enable JavaScript to view the comments</noscript>
  </div>


              </article>
            
          </article>
        </div>
      </div>
    </div>
    
      <div class="d-none d-lg-block col-lg-2 toc-container" id="toc-ctn">
        <div id="toc">
  <p class="toc-header"><i class="iconfont icon-list"></i>&nbsp;目录</p>
  <div class="toc-body" id="toc-body"></div>
</div>

      </div>
    
  </div>
</div>

<!-- Custom -->


    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v"
                 for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>
    

    
  </main>

  <footer class="text-center mt-5 py-3">
  <div class="footer-content">
     <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> 
  </div>
  

  

  
</footer>


  <!-- SCRIPTS -->
  
  <script  src="https://cdn.jsdelivr.net/npm/nprogress@0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/nprogress@0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js" ></script>
<script  src="https://cdn.jsdelivr.net/npm/bootstrap@4/dist/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>

<!-- Plugins -->


  <script  src="/js/local-search.js" ></script>



  
    <script  src="/js/img-lazyload.js" ></script>
  



  



  
    <script  src="https://cdn.jsdelivr.net/npm/tocbot@4/dist/tocbot.min.js" ></script>
  
  
    <script  src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3/dist/jquery.fancybox.min.js" ></script>
  
  
    <script  src="https://cdn.jsdelivr.net/npm/anchor-js@4/anchor.min.js" ></script>
  
  
    <script defer src="https://cdn.jsdelivr.net/npm/clipboard@2/dist/clipboard.min.js" ></script>
  






  <script  src="https://cdn.jsdelivr.net/npm/typed.js@2/lib/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var title = document.getElementById('subtitle').title;
      
        typing(title);
      
    })(window, document);
  </script>















<!-- 主题的启动项 保持在最底部 -->
<script  src="/js/boot.js" ></script>


</body>
</html>
